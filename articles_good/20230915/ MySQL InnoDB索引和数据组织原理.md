
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 概述
InnoDB是MySQL数据库默认的存储引擎之一，其提供了对外键完整性约束、事务支持等诸多功能。而它的高效率和并发能力使得它在一些需要快速处理海量数据的应用场景中占有一席之地。因此，对于InnoDB索引背后的原理及其设计原则尤为重要。本文从一个使用者视角出发，试图通过阅读源码的方式来探究InnoDB索引的工作原理及其优化方法。

## 作者简介

我是王泽锋，目前就职于浙江大学软件学院，主要负责计算机视觉相关算法研究，机器学习方向。我的研究兴趣广泛，包括图像处理、计算机视觉、深度学习等领域。

# 2.基本概念及术语
## 页（Page）
InnoDB是基于聚集索引的存储引擎，表的每个磁盘页（page）都存放的是该表的一行或若干连续行记录。一般来说，每张表都至少有两个页面：第一个是数据字典页（data dictionary page），用于存放表结构信息；第二个是聚集索引树的根页（clustered index root page）。其余的页都是二级索引页（secondary index pages）或堆（heap）页（heap pages）。InnoDB页面大小为默认为16KB。

## 区（Extent）
InnoDB将磁盘上的磁盘块划分成多个区（extent），每个区可以包含多个数据页。区的大小由参数innodb_page_size控制，默认为16KB。当创建一个新的表或索引时，会初始化一个区。

## 数据页和区
InnoDB的数据文件（ibdata1）实际上是一个逻辑概念，实际存在的物理数据文件由以下三部分构成：
-.frm文件：存放表定义信息；
- 数据页：存放表数据；
- 索引页：存放表索引；
其中，数据页和索引页共同组成了数据文件的内容。InnoDB在读取某个数据页时，会将整个区加载到内存，之后再读取指定的数据页。而在写入新的数据时，如果所在区已满，InnoDB会申请一个新的区作为扩展。区的大小由参数innodb_page_size确定，默认为16KB。

## LRU列表
InnoDB采用Least Recently Used（LRU）算法管理缓冲池中的页缓存，即最近最少使用的页面将被优先淘汰。InnoDB维护一个称作LRU列表的数据结构，用于存储所有脏（dirty）页的最新访问时间戳。当发生写入操作时，InnoDB首先根据其对应的LSN（Log Sequence Number）判断其是否可回滚，如果不可回滚，InnoDB则会将脏页加入到LRU列表中。当缓冲池空间不足时，InnoDB则会释放旧的脏页，以保证更多的新页被缓存。

## redo log
Redo日志（redo log）是InnoDB用来恢复InnoDB状态崩溃后，重新构造数据文件和重做修改的一种机制。通过 redo log 可以把用户的事务提交的信息持久化到磁盘，使InnoDB数据库在异常情况下也能正常运行，不会丢失任何已经提交的事务信息。

## undo log
Undo日志（undo log）是InnoDB用来实现事务的回滚机制的一种机制。当一条事务执行失败或者需要回滚时，InnoDB会生成对应的undo日志，这些日志记录着事务所进行的所有修改，当其他事务要回滚时，就可以根据这些日志将之前的状态还原出来。

## 聚集索引
聚集索引（clustered index）就是将数据行按照物理顺序存放在表的物理页上，也叫主键索引。一个表只能有一个聚集索引，不能有多个聚集索引。其特点是在插入新行或者更新已有行时，将按照索引的顺序更新，而不是随机散列。

## 辅助索引
辅助索引（secondary index）是为了提高检索速度的非聚集索引。InnoDB中除了聚集索引外，还可以创建普通索引、唯一索引、全文索引、空间索引等。除了聚集索引外，其他类型的索引都依赖于B+树来实现。

## B+树
B+树是InnoDB和MyISAM索引使用的关键数据结构。它是一个自平衡的多路搜索树，也是MySQL的默认索引类型。InnoDB的索引都是聚簇索引，也就是说索引和数据存放在一起。InnoDB的索引结构以数据页（page）为基本单位，页内数据按列顺序排列。B+树的层次最大为2~3层，树的高度决定了B+树查询的效率。InnoDB使用B+树来构建聚集索引和辅助索引，并且所有的辅助索引都是用聚集索引建立的。

## ICP（索引合并预读）
ICP（索引合并预读）是InnoDB存储引擎的一个性能优化策略。其过程如下：
1. 当一个范围查找请求带有WHERE条件时，InnoDB存储引擎会自动为这个查询建立一个临时索引。该临时索引的列顺序与查询中给出的列顺序相同，但是只包含满足范围条件的记录，而且每条记录的主键值也都会包含在索引中。
2. 如果该临时索引可以覆盖查询涉及的字段，InnoDB会直接利用它来返回查询结果。否则，InnoDB会继续扫描聚集索引。
3. 在第2步中，如果某些索引已经包含了全部符合条件的记录，InnoDB能够立即返回结果。否则，InnoDB将继续扫描其他的索引，直到找到所有符合条件的记录。
4. 根据第3步中的信息，InnoDB会将读取到的索引页的数量统计合并到一个统计信息中，并同时向表描述符中写入该统计信息。下一次相同的范围查找请求可以通过获取这个统计信息，根据索引的选择性进行估算，从而避免读取过多无用的索引页。

# 3.InnoDB索引原理与设计原则
## InnoDB索引类型
InnoDB支持三种类型的索引：
- 聚集索引（clustered index）：这种索引的叶子节点对应于数据行，叶子节点中保存了完整的数据记录。对于InnoDB表，主键索引就是聚集索引。
- 辅助索引（secondary index）：这种索引的叶子节点对应于索引列的值，并且没有对应的数据行。InnoDB的辅助索引是非聚集索引，这意味着它们不是将数据行的物理位置直接保存在索引页上，而是引用其他的页来存储数据。辅助索引的目的是为了帮助InnoDB在查询数据时更快的找到匹配的行。
- 唯一索引（unique index）：这种索引唯一标识表中的每一行，也就是说不允许重复的值。一个表中只能拥有一个唯一索引。

## 索引的选择
索引的选择要综合考虑查询频繁度、查询计划、索引冗余度、索引维护成本、查询性能等因素。

### 查询频繁度
查询频繁度越高，应创建越少的索引。不要过度索引，索引越多，查询响应时间越慢，系统资源消耗也越大。另外，索引失效也会增加系统开销。因此，建议查询频繁度较低的字段不适用索引，如大文本字段、表达式字段等。

### 查询计划
索引的选择可能导致查询优化器选择不同的执行计划。不同执行计划可能会导致查询性能不同，但绝对不会差距太大。因此，索引的选择一定程度上取决于实际生产环境中的查询情况。

### 索引冗余度
索引冗余度越大，系统开销越大。因此，应该尽量降低索引冗余度，尽量让每一行都能命中索引。不要让字段过多地成为组合索引的组成部分，尽量保持单列索引。

### 索引维护成本
索引维护成本越低，系统的吞吐量越高。因此，创建索引应当确保索引定期维护，保持其正确性、最新性。不要在不必要的时间段创建索引。

### 查询性能
索引的性能可能会受到各种因素的影响，例如索引列的分布、索引树的高度、索引列的数据类型等。一般来说，BTree索引可以达到很好的查询性能，因此建议优先考虑使用BTree索引。

## 聚集索引与辅助索引
InnoDB的索引总体上可以分为两类：聚集索引和辅助索引。聚集索引和主键索引的主要区别在于：聚集索引的叶子节点存储数据的同时，也保存了索引列的值，主键索引的叶子节点保存的仅仅是数据的主键值。

对于表的每一行数据，InnoDB都会为每一个索引列生成一个相应的索引槽。而如果索引列是主键索引，那么只有主键索引列的值才会被存放在索引槽里。对于主键索引来说，InnoDB直接将主键值保存在索引页的页面序号(page number)中。而对于普通的聚集索引和辅助索引，InnoDB将索引列的列值和对应的页面序号存放在索引页的页面内。

除了索引列的值和对应的页面序号，InnoDB的索引页还可以存储指向数据行的指针。所以对于每个数据行，其数据记录和索引记录共同占据了索引页。这种数据记录和索引记录相互关联的方式，其实就是“聚集”的概念。这也是为什么InnoDB要求主键索引不能有空值。

## B+树索引结构
InnoDB中的索引都是用B+树实现的，并且B+树的高度一般为2~3层。每一层的节点都包括两个部分：键（key）和指针（pointer）。

### 索引页的格式
索引页存储的是键值和指向下一个索引页的指针。每一页最多可以存放255个键值对，每一个键值对的格式如下：

| 偏移地址 | 长度 | 属性类型 | 属性名称 | 属性值的格式 | 描述 |
| ------ | --- | ---- | ----- | -------- | ---- |
| 0      | 2   | 字节  | 检测标记 | 无符号整数 | 当前页面是否是属于的索引页的最后一页，0表示不是，1表示是 |
| 2      | 6   | 字节 | 下个节点指针 | 变长整数 | 如果当前页面不是最后一页，指向下一页的头部；如果当前页面是最后一页，该位置没有有效数据 |
| 8      | 2   | 字节  | 头部插槽数 | 无符号整数 | 当前页面上的键值对数量，加起来等于255 |
| 10     | 6 + (FIL_PAGE_DATA_END - FIL_PAGE_DATA_START)/16 | 无符号整型数组 | 主键列或其前缀 | 可变长编码整数 | 每一个键值对都包含一个聚集索引列的值和主键的值，或者一个辅助索引列的值，或者一个唯一索引列的值。 |
|...    |... |... |... |... |... |

其中，FIL_PAGE_DATA_START和FIL_PAGE_DATA_END分别代表当前页中的数据区的起始位置和结束位置，FIL_PAGE_SPACE_OR_CHKSUM_SIZE代表校验和大小。KEY_LEN指示当前键值的字节长度。对于聚集索引，这一列的值等于聚集索引列的字节长度，对于辅助索引，这一列的值等于索引列的字节长度，对于唯一索引，这一列的值等于唯一索引列的字节长度。

### B+树节点结构
B+树中的节点存储着子节点的指针和数据。每一个节点都包括三个部分：
- 是否是内部节点（IS_INNTER）：在节点的第一位，位值为0表示当前节点是非内部节点，为1表示当前节点是内部节点。
- 分支节点个数（N_KEYS）：在当前节点的头部，表示当前节点拥有的子节点的数量。
- 键值对（KEYS/POINTERS）：如果是内部节点，则在此处存储子节点的指针；如果是叶子节点，则在此处存储键值对。

对于叶子节点，其结构如下：

| 偏移地址 | 长度 | 属性类型 | 属性名称 | 属性值的格式 | 描述 |
| ------ | --- | ---- | ----- | -------- | ---- |
| 0      | 2   | 字节 | 文件头 | 无符号整数 | 页面类型，对于索引页固定为1，表示当前页面是叶子节点 |
| 2      | 6   | 字节 | 上个节点指针 | 变长整数 | 如果当前页面不是第一页，指向上一页的头部；如果当前页面是第一页，该位置没有有效数据 |
| 8      | 2   | 字节 | 头部插槽数 | 无符号整数 | 当前页面上的键值对数量，加起来等于255 |
| 10     | 6 + ((INDEX_SIZE + DATA_TRX_ID_LEN + DATA_ROLL_PTR_LEN)*N_COLUMNS) | 有符号整型数组 | 数据列 | 变量长度 | N_COLUMNS表示索引列的数量，每一个键值对都包含一个聚集索引列的值和主键的值，或者一个辅助索引列的值，或者一个唯一索引列的值。 |
|...    |... |... |... |... |... |

其中，INDEX_SIZE表示索引列的长度，通常为4或8，DATA_TRX_ID_LEN和DATA_ROLL_PTR_LEN分别代表事务ID列的长度和回滚指针列的长度。对于数据列，每一个键值对都包含一个索引列的值和主键的值，或者一个辅助索引列的值，或者一个唯一索引列的值。

对于内部节点，其结构如下：

| 偏移地址 | 长度 | 属性类型 | 属性名称 | 属性值的格式 | 描述 |
| ------ | --- | ---- | ----- | -------- | ---- |
| 0      | 2   | 字节 | 文件头 | 无符号整数 | 页面类型，对于索引页固定为2，表示当前页面是内部节点 |
| 2      | 6   | 字节 | 上个节点指针 | 变长整数 | 如果当前页面不是第一页，指向上一页的头部；如果当前页面是第一页，该位置没有有效数据 |
| 8      | 2   | 字节 | 头部插槽数 | 无符号整数 | 当前页面上的键值对数量，加起来等于255 |
| 10     | 6 + INDEX_SIZE*N_COLUMNS | 无符号整型数组 | 节点中存放的指针 | 变长整数 | N_COLUMNS表示索引列的数量，每一个键值对都包含一个子节点的指针。 |
|...    |... |... |... |... |... |

其中，N_COLUMNS表示索引列的数量。每个键值对都包含一个子节点的指针。

## 创建索引
### 语法
```sql
CREATE [UNIQUE] INDEX index_name
    ON table_name (column1, column2,...)
    [USING {BTREE | HASH}]
    [COMMENT'string'];
```
- `index_name`：索引名称。
- `table_name`：表名。
- `column1, column2,...`：索引列。
- `USING {BTREE | HASH}`：指定索引使用的算法，默认使用 BTREE 。
- `COMMENT'string'`：索引备注。

### 操作示例
假设有一个表`test`，需要对`id`、`age`、`name`列创建索引：

```sql
CREATE TABLE test (
  id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
  age INT DEFAULT NULL,
  name VARCHAR(50),
  email VARCHAR(100));

-- 创建id索引
CREATE INDEX idx_id ON test (id);

-- 创建age索引
CREATE INDEX idx_age ON test (age);

-- 创建name索引
CREATE INDEX idx_name ON test (name);
```

这里创建的索引类型默认使用BTree。也可以改为HASH索引：

```sql
-- 使用HASH索引创建id索引
CREATE INDEX idx_hash_id ON test (id) USING HASH;

-- 使用HASH索引创建age索引
CREATE INDEX idx_hash_age ON test (age) USING HASH;

-- 使用HASH索引创建name索引
CREATE INDEX idx_hash_name ON test (name) USING HASH;
```

## 查看索引
### 语法
```sql
SHOW INDEX FROM table_name;
```
### 操作示例
查看表`test`的所有索引：

```sql
SHOW INDEX FROM test;
```

输出结果：

```
+------------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table      | Non_unique | Key_name        | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+------------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| test       |          0 | PRIMARY         |            1 | id          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |
| test       |          1 | idx_age         |            1 | age         | A         |           0 |     NULL | NULL   | YES  | BTREE      |         |               |
| test       |          1 | idx_email       |            1 | email       | A         |           0 |     NULL | NULL   | YES  | BTREE      |         |               |
| test       |          1 | idx_id          |            1 | id          | A         |           0 |     NULL | NULL   | NO   | BTREE      |         |               |
| test       |          1 | idx_name        |            1 | name        | A         |           0 |     NULL | NULL   | YES  | BTREE      |         |               |
+------------+------------+-----------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
```

其中各列的含义如下：
- `Table`：表名。
- `Non_unique`：0 表示唯一索引，1 表示非唯一索引。
- `Key_name`：索引名称。
- `Seq_in_index`：索引列顺序号，值越小越先。
- `Column_name`：索引列名称。
- `Collation`：列的排序规则。
- `Cardinality`：基数，表示索引列的唯一值数量。
- `Sub_part`：列值的子字符串，如果列值是一个字符串。
- `Packed`：NULL ，因为MyISAM表不支持压缩索引。
- `Null`：YES 表示该索引列可以使用NULL值，NO 表示不能使用NULL值。
- `Index_type`：索引类型，通常为 BTREE 或 HASH。
- `Comment`：索引备注。
- `Index_comment`：备用注释。