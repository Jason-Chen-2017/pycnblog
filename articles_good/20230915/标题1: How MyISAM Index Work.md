
作者：禅与计算机程序设计艺术                    

# 1.简介
  

MyISAM是一个基于磁盘的关系型数据库引擎，由原始作者为<NAME>所开发，后被Sun公司收购。它的特点包括快速、可靠、自动维护索引文件。在MySQL 5.5之前的版本中，默认使用的就是InnoDB引擎，但从5.5开始，MyISAM也逐渐得到了越来越多的应用。
本文将对MyISAM的索引结构及其工作原理进行全面剖析。

# 2.基本概念术语说明
## 2.1 数据页（Data Page）
数据页是存储数据的单位。一个数据页大小通常为16KB，最多可以存放65,535个记录。每张表都至少有一个数据页，除非数据量很小，只有一个数据页的情况非常罕见。数据页由数据项和索引节点组成，数据项存放实际的数据记录，而索引节点则存放着索引键值及相应的行指针。

## 2.2 数据字典（Dictionary）
数据字典是一个索引文件，里面保存着所有表名、字段名、各数据页所在位置等信息。每当打开某个表时，都会根据数据字典找到该表对应的索引文件并打开它，然后通过索引文件来定位到对应的数据页。

## 2.3 B-树
B-树是一种多路平衡查找树，具备以下特征：

1. 每个结点至多含有m个子女；
2. 有k个子女的结点必然有 k+1 个关键字；
3. 除了根结点外，每个中间结点至少含有 ceil(m/2) 个关键字。

其中 m 称为 B-树的阶数。一个结点的所有关键字都处于同一条水平线上，并且按照升序排列。

## 2.4 聚集索引与非聚集索引
在InnoDB存储引擎中，表都是用聚集索引建立的，即索引和数据是存放在一起的。但是如果表没有主键或没有唯一索引，InnoDB会选择一个唯一且完整的索引作为聚集索引。其他索引则作为非聚集索引存在。聚集索引对查询的性能影响很大，应该尽可能选择较短的列做主键，同时避免长文本或大的二进制对象。

# 3.核心算法原理和具体操作步骤以及数学公式讲解
## 3.1 MyISAM索引构建过程
### 3.1.1 创建表
首先创建一个新的表test：
```sql
CREATE TABLE test (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    age INT,
    score FLOAT,
    info TEXT
);
```
### 3.1.2 插入数据
向表中插入几条测试数据：
```sql
INSERT INTO test VALUES 
    (NULL, 'Alice', 17, 90.5, 'I am a student'),
    (NULL, 'Bob', 18, 85.2, 'He is my friend'),
    (NULL, 'Charlie', 16, 92.1, 'She is my teacher');
```
### 3.1.3 查看表信息
查看表结构：
```sql
SHOW CREATE TABLE test;
```
```sql
CREATE TABLE `test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `score` float DEFAULT NULL,
  `info` text,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`) USING BTREE,
  KEY `idx_age_score` (`age`,`score`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```
可以看到表中包含四个字段，其中`id`为主键，其它三个为普通字段。普通字段`name`, `age`和`score`均创建了聚集索引`idx_name`，由于`age`字段无符号整型，因此不能做聚集索引，只能选作联合索引。字段`info`没有设定索引，因为长度较长，不宜建索引。

### 3.1.4 检查表结构是否正确
检查表是否有重建索引的必要性：
```sql
ALTER TABLE test ADD INDEX idx_all_cols (name, age, score, info);
```
```sql
mysql> ALTER TABLE test ADD INDEX idx_all_cols (name, age, score, info);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0
```
上面的命令为`test`表添加了一个索引`idx_all_cols`，包括所有的字段。这个索引可以覆盖所有的查询，没有必要再继续创建其他索引。

### 3.1.5 更新表数据
更新数据：
```sql
UPDATE test SET name='Jane' WHERE id=3;
```
### 3.1.6 查询数据
查询某条数据：
```sql
SELECT * FROM test WHERE id=3;
```
```sql
mysql> SELECT * FROM test WHERE id=3;
+----+-------+-----+-------+--------------+
| id | name  | age | score | info         |
+----+-------+-----+-------+--------------+
|  3 | Jane  |   16|  92.1 | She is my t...|
+----+-------+-----+-------+--------------+
1 row in set (0.00 sec)
```
查询某个范围内的数据：
```sql
SELECT * FROM test WHERE age BETWEEN 17 AND 18 ORDER BY age DESC LIMIT 2 OFFSET 1;
```
```sql
mysql> SELECT * FROM test WHERE age BETWEEN 17 AND 18 ORDER BY age DESC LIMIT 2 OFFSET 1;
+----+------+-----+--------+--------------+
| id | name | age | score  | info         |
+----+------+-----+--------+--------------+
|  2 | Bob  |  18 |  85.20| He is my fr...|
|  1 | Alice|  17 |  90.50| I am a stud...|
+----+------+-----+--------+--------------+
2 rows in set (0.00 sec)
```
查询条件包含搜索条件`LIKE`：
```sql
SELECT * FROM test WHERE name LIKE '%li%';
```
```sql
mysql> SELECT * FROM test WHERE name LIKE '%li%';
+----+-------+-----+-------+--------------+
| id | name  | age | score | info         |
+----+-------+-----+-------+--------------+
|  1 | Alice |  17 |  90.5 | I am a stud...|
|  3 | Jane  |  16 |  92.1 | She is my t...|
|  2 | Bob   |  18 |  85.2 | He is my fr...|
+----+-------+-----+-------+--------------+
3 rows in set (0.00 sec)
```
查询条件包含排序条件`ORDER BY`：
```sql
SELECT * FROM test ORDER BY age DESC, score ASC;
```
```sql
mysql> SELECT * FROM test ORDER BY age DESC, score ASC;
+----+-------+-----+-------+--------------+
| id | name  | age | score | info         |
+----+-------+-----+-------+--------------+
|  3 | Jane  |  16 |  92.1 | She is my t...|
|  1 | Alice |  17 |  90.5 | I am a stud...|
|  2 | Bob   |  18 |  85.2 | He is my fr...|
+----+-------+-----+-------+--------------+
3 rows in set (0.00 sec)
```
查询结果分页显示：
```sql
SELECT * FROM test ORDER BY age DESC, score ASC LIMIT 2, 2;
```
```sql
mysql> SELECT * FROM test ORDER BY age DESC, score ASC LIMIT 2, 2;
+----+-------+-----+-------+--------------+
| id | name  | age | score | info         |
+----+-------+-----+-------+--------------+
|  1 | Alice |  17 |  90.5 | I am a stud...|
|  2 | Bob   |  18 |  85.2 | He is my fr...|
+----+-------+-----+-------+--------------+
2 rows in set (0.00 sec)
```
这次的查询结果只返回第3到第5条记录，因为LIMIT语句指定了要返回第2~3条记录。OFFSET设置偏移量为2，所以只返回第3~4条记录。

## 3.2 聚集索引与非聚集索引
聚集索引：聚集索引的叶子节点指向对应的数据记录，因此查询直接定位到相应的数据块。优点是索引和数据保存在同一个地方，查询速度快；缺点是数据修改操作比较麻烦，需要移动数据，降低了性能。

非聚集索引：非聚集索引的叶子节点只存储相应记录的地址，而不是数据本身。数据读取需要先读索引，再根据索引找到对应的数据块，然后再读取数据块中的数据。优点是查询效率高，而且索引占用的空间很小，索引更加紧凑；缺点是插入删除操作比较麻烦，需要更新索引。

InnoDB存储引擎在创建表时，若没有定义主键，则InnoDB会选择一个唯一且完整的索引作为聚集索引。在创建新的数据时，InnoDB先搜索聚集索引，然后在聚集索引的基础上，再根据非聚集索引查找相应的数据。对于查询，若命中索引则快速定位数据，否则遍历聚集索引。

## 3.3 聚集索引的数据结构
InnoDB存储引擎中，表都是用聚集索引建立的，即索引和数据是存放在一起的。而MyISAM存储引擎不同，在表的建立过程中，可以选择不同类型的索引。因此，两种引擎的聚集索引结构略有不同。

### InnoDB聚集索引结构
InnoDB聚集索引的结构其实就是一个B+树，不过每一个叶子节点的最大容量限制为16KB。它的数据结构如下图所示：

InnoDB的聚集索引的叶子节点存放的是完整的数据记录。每张表只能有一个聚集索引。

#### 插入新记录
当向聚集索引的表中插入新记录时，InnoDB执行插入数据的方式如下：
1. 在B+树的最后一个关键词的节点中插入数据记录。
2. 如果这一页已经满了，则申请一个新的页，并将原来的页指向新的页。
3. 如果插入的数据导致页分裂，那么就将中间的页中对应的数据迁移到新页中。
4. 返回插入的索引ID。

#### 删除记录
当从聚集索引的表中删除记录时，InnoDB执行删除数据的方式如下：
1. 从索引对应的B+树中删除数据记录。
2. 当被删除的记录的所在的页上的记录数量变少时，如果这一页上的记录数量小于等于半满状态下的阈值（一般为一半），则将当前页与相邻的两页合并成一个页，以节省磁盘空间。

#### 数据更新
当更新聚集索引的表中某个数据时，InnoDB执行更新数据的方式如下：
1. 根据主键找到对应的页，并将数据更新在内存缓冲区中。
2. 将内存缓冲区中的数据写入磁盘。
3. 如果修改的数据所在页上的数据页已经满了，则申请一个新的页，并将原来的页指向新的页。
4. 如果插入的数据导致页分裂，那么就将中间的页中对应的数据迁移到新页中。

#### 空间效率
InnoDB采用聚集索引结构，聚集索引的叶子节点存放的是完整的数据记录，因此记录占用的空间比堆积在索引节点上的更少。这样可以减少索引的体积，加快检索速度。

### MyISAM聚集索引结构
MyISAM的聚集索引的结构是一棵B+树。每一个叶子节点的最大容量限制为16KB。它的数据结构如下图所示：

#### 插入新记录
当向聚集索引的表中插入新记录时，MyISAM执行插入数据的方式如下：
1. 在B+树的最后一个关键词的节点中插入数据记录。
2. 如果这一页已经满了，则申请一个新的页，并将原来的页指向新的页。
3. 如果插入的数据导致页分裂，那么就将中间的页中对应的数据迁移到新页中。

#### 删除记录
当从聚集索引的表中删除记录时，MyISAM执行删除数据的方式如下：
1. 从索引对应的B+树中删除数据记录。
2. 当被删除的记录的所在的页上的记录数量变少时，如果这一页上的记录数量小于等于半满状态下的阈值（一般为一半），则将当前页与相邻的两页合并成一个页，以节省磁盘空间。

#### 数据更新
当更新聚集索引的表中某个数据时，MyISAM执行更新数据的方式如下：
1. 根据主键找到对应的页，并将数据更新在内存缓冲区中。
2. 将内存缓冲区中的数据写入磁盘。

#### 空间效率
MyISAM的聚集索引结构的特点是索引数据和数据本身存放在一起，因此索引占用的空间很大。而且索引占用的空间与数据量的平方成正比。这使得MyISAM的聚集索引非常浪费空间。

# 4.具体代码实例和解释说明
## 4.1 MySQL源码分析
### 4.1.1 bdb.c文件分析
bdb.c文件实现了Berkeley DB数据库引擎的接口函数，也是MyISAM存储引擎的底层存储模块。主要实现了数据页的读写、索引文件的管理等功能。

### 4.1.2 sql/myisam_index.cc文件分析
sql/myisam_index.cc文件实现了MyISAM存储引擎的索引处理逻辑，主要负责索引的建立、维护和维护相关的数据结构。

## 4.2 MySQL索引设计技巧
## 4.2.1 为什么要建立索引？
索引能够极大地提高检索数据的效率，虽然索引也会增加额外的存储开销，但相对来说还是值得的。

- 提升检索效率。通过索引，数据库管理系统可以仅扫描索引的相关部分来定位需要的数据，从而大大减少了磁盘 IO 次数，提升检索效率。
- 大幅度减少查询时间。由于索引数据结构中存储了索引关键字的值及对应的数据地址，因此当需要访问数据时，只需要访问索引，无需进行全表扫描。也就是说，索引大大减少了服务器的 CPU 和 IO 使用率，进而提升数据库的整体查询性能。
- 添加约束。索引还可以帮助我们制定一些查询上的约束条件，如唯一键、主键、外键等。通过使用索引可以保证数据的一致性。

## 4.2.2 怎样选择索引列？
索引列是指用于检索的列，也就是把数据按一定顺序组织起来形成的数据结构。因此，我们在建索引的时候，需要考虑选择索引列的原则。

- 选择区分度高的列。区分度是指两个相同值的集合中，不同值的个数。一个具有区分度高的列，能够让我们的查询数据更准确。例如，性别、年龄、居住城市这些列，都可以用来建立索引。
- 不要选择无关的列。不要在一个表中存在太多的索引列。选择索引列的目的就是为了提高查询效率，应当尽量选择区分度高的列。同时，选择太多的索引列也会降低查询效率。
- 不要过度索引。索引不是越多越好，索引的数量也需要与数据量成正比，索引列越多，查询效率也会降低。

## 4.2.3 索引失效场景
索引失效的场景有很多，下面是一些常见的索引失效场景：

- LIKE语句前置条件。比如，若列A的索引设置为INDEX A (col1)，那么如果执行查询select * from table where col1 like 'abc%'，则优化器无法利用索引进行优化，仍然需要进行全表扫描。这是因为MySQL优化器目前还无法识别索引中含有“%”的LIKE语句。
- OR条件前置。若对列A和B建立联合索引 INDEX A_B (col1, col2)，那么查询 select * from table where col1 = x or col2 = y 的查询计划可能会出现全表扫描。原因是OR条件无法使用索引作为搜索条件，必须先查询匹配col1的行，之后再查询匹配col2的行。此时即使给A_B索引加速，也无法提升查询效率。
- 用范围查询代替精确匹配。在使用=号查询的时候，如果该列上有索引，会优先使用索引而不是全表扫描。但是如果查询条件带有范围，如>=、<=、>、<，那么优化器便无法利用索引进行优化，仍然需要进行全表扫描。原因是MySQL优化器在生成执行计划时，无法确定查询条件所涉及的列是否有索引。解决方法是将范围查询转化为多个精确匹配查询。
- 字符串类型使用like关键词模糊匹配的场景下。类似上述的LIKE语句、OR条件等，是无法使用索引作为搜索条件的。这种情况下，我们建议改用其他方式，如REGEXP或其他支持索引的函数。