
作者：禅与计算机程序设计艺术                    

# 1.简介
         
 MyBatis 是一款优秀的持久层框架，它可以使得使用 SQL 和 HQL 来操作数据库变得很简单， MyBatis 将原生的jdbc API隐藏在接口中，使开发人员更关注业务逻辑，从而方便地实现数据持久化操作。 MyBatis 中最重要的组件之一就是 MyBatis 的 Mapper XML 配置文件。 Mapper XML 配置文件用来描述 MyBatis 映射器接口及其对应的 SQL、SQL语句的参数类型、返回值类型等信息。通过定义好的 Mapper XML 配置文件后，MyBatis 可以根据配置文件中的配置动态生成完整的 SQL，并将执行结果转换为 Java 对象。本文将详细介绍 MyBatis 中的 Mapper 文件配置、配置原理、配置方法、常见错误、性能优化、扩展阅读等相关内容。
         # 2.核心概念术语
         ## （一）什么是 Mapper
        Mapper（即 mapper）是 MyBatis 中的一个重要组件，主要作用是负责 SQL 映射。它负责将 XML 映射配置文件中的接口和 SQL 映射进行绑定，生成最终需要执行的 SQL 语句，然后将执行结果映射成相应的对象。由于 MyBatis 会在运行时动态生成 SQL 语句，因此 Mapper 实际上也称作动态 SQL 工具。 Mapper 只需要按照 MyBatis 提供的 XML 配置语法编写 Mapper 接口即可，不需要额外编写 SQL 代码，系统会自动完成 SQL 语句的生成和参数绑定的过程。

        在 MyBatis 项目中，Mapper 通过定义接口来完成对数据库表的 CURD 操作。Mapper 接口可以和多个 XML 文件关联，每个 XML 文件中通常包含多个 mapper 接口的定义。当启动 MyBatis 时，它会加载所有关联的 XML 文件，根据 XML 文件中的定义加载 Mapper 接口，然后为这些接口生成代理对象，并由代理对象完成各种数据库操作。

        ## （二）Mapper XML 文件配置元素详解
        ### （1）select/insert/update/delete
        select/insert/update/delete标签用于定义操作数据库表的 SELECT、INSERT、UPDATE 或 DELETE 操作。以下是一个 select 查询的示例：

        ```xml
        <select id="findActiveBlog" parameterType="int" resultType="blog">
            SELECT * FROM blog WHERE state = #{state} AND deleted = false
        </select>
        ```

         - `id`：该属性指定了唯一标识符，mybatis 会用这个标识符来匹配 xml 文件中的定义，可以通过 `#{property}` 引用 sql 参数。
         - `parameterType`：该属性指定了传入 SQL 执行语句的参数类型，可选值为 java 包装类、基本数据类型或复杂对象。如果没有指定，则默认为不带参数的查询。
         - `resultType`：该属性指定了期望获取的数据类型，比如这里期望获取的是个 `blog` 对象。


        insert/update/delete 标签配置同样类似，以下是一个插入记录的示例：

        ```xml
        <insert id="insertBlog" parameterType="blog">
            INSERT INTO blog (title, content, create_time) VALUES (#{title}, #{content}, NOW())
        </insert>
        ```

         - `parameterType`：参数类型需要和 mapper 方法的入参一致。
         - 使用 `NOW()` 函数可以让 MyBatis 插入当前时间戳作为记录的创建时间。



        ### （2）sql
        `sql` 标签用于定义可复用的 SQL 片段，一般情况下，我们会把一些比较复杂的 SQL 语句抽取到 sql 标签中，然后在其他地方引用此标签。以下是一个简单的 sql 标签的示例：

        ```xml
        <sql id="selectAllColumns">
            a.*, b.*
        </sql>
        ```

        上述示例定义了一个名为 `selectAllColumns` 的 SQL 片段，其中包含两个 `*` 以便于在其他地方进行扩展。



        ### （3）include
        `include` 标签用于导入另一个 mapper xml 文件。以下是一个简单的 include 标签的示例：

        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
        <!-- imported XML file -->
        <mapper namespace="com.example.dao.UserDao">
           ...
        </mapper>
        
        <!-- main XML file -->
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
        <mapper namespace="com.example.dao.BlogDao">
            <include resource="user.xml"/>
            
            <select id="findByTitleLike" parameterType="string">
                SELECT b.* 
                FROM blog AS b JOIN user AS u ON b.author_id = u.id
                WHERE b.title LIKE #{title} AND b.deleted = false
            </select>
        </mapper>
        ```

        在这里，main xml 文件包括了 import 的 `user.xml`，`namespace` 为 `com.example.dao.BlogDao`。引入的文件中的 `namespace` 需要和本文件保持一致。`include` 的引入方式只需填写资源文件的路径，例如 `resource="user.xml"`。

        如果某个 XML 文件中存在多个 mapper 声明，那么 MyBatis 会加载其中所有的 mapper。



        ### （4）bind
        `bind` 标签用于设置参数变量和属性值，以下是一个简单的 bind 标签的示例：

        ```xml
        <select id="getBlogByAuthor" parameterType="string" resultType="blog">
            <bind name="username" value="'jim'"></bind>
            SELECT * FROM blog WHERE author_name = #{username} AND deleted = false
        </select>
        ```

        在上面的示例中，`value` 属性的值为 `'jim'`，表示变量 `username` 的默认值是 'jim'。

        在 SQL 语句中，也可以直接引用 `#{username}` 变量，如果该变量无效，则 MyBatis 会抛出异常。但是这样做会导致参数泄露，安全性较差。因此，建议使用 `<bind>` 标签指定默认值，防止未来的参数更改造成兼容性问题。



        ### （5）resultMap
        `resultMap` 标签用于指定一条 SQL 语句的列名和属性名之间的映射关系，以及查询结果集的类型。以下是一个简单的 resultMap 标签的示例：

        ```xml
        <resultMap id="BlogResult" type="blog">
            <id property="id" column="id"/>
            <result property="title" column="title"/>
            <result property="content" column="content"/>
            <result property="createTime" column="create_time"/>
            <result property="modifiedTime" column="modify_time"/>
            <result property="authorName" column="author_name" />
            <association property="author" javaType="user">
                <id property="id" column="author_id"/>
                <result property="userName" column="user_name"/>
                <result property="password" column="password"/>
            </association>
        </resultMap>
        ```

        在上述示例中，`type` 属性指定了查询结果的类型为 `blog`，`id` 子标签用于映射主键字段，`result` 子标签用于映射普通字段。还可以使用 `association` 子标签将一组关联关系映射到另一个实体。

        当查询结果包含多张表或者对象关系映射时，就需要用到 `resultMap` 标签。`resultMap` 标签非常灵活，可以在多个层次上进行嵌套，以构建复杂的查询结果。



        ### （6）collection
        `collection` 标签用于表示查询结果集合，并包含了一系列子标签用于定义集合元素的类型。以下是一个简单的 collection 标签的示例：

        ```xml
        <select id="listBlogsByTagId" parameterType="int" resultType="blog">
            SELECT b.*, t.tag_name 
            FROM blog AS b LEFT OUTER JOIN blog_tag AS bt ON b.id = bt.blog_id LEFT OUTER JOIN tag AS t ON bt.tag_id = t.id 
            WHERE t.id = #{tagId} AND b.deleted = false 
        </select>
            
        <collection property="blogs" ofType="blog">
            <id property="id" column="b.id"/>
            <result property="title" column="b.title"/>
            <result property="content" column="b.content"/>
            <result property="createTime" column="b.create_time"/>
            <result property="modifiedTime" column="b.modify_time"/>
            <result property="authorName" column="u.user_name"/>
            <association property="author" javaType="user">
                <id property="id" column="b.author_id"/>
                <result property="userName" column="u.user_name"/>
                <result property="password" column="u.password"/>
            </association>
            <collection property="tags" ofType="tag">
                <result property="tagName" column="t.tag_name"/>
            </collection>
        </collection>
        ```

        在上述示例中，`ofType` 属性定义了集合元素的类型为 `blog`，`id` 子标签用于映射集合元素的主键字段。`association` 子标签用于定义集合元素的关联关系，在查询结果中包含多张表或者对象关系映射时，就可以用 `association` 标签将多张表的字段映射到一个实体对象中。`collection` 子标签用于将集合元素再进一步分组，在查询结果中包含某些集合字段时，就可以用 `collection` 标签将集合元素再划分为多个部分。



        ### （7）cache
        `cache` 标签用于缓存查询结果，可以提高性能。以下是一个简单的 cache 标签的示例：

        ```xml
        <cache namespace="blogCache" expireSeconds="3600">
            <select id="findOneBlog" parameterType="long" useCache="true" resultType="blog">
                SELECT * FROM blog WHERE id = #{id} AND deleted = false
            </select>
        </cache>
        ```

        在上述示例中，`namespace` 属性为缓存的命名空间，`expireSeconds` 属性指定缓存过期时间，单位为秒。`useCache` 属性设置为 true 表示启用缓存，默认值为 true。

        通过 `cache` 标签，我们可以轻松实现查询结果的缓存功能。需要注意的是，如果数据被修改，则应该考虑刷新缓存。如果希望每次请求都强制重新查询数据库，则可以通过设置 `flushOnQuery` 属性为 true 来实现。



        ### （8）parameterMap
        `parameterMap` 标签用于参数绑定，提供了一种参数化查询的方式。以下是一个简单的 parameterMap 标签的示例：

        ```xml
        <parameterMap id="blogParameter" type="blog">
            <id property="id" column="id"/>
            <parameter property="title" javaType="java.lang.String" jdbcType="VARCHAR"
                mode="IN" dbType="VARCHAR" numericScale="0" expression="#{param1}"/>
            <parameter property="content" javaType="java.lang.String" jdbcType="VARCHAR"
                mode="IN" dbType="VARCHAR" numericScale="0" expression="#{param2}"/>
            <parameter property="tags" javaType="java.util.List" nestedResultMap="tagResultMap" mode="IN" >
                <column property="tagName" jdbcType="VARCHAR" />
            </parameter>
        </parameterMap>
        
        <select id="queryBlog" parameterMap="blogParameter" resultMap="blogResultMap">
            SELECT * FROM blog WHERE title like concat('%', #{title}, '%') and content like concat('%', #{content}, '%') 
        </select>
        ```

        在上述示例中，`parameterMap` 标签定义了输入参数类型为 `blog`，并给出各个字段的名称和 JDBC 数据类型。参数模式设定为 `IN`，表示参数在一次数据库交互过程中可以重复使用。参数表达式 `#{param1}`、`#{param2}` 指定了占位符的位置。`nestedResultMap` 属性用来处理 `tags` 参数，映射 `tag` 表中的字段。`mode` 属性用来设置参数的输入模式。

        此外，我们还可以使用 `include` 标签导入参数映射配置文件，节省编码量。



        ### （9）resultSets
        `resultSets` 标签用于自定义结果集解析器，以满足特殊的需求。以下是一个简单的 resultSets 标签的示例：

        ```xml
        <resultSets>
            <resultSet id="userResultSet">
                <result column="id" property="userId" />
                <result column="username" property="userName" />
                <result column="password" property="passWord" />
            </resultSet>
        </resultSets>
        
        <select id="getUserById" parameterType="long" resultSetType="userResultSet" resultType="User">
            SELECT id, username, password FROM users where id = #{id}
        </select>
        ```

        在上述示例中，我们定义了一个名为 `userResultSet` 的结果集，其中包含三个字段：`id`、`username`、`password`。`resultSetType` 属性指定了该查询使用的结果集解析器，在这种情况下，我们使用 MyBatis 默认的结果集解析器。

        当然，我们也可以自己编写自己的结果集解析器，以满足特殊的需求。



        # 3.Mapper XML 文件配置原理
        ## （一）动态 SQL 映射原理
        Mybatis 通过两种方式完成 SQL 映射：一种是使用 XML 文件进行静态 SQL 语句的配置；另外一种是采用动态 SQL 标签来动态构造 SQL 语句。

        **静态 SQL 语句**： MyBatis 的 XML 配置文件可以手写，或者使用基于模板的文本编辑器来编写，这种方式就是典型的静态 SQL 语句。举例如下：

        ```xml
        <select id="findActiveBlog" resultType="blog">
            SELECT * FROM blog WHERE state = ${state} AND deleted = false
        </select>
        ```

        **动态 SQL 标签**： MyBatis 框架支持多种动态 SQL 标签，能够动态构造 SQL 语句。动态 SQL 标签可分为两大类：条件类标签和遍历类标签。

        **条件类标签**： mybatis 支持 if、choose、when、otherwise 标签，通过判断条件来决定是否拼接 SQL 语句。

        ```xml
        <select id="findActiveBlog" parameterType="int" resultType="blog">
            SELECT * FROM blog WHERE state = #{state}
            <if test="deleted eq false">AND deleted = false</if>
        </select>
        ```

        **遍历类标签**： mybatis 支持 foreach 标签，通过循环的方式来决定是否拼接 SQL 语句。

        ```xml
        <select id="findActiveBlogWithTags" parameterType="int" resultType="blog">
            SELECT b.*, t.tag_name FROM blog AS b 
            INNER JOIN blog_tag AS bt ON b.id = bt.blog_id
            INNER JOIN tag AS t ON bt.tag_id = t.id
            WHERE b.state = #{state}
            <foreach item="tagName" collection="${tagNames}" separator=" OR ">
                t.tag_name = #{tagName}
            </foreach>
        </select>
        ```

        以上例子展示了如何结合条件类标签和遍历类标签来完成动态 SQL 语句的构造。

        ## （二）映射器接口配置原理
        通过阅读前面 Mapper XML 文件配置元素的讲解，读者已经掌握了 MyBatis 的 Mapper XML 文件的结构。下面，我们将继续探索 Mapper 接口的配置原理。

        ### （1）映射器接口定义规则
        在 MyBatis 中，映射器接口定义遵循如下规则：

        - 每个映射器接口必须声明一个 `@Mapper` 注解。
        - 每个映射器接口的方法必须与单个的 SQL 语句对应。
        - 每个映射器接口的方法必须声明 SQL 语句所需的所有参数和返回值。

        下面，我们用一个示例来说明这些规则：

        ```java
        @Mapper
        public interface BlogMapper {
        
            // 根据 ID 查找博文
            Blog findOne(Long id);

            // 根据状态查找所有已发布的博文列表
            List<Blog> findAllPublished();

            // 插入新博文
            int save(Blog blog);

            // 更新博文
            void update(Blog blog);

            // 删除博文
            void delete(Long id);
        }
        ```

        上述接口的定义包含三个方法：

        1. `findOne` 方法用于根据 ID 查找博文，此方法仅有一个参数（ID），无返回值，对应的 SQL 语句为：

           ```sql
           SELECT * FROM blog WHERE id = #{id}
           ```

        2. `findAllPublished` 方法用于查找所有已发布的博文列表，此方法没有参数，返回值为 List<Blog> 类型的博文列表，对应的 SQL 语句为：

           ```sql
           SELECT * FROM blog WHERE state = 'published' AND deleted = false
           ```

        3. `save` 方法用于插入新的博文，此方法只有一个参数（新增的 Blog 对象），返回值为受影响行数，对应的 SQL 语句为：

           ```sql
           INSERT INTO blog (title, content, create_time) VALUES (#{title}, #{content}, NOW())
           ```

        4. `update` 方法用于更新博文，此方法只有一个参数（待更新的 Blog 对象），无返回值，对应的 SQL 语句为：

           ```sql
           UPDATE blog SET title=#{title}, content=#{content}, modify_time=NOW() WHERE id = #{id}
           ```

        5. `delete` 方法用于删除博文，此方法只有一个参数（博文 ID），无返回值，对应的 SQL 语句为：

           ```sql
           DELETE FROM blog WHERE id = #{id}
           ```

    ### （2）动态代理机制
    MyBatis 使用动态代理机制来创建映射器接口的代理对象。代理对象会拦截调用映射器接口方法，根据方法签名，找到对应的 SQL 语句并执行。

    ## （三）动态 SQL 标签的限制和局限性
    MyBatis 在设计动态 SQL 标签的时候，参考了 Hibernate 的 JPQL 语法，并融合了 MyBatis 的 XML 配置语法。但是，MyBatis 的动态 SQL 标签还是有一些局限性。下面，我们来看一下 MyBatis 的动态 SQL 标签的限制和局限性。

    ### （1）动态 SQL 标签存在性能开销
    MyBatis 的动态 SQL 标签是在运行时解析的，因此存在着性能开销。而且，MyBatis 不支持预编译语句，因此，如果执行相同的 SQL 语句很多次，就会导致性能下降。为了避免性能下降，我们应尽量减少动态 SQL 的使用。

    ### （2）动态 SQL 无法解决所有的 SQL 场景
    MyBatis 的动态 SQL 标签只是一种简化 SQL 书写的语法糖，无法解决所有可能出现的 SQL 场景。而且，MyBatis 的动态 SQL 标签的使用非常局限，只能解决部分简单类型的条件语句。对于复杂的 SQL 语句，还是建议使用原始的 SQL 语句。

    # 4.Mapper 文件配置方法
    本节将介绍 MyBatis 中的 Mapper 文件的配置方法，包括 XML 配置文件、注解配置和混合配置。

    ## （一）XML 文件配置方法
    MyBatis 的 Mapper XML 配置文件采用 XML 格式，并遵循mybatis-config.xml 和 mybatis-mapper.xml 的命名规范。

    ### （1）mybatis-config.xml 配置
    mybatis-config.xml 文件主要用于全局配置，如连接池配置、日志配置等。该文件位于 classpath 根目录下的mybatis文件夹中。

    ### （2）mybatis-mapper.xml 配置
    mybatis-mapper.xml 文件用来配置映射器（Mapper），该文件中的 `<mapper>` 标签用于定义命名空间，多个`<mapper>`标签可以定义多个命名空间。每个 `<mapper>` 标签必须包含 `namespace` 属性，该属性值对应的是 MyBatis 配置的 Mapper 接口的全限定类名。`<mapper>` 标签可以包含多个 `<sql>` 标签，用来定义可重用的 SQL 语句片段。`<mapper>` 标签内可以包含 `<select>`、`<insert>`、`<update>`、`<delete>`、`<resultMap>`、`<parameterMap>`、`<sql>`、`<include>`、`<cache>` 等标签。

    ### （3）自定义 XML 解析器
    当 MyBatis 初始化的时候，它会读取mybatis-config.xml 文件和mybatis-mapper.xml 文件，并创建一个 Configuration 对象。Configuration 对象中包含一系列 MyBatis 配置项，包括连接池配置、日志配置等。Configuration 对象还包含一个 mappedStatements 列表，其中保存了所有 Mapper 的映射关系信息。在初始化阶段，MyBatis 会实例化所有插件，并调用 Plugin.init() 方法初始化它们。Plugin 是 MyBatis 的插件接口， MyBatis 在初始化阶段，会根据插件提供的接口，调用插件的 init 方法，来对插件进行初始化。

    Configuration 对象还会实例化一个 XMLConfigBuilder 对象，该对象会读取 mybatis-config.xml 文件的内容，并加载 Configuration 对象中相应的配置项。

    XMLConfigBuilder 对象会创建一个 DefaultSqlSessionFactory 对象，DefaultSqlSessionFactory 对象会创建一个 DefaultSqlSession 对象，而 DefaultSqlSession 对象会创建一个 Executor 对象，Executor 对象会真正去执行 MyBatis 的 SQL 语句。Executor 对象首先会根据传入的 statementId 获取 mappedStatement 对象，mappedStatement 对象封装了 SQL 语句的信息，包括 SQL 语句的 id、参数类型、结果类型等。Executor 对象会通过 ParameterHandler 类来对参数进行处理，处理完毕之后，Executor 对象会通过 StatementHandler 类来准备执行 SQL 语句，包括prepareStatement 方法、参数设置方法、执行 SQL 语句、结果映射方法等。

    当 MyBatis 需要执行一个 SQL 语句时，MappedStatement 对象会返回一个 BoundSql 对象，BoundSql 对象封装了 SQL 语句和参数信息，并提供了 getter 方法来获取 SQL 语句信息。MappedStatement 对象会将 BoundSql 对象传递给 StatementHandler 对象，StatementHandler 对象会通过 ParameterHandler 对参数进行处理，并通过 PreparedStatement 对象的 executeUpdate 方法来执行 SQL 语句，并通过 ResultSetHandler 对执行结果进行映射。

    ## （二）注解配置方法
    ### （1）JavaConfig 映射文件
    若想使用注解配置 MyBatis，则需要先在 pom 文件中加入以下依赖：

    ```xml
    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>${mybatis.version}</version>
    </dependency>
    
    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring -->
    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>${mybatis-spring.version}</version>
    </dependency>
    ```

     此外，还需要在配置文件中增加以下配置：

    ```xml
    <!-- MyBatis -->
    <bean class="org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration">
      <properties>
        <property name="configLocation" value="/mybatis-config.xml"/>
        <property name="mapperLocations" value="classpath*:mybatis/*.xml"/>
      </properties>
    </bean>
    ```

      其中 configLocation 属性指定了 mybatis-config.xml 文件的路径，mapperLocations 属性指定了 MyBatis 的映射配置文件所在的位置。

      映射配置文件名必须符合以下规则：

      1. 必须以 `mapper` 开头。
      2. 必须以 `.xml` 结尾。
      3. 文件名中的 `Mapper` 字符必须转换成小写字母。

      下面是一个示例：

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    <mapper namespace="com.example.dao.BlogMapper">
    
      <!-- 可重用的 SQL 语句片段 -->
      <sql id="tableName">blog</sql>
      <sql id="columns">id, title, content, author_id, created_at, updated_at</sql>
      
      <!-- 根据 ID 查找博文 -->
      <select id="findOne" resultType="com.example.model.Blog">
        SELECT 
          id, title, content, author_id, created_at, updated_at 
        FROM 
          <include refid="tableName" />  
        WHERE 
          id = #{id} 
      </select>
      
      <!-- 插入新博文 -->
      <insert id="save" parameterType="com.example.model.Blog">
        INSERT INTO 
          <include refid="tableName" />  
        (<include refid="columns" />) 
        VALUES 
        (#{id}, #{title}, #{content}, #{authorId}, now(), now())
      </insert>
      
      <!-- 更新博文 -->
      <update id="update" parameterType="com.example.model.Blog">
        UPDATE 
          <include refid="tableName" />  
        SET 
          title = #{title}, content = #{content}, author_id = #{authorId}, updated_at = now() 
        WHERE 
          id = #{id}
      </update>
      
      <!-- 删除博文 -->
      <delete id="remove">
        DELETE FROM 
          <include refid="tableName" />  
        WHERE 
          id = #{id}
      </delete>
      
    </mapper>
    ```

      在这里，我们定义了一些 SQL 语句模板，包括 tableName 和 columns 。然后分别配置了三个方法：findOne、save、update、remove。

      上述配置方法是纯注解的方式，在 XML 风格的 `<mapper/>` 标签中无法定义属性、注释等。不过，使用纯注解的方式，我们又丧失了 XML 配置文件的便利性。

    ## （三）混合配置方法
    有时候，我们既想使用 XML 配置 MyBatis，又想使用注解配置 MyBatis。这种情况下，我们就可以通过配置文件同时配置 XML 和注解。

    ```xml
    <!-- MyBatis -->
    <bean class="org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration">
      <property name="configurationProperties" value="..."/>
      <property name="typeAliasesPackage" value="com.example.model"/>
      <property name="mapperLocations" value="classpath*:mybatis/*Mapper.xml"/>
    </bean>
    ```

    在这里，MyBatisAutoConfiguration 类的 configurationProperties 属性用来加载 mybatis-config.xml 文件中的配置项，typeAliasesPackage 属性用来定义 Java 类型别名，mapperLocations 属性用来指定 MyBatis 映射器配置文件的位置。

    注解配置 MyBatis 的方法与 XML 配置 MyBatis 完全相同，只要在 Bean 的 Class 属性里指定 MapperScannerConfigurer 类，并且增加 annotationClass 属性指定扫描的注解。

    ```xml
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
      <property name="basePackage" value="com.example.dao"/>
      <property name="annotationClass" value="com.example.dao.annotations.MyBatisRepository"/>
    </bean>
    ```