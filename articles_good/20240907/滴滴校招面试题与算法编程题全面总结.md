                 

### 2025滴滴校招面试题与算法编程题全面总结

#### 1. 设计一个LRU缓存算法

**题目：** 设计一个LRU（Least Recently Used）缓存算法，实现一个类，该类支持以下操作：get 和 put。

**答案：**
```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：**
这个LRU缓存算法使用一个有序字典（OrderedDict）来存储键值对。在`get`方法中，如果键不存在，返回-1；如果存在，将其移动到字典的末尾，以表示它是最近使用的。在`put`方法中，如果键已存在，同样移动到末尾；如果不存在，将其添加到字典中。如果字典的大小超过了容量，则移除最旧的键值对。

#### 2. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for char in strs[0]:
        for s in strs[1:]:
            if len(s) < len(prefix) or s[:len(prefix)] != prefix:
                return prefix
        prefix += char
    return prefix
```

**解析：**
这个函数首先检查字符串数组是否为空，如果是，则直接返回空字符串。然后，它初始化一个空字符串`prefix`。它逐个字符地遍历第一个字符串，并与后续的字符串进行对比，一旦发现不匹配，则返回当前的最长公共前缀。如果所有字符串都匹配，则继续添加字符到`prefix`。

#### 3. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**
```python
# 定义单链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    tail.next = l1 or l2
    return dummy.next
```

**解析：**
这个函数定义了一个哑节点（dummy），然后通过比较两个链表的当前节点值，将较小的值链接到哑节点的下一个节点，并移动相应的链表指针。最后，将剩余的链表（如果有的话）链接到结果链表的末尾。这样，就可以得到一个新的有序链表。

#### 4. 反转链表

**题目：** 编写一个函数，用于反转一个单链表。

**答案：**
```python
def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**解析：**
这个函数使用一个哑节点prev和当前节点curr来逐步反转链表。它通过将当前节点的下一个节点指向prev，然后移动prev和curr到下一个节点，直到遍历完整个链表。最后，prev将成为新的头节点，返回它即可得到反转后的链表。

#### 5. 二进制搜索

**题目：** 实现一个二分搜索算法，给定一个有序数组和一个目标值，找到目标值在数组中的索引。如果不存在，返回-1。

**答案：**
```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left
```

**解析：**
这个函数使用二分搜索算法来查找目标值在有序数组中的索引。它初始化两个指针left和right，然后通过不断缩小区间来查找目标值。如果找到目标值，返回其索引；如果未找到，返回左侧边界（即目标值应该插入的位置）。

#### 6. 汉明距离

**题目：** 给定两个整数x和y，计算并返回两个数的汉明距离。

**答案：**
```python
def hammingDistance(x, y):
    xor = x ^ y
    distance = 0
    while xor:
        distance += xor & 1
        xor >>= 1
    return distance
```

**解析：**
这个函数通过计算两个整数的异或（XOR）结果，然后统计结果中1的位数来计算汉明距离。每执行一次`xor & 1`操作，就可以得到当前位是否为1，然后右移一位，继续统计。

#### 7. 二进制表示中1的个数

**题目：** 编写一个函数，计算一个无符号整数二进制表示中1的个数。

**答案：**
```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

**解析：**
这个函数使用位操作来统计整数中1的个数。通过不断将整数右移，并检查当前最低位是否为1，来累加1的个数。

#### 8. 打家劫舍

**题目：** 你是一个盗贼，打算闯入一排按从大到小排列的房屋，每间房内都有一些财物。你不能闯入相邻的两间房屋，设计一个算法计算你最多可以偷窃的财物总量。

**答案：**
```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    prev, curr = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        prev, curr = curr, max(prev+nums[i], curr)
    return curr
```

**解析：**
这个函数使用动态规划来解决问题。它维护两个变量`prev`和`curr`，分别表示不偷当前房屋和不偷相邻房屋时能够偷窃的最大财物量。遍历数组时，更新这两个变量，最后返回`curr`即可得到最大偷窃量。

#### 9. 打家劫舍 II

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋，相邻的房屋在一段时间内无法被闯入。计算你最多可以偷窃的财物总量。

**答案：**
```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    return max(rob(nums[:-1]), rob(nums[1:]))
```

**解析：**
这个函数同样是使用动态规划来解决问题。由于最后一个房屋不能被偷，因此需要计算不包含最后一个房屋和不包含第一个房屋时能够偷窃的最大财物量，并取最大值。

#### 10. 盛最多水的容器

**题目：** 给定一个二维矩阵，计算最大的盛水量。

**答案：**
```python
def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**解析：**
这个函数使用双指针方法来寻找最大的盛水量。两个指针分别指向数组的开始和结束，通过比较左右两侧的高度来移动指针，计算当前容器的盛水量，并更新最大值。

#### 11. 设计循环队列

**题目：** 设计一个循环队列，支持 Front、Rear 和 IsEmpty 等操作。

**答案：**
```python
from collections import deque

class MyCircularQueue:

    def __init__(self, k: int):
        self.queue = deque(maxlen=k)

    def Front(self) -> int:
        if not self.queue:
            return -1
        return self.queue[0]

    def Rear(self) -> int:
        if not self.queue:
            return -1
        return self.queue[-1]

    def enQueue(self, value: int) -> bool:
        if len(self.queue) < self.queue.maxlen:
            self.queue.append(value)
            return True
        return False

    def deQueue(self) -> bool:
        if not self.queue:
            return False
        self.queue.popleft()
        return True

    def isEmpty(self) -> bool:
        return len(self.queue) == 0
```

**解析：**
这个循环队列使用双端队列（deque）来实现。初始化时设置最大长度为k。`enQueue`和`deQueue`方法分别添加和删除元素，并返回布尔值表示是否成功。`Front`、`Rear`和`isEmpty`方法分别返回队列的头部、尾部和是否为空。

#### 12. 岛屿的最大面积

**题目：** 给定一个包含了一些 0 和 1 的非空二维数组，请找出该数组中的所有岛屿，并返回岛屿的最大面积。

**答案：**
```python
def maxAreaOfIsland(grid):
    def dfs(i, j):
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
            return 0
        grid[i][j] = 0
        return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)

    max_area = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                max_area = max(max_area, dfs(i, j))
    return max_area
```

**解析：**
这个函数使用深度优先搜索（DFS）来计算岛屿的面积。对于每个未访问的陆地（1），调用`dfs`函数来计算其面积，并更新最大面积。`dfs`函数递归地遍历所有相邻的陆地，并将其标记为已访问。

#### 13. 有效括号字符串

**题目：** 给定一个字符串，判断其是否是一个有效的括号字符串，其中 '('、')'和'{'、'}'、'['和']'都算作一组有效的括号。

**答案：**
```python
def isValid(s):
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in pairs.values():
            stack.append(char)
        elif char in pairs and stack and stack[-1] == pairs[char]:
            stack.pop()
        else:
            return False
    return not stack
```

**解析：**
这个函数使用栈来检查字符串是否有效。它遍历字符串，对于每一个左括号，将其推入栈中；对于每一个右括号，检查其是否与栈顶元素匹配。如果匹配，则弹出栈顶元素。最后，如果栈为空，说明字符串有效。

#### 14. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**
```python
# 定义单链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    tail.next = l1 or l2
    return dummy.next
```

**解析：**
这个函数定义了一个哑节点（dummy），然后通过比较两个链表的当前节点值，将较小的值链接到哑节点的下一个节点，并移动相应的链表指针。最后，将剩余的链表（如果有的话）链接到结果链表的末尾。这样，就可以得到一个新的有序链表。

#### 15. 链表中倒数第k个节点

**题目：** 输入一个链表，输出该链表中倒数第k个节点。

**答案：**
```python
# 定义单链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head, k):
    fast = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    slow = head
    while fast:
        slow = slow.next
        fast = fast.next
    return slow
```

**解析：**
这个函数使用快慢指针法来找到链表中倒数第k个节点。快指针先走k步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针正好指向倒数第k个节点。

#### 16. 暴力解法

**题目：** 给定一个包含 n 个整数的数组和一个目标值 target，判断是否存在且仅存在一个目标值，使得将数组中所有大于等于目标值的整数进行相加和减去所有小于目标值的整数的和的结果为 0。

**答案：**
```python
def isPossible(nums, target):
    s = sum(nums)
    if s < target or (s + target) % 2:
        return False
    target = (s + target) // 2
    cnt = Counter(nums)
    return all(v <= cnt[target - k] for k in range(target + 1))
```

**解析：**
这个函数使用计数和排序的方法来判断是否存在一个目标值。首先计算数组中所有数的和s，如果s小于目标值或者s加上目标值不能被2整除，则无法找到目标值。然后遍历从0到目标值的所有可能的目标值，检查是否满足条件。

#### 17. 等价二进制字符串对的数量

**题目：** 给定一个字符串 s，计算有多少个字符串与 s 等价（等价表示两个字符串的每个字符都相同，但位置可以不同）。

**答案：**
```python
from collections import Counter

def countEquivalentSubstrings(s):
    cnt = Counter(s)
    ans = 0
    for v in cnt.values():
        ans += v * (v - 1) // 2
    return ans
```

**解析：**
这个函数使用计数的方法来计算等价二进制字符串对的数量。对于每个字符出现的次数v，可以计算出与该字符等价的字符串对的数量，然后将它们相加。

#### 18. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：**
```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack.pop()
```

**解析：**
这个函数使用栈来实现逆波兰表达式的求值。它遍历表达式中的每个字符，根据字符的类型进行相应的操作，并将结果推入栈中。最后，返回栈顶元素作为最终结果。

#### 19. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：**
```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last = ans[-1]
        if interval[0] <= last[1]:
            ans[-1] = [last[0], max(last[1], interval[1])]
        else:
            ans.append(interval)
    return ans
```

**解析：**
这个函数首先对区间进行排序，然后遍历排序后的区间，合并重叠的区间。如果当前区间的起始值小于或等于前一个区间的结束值，则合并这两个区间；否则，将当前区间添加到结果中。

#### 20. 设计循环双端队列

**题目：** 设计实现一个双端队列。

**答案：**
```python
from collections import deque

class MyCircularDeque:

    def __init__(self, k: int, value: List[int]):
        self.q = deque(value, maxlen=k)

    def insertFront(self, value: int) -> bool:
        if len(self.q) < self.q.maxlen:
            self.q.appendleft(value)
            return True
        return False

    def insertLast(self, value: int) -> bool:
        if len(self.q) < self.q.maxlen:
            self.q.append(value)
            return True
        return False

    def deleteFront(self) -> bool:
        if len(self.q):
            self.q.popleft()
            return True
        return False

    def deleteLast(self) -> bool:
        if len(self.q):
            self.q.pop()
            return True
        return False

    def getFront(self) -> int:
        if len(self.q):
            return self.q[0]
        return -1

    def getRear(self) -> int:
        if len(self.q):
            return self.q[-1]
        return -1

    def isEmpty(self) -> bool:
        return len(self.q) == 0

    def isFull(self) -> bool:
        return len(self.q) == self.q.maxlen
```

**解析：**
这个类使用Python的deque来实现循环双端队列。初始化时，传入容量k和初始值数组value。`insertFront`和`insertLast`方法分别在前端和后端插入元素，`deleteFront`和`deleteLast`方法分别删除前端和后端的元素。`getFront`和`getRear`方法返回前端和后端的元素，`isEmpty`和`isFull`方法分别判断队列是否为空或满。

#### 21. 设计数管家

**题目：** 设计一个数管家，具有以下功能：插入、删除和查询。数管家应能返回给定数字序列中的所有重复数字。

**答案：**
```python
from collections import defaultdict

class NumberLock:

    def __init__(self):
        self.locks = defaultdict(list)

    def insert(self, number: int) -> bool:
        self.locks[number].append(number)
        return True

    def delete(self, number: int) -> bool:
        self.locks[number].pop()
        if not self.locks[number]:
            del self.locks[number]
        return True

    def query(self, number: int) -> bool:
        return bool(self.locks[number])
```

**解析：**
这个数管家使用字典来存储每个数字及其重复次数。`insert`方法将数字插入到字典中，`delete`方法从字典中删除数字，`query`方法检查数字是否在字典中。

#### 22. 设计循环双队列

**题目：** 设计一个循环双队列，具有以下功能：在队首和队尾添加元素，在队首和队尾删除元素，获取队首和队尾元素。

**答案：**
```python
from collections import deque

class MyCircularDeque:

    def __init__(self, k: int):
        self.q = deque(maxlen=k)

    def insertFront(self, value: int) -> bool:
        if len(self.q) < self.q.maxlen:
            self.q.appendleft(value)
            return True
        return False

    def insertLast(self, value: int) -> bool:
        if len(self.q) < self.q.maxlen:
            self.q.append(value)
            return True
        return False

    def deleteFront(self) -> bool:
        if len(self.q):
            self.q.popleft()
            return True
        return False

    def deleteLast(self) -> bool:
        if len(self.q):
            self.q.pop()
            return True
        return False

    def getFront(self) -> int:
        if len(self.q):
            return self.q[0]
        return -1

    def getRear(self) -> int:
        if len(self.q):
            return self.q[-1]
        return -1
```

**解析：**
这个类使用Python的deque来实现循环双队列。它提供了在队首和队尾添加元素、删除元素以及获取队首和队尾元素的方法。队列的容量通过deque的maxlen参数控制。

#### 23. 找出旋转排序数组中的最小值

**题目：** 给你一个旋转排序的数组 nums ，请你找出并返回数组中的最小元素。

**答案：**
```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：**
这个函数使用二分查找来找到旋转排序数组中的最小值。通过比较中间值和最右边的值，可以确定最小值所在的区间，然后继续在区间内二分查找。

#### 24. 设计一个组合锁

**题目：** 设计一个组合锁，具有以下功能：设置组合、验证组合、重置组合。

**答案：**
```python
class CombinationLock:

    def __init__(self, code):
        self.code = code

    def setCombination(self, x, y, z):
        self.code = (x, y, z)

    def validate(self, a, b, c):
        return (a, b, c) == self.code

    def reset(self):
        self.code = None
```

**解析：**
这个组合锁类通过一个三元组来存储密码，提供了设置密码、验证密码和重置密码的方法。

#### 25. 设计LRU缓存

**题目：** 设计一个LRU（Least Recently Used）缓存，支持获取和设置操作。

**答案：**
```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：**
这个LRU缓存类使用OrderedDict来实现，提供了获取和设置缓存值的方法。当缓存超过容量时，会自动删除最旧的键值对。

#### 26. 设计电话目录

**题目：** 设计一个电话目录，支持添加和查询操作。

**答案：**
```python
from collections import defaultdict

class PhoneDirectory:

    def __init__(self, maxNumbers: int):
        self.maxNumbers = maxNumbers
        self.used = set()
        self.left = [i for i in range(maxNumbers)]

    def get(self) -> int:
        if not self.left:
            return -1
        return self.left.pop()

    def check(self, number: int) -> bool:
        return number not in self.used

    def release(self, number: int) -> bool:
        if number not in self.used:
            return False
        self.used.remove(number)
        self.left.append(number)
        return True
```

**解析：**
这个电话目录类使用一个集合来存储已分配的电话号码，使用一个列表来存储未分配的电话号码。提供了获取、检查和释放电话号码的方法。

#### 27. 设计一个日记系统

**题目：** 设计一个日记系统，支持以下操作：写日记、阅读日记、删除日记。

**答案：**
```python
from bisect import bisect_left, bisect_right
from collections import defaultdict

class Diary:

    def __init__(self):
        self.dates = []
        self.diaries = defaultdict(list)

    def write(self, date: int, content: str) -> bool:
        idx = bisect_left(self.dates, date)
        if idx < len(self.dates) and self.dates[idx] == date:
            return False
        self.dates.insert(idx, date)
        self.diaries[date].append(content)
        return True

    def read(self, date: int) -> List[str]:
        left, right = bisect_left(self.dates, date), bisect_right(self.dates, date) - 1
        if left == len(self.dates) or right < 0 or left > right:
            return []
        return self.diaries[self.dates[left]][bisect_right(self.diaries[self.dates[left]], date) - 1]

    def delete(self, date: int) -> bool:
        left, right = bisect_left(self.dates, date), bisect_right(self.dates, date) - 1
        if left == len(self.dates) or right < 0 or left > right:
            return False
        del self.diaries[self.dates[left]][bisect_right(self.diaries[self.dates[left]], date) - 1]
        self.dates.pop(left)
        return True
```

**解析：**
这个日记系统使用二分查找和哈希表来实现。写日记时，使用二分查找插入日期，并添加日记内容。阅读日记时，使用二分查找找到日期范围，并返回相应的日记内容。删除日记时，使用二分查找删除日期和日记内容。

#### 28. 设计一个优先级队列

**题目：** 设计一个优先级队列，支持以下操作：添加元素、获取最高优先级元素、删除最高优先级元素。

**答案：**
```python
import heapq

class PriorityQueue:

    def __init__(self):
        self.heap = []

    def push(self, item, priority):
        heapq.heappush(self.heap, (-priority, item))

    def pop(self):
        return heapq.heappop(self.heap)[1]

    def isEmpty(self):
        return len(self.heap) == 0
```

**解析：**
这个优先级队列使用Python的heapq模块来实现。push方法添加元素，pop方法获取和删除最高优先级元素，isEmpty方法检查队列是否为空。

#### 29. 设计一个堆

**题目：** 设计一个堆，支持以下操作：插入元素、删除最大元素、获取最大元素。

**答案：**
```python
import heapq

class Heap:

    def __init__(self):
        self.heap = []

    def push(self, item):
        heapq.heappush(self.heap, item)

    def pop(self):
        return heapq.heappop(self.heap)

    def peek(self):
        return self.heap[0]
```

**解析：**
这个堆使用Python的heapq模块来实现。push方法插入元素，pop方法删除最大元素，peek方法获取最大元素。

#### 30. 设计一个优先级队列

**题目：** 设计一个优先级队列，支持以下操作：添加元素、获取最高优先级元素、删除最高优先级元素。

**答案：**
```python
from queue import PriorityQueue

class PriorityQueue:

    def __init__(self):
        self.queue = PriorityQueue()

    def push(self, item, priority):
        self.queue.put((priority, item))

    def pop(self):
        return self.queue.get()[1]

    def isEmpty(self):
        return self.queue.empty()
```

**解析：**
这个优先级队列使用Python的queue模块来实现。push方法添加元素，pop方法获取和删除最高优先级元素，isEmpty方法检查队列是否为空。

### 总结

通过以上题目，我们可以看到滴滴校招面试题和算法编程题涵盖了数据结构与算法的各个方面，包括链表、队列、栈、排序、搜索、动态规划等。这些题目不仅考察了基本的数据结构操作，还涉及到算法设计和优化。同时，还涉及到了一些实际应用场景的问题，如缓存算法、循环队列、优先级队列等。这些题目可以帮助求职者更好地准备面试，提升算法能力和解题技巧。在面试过程中，除了对算法的理解和应用，还需要注重思路的清晰和逻辑的严密，以便在短时间内展示自己的解题能力。希望以上总结能对大家有所帮助。

