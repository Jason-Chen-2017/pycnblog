                 

### 自拟标题
《洞察力的实践指南：一线互联网大厂面试算法解析》

### 一、算法面试题库

#### 1. 快排算法
**题目：** 实现快速排序算法。

**答案：**
```go
package main

import (
    "fmt"
)

func quicksort(arr []int) {
    if len(arr) <= 1 {
        return
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    right := make([]int, 0)

    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else {
            right = append(right, v)
        }
    }

    quicksort(left)
    quicksort(right)

    arr = append(append(left, pivot), right...)
}

func main() {
    arr := []int{9, 7, 5, 11, 12, 2, 14, 3, 10, 6}
    quicksort(arr)
    fmt.Println(arr)
}
```

**解析：** 快速排序（Quick Sort）是一种高效的排序算法。选择一个基准元素（pivot），然后将数组分为两部分，小于基准元素的部分和大于基准元素的部分，递归地对这两部分进行排序。

#### 2. 链表反转
**题目：** 实现单链表反转的功能。

**答案：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head

    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}

    newHead := reverseList(head)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 通过迭代的方式反转链表，每次遍历将当前节点的 `next` 指向 `prev`，然后移动 `prev` 和 `cur` 到下一个节点。

#### 3. 二分查找
**题目：** 实现一个二分查找算法。

**答案：**
```go
package main

import (
    "fmt"
)

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1

    for low <= high {
        mid := (low + high) / 2

        if arr[mid] == target {
            return mid
        }

        if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return -1
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    target := 5

    result := binarySearch(arr, target)
    if result != -1 {
        fmt.Println("Element found at index:", result)
    } else {
        fmt.Println("Element not found.")
    }
}
```

**解析：** 二分查找是一种在有序数组中查找特定元素的搜索算法。通过不断地将搜索区间缩小一半，直到找到目标元素或确定其不存在。

#### 4. 合并两个有序链表
**题目：** 合并两个有序链表。

**答案：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6}}}

    mergedList := mergeTwoLists(l1, l2)
    for mergedList != nil {
        fmt.Println(mergedList.Val)
        mergedList = mergedList.Next
    }
}
```

**解析：** 通过迭代的方式，比较两个链表的当前节点值，将较小的节点添加到新的链表中，并移动当前节点。

#### 5. 逆波兰表达式求值
**题目：** 实现逆波兰表达式求值。

**答案：**
```go
package main

import (
    "fmt"
    "math"
)

func evalRPN(tokens []string) float64 {
    var stack []float64

    for _, token := range tokens {
        switch token {
        case "+":
            t2 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            t1 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, t1+t2)
        case "-":
            t2 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            t1 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, t1-t2)
        case "*":
            t2 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            t1 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, t1*t2)
        case "/":
            t2 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            t1 := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if t2 != 0 {
                stack = append(stack, t1/t2)
            } else {
                return math.NaN()
            }
        default:
            stack = append(stack, float64([]byte(token)[0] - '0'))
        }
    }

    return stack[0]
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    result := evalRPN(tokens)
    fmt.Println("Result:", result)
}
```

**解析：** 使用栈来处理逆波兰表达式，遇到操作数直接入栈，遇到操作符则弹出栈顶两个操作数进行运算，并将结果重新入栈。

#### 6. 计数排序
**题目：** 实现计数排序算法。

**答案：**
```go
package main

import (
    "fmt"
)

func countingSort(arr []int) []int {
    max := arr[0]
    for _, v := range arr {
        if v > max {
            max = v
        }
    }

    count := make([]int, max+1)
    output := make([]int, 0, len(arr))

    for _, v := range arr {
        count[v]++
    }

    for i, v := range count {
        for j := 0; j < v; j++ {
            output = append(output, i)
        }
    }

    return output
}

func main() {
    arr := []int{4, 2, 2, 8, 3, 3, 1}
    sortedArr := countingSort(arr)
    fmt.Println("Sorted array:", sortedArr)
}
```

**解析：** 计数排序是一种线性时间复杂度的排序算法，适用于整数数组。首先找到数组中的最大值，然后创建一个计数数组，遍历原数组，计数数组中对应元素的数量即为原数组中该元素的出现次数，最后根据计数数组进行排序。

#### 7. 快速幂算法
**题目：** 实现快速幂算法。

**答案：**
```go
package main

import (
    "fmt"
)

func quickPower(base int, exponent int) int {
    result := 1
    for exponent > 0 {
        if exponent%2 == 1 {
            result *= base
        }
        base *= base
        exponent /= 2
    }
    return result
}

func main() {
    base := 2
    exponent := 10
    result := quickPower(base, exponent)
    fmt.Printf("Result: %d\n", result)
}
```

**解析：** 快速幂算法利用指数的二进制表示进行递归计算，时间复杂度为 O(log n)。

#### 8. 冒泡排序
**题目：** 实现冒泡排序算法。

**答案：**
```go
package main

import (
    "fmt"
)

func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func main() {
    arr := []int{4, 2, 6, 8, 1, 5}
    bubbleSort(arr)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 冒泡排序通过重复遍历待排序的数组，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数组直到没有再需要交换的元素。

#### 9. 选择排序
**题目：** 实现选择排序算法。

**答案：**
```go
package main

import (
    "fmt"
)

func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}

func main() {
    arr := []int{4, 2, 6, 8, 1, 5}
    selectionSort(arr)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 选择排序通过每次循环找到待排序数组的剩余元素中的最小元素，将其与第一个元素交换，以达到排序的目的。

#### 10. 插入排序
**题目：** 实现插入排序算法。

**答案：**
```go
package main

import (
    "fmt"
)

func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}

func main() {
    arr := []int{4, 2, 6, 8, 1, 5}
    insertionSort(arr)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

#### 11. 合并两个有序数组
**题目：** 合并两个有序数组。

**答案：**
```go
package main

import (
    "fmt"
)

func mergeSortedArrays(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }

    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    nums2 := []int{2, 5, 6}
    m, n := 3, 3
    mergeSortedArrays(nums1, m, nums2, n)
    fmt.Println(nums1)
}
```

**解析：** 从两个数组的末尾开始比较，将较大的元素放入合并数组的末尾，最后将剩余的元素填充到合并数组中。

#### 12. 最长公共子序列
**题目：** 求最长公共子序列。

**答案：**
```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("Length of LCS:", result)
}
```

**解析：** 使用动态规划求解最长公共子序列，创建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 的前 `i` 个字符和字符串 `text2` 的前 `j` 个字符的最长公共子序列的长度。

#### 13. 求最大子序和
**题目：** 求一个数组中的最大子序和。

**答案：**
```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSoFar = max(maxSoFar, currSum)
    }
    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println("Maximum subarray sum:", result)
}
```

**解析：** 使用前缀和与动态规划的方法，遍历数组，更新当前最大和，并记录全局最大和。

#### 14. 求零的个数
**题目：** 求一个数组中 0 的个数。

**答案：**
```go
package main

import (
    "fmt"
)

func zeroCount(nums []int) int {
    count := 0
    for _, num := range nums {
        if num == 0 {
            count++
        }
    }
    return count
}

func main() {
    nums := []int{0, 1, 0, 2, 0, 4, 0}
    result := zeroCount(nums)
    fmt.Println("Number of zeros:", result)
}
```

**解析：** 通过遍历数组，统计 0 的个数。

#### 15. 求和为 k 的数对
**题目：** 求一个数组中和为 k 的数对个数。

**答案：**
```go
package main

import (
    "fmt"
)

func pairSumCount(nums []int, k int) int {
    count := 0
    freq := make(map[int]int)

    for _, num := range nums {
        target := k - num
        count += freq[target]
        freq[num]++
    }

    return count
}

func main() {
    nums := []int{1, 5, 7, -1, 5}
    k := 6
    result := pairSumCount(nums, k)
    fmt.Println("Number of pairs:", result)
}
```

**解析：** 使用哈希表记录数组中每个元素的频次，遍历数组，对于每个元素，计算与目标值的差，并累加差值在哈希表中的频次。

#### 16. 求最长公共前缀
**题目：** 求一个字符串数组中的最长公共前缀。

**答案：**
```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 {
            if !strings.HasPrefix(strs[i], prefix) {
                prefix = prefix[:len(prefix)-1]
            } else {
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("Longest common prefix:", result)
}
```

**解析：** 从第一个字符串开始，逐步减少公共前缀的长度，直到找到所有字符串都有的公共前缀。

#### 17. 最长递增子序列
**题目：** 求一个数组的最长递增子序列。

**答案：**
```go
package main

import (
    "fmt"
)

func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    dp := make([]int, len(nums))
    dp[0] = 1
    maxLen := 1

    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
                maxLen = max(maxLen, dp[i])
            }
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    result := lengthOfLIS(nums)
    fmt.Println("Length of LIS:", result)
}
```

**解析：** 使用动态规划求解最长递增子序列，创建一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

#### 18. 罗马数字转整数
**题目：** 实现罗马数字转整数。

**答案：**
```go
package main

import (
    "fmt"
)

func romanToInt(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    result := 0
    prev := 0

    for i := len(s) - 1; i >= 0; i-- {
        curr := m[rune(s[i])]
        if curr < prev {
            result -= curr
        } else {
            result += curr
        }
        prev = curr
    }

    return result
}

func main() {
    s := "MCMXCV"
    result := romanToInt(s)
    fmt.Println("Integer value:", result)
}
```

**解析：** 从字符串的最后一个字符开始遍历，根据罗马数字的规则进行计算。

#### 19. 最大子序和
**题目：** 求一个数组中的最大子序和。

**答案：**
```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSoFar = max(maxSoFar, currSum)
    }
    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println("Maximum subarray sum:", result)
}
```

**解析：** 使用前缀和与动态规划的方法，遍历数组，更新当前最大和，并记录全局最大和。

#### 20. 二分查找
**题目：** 实现二分查找算法。

**答案：**
```go
package main

import (
    "fmt"
)

func binarySearch(nums []int, target int) int {
    low, high := 0, len(nums)-1

    for low <= high {
        mid := (low + high) / 2

        if nums[mid] == target {
            return mid
        }

        if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    result := binarySearch(nums, target)
    if result != -1 {
        fmt.Println("Element found at index:", result)
    } else {
        fmt.Println("Element not found.")
    }
}
```

**解析：** 二分查找是一种在有序数组中查找特定元素的搜索算法。通过不断地将搜索区间缩小一半，直到找到目标元素或确定其不存在。

#### 21. 求和为 m 的数对
**题目：** 求一个数组中和为 m 的数对个数。

**答案：**
```go
package main

import (
    "fmt"
)

func pairSumCount(nums []int, m int) int {
    count := 0
    freq := make(map[int]int)

    for _, num := range nums {
        target := m - num
        count += freq[target]
        freq[num]++
    }

    return count
}

func main() {
    nums := []int{1, 5, 7, -1, 5}
    m := 6
    result := pairSumCount(nums, m)
    fmt.Println("Number of pairs:", result)
}
```

**解析：** 使用哈希表记录数组中每个元素的频次，遍历数组，对于每个元素，计算与目标值的差，并累加差值在哈希表中的频次。

#### 22. 求最长公共子串
**题目：** 求一个字符串数组中的最长公共子串。

**答案：**
```go
package main

import (
    "fmt"
)

func longestCommonSubstring(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    dp := make([][]int, len(strs))
    for i := range dp {
        dp[i] = make([]int, len(strs[0])+1)
    }
    maxLen := 0
    endIndex := 0

    for i := 1; i <= len(strs[0]); i++ {
        for j := 1; j <= len(strs); j++ {
            if strs[0][i-1] == strs[j-1][i-1] {
                dp[j][i] = dp[j-1][i-1] + 1
                if dp[j][i] > maxLen {
                    maxLen = dp[j][i]
                    endIndex = i
                }
            }
        }
    }

    return strs[0][endIndex-maxLen : endIndex]
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonSubstring(strs)
    fmt.Println("Longest common substring:", result)
}
```

**解析：** 使用动态规划求解最长公共子串，创建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `strs[i]` 和字符串 `strs[j]` 的最长公共子串的长度。

#### 23. 判断字符串是否是回文
**题目：** 判断一个字符串是否是回文。

**答案：**
```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    left, right := 0, len(s)-1

    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }

    return true
}

func main() {
    s := "level"
    result := isPalindrome(s)
    fmt.Println("Is palindrome:", result)
}
```

**解析：** 通过两个指针从字符串的两端开始遍历，比较对应的字符，直到中间相遇。

#### 24. 求两个有序数组的中位数
**题目：** 求两个有序数组的中位数。

**答案：**
```go
package main

import (
    "fmt"
    "math"
)

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    totalLen := m + n
    medianIndex := (totalLen - 1) / 2
    i, j := 0, 0

    for i < m && j < n {
        if nums1[i] <= nums2[j] {
            i++
        } else {
            j++
        }
    }

    if totalLen%2 == 0 {
        leftMax := math.Max(float64(nums1[i-1]), float64(nums2[j-1]))
        rightMin := math.Max(float64(nums1[i]), float64(nums2[j]))
        return (leftMax + rightMin) / 2
    } else {
        return float64(math.Max(float64(nums1[i-1]), float64(nums2[j-1])))
    }
}

func main() {
    nums1 := []int{1, 3}
    nums2 := []int{2}
    result := findMedianSortedArrays(nums1, nums2)
    fmt.Println("Median:", result)
}
```

**解析：** 使用两个指针遍历两个数组，找到中位数。如果数组长度是偶数，则返回中位数和下一个数的平均值。

#### 25. 求最大连续子序列和
**题目：** 求一个数组中的最大连续子序列和。

**答案：**
```go
package main

import (
    "fmt"
)

func maxSubArraySum(nums []int) int {
    maxSoFar := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSoFar = max(maxSoFar, currSum)
    }

    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArraySum(nums)
    fmt.Println("Maximum subarray sum:", result)
}
```

**解析：** 使用前缀和与动态规划的方法，遍历数组，更新当前最大和，并记录全局最大和。

#### 26. 求最大公约数
**题目：** 求两个数的最大公约数。

**答案：**
```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    a := 12
    b := 18
    result := gcd(a, b)
    fmt.Println("GCD:", result)
}
```

**解析：** 使用辗转相除法（欧几里得算法）求解最大公约数。

#### 27. 求最小公倍数
**题目：** 求两个数的最小公倍数。

**答案：**
```go
package main

import (
    "fmt"
)

func lcm(a, b int) int {
    return (a / gcd(a, b)) * b
}

func main() {
    a := 12
    b := 18
    result := lcm(a, b)
    fmt.Println("LCM:", result)
}
```

**解析：** 使用最大公约数和最小公倍数的关系求解最小公倍数。

#### 28. 求逆元
**题目：** 求一个整数在模 m 下的逆元。

**答案：**
```go
package main

import (
    "fmt"
)

func modInverse(a, m int) int {
    for i := 1; i < m; i++ {
        if (a*i) % m == 1 {
            return i
        }
    }
    return -1
}

func main() {
    a := 3
    m := 7
    result := modInverse(a, m)
    fmt.Println("Modular inverse:", result)
}
```

**解析：** 使用循环遍历模 m，找到满足 `a*i % m == 1` 的 i 值。

#### 29. 求斐波那契数列的第 n 项
**题目：** 求斐波那契数列的第 n 项。

**答案：**
```go
package main

import (
    "fmt"
)

func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}

func main() {
    n := 10
    result := fibonacci(n)
    fmt.Println("Fibonacci number:", result)
}
```

**解析：** 使用循环迭代求解斐波那契数列的第 n 项。

#### 30. 求矩阵的行列式
**题目：** 求一个矩阵的行列式。

**答案：**
```go
package main

import (
    "fmt"
)

func determinant(matrix [][]int) int {
    rows := len(matrix)
    cols := len(matrix[0])

    if rows != cols {
        panic("Matrix must be square")
    }

    if rows == 1 {
        return matrix[0][0]
    }

    det := 0
    for c := 0; c < cols; c++ {
        det += ((-1)^(c%2)) * matrix[0][c] * determinant(subMatrix(matrix, 0, c))
    }
    return det
}

func subMatrix(matrix [][]int, i int, j int) [][]int {
    var result [][]int
    for r := 1; r < len(matrix); r++ {
        var row []int
        for c := 0; c < len(matrix[0]); c++ {
            if c != j {
                row = append(row, matrix[r][c])
            }
        }
        result = append(result, row)
    }
    return result
}

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    result := determinant(matrix)
    fmt.Println("Determinant:", result)
}
```

**解析：** 使用递归求解矩阵的行列式，通过计算子矩阵的行列式并累加得到结果。

### 二、算法编程题库

#### 1. 合并两个有序链表
**题目：** 给定两个有序链表，合并两个链表并返回合并后的链表。

**答案：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}

    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 通过递归合并两个有序链表，每次比较当前节点的值，将较小的节点连接到结果链表中，并递归调用。

#### 2. 反转链表
**题目：** 给定一个链表，反转链表并返回新的链表。

**答案：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head

    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }

    return prev
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}

    newHead := reverseList(head)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 通过迭代反转链表，每次遍历将当前节点的 `next` 指向 `prev`，然后移动 `prev` 和 `current` 到下一个节点。

#### 3. 求两个数组的交集
**题目：** 给定两个整数数组，返回它们的交集。

**答案：**
```go
package main

import (
    "fmt"
)

func intersection(nums1 []int, nums2 []int) []int {
    m := make(map[int]bool)
    var result []int

    for _, num := range nums1 {
        m[num] = true
    }

    for _, num := range nums2 {
        if m[num] {
            result = append(result, num)
            delete(m, num)
        }
    }

    return result
}

func main() {
    nums1 := []int{4, 9, 5}
    nums2 := []int{9, 4, 9, 8, 4}
    result := intersection(nums1, nums2)
    fmt.Println("Intersection:", result)
}
```

**解析：** 使用哈希表记录数组 `nums1` 中的元素，然后遍历数组 `nums2`，将共有的元素添加到结果数组中。

#### 4. 求最大子序列和
**题目：** 给定一个整数数组，返回最大子序列和。

**答案：**
```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSoFar = max(maxSoFar, currSum)
    }

    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println("Maximum subarray sum:", result)
}
```

**解析：** 使用动态规划求解最大子序列和，遍历数组，更新当前最大和，并记录全局最大和。

#### 5. 求两个字符串的子序列
**题目：** 给定两个字符串，判断字符串 `s2` 是否是字符串 `s1` 的子序列。

**答案：**
```go
package main

import (
    "fmt"
)

func isSubsequence(s1, s2 string) bool {
    i, j := 0, 0

    for i < len(s1) && j < len(s2) {
        if s1[i] == s2[j] {
            j++
        }
        i++
    }

    return j == len(s2)
}

func main() {
    s1 := "abcde"
    s2 := "ace"
    result := isSubsequence(s1, s2)
    fmt.Println("Is subsequence:", result)
}
```

**解析：** 通过两个指针遍历字符串 `s1` 和 `s2`，判断 `s2` 是否是 `s1` 的子序列。

#### 6. 求字符串的长度
**题目：** 给定一个字符串，求其长度。

**答案：**
```go
package main

import (
    "fmt"
)

func lengthOfLastWord(s string) int {
    length := 0
    atWordStart := false
    atEnd := false

    for i := len(s) - 1; i >= 0; i-- {
        if s[i] != ' ' {
            if atEnd {
                length++
            }
            atEnd = true
            if !atWordStart {
                atWordStart = true
            }
        } else {
            atEnd = false
        }
    }

    return length
}

func main() {
    s := "Hello World"
    result := lengthOfLastWord(s)
    fmt.Println("Length of last word:", result)
}
```

**解析：** 通过遍历字符串，计算最后一个单词的长度。

#### 7. 求两个数的和
**题目：** 给定两个整数，返回它们的和。

**答案：**
```go
package main

import (
    "fmt"
)

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        x := 0
        y := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }

        sum := x + y + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10}
        current = current.Next
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}
    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}

    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 通过链表模拟加法，处理进位。

#### 8. 求两个数的最大公约数
**题目：** 给定两个整数，返回它们的最大公约数。

**答案：**
```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    a := 12
    b := 18
    result := gcd(a, b)
    fmt.Println("GCD:", result)
}
```

**解析：** 使用辗转相除法（欧几里得算法）求解最大公约数。

#### 9. 求最小公倍数
**题目：** 给定两个整数，返回它们的最小公倍数。

**答案：**
```go
package main

import (
    "fmt"
)

func lcm(a, b int) int {
    return (a / gcd(a, b)) * b
}

func main() {
    a := 12
    b := 18
    result := lcm(a, b)
    fmt.Println("LCM:", result)
}
```

**解析：** 使用最大公约数和最小公倍数的关系求解最小公倍数。

#### 10. 求字符串的长度
**题目：** 给定一个字符串，求其长度。

**答案：**
```go
package main

import (
    "fmt"
)

func lengthOfLastWord(s string) int {
    length := 0
    atWordStart := false
    atEnd := false

    for i := len(s) - 1; i >= 0; i-- {
        if s[i] != ' ' {
            if atEnd {
                length++
            }
            atEnd = true
            if !atWordStart {
                atWordStart = true
            }
        } else {
            atEnd = false
        }
    }

    return length
}

func main() {
    s := "Hello World"
    result := lengthOfLastWord(s)
    fmt.Println("Length of last word:", result)
}
```

**解析：** 通过遍历字符串，计算最后一个单词的长度。

#### 11. 求一个数组的和
**题目：** 给定一个整数数组，求其元素的和。

**答案：**
```go
package main

import (
    "fmt"
)

func sumArray(nums []int) int {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return sum
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := sumArray(nums)
    fmt.Println("Sum:", result)
}
```

**解析：** 通过遍历数组，计算所有元素的和。

#### 12. 求两个数的最大值
**题目：** 给定两个整数，返回它们的最大值。

**答案：**
```go
package main

import (
    "fmt"
)

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    a := 10
    b := 20
    result := max(a, b)
    fmt.Println("Maximum:", result)
}
```

**解析：** 使用比较运算符计算两个数的最大值。

#### 13. 求两个数的平均值
**题目：** 给定两个整数，返回它们的平均值。

**答案：**
```go
package main

import (
    "fmt"
)

func average(a, b int) float64 {
    return float64(a+b) / 2
}

func main() {
    a := 10
    b := 20
    result := average(a, b)
    fmt.Println("Average:", result)
}
```

**解析：** 将两个整数相加后除以 2，得到平均值。

#### 14. 求两个数的最小值
**题目：** 给定两个整数，返回它们的最小值。

**答案：**
```go
package main

import (
    "fmt"
)

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    a := 10
    b := 20
    result := min(a, b)
    fmt.Println("Minimum:", result)
}
```

**解析：** 使用比较运算符计算两个数的最小值。

#### 15. 求一个数的平方
**题目：** 给定一个整数，返回它的平方。

**答案：**
```go
package main

import (
    "fmt"
)

func square(a int) int {
    return a * a
}

func main() {
    a := 4
    result := square(a)
    fmt.Println("Square:", result)
}
```

**解析：** 将整数与自身相乘，得到平方值。

#### 16. 求一个数的三次方
**题目：** 给定一个整数，返回它的三次方。

**答案：**
```go
package main

import (
    "fmt"
)

func cube(a int) int {
    return a * a * a
}

func main() {
    a := 2
    result := cube(a)
    fmt.Println("Cube:", result)
}
```

**解析：** 将整数与自身相乘三次，得到三次方值。

#### 17. 求两个数的和
**题目：** 给定两个整数，返回它们的和。

**答案：**
```go
package main

import (
    "fmt"
)

func sum(a, b int) int {
    return a + b
}

func main() {
    a := 10
    b := 20
    result := sum(a, b)
    fmt.Println("Sum:", result)
}
```

**解析：** 使用加法运算符计算两个数的和。

#### 18. 求一个数组的平均值
**题目：** 给定一个整数数组，返回它们的平均值。

**答案：**
```go
package main

import (
    "fmt"
)

func average(nums []int) float64 {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return float64(sum) / float64(len(nums))
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := average(nums)
    fmt.Println("Average:", result)
}
```

**解析：** 通过遍历数组，计算所有元素的和，然后除以数组长度得到平均值。

#### 19. 求一个数组的最大值
**题目：** 给定一个整数数组，返回它们的最大值。

**答案：**
```go
package main

import (
    "fmt"
)

func max(nums []int) int {
    maxNum := nums[0]
    for _, num := range nums {
        if num > maxNum {
            maxNum = num
        }
    }
    return maxNum
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := max(nums)
    fmt.Println("Maximum:", result)
}
```

**解析：** 通过遍历数组，找到最大值。

#### 20. 求一个数组的和
**题目：** 给定一个整数数组，返回它们的和。

**答案：**
```go
package main

import (
    "fmt"
)

func sum(nums []int) int {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return sum
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := sum(nums)
    fmt.Println("Sum:", result)
}
```

**解析：** 通过遍历数组，计算所有元素的和。

#### 21. 求两个数的和
**题目：** 给定两个整数，返回它们的和。

**答案：**
```go
package main

import (
    "fmt"
)

func sum(a, b int) int {
    return a + b
}

func main() {
    a := 10
    b := 20
    result := sum(a, b)
    fmt.Println("Sum:", result)
}
```

**解析：** 使用加法运算符计算两个数的和。

#### 22. 求一个数组的平均值
**题目：** 给定一个整数数组，返回它们的平均值。

**答案：**
```go
package main

import (
    "fmt"
)

func average(nums []int) float64 {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return float64(sum) / float64(len(nums))
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := average(nums)
    fmt.Println("Average:", result)
}
```

**解析：** 通过遍历数组，计算所有元素的和，然后除以数组长度得到平均值。

#### 23. 求两个数的最大公约数
**题目：** 给定两个整数，返回它们的最大公约数。

**答案：**
```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    a := 12
    b := 18
    result := gcd(a, b)
    fmt.Println("GCD:", result)
}
```

**解析：** 使用辗转相除法（欧几里得算法）求解最大公约数。

#### 24. 求两个数的最小公倍数
**题目：** 给定两个整数，返回它们的最小公倍数。

**答案：**
```go
package main

import (
    "fmt"
)

func lcm(a, b int) int {
    return (a / gcd(a, b)) * b
}

func main() {
    a := 12
    b := 18
    result := lcm(a, b)
    fmt.Println("LCM:", result)
}
```

**解析：** 使用最大公约数和最小公倍数的关系求解最小公倍数。

#### 25. 求一个数组的最大值
**题目：** 给定一个整数数组，返回它们的最大值。

**答案：**
```go
package main

import (
    "fmt"
)

func max(nums []int) int {
    maxNum := nums[0]
    for _, num := range nums {
        if num > maxNum {
            maxNum = num
        }
    }
    return maxNum
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := max(nums)
    fmt.Println("Maximum:", result)
}
```

**解析：** 通过遍历数组，找到最大值。

#### 26. 求一个数组的和
**题目：** 给定一个整数数组，返回它们的和。

**答案：**
```go
package main

import (
    "fmt"
)

func sum(nums []int) int {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return sum
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := sum(nums)
    fmt.Println("Sum:", result)
}
```

**解析：** 通过遍历数组，计算所有元素的和。

#### 27. 求两个数的和
**题目：** 给定两个整数，返回它们的和。

**答案：**
```go
package main

import (
    "fmt"
)

func sum(a, b int) int {
    return a + b
}

func main() {
    a := 10
    b := 20
    result := sum(a, b)
    fmt.Println("Sum:", result)
}
```

**解析：** 使用加法运算符计算两个数的和。

#### 28. 求一个数组的平均值
**题目：** 给定一个整数数组，返回它们的平均值。

**答案：**
```go
package main

import (
    "fmt"
)

func average(nums []int) float64 {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return float64(sum) / float64(len(nums))
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := average(nums)
    fmt.Println("Average:", result)
}
```

**解析：** 通过遍历数组，计算所有元素的和，然后除以数组长度得到平均值。

#### 29. 求两个数的最大公约数
**题目：** 给定两个整数，返回它们的最大公约数。

**答案：**
```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    a := 12
    b := 18
    result := gcd(a, b)
    fmt.Println("GCD:", result)
}
```

**解析：** 使用辗转相除法（欧几里得算法）求解最大公约数。

#### 30. 求两个数的最小公倍数
**题目：** 给定两个整数，返回它们的最小公倍数。

**答案：**
```go
package main

import (
    "fmt"
)

func lcm(a, b int) int {
    return (a / gcd(a, b)) * b
}

func main() {
    a := 12
    b := 18
    result := lcm(a, b)
    fmt.Println("LCM:", result)
}
```

**解析：** 使用最大公约数和最小公倍数的关系求解最小公倍数。

