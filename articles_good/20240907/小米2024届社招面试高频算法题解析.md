                 

### 小米2024届社招面试高频算法题解析

#### 目录

1. [最长公共子序列](#1-最长公共子序列)
2. [二分查找](#2-二分查找)
3. [合并区间](#3-合并区间)
4. [单调栈](#4-单调栈)
5. [最长递增子序列](#5-最长递增子序列)
6. [滑动窗口](#6-滑动窗口)
7. [动态规划](#7-动态规划)
8. [树与二叉树](#8-树与二叉树)
9. [图算法](#9-图算法)
10. [位操作](#10-位操作)
11. [数学问题](#11-数学问题)
12. [字符串处理](#12-字符串处理)
13. [排序算法](#13-排序算法)
14. [回溯算法](#14-回溯算法)
15. [快慢指针](#15-快慢指针)
16. [双指针](#16-双指针)
17. [贪心算法](#17-贪心算法)
18. [队列](#18-队列)
19. [堆](#19-堆)
20. [拓扑排序](#20-拓扑排序)
21. [并查集](#21-并查集)

---

#### 1. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**示例：**

```text
text1 = "abcde"
text2 = "ace"
```

**答案：** 

```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划求解最长公共子序列，时间复杂度为 \(O(m \times n)\)，空间复杂度为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别为两个字符串的长度。

---

#### 2. 二分查找

**题目：** 给定一个排序后的数组 `nums` 和一个目标值 `target`，找出 `target` 在数组中的索引，如果不存在，返回 `-1`。

**示例：**

```text
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
```

**答案：** 

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return -1
}
```

**解析：** 使用二分查找算法，时间复杂度为 \(O(\log n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为数组长度。

---

#### 3. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**

```text
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**答案：** 

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for _, interval := range intervals[1:] {
        last := len(ans) - 1
        if ans[last][1] >= interval[0] {
            ans[last] = []int{ans[last][0], max(ans[last][1], interval[1])}
        } else {
            ans = append(ans, interval)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 首先对区间进行排序，然后遍历合并重叠的区间，时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为区间数量。

---

#### 4. 单调栈

**题目：** 给定一个数组 `nums`，找到每个元素的下一个更大元素。

**示例：**

```text
nums = [2,1,2,4,3]
```

**答案：** 

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    stack := []int{-1}
    for i := 0; i < 2*n; i++ {
        for nums[i%n] > stack[len(stack)-1] {
            stack = stack[:len(stack)-1]
        }
        if stack[len(stack)-1] != -1 {
            ans[i%n] = stack[len(stack)-1]
        } else {
            ans[i%n] = -1
        }
        stack = append(stack, nums[i%n])
    }
    return ans
}
```

**解析：** 使用单调栈求解，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为数组长度。

---

#### 5. 最长递增子序列

**题目：** 给定一个无序数组 `nums`，找出最长递增子序列的长度。

**示例：**

```text
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

**答案：** 

```go
func lengthOfLIS(nums []int) int {
    d := make([]int, len(nums))
    for i := range d {
        d[i] = 1
    }
    for i := 0; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                d[i] = max(d[i], d[j]+1)
            }
        }
    }
    ans := 0
    for _, v := range d {
        ans = max(ans, v)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划求解最长递增子序列长度，时间复杂度为 \(O(n^2)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为数组长度。

---

#### 6. 滑动窗口

**题目：** 给定一个字符串 `s` 和一个整数 `k`，找到所有长度为 `k` 的子串中，包含所有 `s` 中字符的最小窗口。

**示例：**

```text
s = "ADOBECODEBANC", k = 4
```

**答案：** 

```go
func minWindow(s string, t string, k int) string {
    cnt := [128]int{}
    for _, c := range t {
        cnt[c]++;
    }
    cntT := len(t)
    left, right := 0, 0
    ans := ""
    while:
        cnt[s[right]]--
        if cnt[s[right]] >= 0 {
            cntT--
        }
        if cntT == 0 {
            whileStart := left
            whileEnd := right
            for ; left < right; left++ {
                if cnt[s[left]] < 0 {
                    whileStart++
                    cnt[s[left]]++
                }
            }
            if len(ans) == 0 || (right - left + 1) < len(ans) {
                ans = s[whileStart : whileEnd+1]
            }
            cntT++
            cnt[s[left]]++
        }
        right++
        if right-left == k {
            left++
            cnt[s[left-1]]++
            cntT--
        }
    return ans
}
```

**解析：** 使用滑动窗口求解，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(128)\)，其中 \(n\) 为字符串 `s` 的长度。

---

#### 7. 动态规划

**题目：** 给定一个整数数组 `nums`，找出所有连续子数组的和最大值。

**示例：**

```text
nums = [1, -2, 3, 4]
```

**答案：** 

```go
func maxSubArray(nums []int) int {
    ans := nums[0]
    cur := nums[0]
    for i := 1; i < len(nums); i++ {
        cur = max(nums[i], cur+nums[i])
        ans = max(ans, cur)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划求解最大子数组和，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为数组长度。

---

#### 8. 树与二叉树

**题目：** 给定一个二叉树，求其最大深度。

**示例：**

```text
    3
   / \
  9  20
    /  \
   15   7
```

**答案：**

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    left := maxDepth(root.Left)
    right := maxDepth(root.Right)
    return 1 + max(left, right)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

**解析：** 使用递归求解二叉树的最大深度，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为二叉树的节点数量。

---

#### 9. 图算法

**题目：** 给定一个无向图，判断是否存在一条路径，使得节点值依次递增。

**示例：**

```text
nodes = [
    [2, 6, 3],
    [1, 3],
    [1, 4],
    [4, 6],
    [1, 7],
    [7, 4],
]
```

**答案：**

```go
func validPath(graph [][]int, start, target int) bool {
    g := make([][]int, len(graph))
    for i := range g {
        g[i] = make([]int, 0, len(graph[i]))
        for _, v := range graph[i] {
            g[i] = append(g[i], v)
        }
        sort.Ints(g[i])
    }
    vis := make([]bool, len(graph))
    var dfs func(start, target int) bool
    dfs = func(start, target int) bool {
        if start == target {
            return true
        }
        if vis[start] {
            return false
        }
        vis[start] = true
        for _, v := range g[start] {
            if dfs(v, target) {
                return true
            }
        }
        return false
    }
    return dfs(start, target)
}
```

**解析：** 使用深度优先搜索（DFS）判断图中是否存在一条路径，使得节点值依次递增，时间复杂度为 \(O(n + m)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为节点数量，\(m\) 为边数量。

---

#### 10. 位操作

**题目：** 给定一个整数 `n`，返回其二进制表示中 1 的个数。

**示例：**

```text
n = 00000000000000000000000000001011
```

**答案：**

```go
func hammingWeight(num uint32) int {
    ans := 0
    for num != 0 {
        ans++
        num &= num - 1
    }
    return ans
}
```

**解析：** 使用位操作计算整数中 1 的个数，时间复杂度为 \(O(\log n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为输入整数的位数。

---

#### 11. 数学问题

**题目：** 给定一个非负整数 `num`，计算它的立方根。

**示例：**

```text
num = 27
```

**答案：**

```go
func myCbrt(num int) float64 {
    l, r := 0, num
    for l <= r {
        mid := (l + r) / 2
        if mid*mid*mid == num {
            return float64(mid)
        } else if mid*mid*mid < num {
            l = mid + 1
        } else {
            r = mid - 1
        }
    }
    return float64(r)
}
```

**解析：** 使用二分查找计算整数的立方根，时间复杂度为 \(O(\log n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为输入整数的立方。

---

#### 12. 字符串处理

**题目：** 给定一个字符串 `s`，找出它的最长重复子串。

**示例：**

```text
s = "banana"
```

**答案：**

```go
func longestRepeatingSubstring(s string) string {
    n := len(s)
    for i := 1; i <= n/2; i++ {
        if n%i == 0 {
            return substring(s, 0, i)
        }
    }
    return ""
}

func substring(s string, start, end int) string {
    return s[start:end]
}
```

**解析：** 遍历字符串长度的一半，找出最长重复子串，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为字符串长度。

---

#### 13. 排序算法

**题目：** 给定一个整数数组 `arr`，使用快速排序进行排序。

**示例：**

```text
arr = [5, 2, 9, 1]
```

**答案：**

```go
func quickSort(arr []int, left, right int) {
    if left >= right {
        return
    }
    pivot := arr[right]
    i := left
    for j := left; j < right; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[right] = arr[right], arr[i]
    quickSort(arr, left, i-1)
    quickSort(arr, i+1, right)
}
```

**解析：** 使用快速排序对数组进行排序，时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(\log n)\)，其中 \(n\) 为数组长度。

---

#### 14. 回溯算法

**题目：** 给定一个无重复数字的数组 `nums`，返回其所有可能的排列。

**示例：**

```text
nums = [1, 2, 3]
```

**答案：**

```go
func permute(nums []int) [][]int {
    ans := [][]int{}
    used := make([]bool, len(nums))
    path := []int{}
    var dfs func() 
    dfs = func() {
        if len(path) == len(nums) {
            t := make([]int, len(path))
            copy(t, path)
            ans = append(ans, t)
            return
        }
        for i, v := range nums {
            if used[i] {
                continue
            }
            used[i] = true
            path = append(path, v)
            dfs()
            path = path[:len(path)-1]
            used[i] = false
        }
    }
    dfs()
    return ans
}
```

**解析：** 使用回溯算法求解全排列，时间复杂度为 \(O(n \times n!)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为数组长度。

---

#### 15. 快慢指针

**题目：** 给定一个链表，返回链表的中间节点。

**示例：**

```text
head = [1, 2, 3, 4, 5]
```

**答案：**

```go
func middleNode(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
    }
    return slow
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

**解析：** 使用快慢指针找出链表的中间节点，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为链表长度。

---

#### 16. 双指针

**题目：** 给定一个无序数组 `nums`，找出其中的最长递增子序列。

**示例：**

```text
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

**答案：**

```go
func lengthOfLIS(nums []int) int {
    d := make([]int, len(nums))
    for i := range d {
        d[i] = 1
    }
    for i := 0; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                d[i] = max(d[i], d[j]+1)
            }
        }
    }
    ans := 0
    for _, v := range d {
        ans = max(ans, v)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用双指针和动态规划求解最长递增子序列长度，时间复杂度为 \(O(n^2)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为数组长度。

---

#### 17. 贪心算法

**题目：** 给定一个无序数组 `nums`，将其排序。

**示例：**

```text
nums = [5, 2, 9, 1]
```

**答案：**

```go
func heapSort(nums []int) {
    n := len(nums)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(nums, n, i)
    }
    for i := n - 1; i >= 0; i-- {
        nums[0], nums[i] = nums[i], nums[0]
        heapify(nums, i, 0)
    }
}

func heapify(nums []int, n, i int) {
    largest := i
    l := 2*i + 1
    r := 2*i + 2
    if l < n && nums[l] > nums[largest] {
        largest = l
    }
    if r < n && nums[r] > nums[largest] {
        largest = r
    }
    if largest != i {
        nums[i], nums[largest] = nums[largest], nums[i]
        heapify(nums, n, largest)
    }
}
```

**解析：** 使用贪心算法和堆排序对数组进行排序，时间复杂度为 \(O(n \log n)\)，空间复杂度为 \(O(1)\)，其中 \(n\) 为数组长度。

---

#### 18. 队列

**题目：** 给定一个整数数组 `nums`，实现一个队列，支持以下操作：

- `appendTail(value)`：向队列尾部添加一个元素 `value`。
- `deleteHead()`：删除队列头部的一个元素，如果队列为空，则不进行操作。

**示例：**

```text
nums = [5, 7, 7, 8, 2, 8, 1, 4]
```

**答案：**

```go
type CustomQueue struct {
    queue []int
    head  int
}

func Constructor() CustomQueue {
    return CustomQueue{queue: make([]int, len(nums))}
}

func (this *CustomQueue) AppendTail(value int) {
    this.queue = append(this.queue, value)
}

func (this *CustomQueue) DeleteHead() {
    if this.head < len(this.queue) {
        this.queue = this.queue[this.head+1:]
        this.head++
    }
}
```

**解析：** 使用队列实现一个支持尾部插入和头部删除的队列，时间复杂度为 \(O(1)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为数组长度。

---

#### 19. 堆

**题目：**

**解析：**

---

#### 20. 拓扑排序

**题目：** 给定一个无向图，求其拓扑排序。

**示例：**

```text
graph = [
    [2, 6],
    [1, 6],
    [4, 6],
    [7, 6],
    [7, 5],
    [1, 2],
    [2, 3],
    [3, 4],
    [5, 4],
]
```

**答案：**

```go
func topologicalSort(edges [][]int, numCourses int) []int {
    g := make([][]int, numCourses)
    indeg := make([]int, numCourses)
    for _, edge := range edges {
        u, v := edge[0], edge[1]
        g[u] = append(g[u], v)
        indeg[v]++
    }
    q := []int{}
    for i, v := range indeg {
        if v == 0 {
            q = append(q, i)
        }
    }
    ans := []int{}
    for len(q) > 0 {
        v := q[0]
        q = q[1:]
        ans = append(ans, v)
        for _, w := range g[v] {
            indeg[w]--
            if indeg[w] == 0 {
                q = append(q, w)
            }
        }
    }
    return ans
}
```

**解析：** 使用拓扑排序求解，时间复杂度为 \(O(n + m)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为节点数量，\(m\) 为边数量。

---

#### 21. 并查集

**题目：** 给定一个无向图，判断是否存在一个三角形。

**示例：**

```text
edges = [
    [2, 3],
    [3, 1],
    [1, 2],
]
```

**答案：**

```go
func validTree(n int, edges [][]int) bool {
    p := make([]int, n)
    for i := range p {
        p[i] = i
    }
    for _, edge := range edges {
        u, v := edge[0], edge[1]
        rootU, rootV := find(u), find(v)
        if rootU == rootV {
            return false
        }
        p[rootU] = rootV
    }
    return n == len(edges)
}

func find(x int) int {
    if p[x] != x {
        p[x] = find(p[x])
    }
    return p[x]
}
```

**解析：** 使用并查集求解，时间复杂度为 \(O(n)\)，空间复杂度为 \(O(n)\)，其中 \(n\) 为节点数量。

