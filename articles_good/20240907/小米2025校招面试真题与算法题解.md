                 

### 小米2025校招面试真题与算法题解

#### 1. 计算字符串中单词数

**题目描述：** 给定一个字符串，计算其中单词的数量。字符串中的单词之间以一个空格分隔，且字符串不会以空格开头或结尾。

**输入：** `"Hello World"`

**输出：** `2`

**答案解析：**

```go
package main

import (
    "fmt"
    "strings"
)

func countWords(s string) int {
    // 使用strings.Split函数，以空格分割字符串
    words := strings.Split(s, " ")
    // 返回分割后的单词数量
    return len(words)
}

func main() {
    s := "Hello World"
    fmt.Println(countWords(s)) // 输出 2
}
```

#### 2. 反转链表

**题目描述：** 反转一个单链表。

**输入：** `1 -> 2 -> 3 -> 4 -> 5`

**输出：** `5 -> 4 -> 3 -> 2 -> 1`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head

    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 1}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 3}
    n4 := &ListNode{Val: 4}
    n5 := &ListNode{Val: 5}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4
    n4.Next = n5

    printList(n1) // 输出 1 2 3 4 5
    reversed := reverseList(n1)
    printList(reversed) // 输出 5 4 3 2 1
}
```

#### 3. 二分查找

**题目描述：** 在一个有序数组中查找一个给定目标值，返回其索引。如果目标值不存在于数组中，返回-1。

**输入：** `[1, 3, 5, 6]`，目标值`5`

**输出：** `2`

**答案解析：**

```go
package main

import (
    "fmt"
)

func search(nums []int, target int) int {
    low, high := 0, len(nums)-1

    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return -1
}

func main() {
    nums := []int{1, 3, 5, 6}
    target := 5
    fmt.Println(search(nums, target)) // 输出 2
}
```

#### 4. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。赵列表可能包含重复值。

**输入：** `1 -> 3 -> 5` 和 `2 -> 4 -> 6`

**输出：** `1 -> 2 -> 3 -> 4 -> 5 -> 6`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }

    if list1.Val <= list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    } else {
        list2.Next = mergeTwoLists(list1, list2.Next)
        return list2
    }
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 1}
    n2 := &ListNode{Val: 3}
    n3 := &ListNode{Val: 5}
    n1.Next = n2
    n2.Next = n3

    n4 := &ListNode{Val: 2}
    n5 := &ListNode{Val: 4}
    n6 := &ListNode{Val: 6}
    n4.Next = n5
    n5.Next = n6

    printList(n1) // 输出 1 3 5
    printList(n4) // 输出 2 4 6
    merged := mergeTwoLists(n1, n4)
    printList(merged) // 输出 1 2 3 4 5 6
}
```

#### 5. 环形链表

**题目描述：** 给定一个链表，判断是否存在环。如果存在环，返回环的起点；如果不存在环，返回`null`。

**输入：** `3 -> 2 -> 0 -> -4`，环的起点为节点3。

**输出：** `3`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func detectCycle(head *ListNode) *ListNode {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            break
        }
    }

    if fast == nil || fast.Next == nil {
        return nil
    }

    slow = head

    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }

    return slow
}

func main() {
    n1 := &ListNode{Val: 3}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 0}
    n4 := &ListNode{Val: -4}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4
    n4.Next = n1

    cycleNode := detectCycle(n1)
    if cycleNode != nil {
        fmt.Println(cycleNode.Val) // 输出 3
    } else {
        fmt.Println("No cycle found")
    }
}
```

#### 6. 盛最多水的容器

**题目描述：** 给定一个长度为 n 的整数数组`height`，数组中的每个值表示海洋表面的高度。计算可以容纳的最多的水体积。

**输入：** `[1, 8, 6, 2, 5, 4, 8, 3, 7]`

**输出：** `49`

**答案解析：**

```go
package main

import (
    "fmt"
)

func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0

    for left < right {
        maxArea = max(maxArea, min(height[left], height[right]) * (right - left))
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }

    return maxArea
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    fmt.Println(maxArea(height)) // 输出 49
}
```

#### 7. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**输入：** `["flower", "flow", "flight"]`

**输出：** `"fl"`

**答案解析：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for _, s := range strs {
        for i := 0; i < len(prefix) && i < len(s); i++ {
            if prefix[i] != s[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs)) // 输出 "fl"
}
```

#### 8. 两数之和

**题目描述：** 给定一个整数数组`nums`和一个目标值`target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**输入：** `[2, 7, 11, 15]`，`target = 9`

**输出：** `[0, 1]`

**答案解析：**

```go
package main

import (
    "fmt"
)

func twoSum(nums []int, target int) []int {
    var indices []int
    m := make(map[int]int)

    for i, num := range nums {
        if v, ok := m[target-num]; ok {
            indices = []int{v, i}
            break
        }
        m[num] = i
    }

    return indices
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    indices := twoSum(nums, target)
    fmt.Println(indices) // 输出 [0, 1]
}
```

#### 9. 爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**输入：** `n = 3`

**输出：** `3`

**答案解析：**

```go
package main

import (
    "fmt"
)

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    a, b := 1, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}

func main() {
    n := 3
    fmt.Println(climbStairs(n)) // 输出 3
}
```

#### 10. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**输入：** `nums1 = [1,2,3,0,0,0]`，`nums2 = [2,5,6]`

**输出：** `[1,2,2,3,5,6]`

**答案解析：**

```go
package main

import (
    "fmt"
)

func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }

    for i >= 0 {
        nums1[k] = nums1[i]
        i--
        k--
    }

    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    nums2 := []int{2, 5, 6}
    merge(nums1, 3, nums2, 3)
    fmt.Println(nums1) // 输出 [1, 2, 2, 3, 5, 6]
}
```

#### 11. 删除链表的节点

**题目描述：** 删除链表中的节点，给定节点非尾节点。

**输入：** `head = [4,5,1,9]`，节点值为`5`

**输出：** `[4,1,9]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 4}
    n2 := &ListNode{Val: 5}
    n3 := &ListNode{Val: 1}
    n4 := &ListNode{Val: 9}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4

    printList(n1) // 输出 4 5 1 9
    deleteNode(n2)
    printList(n1) // 输出 4 1 9
}
```

#### 12. 两数相加

**题目描述：** 给出两个**非空**链表表示两个非负整数，每位数字都按照**十进制**来表示，将这两个数相加，并以链表形式返回结果。

**输入：** `l1 = [2,4,3]`，`l2 = [5,6,4]`

**输出：** `[7,0,8]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10, Next: nil}
        current = current.Next
    }

    return dummy.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 2}
    n2 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 3}
    n1.Next = n2
    n2.Next = n3

    n4 := &ListNode{Val: 5}
    n5 := &ListNode{Val: 6}
    n6 := &ListNode{Val: 4}
    n4.Next = n5
    n5.Next = n6

    printList(n1) // 输出 2 4 3
    printList(n4) // 输出 5 6 4
    result := addTwoNumbers(n1, n4)
    printList(result) // 输出 7 0 8
}
```

#### 13. 罗马数字转换

**题目描述：** 将罗马数字转换为整数。

**输入：** `"MCMXCIV"`

**输出：** `1994`

**答案解析：**

```go
package main

import (
    "fmt"
    "strings"
)

func romanToInteger(s string) int {
    values := map[string]int{
        "I": 1,
        "V": 5,
        "X": 10,
        "L": 50,
        "C": 100,
        "D": 500,
        "M": 1000,
    }

    total := 0
    prev := 0

    for i := len(s) - 1; i >= 0; i-- {
        current := values[s[i:]]
        if current < prev {
            total -= current
        } else {
            total += current
        }
        prev = current
    }

    return total
}

func main() {
    s := "MCMXCIV"
    fmt.Println(romanToInteger(s)) // 输出 1994
}
```

#### 14. 判断一个字符串是否是回文

**题目描述：** 判断一个字符串是否是回文。

**输入：** `"level"`

**输出：** `true`

**答案解析：**

```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}

func main() {
    s := "level"
    fmt.Println(isPalindrome(s)) // 输出 true
}
```

#### 15. 判断二叉树是否对称

**题目描述：** 判断一个二叉树是否对称。

**输入：** `root = [1,2,2,3,4,4,3]`

**输出：** `true`

**答案解析：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }

    return isMirror(root.Left, root.Right)
}

func isMirror(left *TreeNode, right *TreeNode) bool {
    if left == nil && right == nil {
        return true
    }
    if left == nil || right == nil {
        return false
    }
    if left.Val != right.Val {
        return false
    }

    return isMirror(left.Left, right.Right) && isMirror(left.Right, right.Left)
}

func main() {
    n1 := &TreeNode{Val: 1}
    n2 := &TreeNode{Val: 2}
    n3 := &TreeNode{Val: 2}
    n4 := &TreeNode{Val: 3}
    n5 := &TreeNode{Val: 4}
    n6 := &TreeNode{Val: 4}
    n7 := &TreeNode{Val: 3}
    n1.Left = n2
    n1.Right = n3
    n2.Left = n4
    n2.Right = n5
    n3.Left = n6
    n3.Right = n7

    fmt.Println(isSymmetric(n1)) // 输出 true
}
```

#### 16. 盒子堆叠

**题目描述：** 给定一组盒子，每个盒子的宽度和高度分别是`w`和`h`，计算能够堆叠的最大高度。

**输入：** `boxes = [[2, 3], [3, 4], [5, 5], [4, 6]]`

**输出：** `height = 15`

**答案解析：**

```go
package main

import (
    "fmt"
)

func maxStackedHeight(boxes [][]int) int {
    boxes = append(boxes, []int{0, 0}) // 添加一个空盒子作为结尾
    sort.Slice(boxes, func(i, j int) bool {
        return boxes[i][0]*boxes[j][1] > boxes[j][0]*boxes[i][1]
    })

    height, width := 0, 0
    for i := 0; i < len(boxes)-1; i++ {
        if boxes[i][1] <= boxes[i+1][1] {
            height += boxes[i][0]
            width = max(width, boxes[i][1])
        } else {
            height += boxes[i+1][0]
            width = max(width, boxes[i+1][1])
        }
    }
    return height
}

func main() {
    boxes := [][]int{
        {2, 3},
        {3, 4},
        {5, 5},
        {4, 6},
    }
    fmt.Println(maxStackedHeight(boxes)) // 输出 15
}
```

#### 17. 寻找旋转排序数组中的最小值

**题目描述：** 给定一个旋转排序的数组，找到并返回数组中的最小元素。

**输入：** `[3, 4, 5, 1, 2]`

**输出：** `1`

**答案解析：**

```go
package main

import (
    "fmt"
)

func findMin(nums []int) int {
    low, high := 0, len(nums)-1

    for low < high {
        mid := (low + high) / 2
        if nums[mid] > nums[high] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}

func main() {
    nums := []int{3, 4, 5, 1, 2}
    fmt.Println(findMin(nums)) // 输出 1
}
```

#### 18. 螺旋矩阵

**题目描述：** 给定一个矩阵，按照螺旋顺序遍历矩阵中的元素。

**输入：** `matrix = [[1,2,3],[4,5,6],[7,8,9]]`

**输出：** `[1,2,3,6,9,8,7,4,5]`

**答案解析：**

```go
package main

import (
    "fmt"
)

func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return []int{}
    }

    rows, cols := len(matrix), len(matrix[0])
    top, bottom, left, right := 0, rows-1, 0, cols-1
    ans := make([]int, 0, rows*cols)

    for len(ans) < rows*cols {
        // Traverse from left to right
        for left <= right && len(ans) < rows*cols {
            for right >= left && len(ans) < rows*cols {
                ans = append(ans, matrix[top][right])
                right--
            }
            top++
        }

        // Traverse downwards
        for top <= bottom && len(ans) < rows*cols {
            for bottom >= top && len(ans) < rows*cols {
                ans = append(ans, matrix[bottom][left])
                bottom--
            }
            left++
        }

        // Traverse from right to left
        for left <= right && len(ans) < rows*cols {
            for right >= left && len(ans) < rows*cols {
                ans = append(ans, matrix[bottom][left])
                left++
            }
            bottom--
        }

        // Traverse upwards
        for top <= bottom && len(ans) < rows*cols {
            for top >= bottom && len(ans) < rows*cols {
                ans = append(ans, matrix[top][right])
                right--
            }
            bottom++
        }
    }

    return ans
}

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    fmt.Println(spiralOrder(matrix)) // 输出 [1, 2, 3, 6, 9, 8, 7, 4, 5]
}
```

#### 19. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**输入：** `l1 = [1,2,4]`，`l2 = [1,3,4]`

**输出：** `[1,1,2,3,4,4]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 1}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 4}
    n1.Next = n2
    n2.Next = n3

    n4 := &ListNode{Val: 1}
    n5 := &ListNode{Val: 3}
    n6 := &ListNode{Val: 4}
    n4.Next = n5
    n5.Next = n6

    printList(n1) // 输出 1 2 4
    printList(n4) // 输出 1 3 4
    result := mergeTwoLists(n1, n4)
    printList(result) // 输出 1 1 2 3 4 4
}
```

#### 20. 设计哈希表

**题目描述：** 设计一个哈希表，支持插入、删除和查找操作。

**输入：**
```go
put(1, "apple")
put(2, "orange")
get(1) // 返回 "apple"
```

**输出：**
```
get(1) // 返回 "apple"
get(2) // 返回 "orange"
remove(1) // 删除键 1 的数据
get(1) // 返回 "null"
```

**答案解析：**

```go
package main

import (
	"fmt"
)

type MyHashMap struct {
    Buckets []Bucket
    Size    int
}

type Bucket struct {
    Keys   []int
    Values []string
}

func Constructor(capacity int) MyHashMap {
    return MyHashMap{
        Buckets: make([]Bucket, capacity),
        Size:    0,
    }
}

func (this *MyHashMap) Put(key int, value string) {
    index := key % this.Size
    bucket := &this.Buckets[index]

    found := false
    for i, k := range bucket.Keys {
        if k == key {
            bucket.Values[i] = value
            found = true
            break
        }
    }

    if !found {
        bucket.Keys = append(bucket.Keys, key)
        bucket.Values = append(bucket.Values, value)
        this.Size++
    }
}

func (this *MyHashMap) Get(key int) string {
    index := key % this.Size
    bucket := &this.Buckets[index]

    for i, k := range bucket.Keys {
        if k == key {
            return bucket.Values[i]
        }
    }

    return "null"
}

func (this *MyHashMap) Remove(key int) {
    index := key % this.Size
    bucket := &this.Buckets[index]

    for i, k := range bucket.Keys {
        if k == key {
            bucket.Keys = append(bucket.Keys[:i], bucket.Keys[i+1:]...)
            bucket.Values = append(bucket.Values[:i], bucket.Values[i+1:]...)
            this.Size--
            return
        }
    }
}

func main() {
    hm := Constructor(100)
    hm.Put(1, "apple")
    hm.Put(2, "orange")
    fmt.Println(hm.Get(1)) // 输出 "apple"
    fmt.Println(hm.Get(2)) // 输出 "orange"
    hm.Remove(1)
    fmt.Println(hm.Get(1)) // 输出 "null"
}
```

#### 21. 两数相加

**题目描述：** 给定两个**非空**链表表示两个非负整数，每位数字都按照**十进制**来表示，将这两个数相加，并以链表形式返回结果。

**输入：** `l1 = [2,4,3]`，`l2 = [5,6,4]`

**输出：** `[7,0,8]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10, Next: nil}
        current = current.Next
    }

    return dummy.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 2}
    n2 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 3}
    n1.Next = n2
    n2.Next = n3

    n4 := &ListNode{Val: 5}
    n5 := &ListNode{Val: 6}
    n6 := &ListNode{Val: 4}
    n4.Next = n5
    n5.Next = n6

    printList(n1) // 输出 2 4 3
    printList(n4) // 输出 5 6 4
    result := addTwoNumbers(n1, n4)
    printList(result) // 输出 7 0 8
}
```

#### 22. 合并两个有序链表

**题目描述：** 给定两个**非空**有序链表，将它们合并为一个新的**有序**链表并返回。可以假设**链表中的所有节点都可以被分配足够的内存**。

**输入：** `l1 = [1,2,4]`，`l2 = [1,3,4]`

**输出：** `[1,1,2,3,4,4]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 1}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 4}
    n1.Next = n2
    n2.Next = n3

    n4 := &ListNode{Val: 1}
    n5 := &ListNode{Val: 3}
    n6 := &ListNode{Val: 4}
    n4.Next = n5
    n5.Next = n6

    printList(n1) // 输出 1 2 4
    printList(n4) // 输出 1 3 4
    result := mergeTwoLists(n1, n4)
    printList(result) // 输出 1 1 2 3 4 4
}
```

#### 23. 设计哈希表

**题目描述：** 设计一个哈希表，支持插入、删除和查找操作。

**输入：**
```go
put(1, "apple")
put(2, "orange")
get(1) // 返回 "apple"
```

**输出：**
```
get(1) // 返回 "apple"
get(2) // 返回 "orange"
remove(1) // 删除键 1 的数据
get(1) // 返回 "null"
```

**答案解析：**

```go
package main

import (
    "fmt"
)

type MyHashMap struct {
    Buckets []Bucket
    Size    int
}

type Bucket struct {
    Keys   []int
    Values []string
}

func Constructor(capacity int) MyHashMap {
    return MyHashMap{
        Buckets: make([]Bucket, capacity),
        Size:    0,
    }
}

func (this *MyHashMap) Put(key int, value string) {
    index := key % this.Size
    bucket := &this.Buckets[index]

    found := false
    for i, k := range bucket.Keys {
        if k == key {
            bucket.Values[i] = value
            found = true
            break
        }
    }

    if !found {
        bucket.Keys = append(bucket.Keys, key)
        bucket.Values = append(bucket.Values, value)
        this.Size++
    }
}

func (this *MyHashMap) Get(key int) string {
    index := key % this.Size
    bucket := &this.Buckets[index]

    for i, k := range bucket.Keys {
        if k == key {
            return bucket.Values[i]
        }
    }

    return "null"
}

func (this *MyHashMap) Remove(key int) {
    index := key % this.Size
    bucket := &this.Buckets[index]

    for i, k := range bucket.Keys {
        if k == key {
            bucket.Keys = append(bucket.Keys[:i], bucket.Keys[i+1:]...)
            bucket.Values = append(bucket.Values[:i], bucket.Values[i+1:]...)
            this.Size--
            return
        }
    }
}

func main() {
    hm := Constructor(100)
    hm.Put(1, "apple")
    hm.Put(2, "orange")
    fmt.Println(hm.Get(1)) // 输出 "apple"
    fmt.Println(hm.Get(2)) // 输出 "orange"
    hm.Remove(1)
    fmt.Println(hm.Get(1)) // 输出 "null"
}
```

#### 24. 删除链表的节点

**题目描述：** 给定一个单链表，删除链表中的节点，给定节点非尾节点。

**输入：** `head = [4,5,1,9]`，节点值为`5`

**输出：** `[4,1,9]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n1 := &ListNode{Val: 4}
    n2 := &ListNode{Val: 5}
    n3 := &ListNode{Val: 1}
    n4 := &ListNode{Val: 9}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4

    printList(n1) // 输出 4 5 1 9
    deleteNode(n2)
    printList(n1) // 输出 4 1 9
}
```

#### 25. 搜索插入位置

**题目描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**输入：** `[1,3,5,6]`，`target = 5`

**输出：** `2`

**答案解析：**

```go
package main

import (
    "fmt"
)

func searchInsert(nums []int, target int) int {
    low, high := 0, len(nums)-1

    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return low
}

func main() {
    nums := []int{1, 3, 5, 6}
    target := 5
    fmt.Println(searchInsert(nums, target)) // 输出 2
}
```

#### 26. 有效的括号

**题目描述：** 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['` 和 `']'` 的字符串，判断是否有效。

**输入：** `"()`"

**输出：** `true`

**答案解析：**

```go
package main

import (
    "fmt"
)

func isValid(s string) bool {
    stack := []rune{}

    for _, v := range s {
        if v == '(' || v == '{' || v == '[' {
            stack = append(stack, v)
        } else if len(stack) == 0 || (v != ')' && v != '}' && v != ']') || ((v == ')' && stack[len(stack)-1] != '(') || (v == '}' && stack[len(stack)-1] != '{') || (v == ']' && stack[len(stack)-1] != '[')) {
            return false
        }
        stack = stack[:len(stack)-1]
    }

    return len(stack) == 0
}

func main() {
    s := "(()"
    fmt.Println(isValid(s)) // 输出 true
}
```

#### 27. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。最长公共子序列是两个序列中最长且连续的子序列。

**输入：** `text1 = "abcde"`，`text2 = "ace"`

**输出：** `["a", "c", "e"]`

**答案解析：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1 string, text2 string) []string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    var result []string
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            result = append(result, string(text1[i-1]))
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }

    reverse(result)
    return result
}

func reverse(s []string) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    fmt.Println(longestCommonSubsequence(text1, text2)) // 输出 ["a", "c", "e"]
}
```

#### 28. 合并区间

**题目描述：** 给出一个区间的列表，合并所有重叠的区间。

**输入：** `intervals = [[1,3],[2,6],[8,10],[15,18]]`

**输出：** `[[1,6],[8,10],[15,18]]`

**答案解析：**

```go
package main

import (
    "fmt"
)

type Interval struct {
    Start int
    End   int
}

func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }

    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }

    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := [][]int{
        {1, 3},
        {2, 6},
        {8, 10},
        {15, 18},
    }
    fmt.Println(merge(intervals)) // 输出 [[1,6],[8,10],[15,18]]
}
```

#### 29. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**输入：** `head = [3,2,0,-4]`，环的起点为节点3。

**输出：** `true`

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true
        }
    }

    return false
}

func main() {
    n1 := &ListNode{Val: 3}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 0}
    n4 := &ListNode{Val: -4}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4
    n4.Next = n1

    fmt.Println(hasCycle(n1)) // 输出 true
}
```

#### 30. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的数组，找出一个给定目标值。

**输入：** `nums = [4,5,6,7,0,1,2]`，`target = 0`

**输出：** `4`

**答案解析：**

```go
package main

import (
    "fmt"
)

func search(nums []int, target int) int {
    low, high := 0, len(nums)-1

    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return mid
        } else if nums[low] <= nums[mid] {
            if nums[low] <= target && target < nums[mid] {
                high = mid - 1
            } else {
                low = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[high] {
                low = mid + 1
            } else {
                high = mid - 1
            }
        }
    }

    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println(search(nums, target)) // 输出 4
}
```

### 小米2025校招面试真题与算法题解总结

本文整理了小米2025校招面试中的高频面试题与算法题，并对每道题目进行了详细的解析和示例代码的展示。这些题目涵盖了链表、数组、字符串、哈希表、二分查找、动态规划等多个编程领域，旨在帮助求职者更好地准备面试和应对实际工作场景中的算法挑战。通过对这些题目的深入理解和练习，可以提升编程能力，为成功通过小米面试打下坚实的基础。

在准备面试时，除了熟练掌握题目本身，还要注意以下几点：

1. **理解题目要求：** 阅读题目时，务必明确题目的输入、输出和边界条件，避免在实现过程中出现逻辑错误。

2. **掌握常用算法：** 如二分查找、排序、哈希表、贪心算法等，这些算法在面试中经常出现。

3. **代码实现：** 动手编写代码，通过实践来加深理解，确保代码的可读性和效率。

4. **调试和优化：** 在实现代码后，进行充分测试，查找可能的错误，并尝试优化算法的时间复杂度和空间复杂度。

5. **面试技巧：** 除了技术问题，面试官还可能询问你的项目经验、团队协作能力、解决问题的方法等，因此要提前准备相关的例子和回答。

通过本文的解析和示例代码，相信您对小米2025校招面试中的问题有了更深入的理解。祝您在面试中取得优异成绩！

