                 

### 数字素养：公民参与的基石

#### 面试题库

### 1. 数字素养的重要性是什么？

**题目：** 请简述数字素养的重要性，以及为什么它对于公民参与至关重要。

**答案：** 数字素养是指个体在使用数字技术、理解数字信息、解决数字问题的能力。其重要性体现在以下几个方面：

* **提高生产力：** 数字素养可以帮助个人更高效地完成任务，提高工作效率。
* **促进经济发展：** 数字素养是现代经济的关键驱动力，能够推动创新和创业。
* **增强公民参与：** 数字素养使公民能够更好地了解和参与政治、社会议题，提高民主参与度。
* **保障信息安全和隐私：** 数字素养有助于公民识别网络诈骗、保护个人信息，维护网络安全。

**解析：** 数字素养不仅是个人发展的基石，也是社会进步的保障。它有助于公民更好地理解数字世界，提高参与公共事务的能力，促进民主社会的建设。

### 2. 如何评估一个国家的数字素养水平？

**题目：** 请描述一种评估一个国家数字素养水平的标准和方法。

**答案：** 评估一个国家的数字素养水平可以从以下几个方面进行：

* **数字技能测试：** 对公民进行数字技能的测试，包括计算机操作、网络应用、信息安全等。
* **教育体系评估：** 评估教育体系中数字素养教育的普及程度、课程设置、教学质量等。
* **就业市场分析：** 分析就业市场中数字技能的需求与供给情况，了解数字素养对就业的影响。
* **社会调查：** 通过问卷调查、访谈等方式了解公民对数字技术的态度、使用情况、认知水平等。

**解析：** 通过多维度、多角度的综合评估，可以较为全面地了解一个国家的数字素养水平，为制定相关政策提供依据。

### 3. 数字素养教育与公民参与之间的关系是什么？

**题目：** 请阐述数字素养教育对公民参与的重要性，以及如何通过教育促进公民参与。

**答案：** 数字素养教育对公民参与的重要性体现在以下几个方面：

* **提高信息获取能力：** 数字素养教育使公民能够更有效地获取和处理信息，为参与公共事务提供信息支持。
* **增强问题解决能力：** 数字素养教育培养公民分析问题、解决问题的能力，提高公共参与的质量。
* **促进民主意识：** 数字素养教育有助于培养公民的民主意识和参与意识，增强公共参与的热情。
* **提高决策效率：** 数字素养教育使公民能够更好地参与决策过程，提高决策的民主性和科学性。

**解析：** 通过数字素养教育，公民可以更好地了解公共事务，提高参与能力，进而推动民主社会的建设。

### 4. 如何培养公民的数字素养？

**题目：** 请提出一些有效的策略和方法，以培养公民的数字素养。

**答案：** 培养公民的数字素养可以从以下几个方面入手：

* **加强教育：** 将数字素养教育纳入各级教育体系中，培养公民的基础数字技能。
* **开展培训：** 针对不同人群，开展有针对性的数字素养培训，提高公民的实际应用能力。
* **推广数字技能：** 利用公共媒体、社区活动等渠道，宣传数字素养的重要性，推广数字技能。
* **建立社区支持网络：** 建立数字素养社区支持网络，为公民提供学习、交流和咨询的平台。
* **政策支持：** 制定相关政策，鼓励企业、社会组织和政府机构参与数字素养教育。

**解析：** 通过多层次、多角度的举措，可以有效培养公民的数字素养，提高公民参与公共事务的能力。

#### 算法编程题库

### 1. 如何设计一个算法，以检测用户输入的电子邮件地址是否有效？

**题目：** 编写一个函数，用于检测用户输入的电子邮件地址是否符合标准格式。

**答案：** 可以使用正则表达式来检测电子邮件地址的有效性。以下是一个简单的 Python 实现：

```python
import re

def is_valid_email(email):
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return re.match(pattern, email) is not None

# 测试
print(is_valid_email("example@example.com"))  # True
print(is_valid_email("example@example"))      # False
```

**解析：** 该函数使用正则表达式 `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$` 来匹配电子邮件地址。正则表达式分为两部分：第一部分是用户名，由字母、数字、特殊字符组成；第二部分是域名，由字母、数字、点号组成，至少有两个字母的后缀。

### 2. 编写一个算法，用于统计文本中每个单词出现的频率。

**题目：** 给定一个字符串，编写一个函数返回每个单词出现的频率。

**答案：** 以下是一个简单的 Python 实现：

```python
def word_frequency(text):
    words = text.split()
    frequency = {}
    for word in words:
        frequency[word] = frequency.get(word, 0) + 1
    return frequency

# 测试
text = "hello world hello world world"
print(word_frequency(text))  # {'hello': 2, 'world': 2}
```

**解析：** 该函数首先将输入的文本按空格分割成单词，然后使用字典来统计每个单词出现的频率。`get` 方法用于获取单词的当前频率，如果不存在则返回默认值 0。

### 3. 实现一个算法，找到字符串中的最长公共前缀。

**题目：** 编写一个函数，用于找到多个字符串的最长公共前缀。

**答案：** 以下是一个简单的 Python 实现：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix

# 测试
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # "fl"
```

**解析：** 该函数首先检查输入的字符串数组是否为空。然后，从第一个字符串的每个字符开始，依次与前一个字符串进行比较，直到找到不同的字符或到达字符串的末尾。找到最长公共前缀后，返回该前缀。

### 4. 编写一个算法，实现二分查找。

**题目：** 给定一个有序数组和一个目标值，编写一个函数使用二分查找算法找到目标值的位置。

**答案：** 以下是一个简单的 Python 实现：

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 测试
arr = [1, 3, 5, 7, 9]
target = 7
print(binary_search(arr, target))  # 3
```

**解析：** 该函数使用二分查找算法在有序数组中查找目标值。通过不断缩小查找范围，最终找到目标值的位置。如果目标值存在，返回其索引；否则，返回 -1。

### 5. 编写一个算法，实现快速排序。

**题目：** 给定一个数组，编写一个函数使用快速排序算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 测试
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 该函数使用快速排序算法对数组进行排序。首先选择一个基准值（pivot），然后将数组分成三个部分：小于基准值的部分、等于基准值的部分和大于基准值的部分。递归地对小于和大于基准值的部分进行快速排序，最终合并结果。

### 6. 编写一个算法，实现冒泡排序。

**题目：** 给定一个数组，编写一个函数使用冒泡排序算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# 测试
arr = [3, 6, 8, 10, 1, 2, 1]
bubble_sort(arr)
print(arr)  # [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 该函数使用冒泡排序算法对数组进行排序。通过多次遍历数组，比较相邻元素的大小，将较大的元素移动到数组末尾，直到整个数组有序。

### 7. 编写一个算法，实现选择排序。

**题目：** 给定一个数组，编写一个函数使用选择排序算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# 测试
arr = [3, 6, 8, 10, 1, 2, 1]
selection_sort(arr)
print(arr)  # [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 该函数使用选择排序算法对数组进行排序。每次遍历数组，找到剩余部分中的最小元素，将其与当前元素交换，直到整个数组有序。

### 8. 编写一个算法，实现插入排序。

**题目：** 给定一个数组，编写一个函数使用插入排序算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# 测试
arr = [3, 6, 8, 10, 1, 2, 1]
insertion_sort(arr)
print(arr)  # [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 该函数使用插入排序算法对数组进行排序。从第二个元素开始，将每个元素插入到已排序部分的正确位置，直到整个数组有序。

### 9. 编写一个算法，实现归并排序。

**题目：** 给定一个数组，编写一个函数使用归并排序算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# 测试
arr = [3, 6, 8, 10, 1, 2, 1]
print(merge_sort(arr))  # [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 该函数使用归并排序算法对数组进行排序。首先将数组分为两半，递归地对两部分进行排序，然后合并两个有序数组。

### 10. 编写一个算法，实现基数排序。

**题目：** 给定一个整数数组，编写一个函数使用基数排序算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def counting_sort(arr, exp1):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    for i in range(0, n):
        index = int(arr[i] / exp1)
        count[index % 10] += 1

    for i in range(1, 10):
        count[i] += count[i - 1]

    i = n - 1
    while i >= 0:
        index = int(arr[i] / exp1)
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    for i in range(0, len(arr)):
        arr[i] = output[i]

def radix_sort(arr):
    max1 = max(arr)
    exp = 1
    while max1 / exp > 0:
        counting_sort(arr, exp)
        exp *= 10

# 测试
arr = [170, 45, 75, 90, 802, 24, 2, 66]
radix_sort(arr)
print(arr)  # [2, 24, 45, 66, 75, 90, 170, 802]
```

**解析：** 该函数使用基数排序算法对整数数组进行排序。首先找到数组中的最大数，然后按位数进行排序，从最低位到最高位。每次排序都使用计数排序算法，将当前位相同的元素排列在一起。

### 11. 编写一个算法，实现 heapsort。

**题目：** 给定一个整数数组，编写一个函数使用 heapsort 算法对其进行排序。

**答案：** 以下是一个简单的 Python 实现：

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapsort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# 测试
arr = [12, 11, 13, 5, 6, 7]
heapsort(arr)
print(arr)  # [5, 6, 7, 11, 12, 13]
```

**解析：** 该函数使用 heapsort 算法对整数数组进行排序。首先构建一个最大堆，然后不断将堆顶元素（最大元素）移到数组的末尾，并调整剩余元素构成新的最大堆，直到整个数组有序。

### 12. 编写一个算法，实现中位数。

**题目：** 给定两个整数数组，编写一个函数计算它们的第 k 个中位数。

**答案：** 以下是一个简单的 Python 实现：

```python
def findMedianSortedArrays(nums1, nums2):
    nums = nums1 + nums2
    nums.sort()
    n = len(nums)
    if n % 2 == 0:
        return (nums[n//2 - 1] + nums[n//2]) / 2
    else:
        return nums[n//2]

# 测试
nums1 = [1, 3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2))  # 2
```

**解析：** 该函数首先将两个数组合并为一个数组，然后对合并后的数组进行排序。根据数组的长度判断中位数的位置，如果是偶数个元素，则返回中间两个数的平均值；如果是奇数个元素，则返回中间的数。

### 13. 编写一个算法，实现寻找两个有序数组中的第 k 个最小数。

**题目：** 给定两个有序数组，编写一个函数返回第 k 个最小数。

**答案：** 以下是一个简单的 Python 实现：

```python
def findKthElement(nums1, nums2, k):
    if len(nums1) > len(nums2):
        return findKthElement(nums2, nums1, k)
    len1, len2 = len(nums1), len(nums2)
    if len1 == 0:
        return nums2[k-1]
    if k == 1:
        return min(nums1[0], nums2[0])
    i, j = min(k//2, len1), min(k//2, len2)
    if nums1[i-1] > nums2[j-1]:
        return findKthElement(nums1, nums2[j:], k-j)
    else:
        return findKthElement(nums1[i:], nums2, k-i)

# 测试
nums1 = [1, 3, 5]
nums2 = [2, 4, 6]
print(findKthElement(nums1, nums2, 3))  # 4
```

**解析：** 该函数使用二分查找的方法来寻找第 k 个最小数。首先确定两个数组的长度，然后分别对两个数组的中间元素进行比较，逐步缩小搜索范围，直到找到第 k 个最小数。

### 14. 编写一个算法，实现查找最长公共子序列。

**题目：** 给定两个字符串，编写一个函数返回它们的最长公共子序列。

**答案：** 以下是一个简单的 Python 实现：

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

# 测试
s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))  # "ACD"
```

**解析：** 该函数使用动态规划的方法来计算最长公共子序列。通过填充一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符与 `s2` 的前 `j` 个字符的最长公共子序列长度。最后，返回 `dp[m][n]` 作为结果。

### 15. 编写一个算法，实现判断字符串是否是变位词。

**题目：** 给定两个字符串，编写一个函数判断它们是否是变位词。

**答案：** 以下是一个简单的 Python 实现：

```python
def is_anagram(s1, s2):
    return sorted(s1) == sorted(s2)

# 测试
s1 = "listen"
s2 = "silent"
print(is_anagram(s1, s2))  # True
```

**解析：** 该函数使用排序的方法来判断两个字符串是否是变位词。首先对两个字符串进行排序，然后比较排序后的字符串是否相同。如果相同，则它们是变位词。

### 16. 编写一个算法，实现判断字符串是否是回文。

**题目：** 给定一个字符串，编写一个函数判断它是否是回文。

**答案：** 以下是一个简单的 Python 实现：

```python
def is_palindrome(s):
    return s == s[::-1]

# 测试
s = "racecar"
print(is_palindrome(s))  # True
```

**解析：** 该函数使用字符串反转的方法来判断字符串是否是回文。首先将字符串反转，然后与原始字符串进行比较。如果相同，则它是回文。

### 17. 编写一个算法，实现计算字符串的长度。

**题目：** 给定一个字符串，编写一个函数计算它的长度。

**答案：** 以下是一个简单的 Python 实现：

```python
def length_of_string(s):
    return len(s)

# 测试
s = "hello"
print(length_of_string(s))  # 5
```

**解析：** 该函数使用 Python 内置的 `len` 函数来计算字符串的长度。

### 18. 编写一个算法，实现判断字符串是否是数字。

**题目：** 给定一个字符串，编写一个函数判断它是否是数字。

**答案：** 以下是一个简单的 Python 实现：

```python
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

# 测试
s = "123.456"
print(is_number(s))  # True
```

**解析：** 该函数使用 Python 的 `float` 函数来尝试将字符串转换为浮点数。如果成功，则字符串是数字；否则，返回 `False`。

### 19. 编写一个算法，实现字符串反转。

**题目：** 给定一个字符串，编写一个函数实现字符串反转。

**答案：** 以下是一个简单的 Python 实现：

```python
def reverse_string(s):
    return s[::-1]

# 测试
s = "hello"
print(reverse_string(s))  # "olleh"
```

**解析：** 该函数使用字符串切片的方法来反转字符串。通过使用 `-1` 作为步长，将从末尾到开头的所有字符取出，实现字符串反转。

### 20. 编写一个算法，实现字符串截取。

**题目：** 给定一个字符串和两个整数 `start` 和 `end`，编写一个函数返回字符串的子串，从 `start` 到 `end`（包括 `start` 但不包括 `end`）。

**答案：** 以下是一个简单的 Python 实现：

```python
def substring(s, start, end):
    return s[start:end]

# 测试
s = "hello world"
start = 3
end = 7
print(substring(s, start, end))  # "lo w"
```

**解析：** 该函数使用字符串切片的方法来截取字符串。通过提供 `start` 和 `end` 参数，从 `start` 到 `end`（不包括 `end`）的字符被取出，作为新的子串返回。

### 21. 编写一个算法，实现字符串拼接。

**题目：** 给定两个字符串，编写一个函数将它们拼接在一起。

**答案：** 以下是一个简单的 Python 实现：

```python
def concatenate(s1, s2):
    return s1 + s2

# 测试
s1 = "hello"
s2 = "world"
print(concatenate(s1, s2))  # "helloworld"
```

**解析：** 该函数使用加号运算符将两个字符串拼接在一起，返回拼接后的字符串。

### 22. 编写一个算法，实现字符串替换。

**题目：** 给定一个字符串和两个字符串，编写一个函数将字符串中的所有指定子串替换为另一个字符串。

**答案：** 以下是一个简单的 Python 实现：

```python
def replace_substring(s, target, replacement):
    return s.replace(target, replacement)

# 测试
s = "hello world"
target = "world"
replacement = "everyone"
print(replace_substring(s, target, replacement))  # "hello everyone"
```

**解析：** 该函数使用字符串的 `replace` 方法来替换所有指定的子串。`target` 参数表示要替换的子串，`replacement` 参数表示替换后的子串。

### 23. 编写一个算法，实现字符串查找。

**题目：** 给定一个字符串和子串，编写一个函数查找子串在字符串中第一次出现的位置。

**答案：** 以下是一个简单的 Python 实现：

```python
def find_substring(s, sub):
    return s.find(sub)

# 测试
s = "hello world"
sub = "world"
print(find_substring(s, sub))  # 6
```

**解析：** 该函数使用字符串的 `find` 方法来查找子串在字符串中第一次出现的位置。返回的是子串的第一个字符的索引。

### 24. 编写一个算法，实现字符串首字母大写。

**题目：** 给定一个字符串，编写一个函数将字符串的首字母大写。

**答案：** 以下是一个简单的 Python 实现：

```python
def capitalize(s):
    return s.capitalize()

# 测试
s = "hello world"
print(capitalize(s))  # "Hello world"
```

**解析：** 该函数使用字符串的 `capitalize` 方法来将字符串的首字母大写。如果字符串是空的或已经以大写字母开头，则不进行任何操作。

### 25. 编写一个算法，实现字符串所有字母大写。

**题目：** 给定一个字符串，编写一个函数将字符串中的所有字母大写。

**答案：** 以下是一个简单的 Python 实现：

```python
def uppercase(s):
    return s.upper()

# 测试
s = "hello world"
print(uppercase(s))  # "HELLO WORLD"
```

**解析：** 该函数使用字符串的 `upper` 方法来将字符串中的所有字母大写。

### 26. 编写一个算法，实现字符串所有字母小写。

**题目：** 给定一个字符串，编写一个函数将字符串中的所有字母小写。

**答案：** 以下是一个简单的 Python 实现：

```python
def lowercase(s):
    return s.lower()

# 测试
s = "HELLO WORLD"
print(lowercase(s))  # "hello world"
```

**解析：** 该函数使用字符串的 `lower` 方法来将字符串中的所有字母小写。

### 27. 编写一个算法，实现字符串首字母小写。

**题目：** 给定一个字符串，编写一个函数将字符串的首字母小写。

**答案：** 以下是一个简单的 Python 实现：

```python
def lowercase_first_letter(s):
    return s[0].lower() + s[1:]

# 测试
s = "Hello WORLD"
print(lowercase_first_letter(s))  # "hello WORLD"
```

**解析：** 该函数使用字符串的 `lower` 方法来将字符串的首字母小写。首先提取字符串的第一个字符，然后将其小写，再与剩余的字符串拼接起来。

### 28. 编写一个算法，实现字符串格式化输出。

**题目：** 给定一个字符串和一个数字，编写一个函数将数字格式化为字符串的一部分，例如 "There are 3 apples"。

**答案：** 以下是一个简单的 Python 实现：

```python
def format_string(s, num):
    return s.format(num)

# 测试
s = "There are {} apples"
num = 3
print(format_string(s, num))  # "There are 3 apples"
```

**解析：** 该函数使用字符串的 `format` 方法来将数字格式化为字符串的一部分。`{}` 是格式化占位符，可以通过传递一个数字来替换它。

### 29. 编写一个算法，实现字符串加密。

**题目：** 给定一个字符串，编写一个函数使用凯撒密码对其进行加密。

**答案：** 以下是一个简单的 Python 实现：

```python
def caesar_cipher(s, shift):
    encrypted = ""
    for char in s:
        if char.isalpha():
            ascii_offset = 65 if char.isupper() else 97
            encrypted += chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)
        else:
            encrypted += char
    return encrypted

# 测试
s = "hello"
shift = 3
print(caesar_cipher(s, shift))  # "khoor"
```

**解析：** 该函数使用凯撒密码对字符串进行加密。对于每个字母字符，将其 ASCII 码值移动 `shift` 个位置，并使用模 26 运算以确保字符在字母表中循环。

### 30. 编写一个算法，实现字符串解密。

**题目：** 给定一个加密字符串和凯撒密码的 shift 值，编写一个函数将其解密。

**答案：** 以下是一个简单的 Python 实现：

```python
def caesar_decipher(s, shift):
    decrypted = ""
    for char in s:
        if char.isalpha():
            ascii_offset = 65 if char.isupper() else 97
            decrypted += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
        else:
            decrypted += char
    return decrypted

# 测试
s = "khoor"
shift = 3
print(caesar_decipher(s, shift))  # "hello"
```

**解析：** 该函数使用凯撒密码对字符串进行解密。与加密过程类似，只是将 shift 值取反，将加密后的字符 ASCII 码值减去 `shift` 个位置，并使用模 26 运算以确保字符在字母表中循环。

