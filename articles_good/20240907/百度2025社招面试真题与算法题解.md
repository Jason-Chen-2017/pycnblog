                 

### 百度2025社招面试真题与算法题解

本文将详细介绍百度2025年社招面试中的高频面试题和算法题，并针对每道题目提供详尽的答案解析和源代码实例。这些题目涵盖了数据结构与算法、系统设计、系统编程等多个方面，旨在帮助求职者更好地准备面试。

#### 1. 数据结构与算法

##### 题目1：排序算法

**题目描述：** 实现快速排序算法。

**答案：**

快速排序是一种高效的排序算法，其基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**代码实例：**

```go
package main

import (
    "fmt"
)

func QuickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        QuickSort(arr, low, pi-1)
        QuickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    QuickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

#### 2. 系统设计

##### 题目2：缓存系统设计

**题目描述：** 设计一个缓存系统，支持添加、删除、查询和缓存击穿。

**答案：**

缓存系统设计需要考虑以下方面：

* 缓存过期策略：可以采用定时过期或者LRU（最近最少使用）策略。
* 缓存击穿处理：缓存击穿指在缓存过期后，第一个访问该数据的请求直接查询数据库，并将结果写入缓存，后续请求直接从缓存获取数据。
* 缓存淘汰策略：可以采用LRU或者LFU（最频繁使用）策略。

**代码实例：**

```go
package main

import (
    "fmt"
    "time"
)

type Cache struct {
    data     map[string]interface{}
    expire   map[string]time.Time
    capacity int
}

func NewCache(capacity int) *Cache {
    return &Cache{
        data:     make(map[string]interface{}),
        expire:   make(map[string]time.Time),
        capacity: capacity,
    }
}

func (c *Cache) Set(key string, value interface{}, expire time.Duration) {
    if len(c.data) >= c.capacity {
        // 淘汰策略
        // ...
    }
    c.data[key] = value
    c.expire[key] = time.Now().Add(expire)
}

func (c *Cache) Get(key string) (interface{}, bool) {
    if value, ok := c.data[key]; ok {
        expireTime, _ := c.expire[key]
        if time.Now().Before(expireTime) {
            return value, true
        } else {
            // 缓存过期，淘汰缓存
            // ...
            return nil, false
        }
    }
    return nil, false
}

func (c *Cache) Del(key string) {
    delete(c.data, key)
    delete(c.expire, key)
}

func main() {
    cache := NewCache(10)
    cache.Set("key1", "value1", 10*time.Minute)
    fmt.Println(cache.Get("key1"))
    time.Sleep(11 * time.Minute)
    fmt.Println(cache.Get("key1"))
}
```

#### 3. 系统编程

##### 题目3：实现TCP客户端和服务器

**题目描述：** 实现一个简单的TCP客户端和服务器，实现文件传输功能。

**答案：**

TCP客户端和服务器实现主要包括以下步骤：

1. 创建TCP连接：客户端和服务器分别通过`net.Dial`方法创建TCP连接。
2. 数据传输：客户端和服务器通过连接发送和接收数据。
3. 关闭连接：数据传输完成后，关闭TCP连接。

**代码实例：**

**客户端：**

```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
)

func main() {
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        panic(err)
    }
    defer conn.Close()

    reader := bufio.NewReader(os.Stdin)
    for {
        input, _ := reader.ReadString('\n')
        _, err := conn.Write([]byte(input))
        if err != nil {
            panic(err)
        }
        if input == "\n" {
            break
        }
    }
}
```

**服务器：**

```go
package main

import (
    "bufio"
    "fmt"
    "net"
    "os"
)

func main() {
    listener, err := net.Listen("tcp", "localhost:8080")
    if err != nil {
        panic(err)
    }
    defer listener.Close()

    for {
        conn, err := listener.Accept()
        if err != nil {
            panic(err)
        }
        go handleRequest(conn)
    }
}

func handleRequest(conn net.Conn) {
    reader := bufio.NewReader(conn)
    for {
        line, err := reader.ReadString('\n')
        if err != nil {
            panic(err)
        }
        fmt.Println("Received:", line)
        conn.Write([]byte(line))
    }
}
```

以上是百度2025年社招面试中的高频面试题和算法题的解析与代码实例。希望这些内容能帮助您更好地准备面试，成功斩获心仪的职位！

