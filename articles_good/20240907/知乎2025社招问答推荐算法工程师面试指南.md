                 

### é¢˜ç›®åˆ—è¡¨åŠç­”æ¡ˆè§£æ

#### 1. ç®—æ³•åŸºç¡€
**é¢˜ç›®ï¼š** æè¿°ä¸€ä¸‹æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦çš„æ¦‚å¿µï¼Œå¹¶ç»™å‡ºä¸€ä¸ªä¾‹å­ã€‚

**ç­”æ¡ˆï¼š** æ—¶é—´å¤æ‚åº¦æ˜¯æŒ‡ç®—æ³•æ‰§è¡Œçš„æ—¶é—´ä¸è¾“å…¥è§„æ¨¡ä¹‹é—´çš„å¢é•¿å…³ç³»ï¼Œé€šå¸¸ä½¿ç”¨å¤§Oç¬¦å·è¡¨ç¤ºï¼Œå¦‚O(1)ã€O(n)ã€O(nÂ²)ç­‰ã€‚ç©ºé—´å¤æ‚åº¦æ˜¯æŒ‡ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­æ‰€éœ€å†…å­˜çš„è§„æ¨¡ä¸è¾“å…¥è§„æ¨¡ä¹‹é—´çš„å¢é•¿å…³ç³»ã€‚

**ä¾‹å­ï¼š** çº¿æ€§æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n)ï¼Œè€ŒäºŒåˆ†æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(log n)ã€‚ç®€å•æ•°æ®ç»“æ„çš„ç©ºé—´å¤æ‚åº¦é€šå¸¸æ˜¯O(1)ï¼Œå¦‚æ ˆã€é˜Ÿåˆ—ï¼Œè€Œå“ˆå¸Œè¡¨çš„ç©ºé—´å¤æ‚åº¦é€šå¸¸æ˜¯O(n)ã€‚

#### 2. æ•°æ®ç»“æ„
**é¢˜ç›®ï¼š** æè¿°å“ˆå¸Œè¡¨çš„åŸºæœ¬åŸç†å’Œå·¥ä½œæœºåˆ¶ã€‚

**ç­”æ¡ˆï¼š** å“ˆå¸Œè¡¨æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œå®ƒé€šè¿‡å“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°è¡¨ä¸­çš„ä½ç½®ï¼Œä»¥å®ç°å¿«é€ŸæŸ¥æ‰¾ã€‚å“ˆå¸Œè¡¨çš„åŸºæœ¬åŸç†æ˜¯ï¼šå½“éœ€è¦æ’å…¥æˆ–æŸ¥æ‰¾ä¸€ä¸ªé”®æ—¶ï¼Œå…ˆé€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—é”®çš„å“ˆå¸Œå€¼ï¼Œç„¶åæ ¹æ®å“ˆå¸Œå€¼å®šä½åˆ°è¡¨ä¸­çš„ä½ç½®ï¼Œå¦‚æœè¯¥ä½ç½®æ²¡æœ‰å†²çªï¼Œåˆ™ç›´æ¥å­˜å‚¨æˆ–æŸ¥æ‰¾ï¼›å¦‚æœæœ‰å†²çªï¼Œåˆ™é‡‡ç”¨é“¾åœ°å€æ³•ã€å¼€æ”¾åœ°å€æ³•ç­‰ç­–ç•¥è§£å†³å†²çªã€‚

#### 3. ç®—æ³•ä¸æ•°æ®ç»“æ„
**é¢˜ç›®ï¼š** æè¿°å¿«é€Ÿæ’åºçš„åŸºæœ¬åŸç†å’Œæ­¥éª¤ã€‚

**ç­”æ¡ˆï¼š** å¿«é€Ÿæ’åºæ˜¯ä¸€ç§åŸºäºåˆ†æ²»ç­–ç•¥çš„æ’åºç®—æ³•ã€‚åŸºæœ¬åŸç†æ˜¯é€‰æ‹©ä¸€ä¸ªåŸºå‡†å…ƒç´ ï¼Œå°†æ•°ç»„åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯å°äºåŸºå‡†å…ƒç´ çš„å…ƒç´ ï¼Œå¦ä¸€éƒ¨åˆ†æ˜¯å¤§äºåŸºå‡†å…ƒç´ çš„å…ƒç´ ã€‚ç„¶åå¯¹è¿™ä¸¤éƒ¨åˆ†é€’å½’è¿›è¡Œå¿«é€Ÿæ’åºã€‚æ­¥éª¤å¦‚ä¸‹ï¼š

1. é€‰æ‹©åŸºå‡†å…ƒç´ ã€‚
2. partitionè¿‡ç¨‹ï¼šå°†å°äºåŸºå‡†å…ƒç´ çš„å…ƒç´ ç§»åŠ¨åˆ°å·¦è¾¹ï¼Œå¤§äºåŸºå‡†å…ƒç´ çš„å…ƒç´ ç§»åŠ¨åˆ°å³è¾¹ï¼ŒåŸºå‡†å…ƒç´ å¤„äºä¸­é—´ä½ç½®ã€‚
3. é€’å½’åœ°å¯¹å·¦å³ä¸¤éƒ¨åˆ†è¿›è¡Œå¿«é€Ÿæ’åºã€‚

#### 4. æ’åºç®—æ³•
**é¢˜ç›®ï¼š** æè¿°å†’æ³¡æ’åºçš„åŸºæœ¬åŸç†å’Œæ­¥éª¤ã€‚

**ç­”æ¡ˆï¼š** å†’æ³¡æ’åºæ˜¯ä¸€ç§ç®€å•çš„æ’åºç®—æ³•ï¼Œé€šè¿‡é‡å¤éå†è¦æ’åºçš„æ•°åˆ—ï¼Œä¸€æ¬¡æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æœå®ƒä»¬çš„é¡ºåºé”™è¯¯å°±æŠŠå®ƒä»¬äº¤æ¢è¿‡æ¥ã€‚éå†æ•°åˆ—çš„å·¥ä½œæ˜¯é‡å¤åœ°è¿›è¡Œï¼Œç›´åˆ°æ²¡æœ‰å†éœ€è¦äº¤æ¢çš„å…ƒç´ ä¸ºæ­¢ã€‚

#### 5. é“¾è¡¨
**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå•é“¾è¡¨ï¼ŒåŒ…æ‹¬æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾å’Œæ‰“å°åŠŸèƒ½ã€‚

**ç­”æ¡ˆï¼š** å®ç°ä¸€ä¸ªå•é“¾è¡¨ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸ªèŠ‚ç‚¹ç»“æ„ä½“ï¼Œä»¥åŠé“¾è¡¨çš„æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾å’Œæ‰“å°åŠŸèƒ½ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func Insert(head *ListNode, val int) *ListNode {
    newNode := &ListNode{Val: val}
    if head == nil {
        return newNode
    }
    curr := head
    for curr.Next != nil {
        curr = curr.Next
    }
    curr.Next = newNode
    return head
}

func Delete(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    curr := head
    for curr.Next != nil && curr.Next.Val != val {
        curr = curr.Next
    }
    if curr.Next != nil {
        curr.Next = curr.Next.Next
    }
    return head
}

func Find(head *ListNode, val int) *ListNode {
    curr := head
    for curr != nil && curr.Val != val {
        curr = curr.Next
    }
    return curr
}

func Print(head *ListNode) {
    curr := head
    for curr != nil {
        fmt.Println(curr.Val)
        curr = curr.Next
    }
}
```

#### 6. æ ˆå’Œé˜Ÿåˆ—
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªæ ˆå’Œé˜Ÿåˆ—ï¼Œåˆ†åˆ«ä½¿ç”¨é“¾è¡¨å’Œæ•°ç»„ä¸¤ç§æ–¹å¼ã€‚

**ç­”æ¡ˆï¼š** æ ˆå’Œé˜Ÿåˆ—éƒ½æ˜¯å¸¸è§çš„æ•°æ®ç»“æ„ï¼Œæ ˆçš„ç‰¹ç‚¹æ˜¯åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰ï¼Œè€Œé˜Ÿåˆ—çš„ç‰¹ç‚¹æ˜¯å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨é“¾è¡¨å®ç°çš„æ ˆå’Œé˜Ÿåˆ—ï¼š

```go
// æ ˆï¼ˆé“¾è¡¨å®ç°ï¼‰
type Stack struct {
    top *ListNode
}

func NewStack() *Stack {
    return &Stack{}
}

func (s *Stack) Push(val int) {
    newNode := &ListNode{Val: val}
    if s.top == nil {
        s.top = newNode
    } else {
        newNode.Next = s.top
        s.top = newNode
    }
}

func (s *Stack) Pop() int {
    if s.top == nil {
        return -1
    }
    val := s.top.Val
    s.top = s.top.Next
    return val
}

// é˜Ÿåˆ—ï¼ˆé“¾è¡¨å®ç°ï¼‰
type Queue struct {
    front, rear *ListNode
}

func NewQueue() *Queue {
    return &Queue{}
}

func (q *Queue) Enqueue(val int) {
    newNode := &ListNode{Val: val}
    if q.rear == nil {
        q.front = q.rear = newNode
    } else {
        q.rear.Next = newNode
        q.rear = newNode
    }
}

func (q *Queue) Dequeue() int {
    if q.front == nil {
        return -1
    }
    val := q.front.Val
    q.front = q.front.Next
    if q.front == nil {
        q.rear = nil
    }
    return val
}
```

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨æ•°ç»„å®ç°çš„æ ˆå’Œé˜Ÿåˆ—ï¼š

```go
// æ ˆï¼ˆæ•°ç»„å®ç°ï¼‰
type StackArray struct {
    data []int
    top  int
}

func NewStackArray() *StackArray {
    return &StackArray{data: make([]int, 10), top: -1}
}

func (s *StackArray) Push(val int) {
    s.top++
    if s.top >= len(s.data) {
        s.data = append(s.data, 0)
    }
    s.data[s.top] = val
}

func (s *StackArray) Pop() int {
    if s.top < 0 {
        return -1
    }
    val := s.data[s.top]
    s.top--
    return val
}

// é˜Ÿåˆ—ï¼ˆæ•°ç»„å®ç°ï¼‰
type QueueArray struct {
    data []int
    front, rear int
}

func NewQueueArray() *QueueArray {
    return &QueueArray{data: make([]int, 10), front: 0, rear: 0}
}

func (q *QueueArray) Enqueue(val int) {
    q.rear++
    if q.rear >= len(q.data) {
        q.data = append(q.data, 0)
    }
    q.data[q.rear] = val
}

func (q *QueueArray) Dequeue() int {
    if q.front == q.rear {
        return -1
    }
    val := q.data[q.front]
    q.front++
    return val
}
```

#### 7. å­—ç¬¦ä¸²
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªå­—ç¬¦ä¸²çš„åè½¬åŠŸèƒ½ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨æ ˆæˆ–è€…å¾ªç¯çš„æ–¹å¼å®ç°å­—ç¬¦ä¸²çš„åè½¬ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨æ ˆå®ç°çš„ä¾‹å­ï¼š

```go
func ReverseString(s string) string {
    stk := []rune(s)
    for i := 0; i < len(stk)/2; i++ {
        temp := stk[i]
        stk[i] = stk[len(stk)-i-1]
        stk[len(stk)-i-1] = temp
    }
    return string(stk)
}
```

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨å¾ªç¯å®ç°çš„ä¾‹å­ï¼š

```go
func ReverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i := 0; i < n/2; i++ {
        runes[i], runes[n-i-1] = runes[n-i-1], runes[i]
    }
    return string(runes)
}
```

#### 8. æ ‘
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªäºŒå‰æ ‘ï¼ŒåŒ…æ‹¬æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾å’Œéå†åŠŸèƒ½ã€‚

**ç­”æ¡ˆï¼š** äºŒå‰æ ‘æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹è‡³å¤šæœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œé€šå¸¸ç§°ä¸ºå·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„äºŒå‰æ ‘å®ç°ï¼š

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func NewTree(val int) *TreeNode {
    return &TreeNode{Val: val}
}

func (t *TreeNode) Insert(val int) {
    if val < t.Val {
        if t.Left == nil {
            t.Left = NewTree(val)
        } else {
            t.Left.Insert(val)
        }
    } else {
        if t.Right == nil {
            t.Right = NewTree(val)
        } else {
            t.Right.Insert(val)
        }
    }
}

func (t *TreeNode) Delete(val int) *TreeNode {
    if t == nil {
        return nil
    }
    if val < t.Val {
        t.Left = t.Left.Delete(val)
    } else if val > t.Val {
        t.Right = t.Right.Delete(val)
    } else {
        if t.Left == nil && t.Right == nil {
            return nil
        } else if t.Left == nil {
            t = t.Right
        } else if t.Right == nil {
            t = t.Left
        } else {
            minNode := t.Right.Min()
            t.Val = minNode.Val
            t.Right = t.Right.Delete(minNode.Val)
        }
    }
    return t
}

func (t *TreeNode) Find(val int) *TreeNode {
    if t == nil {
        return nil
    }
    if val < t.Val {
        return t.Left.Find(val)
    } else if val > t.Val {
        return t.Right.Find(val)
    } else {
        return t
    }
}

func (t *TreeNode) InOrderTraversal() {
    if t != nil {
        t.Left.InOrderTraversal()
        fmt.Println(t.Val)
        t.Right.InOrderTraversal()
    }
}

func (t *TreeNode) PreOrderTraversal() {
    if t != nil {
        fmt.Println(t.Val)
        t.Left.PreOrderTraversal()
        t.Right.PreOrderTraversal()
    }
}

func (t *TreeNode) PostOrderTraversal() {
    if t != nil {
        t.Left.PostOrderTraversal()
        t.Right.PostOrderTraversal()
        fmt.Println(t.Val)
    }
}

func (t *TreeNode) Min() *TreeNode {
    if t.Left == nil {
        return t
    }
    return t.Left.Min()
}
```

#### 9. å›¾
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªå›¾ï¼ŒåŒ…æ‹¬æ·»åŠ èŠ‚ç‚¹ã€æ·»åŠ è¾¹ã€æŸ¥æ‰¾èŠ‚ç‚¹ã€éå†ï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ã€æ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰åŠŸèƒ½ã€‚

**ç­”æ¡ˆï¼š** å›¾æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œç”±èŠ‚ç‚¹å’Œè¾¹ç»„æˆã€‚æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰å¤šä¸ªç›¸é‚»èŠ‚ç‚¹ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å›¾å®ç°ï¼š

```go
type Graph struct {
    nodes map[int]bool
    edges map[int]map[int]bool
}

func NewGraph() *Graph {
    return &Graph{
        nodes: make(map[int]bool),
        edges: make(map[int]map[int]bool),
    }
}

func (g *Graph) AddNode(val int) {
    g.nodes[val] = true
    if _, ok := g.edges[val]; !ok {
        g.edges[val] = make(map[int]bool)
    }
}

func (g *Graph) AddEdge(from, to int) {
    g.edges[from][to] = true
    g.edges[to][from] = true
}

func (g *Graph) FindNode(val int) bool {
    return g.nodes[val]
}

func (g *Graph) BreadthFirstSearch(start int) {
    visited := make(map[int]bool)
    queue := []int{start}
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if !visited[node] {
            visited[node] = true
            fmt.Println(node)
            for adjacent := range g.edges[node] {
                if !visited[adjacent] {
                    queue = append(queue, adjacent)
                }
            }
        }
    }
}

func (g *Graph) DepthFirstSearch(start int) {
    visited := make(map[int]bool)
    func dfs(node int) {
        if visited[node] {
            return
        }
        visited[node] = true
        fmt.Println(node)
        for adjacent := range g.edges[node] {
            dfs(adjacent)
        }
    }
    dfs(start)
}
```

#### 10. ç®—æ³•ä¸æ•°å­¦
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾ç®—æ³•ã€‚

**ç­”æ¡ˆï¼š** äºŒåˆ†æŸ¥æ‰¾æ˜¯ä¸€ç§é«˜æ•ˆçš„æŸ¥æ‰¾ç®—æ³•ï¼Œç”¨äºåœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾æŸä¸ªå…ƒç´ ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„äºŒåˆ†æŸ¥æ‰¾å®ç°ï¼š

```go
func BinarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}
```

#### 11. åŠ¨æ€è§„åˆ’
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªçˆ¬æ¥¼æ¢¯ç®—æ³•ã€‚

**ç­”æ¡ˆï¼š** çˆ¬æ¥¼æ¢¯é—®é¢˜æ˜¯ä¸€ä¸ªç»å…¸çš„åŠ¨æ€è§„åˆ’é—®é¢˜ï¼Œç»™å®šä¸€ä¸ªæ¥¼æ¢¯ï¼Œæ¯æ¬¡å¯ä»¥çˆ¬1ä¸ªæˆ–2ä¸ªå°é˜¶ï¼Œæ±‚æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•çˆ¬åˆ°æ¥¼é¡¶ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„åŠ¨æ€è§„åˆ’å®ç°ï¼š

```go
func ClimbingStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

#### 12. å›æº¯ç®—æ³•
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªç»„åˆé—®é¢˜ã€‚

**ç­”æ¡ˆï¼š** ç»„åˆé—®é¢˜æ˜¯ä¸€ä¸ªå…¸å‹çš„å›æº¯ç®—æ³•é—®é¢˜ï¼Œç»™å®šä¸€ä¸ªæ•°å­—åˆ—è¡¨ï¼Œä»ä¸­é€‰å–è‹¥å¹²ä¸ªæ•°å­—ï¼Œä½¿å¾—å®ƒä»¬çš„å’Œç­‰äºç›®æ ‡å€¼ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å›æº¯ç®—æ³•å®ç°ï¼š

```go
func CombinationSum(candidates []int, target int) [][]int {
    res := [][]int{}
    backtrack(candidates, target, 0, []int{}, &res)
    return res
}

func backtrack(nums []int, target int, start int, path []int, res *[][]int) {
    if target == 0 {
        tmp := make([]int, len(path))
        copy(tmp, path)
        *res = append(*res, tmp)
        return
    }
    if target < 0 {
        return
    }
    for i := start; i < len(nums); i++ {
        path = append(path, nums[i])
        backtrack(nums, target-nums[i], i, path, res)
        path = path[:len(path)-1]
    }
}
```

#### 13. å‰ç¼€æ ‘
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªå‰ç¼€æ ‘ã€‚

**ç­”æ¡ˆï¼š** å‰ç¼€æ ‘æ˜¯ä¸€ç§ç”¨äºé«˜æ•ˆå­˜å‚¨å’ŒæŸ¥æ‰¾å­—ç¬¦ä¸²çš„æ•°æ®ç»“æ„ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å‰ç¼€æ ‘å®ç°ï¼š

```go
type Trie struct {
    children []*Trie
    isEnd    bool
}

func NewTrie() *Trie {
    return &Trie{children: make([]*Trie, 26)}
}

func (t *Trie) Insert(word string) {
    node := t
    for i := 0; i < len(word); i++ {
        index := word[i] - 'a'
        if node.children[index] == nil {
            node.children[index] = &Trie{}
        }
        node = node.children[index]
    }
    node.isEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t
    for i := 0; i < len(word); i++ {
        index := word[i] - 'a'
        if node.children[index] == nil {
            return false
        }
        node = node.children[index]
    }
    return node.isEnd
}
```

#### 14. å¹¶å‘ç¼–ç¨‹
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªå¹¶å‘å®‰å…¨çš„é˜Ÿåˆ—ã€‚

**ç­”æ¡ˆï¼š** å¹¶å‘å®‰å…¨çš„é˜Ÿåˆ—éœ€è¦åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œå®‰å…¨æ€§ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨äº’æ–¥é”ï¼ˆMutexï¼‰å®ç°çš„å¹¶å‘å®‰å…¨é˜Ÿåˆ—ï¼š

```go
type ConcurrentQueue struct {
    queue []int
    mutex sync.Mutex
}

func NewConcurrentQueue() *ConcurrentQueue {
    return &ConcurrentQueue{queue: make([]int, 0)}
}

func (c *ConcurrentQueue) Enqueue(val int) {
    c.mutex.Lock()
    c.queue = append(c.queue, val)
    c.mutex.Unlock()
}

func (c *ConcurrentQueue) Dequeue() int {
    c.mutex.Lock()
    if len(c.queue) == 0 {
        c.mutex.Unlock()
        return -1
    }
    val := c.queue[0]
    c.queue = c.queue[1:]
    c.mutex.Unlock()
    return val
}
```

#### 15. ç½‘ç»œç¼–ç¨‹
**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªHTTPæœåŠ¡å™¨ã€‚

**ç­”æ¡ˆï¼š** HTTPæœåŠ¡å™¨ç”¨äºå¤„ç†HTTPè¯·æ±‚å¹¶è¿”å›å“åº”ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„HTTPæœåŠ¡å™¨å®ç°ï¼š

```go
package main

import (
    "fmt"
    "log"
    "net/http"
)

func handleRequest(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path)
}

func main() {
    http.HandleFunc("/", handleRequest)
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 16. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æœ€é•¿é€’å¢å­åºåˆ—çš„é•¿åº¦ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’çš„æ–¹æ³•æ±‚è§£ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„åŠ¨æ€è§„åˆ’å®ç°ï¼š

```go
func LengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

#### 17. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾åˆ°æ‰€æœ‰ä¸‰ä¸ªæ•°çš„ç»„åˆï¼Œä½¿å…¶å’Œç­‰äºä¸€ä¸ªç‰¹å®šçš„ç›®æ ‡æ•°ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„åŒæŒ‡é’ˆå®ç°ï¼š

```go
func ThreeSum(nums []int, target int) [][]int {
    res := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

#### 18. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºå…¶ä¸­ç¬¬ä¸€ä¸ªä¸é‡å¤å‡ºç°çš„å­—ç¬¦ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å“ˆå¸Œè¡¨å®ç°ï¼š

```go
func FirstUniqChar(s string) int {
    cnt := [26]int{}
    for _, c := range s {
        cnt[c-'a']++
    }
    for i, c := range s {
        if cnt[c-'a'] == 1 {
            return i
        }
    }
    return -1
}
```

#### 19. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦ä¸€åŠçš„å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨æ‘©å°”æŠ•ç¥¨ç®—æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„æ‘©å°”æŠ•ç¥¨ç®—æ³•å®ç°ï¼š

```go
func MajorityElement(nums []int) int {
    count := 0
    candidate := 0
    for _, num := range nums {
        if count == 0 {
            candidate = num
            count = 1
        } else if num == candidate {
            count++
        } else {
            count--
        }
    }
    return candidate
}
```

#### 20. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯å›æ–‡ä¸²ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„åŒæŒ‡é’ˆå®ç°ï¼š

```go
func IsPalindrome(s string) bool {
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

#### 21. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€å°çš„kä¸ªæ•°ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å¿«é€Ÿé€‰æ‹©ç®—æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å¿«é€Ÿé€‰æ‹©ç®—æ³•å®ç°ï¼š

```go
func GetLeastNumbers(arr []int, k int) []int {
    if k > len(arr) {
        return []int{}
    }
    quickSelect(arr, 0, len(arr)-1, k-1)
    return arr[:k]
}

func quickSelect(arr []int, left, right, k int) {
    if left == right {
        return
    }
    pivot := arr[right]
    i := left
    for j := left; j < right; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[right] = arr[right], arr[i]
    if i == k {
        return
    }
    if i < k {
        quickSelect(arr, i+1, right, k)
    } else {
        quickSelect(arr, left, i-1, k)
    }
}
```

#### 22. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å­—ç¬¦ä¸²çš„æœ€é•¿é‡å¤å­ä¸²ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å’Œå“ˆå¸Œçš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š

```go
func longestSubstring(s string) string {
    n := len(s)
    left, right := 1, n
    for right-left > 1 {
        mid := (left + right) / 2
        if containsSubstring(s, mid) {
            left = mid
        } else {
            right = mid
        }
    }
    return s[left:]
}

func containsSubstring(s string, length int) bool {
    m := int64(1e9 + 7)
    hash := func(s string) int64 {
        result := int64(0)
        for _, c := range s {
            result = (result*1333 + int64(c)) % m
        }
        return result
    }
    h := hash(s[:length])
    seen := make(map[int64]bool)
    seen[h] = true
    for i := length; i < len(s); i++ {
        h = (h-((int64(s[i-length])*1333)%m+m)%m)*1333 + int64(s[i])
        if seen[h] {
            return true
        }
        seen[h] = true
    }
    return false
}
```

#### 23. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ç­‰äºé›¶çš„å­æ•°ç»„ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å“ˆå¸Œè¡¨å®ç°ï¼š

```go
func FindAllZeroSumSubarrays(nums []int) [][]int {
    res := [][]int{}
    cnt := make(map[int]int)
    cnt[0] = 1
    sum := 0
    for i := 0; i < len(nums); i++ {
        sum += nums[i]
        if cnt[sum] > 0 {
            res = append(res, nums[i-cnt[sum]:i+1])
        }
        cnt[sum]++
    }
    return res
}
```

#### 24. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å‚ç›´æ‰“å°å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    minLen := len(strs[0])
    for _, s := range strs {
        if minLen > len(s) {
            minLen = len(s)
        }
    }
    var res []byte
    for i := 0; i < minLen; i++ {
        if strs[0][i] == 0 {
            break
        }
        for j := 1; j < len(strs); j++ {
            if strs[j][i] != strs[0][i] {
                return string(res)
            }
        }
        res = append(res, strs[0][i])
    }
    return string(res)
}
```

#### 25. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºå…¶ä¸­ç¬¬ä¸€ä¸ªä¸é‡å¤å‡ºç°çš„å­—ç¬¦ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å“ˆå¸Œè¡¨å®ç°ï¼š

```go
func FirstUniqChar(s string) int {
    cnt := [256]int{}
    for _, c := range s {
        cnt[c]++
    }
    for i, c := range s {
        if cnt[c] == 1 {
            return i
        }
    }
    return -1
}
```

#### 26. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ç­‰äºé›¶çš„å­æ•°ç»„ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å“ˆå¸Œè¡¨å®ç°ï¼š

```go
func FindAllZeroSumSubarrays(nums []int) [][]int {
    res := [][]int{}
    cnt := make(map[int]int)
    cnt[0] = 1
    sum := 0
    for i := 0; i < len(nums); i++ {
        sum += nums[i]
        if cnt[sum] > 0 {
            res = append(res, nums[i-cnt[sum]:i+1])
        }
        cnt[sum]++
    }
    return res
}
```

#### 27. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å‚ç›´æ‰“å°å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    minLen := len(strs[0])
    for _, s := range strs {
        if minLen > len(s) {
            minLen = len(s)
        }
    }
    var res []byte
    for i := 0; i < minLen; i++ {
        if strs[0][i] == 0 {
            break
        }
        for j := 1; j < len(strs); j++ {
            if strs[j][i] != strs[0][i] {
                return string(res)
            }
        }
        res = append(res, strs[0][i])
    }
    return string(res)
}
```

#### 28. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ç­‰äºé›¶çš„å­æ•°ç»„ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å“ˆå¸Œè¡¨å®ç°ï¼š

```go
func FindAllZeroSumSubarrays(nums []int) [][]int {
    res := [][]int{}
    cnt := make(map[int]int)
    cnt[0] = 1
    sum := 0
    for i := 0; i < len(nums); i++ {
        sum += nums[i]
        if cnt[sum] > 0 {
            res = append(res, nums[i-cnt[sum]:i+1])
        }
        cnt[sum]++
    }
    return res
}
```

#### 29. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ±‚å­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å‚ç›´æ‰“å°å­—ç¬¦ä¸²çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°ï¼š

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    minLen := len(strs[0])
    for _, s := range strs {
        if minLen > len(s) {
            minLen = len(s)
        }
    }
    var res []byte
    for i := 0; i < minLen; i++ {
        if strs[0][i] == 0 {
            break
        }
        for j := 1; j < len(strs); j++ {
            if strs[j][i] != strs[0][i] {
                return string(res)
            }
        }
        res = append(res, strs[0][i])
    }
    return string(res)
}
```

#### 30. ç®—æ³•é¢è¯•é¢˜
**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ç­‰äºé›¶çš„å­æ•°ç»„ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨çš„æ–¹æ³•ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„å“ˆå¸Œè¡¨å®ç°ï¼š

```go
func FindAllZeroSumSubarrays(nums []int) [][]int {
    res := [][]int{}
    cnt := make(map[int]int)
    cnt[0] = 1
    sum := 0
    for i := 0; i < len(nums); i++ {
        sum += nums[i]
        if cnt[sum] > 0 {
            res = append(res, nums[i-cnt[sum]:i+1])
        }
        cnt[sum]++
    }
    return res
}
```

### æ€»ç»“

åœ¨æœ¬ç¯‡åšå®¢ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº† 20 é“å›½å†…å¤´éƒ¨ä¸€çº¿å¤§å‚é«˜é¢‘é¢è¯•é¢˜ï¼Œå¹¶æä¾›äº†è¯¦å°½çš„ç­”æ¡ˆè§£æå’Œæºä»£ç å®ä¾‹ã€‚è¿™äº›é¢è¯•é¢˜æ¶µç›–äº†ç®—æ³•åŸºç¡€ã€æ•°æ®ç»“æ„ã€æ’åºç®—æ³•ã€å­—ç¬¦ä¸²ã€æ ‘ã€å›¾ã€åŠ¨æ€è§„åˆ’ã€å›æº¯ç®—æ³•ã€å‰ç¼€æ ‘ã€å¹¶å‘ç¼–ç¨‹ã€ç½‘ç»œç¼–ç¨‹ç­‰å„ä¸ªæ–¹é¢ã€‚é€šè¿‡è¿™äº›é¢˜ç›®ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¥½åœ°å‡†å¤‡é¢è¯•ï¼Œæå‡ç®—æ³•èƒ½åŠ›ã€‚

å¸Œæœ›è¿™ç¯‡åšå®¢èƒ½å¯¹å‡†å¤‡é¢è¯•çš„ä½ æœ‰æ‰€å¸®åŠ©ã€‚å¦‚æœä½ æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ã€‚ç¥ä½ åœ¨é¢è¯•ä¸­å–å¾—å¥½æˆç»©ï¼ğŸ’ªğŸ’¯ğŸ’¥

