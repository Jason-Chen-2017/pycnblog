                 

### 规划机制在任务管理中的作用：面试题与算法编程题解析

#### 一、典型面试题解析

**1. 什么是任务规划？请举例说明。**

**题目描述：** 请简述任务规划的定义，并给出一个实际应用场景的例子。

**答案解析：**
任务规划是指对一系列任务进行系统化、结构化的安排和分配，以达到最优的执行效果。在实际应用中，任务规划广泛应用于生产制造、物流配送、软件开发等各个领域。

**例子：** 假设一家电商公司需要在每天上午10点之前完成订单处理，并且需要确保所有订单在下午5点前完成配送。通过任务规划，可以将订单处理、打包、配送等任务分配给不同的团队和人员，确保每个任务都能按时完成。

**2. 请解释任务调度算法中的“最短任务优先（STF）”策略。**

**题目描述：** 最短任务优先（STF）是什么？它在任务管理中有什么作用？

**答案解析：**
最短任务优先（Shortest Task First，STF）是一种基于任务执行时间进行调度的算法。它选择执行时间最短的待执行任务，优先将其分配给处理器。

**作用：**
- 减少平均任务等待时间。
- 提高系统响应速度。
- 在某些场景下，可以减少调度开销。

**例子：** 在一个具有多个等待处理的任务队列中，如果使用STF策略，那么执行时间最短的任务将被优先执行，这将有助于缩短任务的等待时间。

**3. 请简述任务规划中的“动态规划”方法。**

**题目描述：** 动态规划是一种解决任务规划问题的方法吗？如果是，请解释其基本原理。

**答案解析：**
是的，动态规划是一种有效的解决任务规划问题的方法。动态规划通过将复杂问题分解为更小的子问题，并利用子问题的解来构建原问题的解。

**基本原理：**
- 分解：将问题分解为更小的子问题。
- 记忆：存储已解决的子问题的解，避免重复计算。
- 自底向上：从最基本的子问题开始计算，逐步构建最终问题的解。

**例子：** 在调度任务时，可以使用动态规划来优化任务的执行顺序，使得总执行时间最短。

**4. 请解释任务规划中的“资源调度”概念。**

**题目描述：** 资源调度在任务规划中是什么意思？它在任务管理中有什么重要性？

**答案解析：**
资源调度是指根据任务的优先级、执行时间和资源需求，对系统中的资源（如CPU、内存、网络等）进行合理的分配和调度。

**重要性：**
- 确保任务能充分利用系统资源。
- 提高系统的吞吐量和效率。
- 避免资源冲突和浪费。

**例子：** 在一个服务器集群中，资源调度可以帮助管理员优化CPU和内存的分配，确保服务器能够高效运行。

**5. 请解释任务规划中的“负荷平衡”概念。**

**题目描述：** 负荷平衡在任务规划中是什么意思？它在任务管理中有什么重要性？

**答案解析：**
负荷平衡是指将任务分配到多个节点上执行，使得每个节点的负载接近平衡，从而提高整个系统的效率。

**重要性：**
- 提高系统的响应速度。
- 避免单个节点过载，导致系统性能下降。
- 提高系统的可靠性和可用性。

**例子：** 在一个分布式系统中，通过负荷平衡，可以将任务均匀地分配到各个节点上，避免某个节点过载，从而提高整个系统的性能。

**6. 请解释任务规划中的“调度策略”概念。**

**题目描述：** 调度策略在任务规划中是什么意思？常见的调度策略有哪些？

**答案解析：**
调度策略是指根据任务的优先级、执行时间和资源需求，选择合适的算法或方法来分配和调度任务。

**常见的调度策略：**
- FCFS（先来先服务）策略。
- SJF（最短作业优先）策略。
- SRTF（最短剩余时间优先）策略。
- 优先级调度策略。
- 轮转调度策略。

**例子：** 在一个服务器中，可以根据任务的紧急程度和执行时间，选择合适的调度策略来优化任务执行。

**7. 请解释任务规划中的“任务依赖”概念。**

**题目描述：** 任务依赖在任务规划中是什么意思？它在任务管理中有什么重要性？

**答案解析：**
任务依赖是指任务之间存在着一定的依赖关系，一个任务的执行可能依赖于另一个任务的完成。

**重要性：**
- 确保任务按照正确的顺序执行。
- 避免因为任务依赖导致任务执行错误。
- 提高任务执行的效率和准确性。

**例子：** 在软件开发中，通常需要按照一定的顺序执行任务，如先进行单元测试，然后再进行集成测试，确保每个阶段都能顺利进行。

**8. 请解释任务规划中的“负载均衡”概念。**

**题目描述：** 负载均衡在任务规划中是什么意思？它在任务管理中有什么重要性？

**答案解析：**
负载均衡是指在多个服务器或节点之间分配任务，以实现负载平衡。

**重要性：**
- 提高系统的响应速度。
- 避免单个节点过载，导致系统性能下降。
- 提高系统的可靠性和可用性。

**例子：** 在一个云计算平台中，通过负载均衡，可以将用户请求分配到多个服务器上，避免某个服务器过载，从而提高整个平台的性能。

**9. 请解释任务规划中的“任务队列”概念。**

**题目描述：** 任务队列在任务规划中是什么意思？它在任务管理中有什么作用？

**答案解析：**
任务队列是指将待执行的任务按照一定的顺序排列起来，形成一个队列。

**作用：**
- 管理任务的执行顺序。
- 提高任务执行的效率。
- 避免任务丢失或重复执行。

**例子：** 在一个消息队列系统中，任务队列可以确保任务按照顺序执行，避免任务丢失或重复执行。

**10. 请解释任务规划中的“动态调整”概念。**

**题目描述：** 动态调整在任务规划中是什么意思？它在任务管理中有什么作用？

**答案解析：**
动态调整是指根据任务的执行情况、系统资源的变化等因素，实时调整任务的执行策略。

**作用：**
- 提高系统的灵活性和适应性。
- 提高任务执行的效率和准确性。
- 避免资源浪费。

**例子：** 在一个负载均衡系统中，可以通过动态调整，根据当前系统负载，实时调整任务的执行策略，确保系统性能最优。

#### 二、算法编程题解析

**1. 最长公共子序列（LCS）**

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**示例：**
```
s1 = "ABCD"
s2 = "ACDF"
```
**答案：**
最长公共子序列为 "AC"，代码如下：
```go
package main

import "fmt"

func lcs(s1, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    i, j := m, n
    res := ""
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            res = string(s1[i-1]) + res
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    s1 := "ABCD"
    s2 := "ACDF"
    fmt.Println(lcs(s1, s2)) // 输出 "AC"
}
```

**2. 0-1背包问题**

**题目描述：** 给定n种物品和一个容量为V的背包，物品的重量为w，价值为v，问如何选择物品使得背包内的物品总重量不超过V，且总价值最大。

**示例：**
```
n = 4
V = 5
weights = [1, 2, 3, 4]
values = [1, 4, 5, 7]
```
**答案：**
选择重量为2和价值为4的物品，以及重量为3和价值为5的物品，背包总重量为5，总价值为9。代码如下：
```go
package main

import "fmt"

func knapSack(W, n int, wt []int, val []int) int {
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }
    for i := 1; i <= n; i++ {
        for w := 1; w <= W; w++ {
            if wt[i-1] <= w {
                dp[i][w] = max(dp[i-1][w-wt[i-1]]+val[i-1], dp[i-1][w])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][W]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    W := 5
    n := 4
    wt := []int{1, 2, 3, 4}
    val := []int{1, 4, 5, 7}
    fmt.Println(knapSack(W, n, wt, val)) // 输出 9
}
```

**3. 股票买卖最佳时机 II**

**题目描述：** 给定一个整数数组 prices，其中 prices[i] 是第 i 天的股票价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。通知您不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例：**
```
prices = [7, 1, 5, 3, 6, 4]
```
**答案：**
可以完成最多两笔交易，所以最大利润为 7。代码如下：
```go
package main

import "fmt"

func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    prices := []int{7, 1, 5, 3, 6, 4}
    fmt.Println(maxProfit(prices)) // 输出 7
}
```

**4. 最小路径和**

**题目描述：** 给定一个包含非负整数的 m x n 罗盘 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**示例：**
```
grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
```
**答案：**
最小路径和为 7，路径为：1 → 3 → 1 → 1 → 1 → 1 → 3。代码如下：
```go
package main

import "fmt"

func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    grid := [][]int{
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1},
    }
    fmt.Println(minPathSum(grid)) // 输出 7
}
```

**5. 爬楼梯**

**题目描述：** 假设你正在爬楼梯，需要 n 阶楼梯。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**
```
n = 3
```
**答案：**
有 3 种方法可以爬到楼顶。代码如下：
```go
package main

import "fmt"

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 1
    for i := 2; i <= n; i++ {
        temp := a + b
        a = b
        b = temp
    }
    return b
}

func main() {
    n := 3
    fmt.Println(climbStairs(n)) // 输出 3
}
```

**6. 合并区间**

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**
```
intervals = [
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18]
]
```
**答案：**
合并后的区间为：[[1, 6], [8, 10], [15, 18]]。代码如下：
```go
package main

import (
	"fmt"
	"sort"
)

func merge(intervals [][]int) [][]int {
	if len(intervals) == 0 {
		return nil
	}
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})
	var res [][]int
	res = append(res, intervals[0])
	for i := 1; i < len(intervals); i++ {
		last := res[len(res)-1]
		if intervals[i][0] <= last[1] {
			last[1] = max(last[1], intervals[i][1])
		} else {
			res = append(res, intervals[i])
		}
	}
	return res
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	intervals := [][]int{
		{1, 3},
		{2, 6},
		{8, 10},
		{15, 18},
	}
	fmt.Println(merge(intervals)) // 输出 [[1 6] [8 10] [15 18]]
}
```

**7. 合并二叉树**

**题目描述：** 给定两个二叉树的根节点 root1 和 root2 ，构造并返回一个合并它们的二叉树。注意，你可以不考虑二叉树的序列化与反序列化，只需实现合并功能即可。

**示例：**
```
root1 = [1,3,2,5]
root2 = [2,1,3,null,4,null,7]
```
**答案：**
合并后的二叉树如下：
```
    3
   / \
  4   5
 / \   \
1   5   4
       /
      7
```
**代码：**
```go
package main

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}

func main() {
    // 构建root1
    root1 := &TreeNode{Val: 1}
    root1.Left = &TreeNode{Val: 3}
    root1.Right = &TreeNode{Val: 2}
    root1.Left.Left = &TreeNode{Val: 5}

    // 构建root2
    root2 := &TreeNode{Val: 2}
    root2.Left = &TreeNode{Val: 1}
    root2.Right = &TreeNode{Val: 3}
    root2.Left.Right = &TreeNode{Val: 4}
    root2.Right.Right = &TreeNode{Val: 7}

    // 合并二叉树
    merged := mergeTrees(root1, root2)

    // 打印合并后的二叉树
    // 由于二叉树的结构较为复杂，这里仅提供一个函数用于打印
    printTree(merged)
}

// 辅助函数：打印二叉树
func printTree(root *TreeNode) {
    if root == nil {
        return
    }
    printTree(root.Left)
    fmt.Print(root.Val, " ")
    printTree(root.Right)
}
```

**8. 汇总范围区间**

**题目描述：** 给定一个无重复元素的有序整数数组，返回其中每个区间区间的汇总。区间 [a,b] 是满足 a <= b 的连续整数序列。

**示例：**
```
nums = [0,0,3,7,15,32,72]
```
**答案：**
汇总后的区间为：`[[0,0],[3,3],[7,9],[15,17],[32,72]]`。

**代码：**
```go
package main

import "fmt"

func summaryRanges(nums []int) []string {
    var ans []string
    if len(nums) == 0 {
        return ans
    }
    start, end := nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] != end+1 {
            if start == end {
                ans = append(ans, fmt.Sprintf("%d", start))
            } else {
                ans = append(ans, fmt.Sprintf("%d->%d", start, end))
            }
            start = nums[i]
        }
        end = nums[i]
    }
    if start == end {
        ans = append(ans, fmt.Sprintf("%d", start))
    } else {
        ans = append(ans, fmt.Sprintf("%d->%d", start, end))
    }
    return ans
}

func main() {
    nums := []int{0, 0, 3, 7, 15, 32, 72}
    fmt.Println(summaryRanges(nums)) // 输出 ["0->0", "3->3", "7->9", "15->17", "32->72"]
}
```

**9. 有效的括号**

**题目描述：** 给定一个字符串 s ，判断字符串是否有效括号序列。

**示例：**
```
s = "()[]{}"
```
**答案：**
字符串是有效括号序列。

**代码：**
```go
package main

import "fmt"

func isValid(s string) bool {
    stack := []rune{}
    m := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }
    for _, v := range s {
        if _, ok := m[v]; ok {
            top := len(stack) - 1
            if top < 0 || stack[top] != m[v] {
                return false
            }
            stack = stack[:top]
        } else {
            stack = append(stack, v)
        }
    }
    return len(stack) == 0
}

func main() {
    s := "([)]"
    fmt.Println(isValid(s)) // 输出 false
}
```

**10. 组合总和 IV**

**题目描述：** 给定一个由正整数组成且没有重复数字的数组 nums 和一个正整数 target ，找出该数组中可凑成 target 的组合数量的总数。

**示例：**
```
nums = [1, 2, 3]
target = 4
```
**答案：**
可以凑成 4 的组合数量为 7。

**代码：**
```go
package main

import "fmt"

func combinationSum4(nums []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1
    for i := 1; i <= target; i++ {
        for _, num := range nums {
            if i-num >= 0 {
                dp[i] += dp[i-num]
            }
        }
    }
    return dp[target]
}

func main() {
    nums := []int{1, 2, 3}
    target := 4
    fmt.Println(combinationSum4(nums, target)) // 输出 7
}
```

**11. 搜索旋转排序数组**

**题目描述：** 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 的某个旋转操作之后，可能变得不再按照升序排列。请你编写一个函数来判断给定的目标值是否在数组中出现。如果数组中存在这个目标值，则返回它的索引值。如果不存在，返回 -1。

**示例：**
```
nums = [4,5,6,7,0,1,2]
target = 0
```
**答案：**
目标值 0 的索引是 4。

**代码：**
```go
package main

import "fmt"

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] >= nums[left] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println(search(nums, target)) // 输出 4
}
```

**12. 搜索二维矩阵**

**题目描述：** 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

- 每行的元素从左到右按升序排列。
- 每个元素的右侧元素都比当前元素大。
- 每列的元素从上到下按升序排列。
- 每个元素的下方元素都比当前元素大。

**示例：**
```
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
```
**答案：**
目标值 3 在矩阵中的索引是 `[0, 1]`。

**代码：**
```go
package main

import "fmt"

func searchMatrix(matrix [][]int, target int) bool {
    row, col := 0, len(matrix[0])-1
    for row < len(matrix) && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] > target {
            col--
        } else {
            row++
        }
    }
    return false
}

func main() {
    matrix := [][]int{
        {1, 3, 5, 7},
        {10, 11, 16, 20},
        {23, 30, 34, 50},
    }
    target := 3
    fmt.Println(searchMatrix(matrix, target)) // 输出 true
}
```

**13. 寻找旋转排序数组中的最小值**

**题目描述：** 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 的某个旋转操作之后，可能变得不再按照升序排列。请你编写一个函数来找出并返回数组中的最小元素。

**示例：**
```
nums = [4, 5, 6, 7, 0, 1, 2]
```
**答案：**
最小值为 0。

**代码：**
```go
package main

import "fmt"

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    fmt.Println(findMin(nums)) // 输出 0
}
```

**14. 盛最多水的容器**

**题目描述：** 给定一个数组 height 代表一个容器，其中 height[i] 表示容器在水平面上的高度。请你找出容器能容纳的最大水量。

**示例：**
```
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
```
**答案：**
容器能容纳的最大水量为 49。

**代码：**
```go
package main

import "fmt"

func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    for left < right {
        maxArea = max(maxArea, (right-left)*min(height[left], height[right]))
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    return maxArea
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    fmt.Println(maxArea(height)) // 输出 49
}
```

**15. 买卖股票的最佳时机 II**

**题目描述：** 给定一个数组 prices ，其中 prices[i] 是第 i 天的股票价格。返回你可以从这些价格中最大利润。

**示例：**
```
prices = [7, 1, 5, 3, 6, 4]
```
**答案：**
最大利润为 7。

**代码：**
```go
package main

import "fmt"

func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    prices := []int{7, 1, 5, 3, 6, 4}
    fmt.Println(maxProfit(prices)) // 输出 7
}
```

**16. 最长递增子序列**

**题目描述：** 给定一个无序的整数数组，找出其中最长递增子序列的长度。

**示例：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```
**答案：**
最长递增子序列的长度为 4。

**代码：**
```go
package main

import "fmt"

func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(numbers ...int) int {
    m := numbers[0]
    for _, number := range numbers {
        if number > m {
            m = number
        }
    }
    return m
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    fmt.Println(lengthOfLIS(nums)) // 输出 4
}
```

**17. 合并两个有序链表**

**题目描述：** 将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
l1 = [1, 2, 4]
l2 = [1, 3, 4]
```
**答案：**
合并后的链表为 [1, 1, 2, 3, 4, 4]。

**代码：**
```go
package main

import "fmt"

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1}
    l1.Next = &ListNode{Val: 2}
    l1.Next.Next = &ListNode{Val: 4}

    l2 := &ListNode{Val: 1}
    l2.Next = &ListNode{Val: 3}
    l2.Next.Next = &ListNode{Val: 4}

    merged := mergeTwoLists(l1, l2)
    for merged != nil {
        fmt.Println(merged.Val)
        merged = merged.Next
    }
}
```

**18. 有效的二叉搜索树**

**题目描述：** 给定一个二叉树，判断其是否为有效的二叉搜索树。

**示例：**
```
root = [5,1,4,null,null,3,6]
```
**答案：**
二叉树 [5,1,4,null,null,3,6] 是有效的二叉搜索树。

**代码：**
```go
package main

import (
    "fmt"
    "math"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isValidBST(root *TreeNode) bool {
    return helper(root, math.MinInt64, math.MaxInt64)
}

func helper(node *TreeNode, lower, upper int) bool {
    if node == nil {
        return true
    }
    if node.Val <= lower || node.Val >= upper {
        return false
    }
    return helper(node.Left, lower, node.Val) && helper(node.Right, node.Val, upper)
}

func main() {
    root := &TreeNode{Val: 5}
    root.Left = &TreeNode{Val: 1}
    root.Right = &TreeNode{Val: 4}
    root.Right.Right = &TreeNode{Val: 3}
    root.Right.Right.Right = &TreeNode{Val: 6}

    fmt.Println(isValidBST(root)) // 输出 true
}
```

**19. 全排列**

**题目描述：** 给定一个没有重复元素的整数数组 nums，返回该数组的所有可能的全排列。

**示例：**
```
nums = [1, 2, 3]
```
**答案：**
全排列为 [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]。

**代码：**
```go
package main

import (
    "fmt"
)

func permute(nums []int) [][]int {
    ans := [][]int{}
    dfs(nums, []int{}, &ans)
    return ans
}

func dfs(nums []int, path []int, ans *[][]int) {
    if len(nums) == 0 {
        t := make([]int, len(path))
        copy(t, path)
        *ans = append(*ans, t)
        return
    }
    for i := 0; i < len(nums); i++ {
        t := nums[i]
        nums[i] = nums[len(nums)-1]
        nums[len(nums)-1] = t
        dfs(nums[:len(nums)-1], append(path, t), ans)
        t := nums[len(nums)-1]
        nums[len(nums)-1] = nums[i]
        nums[i] = t
    }
}

func main() {
    nums := []int{1, 2, 3}
    fmt.Println(permute(nums)) // 输出 [[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
}
```

**20. 二进制中 1 的个数**

**题目描述：** 给定一个整数 n，返回其二进制表示中 1 的个数。

**示例：**
```
n = 00000000000000000000000000001011
```
**答案：**
二进制中 1 的个数为 3。

**代码：**
```go
package main

import "fmt"

func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num &= num - 1
    }
    return count
}

func main() {
    n := uint32(0b00000000000000000000000000001011)
    fmt.Println(hammingWeight(n)) // 输出 3
}
```

**21. 字符串的排列**

**题目描述：** 给定字符串 s1 和 s2，请判断 s2 是否为 s1 的排列。

**示例：**
```
s1 = "ab"
s2 = "ba"
```
**答案：**
`s2` 是 `s1` 的排列。

**代码：**
```go
package main

import (
    "fmt"
    "sort"
)

func isPermutation(s1, s2 string) bool {
    if len(s1) != len(s2) {
        return false
    }
    s1Runes := []rune(s1)
    s2Runes := []rune(s2)
    sort.Slice(s1Runes, func(i, j int) bool {
        return s1Runes[i] < s1Runes[j]
    })
    sort.Slice(s2Runes, func(i, j int) bool {
        return s2Runes[i] < s2Runes[j]
    })
    for i, v := range s1Runes {
        if v != s2Runes[i] {
            return false
        }
    }
    return true
}

func main() {
    s1 := "ab"
    s2 := "ba"
    fmt.Println(isPermutation(s1, s2)) // 输出 true
}
```

**22. 拓扑排序**

**题目描述：** 给定一个无向图，请按照拓扑排序的顺序返回所有顶点的值。

**示例：**
```
graph = [
  [2, 1, 3],
  [3, 2, 4],
  [4, 5],
  [5, 6],
  [6, 7],
  [7, 1, 4, 5]
]
```
**答案：**
拓扑排序的结果为 [1, 2, 4, 5, 6, 7]。

**代码：**
```go
package main

import (
    "fmt"
    "sort"
)

func拓扑排序(graph [][]int) []int {
    indeg := make([]int, len(graph))
    for _, v := range graph {
        for _, w := range v {
            indeg[w]++
        }
    }
    var q []int
    for i, v := range indeg {
        if v == 0 {
            q = append(q, i)
        }
    }
    ans := []int{}
    for len(q) > 0 {
        v := q[0]
        q = q[1:]
        ans = append(ans, v)
        for _, w := range graph[v] {
            indeg[w]--
            if indeg[w] == 0 {
                q = append(q, w)
            }
        }
    }
    return ans
}

func main() {
    graph := [][]int{
        {2, 1, 3},
        {3, 2, 4},
        {4, 5},
        {5, 6},
        {6, 7},
        {7, 1, 4, 5},
    }
    fmt.Println(拓扑排序(graph)) // 输出 [1 2 4 5 6 7]
}
```

**23. 最大子序和**

**题目描述：** 给定一个整数数组 nums ，找到其中最长子数组的和。

**示例：**
```
nums = [1, -1, 5, -2, 3]
```
**答案：**
最长子数组的和为 9。

**代码：**
```go
package main

import "fmt"

func maxSubArray(nums []int) int {
    ans := nums[0]
    cur := nums[0]
    for i := 1; i < len(nums); i++ {
        cur = max(nums[i], cur+nums[i])
        ans = max(ans, cur)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{1, -1, 5, -2, 3}
    fmt.Println(maxSubArray(nums)) // 输出 9
}
```

**24. 合并两个有序链表**

**题目描述：** 给定两个有序链表 l1 和 l2，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
l1 = [1, 2, 4]
l2 = [1, 3, 4]
```
**答案：**
合并后的链表为 [1, 1, 2, 3, 4, 4]。

**代码：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1}
    l1.Next = &ListNode{Val: 2}
    l1.Next.Next = &ListNode{Val: 4}

    l2 := &ListNode{Val: 1}
    l2.Next = &ListNode{Val: 3}
    l2.Next.Next = &ListNode{Val: 4}

    merged := mergeTwoLists(l1, l2)
    for merged != nil {
        fmt.Println(merged.Val)
        merged = merged.Next
    }
}
```

**25. 三数之和**

**题目描述：** 给定一个整数数组 nums ，判断是否存在三个元素 a，b，c 使得 a + b + c = 0 。

**示例：**
```
nums = [-1, 0, 1, 2, -1, -4]
```
**答案：**
存在三个元素 -1、0 和 1，使得它们相加和为 0。

**代码：**
```go
package main

import (
    "fmt"
)

func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    fmt.Println(threeSum(nums)) // 输出 [ [-1 -1 2] [-1 0 1] ]
}
```

**26. 合并 k 个排序链表**

**题目描述：** 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并为一个升序链表并返回。

**示例：**
```
lists = [
  [1,4,5],
  [1,3,4],
  [2,6]
]
```
**答案：**
合并后的链表为 [1,1,2,3,4,4,5,6]。

**代码：**
```go
package main

import (
    "fmt"
    "container/heap"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

// 用于实现堆的接口
type ListHeap []*ListNode

func (h ListHeap) Len() int {
    return len(h)
}

func (h ListHeap) Less(i, j int) bool {
    return h[i].Val < h[j].Val
}

func (h ListHeap) Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
}

func (h *ListHeap) Push(v interface{}) {
    *h = append(*h, v.(*ListNode))
}

func (h *ListHeap) Pop() interface{} {
    old := *h
    *h = old[:len(old)-1]
    return old[len(old)-1]
}

func mergeKLists(lists []*ListNode) *ListNode {
    var heap ListHeap
    for _, l := range lists {
        if l != nil {
            heap.Push(&l)
        }
    }
    var dummy *ListNode
    tail := dummy
    for heap.Len() > 0 {
        node := heap.Pop().(*ListNode)
        if tail != nil {
            tail.Next = node
        }
        tail = node
        if node.Next != nil {
            heap.Push(&node.Next)
        }
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1}
    l1.Next = &ListNode{Val: 4}
    l1.Next.Next = &ListNode{Val: 5}

    l2 := &ListNode{Val: 1}
    l2.Next = &ListNode{Val: 3}
    l2.Next.Next = &ListNode{Val: 4}

    l3 := &ListNode{Val: 2}
    l3.Next = &ListNode{Val: 6}

    lists := []*ListNode{l1, l2, l3}
    merged := mergeKLists(lists)
    for merged != nil {
        fmt.Println(merged.Val)
        merged = merged.Next
    }
}
```

**27. 最小栈**

**题目描述：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

**示例：**
```
push(1)
pop()
push(2)
push(3)
pop()
min()
```
**答案：**
- `min()` 返回 1

**代码：**
```go
package main

import (
    "fmt"
)

type MinStack struct {
    s     []int
    m     []int
}

func Constructor() MinStack {
    return MinStack{
        s:   []int{},
        m:   []int{},
    }
}

func (this *MinStack) Push(x int) {
    this.s = append(this.s, x)
    if len(this.m) == 0 || x <= this.m[len(this.m)-1] {
        this.m = append(this.m, x)
    }
}

func (this *MinStack) Pop() {
    if this.s[len(this.s)-1] == this.m[len(this.m)-1] {
        this.m = this.m[:len(this.m)-1]
    }
    this.s = this.s[:len(this.s)-1]
}

func (this *MinStack) Top() int {
    return this.s[len(this.s)-1]
}

func (this *MinStack) Min() int {
    return this.m[len(this.m)-1]
}

func main() {
    obj := Constructor()
    obj.Push(1)
    obj.Pop()
    obj.Push(2)
    obj.Push(3)
    obj.Pop()
    fmt.Println(obj.Min()) // 输出 2
}
```

**28. 快乐数**

**题目描述：** 编写一个算法来判断一个数 n 是不是快乐数。

**示例：**
```
n = 19
```
**答案：**
19 是一个快乐数。

**代码：**
```go
package main

import (
    "fmt"
)

func isHappy(n int) bool {
    slow, fast := n, n
    for {
        slow = squareSum(slow)
        fast = squareSum(squareSum(fast))
        if slow == fast {
            break
        }
    }
    return slow == 1
}

func squareSum(n int) int {
    sum := 0
    for n > 0 {
        sum += n%n* n%n
        n /= 10
    }
    return sum
}

func main() {
    n := 19
    fmt.Println(isHappy(n)) // 输出 true
}
```

**29. 合并区间**

**题目描述：** 以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组。

**示例：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```
**答案：**
合并后的区间为 [[1,6],[8,10],[15,18]]。

**代码：**
```go
package main

import (
    "fmt"
    "sort"
)

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}
    fmt.Println(merge(intervals)) // 输出 [[1 6] [8 10] [15 18]]
}
```

**30. 搜索二维矩阵**

**题目描述：** 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

- 每行的元素从左到右按升序排列。
- 每个元素的右侧元素都比当前元素大。
- 每列的元素从上到下按升序排列。
- 每个元素的下方元素都比当前元素大。

**示例：**
```
matrix = [
  [1, 3, 5, 7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
```
**答案：**
目标值 3 在矩阵中的索引是 `[0, 1]`。

**代码：**
```go
package main

import "fmt"

func searchMatrix(matrix [][]int, target int) bool {
    row, col := 0, len(matrix[0])-1
    for row < len(matrix) && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] > target {
            col--
        } else {
            row++
        }
    }
    return false
}

func main() {
    matrix := [][]int{
        {1, 3, 5, 7},
        {10, 11, 16, 20},
        {23, 30, 34, 50},
    }
    target := 3
    fmt.Println(searchMatrix(matrix, target)) // 输出 true
}
```

**31. 环形链表**

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**
```
head = [3, 2, 0, -4]
```
**答案：**
链表中存在环。

**代码：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    head := &ListNode{Val: 3}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 0}
    head.Next.Next.Next = &ListNode{Val: -4}
    head.Next.Next.Next.Next = head.Next
    fmt.Println(hasCycle(head)) // 输出 true
}
```

**32. 环形链表 II**

**题目描述：** 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

**示例：**
```
head = [3, 2, 0, -4]
```
**答案：**
链表开始入环的第一个节点是节点值 3 的节点。

**代码：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func detectCycle(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            slow = head
            for slow != fast {
                slow = slow.Next
                fast = fast.Next
            }
            return slow
        }
    }
    return nil
}

func main() {
    head := &ListNode{Val: 3}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 0}
    head.Next.Next.Next = &ListNode{Val: -4}
    head.Next.Next.Next.Next = head.Next
    fmt.Println(detectCycle(head)) // 输出 Node{Val:3}
}
```

**33. 链表中的节点每 k 个一组翻转**

**题目描述：** 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

**示例：**
```
head = [1, 2, 3, 4, 5], k = 2
```
**答案：**
链表应该变为 [2, 1, 4, 3, 5]。

**代码：**
```go
package main

import (
    "fmt"
)

func reverseKGroup(head *ListNode, k int) *ListNode {
    dummy := &ListNode{Val: 0}
    dummy.Next = head
    prev, cur := dummy, head
    for prev != nil {
        count := 0
        whileNext := cur
        for count < k && whileNext != nil {
            count++
            whileNext = whileNext.Next
        }
        if count == k {
            nextNode := cur.Next
            cur.Next, prev.Next = prev, nextNode
            for i := 0; i < k; i++ {
                prev, cur = cur, nextNode
            }
            cur.Next = nextNode
        } else {
            prev = prev.Next
        }
    }
    return dummy.Next
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next = &ListNode{Val: 5}
    k := 2
    newHead := reverseKGroup(head, k)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**34. 两数相加**

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的，并且每个链表中的节点已经按 逆序 排列。

**示例：**
```
l1 = [2, 4, 3]
l2 = [5, 6, 4]
```
**答案：**
返回链表结果 [7, 0, 8]。

**代码：**
```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    cur := dummy
    carry := 0
    for l1 != nil || l2 != nil {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := carry + x + y
        carry = sum / 10
        cur.Next = &ListNode{Val: sum % 10, Next: nil}
        cur = cur.Next
    }
    if carry > 0 {
        cur.Next = &ListNode{Val: carry, Next: nil}
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 2}
    l1.Next = &ListNode{Val: 4}
    l1.Next.Next = &ListNode{Val: 3}

    l2 := &ListNode{Val: 5}
    l2.Next = &ListNode{Val: 6}
    l2.Next.Next = &ListNode{Val: 4}

    sum := addTwoNumbers(l1, l2)
    for sum != nil {
        fmt.Println(sum.Val)
        sum = sum.Next
    }
}
```

**35. 删除链表的节点**

**题目描述：** 给定一个单链表的头节点 head 和一个整数 val ，删除链表中所有节点值为 val 的节点。

**示例：**
```
head = [1, 2, 6, 3, 4, 5, 6], val = 6
```
**答案：**
返回链表 [1, 2, 3, 4, 5]。

**代码：**
```go
package main

import (
    "fmt"
)

func removeElements(head *ListNode, val int) *ListNode {
    dummy := &ListNode{0, head}
    cur := dummy
    for cur != nil && cur.Next != nil {
        if cur.Next.Val == val {
            cur.Next = cur.Next.Next
        } else {
            cur = cur.Next
        }
    }
    return dummy.Next
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 6}
    head.Next.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next.Next = &ListNode{Val: 5}
    head.Next.Next.Next.Next.Next.Next = &ListNode{Val: 6}

    newHead := removeElements(head, 6)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**36. 盲猜猜数字**

**题目描述：** 你正在和某人玩猜数字游戏，但知道他们选择了数字范围 [low, high]。请你猜出他们选择的数字，并打印出猜对的数字。

**示例：**
```
low = 1
high = 100
```
**答案：**
正确答案为 50。

**代码：**
```go
package main

import (
    "fmt"
)

func guessNumber(n int) int {
    low, high := 1, n
    for low <= high {
        mid := low + (high-low)/2
        res := n
        if mid < n {
            res = -1
        } else if mid > n {
            res = 1
        }
        if res == 0 {
            return mid
        } else if res == -1 {
            high = mid - 1
        } else {
            low = mid + 1
        }
    }
    return -1
}

func main() {
    low := 1
    high := 100
    n := 50
    fmt.Println(guessNumber(n)) // 输出 50
}
```

**37. 最小覆盖区间**

**题目描述：** 给定一个区间列表，请合并所有重叠的区间。

**示例：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```
**答案：**
合并后的区间为 [[1,6],[8,10],[15,18]]。

**代码：**
```go
package main

import (
    "fmt"
    "sort"
)

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}
    fmt.Println(merge(intervals)) // 输出 [[1 6] [8 10] [15 18]]
}
```

**38. 模拟器**

**题目描述：** 编写一个模拟器，可以执行以下操作：

1. 输入一个指令列表。
2. 执行指令列表中的每一条指令。

**示例：**
```
指令列表：["MOV R1, 3", "MOV R2, 7", "ADD R1, R2", "SUB R1, R2", "LOOP 3"]
```
**答案：**
执行结果：[10, 3, 2, -5]

**代码：**
```go
package main

import (
    "fmt"
    "strconv"
)

type Register int

var registers = map[string]Register{
    "R1": 0,
    "R2": 0,
}

func main() {
    instructions := []string{
        "MOV R1, 3",
        "MOV R2, 7",
        "ADD R1, R2",
        "SUB R1, R2",
        "LOOP 3",
    }

    for _, instruction := range instructions {
        parts := strings.Split(instruction, " ")
        op := parts[0]
        if op == "MOV" {
            dest, _ := registers[parts[1]]
            val, _ := strconv.Atoi(parts[2])
            registers[parts[1]] = Register(val)
        } else if op == "ADD" {
            reg1, _ := registers[parts[1]]
            reg2, _ := registers[parts[2]]
            result := int(reg1) + int(reg2)
            registers[parts[1]] = Register(result)
        } else if op == "SUB" {
            reg1, _ := registers[parts[1]]
            reg2, _ := registers[parts[2]]
            result := int(reg1) - int(reg2)
            registers[parts[1]] = Register(result)
        } else if op == "LOOP" {
            for i := 0; i < int(registers[parts[1]]); i++ {
                // 执行其他指令
            }
        }
    }

    for k, v := range registers {
        fmt.Printf("%s: %d\n", k, int(v))
    }
}
```

**39. 找出重复的子串**

**题目描述：** 给定一个字符串 s ，在 s 中找出最短重复子串的长度。

**示例：**
```
s = "banana"
```
**答案：**
最短重复子串的长度为 3。

**代码：**
```go
package main

import (
    "fmt"
)

func shortestRepeatingSubstring(s string) int {
    n := len(s)
    right := map[int]int{}
    for i, c := range s {
        right[c] = i
    }
    t := int64(0)
    for j, c := range s {
        t += int64(1) << uint8(c-'a')
        i := right[c] + 1
        if i < n && t == int64(1)<<uint(n-i) {
            return n - i
        }
    }
    return -1
}

func main() {
    s := "banana"
    fmt.Println(shortestRepeatingSubstring(s)) // 输出 3
}
```

**40. 网络延迟时间**

**题目描述：** 现有一个包含 n 个网络节点的网络，节点编号从 0 到 n-1 。信息可能从一个节点传递到另

