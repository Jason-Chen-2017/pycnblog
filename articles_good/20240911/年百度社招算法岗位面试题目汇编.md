                 

# 2025年百度社招算法岗位面试题目汇编

## 引言

百度作为中国领先的人工智能公司，其社招算法岗位的面试题目往往具有很高的难度和代表性。本文档汇编了2025年百度社招算法岗位的典型面试题目，旨在帮助准备面试的算法工程师们更好地应对面试挑战。本文将包括20~30道典型面试题目及其满分答案解析，覆盖了算法、数据结构、编程语言等多个方面。

## 面试题库

### 1. 排序算法

**题目：** 实现快速排序算法，并解释其时间复杂度和空间复杂度。

**答案：**

快速排序算法是一种高效的排序算法，其平均时间复杂度为 \(O(n\log n)\)，最坏的时间复杂度为 \(O(n^2)\)，空间复杂度为 \(O(\log n)\)。

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 示例
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))
```

**解析：** 快速排序通过选择一个基准元素，将数组分成两部分，一部分小于基准元素，一部分大于基准元素，然后递归地对这两部分进行排序。时间复杂度主要由递归深度决定，最坏情况是每次递归分割得到的子数组大小相等，从而导致时间复杂度为 \(O(n^2)\)。平均情况下，每次分割能将数组大小减半，因此平均时间复杂度为 \(O(n\log n)\)。

### 2. 二叉树遍历

**题目：** 实现二叉树的先序、中序和后序遍历。

**答案：**

二叉树的遍历有三种方式：先序遍历、中序遍历和后序遍历。

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def preorder_traversal(root):
    if root:
        print(root.val, end=' ')
        preorder_traversal(root.left)
        preorder_traversal(root.right)

def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print(root.val, end=' ')
        inorder_traversal(root.right)

def postorder_traversal(root):
    if root:
        postorder_traversal(root.left)
        postorder_traversal(root.right)
        print(root.val, end=' ')

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("先序遍历:")
preorder_traversal(root)
print("\n中序遍历:")
inorder_traversal(root)
print("\n后序遍历:")
postorder_traversal(root)
```

**解析：** 二叉树的遍历是对树中所有节点访问一次且仅访问一次。三种遍历方式区别在于访问节点的顺序不同。先序遍历首先访问根节点，然后递归地遍历左子树和右子树；中序遍历先递归地遍历左子树，访问根节点，然后递归地遍历右子树；后序遍历先递归地遍历左子树，右子树，最后访问根节点。

### 3. 回溯算法

**题目：** 实现八皇后问题，使用回溯算法寻找所有解决方案。

**答案：**

八皇后问题是经典的回溯算法问题。目标是在一个 \(8 \times 8\) 的棋盘上放置8个皇后，使得任意两个皇后都不在同一行、同一列和对角线上。

```python
def is_safe(queen, row, col, n):
    for i in range(row):
        if queen[i] == col or \
           queen[i] - i == col - row or \
           queen[i] + i == col + row:
            return False
    return True

def place_queens(queen, row, n):
    if row == n:
        print("解：")
        for r in range(n):
            print(" ".join(str(x) if x == queen[r] else '.' for x in range(n)))
        print("\n")
    else:
        for col in range(n):
            if is_safe(queen, row, col, n):
                queen[row] = col
                place_queens(queen, row + 1, n)

def solve_eight_queens():
    queen = [-1] * 8
    place_queens(queen, 0, 8)

solve_eight_queens()
```

**解析：** 回溯算法通过尝试所有的可能性，并在遇到不满足条件的情况时回溯到上一步。在放置皇后时，检查每一行、每一列以及两条对角线上的冲突情况，如果满足条件，则继续放置下一个皇后；否则回溯到上一个皇后并尝试下一个位置。

### 4. 动态规划

**题目：** 给定一个整数数组，找出最长子序列和。

**答案：**

最长子序列和问题可以使用动态规划算法解决。

```python
def max_subarray_sum(arr):
    max_ending_here = max_so_far = arr[0]
    for x in arr[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

# 示例
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(arr))
```

**解析：** 动态规划通过维护两个变量，一个表示当前最大子序列和，一个表示全局最大子序列和。对于每个元素，更新当前最大子序列和，并更新全局最大子序列和。最终返回全局最大子序列和。

### 5. 堆排序

**题目：** 使用堆实现排序算法，并解释堆的性质。

**答案：**

堆排序算法是一种利用堆这种数据结构的排序算法。最大堆（大根堆）的性质是父节点的值大于或等于其子节点的值。

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

    return arr

# 示例
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("排序后的数组：")
for i in range(len(arr)):
    print("%d" % arr[i], end=" ")
```

**解析：** 堆排序首先将数组构建成最大堆，然后交换堆顶元素（最大值）与最后一个元素，然后重新调整堆结构，重复这个过程直到所有元素被排序。

### 6. 双指针法

**题目：** 使用双指针法实现寻找两个有序数组中的中位数。

**答案：**

```python
def findMedianSortedArrays(nums1, nums2):
    nums = nums1 + nums2
    nums.sort()
    n = len(nums)
    if n % 2 == 0:
        return (nums[n // 2 - 1] + nums[n // 2]) / 2
    else:
        return nums[n // 2]

# 示例
nums1 = [1, 3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2))
```

**解析：** 双指针法通过对两个有序数组合并，找到中位数。将两个数组合并为一个数组后，根据数组长度判断中位数的位置，如果是偶数，取中间两个数的平均值；如果是奇数，取中间的数。

### 7. BFS

**题目：** 使用广度优先搜索实现寻找最短路径。

**答案：**

```python
from collections import deque

def bfs(graph, start, goal):
    visited = set()
    queue = deque([(start, [start])])

    while queue:
        node, path = queue.popleft()
        if node == goal:
            return path
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                new_path = path + [neighbor]
                queue.append((neighbor, new_path))

    return None

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
print(bfs(graph, 'A', 'F'))
```

**解析：** BFS（广度优先搜索）从起始节点开始，依次访问其相邻节点，并将未访问的节点加入队列。当找到目标节点时，返回路径。

### 8. DFS

**题目：** 使用深度优先搜索实现寻找所有路径。

**答案：**

```python
def dfs(graph, node, path, paths):
    path.append(node)
    if node == 'F':
        paths.append(list(path))
    for child in graph[node]:
        dfs(graph, child, path, paths)
    path.pop()

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
paths = []
dfs(graph, 'A', [], paths)
print(paths)
```

**解析：** DFS（深度优先搜索）通过递归遍历节点的所有子节点，找到所有可能的路径。

### 9. 快速选择

**题目：** 使用快速选择算法实现寻找第k大元素。

**答案：**

```python
import random

def quickselect(arr, k):
    if len(arr) == 1:
        return arr[0]

    pivot = random.choice(arr)
    low = [x for x in arr if x < pivot]
    high = [x for x in arr if x > pivot]
    pivot_count = len(arr) - len(low) - len(high)

    if k < len(low):
        return quickselect(low, k)
    elif k < len(low) + pivot_count:
        return pivot
    else:
        return quickselect(high, k - len(low) - pivot_count)

# 示例
arr = [3, 2, 1, 5, 6, 4]
k = 2
print(quickselect(arr, k))
```

**解析：** 快速选择是一种基于选择算法原理的快速寻找第k大元素的算法，通过递归选择基准元素，将数组分为三部分。

### 10. 前缀树

**题目：** 实现一个前缀树（Trie）并实现查询功能。

**答案：**

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

# 示例
trie = Trie()
words = ["apple", "app", "bat", "bar", "ball"]
for word in words:
    trie.insert(word)

print(trie.search("apple"))  # 输出 True
print(trie.search("app"))    # 输出 True
print(trie.search("bat"))    # 输出 True
print(trie.search("bar"))    # 输出 True
print(trie.search("ball"))   # 输出 True
print(trie.search("b"))      # 输出 False
```

**解析：** 前缀树是一种高效存储和查询字符串数据的数据结构。每个节点代表一个字符，从根节点到某个节点路径上的所有字符串都是前缀。

### 11. 红黑树

**题目：** 实现一个红黑树并插入节点。

**答案：**

```python
class Node:
    def __init__(self, value, color="red"):
        self.value = value
        self.color = color
        self.parent = None
        self.left = None
        self.right = None

class RedBlackTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        node = Node(value)
        if not self.root:
            self.root = node
        else:
            self._insert(self.root, node)

    def _insert(self, root, node):
        if node.value < root.value:
            if root.left:
                self._insert(root.left, node)
            else:
                root.left = node
                node.parent = root
                self.fix_insert(node)
        elif node.value > root.value:
            if root.right:
                self._insert(root.right, node)
            else:
                root.right = node
                node.parent = root
                self.fix_insert(node)

    def fix_insert(self, node):
        while node != self.root and node.parent.color == "red":
            if node.parent == node.parent.parent.left:
                uncle = node.parent.parent.right
                if uncle and uncle.color == "red":
                    node.parent.color = "black"
                    uncle.color = "black"
                    node.parent.parent.color = "red"
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        node = node.parent
                        self.left_rotate(node)
                    node.parent.color = "black"
                    node.parent.parent.color = "red"
                    self.right_rotate(node.parent.parent)
            else:
                uncle = node.parent.parent.left
                if uncle and uncle.color == "red":
                    node.parent.color = "black"
                    uncle.color = "black"
                    node.parent.parent.color = "red"
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        node = node.parent
                        self.right_rotate(node)
                    node.parent.color = "black"
                    node.parent.parent.color = "red"
                    self.left_rotate(node.parent.parent)
        self.root.color = "black"

    def left_rotate(self, x):
        y = x.right
        x.right = y.left
        if y.left:
            y.left.parent = x
        y.parent = x.parent
        if not x.parent:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    def right_rotate(self, y):
        x = y.left
        y.left = x.right
        if x.right:
            x.right.parent = y
        x.parent = y.parent
        if not y.parent:
            self.root = x
        elif y == y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x

# 示例
rbt = RedBlackTree()
values = [20, 15, 25, 10, 18, 30]
for value in values:
    rbt.insert(value)

# 打印树
def print_tree(node, level=0):
    if node is not None:
        print_tree(node.right, level + 1)
        print(" " * 4 * level + str(node.value) + " [" + node.color + "]")
        print_tree(node.left, level + 1)

print_tree(rbt.root)
```

**解析：** 红黑树是一种自平衡的二叉搜索树，每个节点包含颜色属性，保证了树的平衡性。插入节点后，可能需要执行一系列的旋转和重新着色操作来保持树的平衡。

### 12. 链表

**题目：** 实现单链表并实现常见操作。

**答案：**

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def insert(self, data, position):
        new_node = Node(data)
        if position == 0:
            new_node.next = self.head
            self.head = new_node
        else:
            current = self.head
            for _ in range(position - 1):
                if current is None:
                    return
                current = current.next
            new_node.next = current.next
            current.next = new_node

    def delete(self, position):
        if position == 0:
            self.head = self.head.next
        else:
            current = self.head
            for _ in range(position - 1):
                if current is None:
                    return
                current = current.next
            if current.next:
                current.next = current.next.next

    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# 示例
ll = LinkedList()
ll.append(1)
ll.append(2)
ll.append(3)
ll.insert(4, 2)
ll.delete(1)
ll.display()
```

**解析：** 单链表是一种线性数据结构，每个节点只包含一个数据元素和一个指向下一个节点的指针。通过插入和删除操作可以动态地改变链表的结构。

### 13. 图

**题目：** 实现图的邻接表表示并实现广度优先搜索。

**答案：**

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    def bfs(self, start):
        visited = set()
        queue = [start]
        visited.add(start)

        while queue:
            vertex = queue.pop(0)
            print(vertex, end=" ")
            for neighbour in self.graph[vertex]:
                if neighbour not in visited:
                    queue.append(neighbour)
                    visited.add(neighbour)

# 示例
g = Graph()
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 2)
g.add_edge(2, 0)
g.add_edge(2, 3)
print("BFS:", end=" ")
g.bfs(2)
```

**解析：** 图是一种由节点（顶点）和边组成的数据结构。邻接表是图的一种表示方式，每个节点包含指向相邻节点的指针。通过广度优先搜索可以找到从起始节点到其他所有节点的最短路径。

### 14. 排序算法——冒泡排序

**题目：** 实现冒泡排序算法。

**答案：**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# 示例
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("排序后的数组：")
for i in range(len(arr)):
    print("%d" % arr[i], end=" ")
```

**解析：** 冒泡排序是一种简单的排序算法，通过重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行，直到没有再需要交换的元素为止。

### 15. 排序算法——选择排序

**题目：** 实现选择排序算法。

**答案：**

```python
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# 示例
arr = [64, 34, 25, 12, 22, 11, 90]
selection_sort(arr)
print("排序后的数组：")
for i in range(len(arr)):
    print("%d" % arr[i], end=" ")
```

**解析：** 选择排序是一种简单直观的排序算法，首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

### 16. 字符串匹配——KMP算法

**题目：** 实现字符串匹配的KMP算法。

**答案：**

```python
def compute_lps_array(pattern):
    length = len(pattern)
    lps = [0] * length
    length_of_previous_longest_prefix_suffix = 0
    i = 1

    while i < length:
        if pattern[i] == pattern[length_of_previous_longest_prefix_suffix]:
            length_of_previous_longest_prefix_suffix += 1
            lps[i] = length_of_previous_longest_prefix_suffix
            i += 1
        else:
            if length_of_previous_longest_prefix_suffix != 0:
                length_of_previous_longest_prefix_suffix = lps[length_of_previous_longest_prefix_suffix - 1]
            else:
                lps[i] = 0
                i += 1

    return lps

def KMP_search patr
```<|vq_14031|>### 17. 字符串匹配——BF算法

**题目：** 实现字符串匹配的BF算法。

**答案：**

```python
def BF_search(pattern, text):
    M = len(pattern)
    N = len(text)

    # 先移动模式串的起始位置，然后逐个字符比较
    for i in range(N - M + 1):
        j = 0
        while j < M:
            if pattern[j] != text[i + j]:
                break
            if j == M - 1:  # 如果匹配成功
                return i  # 返回匹配的起始位置

        # 如果匹配失败，模式串向后移动
        i += (j - i)

    return -1  # 没有匹配成功
```

**解析：** BF（Boyer-Moore）算法是一种高效的字符串匹配算法。该算法的基本思想是，当匹配失败时，不是每次都将模式串向后移动一个字符，而是根据某种规则，将模式串向后移动多个字符，从而提高匹配效率。

### 18. 数学问题——求最大公因数

**题目：** 实现欧几里得算法求最大公因数。

**答案：**

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

# 示例
print(gcd(60, 48))  # 输出 12
```

**解析：** 欧几里得算法（也称辗转相除法）是一种用于计算两个整数最大公因数的算法。算法的步骤是不断用较小数去除较大数，然后用得到的余数去除之前的除数，重复这个过程，直到余数为0。此时，较大数即为最大公因数。

### 19. 数学问题——计算阶乘

**题目：** 实现递归和循环两种方法计算一个数的阶乘。

**答案：**

递归方法：

```python
def factorial_recursive(n):
    if n == 0:
        return 1
    else:
        return n * factorial_recursive(n - 1)

# 示例
print(factorial_recursive(5))  # 输出 120
```

循环方法：

```python
def factorial_loop(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

# 示例
print(factorial_loop(5))  # 输出 120
```

**解析：** 阶乘是一个正整数乘以所有小于它的正整数的乘积。递归方法通过不断调用自身来计算阶乘，而循环方法使用一个循环来迭代计算。

### 20. 图算法——Dijkstra算法

**题目：** 实现Dijkstra算法求解单源最短路径。

**答案：**

```python
import heapq

def dijkstra(graph, start):
    dist = {node: float('infinity') for node in graph}
    dist[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_dist, current_node = heapq.heappop(priority_queue)

        if current_dist > dist[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_dist + weight

            if distance < dist[neighbor]:
                dist[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return dist

# 示例
graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'C': 1, 'D': 1},
    'C': {'A': 3, 'B': 1, 'D': 2},
    'D': {'B': 1, 'C': 2}
}
print(dijkstra(graph, 'A'))
```

**解析：** Dijkstra算法是一种用于计算图中每个顶点到起始顶点的最短路径的算法。算法使用一个优先队列（最小堆）来选择距离当前起始顶点最远的未访问顶点，并更新其最短路径距离。

### 21. 图算法——Floyd-Warshall算法

**题目：** 实现Floyd-Warshall算法求解所有顶点之间的最短路径。

**答案：**

```python
def floyd_warshall(graph):
    dist = [[float('infinity')] * len(graph) for _ in range(len(graph))]
    for i in range(len(graph)):
        dist[i][i] = 0

    for u in range(len(graph)):
        for v in range(len(graph)):
            dist[u][v] = graph[u][v]

    for k in range(len(graph)):
        for i in range(len(graph)):
            for j in range(len(graph)):
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

    return dist

# 示例
graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'C': 1, 'D': 1},
    'C': {'A': 3, 'B': 1, 'D': 2},
    'D': {'B': 1, 'C': 2}
}
print(floyd_warshall(graph))
```

**解析：** Floyd-Warshall算法是一种用于计算图中所有顶点之间最短路径的算法。算法通过逐步扩大中间顶点的方式，更新所有顶点之间的最短路径距离。

### 22. 算法问题——二分查找

**题目：** 实现二分查找算法在有序数组中查找目标元素。

**答案：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1

# 示例
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(binary_search(arr, 5))  # 输出 4
```

**解析：** 二分查找算法通过将搜索区间一分为二，每次将中间位置的元素与目标值比较，根据比较结果缩小搜索范围。算法的时间复杂度为 \(O(\log n)\)。

### 23. 算法问题——归并排序

**题目：** 实现归并排序算法。

**答案：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result

# 示例
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = merge_sort(arr)
print("排序后的数组：")
for i in range(len(sorted_arr)):
    print("%d" % sorted_arr[i], end=" ")
```

**解析：** 归并排序是一种经典的排序算法，其核心思想是将待排序的序列不断拆分成子序列，直到每个子序列只有一个元素，然后合并这些子序列，逐步构建出有序序列。算法的时间复杂度为 \(O(n\log n)\)。

### 24. 算法问题——快速排序

**题目：** 实现快速排序算法。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# 示例
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))
```

**解析：** 快速排序是一种高效的排序算法，通过选取一个基准元素，将数组分为两部分，然后递归地对两部分进行排序。算法的时间复杂度为 \(O(n\log n)\)。

### 25. 数据结构——队列

**题目：** 实现队列的入队和出队操作。

**答案：**

```python
class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)
        else:
            return None

    def is_empty(self):
        return len(self.items) == 0

# 示例
q = Queue()
q.enqueue(1)
q.enqueue(2)
q.enqueue(3)
print(q.dequeue())  # 输出 1
print(q.dequeue())  # 输出 2
```

**解析：** 队列是一种先进先出（FIFO）的数据结构，通过入队和出队操作实现元素的插入和删除。入队操作将元素添加到队列的末尾，而出队操作则删除队列的头部元素。

### 26. 数据结构——栈

**题目：** 实现栈的入栈和出栈操作。

**答案：**

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            return None

    def is_empty(self):
        return len(self.items) == 0

# 示例
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.pop())  # 输出 3
print(s.pop())  # 输出 2
```

**解析：** 栈是一种后进先出（LIFO）的数据结构，通过入栈和出栈操作实现元素的插入和删除。入栈操作将元素添加到栈顶，而出栈操作则删除栈顶元素。

### 27. 算法问题——动态规划——最长公共子序列

**题目：** 实现动态规划求解最长公共子序列。

**答案：**

```python
def longest_common_subsequence(X, Y):
    m = len(X)
    n = len(Y)

    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

# 示例
X = "AGGTAB"
Y = "GXTXAYB"
print(longest_common_subsequence(X, Y))  # 输出 4
```

**解析：** 最长公共子序列（LCS）是两个序列中长度最长的公共子序列。动态规划通过构造一个二维数组来存储子问题的解，最终得到整个问题的解。算法的时间复杂度为 \(O(mn)\)。

### 28. 算法问题——动态规划——零钱兑换

**题目：** 使用动态规划求解给定金额的最小硬币数量。

**答案：**

```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# 示例
coins = [1, 2, 5]
amount = 11
print(coin_change(coins, amount))  # 输出 3
```

**解析：** 给定一定数量的硬币和目标金额，动态规划通过构造一个一维数组来存储当前金额的最小硬币数量。算法的时间复杂度为 \(O(amount \times n)\)，其中 \(n\) 是硬币的数量。

### 29. 算法问题——贪心算法——背包问题

**题目：** 使用贪心算法求解01背包问题。

**答案：**

```python
def knapSack(W, wt, val, n):
    # 初始化一个长度为W的数组，用于存储每种重量的最优解
    dp = [0] * (W + 1)

    # 遍历物品
    for i in range(n):
        # 遍历当前物品的重量
        for j in range(W, wt[i] - 1, -1):
            # 更新dp数组
            dp[j] = max(dp[j], dp[j - wt[i]] + val[i])

    return dp[W]

# 示例
val = [60, 100, 120]
wt = [10, 20, 30]
W = 50
n = len(val)
print(knapSack(W, wt, val, n))  # 输出 220
```

**解析：** 01背包问题是给定一组物品，每个物品有一定的价值和重量，求解在总重量不超过给定限制时，能够获取的最大价值。贪心算法通过每次选择当前重量最优的物品，逐步更新最优解。

### 30. 算法问题——哈希表——两数之和

**题目：** 使用哈希表实现两数之和问题。

**答案：**

```python
def twoSum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i

    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))  # 输出 [0, 1]
```

**解析：** 两数之和问题要求在数组中找到两个数，使得它们的和等于给定的目标值。通过使用哈希表，可以快速查找数组中的任意元素，从而降低时间复杂度。算法的时间复杂度为 \(O(n)\)。

## 总结

本文档汇编了2025年百度社招算法岗位的典型面试题目，覆盖了排序、搜索、图算法、动态规划、贪心算法等多个方面。通过详细解析和代码示例，帮助读者更好地理解面试题的解决方案。希望本文档对准备面试的算法工程师们有所帮助。如果读者有任何疑问或建议，欢迎在评论区留言。

