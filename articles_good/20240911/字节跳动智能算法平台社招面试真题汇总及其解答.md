                 

### 1. 字符串匹配算法

#### 题目

给定一个字符串 `s` 和一个模式 `p`，实现一个支持 '.' 和 `*` 的正则表达式匹配。

```python
def isMatch(s: str, p: str) -> bool:
    pass
```

#### 答案解析

这道题的核心在于理解 '.' 和 `*` 的含义：

- '.' 可以匹配任意单个字符。
- `*` 可以匹配前面的任意数量的字符，包括零个。

首先，我们可以使用动态规划的方法来解决这个问题。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s` 的前 `i` 个字符和模式 `p` 的前 `j` 个字符是否匹配。

状态转移方程如下：

- 当 `p[j-1]` 不是 `*` 时，`dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')`。
- 当 `p[j-1]` 是 `*` 时，`dp[i][j]` 可以由以下几种情况决定：
  - `dp[i][j-2]`：表示忽略 `*`，即 `p[j-2]` 匹配了零个字符。
  - `dp[i-1][j]`：表示 `*` 匹配了一个或多个字符，且最后一个字符与 `s[i-1]` 匹配。
  - `dp[i-1][j-1]`：表示 `*` 匹配了一个或多个字符，但最后一个字符与 `s[i-1]` 不匹配。

边界条件如下：

- 当 `j == 0` 时，无论 `i` 的值是多少，`dp[i][j]` 都应为 `False`，因为模式长度为零，无法匹配任何字符串。
- 当 `i == 0` 且 `j == 0` 时，`dp[i][j]` 应为 `True`，因为空模式和空字符串是匹配的。

#### 示例代码

```python
def isMatch(s: str, p: str) -> bool:
    n, m = len(s), len(p)
    dp = [[False] * (m + 1) for _ in range(n + 1)]

    # 初始化边界条件
    dp[0][0] = True
    for j in range(2, m + 1):
        dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or \
                          (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
            else:
                dp[i][j] = dp[i - 1][j - 1] and \
                           (s[i - 1] == p[j - 1] or p[j - 1] == '.')

    return dp[n][m]
```

#### 难点说明

这道题的难点在于状态转移方程的设计，需要正确处理 `*` 的匹配方式。此外，还需要注意初始化边界条件。

### 2. 二分查找

#### 题目

在排序数组中查找元素的第一个和最后一个位置。

```python
def searchRange(nums: List[int], target: int) -> List[int]:
    pass
```

#### 答案解析

二分查找是解决这道题的基础。我们需要分别找到第一个和最后一个目标值的位置。

首先，定义两个函数 `findFirst` 和 `findLast`：

- `findFirst`：找到目标值的第一个位置。
- `findLast`：找到目标值的最后一个位置。

这两个函数的核心在于调整查找区间的策略，每次调整都要根据目标值与中间元素的大小关系来决定是继续搜索左侧还是右侧。

#### 示例代码

```python
def searchRange(nums, target):
    def findFirst():
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return left if nums[left] == target else -1

    def findLast():
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right + 1) // 2
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid
        return left if nums[left] == target else -1

    first = findFirst()
    last = findLast()
    return [first, last]
```

#### 难点说明

这道题的难点在于如何正确地调整查找区间。特别是当中间值等于目标值时，需要考虑是继续搜索左侧还是右侧。此外，还需要处理边界情况，例如目标值不存在于数组中。

### 3. 链表中的节点值交换

#### 题目

交换链表中两个节点的值。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapNodes(head: ListNode, k: int) -> ListNode:
    pass
```

#### 答案解析

这道题需要找到链表中第 `k` 个节点和第 `k + 1` 个节点，然后交换它们的值。可以使用快慢指针的方法来找到这两个节点。

- 定义两个指针 `fast` 和 `slow`，初始时都指向链表头部。
- 让 `fast` 先前进 `k - 1` 步，这样当 `fast` 到达第 `k` 个节点时，`slow` 恰好位于第 `k - 1` 个节点。
- 此时，`fast` 和 `slow` 分别指向第 `k` 个节点和第 `k + 1` 个节点。

交换这两个节点的值即可。

#### 示例代码

```python
def swapNodes(head: ListNode, k: int) -> ListNode:
    dummy = ListNode(0, head)
    slow = fast = dummy
    for _ in range(k - 1):
        fast = fast.next
    while fast.next:
        slow = slow.next
        fast = fast.next
    slow.val, fast.val = fast.val, slow.val
    return dummy.next
```

#### 难点说明

这道题的难点在于找到第 `k` 个节点和第 `k + 1` 个节点。在循环过程中，需要确保 `fast` 和 `slow` 的移动步数相等。

### 4. 二叉搜索树的迭代遍历

#### 题目

给定一个二叉搜索树，实现其迭代遍历。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorderTraversal(root: TreeNode) -> List[int]:
    pass
```

#### 答案解析

迭代遍历二叉搜索树的一种常用方法是用栈实现中序遍历。

- 定义一个栈 `stack`。
- 初始化 `stack`，将根节点入栈。
- 当 `stack` 非空时，执行以下步骤：
  - 出栈栈顶节点，将其值添加到结果列表。
  - 如果该节点的右子节点不为空，将其右子节点入栈。
  - 如果该节点的左子节点不为空，将其左子节点入栈。

#### 示例代码

```python
def inorderTraversal(root: TreeNode) -> List[int]:
    stack = []
    result = []
    current = root
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right
    return result
```

#### 难点说明

这道题的难点在于正确地处理每个节点的访问顺序。特别是在节点没有左子节点但有右子节点的情况下，需要确保右子节点也被访问到。

### 5. 前序遍历非递归

#### 题目

使用非递归方法实现二叉树的前序遍历。

```python
def preorderTraversal(root: TreeNode) -> List[int]:
    pass
```

#### 答案解析

前序遍历的顺序是：根节点 -> 左子树 -> 右子树。可以使用栈来实现。

- 初始化一个空栈 `stack`。
- 将根节点入栈。
- 当栈非空时，执行以下步骤：
  - 出栈栈顶节点，将其值添加到结果列表。
  - 如果该节点的右子节点不为空，将其右子节点入栈。
  - 如果该节点的左子节点不为空，将其左子节点入栈。

#### 示例代码

```python
def preorderTraversal(root: TreeNode) -> List[int]:
    stack = []
    result = []
    if root:
        stack.append(root)
    while stack:
        node = stack.pop()
        result.append(node.val)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    return result
```

#### 难点说明

这道题的难点在于正确地处理节点的出栈和入栈顺序，确保遍历的顺序是根节点 -> 左子树 -> 右子树。

### 6. 后序遍历非递归

#### 题目

使用非递归方法实现二叉树的后序遍历。

```python
def postorderTraversal(root: TreeNode) -> List[int]:
    pass
```

#### 答案解析

后序遍历的顺序是：左子树 -> 右子树 -> 根节点。可以使用栈和栈顶元素标记的方法来实现。

- 初始化一个空栈 `stack`。
- 初始化一个空列表 `result`。
- 将根节点入栈。
- 当栈非空时，执行以下步骤：
  - 出栈栈顶节点。
  - 将其值添加到结果列表。
  - 如果该节点的左子节点不为空，将其左子节点入栈。
  - 如果该节点的右子节点不为空，将其右子节点入栈。
  - 如果栈顶元素是当前节点的父节点，且栈顶元素的标记为 0，说明已经处理了当前节点的右子节点，可以将栈顶元素的标记设置为 1。

#### 示例代码

```python
def postorderTraversal(root: TreeNode) -> List[int]:
    if root is None:
        return []
    stack = [root]
    result = []
    while stack:
        node = stack.pop()
        result.append(node.val)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
        if stack and stack[-1] == node.parent:
            stack[-1].visited = True
    return result[::-1]
```

#### 难点说明

这道题的难点在于正确地处理节点的访问顺序，确保遍历的顺序是左子树 -> 右子树 -> 根节点。需要特别注意栈顶元素和当前节点的父子关系，以及如何正确地设置和检查节点的标记。

### 7. 中序遍历非递归

#### 题目

使用非递归方法实现二叉树的中序遍历。

```python
def inorderTraversal(root: TreeNode) -> List[int]:
    pass
```

#### 答案解析

中序遍历的顺序是：左子树 -> 根节点 -> 右子树。可以使用栈来实现。

- 初始化一个空栈 `stack`。
- 初始化一个空列表 `result`。
- 将根节点入栈。
- 当栈非空时，执行以下步骤：
  - 出栈栈顶节点，将其值添加到结果列表。
  - 如果该节点的左子节点不为空，将其左子节点入栈。

#### 示例代码

```python
def inorderTraversal(root: TreeNode) -> List[int]:
    stack = []
    result = []
    current = root
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        current = stack.pop()
        result.append(current.val)
        current = current.right
    return result
```

#### 难点说明

这道题的难点在于正确地处理节点的访问顺序，确保遍历的顺序是左子树 -> 根节点 -> 右子树。需要特别注意如何处理当前节点的右子节点。

### 8. 合并两个有序链表

#### 题目

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    pass
```

#### 答案解析

这道题可以使用迭代和递归两种方法。

**迭代方法：**

- 初始化一个哑节点 `dummy` 和一个当前节点 `current`。
- 将 `dummy` 指向链表的头节点。
- 遍历两个链表，比较当前节点的值，将较小的节点连接到当前节点。
- 更新当前节点，并移动较小节点的下一个节点。

**递归方法：**

- 如果一个链表为空，返回另一个链表。
- 如果两个链表的头节点的值相同，将当前节点设置为这个值，并递归地合并下一个节点。
- 如果两个链表的头节点的值不同，选择较小的值作为当前节点的值，并递归地合并下一个节点。

#### 示例代码

迭代方法：

```python
def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

递归方法：

```python
def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

#### 难点说明

这道题的难点在于如何处理两个链表的非空情况，以及如何确保合并后的链表仍然有序。

### 9. 恢复旋转字符串

#### 题目

给定一个旋转后的字符串，编写一个函数来判断它是不是回文。

```python
def isPalindrome(s: str, k: int) -> bool:
    pass
```

#### 答案解析

这道题的关键在于找到字符串的一个旋转点，使得旋转后的字符串是回文。

- 首先，将字符串 `s` 重复两次，这样无论字符串如何旋转，其长度都是偶数。
- 然后，遍历字符串，找到最小的旋转点。旋转点是指从该点开始到字符串末尾的子串与从字符串开头到该点的子串相同。
- 一旦找到旋转点，将字符串分割成两个子串，检查其中一个子串是否是另一个子串的旋转。

#### 示例代码

```python
def isPalindrome(s: str, k: int) -> bool:
    def is_rotate(a, b):
        return a == b or a == b[::-1]

    s = s * 2
    for i in range(k, len(s) - k):
        if is_rotate(s[:k], s[i:i+k]):
            return True
    return False
```

#### 难点说明

这道题的难点在于如何快速找到旋转点，并检查两个子串是否是旋转关系。

### 10. 查找旋转排序数组中的最小值

#### 题目

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

```python
def findMin(nums: List[int]) -> int:
    pass
```

#### 答案解析

这道题可以使用二分查找的方法来寻找最小值。

- 首先确定中间元素 `mid`。
- 如果 `mid` 大于 `nums[left]`，说明最小值在 `mid` 的右侧。
- 如果 `mid` 小于 `nums[left]`，说明最小值在 `mid` 的左侧或就是 `mid` 本身。
- 如果 `mid` 等于 `nums[left]`，则需要分别检查 `mid` 的左侧和右侧。

#### 示例代码

```python
def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        elif nums[mid] < nums[right]:
            right = mid
        else:
            right -= 1
    return nums[left]
```

#### 难点说明

这道题的难点在于如何有效地处理中间元素等于左右两端元素的情况，避免陷入死循环。

### 11. 合并K个排序链表

#### 题目

合并 `k` 个排序链表，返回合并后的排序链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: List[ListNode]) -> ListNode:
    pass
```

#### 答案解析

这道题可以使用优先队列（最小堆）的方法来实现。

- 将第一个链表的头节点加入优先队列。
- 当优先队列为空时，遍历链表，每次取出优先队列的最小节点，将其下一个节点加入优先队列，并将当前节点连接到结果链表中。
- 最终结果链表的最后一个节点的 `next` 指针指向 `None`。

#### 示例代码

```python
import heapq

def mergeKLists(lists: List[ListNode]) -> ListNode:
    dummy = ListNode(0)
    curr = dummy
    q = []
    for node in lists:
        if node:
            heapq.heappush(q, (node.val, node))
    while q:
        _, node = heapq.heappop(q)
        curr.next = node
        curr = curr.next
        if node.next:
            heapq.heappush(q, (node.next.val, node.next))
    return dummy.next
```

#### 难点说明

这道题的难点在于如何有效地合并多个链表，同时保持链表的有序性。

### 12. 图的拓扑排序

#### 题目

给定一个无向图，实现拓扑排序。

```python
from collections import defaultdict, deque

def topologicalSort(vertices: int, edges: List[List[int]]) -> List[int]:
    pass
```

#### 答案解析

拓扑排序可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来实现。

- 使用 DFS 实现：
  - 初始化一个栈 `stack` 和一个列表 `result`。
  - 遍历所有顶点，对于每个未访问的顶点，执行 DFS。
  - 在 DFS 中，将当前顶点入栈，并访问其邻接点。
  - 当访问完所有邻接点后，将当前顶点添加到结果列表中。
  - 返回结果列表的逆序。

- 使用 BFS 实现：
  - 初始化一个队列 `queue` 和一个列表 `result`。
  - 遍历所有顶点，对于每个未访问的顶点，将其入队。
  - 当队列非空时，执行以下步骤：
    - 出队一个顶点，将其添加到结果列表中。
    - 访问该顶点的所有邻接点，对于每个未访问的邻接点，将其入队。

#### 示例代码

DFS 实现：

```python
def topologicalSort(vertices: int, edges: List[List[int]]) -> List[int]:
    def dfs(vertex):
        visited.add(vertex)
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                dfs(neighbor)
        stack.append(vertex)

    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    visited = set()
    stack = []
    for vertex in range(vertices):
        if vertex not in visited:
            dfs(vertex)
    return [stack.pop() for _ in range(len(stack))][::-1]
```

BFS 实现：

```python
def topologicalSort(vertices: int, edges: List[List[int]]) -> List[int]:
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    result = []
    visited = [False] * vertices
    for vertex in range(vertices):
        if not visited[vertex]:
            queue = deque([vertex])
            visited[vertex] = True
            while queue:
                current = queue.popleft()
                result.append(current)
                for neighbor in graph[current]:
                    if not visited[neighbor]:
                        queue.append(neighbor)
                        visited[neighbor] = True
    return result
```

#### 难点说明

拓扑排序的难点在于如何处理有向图中的环，以及如何正确地实现深度优先搜索或广度优先搜索。

### 13. 最长公共前缀

#### 题目

编写一个函数来查找字符串数组中的最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    pass
```

#### 答案解析

这道题可以使用垂直扫描的方法来实现。

- 如果字符串数组为空，返回空字符串。
- 选择第一个字符串作为基准字符串。
- 遍历基准字符串的每个字符，与数组的其他字符串的相同位置字符进行比较。
- 如果所有字符串在相同位置上的字符都相同，继续比较下一个字符；否则，返回当前字符前的子串。

#### 示例代码

```python
def longestCommonPrefix(strs: List[str]) -> str:
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix
```

#### 难点说明

这道题的难点在于如何高效地比较字符串数组中的每个字符串，同时避免越界错误。

### 14. 判断二叉树是否是平衡二叉树

#### 题目

给定一个二叉树，判断它是否是平衡二叉树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isBalanced(root: TreeNode) -> bool:
    pass
```

#### 答案解析

这道题可以使用递归的方法来判断二叉树是否是平衡的。

- 定义一个辅助函数 `checkHeight`，计算节点的平衡因子（即左右子树的高度差）。
- 如果节点的平衡因子大于 1 或小于 -1，说明不是平衡二叉树。
- 否则，继续递归地检查左右子树。

#### 示例代码

```python
def isBalanced(root: TreeNode) -> bool:
    def checkHeight(node):
        if not node:
            return 0
        left_height = checkHeight(node.left)
        if left_height == -1:
            return -1
        right_height = checkHeight(node.right)
        if right_height == -1:
            return -1
        if abs(left_height - right_height) > 1:
            return -1
        return max(left_height, right_height) + 1

    return checkHeight(root) != -1
```

#### 难点说明

这道题的难点在于如何计算每个节点的平衡因子，并检查是否所有节点的平衡因子都在合理范围内。

### 15. 拓扑序列

#### 题目

给定一个包含 `n` 个元素的排列的序列，判断序列是否是合法的拓扑序列。一个合法的拓扑序列需要满足：每个元素位于 `1` 和 `n` 之间，序列中的前 `k` 个元素按字典序排列，且对于任意 `i`，序列中第 `i` 个元素必须位于第 `i+1` 个元素之前。

```python
def sequenceReconstruction(nums: List[int], sequences: List[List[int]]) -> bool:
    pass
```

#### 答案解析

这道题可以使用图和拓扑排序的方法来判断序列是否合法。

- 首先构建一个有向图，其中每个元素作为节点，如果 `nums[i]` 在 `sequences[j]` 中且 `i < j`，则在图中从 `i` 到 `j` 添加一条有向边。
- 然后使用拓扑排序的方法检查图是否为空，并确保每个节点的入度都为 0。
- 如果图不为空且所有节点的入度为 0，说明序列是合法的。

#### 示例代码

```python
from collections import defaultdict, deque

def sequenceReconstruction(nums, sequences):
    n = len(nums)
    graph = defaultdict(list)
    indegrees = [0] * n
    for seq in sequences:
        for i in range(1, len(seq) - 1):
            indegrees[seq[i]] += 1
            graph[seq[i - 1]].append(seq[i])
    queue = deque()
    for i in range(n):
        if indegrees[i] == 0:
            queue.append(i)
    result = []
    while queue:
        if len(queue) > 1:
            return False
        node = queue.popleft()
        result.append(node)
        for neighbor in graph[node]:
            indegrees[neighbor] -= 1
            if indegrees[neighbor] == 0:
                queue.append(neighbor)
    return len(result) == n
```

#### 难点说明

这道题的难点在于如何正确地构建图，并使用拓扑排序的方法检查序列是否合法。需要注意处理节点的入度和图的拓扑排序。

### 16. 最长递增子序列

#### 题目

给定一个无序数组，找出最长递增子序列的长度。

```python
def lengthOfLIS(nums: List[int]) -> int:
    pass
```

#### 答案解析

这道题可以使用动态规划的方法来实现。

- 定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
- 遍历数组，对于每个元素 `nums[i]`，遍历数组的前 `i` 个元素，找到第一个比 `nums[i]` 大的元素 `nums[j]`，则 `dp[i] = dp[j] + 1`。
- 最后，返回 `dp` 中的最大值。

#### 示例代码

```python
def lengthOfLIS(nums: List[int]) -> int:
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

#### 难点说明

这道题的难点在于如何高效地更新动态规划数组 `dp`，并找到最长递增子序列的长度。

### 17. 最长公共子序列

#### 题目

给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列的长度。

```python
def longestCommonSubsequence(text1: str, text2: str) -> int:
    pass
```

#### 答案解析

这道题可以使用动态规划的方法来实现。

- 定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。
- 遍历字符串，对于每个字符，如果当前字符相同，则 `dp[i][j] = dp[i - 1][j - 1] + 1`；否则，`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。
- 最后，返回 `dp` 的最后一个元素。

#### 示例代码

```python
def longestCommonSubsequence(text1: str, text2: str) -> int:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

#### 难点说明

这道题的难点在于如何正确地更新动态规划数组 `dp`，并找到最长公共子序列的长度。

### 18. 最小编辑距离

#### 题目

给定两个字符串 `word1` 和 `word2`，找出将 `word1` 转换为 `word2` 的最小编辑距离。

```python
def minDistance(word1: str, word2: str) -> int:
    pass
```

#### 答案解析

这道题可以使用动态规划的方法来实现。

- 定义一个二维数组 `dp`，其中 `dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符的最小编辑距离。
- 遍历字符串，对于每个字符，如果当前字符相同，则 `dp[i][j] = dp[i - 1][j - 1]`；否则，`dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1`。
- 最后，返回 `dp` 的最后一个元素。

#### 示例代码

```python
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
    return dp[m][n]
```

#### 难点说明

这道题的难点在于如何正确地更新动态规划数组 `dp`，并找到最小编辑距离。

### 19. 前K个高频元素

#### 题目

给定一个整数数组 `nums` 和一个整数 `k`，找出 `nums` 中的前 `k` 个高频元素。

```python
from collections import Counter

def topKFrequent(nums: List[int], k: int) -> List[int]:
    pass
```

#### 答案解析

这道题可以使用哈希表和优先队列的方法来实现。

- 使用哈希表 `Counter` 统计每个元素出现的频率。
- 使用优先队列（小根堆）按照频率从小到大排序，优先队列中的元素是元组 `(频率，元素)`。
- 遍历哈希表，将每个元素的频率和元素作为元组加入优先队列。
- 如果优先队列的大小大于 `k`，则弹出堆顶元素，最后优先队列中的元素就是前 `k` 个高频元素。

#### 示例代码

```python
def topKFrequent(nums: List[int], k: int) -> List[int]:
    count = Counter(nums)
    priority_queue = []
    for num, freq in count.items():
        priority_queue.append((freq, num))
        if len(priority_queue) > k:
            heapq.heappop(priority_queue)
    return [x[1] for x in priority_queue]
```

#### 难点说明

这道题的难点在于如何高效地统计每个元素的频率，并找到前 `k` 个高频元素。

### 20. 有效的括号

#### 题目

给定一个包含大括号 `{}` 的字符串，判断该字符串是否有效。

```python
def isValid(s: str) -> bool:
    pass
```

#### 答案解析

这道题可以使用栈的方法来判断字符串是否有效。

- 初始化一个空栈。
- 遍历字符串，对于每个字符：
  - 如果是左括号，将其入栈。
  - 如果是右括号，检查栈顶元素是否与之匹配，如果不匹配或栈为空，返回 `False`。
- 最后，如果栈为空，返回 `True`；否则，返回 `False`。

#### 示例代码

```python
def isValid(s: str) -> bool:
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in pairs.values():
            stack.append(char)
        elif char in pairs and stack and stack[-1] == pairs[char]:
            stack.pop()
        else:
            return False
    return not stack
```

#### 难点说明

这道题的难点在于如何正确地处理括号匹配，并确保栈中元素的顺序。

### 21. 奇偶排序II

#### 题目

给定一个非负整数数组 `nums`，`2` 的幂次序列也是一个非负整数数组，并且原数组可以按某个旋转总动得到它的一个排列。

```python
def reverseBits(n: int) -> int:
    pass
```

#### 答案解析

这道题可以使用位运算的方法来实现。

- 将 `n` 转换为二进制字符串。
- 将二进制字符串翻转。
- 将翻转后的二进制字符串转换为整数。

#### 示例代码

```python
def reverseBits(n: int) -> int:
    return int(bin(n)[2:][::-1], 2)
```

#### 难点说明

这道题的难点在于如何正确地处理位运算，并确保二进制字符串的翻转和转换。

### 22. 设计哈希集合

#### 题目

不使用任何额外空间，设计哈希集合。

```python
class MyHashSet:

    def __init__(self):
        pass

    def add(self, key: int) -> None:
        pass

    def remove(self, key: int) -> None:
        pass

    def contains(self, key: int) -> bool:
        pass
```

#### 答案解析

这道题可以使用位运算法则来实现。

- 初始化一个大小为 `10007` 的数组 `hashTable`。
- 对于每个 `key`，计算其哈希值 `h = key % 10007`。
- 将 `hashTable[h]` 设置为 `1`，表示 `key` 存在于集合中。
- 如果要移除 `key`，将 `hashTable[h]` 设置为 `0`。
- 检查 `key` 是否存在于集合中，返回 `hashTable[h]` 是否为 `1`。

#### 示例代码

```python
class MyHashSet:

    def __init__(self):
        self.hashTable = [0] * 10007

    def add(self, key: int) -> None:
        self.hashTable[key % 10007] = 1

    def remove(self, key: int) -> None:
        self.hashTable[key % 10007] = 0

    def contains(self, key: int) -> bool:
        return self.hashTable[key % 10007] == 1
```

#### 难点说明

这道题的难点在于如何高效地计算哈希值，并处理哈希冲突。

### 23. 设计LRU缓存

#### 题目

设计一个LRU（最近最少使用）缓存。

```python
class LRUCache:

    def __init__(self, capacity: int):
        pass

    def get(self, key: int) -> int:
        pass

    def put(self, key: int, value: int) -> None:
        pass
```

#### 答案解析

这道题可以使用哈希表和双向链表的方法来实现。

- 初始化一个双向链表 `head` 和 `tail`，分别表示链表的头节点和尾节点。
- 初始化一个哈希表 `cache`，用于存储键值对。
- 对于 `get` 操作，如果键不存在，返回 `-1`；如果存在，将节点移动到链表头部。
- 对于 `put` 操作，如果键存在，更新值并将节点移动到链表头部；如果不存在，添加新的键值对，并检查容量是否超过限制，如果超过，删除链表尾节点。

#### 示例代码

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

#### 难点说明

这道题的难点在于如何高效地实现最近最少使用策略，并处理键值对的添加和移除。

### 24. 设计时间轮

#### 题目

设计一个时间轮，用于处理定时任务。

```python
class TimeWheel:

    def __init__(self, capacity: int, interval: int):
        pass

    def addTask(self, timestamp: int, task: Any) -> bool:
        pass

    def tick(self) -> None:
        pass
```

#### 答案解析

这道题可以使用数组模拟时间轮，结合链表存储任务。

- 初始化一个大小为 `interval` 的数组 `buckets`，每个数组元素是一个链表，用于存储在相同时间间隔的任务。
- 对于 `addTask`，根据任务的时间戳将任务添加到相应的链表中。
- 对于 `tick`，遍历每个链表，执行链表中的所有任务，并从链表中移除这些任务。

#### 示例代码

```python
class TimeWheel:

    def __init__(self, capacity: int, interval: int):
        self.capacity = capacity
        self.interval = interval
        self.buckets = [[] for _ in range(interval)]

    def addTask(self, timestamp: int, task: Any) -> bool:
        index = timestamp % self.interval
        self.buckets[index].append(task)
        return True

    def tick(self) -> None:
        for bucket in self.buckets:
            while bucket:
                task = bucket.pop(0)
                # 执行任务
```

#### 难点说明

这道题的难点在于如何高效地处理定时任务的添加和执行，并确保时间轮的准确性和效率。

### 25. 设计堆

#### 题目

设计一个堆，支持插入、删除和获取最大元素。

```python
class MaxHeap:

    def __init__(self):
        pass

    def insert(self, val: int) -> None:
        pass

    def extractMax(self) -> int:
        pass

    def getMax(self) -> int:
        pass
```

#### 答案解析

这道题可以使用数组模拟堆。

- 初始化一个数组 `heap`，堆中的元素从 `1` 开始索引。
- 对于 `insert`，将新元素添加到数组末尾，然后进行上滤操作。
- 对于 `extractMax`，删除堆顶元素，然后将堆的最后一个元素移动到堆顶，并进行下滤操作。
- 对于 `getMax`，直接返回堆顶元素。

#### 示例代码

```python
class MaxHeap:

    def __init__(self):
        self.heap = []

    def insert(self, val: int) -> None:
        self.heap.append(val)
        self._siftUp(len(self.heap) - 1)

    def extractMax(self) -> int:
        if not self.heap:
            return -1
        result = self.heap[1]
        self.heap[1] = self.heap.pop()
        self._siftDown(1)
        return result

    def getMax(self) -> int:
        return self.heap[1] if self.heap else -1

    def _siftUp(self, index):
        while index > 1 and self.heap[index] > self.heap[index // 2]:
            self.heap[index], self.heap[index // 2] = self.heap[index // 2], self.heap[index]
            index //= 2

    def _siftDown(self, index):
        while 2 * index <= len(self.heap):
            maxIndex = index
            if 2 * index + 1 <= len(self.heap) and self.heap[2 * index + 1] > self.heap[maxIndex]:
                maxIndex = 2 * index + 1
            if self.heap[index] < self.heap[maxIndex]:
                self.heap[index], self.heap[maxIndex] = self.heap[maxIndex], self.heap[index]
                index = maxIndex
            else:
                break
```

#### 难点说明

这道题的难点在于如何高效地实现堆的上滤和下滤操作，确保堆的性质。

### 26. 设计优先队列

#### 题目

设计一个优先队列，支持插入、删除和获取最小元素。

```python
class PriorityQueue:

    def __init__(self):
        pass

    def insert(self, priority: int, item: Any) -> None:
        pass

    def delete(self, item: Any) -> None:
        pass

    def getMin(self) -> int:
        pass
```

#### 答案解析

这道题可以使用二叉堆（小根堆）来实现。

- 初始化一个最小堆。
- 对于 `insert`，将元素插入堆中。
- 对于 `delete`，找到元素，将其从堆中移除。
- 对于 `getMin`，直接返回堆顶元素。

#### 示例代码

```python
import heapq

class PriorityQueue:

    def __init__(self):
        self.heap = []

    def insert(self, priority: int, item: Any) -> None:
        heapq.heappush(self.heap, (priority, item))

    def delete(self, item: Any) -> None:
        self.heap.remove((min(self.heap, key=lambda x: x[0])[0]))
        heapq.heapify(self.heap)

    def getMin(self) -> int:
        if not self.heap:
            return -1
        return self.heap[0][1]
```

#### 难点说明

这道题的难点在于如何高效地实现元素的插入、删除和获取最小元素操作。

### 27. 设计优先级队列

#### 题目

设计一个优先级队列，支持插入、删除和获取最大元素。

```python
class PriorityQueue:

    def __init__(self):
        pass

    def insert(self, priority: int, item: Any) -> None:
        pass

    def delete(self, item: Any) -> None:
        pass

    def getMax(self) -> int:
        pass
```

#### 答案解析

这道题可以使用最大堆来实现。

- 初始化一个最大堆。
- 对于 `insert`，将元素插入堆中。
- 对于 `delete`，找到元素，将其从堆中移除。
- 对于 `getMax`，直接返回堆顶元素。

#### 示例代码

```python
import heapq

class PriorityQueue:

    def __init__(self):
        self.heap = []

    def insert(self, priority: int, item: Any) -> None:
        heapq.heappush(self.heap, (-priority, item))

    def delete(self, item: Any) -> None:
        self.heap.remove((-min(self.heap, key=lambda x: x[0])[0][0], item))
        heapq.heapify(self.heap)

    def getMax(self) -> int:
        if not self.heap:
            return -1
        return -self.heap[0][0]
```

#### 难点说明

这道题的难点在于如何高效地实现元素的插入、删除和获取最大元素操作。

### 28. 设计前缀树

#### 题目

设计一个前缀树，支持插入、搜索和搜索前缀。

```python
class Trie:

    def __init__(self):
        pass

    def insert(self, word: str) -> None:
        pass

    def search(self, word: str) -> bool:
        pass

    def startsWith(self, prefix: str) -> bool:
        pass
```

#### 答案解析

这道题可以使用树结构来实现。

- 初始化一个根节点。
- 对于 `insert`，从根节点开始，遍历字符串，对于每个字符，如果节点不存在，创建新的节点，然后移动到下一个节点。
- 对于 `search`，从根节点开始，遍历字符串，如果节点存在，移动到下一个节点；否则，返回 `False`。
- 对于 `startsWith`，从根节点开始，遍历前缀字符串，如果节点存在，移动到下一个节点；否则，返回 `False`。

#### 示例代码

```python
class Trie:

    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node:
                node[char] = {}
            node = node[char]
        node['#'] = '#'

    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            if char not in node:
                return False
            node = node[char]
        return '#' in node

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node:
                return False
            node = node[char]
        return True
```

#### 难点说明

这道题的难点在于如何高效地实现前缀树的插入、搜索和搜索前缀操作。

### 29. 设计堆队列

#### 题目

设计一个堆队列，支持插入、删除和获取最大元素。

```python
class MaxHeapQueue:

    def __init__(self):
        pass

    def insert(self, val: int) -> None:
        pass

    def delete(self) -> int:
        pass

    def getMax(self) -> int:
        pass
```

#### 答案解析

这道题可以使用两个堆来实现。

- 一个最大堆，用于存储元素。
- 一个最小堆，用于存储最大堆的堆顶元素。
- 对于 `insert`，将新元素插入最大堆。
- 对于 `delete`，从最大堆中删除堆顶元素，并将其插入最小堆。
- 对于 `getMax`，返回最小堆的堆顶元素。

#### 示例代码

```python
import heapq

class MaxHeapQueue:

    def __init__(self):
        self.maxHeap = []
        self.minHeap = []

    def insert(self, val: int) -> None:
        heapq.heappush(self.maxHeap, -val)
        heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))

    def delete(self) -> int:
        heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))
        return -heapq.heappop(self.maxHeap)

    def getMax(self) -> int:
        return -self.minHeap[0]
```

#### 难点说明

这道题的难点在于如何高效地实现元素的插入、删除和获取最大元素操作。

### 30. 设计栈队列

#### 题目

设计一个栈队列，支持插入、删除和获取最大元素。

```python
class MaxStackQueue:

    def __init__(self):
        pass

    def insert(self, val: int) -> None:
        pass

    def delete(self) -> int:
        pass

    def getMax(self) -> int:
        pass
```

#### 答案解析

这道题可以使用两个栈来实现。

- 一个栈，用于存储元素。
- 一个辅助栈，用于存储最大元素。
- 对于 `insert`，将新元素插入主栈，并将新元素与辅助栈的栈顶元素比较，如果大于栈顶元素，则将新元素入辅助栈。
- 对于 `delete`，从主栈中弹出栈顶元素，如果该元素等于辅助栈的栈顶元素，则从辅助栈中弹出该元素。
- 对于 `getMax`，返回辅助栈的栈顶元素。

#### 示例代码

```python
class MaxStackQueue:

    def __init__(self):
        self.mainStack = []
        self辅助Stack = []

    def insert(self, val: int) -> None:
        self.mainStack.append(val)
        if not self.辅助Stack or val > self.辅助Stack[-1]:
            self.辅助Stack.append(val)

    def delete(self) -> int:
        if self.mainStack[-1] == self.辅助Stack[-1]:
            self.辅助Stack.pop()
        return self.mainStack.pop()

    def getMax(self) -> int:
        return self.辅助Stack[-1]
```

#### 难点说明

这道题的难点在于如何高效地实现元素的插入、删除和获取最大元素操作。需要注意维护辅助栈的栈顶元素与主栈的栈顶元素的一致性。

