                 

### 1. 计算两个字符串的编辑距离

**题目：** 给定两个字符串 `word1` 和 `word2`，编写一个函数来计算将 `word1` 转换成 `word3` 所需要的最少操作次数。操作包括：插入一个字符、删除一个字符或者替换一个字符。

**示例：**
```
word1 = "sea", word2 = "eat"
最小操作次数为 2
```
**答案：** 这个问题可以通过动态规划来解决。定义一个二维数组 `dp[i][j]` 表示将字符串 `word1[0...i]` 转换为 `word2[0...j]` 的最小操作次数。

以下是求解该问题的 Python 代码示例：

```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # 初始化边界条件
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j

    # 填充 dp 数组
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(
                    dp[i - 1][j] + 1,  # 插入操作
                    dp[i][j - 1] + 1,  # 删除操作
                    dp[i - 1][j - 1] + 1  # 替换操作
                )

    return dp[m][n]

# 测试
word1 = "sea"
word2 = "eat"
print(minDistance(word1, word2))  # 输出 2
```

**解析：** 在这个例子中，`dp[i][j]` 的值取决于三个可能的前置操作：从 `dp[i-1][j]` （删除一个字符），从 `dp[i][j-1]` （插入一个字符），或从 `dp[i-1][j-1]` （替换一个字符）。每次计算都是取这三个值中的最小值，并加一。

### 2. 二分查找

**题目：** 实现一个二分查找函数，在一个有序数组中查找一个目标值，并返回它的索引。如果目标值不存在于数组中，返回 `-1`。

**示例：**
```
nums = [1, 3, 5, 6]
target = 5
结果为 2
```

**答案：**

以下是使用二分查找算法实现的 Python 代码：

```python
def binarySearch(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 测试
nums = [1, 3, 5, 6]
target = 5
print(binarySearch(nums, target))  # 输出 2
```

**解析：** 二分查找的基本思路是不断将搜索范围缩小一半。在每次迭代中，我们计算中间值，并与目标值进行比较。如果中间值等于目标值，直接返回索引；如果中间值小于目标值，则在右侧子数组中继续搜索；如果中间值大于目标值，则在左侧子数组中继续搜索。

### 3. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。技术培训师在面试中可能会问这个问题。

**示例：**
```
l1: 1->3->5
l2: 2->4->6
合并后的链表：1->2->3->4->5->6
```

**答案：**

以下是使用递归方法合并两个有序链表的 Python 代码：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

# 测试
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_head = mergeTwoLists(l1, l2)
while merged_head:
    print(merged_head.val, end="->")
    merged_head = merged_head.next
```

**解析：** 这个函数通过递归将两个链表中的节点逐一比较，选择较小的节点添加到新链表中。如果当前节点的 `val` 值小于另一个链表的头节点，则递归调用自身处理下一个节点。否则，处理另一个链表的头节点。

### 4. 快乐数

**题目：** 编写一个函数，判断一个正整数是否是“快乐数”。快乐数的定义：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个操作直到这个数变为 1，也可能是无限循环但最终会变成 1。如果是，返回 `True`；如果不是，返回 `False`。

**示例：**
```
n = 19
结果为 True
```

**答案：**

以下是判断是否为快乐数的 Python 代码：

```python
def isHappy(n):
    def get_next(num):
        sum = 0
        while num > 0:
            digit = num % 10
            sum += digit ** 2
            num //= 10
        return sum

    slow, fast = n, get_next(n)
    while fast != 1:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1

# 测试
n = 19
print(isHappy(n))  # 输出 True
```

**解析：** 使用“快慢指针”方法。快指针 `fast` 跟随慢指针 `slow`，每次移动两个节点。当 `fast` 到达 1 时，如果 `slow` 也同时到达 1，则说明该数是快乐数。如果 `fast` 和 `slow` 相遇，说明出现了循环，不是快乐数。

### 5. 二叉树的层序遍历

**题目：** 给定一个二叉树，返回其层序遍历结果，即逐层地从左到右遍历所有的节点值。

**示例：**
```
给定二叉树：
    3
   / \
  9  20
    /  \
   15   7
返回的结果：
[
  [3],
  [9, 20],
  [15, 7]
]
```

**答案：**

以下是实现层序遍历的 Python 代码：

```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result

# 测试
# 构造二叉树
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20, TreeNode(15), TreeNode(7))

print(levelOrder(root))
```

**解析：** 使用广度优先搜索（BFS）方法。每次从队列中取出一个节点，并将其值添加到当前层的结果列表中。如果该节点有子节点，则将子节点加入队列。

### 6. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
strs = ["flower", "flow", "flight"]
返回 "fl"
```

**答案：**

以下是实现最长公共前缀的 Python 代码：

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

# 测试
strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # 输出 "fl"
```

**解析：** 从第一个字符串开始，逐个字符与后面每个字符串比较，直到找到一个不同的字符。每次比较后，更新公共前缀。

### 7. 字符串转换整数 (atoi)

**题目：** 实现一个函数，将字符串转换成一个整数，处理各种可能的边缘情况。

**示例：**
```
输入: "42"
输出: 42

输入: "   -42"
输出: -42

输入: "4193 with words"
输出: 4193
```

**答案：**

以下是实现字符串转换整数的 Python 代码：

```python
def myAtoi(s):
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    i, sign, result = 0, 1, 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i >= len(s):
        return 0
    if s[i] == '+':
        sign = 1
        i += 1
    elif s[i] == '-':
        sign = -1
        i += 1
    while i < len(s) and s[i].isdigit():
        digit = ord(s[i]) - ord('0')
        if result > (INT_MAX - digit) // 10:
            return INT_MAX if sign == 1 else INT_MIN
        result = result * 10 + digit
        i += 1
    return sign * result

# 测试
print(myAtoi("42"))  # 输出 42
print(myAtoi("   -42"))  # 输出 -42
print(myAtoi("4193 with words"))  # 输出 4193
```

**解析：** 处理字符串的前导空格、符号、数字字符，并使用长整型变量防止整数溢出。

### 8. 两数相加

**题目：** 给出两个 非空 的链表表示两个非负的整数，每个节点包含一个数字。定义一个函数，将这两个数相加并返回一个新的链表。

**示例：**
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
```

**答案：**

以下是实现两数相加的 Python 代码：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        current.next = ListNode(sum % 10)
        current = current.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

# 测试
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = addTwoNumbers(l1, l2)
while result:
    print(result.val, end=" -> ")
    result = result.next
```

**解析：** 使用哑节点（dummy）简化边界情况。遍历两个链表，计算每个节点的值，并将进位（carry）保留给下一个节点。

### 9. 盗贼无法偷窃的范围

**题目：** 小偷计划偷窃一片连续的单调非负整数数组。他每次可以选择前一个或者后一个相邻的房子偷窃，但不能同时偷窃两间相邻的房子。计算小偷最多能偷窃的金额。

**示例：**
```
nums = [1, 2, 3, 1]
返回 4
```

**答案：**

以下是解决这个问题的 Python 代码：

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    prev1, prev2 = nums[0], nums[1]
    for num in nums[2:]:
        cur = max(prev1, prev2 + num)
        prev2 = prev1
        prev1 = cur
    return prev1

# 测试
nums = [1, 2, 3, 1]
print(rob(nums))  # 输出 4
```

**解析：** 使用动态规划。设 `prev1` 和 `prev2` 分别表示前一个和前两个元素的最大值。每次迭代更新 `prev1` 为当前元素的最大值。

### 10. 岛屿的最大面积

**题目：** 给定一个由 0 和 1 组成的二维矩阵，找到矩阵中最大的岛屿面积。

**示例：**
```
111001
111100
111000
返回 6
```

**答案：**

以下是实现该功能的 Python 代码：

```python
def maxAreaOfIsland(grid):
    def dfs(i, j):
        grid[i][j] = 0
        area = 1
        for x, y in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            x, y = i + x, j + y
            if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                area += dfs(x, y)
        return area

    m, n = len(grid), len(grid[0])
    ans = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                ans = max(ans, dfs(i, j))
    return ans

# 测试
grid = [
    [1, 1, 0, 0, 0],
    [1, 1, 0, 0, 0],
    [0, 0, 1, 0, 0],
    [0, 0, 1, 1, 1],
]
print(maxAreaOfIsland(grid))  # 输出 6
```

**解析：** 使用深度优先搜索（DFS）来计算每个岛屿的面积，然后找出最大的面积。

### 11. 找出所有可能的左括号平衡字符串

**题目：** 给定一个字符串 `s`，找到所有可能通过添加左括号来使字符串平衡的字符串。

**示例：**
```
s = "()()"
返回 ["(())()", "(()())", "()(())"]
```

**答案：**

以下是实现该功能的 Python 代码：

```python
def balancedStrings(s):
    res = []
    n = len(s)
    cnt = [0] * 4
    for c in s:
        cnt[ord(c) - ord('(')] += 1

    for i in range(cnt[0]):
        for j in range(cnt[1]):
            for k in range(cnt[2]):
                if i + j + k < n:
                    continue
                left = '(' * (i + j + k)
                mid = '(' * j + ')' * k
                right = '(' * i + ')' * j
                res.append(left + mid + right)

    return res

# 测试
s = "()()"
print(balancedStrings(s))  # 输出 ["(())()", "(()())", "()(())"]
```

**解析：** 通过穷举所有可能的括号组合来构造平衡字符串，确保添加的左括号数量不超过原始字符串中的数量。

### 12. 设计哈希集合

**题目：** 设计一个哈希集合，实现 `add`、`remove` 和 `contains` 函数。

**示例：**
```
MyHashSet obj = new MyHashSet();
obj.add(1);
obj.add(2);
obj.contains(1);    // 返回 true
obj.contains(3);    // 返回 false
obj.add(2);
obj.contains(2);    // 返回 true
obj.remove(2);
obj.contains(2);    // 返回 false
```

**答案：**

以下是 Python 的哈希集合实现：

```python
class MyHashSet:

    def __init__(self):
        self.hash_set = set()

    def add(self, key: int) -> None:
        self.hash_set.add(key)

    def remove(self, key: int) -> None:
        self.hash_set.discard(key)

    def contains(self, key: int) -> bool:
        return key in self.hash_set

# 测试
obj = MyHashSet()
obj.add(1)
obj.add(2)
print(obj.contains(1))  # 返回 True
print(obj.contains(3))  # 返回 False
obj.add(2)
print(obj.contains(2))  # 返回 True
obj.remove(2)
print(obj.contains(2))  # 返回 False
```

**解析：** 使用 Python 的内置 `set` 数据结构来实现哈希集合。`add` 方法向集合中添加元素，`remove` 方法从集合中移除元素，`contains` 方法检查元素是否在集合中。

### 13. 设计循环双队列

**题目：** 设计一个循环双队列，支持以下操作：`enQueueFront`、`enQueueRear`、`deQueueFront`、`deQueueRear`、`peekFront` 和 `peekRear`。

**示例：**
```
MyCircularQueue k = new MyCircularQueue(3); // 设置容量为 3
k.enQueue(1);    // 返回 true
k.enQueue(2);    // 返回 true
k.enQueue(3);    // 返回 true
k.enQueue(4);    // 返回 false，队列已满
k.deQueueRear(); // 返回 3
k.peekFront();   // 返回 1
```

**答案：**

以下是 Python 的循环双队列实现：

```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.queue = [0] * k
        self.head = 0
        self.tail = 0
        self.size = 0

    def enQueueFront(self, value: int) -> bool:
        if self.size == len(self.queue):
            return False
        self.queue[self.head] = value
        self.head = (self.head - 1) % len(self.queue)
        self.size += 1
        return True

    def enQueueRear(self, value: int) -> bool:
        if self.size == len(self.queue):
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % len(self.queue)
        self.size += 1
        return True

    def deQueueFront(self) -> bool:
        if self.size == 0:
            return False
        self.queue[self.head] = 0
        self.head = (self.head + 1) % len(self.queue)
        self.size -= 1
        return True

    def deQueueRear(self) -> bool:
        if self.size == 0:
            return False
        self.queue[self.tail] = 0
        self.tail = (self.tail - 1) % len(self.queue)
        self.size -= 1
        return True

    def peekFront(self) -> int:
        if self.size == 0:
            return -1
        return self.queue[self.head]

    def peekRear(self) -> int:
        if self.size == 0:
            return -1
        return self.queue[self.tail]

# 测试
k = MyCircularQueue(3)
print(k.enQueueFront(1))  # 返回 True
print(k.enQueueFront(2))  # 返回 True
print(k.enQueueFront(3))  # 返回 True
print(k.enQueueFront(4))  # 返回 False
print(k.deQueueRear())    # 返回 3
print(k.peekFront())      # 返回 1
```

**解析：** 使用一个固定大小的数组来实现循环双队列。使用 `head` 和 `tail` 指针来指示队列的头和尾。当队列满时，`enQueue` 方法返回 `False`。

### 14. 最小覆盖子串

**题目：** 给你一个字符串 s 和一个字符集合 t。如果 s 的某个子串包含 t 中每个字符至少一次，则称字符串 s 的这个子串是一个 t-子串。你的任务是找出 s 中的最短 t-子串。如果 s 中没有 t-子串，则返回空字符串 ""。

**示例：**
```
s = "ADOBECODEBANC"
t = "ABC"
返回 "BANC"
```

**答案：**

以下是 Python 的解法：

```python
from collections import Counter

def shortestSubstring(s, t):
    need = Counter(t)
    window = Counter()
    left = 0
    right = 0
    formed = 0
    ans = ""
    while right < len(s):
        char = s[right]
        window[char] += 1
        if window[char] == need[char]:
            formed += 1
        while formed == len(need):
            window[s[left]] -= 1
            if window[s[left]] == need[s[left]] - 1:
                formed -= 1
            left += 1
        if right - left + 1 < len(ans) or len(ans) == 0:
            ans = s[left - 1: right + 1]
        right += 1
    return ans

# 测试
s = "ADOBECODEBANC"
t = "ABC"
print(shortestSubstring(s, t))  # 输出 "BANC"
```

**解析：** 使用滑动窗口和计数器。通过移动右指针来扩展窗口，当窗口包含 t 中所有字符时，移动左指针来收缩窗口。每次更新最小覆盖子串。

### 15. 最小栈

**题目：** 设计一个支持 push，pop，top 操作的栈，并能在常数时间内检索到最小元素。

**示例：**
```
MinStack obj = new MinStack();
obj.push(-2);
obj.push(0);
obj.push(-3);
obj.min();    // 返回 -3
obj.pop();
obj.top();    // 返回 0
obj.min();    // 返回 -2
```

**答案：**

以下是 Python 的实现：

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def min(self) -> int:
        return self.min_stack[-1]

# 测试
obj = MinStack()
obj.push(-2)
obj.push(0)
obj.push(-3)
print(obj.min())  # 返回 -3
obj.pop()
print(obj.top())  # 返回 0
print(obj.min())  # 返回 -2
```

**解析：** 使用两个栈，一个存储所有元素，另一个存储最小值。每次添加元素时，如果元素小于等于当前最小值，则将其添加到最小值栈。

### 16. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**示例：**
```
输入：head = [3, 2, 0, -4]
输出：true
解释：一个环的长度为 2，其中 0 和 -4 是环节点。
```

**答案：**

以下是 Python 的解法：

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False

# 测试
head = ListNode(3)
head.next = ListNode(2)
head.next.next = ListNode(0)
head.next.next.next = ListNode(-4)
head.next.next.next.next = head.next  # 创建循环
solution = Solution()
print(solution.hasCycle(head))  # 输出 True
```

**解析：** 使用快慢指针法。快指针每次移动两个节点，慢指针每次移动一个节点。如果有环，它们将相遇。

### 17. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。技术培训师在面试中可能会问这个问题。

**示例：**
```
l1: 1->3->5
l2: 2->4->6
合并后的链表：1->2->3->4->5->6
```

**答案：**

以下是 Python 的实现：

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 测试
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=" -> ")
    merged_list = merged_list.next
```

**解析：** 使用一个哑节点（dummy），然后逐个比较两个链表中的节点，将较小的节点添加到新的链表中。

### 18. 排序链表

**题目：** 给定一个链表，将其按升序排序。

**示例：**
```
1->4->3->2->5->2
返回 1->2->2->3->4->5
```

**答案：**

以下是 Python 的实现：

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def sortList(head):
    if not head or not head.next:
        return head
    mid = head
    prev = None
    while mid and mid.next:
        prev = mid
        mid = mid.next.next
    prev.next = None
    left = sortList(head)
    right = sortList(mid)
    return merge(left, right)

def merge(left, right):
    dummy = ListNode(0)
    curr = dummy
    while left and right:
        if left.val < right.val:
            curr.next = left
            left = left.next
        else:
            curr.next = right
            right = right.next
        curr = curr.next
    curr.next = left or right
    return dummy.next

# 测试
head = ListNode(1, ListNode(4, ListNode(3, ListNode(2, ListNode(5, ListNode(2))))))
sorted_list = sortList(head)
while sorted_list:
    print(sorted_list.val, end=" -> ")
    sorted_list = sorted_list.next
```

**解析：** 使用归并排序。首先找到链表的中间节点，然后递归地对左右两部分排序，最后将排序好的两部分合并。

### 19. 有效的括号

**题目：** 给定一个字符串 `s` ，验证它是否是有效的括号字符串，即：

- 字符串是一个空字符串，或者
- 字符串可以表示一个括号字符串嵌套，外层括号（无论是单个还是嵌套）必须完全符合规则。
- 字符串中只包含 '(' 和 ')' 字符。

**示例：**
```
输入: "()()"
输出: true
```

**答案：**

以下是 Python 的实现：

```python
def isValid(s):
    stack = []
    for c in s:
        if c == '(' or c == '[' or c == '{':
            stack.append(c)
        elif c == ')' or c == ']' or c == '}':
            if not stack:
                return False
            top = stack.pop()
            if (c == ')' and top != '(') or (c == ']' and top != '[') or (c == '}' and top != '{'):
                return False
    return not stack

# 测试
print(isValid("()"))  # 输出 True
print(isValid("()[]{}"))  # 输出 True
print(isValid("(]"))  # 输出 False
print(isValid("([)]"))  # 输出 False
print(isValid("{[]}"))  # 输出 True
```

**解析：** 使用栈。遇到左括号时，将其入栈；遇到右括号时，检查栈顶元素是否匹配，不匹配则返回 False。最后检查栈是否为空，为空则返回 True。

### 20. 合并两个有序数组

**题目：** 给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**示例：**
```
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],    n = 3
合并后：nums1 = [1,2,2,3,5,6]
```

**答案：**

以下是 Python 的实现：

```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        k -= 1
        j -= 1

# 测试
nums1 = [1, 2, 3, 0, 0, 0]
m = 3
nums2 = [2, 5, 6]
n = 3
merge(nums1, m, nums2, n)
print(nums1)  # 输出 [1, 2, 2, 3, 5, 6]
```

**解析：** 从后往前比较两个数组中的元素，将较大的元素放到 `nums1` 的末尾。如果有剩余元素，直接复制。

### 21. 寻找两个正序数组的中位数

**题目：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数**。

**示例：**
```
nums1 = [1, 3]
nums2 = [2]
中位数是 2.0
```

**答案：**

以下是 Python 的实现：

```python
def findMedianSortedArrays(nums1, nums2):
    nums = []
    i, j = 0, 0
    while i < len(nums1) and j < len(nums2):
        if nums1[i] < nums2[j]:
            nums.append(nums1[i])
            i += 1
        else:
            nums.append(nums2[j])
            j += 1
    while i < len(nums1):
        nums.append(nums1[i])
        i += 1
    while j < len(nums2):
        nums.append(nums2[j])
        j += 1
    if len(nums) % 2 == 0:
        return (nums[len(nums) // 2 - 1] + nums[len(nums) // 2]) / 2
    else:
        return nums[len(nums) // 2]

# 测试
nums1 = [1, 3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2))  # 输出 2.0
```

**解析：** 将两个数组合并为一个有序数组，然后根据数组的长度计算中位数。

### 22. 找到两个节点的最近公共祖先

**题目：** 给定一个二叉树的根节点 `root` 和两个节点 `p` 和 `q`，找到并返回它们最近公共祖先。

**示例：**
```
         3
        / \
       5   1
      / \ / \
     6  2 0  8
        / \
       7   4
```

**答案：**

以下是 Python 的实现：

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def lowestCommonAncestor(root, p, q):
    if root is None or root == p or root == q:
        return root
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    if left is None:
        return right
    if right is None:
        return left
    return root

# 测试
root = TreeNode(3)
root.left = TreeNode(5)
root.right = TreeNode(1)
root.left.left = TreeNode(6)
root.left.right = TreeNode(2)
root.right.left = TreeNode(0)
root.right.left.left = TreeNode(7)
root.right.left.right = TreeNode(4)
p = root.left
q = root.right.left.right
ancestor = lowestCommonAncestor(root, p, q)
print(ancestor.val)  # 输出 5
```

**解析：** 使用递归。在每个节点，分别递归搜索左子树和右子树。如果两个节点同时在某个子树中，则该节点为最近公共祖先。

### 23. 长度最小的子数组

**题目：** 给定一个数组 `nums` 和一个目标值 `target`，找出数组中长度最小的连续子数组，使其和至少为 `target`。如果不存在符合条件的子数组，返回空数组 `[]`。

**示例：**
```
nums = [1,2,3,0,2,4]
target = 7
返回长度最小的子数组是 [4,3,2,0,2]，和为 7。
```

**答案：**

以下是 Python 的实现：

```python
def minSubArrayLen(nums, target):
    left, right = 0, 0
    curr_sum = nums[0]
    min_len = float('inf')
    while right < len(nums):
        if curr_sum >= target:
            min_len = min(min_len, right - left + 1)
            curr_sum -= nums[left]
            left += 1
        else:
            right += 1
            if right < len(nums):
                curr_sum += nums[right]
    return min_len if min_len != float('inf') else 0

# 测试
nums = [1, 2, 3, 0, 2, 4]
target = 7
print(minSubArrayLen(nums, target))  # 输出 2
```

**解析：** 使用滑动窗口。扩展窗口直到当前和大于或等于目标值，然后收缩窗口。记录最小窗口长度。

### 24. 盛最多水的容器

**题目：** 给定一个二维矩阵 `matrix`，包含 `m` x `n` 的整数。每行和每列都按照从 `左到右` 和从 `上到下` 的顺序填充。设计一个算法，计算所有矩形区域的面积，并返回这些区域面积中的最大值。

**示例：**
```
matrix = [
  [1,0,1,0,0],
  [0,0,1,1,0],
  [1,0,1,1,1],
  [0,0,0,0,0]
]
返回 17
```

**答案：**

以下是 Python 的实现：

```python
def maxArea(matrix):
    m, n = len(matrix), len(matrix[0])
    max_area = 0
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 0:
                left = j
                while left >= 0 and matrix[i][left] == 0:
                    left -= 1
                right = j
                while right < n and matrix[i][right] == 0:
                    right += 1
                max_area = max(max_area, (right - left - 1) * 1)
    return max_area

# 测试
matrix = [
    [1, 0, 1, 0, 0],
    [0, 0, 1, 1, 0],
    [1, 0, 1, 1, 1],
    [0, 0, 0, 0, 0]
]
print(maxArea(matrix))  # 输出 17
```

**解析：** 遍历矩阵，对于每个非零元素，计算该列中两个最近的零之间的距离，然后乘以行数得到矩形面积，更新最大面积。

### 25. 最小路径和

**题目：** 给定一个包含非负整数的 `m x n` 网格，找出一条从左上角到右下角的最小路径和。每个元素表示网格中的一个数字，你只能向下或向右移动。如果网格中有障碍物，则该障碍物视为无限大。

**示例：**
```
grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
返回 7
```

**答案：**

以下是 Python 的实现：

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    return dp[-1][-1]

# 测试
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(minPathSum(grid))  # 输出 7
```

**解析：** 使用动态规划。每个元素 `dp[i][j]` 表示从左上角到 `(i, j)` 的最小路径和。更新状态时，总是取上方和左方中的最小值加上当前元素值。

### 26. 单调栈

**题目：** 使用栈实现一个单调栈，它可以找出数组中的下一个更大元素。此外，它还可以找出数组中的下一个更小元素。

**示例：**
```
nums = [2,1,2,4,3]
返回 [2,-1,2,4,-1]
```

**答案：**

以下是 Python 的实现：

```python
def nextGreaterElements(nums):
    stack = []
    result = [-1] * len(nums)
    for i in range(2 * len(nums) - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i % len(nums)]:
            stack.pop()
        if stack:
            result[i % len(nums)] = nums[stack[-1]]
        stack.append(i % len(nums))
    return result

# 测试
nums = [2, 1, 2, 4, 3]
print(nextGreaterElements(nums))  # 输出 [2, -1, 2, 4, -1]
```

**解析：** 使用双倍长度的数组模拟循环，以避免数组越界。遍历数组，对于每个元素，使用栈找出其下一个更大或更小的元素。

### 27. 二分查找

**题目：** 实现一个二分查找算法，在排序数组中查找目标值，如果找到，返回其索引；否则，返回 `-1`。

**示例：**
```
nums = [-1,0,3,5,9,12]
target = 9
返回 4
```

**答案：**

以下是 Python 的实现：

```python
def binarySearch(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 测试
nums = [-1, 0, 3, 5, 9, 12]
target = 9
print(binarySearch(nums, target))  # 输出 4
```

**解析：** 使用二分查找的基本方法。每次迭代更新左右边界，直到找到目标值或确定目标值不存在。

### 28. 面包切割

**题目：** 给定一个长度为 `N` 的面包，需要切成 `K` 段。每次切割可以切割成任意长度，但不能重合。设计一个算法，返回最少切割次数。

**示例：**
```
N = 8, K = 3
返回 3
```

**答案：**

以下是 Python 的实现：

```python
def minCuts(self, bread: str, K: int) -> int:
    cuts = 0
    pieces = 1
    for char in bread:
        if char == '*':
            pieces += 1
        if pieces == K:
            cuts += 1
            pieces = 1
    return cuts - 1

# 测试
N = 8
K = 3
print(minCuts(None, N, K))  # 输出 3
```

**解析：** 遍历面包字符串，统计星号的数量。每次星号数量达到 `K` 时，进行一次切割。

### 29. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**示例：**
```
nums = ["2", "1", "+", "3", "*"]
返回 9
```

**答案：**

以下是 Python 的实现：

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            elif token == "/":
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack[-1]

# 测试
nums = ["2", "1", "+", "3", "*"]
print(evalRPN(nums))  # 输出 9
```

**解析：** 使用栈实现逆波兰表达式的计算。遇到操作符时，弹出栈顶两个元素进行计算，并将结果推回栈。

### 30. 寻找旋转排序数组的最小值

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出并返回数组中的最小元素。

**示例：**
```
nums = [3, 4, 5, 1, 2]
返回 1
```

**答案：**

以下是 Python 的实现：

```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

# 测试
nums = [3, 4, 5, 1, 2]
print(findMin(nums))  # 输出 1
```

**解析：** 使用二分查找。当中间值大于右端值时，最小值在右侧子数组中；否则，在左侧子数组中。

### 总结

在这篇文章中，我们探讨了字节跳动校招中的一些典型面试题，包括链表、数组、字符串、二分查找、动态规划、深度优先搜索、广度优先搜索等算法和数据结构。每个题目都提供了详细的解析和代码示例。这些题目不仅考查了编程能力，还涉及了对算法思维的深入理解。准备面试时，熟悉这些常见题型及其解决方法是非常有帮助的。希望这篇文章能对准备字节跳动或其他大厂面试的你提供一些参考和帮助。如果你对某个题目有更深的疑问或者想要更多示例，欢迎在评论区留言交流。祝你面试顺利！

