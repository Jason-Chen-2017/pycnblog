                 

### 2024年华为校招算法面试题库及答案

#### 1. 二分查找算法

**题目：** 在一个有序数组中，找到目标值的位置。如果不能找到，返回 -1。

**答案：** 

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 二分查找算法的基本思想是：将数组中间的元素与目标值比较，如果相等则返回中间元素的下标；如果目标值比中间元素大，则在右半边继续查找；如果目标值比中间元素小，则在左半边继续查找。每次比较后，都将查找范围缩小一半，直到找到目标值或确定目标值不存在。

#### 2. 链表反转

**题目：** 反转单链表。

**答案：** 

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**解析：** 反转单链表的方法是：从前往后遍历链表，每次遍历都将当前节点的下一个节点指向当前节点的前一个节点。最后返回新的头节点。

#### 3. 最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**答案：** 

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if not s.startswith(prefix):
                return prefix
        prefix += c
    return prefix
```

**解析：** 最长公共前缀的方法是：从第一个字符串开始，逐个字符与前一个字符串比较，如果所有的字符串都以该字符开头，则将该字符添加到公共前缀中，继续比较下一个字符。

#### 4. 两数相加

**题目：** 不使用加法运算符，实现两个整数的相加。

**答案：** 

```python
def add(a, b):
    while b:
        a, b = a^b, (a&b)<<1
    return a
```

**解析：** 不使用加法运算符的方法是：使用异或运算（^）进行加法运算，使用与运算（&）和左移运算（<<）进行进位运算。每次运算后，将结果更新为 a 和 b 的异或值，进位更新为 a 和 b 的与运算结果左移一位。

#### 5. 两数之和

**题目：** 给定一个整数数组和一个目标值，找出数组中两数之和等于目标值的两个数。

**答案：** 

```python
def two_sum(nums, target):
    dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in dict:
            return [dict[complement], i]
        dict[num] = i
    return []
```

**解析：** 两数之和的方法是：使用哈希表存储每个数和其下标，遍历数组，对于每个数，计算其与目标值的差值，如果在哈希表中存在该差值，则返回两个数的下标；否则将当前数和其下标存储在哈希表中。

#### 6. 最长回文子串

**题目：** 给定一个字符串，找出其中最长的回文子串。

**答案：** 

```python
def longest_palindromic_substring(s):
    start, max_len = 0, 1
    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        len_max = max(len1, len2)
        if len_max > max_len:
            max_len = len_max
            start = i - (len_max - 1) // 2
    return s[start: start + max_len]
```

**解析：** 最长回文子串的方法是：使用中心扩展法。以每个字符为中心，向左右两边扩展，直到边界或非相同字符，记录扩展得到的长度，更新最长回文子串。

#### 7. 三数之和

**题目：** 给定一个整数数组，找出其中任意三个数之和等于零的所有三元组。

**答案：** 

```python
def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result
```

**解析：** 三数之和的方法是：首先对数组进行排序，然后使用双指针法。以第一个数为基准，第二个数从第一个数后开始，第三个数从数组末尾开始，根据三个数之和与零的关系调整左右指针的位置。

#### 8. 四数之和

**题目：** 给定一个整数数组，找出其中任意四个数之和等于零的所有四元组。

**答案：** 

```python
def four_sum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left, right = j + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total < target:
                    left += 1
                elif total > target:
                    right -= 1
                else:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
    return result
```

**解析：** 四数之和的方法是：首先对数组进行排序，然后使用双指针法。以第一个数和第二个数为基准，第三个数从第一个数后开始，第四个数从数组末尾开始，根据四个数之和与目标值的关系调整左右指针的位置。

#### 9. 无重复字符的最长子串

**题目：** 给定一个字符串，找出其中不含有重复字符的最长子串的长度。

**答案：** 

```python
def length_of_longest_substring(s):
    start = 0
    max_len = 0
    char_index_map = {}
    for end in range(len(s)):
        if s[end] in char_index_map:
            start = max(start, char_index_map[s[end]] + 1)
        max_len = max(max_len, end - start + 1)
        char_index_map[s[end]] = end
    return max_len
```

**解析：** 无重复字符的最长子串的方法是：使用滑动窗口。定义一个左边界 start 和一个右边界 end，以及一个哈希表存储字符和其下标。从左边界开始，每次向右移动右边界，如果当前字符已经存在于哈希表中，则更新左边界为哈希表中该字符下标加一。更新最大长度为当前子串长度。

#### 10. 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：** 

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 合并两个有序链表的方法是：创建一个虚拟头节点，使用当前节点指向链表中的较小值，然后移动当前节点和较小值的下一个节点，直到其中一个链表为空，将另一个链表接在当前节点后面。

#### 11. 链表中的环

**题目：** 判断链表中是否存在环。

**答案：** 

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**解析：** 判断链表中是否存在环的方法是：使用快慢指针法。初始化快指针和慢指针都指向链表的头节点，快指针每次移动两个节点，慢指针每次移动一个节点。如果快指针追上慢指针，则说明链表中存在环。

#### 12. 有效的括号

**题目：** 判断字符串中的括号是否匹配。

**答案：** 

```python
def is_valid(s):
    stack = []
    for c in s:
        if c in ['(', '[', '{']:
            stack.append(c)
        elif c in [')', ']', '}']:
            if not stack:
                return False
            top = stack.pop()
            if (c == ')' and top != '(') or (c == ']' and top != '[') or (c == '}' and top != '{'):
                return False
    return not stack
```

**解析：** 判断字符串中的括号是否匹配的方法是：使用栈。遍历字符串，对于左括号，将其入栈；对于右括号，检查栈顶元素是否匹配，如果匹配则出栈，否则返回 False。遍历结束后，如果栈为空，则说明字符串中的括号匹配。

#### 13. 汉诺塔问题

**题目：** 使用递归算法解决汉诺塔问题。

**答案：**

```python
def hanoi(n, from_peg, to_peg, aux_peg):
    if n == 1:
        print(f"Move disk 1 from peg {from_peg} to peg {to_peg}")
        return
    hanoi(n-1, from_peg, aux_peg, to_peg)
    print(f"Move disk {n} from peg {from_peg} to peg {to_peg}")
    hanoi(n-1, aux_peg, to_peg, from_peg)
```

**解析：** 汉诺塔问题的递归算法：将 n 个盘子从 from_peg 移动到 to_peg，首先将前 n-1 个盘子从 from_peg 移动到 aux_peg，然后将第 n 个盘子从 from_peg 移动到 to_peg，最后将前 n-1 个盘子从 aux_peg 移动到 to_peg。

#### 14. 股票买卖最佳时机

**题目：** 给定一个整数数组，找出只包含正整数的子数组，使得子数组的最大值减去最小值最小。

**答案：**

```python
def min_difference(nums):
    min_val = nums[0]
    max_diff = nums[1] - nums[0]
    for i in range(1, len(nums)):
        if nums[i] < min_val:
            min_val = nums[i]
        diff = nums[i] - min_val
        if diff < max_diff:
            max_diff = diff
    return max_diff
```

**解析：** 股票买卖最佳时机的方法是：遍历数组，记录最小值和最大差值，如果当前值小于最小值，则更新最小值；计算当前值与最小值的差值，如果差值小于最大差值，则更新最大差值。

#### 15. 零钱兑换

**题目：** 给定一个整数数组 coins 表示硬币的面额，和一个整数 amount 表示总金额，计算凑出总金额所需的最少硬币数量。

**答案：**

```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1
```

**解析：** 零钱兑换的方法是：使用动态规划。定义一个数组 dp，其中 dp[i] 表示凑出金额 i 所需的最少硬币数量。遍历每个金额，对于每个硬币，如果当前金额大于等于硬币面额，则更新 dp[i] 为 min(dp[i], dp[i - coin] + 1)。

#### 16. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将两个数组合并为一个有序数组。

**答案：**

```python
def merge_sorted_array(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1
```

**解析：** 合并两个有序数组的方法是：使用双指针法。定义三个指针 i、j、k 分别指向 nums1 的最后一个元素、nums2 的最后一个元素和合并后的数组的最后一个元素。比较两个数组的当前元素，将较大的元素放入合并后的数组，并移动相应的指针。

#### 17. 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：** 最长公共子序列的方法是：使用动态规划。定义一个二维数组 dp，其中 dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符的最长公共子序列长度。遍历两个字符串，如果当前字符相等，则更新 dp[i][j] 为 dp[i - 1][j - 1] + 1；否则更新 dp[i][j] 为 max(dp[i - 1][j], dp[i][j - 1])。

#### 18. 最大子序和

**题目：** 给定一个整数数组，找出其中最大的子序和。

**答案：**

```python
def max_subarray_sum(nums):
    if not nums:
        return 0
    max_so_far = nums[0]
    curr_max = nums[0]
    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far
```

**解析：** 最大子序和的方法是：使用动态规划。定义两个变量，max_so_far 和 curr_max，分别表示当前最大子序和和当前最大子序和。遍历数组，对于每个元素，更新 curr_max 为 max(nums[i], curr_max + nums[i])，然后更新 max_so_far 为 max(max_so_far, curr_max)。

#### 19. 求和的最大连续子数组

**题目：** 给定一个整数数组，找出其中和最大的连续子数组。

**答案：**

```python
def max_subarray_sum(nums):
    if not nums:
        return 0
    max_so_far = nums[0]
    curr_max = nums[0]
    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far
```

**解析：** 求和的最大连续子数组的方法与最大子序和相同，只是使用的变量名不同。

#### 20. 逆序对的数量

**题目：** 给定一个整数数组，求出数组中逆序对的数量。

**答案：**

```python
def count_inversions(nums):
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr, 0
        mid = len(arr) // 2
        left, left_inv = merge_sort(arr[:mid])
        right, right_inv = merge_sort(arr[mid:])
        merged, merge_inv = merge(left, right)
        return merged, left_inv + right_inv + merge_inv

    def merge(left, right):
        i = j = 0
        merged = []
        inv = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                merged.append(left[i])
                i += 1
            else:
                merged.append(right[j])
                inv += len(left) - i
                j += 1
        merged.extend(left[i:])
        merged.extend(right[j:])
        return merged, inv

    _, inv = merge_sort(nums)
    return inv
```

**解析：** 逆序对的数量使用归并排序的方法。在归并排序的过程中，当右子数组中的元素小于左子数组中的元素时，说明左子数组中剩余的所有元素都与当前右子数组的元素构成逆序对，因此更新逆序对的数量。

#### 21. 索引对的数量

**题目：** 给定一个整数数组，找出其中不同的索引对的个数，满足第 i 个数小于第 j 个数。

**答案：**

```python
def count_pairs(nums):
    cnt = Counter(nums)
    result = 0
    for num in nums:
        result += sum(cnt[greater] for greater in cnt if greater > num)
        cnt[num] -= 1
    return result
```

**解析：** 索引对的数量使用计数的方法。遍历数组，对于每个元素，计算大于该元素的元素个数，累加到结果中。每次计算后，更新计数器中该元素的计数。

#### 22. 删除有序数组中的重复元素

**题目：** 给定一个有序数组，删除重复元素，返回删除后的数组长度。

**答案：**

```python
def remove_duplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[slow] != nums[fast]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1
```

**解析：** 删除有序数组中的重复元素的方法是：使用快慢指针。定义两个指针 slow 和 fast，slow 指针指向最后一个不同的元素，fast 指针遍历数组，如果当前元素与 slow 指针指向的元素不同，则将当前元素赋值给 slow 指针指向的下一个位置，并更新 slow 指针。

#### 23. 两数之和 II - 输入有序数组

**题目：** 给定一个有序数组，找出两个数，使得它们的和等于目标值。

**答案：**

```python
def two_sum_two_pointers(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        total = nums[left] + nums[right]
        if total == target:
            return [left + 1, right + 1]
        elif total < target:
            left += 1
        else:
            right -= 1
    return []
```

**解析：** 两数之和 II - 输入有序数组的方法是：使用双指针法。定义两个指针 left 和 right，分别指向数组的头部和尾部，根据两个指针指向的元素之和与目标值的关系，移动 left 或 right 指针。

#### 24. 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_list(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 合并两个有序链表的方法是：使用链表头节点。定义一个虚拟头节点，使用当前节点指向链表中的较小值，然后移动当前节点和较小值的下一个节点，直到其中一个链表为空，将另一个链表接在当前节点后面。

#### 25. 盛最多水的容器

**题目：** 给定一个由若干个非负整数组成的数组，计算数组的最大子序列和。

**答案：**

```python
def max_subarray_sum(nums):
    if not nums:
        return 0
    max_so_far = nums[0]
    curr_max = nums[0]
    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far
```

**解析：** 盛最多水的容器的最大子序列和的方法与最大子序和相同，只是使用的变量名不同。

#### 26. 有效的括号字符串

**题目：** 判断一个字符串是否为有效的括号字符串。

**答案：**

```python
def is_valid(s):
    stack = []
    for c in s:
        if c in ['(', '[', '{']:
            stack.append(c)
        elif c in [')', ']', '}']:
            if not stack:
                return False
            top = stack.pop()
            if (c == ')' and top != '(') or (c == ']' and top != '[') or (c == '}' and top != '{'):
                return False
    return not stack
```

**解析：** 有效的括号字符串的方法是：使用栈。遍历字符串，对于左括号，将其入栈；对于右括号，检查栈顶元素是否匹配，如果匹配则出栈，否则返回 False。遍历结束后，如果栈为空，则说明字符串中的括号匹配。

#### 27. 链表中倒数第 k 个节点

**题目：** 给定一个链表，返回链表中的倒数第 k 个节点。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def get_kth_from_end(head, k):
    slow = fast = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    while fast:
        slow = slow.next
        fast = fast.next
    return slow
```

**解析：** 链表中倒数第 k 个节点的方法是：使用快慢指针。定义两个指针 slow 和 fast，fast 指针先走 k 步，然后 slow 和 fast 同时移动。当 fast 到达链表末尾时，slow 指针指向倒数第 k 个节点。

#### 28. 快乐数

**题目：** 编写一个算法来判断一个数是否是“快乐数”。

**答案：**

```python
def is_happy(n):
    def get_next(n):
        sum = 0
        while n:
            sum += (n % 10) ** 2
            n //= 10
        return sum

    seen = set()
    while n != 1 and n not in seen:
        seen.add(n)
        n = get_next(n)
    return n == 1
```

**解析：** 快乐数的方法是：使用快慢指针。定义一个函数 get_next，计算一个数的下一个快乐数。定义一个集合 seen，用来存储已经遍历过的数。使用快慢指针法，如果最终 n 等于 1，则说明是快乐数。

#### 29. 两数相加

**题目：** 不使用加法运算符，实现两个整数的相加。

**答案：**

```python
def add(a, b):
    while b:
        a, b = a^b, (a&b)<<1
    return a
```

**解析：** 两数相加的方法是：使用异或运算和与运算。异或运算用于计算两个数的和，与运算用于计算进位。每次运算后，将结果更新为 a 和 b 的异或值，进位更新为 a 和 b 的与运算结果左移一位。

#### 30. 有效的数字

**题目：** 判断一个字符串是否为有效的数字。

**答案：**

```python
def is_number(s):
    import re
    return bool(re.match(r'^-?\d+(\.\d+)?([eE][-+]?\d+)?$', s))
```

**解析：** 有效的数字的方法是：使用正则表达式。定义一个正则表达式，匹配整数、浮点数和科学计数法表示的数字。如果字符串匹配正则表达式，则返回 True。

### 总结

以上是华为2024年校招算法面试题库及答案的详细解析，涵盖常见的算法和数据结构问题。这些题目不仅能帮助求职者熟悉华为的面试风格，还能提升编程和算法能力。通过详细的解析和代码实例，求职者可以更好地理解题目的本质和解题思路，为面试做好准备。在实际面试中，求职者可以根据题目要求灵活运用各种算法和数据结构，展示自己的编程能力。祝大家面试顺利，取得好成绩！


