                 

## 2025滴滴社招算法面试题汇总与解析

### 1. 算法题：二分查找

**题目：** 在一个有序数组中，找出目标值的位置。

**输入：** 
```
nums = [1, 3, 5, 7, 9, 11]
target = 7
```

**输出：**
```
index = 3
```

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right - left) / 2
        
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1
}
```

**解析：** 使用二分查找算法，通过不断缩小查找范围，直到找到目标值或确定其不存在。此算法的时间复杂度为 O(log n)。

### 2. 算法题：最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**输入：** 
```
strs = ["flower", "flow", "flight"]
```

**输出：**
```
prefix = "fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    
    prefix := strs[0]
    
    for _, s := range strs {
        for i := 0; i < len(prefix) && i < len(s); i++ {
            if prefix[i] != s[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    
    return prefix
}
```

**解析：** 从第一个字符串开始，依次与后续字符串比较，找到公共前缀。此算法的时间复杂度为 O(n * m)，其中 n 为字符串数量，m 为最长字符串长度。

### 3. 算法题：环形数组中的最小元素

**题目：** 在一个环形数组中，找出最小元素的位置。

**输入：**
```
nums = [2,1,5,2,3,2]
```

**输出：**
```
minIndex = 1
```

**答案：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    
    for left < right {
        mid := left + (right - left) / 2
        
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return nums[left]
}
```

**解析：** 将问题转化为寻找最小元素的左边界。使用二分查找，时间复杂度为 O(n)。

### 4. 算法题：有效的括号字符串

**题目：** 判断字符串中括号是否匹配。

**输入：**
```
s = "()()"
```

**输出：**
```
true
```

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    
    for _, v := range s {
        if v == '(' || v == '{' || v == '[' {
            stack = append(stack, v)
        } else if len(stack) == 0 || (v != ')' && v != '}' && v != ']') || (v == ')' && stack[len(stack)-1] != '(') || (v == '}' && stack[len(stack)-1] != '{') || (v == ']' && stack[len(stack)-1] != '[') {
            return false
        }
        
        stack = stack[:len(stack)-1]
    }
    
    return len(stack) == 0
}
```

**解析：** 使用栈存储括号，匹配括号时判断是否与栈顶元素匹配。此算法的时间复杂度为 O(n)。

### 5. 算法题：最大子序和

**题目：** 求一个数组的最大子序和。

**输入：**
```
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

**输出：**
```
maxSum = 6
```

**答案：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    curSum := nums[0]
    
    for i := 1; i < len(nums); i++ {
        curSum = max(nums[i], curSum+nums[i])
        maxSum = max(maxSum, curSum)
    }
    
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用贪心算法，遍历数组，更新当前最大子序和和全局最大子序和。此算法的时间复杂度为 O(n)。

### 6. 算法题：全排列

**题目：** 求一个数组的所有排列。

**输入：**
```
nums = [1, 2, 3]
```

**输出：**
```
permutations = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

**答案：**

```go
func permute(nums []int) [][]int {
    var res [][]int
    dfs(nums, []int{}, &res)
    return res
}

func dfs(nums []int, path []int, res *[][]int) {
    if len(nums) == 0 {
        t := make([]int, len(path))
        copy(t, path)
        *res = append(*res, t)
        return
    }
    
    for i := 0; i < len(nums); i++ {
        t := make([]int, len(nums))
        copy(t, nums)
        t = append(t[:i], t[i+1:]...)
        dfs(t, append(path, nums[i]), res)
    }
}

```

**解析：** 使用深度优先搜索（DFS）算法，递归地生成所有排列。此算法的时间复杂度为 O(n!)。

### 7. 算法题：最长公共子序列

**题目：** 求两个字符串的最长公共子序列。

**输入：**
```
text1 = "ABCD"
text2 = "ACDF"
```

**输出：**
```
lcs = "AC"
```

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    res := ""
    i, j := m, n
    for dp[i][j] != 0 {
        if text1[i-1] == text2[j-1] {
            res = string(text1[i-1]) + res
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划（DP）算法，构建一个二维数组记录最长公共子序列的长度。然后回溯求解最长公共子序列。此算法的时间复杂度为 O(m * n)。

### 8. 算法题：股票交易

**题目：** 给定一个数组，求在该数组中进行最多一次买卖能获得的最大利润。

**输入：**
```
prices = [7, 1, 5, 3, 6, 4]
```

**输出：**
```
maxProfit = 5
```

**答案：**

```go
func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    
    minPrice := prices[0]
    maxProfit := 0
    
    for i := 1; i < len(prices); i++ {
        if prices[i] < minPrice {
            minPrice = prices[i]
        } else {
            profit := prices[i] - minPrice
            if profit > maxProfit {
                maxProfit = profit
            }
        }
    }
    
    return maxProfit
}
```

**解析：** 从第一个元素开始，遍历数组，更新最小价格和最大利润。此算法的时间复杂度为 O(n)。

### 9. 算法题：最长递增子序列

**题目：** 求一个数组的最长递增子序列。

**输入：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

**输出：**
```
lens = 4
```

**答案：**

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    dp := make([]int, len(nums))
    dp[0] = 1
    maxLen := 1
    
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }
    
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划（DP）算法，构建一个一维数组记录最长递增子序列的长度。此算法的时间复杂度为 O(n^2)。

### 10. 算法题：合并两个有序链表

**题目：** 合并两个有序链表。

**输入：**
```
l1 = [1, 2, 4]
l2 = [1, 3, 4]
```

**输出：**
```
merged = [1, 1, 2, 3, 4, 4]
```

**答案：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归地比较两个链表的头节点，将较小的节点连接到合并后的链表，然后继续递归合并剩余部分。此算法的时间复杂度为 O(n+m)。

### 11. 算法题：最小栈

**题目：** 设计一个最小栈，支持插入、删除和获取最小值操作。

**输入：**
```
ops = ["Push", "Push", "Push", "GetMin", "Pop", "GetMin"]
values = [[], [5], [2], [], [], []]
```

**输出：**
```
results = [2, 2, 2, 2]
```

**答案：**

```go
type MinStack struct {
    s []int
    min int
}

func Constructor() MinStack {
    return MinStack{[]int{}, math.MaxInt32}
}

func (this *MinStack) Push(x int)  {
    this.s = append(this.s, x)
    if x < this.min {
        this.min = x
    }
}

func (this *MinStack) Pop()  {
    if this.s == nil {
        return
    }
    x := this.s[len(this.s)-1]
    this.s = this.s[:len(this.s)-1]
    if x == this.min {
        this.min = this.s[0]
    }
}

func (this *MinStack) Top() int {
    if this.s == nil {
        return -1
    }
    return this.s[len(this.s)-1]
}

func (this *MinStack) GetMin() int {
    if this.s == nil {
        return -1
    }
    return this.min
}
```

**解析：** 使用一个辅助栈记录最小值，每次插入和删除时更新最小值。此算法的时间复杂度为 O(1)。

### 12. 算法题：有效的括号字符串

**题目：** 判断字符串中的括号是否匹配。

**输入：**
```
s = "()()"
```

**输出：**
```
true
```

**答案：**

```go
func isValid(s string) bool {
    stack := []byte{}
    m := map[rune]int{'(': ')', '{': '}', '[': ']'}
    
    for _, v := range s {
        if m[v] > 0 {
            stack = append(stack, m[v])
        } else if len(stack) == 0 || stack[len(stack)-1] != v {
            return false
        }
        stack = stack[:len(stack)-1]
    }
    
    return len(stack) == 0
}
```

**解析：** 使用栈存储括号，匹配括号时判断是否与栈顶元素匹配。此算法的时间复杂度为 O(n)。

### 13. 算法题：合并区间

**题目：** 合并一个区间列表。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
merged = [[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    
    var res [][]int
    res = append(res, intervals[0])
    
    for i := 1; i < len(intervals); i++ {
        last := res[len(res)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            res = append(res, intervals[i])
        }
    }
    
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 首先对区间列表进行排序，然后遍历区间列表，合并重叠的区间。此算法的时间复杂度为 O(nlogn)。

### 14. 算法题：排序链表

**题目：** 对链表进行排序。

**输入：**
```
head = [4,2,1,3]
```

**输出：**
```
sorted = [1,2,3,4]
```

**答案：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    
    mid := middleNode(head)
    right := sortList(mid.Next)
    mid.Next = nil
    
    left := sortList(head)
    return merge(left, right)
}

func middleNode(head *ListNode) *ListNode {
    slow, fast := head, head
    
    for fast.Next != nil && fast.Next.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    
    return slow
}

func merge(left, right *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    curr := dummy
    
    for left != nil && right != nil {
        if left.Val < right.Val {
            curr.Next = left
            left = left.Next
        } else {
            curr.Next = right
            right = right.Next
        }
        curr = curr.Next
    }
    
    if left != nil {
        curr.Next = left
    }
    if right != nil {
        curr.Next = right
    }
    
    return dummy.Next
}
```

**解析：** 使用归并排序，递归地将链表分为两半，然后合并排序后的链表。此算法的时间复杂度为 O(nlogn)。

### 15. 算法题：排序数组

**题目：** 对一个数组进行排序。

**输入：**
```
nums = [5, 2, 9, 1]
```

**输出：**
```
sorted = [1, 2, 5, 9]
```

**答案：**

```go
func sortArray(nums []int) []int {
    if len(nums) < 2 {
        return nums
    }
    
    mid := len(nums) / 2
    left := sortArray(nums[:mid])
    right := sortArray(nums[mid:])
    
    return merge(left, right)
}

func merge(left, right []int) []int {
    var res []int
    i, j := 0, 0
    
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            res = append(res, left[i])
            i++
        } else {
            res = append(res, right[j])
            j++
        }
    }
    
    res = append(res, left[i:]...)
    res = append(res, right[j:]...)
    
    return res
}
```

**解析：** 使用归并排序，递归地将数组分为两半，然后合并排序后的数组。此算法的时间复杂度为 O(nlogn)。

### 16. 算法题：加一

**题目：** 对一个整数数组进行加一操作。

**输入：**
```
digits = [1,2,3]
```

**输出：**
```
result = [1,2,4]
```

**答案：**

```go
func plusOne(digits []int) []int {
    for i := len(digits) - 1; i >= 0; i-- {
        if digits[i] < 9 {
            digits[i]++
            return digits
        }
        digits[i] = 0
    }
    
    newDigit := make([]int, len(digits)+1)
    newDigit[0] = 1
    
    return newDigit
}
```

**解析：** 从个位开始加一，如果当前位小于9，则直接加一；否则，当前位变为0，继续向前一位加一。如果最高位也需要加一，则扩展数组长度。此算法的时间复杂度为 O(n)。

### 17. 算法题：有效的数独

**题目：** 判断一个 9x9 数独是否有效。

**输入：**
```
board = [["5","3",".",".","7",".",".",".","."],
         ["6",".",".","1","9","5",".",".","."],
         [".","9","8",".",".",".",".","6","."],
         ["8",".",".",".","6",".",".",".","3"],
         ["4",".",".","8",".","3",".",".","1"],
         ["7",".",".",".","2",".",".",".","6"],
         [".","6",".",".",".",".","2","8","."],
         [".",".",".","4","1","9",".",".","5"],
         [".",".",".",".","8",".",".","7","9"]]
```

**输出：**
```
valid = true
```

**答案：**

```go
func isValidSudoku(board [][]byte) bool {
    row, col := [9][9]bool{}, [9][9]bool{}
    square := [9][9]bool{}
    
    for i := 0; i < 9; i++ {
        for j := 0; j < 9; j++ {
            v := board[i][j]
            if v != '.' {
                r, c := i/3, j/3
                if row[i][v-'1'] || col[j][v-'1'] || square[r][c][v-'1'] {
                    return false
                }
                row[i][v-'1'] = true
                col[j][v-'1'] = true
                square[r][c][v-'1'] = true
            }
        }
    }
    
    return true
}
```

**解析：** 使用三个二维数组分别记录行、列和3x3宫格中的数字。遍历数组，判断是否出现重复数字。此算法的时间复杂度为 O(n^2)。

### 18. 算法题：最大子序列和

**题目：** 求一个数组中的最大子序列和。

**输入：**
```
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

**输出：**
```
maxSum = 6
```

**答案：**

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    maxSum, curSum := nums[0], nums[0]
    
    for i := 1; i < len(nums); i++ {
        curSum = max(nums[i], curSum+nums[i])
        maxSum = max(maxSum, curSum)
    }
    
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用贪心算法，遍历数组，更新当前最大子序列和和全局最大子序列和。此算法的时间复杂度为 O(n)。

### 19. 算法题：合并两个有序链表

**题目：** 合并两个有序链表。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
merged = [1,1,2,3,4,4]
```

**答案：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归地比较两个链表的头节点，将较小的节点连接到合并后的链表，然后继续递归合并剩余部分。此算法的时间复杂度为 O(n+m)。

### 20. 算法题：打家劫舍

**题目：** 你是一个偷盗者，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素是相邻的房屋装有相互连通的防盗系统。计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**输入：**
```
nums = [2,7,9,3,1]
```

**输出：**
```
maxAmount = 12
```

**答案：**

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    
    prev2, prev1 := 0, nums[0]
    for i := 1; i < len(nums); i++ {
        curr := max(prev1, prev2+nums[i])
        prev2 = prev1
        prev1 = curr
    }
    
    return prev1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划（DP）算法，遍历数组，更新前两个元素的最大值。此算法的时间复杂度为 O(n)。

### 21. 算法题：最长公共子串

**题目：** 给定两个字符串，求它们的最长公共子串。

**输入：**
```
s1 = "abcde"
s2 = "acdef"
```

**输出：**
```
lcs = "ac"
```

**答案：**

```go
func longestCommonSubstr(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    maxLen, mx := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    mx = i
                }
            }
        }
    }
    
    return s1[mx-maxLen : mx]
}
```

**解析：** 使用动态规划（DP）算法，构建一个二维数组记录最长公共子串的长度。然后回溯求解最长公共子串。此算法的时间复杂度为 O(m * n)。

### 22. 算法题：矩阵中的最长递增路径

**题目：** 给定一个 m x n 的矩阵，求矩阵中的最长递增路径。

**输入：**
```
matrix = [
    [9,9,4],
    [6,6,8],
    [2,1,7]
]
```

**输出：**
```
length = 4
```

**答案：**

```go
func longestIncreasingPath(matrix [][]int) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }
    
    m, n := len(matrix), len(matrix[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    
    maxLen := 1
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            maxLen = max(maxLen, dfs(i, j, &matrix, dp))
        }
    }
    
    return maxLen
}

func dfs(i, j int, matrix **[][]int, dp **[]*int) int {
    if (*dp)[i][j] != 0 {
        return (*dp)[i][j]
    }
    
    directs := []int{-1, 0, 1, 0, -1}
    for k := 0; k < 4; k++ {
        x, y := i+directs[k], j+directs[k+1]
        if x >= 0 && x < len(*matrix) && y >= 0 && y < len((*matrix)[0]) && (*matrix)[x][y] > (*matrix)[i][j] {
            (*dp)[i][j] = max((*dp)[i][j], dfs(x, y, matrix, dp)+1)
        }
    }
    
    return (*dp)[i][j]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用深度优先搜索（DFS）算法，遍历矩阵，更新最长递增路径的长度。此算法的时间复杂度为 O(m * n)。

### 23. 算法题：二叉搜索树的第 k 个节点

**题目：** 给定一个二叉搜索树的根节点 root 和一个整数 k，返回二叉搜索树中第 k 个节点的值。

**输入：**
```
root = [5,3,7,2,4,6,8], k = 3
```

**输出：**
```
val = 4
```

**答案：**

```go
func kthSmallest(root *TreeNode, k int) int {
    var dfs func(*TreeNode) int
    dfs = func(root *TreeNode) int {
        if root == nil {
            return -1
        }
        left := dfs(root.Left)
        if left != -1 {
            return left
        }
        if --k == 0 {
            return root.Val
        }
        return dfs(root.Right)
    }
    return dfs(root)
}
```

**解析：** 使用中序遍历，遍历到第 k 个节点时返回其值。此算法的时间复杂度为 O(n)。

### 24. 算法题：搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，找出一个给定目标值的目标索引。如果数组中存在这个目标值，则返回它的索引，否则返回 -1。

**输入：**
```
nums = [4,5,6,7,0,1,2], target = 0
```

**输出：**
```
index = 4
```

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    
    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            if nums[right] == target {
                return right
            }
            left = mid + 1
        } else {
            if nums[left] == target {
                return left
            }
            right = mid - 1
        }
    }
    
    return -1
}
```

**解析：** 使用二分查找，根据中间值判断数组是否旋转，并更新左右边界。此算法的时间复杂度为 O(log n)。

### 25. 算法题：爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶，求有多少种不同的方法可以爬到楼顶。

**输入：**
```
n = 3
```

**输出：**
```
ways = 3
```

**答案：**

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    
    prev2, prev1 := 1, 2
    for i := 2; i < n; i++ {
        curr := prev1 + prev2
        prev2 = prev1
        prev1 = curr
    }
    
    return prev1
}
```

**解析：** 使用动态规划，更新前两个元素的方法数。此算法的时间复杂度为 O(n)。

### 26. 算法题：最长公共前缀

**题目：** 给定一个字符串数组，找出它们的最大公共前缀。

**输入：**
```
strs = ["flower","flow","flight"]
```

**输出：**
```
prefix = "fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    
    prefix := strs[0]
    
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    
    return prefix
}
```

**解析：** 从第一个字符串开始，依次与后续字符串比较，找到公共前缀。此算法的时间复杂度为 O(n * m)，其中 n 为字符串数量，m 为最长字符串长度。

### 27. 算法题：二进制求和

**题目：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**输入：**
```
a = "11"
b = "1"
```

**输出：**
```
sum = "100"
```

**答案：**

```go
func addBinary(a string, b string) string {
    var ans string
    i, j := len(a)-1, len(b)-1
    carry := 0
    
    for i >= 0 || j >= 0 {
        x, y := 0, 0
        if i >= 0 {
            x = int(a[i]-'0')
            i--
        }
        if j >= 0 {
            y = int(b[j]-'0')
            j--
        }
        sum := x + y + carry
        carry = sum / 2
        ans = strconv.Itoa(sum%2) + ans
    }
    
    if carry > 0 {
        ans = "1" + ans
    }
    
    return ans
}
```

**解析：** 从低位开始相加，计算进位。此算法的时间复杂度为 O(max(m, n))，其中 m 和 n 分别为两个二进制字符串的长度。

### 28. 算法题：三数之和

**题目：** 给定一个数组 nums 和一个目标值 target，找出数组中三个元素的和等于 target 的元素。

**输入：**
```
nums = [-1, 0, 1, 2, -1, -4], target = 0
```

**输出：**
```
triplets = [[-1, 0, 1], [-1, -1, 2]]
```

**答案：**

```go
func threeSum(nums []int) [][]int {
    if len(nums) < 3 {
        return nil
    }
    
    sort.Ints(nums)
    var res [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    
    return res
}
```

**解析：** 使用排序和双指针，遍历数组，找到三个元素的和等于目标值。此算法的时间复杂度为 O(n^2)。

### 29. 算法题：两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字，请计算它们表示的非负整数的和，并用链表形式返回。

**输入：**
```
l1 = [2,4,3]
l2 = [5,6,4]
```

**输出：**
```
result = [7,0,7]
```

**答案：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    curr := dummy
    carry := 0
    
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        node := &ListNode{Val: sum % 10}
        curr.Next = node
        curr = curr.Next
    }
    
    return dummy.Next
}
```

**解析：** 使用链表存储和的每一位，更新进位。此算法的时间复杂度为 O(max(m, n))，其中 m 和 n 分别为两个链表的长度。

### 30. 算法题：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**输入：**
```
s1 = "abcde"
s2 = "ace"
```

**输出：**
```
lcs = "ace"
```

**答案：**

```go
func longestCommonSubsequence(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    
    var lcs []byte
    for i := m; i > 0 && j > 0; i-- {
        if s1[i-1] == s2[j-1] {
            lcs = append([]byte{s1[i-1]}, lcs...)
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    
    return string(lcs)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划（DP）算法，构建一个二维数组记录最长公共子序列的长度。然后回溯求解最长公共子序列。此算法的时间复杂度为 O(m * n)。

### 31. 算法题：合并区间

**题目：** 给出一个区间的列表，合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
merged = [[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    
    var res [][]int
    res = append(res, intervals[0])
    
    for i := 1; i < len(intervals); i++ {
        last := res[len(res)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            res = append(res, intervals[i])
        }
    }
    
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 首先对区间列表进行排序，然后遍历区间列表，合并重叠的区间。此算法的时间复杂度为 O(nlogn)。

### 32. 算法题：环形数组中的最小元素

**题目：** 给定一个环形数组，找出数组中的最小元素。

**输入：**
```
nums = [2,1,5,2,3,2]
```

**输出：**
```
minIndex = 1
```

**答案：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    
    for left < right {
        mid := left + (right - left) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    
    return nums[left]
}
```

**解析：** 将问题转化为寻找最小元素的左边界。使用二分查找，时间复杂度为 O(n)。

### 33. 算法题：奇偶数排序

**题目：** 给定一个由奇数数组和偶数数组组成的数组，将奇数放在偶数的前面，返回重排后的数组。

**输入：**
```
nums = [12, 3, 4, 6, 2]
```

**输出：**
```
sorted = [3, 2, 4, 6, 12]
```

**答案：**

```go
func sortArrayByParityII(nums []int) []int {
    even := 0
    for i := 0; i < len(nums); i += 2 {
        if nums[i]%2 != 0 {
            nums[i], nums[even] = nums[even], nums[i]
            even += 2
        }
    }
    return nums
}
```

**解析：** 将奇数移到偶数的位置。此算法的时间复杂度为 O(n)。

### 34. 算法题：两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字，请计算它们表示的非负整数的和，并用链表形式返回。

**输入：**
```
l1 = [2,4,3]
l2 = [5,6,4]
```

**输出：**
```
result = [7,0,7]
```

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    curr := dummy
    carry := 0
    
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        node := &ListNode{Val: sum % 10}
        curr.Next = node
        curr = curr.Next
    }
    
    return dummy.Next
}
```

**解析：** 使用链表存储和的每一位，更新进位。此算法的时间复杂度为 O(max(m, n))，其中 m 和 n 分别为两个链表的长度。

### 35. 算法题：无重复字符的最长子串

**题目：** 给定一个字符串，找出不含有重复字符的最长子串的长度。

**输入：**
```
s = "abcabcbb"
```

**输出：**
```
length = 3
```

**答案：**

```go
func lengthOfLongestSubstring(s string) int {
    var res int
    m := map[rune]bool{}
    l, r := 0, 0
    for r < len(s) {
        for m[s[r]] {
            delete(m, s[l])
            l++
        }
        res = max(res, r-l+1)
        r++
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用双指针和哈希表，遍历字符串，更新最长子串的长度。此算法的时间复杂度为 O(n)。

