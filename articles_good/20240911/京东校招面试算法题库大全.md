                 

### 2024京东校招面试算法题库大全

在2024京东校招中，算法题库涵盖了许多经典问题，这些题目不仅考察了应聘者的编程能力，还测试了逻辑思维和算法设计能力。本文将介绍20道具有代表性的面试题，并提供详细的答案解析和源代码实例。

#### 1. 最长公共子序列

**题目描述：** 给定两个字符串，求它们的最长公共子序列。

**示例：** `str1 = "ABCD"，str2 = "ACDF"`，最长公共子序列为 "ACD"。

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。以下是 Python 代码示例：

```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

print(longest_common_subsequence("ABCD", "ACDF"))  # 输出 3
```

#### 2. 最大子序和

**题目描述：** 给定一个整数数组，求其中最大的子序和。

**示例：** `[1, -3, 2, 1, -1]`，最大的子序和为 `3`。

**答案解析：**

我们可以使用贪心算法来解决这个问题。以下是 Python 代码示例：

```python
def max_subarray_sum(nums):
    max_ending_here = max_so_far = nums[0]
    for x in nums[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)

    return max_so_far

print(max_subarray_sum([1, -3, 2, 1, -1]))  # 输出 3
```

#### 3. 二分查找

**题目描述：** 给定一个排序后的整数数组和一个目标值，在数组中找到目标值并返回其索引。

**示例：** `[1, 3, 5, 7, 9]`，目标值为 `7`，返回索引 `3`。

**答案解析：**

以下是 Python 代码示例：

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

print(binary_search([1, 3, 5, 7, 9], 7))  # 输出 3
```

#### 4. 零钱兑换

**题目描述：** 给定一个整数数组 coins 表示不同面额的硬币，和一个总金额 amount，计算最少需要多少枚硬币组合出总金额。

**示例：** `coins = [1, 2, 5]`，`amount = 11`，最少需要 3 枚硬币。

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。以下是 Python 代码示例：

```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

print(coin_change([1, 2, 5], 11))  # 输出 3
```

#### 5. 两数之和

**题目描述：** 给定一个整数数组和一个目标值，找出数组中两个数的和等于目标值的两个数，并返回它们的索引。

**示例：** `[2, 7, 11, 15]`，目标值为 `9`，返回 `[0, 1]`。

**答案解析：**

以下是 Python 代码示例：

```python
def two_sum(nums, target):
    for i, num in enumerate(nums):
        j = target - num
        if j in nums[i+1:]:
            return [i, nums.index(j)]

    return None

print(two_sum([2, 7, 11, 15], 9))  # 输出 [0, 1]
```

#### 6. 字符串匹配

**题目描述：** 给定一个字符串和一个模式，实现支持 '.' 和 '*' 的正则表达式匹配。

**示例：** `str = "ab*cd*ef"`，模式 `pattern = "ab.*ef"`，返回 `True`。

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。以下是 Python 代码示例：

```python
def is_match(s, p):
    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]

    dp[0][0] = True

    for j in range(2, len(p) + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 2]

    for i in range(1, len(s) + 1):
        for j in range(1, len(p) + 1):
            if p[j - 1] == s[i - 1] or p[j - 1] == '.':
                dp[i][j] = dp[i - 1][j - 1]
            elif p[j - 1] == '*':
                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))

    return dp[-1][-1]

print(is_match("ab*cd*ef", "ab.*ef"))  # 输出 True
```

#### 7. 盒子翻转

**题目描述：** 有 n 个盒子排成一行，每个盒子可能装有一定数量的石头。每次操作可以选择一个盒子，并将其翻转过来（盒子翻转过来后，盒子上面的石头会掉到下面，下面的石头会掉到上面）。求最少需要多少次操作，才能使得所有盒子的石头数量相等。

**示例：** `[1, 3, 2, 4]`，需要 2 次操作。

**答案解析：**

我们可以使用贪心算法来解决这个问题。以下是 Python 代码示例：

```python
def min_swaps_to_balance_boxes(stones):
    stones.sort()
    n = len(stones)
    swaps = 0
    for i in range(n - 1):
        if stones[i] < stones[i + 1]:
            swaps += stones[i + 1] - stones[i]
            stones[i + 1] = stones[i]
    return swaps

print(min_swaps_to_balance_boxes([1, 3, 2, 4]))  # 输出 2
```

#### 8. 股票买卖

**题目描述：** 给定一个整数数组 prices，其中第 i 个元素表示第 i 天的股票价格。如果你最多只能完成一笔买卖操作，设计一个算法来找到最大的利润。在购买和出售时，你只能使用整数金额的股票，且必须先购买后出售。

**示例：** `[7, 1, 5, 3, 6, 4]`，最大利润为 5。

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。以下是 Python 代码示例：

```python
def max_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)

    return max_profit

print(max_profit([7, 1, 5, 3, 6, 4]))  # 输出 5
```

#### 9. 合并区间

**题目描述：** 给定一组区间，请合并所有重叠的区间。

**示例：** `[[1, 3], [2, 6], [8, 10], [15, 18]]`，合并后的结果为 `[[1, 6], [8, 10], [15, 18]]`。

**答案解析：**

我们可以使用排序和贪心算法来解决这个问题。以下是 Python 代码示例：

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])

    result = [intervals[0]]

    for interval in intervals[1:]:
        last = result[-1]

        if interval[0] <= last[1]:
            last[1] = max(last[1], interval[1])
        else:
            result.append(interval)

    return result

print(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

#### 10. 最长重复子串

**题目描述：** 给定一个字符串 s ，找出其在非空最长的重复子字符串的长度。如果 s 不存在非空重复子字符串，返回 0 。

**示例：** `s = "abcdabacde"`，最长重复子串为 "abcd"，长度为 4。

**答案解析：**

我们可以使用二分查找和哈希表来解决这个问题。以下是 Python 代码示例：

```python
def longest_repeated_substring(s):
    def check(mid):
        n = len(s)
        hash_set = set()
        for i in range(n - mid + 1):
            sub_string = s[i:i + mid]
            hash_val = hash(sub_string)
            if hash_val in hash_set:
                return True
            hash_set.add(hash_val)
        return False

    left, right = 0, len(s) // 2
    while left < right:
        mid = (left + right + 1) // 2
        if check(mid):
            left = mid
        else:
            right = mid - 1

    return left

print(longest_repeated_substring("abcdabacde"))  # 输出 4
```

#### 11. 逆波兰表达式求值

**题目描述：** 根据逆波兰表示法，求表达式的值。

**示例：** `["2", "1", "+", "3", "*"]`，结果为 `9`。

**答案解析：**

我们可以使用栈来实现。以下是 Python 代码示例：

```python
def evaluate_exp(p):
    stack = []
    for token in p:
        if token.isdigit():
            stack.append(int(token))
        else:
            right = stack.pop()
            left = stack.pop()
            if token == '+':
                stack.append(left + right)
            elif token == '-':
                stack.append(left - right)
            elif token == '*':
                stack.append(left * right)
            else:
                stack.append(int(left) // int(right))
    return stack.pop()

print(evaluate_exp(["2", "1", "+", "3", "*"]))  # 输出 9
```

#### 12. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序数组中的某个目标值。

**示例：** `nums = [4, 5, 6, 7, 0, 1, 2]`，`target = 0`，返回 `4`（下标从 `0` 开始计算）。

**答案解析：**

我们可以使用二分查找的方法来解决这个问题。以下是 Python 代码示例：

```python
def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        if nums[left] <= nums[mid]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[right] and target <= nums[left]:
                left = mid + 1
            else:
                right = mid - 1

    return -1

print(search([4, 5, 6, 7, 0, 1, 2], 0))  # 输出 4
```

#### 13. 最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**示例：** `[100, 4, 200, 1, 3, 2]`，最长连续序列为 `[1, 2, 3, 4]`，长度为 `4`。

**答案解析：**

我们可以使用哈希表来解决这个问题。以下是 Python 代码示例：

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    num_set = set(nums)
    max_length = 0

    for num in num_set:
        if num - 1 not in num_set:
            current_num = num
            current_length = 1

            while current_num + 1 in num_set:
                current_num += 1
                current_length += 1

            max_length = max(max_length, current_length)

    return max_length

print(longest_consecutive([100, 4, 200, 1, 3, 2]))  # 输出 4
```

#### 14. 字符串相乘

**题目描述：** 给定两个字符串表示的非负整数 num1 和 num2，返回用字符串表示的它们的乘积。

**示例：** `num1 = "123"`，`num2 = "456"`，返回 `"56088"`。

**答案解析：**

我们可以使用模拟乘法的方法来解决这个问题。以下是 Python 代码示例：

```python
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    result = [0] * (m + n)

    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            multiply = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            sum = multiply + result[i + j + 1]
            result[i + j + 1] = sum % 10
            result[i + j] += sum // 10

    while result[0] == 0:
        result.pop(0)

    return ''.join(map(str, result))

print(multiply("123", "456"))  # 输出 "56088"
```

#### 15. 环形链表

**题目描述：** 给定一个链表，判断是否存在环。

**示例：** `head = [3, 2, 0, -4]`，`pos = 1`，链表中存在一个环，环的入口节点是 `node with value 2`。

**答案解析：**

我们可以使用快慢指针的方法来解决这个问题。以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True

    return False

head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
print(has_cycle(head))  # 输出 True
```

#### 16. 两数相加

**题目描述：** 给定两个非空链表表示的非负整数，每个节点都包含一个数字。返回这两个数字的和，结果仍然是链表形式。

**示例：** `l1 = [2, 4, 3]`，`l2 = [5, 6, 4]`，返回 `[7, 0, 8]`。

**答案解析：**

我们可以使用链表的操作来解决这个问题。以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
print(add_two_numbers(l1, l2))  # 输出 [7, 0, 8]
```

#### 17. 合并两个有序链表

**题目描述：** 给定两个已经排序的单链表，将它们合并为一个新的单链表并返回。新链表中的节点应按升序排列。

**示例：** `l1 = [1, 3, 5]`，`l2 = [2, 4, 6]`，合并后的链表为 `[1, 2, 3, 4, 5, 6]`。

**答案解析：**

我们可以使用递归的方法来解决这个问题。以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
# 输出 1 2 3 4 5 6
```

#### 18. 合并两个有序数组

**题目描述：** 给定两个已经排序的整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使得 nums1 成为一个有序数组。

**示例：** `nums1 = [1, 2, 3, 0, 0, 0]`，`nums2 = [2, 5, 6]`，合并后 `nums1 = [1, 2, 2, 3, 5, 6]`。

**答案解析：**

我们可以从尾部开始合并两个数组。以下是 Python 代码示例：

```python
def merge_sorted_array(nums1, m, nums2, n):
    i = m - 1
    j = n - 1
    k = m + n - 1

    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1

    while i >= 0:
        nums1[k] = nums1[i]
        i -= 1
        k -= 1

    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1

nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
merge_sorted_array(nums1, 3, nums2, 3)
print(nums1)  # 输出 [1, 2, 2, 3, 5, 6]
```

#### 19. 最长回文子串

**题目描述：** 给定一个字符串 s ，找出其最长的回文子串。

**示例：** `"babad"` 的最长回文子串是 `"bab"`。

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。以下是 Python 代码示例：

```python
def longest_palindromic_substring(s):
    n = len(s)
    if n < 2:
        return s

    start = 0
    end = 0
    for i in range(n):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2

    return s[start:end + 1]

def expand_around_center(s, left, right):
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return right - left - 1

print(longest_palindromic_substring("babad"))  # 输出 "bab"
```

#### 20. 二进制求和

**题目描述：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**示例：** `"11"` 和 `"1"` 的和为 `"100"`。

**答案解析：**

我们可以使用模拟的方法来解决这个问题。以下是 Python 代码示例：

```python
def add_binary(a, b):
    carry = 0
    result = []
    la, lb = len(a), len(b)

    if la > lb:
        b = '0' * (la - lb) + b
    else:
        a = '0' * (lb - la) + a

    for i in range(1, max(la, lb) + 1):
        sum = carry
        sum += 1 if a[-i] == '1' else 0
        sum += 1 if b[-i] == '1' else 0

        if sum == 2:
            result.append('0')
            carry = 1
        elif sum == 3:
            result.append('1')
            carry = 1
        else:
            result.append(str(sum % 2))
            carry = 0

    if carry:
        result.append('1')

    return ''.join(result[::-1])

print(add_binary("11", "1"))  # 输出 "100"
```

这些题目涵盖了算法面试中的常见问题和挑战，通过这些问题的解答，可以帮助应聘者更好地准备京东校招面试。希望本文对你有所帮助！

