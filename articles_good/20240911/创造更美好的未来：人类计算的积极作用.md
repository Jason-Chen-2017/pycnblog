                 

# **自拟标题：** 探索人类计算在构建未来美好世界中的核心作用与算法实现

## **一、引言**

在《创造更美好的未来：人类计算的积极作用》这个主题下，我们将深入探讨计算技术如何成为推动社会进步、提升生活质量的重要力量。本文将围绕这一主题，分析国内头部一线大厂在计算领域的高频面试题和算法编程题，以展示计算技术在各行业中的应用及其潜力。

## **二、典型问题与面试题库**

### **1. 算法优化问题：寻找峰值元素**

**题目：** 在一个整数数组的中，找到峰值元素，即数组中的一个元素，其值大于左右相邻的元素。

**答案解析：**

- **简单解法：** 采用暴力搜索的方式，遍历数组，找到符合条件的元素。

```python
def find_peak_element(nums):
    for i in range(1, len(nums) - 1):
        if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
            return nums[i]
    return -1
```

- **二分查找解法：** 利用二分查找的思想，不断缩小查找范围。

```python
def find_peak_element(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return nums[left]
```

### **2. 数据结构问题：设计循环双端队列**

**题目：** 设计一个支持以下操作的双端队列：

- `appendFront`：在队列头部插入一个元素。
- `append Rear`：在队列尾部插入一个元素。
- `deleteFront`：删除队列头部元素。
- `deleteRear`：删除队列尾部元素。
- `getFront`：获取队列头部元素。
- `getRear`：获取队列尾部元素。

**答案解析：**

- **实现思路：** 使用两个指针`front`和`rear`分别指向队列的头和尾，利用`append`和`pop`操作实现上述功能。

```python
from collections import deque

class MyCircularDeque:
    def __init__(self, k: int):
        self.deque = deque()
        self.k = k

    def insertFront(self, value: int) -> bool:
        if len(self.deque) < self.k:
            self.deque.appendleft(value)
            return True
        return False

    def insertLast(self, value: int) -> bool:
        if len(self.deque) < self.k:
            self.deque.append(value)
            return True
        return False

    def deleteFront(self) -> bool:
        if len(self.deque) > 0:
            self.deque.popleft()
            return True
        return False

    def deleteRear(self) -> bool:
        if len(self.deque) > 0:
            self.deque.pop()
            return True
        return False

    def getFront(self) -> int:
        if len(self.deque) > 0:
            return self.deque[0]
        return -1

    def getRear(self) -> int:
        if len(self.deque) > 0:
            return self.deque[-1]
        return -1
```

### **3. 算法问题：最短子数组长度**

**题目：** 给定一个数组`nums`和一个整数`k`，找到最短的非空子数组，使得子数组的和大于或等于`k`。返回该子数组的长度。如果不存在这样的子数组，返回 `-1`。

**答案解析：**

- **前缀和 + 双指针：** 使用前缀和数组`prefixSum`来计算每个位置到当前位置的和，然后使用双指针法找到最短子数组。

```python
def shortestSubarray(nums, k):
    n = len(nums)
    prefixSum = [0] * (n + 1)
    for i in range(1, n + 1):
        prefixSum[i] = prefixSum[i - 1] + nums[i - 1]
    left, right = 0, 0
    ans = n + 1
    while right < n:
        while prefixSum[right + 1] - prefixSum[left] >= k:
            ans = min(ans, right - left + 1)
            left += 1
        right += 1
    return ans if ans <= n else -1
```

### **4. 算法问题：数组的相对排序**

**题目：** 给定两个整数数组`arr1`和`arr2`，使用这两个数组中的元素，在不改变原来的数组的情况下，对数组`arr1`进行排序，使其满足`arr1`中所有小于`arr2`中对应元素的都排在`arr2`中所有元素的左边。

**答案解析：**

- **计数排序：** 对数组`arr2`中的每个元素进行计数，然后按照计数结果将`arr1`中的元素进行排序。

```python
def relative_sort_array(arr1, arr2):
    count = [0] * (max(arr2) + 1)
    for num in arr2:
        count[num] += 1
    i, j = 0, 0
    while i < len(arr1):
        if count[arr1[i]]:
            arr1[i] = arr2[j]
            j += 1
            count[arr1[i]] -= 1
        else:
            i += 1
    return arr1
```

### **5. 算法问题：合并区间**

**题目：** 给定一个区间列表，合并所有重叠的区间。

**答案解析：**

- **排序 + 合并：** 首先将区间按照起点排序，然后依次合并相邻的区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort()
    res = [intervals[0]]
    for i in range(1, len(intervals)):
        if intervals[i][0] <= res[-1][1]:
            res[-1][1] = max(res[-1][1], intervals[i][1])
        else:
            res.append(intervals[i])
    return res
```

### **6. 算法问题：二进制数位计数**

**题目：** 给定一个非负整数`num`，计算并返回其二进制表示中`1`的个数。

**答案解析：**

- **位操作：** 使用位操作，将数字不断右移，判断每位的值。

```python
def hammingWeight(num):
    count = 0
    while num:
        count += num & 1
        num >>= 1
    return count
```

### **7. 算法问题：最长公共子序列**

**题目：** 给定两个字符串`text1`和`text2`，找出并返回两个字符串的 最长公共子序列。如果不存在公共子序列，返回空字符串。

**答案解析：**

- **动态规划：** 使用二维数组`dp`来存储子问题的解，然后根据`dp`数组的值构建最长公共子序列。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            result.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return ''.join(result[::-1])
```

### **8. 算法问题：字符串压缩**

**题目：** 实现一个字符串压缩方法，将字符串按照一定的规则进行压缩，压缩后的字符串长度不能大于原字符串长度。

**答案解析：**

- **简单压缩：** 对字符串进行遍历，将连续相同字符的数量进行压缩。

```python
def compressString(s):
    if not s:
        return ""
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            compressed.append(s[i - 1] + str(count))
            count = 1
    compressed.append(s[-1] + str(count))
    return ''.join(compressed) if len(''.join(compressed)) < len(s) else s
```

### **9. 算法问题：最长公共前缀**

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**

- **垂直扫描：** 对字符串数组进行垂直扫描，找到所有字符串的最长公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix
```

### **10. 算法问题：缺失的数字**

**题目：** 给定一个包含`0`到`n`中`n`个数的序列，找出0到`n`中不在序列中的那个数。

**答案解析：**

- **排序 + 二分查找：** 对序列进行排序，然后使用二分查找找到缺失的数字。

```python
def missingNumber(nums):
    n = len(nums)
    left, right = 0, n
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == mid:
            left = mid + 1
        else:
            right = mid
    return left
```

### **11. 算法问题：两数之和**

**题目：** 给定一个整数数组`nums`和一个目标值`target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：**

- **暴力法：** 对数组进行遍历，使用双指针找到和为`target`的两个数。

```python
def twoSum(nums, target):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

- **哈希表：** 使用哈希表存储数组中的元素及其索引，快速查找和为`target`的两个数。

```python
def twoSum(nums, target):
    dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in dict:
            return [dict[complement], i]
        dict[num] = i
    return []
```

### **12. 算法问题：环形链表**

**题目：** 给定一个链表，判断是否存在环路。

**答案解析：**

- **快慢指针：** 使用快慢指针法，快指针每次移动两个节点，慢指针每次移动一个节点。如果存在环路，快慢指针最终会相遇。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head):
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### **13. 算法问题：有效的括号字符串**

**题目：** 给定一个字符串`s`，判断`strings`是否是一个有效的括号字符串，即字符串中只含有`()`、`[]`和`{}`，且任意两个相同的括号必须正确闭合。

**答案解析：**

- **栈：** 使用栈来存储遇到的括号，当遇到与之配对的括号时，将其从栈中弹出。

```python
def isValid(s):
    stack = []
    for c in s:
        if c in '({[':
            stack.append(c)
        elif not stack:
            return False
        else:
            top = stack[-1]
            if (c == ')' and top == '(') or (c == '}' and top == '{') or (c == ']' and top == '['):
                stack.pop()
            else:
                return False
    return not stack
```

### **14. 算法问题：有效的数字**

**题目：** 给定一个字符串`s`，判断`s`是否是一个有效的数字。

**答案解析：**

- **状态机：** 使用状态机来解析字符串，根据当前的状态和遇到的字符来判断是否是有效的数字。

```python
def isNumber(s):
    states = [
        {'': ['sign', 'decimal', 'integer', 'exp'], 'sign': ['integer', 'exp'], 'integer': ['decimal', 'exp', 'fraction'], 'decimal': ['fraction', 'exp'], 'exp': ['integer', 'decimal', 'fraction'], 'fraction': ['exp'], 'sign': ['integer', 'exp', 'fraction'], 'decimal': ['fraction', 'exp']},
        {'0': 'integer', '1': 'integer', '2': 'integer', '3': 'integer', '4': 'integer', '5': 'integer', '6': 'integer', '7': 'integer', '8': 'integer', '9': 'integer', '+': 'sign', '-': 'sign', '.': 'decimal'},
        {'0': 'integer', '1': 'integer', '2': 'integer', '3': 'integer', '4': 'integer', '5': 'integer', '6': 'integer', '7': 'integer', '8': 'integer', '9': 'integer'},
        {'0': 'fraction', '1': 'fraction', '2': 'fraction', '3': 'fraction', '4': 'fraction', '5': 'fraction', '6': 'fraction', '7': 'fraction', '8': 'fraction', '9': 'fraction'},
        {'0': 'exp', '1': 'exp', '2': 'exp', '3': 'exp', '4': 'exp', '5': 'exp', '6': 'exp', '7': 'exp', '8': 'exp', '9': 'exp', '+': 'sign', '-': 'sign'},
        {'0': 'fraction', '1': 'fraction', '2': 'fraction', '3': 'fraction', '4': 'fraction', '5': 'fraction', '6': 'fraction', '7': 'fraction', '8': 'fraction', '9': 'fraction'},
        {'0': 'integer', '1': 'integer', '2': 'integer', '3': 'integer', '4': 'integer', '5': 'integer', '6': 'integer', '7': 'integer', '8': 'integer', '9': 'integer'},
    ]
    state = 'integer'
    for c in s:
        if c in states[state]:
            state = states[state][c]
        else:
            return False
    return state in ('integer', 'decimal', 'fraction', 'exp')
```

### **15. 算法问题：反转字符串**

**题目：** 编写一个函数，反转字符串中的所有字母。

**答案解析：**

- **双指针：** 使用双指针法，一个指针指向字符串的头部，另一个指针指向字符串的尾部，然后交换两个指针指向的字符，直到两个指针相遇。

```python
def reverseString(s):
    s = list(s)
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1
    return ''.join(s)
```

### **16. 算法问题：有效的括号**

**题目：** 给定一个字符串`s`，判断`s`是否是一个有效的括号字符串。

**答案解析：**

- **栈：** 使用栈来存储遇到的括号，当遇到与之配对的括号时，将其从栈中弹出。

```python
def isValid(s):
    stack = []
    for c in s:
        if c in '([{':
            stack.append(c)
        elif not stack:
            return False
        else:
            top = stack[-1]
            if (c == ')' and top == '(') or (c == ']' and top == '[') or (c == '}' and top == '{'):
                stack.pop()
            else:
                return False
    return not stack
```

### **17. 算法问题：最小栈**

**题目：** 设计一个支持 push，pop，top 操作的栈，同时还能查询栈的最小元素。

**答案解析：**

- **辅助栈：** 使用一个辅助栈来存储栈中的最小元素。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.minStack or val <= self.minStack[-1]:
            self.minStack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.minStack[-1]:
            self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
```

### **18. 算法问题：爬楼梯**

**题目：** 假设你正在爬楼梯。需要`n`阶楼梯，每次可以爬1或2个台阶，问有多少种不同的方法可以爬到楼顶。

**答案解析：**

- **动态规划：** 使用动态规划，定义状态`f[i]`为到达第`i`阶楼梯的方法数。

```python
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    f = [0] * (n + 1)
    f[1], f[2] = 1, 2
    for i in range(3, n + 1):
        f[i] = f[i - 1] + f[i - 2]
    return f[n]
```

### **19. 算法问题：合并两个有序链表**

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案解析：**

- **递归：** 使用递归，将两个链表的最小节点拼接在一起。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

- **迭代：** 使用迭代，将两个链表的最小节点拼接在一起。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next
        curr.next = list1 or list2
        return dummy.next
```

### **20. 算法问题：零钱兑换**

**题目：** 给定一个数组`coins`表示不同的硬币面额，和一个总金额`amount`，计算最少需要多少枚硬币凑出`amount`。

**答案解析：**

- **动态规划：** 使用动态规划，定义状态`dp[i]`为凑出金额`i`所需的最少硬币数。

```python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return -1 if dp[amount] == float('inf') else dp[amount]
```

### **21. 算法问题：最长公共子序列**

**题目：** 给定两个字符串`s1`和`s2`，找到它们的最长公共子序列。

**答案解析：**

- **动态规划：** 使用动态规划，定义状态`dp[i][j]`为`s1`的前`i`个字符和`s2`的前`j`个字符的最长公共子序列长度。

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

### **22. 算法问题：有效的数字**

**题目：** 判断一个字符串是否是一个有效的数字。

**答案解析：**

- **状态机：** 使用状态机来处理字符串，根据当前的状态和遇到的字符来判断是否是有效的数字。

```python
def isNumber(s):
    states = [
        {'': ['sign', 'decimal', 'integer', 'exp'], 'sign': ['integer', 'exp'], 'integer': ['decimal', 'exp', 'fraction'], 'decimal': ['fraction', 'exp'], 'exp': ['integer', 'decimal', 'fraction'], 'fraction': ['exp'], 'sign': ['integer', 'exp', 'fraction'], 'decimal': ['fraction', 'exp']},
        {'0': 'integer', '1': 'integer', '2': 'integer', '3': 'integer', '4': 'integer', '5': 'integer', '6': 'integer', '7': 'integer', '8': 'integer', '9': 'integer', '+': 'sign', '-': 'sign', '.': 'decimal'},
        {'0': 'integer', '1': 'integer', '2': 'integer', '3': 'integer', '4': 'integer', '5': 'integer', '6': 'integer', '7': 'integer', '8': 'integer', '9': 'integer'},
        {'0': 'fraction', '1': 'fraction', '2': 'fraction', '3': 'fraction', '4': 'fraction', '5': 'fraction', '6': 'fraction', '7': 'fraction', '8': 'fraction', '9': 'fraction'},
        {'0': 'exp', '1': 'exp', '2': 'exp', '3': 'exp', '4': 'exp', '5': 'exp', '6': 'exp', '7': 'exp', '8': 'exp', '9': 'exp', '+': 'sign', '-': 'sign'},
        {'0': 'fraction', '1': 'fraction', '2': 'fraction', '3': 'fraction', '4': 'fraction', '5': 'fraction', '6': 'fraction', '7': 'fraction', '8': 'fraction', '9': 'fraction'},
        {'0': 'integer', '1': 'integer', '2': 'integer', '3': 'integer', '4': 'integer', '5': 'integer', '6': 'integer', '7': 'integer', '8': 'integer', '9': 'integer'},
    ]
    state = 'integer'
    for c in s:
        if c in states[state]:
            state = states[state][c]
        else:
            return False
    return state in ('integer', 'decimal', 'fraction', 'exp')
```

### **23. 算法问题：最长公共前缀**

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**

- **垂直扫描：** 遍历数组中的字符串，找到所有字符串的最长公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix
```

### **24. 算法问题：合并两个有序数组**

**题目：** 给定两个已排序的整数数组`nums1`和`nums2`，将`nums2`合并到`nums1`中，使`nums1`成为一个有序数组。

**答案解析：**

- **双指针：** 从数组的尾部开始，将较大的数放入`nums1`的尾部。

```python
def merge(nums1, m, nums2, n):
    i = m - 1
    j = n - 1
    t = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[t] = nums1[i]
            i -= 1
        else:
            nums1[t] = nums2[j]
            j -= 1
        t -= 1
    while j >= 0:
        nums1[t] = nums2[j]
        t -= 1
        j -= 1
```

### **25. 算法问题：加一**

**题目：** 给定一个整数数组`nums`，其中元素代表一个非负整数，返回一个数组，数组元素表示将原始数加一后的结果。

**答案解析：**

- **遍历数组：** 从数组的尾部开始遍历，如果当前位为9，则将其变为0，并将进位加到下一位。

```python
def plusOne(nums):
    i = len(nums) - 1
    while i >= 0 and nums[i] == 9:
        nums[i] = 0
        i -= 1
    if i < 0:
        nums.insert(0, 1)
        return nums
    nums[i] += 1
    return nums
```

### **26. 算法问题：旋转图像**

**题目：** 给定一个`n x n`的二维矩阵表示一个图像，旋转图像90度。

**答案解析：**

- **四层循环：** 使用四层循环，将矩阵的每一行和每一列进行旋转。

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```

### **27. 算法问题：存在重复元素**

**题目：** 给定一个整数数组`nums`，判断是否存在重复元素。

**答案解析：**

- **哈希表：** 使用哈希表存储数组中的元素，判断是否存在重复元素。

```python
def containsDuplicate(nums):
    s = set()
    for num in nums:
        if num in s:
            return True
        s.add(num)
    return False
```

### **28. 算法问题：最长公共子串**

**题目：** 给定两个字符串`s1`和`s2`，找到它们的最长公共子串。

**答案解析：**

- **动态规划：** 使用动态规划，定义状态`dp[i][j]`为`s1`的前`i`个字符和`s2`的前`j`个字符的最长公共子串长度。

```python
def longestCommonSubstring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_len = max(max_len, dp[i][j])
            else:
                dp[i][j] = 0
    return max_len
```

### **29. 算法问题：两数相加**

**题目：** 给定两个非空链表表示的两个非负整数，分别位于链表的头节点和尾节点，计算它们的和，并以链表的形式返回结果。

**答案解析：**

- **模拟加法：** 从链表的头节点开始，依次计算每一位的和，处理进位。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            sum = val1 + val2 + carry
            carry = sum // 10
            curr.next = ListNode(sum % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

### **30. 算法问题：删除链表的节点**

**题目：** 给定一个链表和一个节点`target`，删除`target`节点。

**答案解析：**

- **模拟删除：** 如果`target`节点不是链表的尾节点，将`target`节点的下一个节点的值赋给`target`节点，然后删除`target`节点的下一个节点。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```

