
作者：禅与计算机程序设计艺术                    
                
                
## 一句话概括：如何在一个队列上进行动态规划？——从动态规划到最长递增子序列
## 概述：动态规划(Dynamic Programming)是一种非常重要的算法思想，它被广泛应用于许多领域，如经济、金融、股市、图论等。现实生活中，很多时候，动态规划都可以帮助我们解决一些实际问题。比如，当我们考虑一个家庭住房问题时，假设有多个住房选项，需要选定一个最佳方案；当我们在选择一批办公室区域时，我们也希望能够找到一个合适的布局方案，以达到最大化工作效率；当我们制定出行路线时，如果出现了交通拥堵，我们也要利用动态规划来优化路径选择。那么，如何在一个队列上进行动态规划呢？本文将分享一些经典的动态规划算法，如背包问题、最长回文子串、最长递增子序列，并着重介绍“队列”这一数据结构上的应用。



# 2.基本概念术语说明
## 1.队列（Queue）
队列是一种特殊的线性表，它只允许在表的一端进行插入操作，而在另一端进行删除操作，先进先出的原则。队列的插入操作称为入队(enqueue)，删除操作称为出队(dequeue)。在对队列进行操作时，只能访问队头元素，队尾元素不能被直接访问。
## 2.动态规划（Dynamic Programming）
动态规划是指在满足资源限制条件下，通过定义子问题，以便避免重复计算，从而解决复杂问题的方法。动态规划是指用自底向上的方法解决问题，即首先考虑最简单的情况，然后逐步推导出其余可能的情况。通过分析子问题之间的关系，动态规划可以把复杂的问题分解成简单的子问题，并利用已解决的子问题的解来求解复杂问题。
## 3.最长回文子串（Longest Palindromic Substring）
给定一个字符串，找出其中最长的回文子串。例如，输入："babad"，输出："bab"或者"aba"。
## 4.最长递增子序列（LIS）
给定一个无序整数数组，找到其中最长递增子序列的长度。例如，输入：[10,9,2,5,3,7,101,18],输出：4，表示最长递增子序列为[2,3,7,101]。

以上四个问题都是动态规划算法的经典问题，本文将详细讨论。





# 3.核心算法原理和具体操作步骤以及数学公式讲解


# （1）最长回文子串问题
## 描述
给定一个字符串，找出其中最长的回文子串。例如，输入："babad"，输出："bab"或者"aba"。
## 定义
### 动态规划问题一般具有三个要素：
- 状态变量：要用数组来存储子问题的解，所以状态变量就是dp数组。
- 决策变量：在每个子问题中，我们至少需要比较两个字符才能判断它们是否构成回文，因此决策变量是当前位置左右两边的字符。
- 子问题：由于最长回文字串问题中，每一个子问题只和前面两个子问题相关，因此可以用滚动数组的方式来优化空间。

### 策略
#### (1) 贪心法
维护一个列表max_palindromes，记录所有符合要求的回文子串及其对应的起始索引，然后遍历整个字符串s，对于每个索引i，尝试将其作为中心点，查找其对应的回文串。
```python
def longestPalindrome(self, s: str) -> str:
    n = len(s)
    if n < 2 or all(s[i] == s[i+1] for i in range(n-1)):
        return s

    max_len = 1
    start = 0
    end = 1
    
    while end < n:
        if s[start:end+1] == s[start:end+1][::-1]:
            if end - start + 1 > max_len:
                max_len = end - start + 1
                res = s[start:end+1]
        
        elif s[start:end+1][:-1] == s[start:end+1][:-1][::-1]: # consider odd palindrome with even length substrings as valid ones
            if end - start + 1 >= max_len and all((s[k]!= s[k-1] for k in range(start+1, end))):
                max_len = end - start + 1
                res = s[start:end+1]
                
        else:
            start += 1

        end += 1
        
    return res
``` 

#### (2) Manacher’s Algorithm
Manacher's algorithm是由W.C.Johnson提出的算法，它的主要思想是把一个字符串变成一个奇偶形式的类似于Z字形的形式，这样可以简化求解过程，提高时间复杂度。其特点是时间复杂度O(n)，且返回结果比标准的O(n^2)算法更加优秀。

我们可以看一下这个算法的具体步骤：
1. 在字符串的两边各添加一个特定的字符，使得字符串长度变为奇数
2. 初始化dp数组，其第i项表示字符串的第i个位置的最大回文半径
3. 从第2项开始往后遍历，根据当前位置的最大回文半径，判断第i+1项的最大回文半径应该是多少。
    - 如果i和i+1之间只有1个字符，则最大回文半径为3
    - 如果i和i+1之间有多个字符，则最大回文半径为max(dp[i], dp[j])，其中0<=j<i，且dp[j]+2>=i-(j+1)+1，表示i到j之间形成的回文串的中心的下标应该在i的左侧，这样就形成了一个相邻的Z字形
4. 返回字符串的第一个和最后一个位置，在这两个位置之间即可得到最长的回文子串

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        t = '#' + '#'.join(s) + '#'
        
        p, mxr, cen = [0]*n, 0, 0
        
        for i in range(n):
            ri, lev = i+mxr, 0
            
            while t[ri-lev]==t[ri+lev]:
                lev += 1
                
            p[i] = lev
            mxr = max(mxr, p[i]-1)
            if mxr>p[cen]:
                cen = i
        
        max_palin = ""
        left, right = 0, 0
        for i in range(n):
            mid = cen + p[i]
            if p[i] > 1 and mid-left <= right-mid:
                continue
            j = min(mid-left, right-mid)
            while i-j>-1 and i+j<n and t[i-j]==t[i+j]:
                j -= 1
            p[i] = j
            max_palin = max(max_palin, s[i-j+1:i+j])
            
        return max_palin
``` 


# （2）最长递增子序列问题
## 描述
给定一个无序整数数组，找到其中最长递增子序列的长度。例如，输入：[10,9,2,5,3,7,101,18],输出：4，表示最长递增子序列为[2,3,7,101]。

## 定义
### 动态规划问题一般具有三个要素：
- 状态变量：要用数组来存储子问题的解，所以状态变量就是dp数组。
- 决策变量：在每个子问题中，我们至少需要考虑三种情况，即当前元素与之前元素的关系：小于、等于或大于之前元素；所以决策变量是当前元素与之前元素的关系。
- 子问题：最长递增子序列问题的每个子问题都和前面两个子问题相关，因此可以用滚动数组的方式来优化空间。

### 策略
#### 贪心法
维护一个列表max_subseq，记录所有最长递增子序列及其对应的起始索引，然后遍历整个数组nums，对于每个索引i，尝试将其加入到之前的所有最长递增子序列中，检查该元素与之前的哪些元素构成的子序列是最长的。
```python
def lengthOfLIS(self, nums: List[int]) -> int:
    n = len(nums)
    if not nums:
        return 0

    max_len = 1
    last_idx = {0 : -float('inf')}
    stack = []

    for i in range(n):
        curr = nums[i]

        idx = bisect_right(stack, curr)
        if idx == len(stack):
            stack.append(curr)
        else:
            stack[idx] = curr

        lis_len = idx+1
        if lis_len > max_len:
            max_len = lis_len
            res = set()
            prev = float('-inf')

            for elem in stack[:idx+1]:
                res.add(elem)
                
                diff = elem - prev
                if diff > 0:
                    res.discard(prev)

                prev = elem
            
            for elem in reversed(stack):
                if elem not in res:
                    break
            
            if elem > stack[-1]:
                res.remove(elem)
                res.add(stack[-1])
            
            res = list(res)[::-1]

        last_idx[lis_len] = i
            
    return len(res)
``` 

#### 二叉搜索树
维护一个二叉搜索树，树节点值存储数组的下标，二叉搜索树的键值是数组的值。为了快速查找某个值的最大连续递增子序列的长度，我们可以在二叉搜索树中搜索该值，因为树节点的值按数组下标的顺序排序。如果搜索成功，则当前节点对应的值肯定存在某条最长递增子序列，否则的话，说明该值一定不属于任何最长递增子序列，此时就可以跳过该节点。
```python
def lengthOfLIS(self, nums: List[int]) -> int:
    TREE_LEAF = 0

    class TreeNode:
        def __init__(self, val=None, left=TREE_LEAF, right=TREE_LEAF):
            self.val = val
            self.left = left
            self.right = right
    
    def insert(root, node, parent, val):
        if root is None:
            return node
        
        cmp_res = val - root.val
        
        if cmp_res == 0:
            return root
        
        if cmp_res < 0:
            new_node = TreeNode(parent=parent, val=val, left=node)
            node.parent = new_node
            node = new_node
        else:
            child = root.right if root.right else TreeNode(parent=root, val=-float('inf'))
            root.right = insert(child, node, root, val)
        
        balance_factor = get_balance_factor(root)
        
        if balance_factor > 1:
            right_child = root.right
            if get_balance_factor(right_child) < 0:
                root.right = rotate_right(right_child)
            root = rotate_left(root)
        
        if balance_factor < -1:
            left_child = root.left
            if get_balance_factor(left_child) > 0:
                root.left = rotate_left(left_child)
            root = rotate_right(root)
        
        return root
    
    
    def search(root, key):
        curr = root
        
        while True:
            if curr is None:
                return None
            
            cmp_res = key - curr.val
            
            if cmp_res == 0:
                return curr
            
            if cmp_res < 0:
                curr = curr.left
            else:
                curr = curr.right
                
    
    def get_length(node):
        if node is None:
            return 0
        
        return node._length
    

    def update_length(node):
        node._length = get_length(node.left) + get_length(node.right) + 1


    def traverse(root, depth=0):
        global lengths
        
        if root is None:
            return
        
        traverse(root.right, depth+1)
        print('   '* depth + f'{lengths[root.val]}', end=' ')
        traverse(root.left, depth+1)
        

    def build_tree(values):
        root = None
        
        for value in values:
            root = insert(root, TreeNode(), TREE_LEAF, value)
        
        return root

    
    def find_insert_pos(root, target):
        """Find the position to insert a new node whose value is equal to or greater than `target`"""
        parent = None
        curr = root
        
        while True:
            if curr is None:
                return parent
            
            cmp_res = target - curr.val
            
            if cmp_res == 0:
                return curr
            
            if cmp_res < 0:
                parent = curr
                curr = curr.left
            else:
                curr = curr.right
            

    def make_list():
        lst = []
        
        for index in sorted(last_idx.keys()):
            pos = last_idx[index]
            lst.extend([arr[pos]]*(index-lst.count(arr[pos])))
        
        return lst

    
    arr = nums[:]
    N = len(arr)
    tree = build_tree(range(N))
    result = {}
    lengths = [-1]*N
    
    for num in arr:
        node = search(tree, num)
        
        if node is None:
            pass
        elif node.val == num:
            prefix_sum = get_length(node.parent.left)
            key = prefix_sum - abs(num-prefix_sum)%abs(num)
            seq_len = result.get(key, 0)
            seq_len += abs(num-last_idx[result.get(key, 0)]-1)
            seq_len = max(seq_len, get_length(node.parent)-1)
            result[key] = seq_len
            last_idx[seq_len] = find_insert_pos(tree, num).val
        else:
            node = node.parent
            key = get_length(node.right)
            seq_len = result.get(key, 0)
            seq_len += abs(num-last_idx[result.get(key, 0)])
            seq_len = max(seq_len, get_length(node.left)-1)
            result[key] = seq_len
            last_idx[seq_len] = find_insert_pos(tree, num).val
        
        update_length(node)
    
    keys = sorted(result.keys())
    lengths = [(result[key] if key in result else 0) for key in keys]
    
    root = build_tree(make_list()[::-1])[::-1]
    temp_dict = dict(zip(sorted(set(arr)), [TreeNode(-1*key,-1*result.get(key, 0),-1*result.get(key, 0)) for key in keys]))
    for key in temp_dict:
        temp_dict[key].val *= -1
    
    traversal = []
    node = root
    level = 0
    
    while node is not None or level < len(traversal):
        if node is None:
            if level < len(traversal):
                node = traversal[level]
            else:
                node = TreeNode(-1, -1, -1)
        else:
            traversal.append(node)
            node = node.right
            
        level += 1
        
        while level < len(traversal):
            temp = traversal.pop()
            parent = traversal[-1]
            side = 'right' if temp.parent.left==temp else 'left'
            setattr(parent, side, getattr(parent,side)._replace(**{temp.val:getattr(temp,'_' + temp.val)}))
            delattr(temp,'_'+temp.val)
            node = temp
    
    reverse_traversal = traversal[::-1]
    final_sequence = []
    
    for node in reverse_traversal[:-1]:
        final_sequence.append(temp_dict[abs(node.val)].val)
    
    return sum(final_sequence)

