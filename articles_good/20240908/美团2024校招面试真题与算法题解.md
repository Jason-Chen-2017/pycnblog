                 

### 美团2024校招面试真题与算法题解：排序算法

#### 1. 快速排序（Quick Sort）

**题目：** 实现快速排序算法，并分析其时间复杂度。

**答案：**

```go
package main

import "fmt"

func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }
    pivot := arr[len(arr)/2]
    left, right := 0, len(arr)-1

    for i := 0; i <= right; i++ {
        if arr[i] < pivot {
            arr[left], arr[i] = arr[i], arr[left]
            left++
        } else if arr[i] > pivot {
            arr[right], arr[i] = arr[i], arr[right]
            right--
            i--
        }
    }

    quickSort(arr[:left])
    quickSort(arr[left+1:])
}

func main() {
    arr := []int{5, 2, 9, 1, 5, 6}
    quickSort(arr)
    fmt.Println(arr)
}
```

**解析：** 快速排序的基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的键值比另一部分的所有记录的键值都要小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。时间复杂度平均情况下为 \(O(n\log n)\)，最坏情况下为 \(O(n^2)\)。

#### 2. 归并排序（Merge Sort）

**题目：** 实现归并排序算法，并分析其时间复杂度。

**答案：**

```go
package main

import "fmt"

func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}

func main() {
    arr := []int{5, 2, 9, 1, 5, 6}
    sortedArr := mergeSort(arr)
    fmt.Println(sortedArr)
}
```

**解析：** 归并排序的基本思想是将待排序的序列不断分割成大小为 1 的子序列，然后将这些子序列两两归并，每次归并产生一个长度为 2 的有序序列，再归并这些序列，直至整个序列有序。时间复杂度为 \(O(n\log n)\)。

#### 3. 堆排序（Heap Sort）

**题目：** 实现堆排序算法，并分析其时间复杂度。

**答案：**

```go
package main

import "fmt"

func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func heapSort(arr []int) {
    n := len(arr)

    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func main() {
    arr := []int{5, 2, 9, 1, 5, 6}
    heapSort(arr)
    fmt.Println(arr)
}
```

**解析：** 堆排序的基本思想是将待排序序列构造成一个最大堆（或最小堆），然后逐步删除堆顶元素（最大或最小元素），并重新调整堆，直至整个序列有序。时间复杂度为 \(O(n\log n)\)。

#### 4. 冒泡排序（Bubble Sort）

**题目：** 实现冒泡排序算法，并分析其时间复杂度。

**答案：**

```go
package main

import "fmt"

func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func main() {
    arr := []int{5, 2, 9, 1, 5, 6}
    bubbleSort(arr)
    fmt.Println(arr)
}
```

**解析：** 冒泡排序的基本思想是通过不断比较相邻的元素并交换，使得较大的元素逐渐“冒泡”到序列的末尾。时间复杂度为 \(O(n^2)\)。

#### 5. 插入排序（Insertion Sort）

**题目：** 实现插入排序算法，并分析其时间复杂度。

**答案：**

```go
package main

import "fmt"

func insertionSort(arr []int) {
    for i := 1; i < len(arr); i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j + 1] = arr[j]
            j--
        }
        arr[j + 1] = key
    }
}

func main() {
    arr := []int{5, 2, 9, 1, 5, 6}
    insertionSort(arr)
    fmt.Println(arr)
}
```

**解析：** 插入排序的基本思想是将一个元素插入到已经有序的序列中，保持序列有序。时间复杂度为 \(O(n^2)\)。

### 总结

排序算法是面试中高频出现的算法题，掌握各种排序算法的原理、实现和优缺点，有助于应对不同的场景需求。以上五种排序算法各有特点，适用于不同场景。快速排序和归并排序的时间复杂度较低，但快速排序在最坏情况下可能退化成 \(O(n^2)\)，归并排序则需要额外的空间。堆排序适合大规模数据排序，而冒泡排序和插入排序适用于数据量较小的情况。在实际开发中，可以根据具体需求选择合适的排序算法。


### 题目解析

1. **时间复杂度分析：** 排序算法的时间复杂度主要取决于数据量和排序过程。快速排序和归并排序的平均时间复杂度为 \(O(n\log n)\)，但快速排序在最坏情况下可能退化成 \(O(n^2)\)。堆排序适用于大规模数据排序，时间复杂度为 \(O(n\log n)\)。冒泡排序和插入排序的时间复杂度为 \(O(n^2)\)，适合数据量较小的情况。

2. **空间复杂度：** 快速排序和归并排序的空间复杂度较低，分别为 \(O(\log n)\) 和 \(O(n)\)。堆排序的空间复杂度为 \(O(1)\)。冒泡排序和插入排序的空间复杂度为 \(O(1)\)。

3. **稳定性：** 稳定性指排序过程中相等元素的相对顺序是否保持不变。快速排序和堆排序是不稳定的排序算法，而归并排序和冒泡排序是稳定的排序算法。

4. **适用场景：** 快速排序适用于数据量较大且基本有序的情况，归并排序适用于大规模数据排序，堆排序适用于大规模数据排序且不需要原地排序的情况，冒泡排序和插入排序适用于数据量较小的情况。

### 源代码实例

以下是五种排序算法的源代码实例，包括快速排序、归并排序、堆排序、冒泡排序和插入排序。

```go
package main

import "fmt"

// 快速排序
func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }
    pivot := arr[len(arr)/2]
    left, right := 0, len(arr)-1

    for i := 0; i <= right; i++ {
        if arr[i] < pivot {
            arr[left], arr[i] = arr[i], arr[left]
            left++
        } else if arr[i] > pivot {
            arr[right], arr[i] = arr[i], arr[right]
            right--
            i--
        }
    }

    quickSort(arr[:left])
    quickSort(arr[left+1:])
}

// 归并排序
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}

// 堆排序
func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func heapSort(arr []int) {
    n := len(arr)

    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

// 冒泡排序
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

// 插入排序
func insertionSort(arr []int) {
    for i := 1; i < len(arr); i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j + 1] = arr[j]
            j--
        }
        arr[j + 1] = key
    }
}

func main() {
    arr := []int{5, 2, 9, 1, 5, 6}
    quickSort(arr)
    fmt.Println("Quick Sort:", arr)

    sortedArr := mergeSort(arr)
    fmt.Println("Merge Sort:", sortedArr)

    heapSort(arr)
    fmt.Println("Heap Sort:", arr)

    bubbleSort(arr)
    fmt.Println("Bubble Sort:", arr)

    insertionSort(arr)
    fmt.Println("Insertion Sort:", arr)
}
```

通过以上代码实例，可以深入了解各种排序算法的实现和性能特点。在实际开发中，可以根据需求选择合适的排序算法，以提高数据处理的效率和性能。

