                 

### 小米社招面试算法题库大全

以下是根据2024年小米社招面试算法题库整理的典型面试题及答案解析。这些题目涵盖了常见的编程和算法问题，旨在帮助准备面试的候选人。

#### 1. 单词搜索 II

**题目：** 给定一个二维网格和一个单词列表，找出网格中的所有单词且单词可以从任意方向（水平或垂直）开始或结束。每个单词只会出现在网格中一次。

**示例：**
```
grid =
[
  ['o', 'a', 'a', 'n'],
  ['e', 't', 'a', 'e'],
  ['i', 'h', 'k', 'r'],
  ['i', 'f', 'l', 'v']
]

words = ["oath", "pea", "eat", "rain"]
```

**答案：**
```go
var findWords = func(board [][]byte, words []string) []string {
    var dfs func(i, j, k int) bool
    dfs = func(i, j, k int) bool {
        if k == len(words) {
            return true
        }
        if (i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] != words[k][0]) {
            return false
        }
        t := board[i][j]
        board[i][j] = '#'
        defer board[i][j] = t

        if dfs(i+1, j, k+1) || dfs(i-1, j, k+1) || dfs(i, j+1, k+1) || dfs(i, j-1, k+1) {
            return true
        }
        return false
    }

    var ans []string
    for _, w := range words {
        for i := range board {
            for j := range board[0] {
                if dfs(i, j, 0) {
                    ans = append(ans, w)
                    break
                }
            }
        }
    }
    return ans
}
```

**解析：** 该题使用深度优先搜索（DFS）在二维网格中查找单词。递归调用`dfs`函数来遍历网格，并在找到单词时将其添加到答案数组中。

#### 2. 有效的数独

**题目：** 判断一个 9x9 的数独是否有效。只需要根据以下规则，依次填充数字 1-9：

- 每行必须包含 1-9 的所有数字
- 每列必须包含 1-9 的所有数字
- 每个以粗实线分隔的 3x3 宫内必须包含 1-9 的所有数字

**示例：**
```
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
```

**答案：**
```go
var isValidSudoku = func(board [][]byte) bool {
    rows, cols := 9, 9
    row := make([]map[byte]bool, rows)
    col := make([]map[byte]bool, cols)
    block := make([]map[byte]bool, rows/3)
    for i, row := range board {
        for j, v := range row {
            if v == '.' {
                continue
            }
            r, c := i/3, j/3
            if i < 3 {
                if _, ok := row[j]; ok {
                    return false
                }
            }
            if j < 3 {
                if _, ok := col[j]; ok {
                    return false
                }
            }
            if _, ok := block[r]; !ok {
                block[r] = make(map[byte]bool)
            }
            if _, ok := block[r][v]; ok {
                return false
            }
            row[i] = append(row[i], v)
            col[j] = append(col[j], v)
            block[r] = append(block[r], v)
        }
    }
    return true
}
```

**解析：** 该题使用三个二维映射来分别存储行、列和块的数字。遍历数独矩阵，将每个数字添加到相应的映射中，并在发现重复时返回`false`。

#### 3. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    var dummy *ListNode
    pre := &ListNode{-1, nil}
    dummy = pre
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            pre.Next = list1
            list1 = list1.Next
        } else {
            pre.Next = list2
            list2 = list2.Next
        }
        pre = pre.Next
    }
    if list1 != nil {
        pre.Next = list1
    } else {
        pre.Next = list2
    }
    return dummy.Next
}
```

**解析：** 该题使用一个哑节点作为合并后的链表的头节点，并使用一个pre指针来始终指向最后一个已添加的节点。遍历两个链表，将较小的节点添加到pre的下一个节点，并更新pre指针。

#### 4. 寻找旋转排序数组中的最小值

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例：**
```
nums = [4,5,6,7,0,1,2]
```

**答案：**
```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        m := (l + r) / 2
        if nums[m] > nums[r] {
            l = m + 1
        } else {
            r = m
        }
    }
    return nums[l]
}
```

**解析：** 该题使用二分查找来找到旋转数组中的最小值。如果中间值大于最右边的值，则最小值在右侧，否则在左侧。

#### 5. 两数相加

**题目：** 给出两个 非空 的链表表示两个非负的整数，每个节点包含一个数字。需要将这两个数相加并返回一个新的链表。

**示例：**
```
l1 = [2,4,3]
l2 = [5,6,4]
```

**答案：**
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    cur := &ListNode{0, nil}
    dummy = cur
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        cur.Val = (val1 + val2 + carry) % 10
        carry = (val1 + val2 + carry) / 10
        cur.Next = &ListNode{0, nil}
        cur = cur.Next
    }
    return dummy.Next
}
```

**解析：** 该题使用一个哑节点作为新链表的头节点，并使用一个当前节点指针来添加新节点。遍历两个链表，计算每个节点的和以及进位。

#### 6. 无重复字符的最长子串

**题目：** 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

**示例：**
```
s = "abcabcbb"
```

**答案：**
```go
func lengthOfLongestSubstring(s string) int {
    m := map[rune]int{}
    i, j := 0, 0
    ans := 0
    for j < len(s) {
        if v, ok := m[s[j]]; ok {
            i = max(i, v+1)
        }
        m[s[j]] = j
        ans = max(ans, j-i+1)
        j++
    }
    return ans
}
```

**解析：** 该题使用双指针和哈希表来实现滑动窗口。移动右指针`j`并更新哈希表，当发现重复字符时，移动左指针`i`。

#### 7. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
strs = ["flower","flow","flight"]
```

**答案：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, s := range strs {
        for i := 0; i < len(prefix) && i < len(s); i++ {
            if prefix[i] != s[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 该题使用字符串遍历和比较，找到所有字符串的公共前缀。

#### 8. 盗贼不能偷相邻的房子

**题目：** 一个专业的盗贼计划偷窃一排房子，其中每所房子装有报警系统。若盗贼同时偷窃两所相邻的房子，系统将会自动报警。计算盗贼最多能偷窃多少价值的财物。

**示例：**
```
houseValues = [1,2,3,1]
```

**答案：**
```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}
```

**解析：** 该题使用动态规划来解决。状态转移方程为`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。

#### 9. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。新的链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 10. 三数之和

**题目：** 给你一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值 `target` 的三个整数，并返回这三个数的下标。不唯一。

**示例：**
```
nums = [-1,0,1,2,-1,-4], target = 0
```

**答案：**
```go
func threeSum(nums []int) [][]int {
    var (
        ans     [][]int
        n       = len(nums)
        first, second
    )
    sort.Ints(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum < 0 {
                left++
            } else if sum > 0 {
                right--
            } else {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            }
        }
    }
    return ans
}
```

**解析：** 该题使用双指针方法在已排序的数组中查找三数之和等于目标值。固定第一个数，并使用两个指针从第二个数和第三个数开始搜索。

#### 11. 打家劫舍 II

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋，窃取的金额为每个房屋的金额。每间房屋只能偷窃一次，相邻的房屋装有相互连通的报警系统。

**示例：**
```
nums = [2,7,9,3,1]
```

**答案：**
```go
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    if len(nums) == 2 {
        return max(nums[0], nums[1])
    }
    f := func(nums []int) int {
        if len(nums) == 0 {
            return 0
        }
        if len(nums) == 1 {
            return nums[0]
        }
        return max(nums[0]+nums[2], nums[1])
    }
    return max(f(nums[:len(nums)-1]), f(nums[1:]))
}
```

**解析：** 该题使用动态规划解决。考虑两个情况，包含第一个房子和不包含第一个房子。

#### 12. 反转链表

**题目：** 反转一个单链表。

**示例：**
```
head = [1,2,3,4,5]
```

**答案：**
```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}
```

**解析：** 该题使用迭代方法反转链表，每次循环更新三个指针：当前节点、前一个节点和下一个节点。

#### 13. 二进制求和

**题目：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**
```
a = "11"
b = "1"
```

**答案：**
```go
func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    ans := []byte{}
    for i >= 0 || j >= 0 || carry > 0 {
        v := carry
        if i >= 0 {
            v += int(a[i] - '0')
            i--
        }
        if j >= 0 {
            v += int(b[j] - '0')
            j--
        }
        ans = append(ans, byte(v%2 + '0'))
        carry = v / 2
    }
    return string(ans)
}
```

**解析：** 该题使用迭代方法计算两个二进制数的和。每次循环计算进位和当前位，并将当前位添加到结果中。

#### 14. 删除链表的节点

**题目：** 删除链表中某个节点，您只能访问给定的节点。

**示例：**
```
head = [4,5,1,9]
pos = 5
```

**答案：**
```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**解析：** 该题将给定节点的值设置为下一个节点的值，并将下一个节点指向下一个节点的下一个节点，从而删除了给定节点。

#### 15. 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**示例：**
```
text1 = "abcde"
text2 = "ace"
```

**答案：**
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 该题使用动态规划计算最长公共子序列。状态转移方程为`dp[i][j] = dp[i-1][j-1] + 1`（如果当前字符相同）或`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（如果当前字符不同）。

#### 16. 二叉树的直径

**题目：** 给定一棵二叉树，求它的最大直径。树的直径是任意两个结点路径上的边数最大值。

**示例：**
```
    1
   / \
  2   3
 / \ 
4   5
```

**答案：**
```go
var maxDIameter int

func diameterOfBinaryTree(root *TreeNode) int {
    dfs(root)
    return maxDIameter
}

func dfs(root *TreeNode) int {
    if root == nil {
        return 0
    }
    left, right := dfs(root.Left), dfs(root.Right)
    maxDIameter = max(maxDIameter, left+right)
    return max(left, right) + 1
}
```

**解析：** 该题使用递归遍历二叉树，计算每个节点的左右子树的高度，并更新最大直径。

#### 17. 有效的括号字符串

**题目：** 给定一个只包含 '('、')' 和 '*' 的字符串，验证是否有效。

**示例：**
```
s = "(()*)()"
```

**答案：**
```go
func isValid(s string) bool {
    star := -1
    left := 0
    for i, v := range s {
        if v == '(' {
            left++
        } else if v == ')' {
            if star >= 0 {
                star--
            } else {
                left--
            }
        } else if v == '*' {
            if left > 0 {
                star++
            } else {
                star = -1
            }
        }
        if left < 0 {
            return false
        }
    }
    return left == 0 && star == 0
}
```

**解析：** 该题使用一个计数器`left`来跟踪未匹配的左括号，一个指针`star`来跟踪`*`的使用。当`*`与未匹配的左括号相邻时，它可以替代一个左括号。

#### 18. 寻找旋转排序数组中的最小值

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例：**
```
nums = [4,5,6,7,0,1,2]
```

**答案：**
```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 该题使用二分查找找到旋转点的位置，从而找到最小值。

#### 19. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**示例：**
```
tokens = ["2","1","+","3","*"]
```

**答案：**
```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            stack = append(stack, stack[len(stack)-2]+stack[len(stack)-1])
        case "-":
            stack = append(stack, stack[len(stack)-2]-stack[len(stack)-1])
        case "*":
            stack = append(stack, stack[len(stack)-2]*stack[len(stack)-1])
        case "/":
            stack = append(stack, stack[len(stack)-2]/stack[len(stack)-1])
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

**解析：** 该题使用栈来模拟逆波兰表达式的求值过程，按照操作符的优先级进行计算。

#### 20. 有效的括号字符串

**题目：** 判断字符串是否有效，字符串只包含 '('、')' 和 '*'。

**示例：**
```
s = "(()*)()"
```

**答案：**
```go
func isValid(s string) bool {
    star := -1
    left := 0
    for i, v := range s {
        if v == '(' {
            left++
        } else if v == ')' {
            if star >= 0 {
                star--
            } else {
                left--
            }
        } else if v == '*' {
            if left > 0 {
                star++
            } else {
                star = -1
            }
        }
        if left < 0 {
            return false
        }
    }
    return left == 0 && star == 0
}
```

**解析：** 该题使用一个计数器`left`来跟踪未匹配的左括号，一个指针`star`来跟踪`*`的使用。

#### 21. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 22. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 23. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 24. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 25. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 26. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 27. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 28. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 29. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

#### 30. 合并两个有序链表

**题目：** 给定两个排序链表，将两个链表合并为一个新的有序链表并返回。

**示例：**
```
l1: 1->3->4
l2: 2->6
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该题使用递归合并两个链表，如果第一个链表的当前节点值小于第二个链表的当前节点值，则将第二个链表连接到第一个链表的下一个节点，反之亦然。

