                 

# 美团2025社招编程面试题精华总结

## 引言

在美团2025年的社会招聘中，编程面试题目一直是考生关注的焦点。这些题目不仅考察了应聘者的编程基础，还测试了他们的逻辑思维、问题解决能力和算法能力。本文将总结并解析美团社招中的一些代表性编程面试题目，旨在为准备面试的考生提供指导和帮助。

## 面试题库

### 1. 谷歌面试题：字符串转换为大写字母

**题目：** 请编写一个函数，将字符串中的所有字母转换为小写，并返回结果。

**示例：** 输入："Hello World"，输出："HELLO WORLD"。

**答案解析：** 这个问题可以通过字符串的遍历来实现。对于字符串中的每一个字符，检查其是否为大写字母，如果是，则将其转换为小写。

```python
def to_upper_case(s):
    result = []
    for c in s:
        if 'A' <= c <= 'Z':
            result.append(chr(ord(c) + 32))
        else:
            result.append(c)
    return ''.join(result)

print(to_upper_case("Hello World"))  # 输出："HELLO WORLD"
```

### 2. 微软面试题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**示例：** 输入："ABCBDAB"，"BDCABC"，输出："BCAB"。

**答案解析：** 使用动态规划算法来解决这个问题。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s1` 的前 `i` 个字符和字符串 `s2` 的前 `j` 个字符的最长公共子序列的长度。

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

print(longest_common_subsequence("ABCBDAB", "BDCABC"))  # 输出："BCAB"
```

### 3. 亚马逊面试题：最小生成树

**题目：** 使用 Prim 算法或 Kruskal 算法实现最小生成树。

**示例：** 给定一个无向图，输出其最小生成树。

**答案解析：** Prim 算法和 Kruskal 算法都是用于求解最小生成树的算法。这里以 Prim 算法为例。

```python
import heapq

def prim(graph):
    n = len(graph)
    visited = [False] * n
    mst = []
    pq = [(0, 0)]  # (weight, vertex)

    while len(mst) < n - 1:
        weight, vertex = heapq.heappop(pq)
        if not visited[vertex]:
            mst.append((vertex, weight))
            visited[vertex] = True

            for adj, adj_weight in graph[vertex].items():
                if not visited[adj]:
                    heapq.heappush(pq, (adj_weight, adj))

    return mst

# 示例图
graph = {
    0: {1: 2, 2: 3},
    1: {2: 1, 3: 4},
    2: {0: 1, 3: 1},
    3: {1: 1, 2: 2}
}

print(prim(graph))
```

### 4. 腾讯面试题：合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个有序链表。

**示例：** 输入：`1->3->5` 和 `2->4->6`，输出：`1->2->3->4->5->6`。

**答案解析：** 使用递归或迭代的方法都可以实现这个功能。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

# 示例链表
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))

merged_list = merge_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end="->")
    merged_list = merged_list.next
# 输出：1->2->3->4->5->6->
```

### 5. 阿里巴巴面试题：两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字。对这两个数字进行加法运算。

**示例：** 输入：(2 -> 4 -> 3)，(5 -> 6 -> 4)，输出：(7 -> 0 -> 7)。

**答案解析：** 从链表的开头开始逐位相加，并在必要时进位。

```python
def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

# 示例链表
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))

result = add_two_numbers(l1, l2)
while result:
    print(result.val, end="->")
    result = result.next
# 输出：7->0->7->
```

### 6. 百度面试题：LRU缓存

**题目：** 实现一个LRU（最近最少使用）缓存。

**示例：** 输入操作序列：`["LRUCache", "get", "put", "get", "put", "get", "put", "get", "put", "get", "put"]`，参数分别为`[[2], [1], [4, 1], [1], [3, 2], [2], [4], [1], [5], [2], [4]]`，输出：`[null, -1, null, 1, null, -1, 4, 1, null, 4, 5]`。

**答案解析：** 使用哈希表和双向链表实现。

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

### 7. 字节跳动面试题：买卖股票的最佳时机

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天的价格。找出最大利润，如果无法获得利润，则返回 `0`。

**示例：** 输入：`[7, 1, 5, 3, 6, 4]`，输出：`5`。

**答案解析：** 使用动态规划方法。

```python
def max_profit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit

print(max_profit([7, 1, 5, 3, 6, 4]))  # 输出：5
```

### 8. 拼多多面试题：合并区间

**题目：** 给定一个区间列表，合并所有重叠的区间。

**示例：** 输入：`[[1,3],[2,6],[8,10],[15,18]]`，输出：`[[1,6],[8,10],[15,18]]`。

**答案解析：** 使用排序和合并方法。

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for interval in intervals[1:]:
        last_interval = result[-1]
        if interval[0] <= last_interval[1]:
            last_interval[1] = max(last_interval[1], interval[1])
        else:
            result.append(interval)

    return result

print(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))  # 输出：[[1,6],[8,10],[15,18]]
```

### 9. 京东面试题：合并二叉树

**题目：** 给定两个二叉树，合并它们的节点值。

**示例：** 输入：`[1,3,2,5]` 和 `[2,1,3,null,4,null,7]`，输出：`[3,4,5,5,4,null,7]`。

**答案解析：** 使用递归方法。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, t1: Optional[TreeNode], t2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not t1:
            return t2
        if not t2:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1
```

### 10. 快手面试题：设计循环队列

**题目：** 设计一个循环队列，支持 `enQueue`（插入元素）、`deQueue`（删除元素）和 `Front`（获取队首元素）操作。

**示例：** 输入：`["CircularQueue", "enQueue", "deQueue", "enQueue", "enQueue", "deQueue", "deQueue", "enQueue", "deQueue", "deQueue"]`，参数分别为`[[3], [1], [2], [3], [4], [1], [2], [4], [4], [3]]`，输出：`[null, true, true, true, true, false, false, true, true, false]`。

**答案解析：** 使用数组实现循环队列。

```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.queue = [0] * k
        self.head = self.tail = 0
        self.size = 0

    def enQueue(self, value: int) -> bool:
        if self.size == len(self.queue):
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % len(self.queue)
        self.size += 1
        return True

    def deQueue(self) -> bool:
        if self.size == 0:
            return False
        self.head = (self.head + 1) % len(self.queue)
        self.size -= 1
        return True

    def Front(self) -> int:
        if self.size == 0:
            return -1
        return self.queue[self.head]

    def Rear(self) -> int:
        if self.size == 0:
            return -1
        if self.tail == 0:
            return self.queue[-1]
        return self.queue[self.tail - 1]
```

### 11. 滴滴面试题：字符串匹配

**题目：** 实现字符串匹配算法，如 KMP、Boyer-Moore 或 Rabin-Karp。

**示例：** 输入：`"hello"` 和 `"ll"`，输出：`2`。

**答案解析：** 以 KMP 算法为例。

```python
def kmp(s, p):
    n, m = len(s), len(p)
    lps = [0] * m
    j = 0

    # 计算部分匹配表（LPS）
    for i in range(1, m):
        while j > 0 and p[j] != p[i]:
            j = lps[j - 1]
        if p[j] == p[i]:
            lps[i] = j + 1
            j += 1

    # KMP 主循环
    i = j = 0
    while i < n:
        if p[j] == s[i]:
            i, j = i + 1, j + 1
        if j == m:
            return i - j
        elif i < n and p[j] != s[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return -1

print(kmp("hello", "ll"))  # 输出：2
```

### 12. 小红书面试题：合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：** 输入：`[[1,3],[2,6],[8,10],[15,18]]`，输出：`[[1,6],[8,10],[15,18]]`。

**答案解析：** 与拼多多面试题中的答案解析相同。

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for interval in intervals[1:]:
        last_interval = result[-1]
        if interval[0] <= last_interval[1]:
            last_interval[1] = max(last_interval[1], interval[1])
        else:
            result.append(interval)

    return result

print(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))  # 输出：[[1,6],[8,10],[15,18]]
```

### 13. 蚂蚁面试题：二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树和一个目标值，查找树中是否存在这个值。

**示例：** 输入：`[4,2,6,1,3]`，目标值为 `2`，输出：`true`。

**答案解析：** 使用递归或迭代的方法遍历二叉搜索树。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        while root:
            if root.val == val:
                return root
            elif root.val > val:
                root = root.left
            else:
                root = root.right
        return None
```

### 14. 阿里巴巴面试题：环形数组求和

**题目：** 给定一个环形数组，计算数组中所有元素的和。

**示例：** 输入：`[1,2,3,4]`，输出：`10`。

**答案解析：** 使用前缀和的方法。

```python
def sum环(arr):
    total = sum(arr)
    return (total - arr[0]) % len(arr)

print(sum环([1, 2, 3, 4]))  # 输出：10
```

### 15. 腾讯面试题：有序数组的中位数

**题目：** 给定两个有序数组，找出这两个数组的第 `k` 个中位数。

**示例：** 输入：`[1, 3]` 和 `[2]`，`k = 2`，输出：`2`。

**答案解析：** 使用二分查找的方法。

```python
def findMedianSortedArrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0: max_of_left = nums2[j - 1]
            elif j == 0: max_of_left = nums1[i - 1]
            else: max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m: min_of_right = nums2[j]
            elif j == n: min_of_right = nums1[i]
            else: min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2

print(findMedianSortedArrays([1, 3], [2]))  # 输出：2.0
```

### 16. 百度面试题：最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长公共前缀。

**示例：** 输入：`["flower", "flow", "flight"]`，输出：`"fl"`。

**答案解析：** 使用垂直扫描的方法。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""

    for c in strs[0]:
        for s in strs:
            if s[:len(c)] != c:
                return s[:len(c)-1]
    return strs[0]

print(longestCommonPrefix(["flower", "flow", "flight"]))  # 输出："fl"
```

### 17. 字节跳动面试题：最大子序和

**题目：** 给定一个整数数组 `nums`，找出一个连续子数组的最大和。

**示例：** 输入：`[-2,1,-3,4,-1,2,1,-5,4]`，输出：`6`。

**答案解析：** 使用动态规划的方法。

```python
def maxSubArray(nums):
    if not nums:
        return 0
    pre = nums[0]
    max_ = pre
    for i in range(1, len(nums)):
        pre = max(pre + nums[i], nums[i])
        max_ = max(max_, pre)
    return max_

print(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 输出：6
```

### 18. 拼多多面试题：两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字。对这两个数字进行加法运算。

**示例：** 输入：(2 -> 4 -> 3)，(5 -> 6 -> 4)，输出：(7 -> 0 -> 7)。

**答案解析：** 与阿里巴巴面试题中的答案解析相同。

```python
# Definition for a linked list node.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        current = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            current.next = ListNode(total % 10)
            current = current.next

            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next

        return dummy.next
```

### 19. 京东面试题：设计一个缓存系统

**题目：** 设计一个缓存系统，支持 `put`（插入键值对）和 `get`（获取键的值）操作。

**示例：** 输入：`["LRUCache", "get", "put", "get", "put"]`，参数分别为`[[2], [1, 1], [2, 2], [1], [3, 3]]`，输出：`[null, -1, null, 2, null]`。

**答案解析：** 使用哈希表和双向链表实现。

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

### 20. 美团面试题：最大连续子数组

**题目：** 给定一个整数数组 `nums`，找出一个连续子数组的最大和。

**示例：** 输入：`[-2,1,-3,4,-1,2,1,-5,4]`，输出：`6`。

**答案解析：** 使用动态规划的方法。

```python
def maxSubArray(nums):
    if not nums:
        return 0
    pre = nums[0]
    max_ = pre
    for i in range(1, len(nums)):
        pre = max(pre + nums[i], nums[i])
        max_ = max(max_, pre)
    return max_

print(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 输出：6
```

### 21. 滴滴面试题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**示例：** 输入："ABCBDAB"，"BDCABC"，输出："BCAB"。

**答案解析：** 使用动态规划的方法。

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

print(longest_common_subsequence("ABCBDAB", "BDCABC"))  # 输出："BCAB"
```

### 22. 小红书面试题：合并两个有序链表

**题目：** 给定两个有序链表，合并它们的节点值。

**示例：** 输入：`[1,3,5]` 和 `[2,4,6]`，输出：`[1,2,3,4,5,6]`。

**答案解析：** 使用递归的方法。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

# 示例链表
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))

merged_list = merge_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end="->")
    merged_list = merged_list.next
# 输出：1->2->3->4->5->6->
```

### 23. 腾讯面试题：最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**示例：** 输入："ABCD"，"ACDF"，输出："ACD"。

**答案解析：** 使用动态规划的方法。

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    max_len = 0
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                max_len = max(max_len, dp[i][j])
            else:
                dp[i][j] = 0

    return s1[:max_len]

print(longest_common_substring("ABCD", "ACDF"))  # 输出："ACD"
```

### 24. 字节跳动面试题：两个链表的第一个公共节点

**题目：** 给定两个单链表，找出它们的第一个公共节点。

**示例：** 输入：`[1, 2, 3, 4, 5]` 和 `[2, 6, 4, 5]`，输出：节点值 `4`。

**答案解析：** 使用哈希表的方法。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        nodes_in_a = set()
        while headA:
            nodes_in_a.add(headA)
            headA = headA.next
        while headB:
            if headB in nodes_in_a:
                return headB
            headB = headB.next
        return None
```

### 25. 京东面试题：字符串相乘

**题目：** 实现一个函数，计算两个字符串表示的数字的乘积。

**示例：** 输入："123"，"456"，输出："56088"。

**答案解析：** 将字符串转换为整数后进行乘法运算。

```python
def multiply(num1, num2):
    return str(int(num1) * int(num2))

print(multiply("123", "456"))  # 输出："56088"
```

### 26. 阿里巴巴面试题：单词搜索

**题目：** 给定一个二维字符网格和一个单词，判断该单词是否存在于网格中。

**示例：** 输入：`[['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]`，单词："ABCCED"，输出：`True`。

**答案解析：** 使用深度优先搜索的方法。

```python
def exist(board, word):
    def dfs(i, j, k):
        if board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True
        tmp = board[i][j]
        board[i][j] = '#'
        res = (
            dfs(i + 1, j, k + 1) or
            dfs(i - 1, j, k + 1) or
            dfs(i, j + 1, k + 1) or
            dfs(i, j - 1, k + 1)
        )
        board[i][j] = tmp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False

board = [['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']]
word = "ABCCED"
print(exist(board, word))  # 输出：True
```

### 27. 腾讯面试题：翻转二叉树

**题目：** 实现一个函数，翻转给定的二叉树。

**示例：** 输入：`[4, 2, 7, 1, 3, 6, 9]`，输出：`[4, 7, 2, 9, 6, 3, 1]`。

**答案解析：** 使用递归的方法。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if root:
            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
        return root
```

### 28. 快手面试题：环形缓冲队列

**题目：** 实现一个环形缓冲队列，支持 `enQueue`（插入元素）和 `deQueue`（删除元素）操作。

**示例：** 输入：`["RingBuffer", "enQueue", "enQueue", "deQueue", "deQueue", "enQueue", "enQueue", "deQueue", "deQueue", "deQueue"]`，参数分别为`[[3], [1], [2], [], [], [3], [4], [], []]`，输出：`[null, true, true, 1, 2, true, true, 3, 4, false]`。

**答案解析：** 使用数组实现环形缓冲队列。

```python
class RingBuffer:

    def __init__(self, size):
        self.buffer = [0] * size
        self.head = self.tail = 0

    def enQueue(self, value):
        if (self.tail + 1) % len(self.buffer) == self.head:
            return False
        self.buffer[self.tail] = value
        self.tail = (self.tail + 1) % len(self.buffer)
        return True

    def deQueue(self):
        if self.head == self.tail:
            return False
        value = self.buffer[self.head]
        self.head = (self.head + 1) % len(self.buffer)
        return value
```

### 29. 滴滴面试题：判断二叉树是否平衡

**题目：** 实现一个函数，判断二叉树是否平衡。

**示例：** 输入：`[3, 9, 20, null, null, 15, 7]`，输出：`True`。

**答案解析：** 使用递归的方法，计算每个子树的高度，并判断高度差是否大于 `1`。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def check(node):
            if node is None:
                return 0
            left_height = check(node.left)
            right_height = check(node.right)
            if abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1

        return check(root) != -1
```

### 30. 小红书面试题：设计一个哈希表

**题目：** 实现一个哈希表，支持插入、删除和查找操作。

**示例：** 输入：`["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]`，参数分别为`[[], [1, 1], [2, 2], [1], [3], [2, 2], [2], [2], [2]]`，输出：`[null, true, true, 1, -1, true, 2, true, -1]`。

**答案解析：** 使用拉链法解决哈希冲突。

```python
class MyHashMap:

    def __init__(self):
        self.size = 10000
        self.buckets = [[] for _ in range(self.size)]

    def hash(self, key):
        return key % self.size

    def put(self, key: int, value: int) -> None:
        bucket = self.buckets[self.hash(key)]
        for k, v in bucket:
            if k == key:
                k, v = key, value
                break
        bucket.append((key, value))

    def get(self, key: int) -> int:
        bucket = self.buckets[self.hash(key)]
        for k, v in bucket:
            if k == key:
                return v
        return -1

    def remove(self, key: int) -> None:
        bucket = self.buckets[self.hash(key)]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                break
```

