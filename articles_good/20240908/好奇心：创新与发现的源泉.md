                 

### 1. 最短子数组和大于平均数

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，请找到最短子数组，其和大于或等于 `k`。返回这个子数组的长度。

**示例：**
```plaintext
输入：nums = [1,3,2,4,4,3], k = 7
输出：2
解释：子数组 [4,4] 的和为 8，大于等于 7。
```

**答案：**

```go
func shortestSubarray(nums []int, k int) int {
    n := len(nums)
    pref := make([]int, n+1)
    for i := 0; i < n; i++ {
        pref[i+1] = pref[i] + nums[i]
    }
    ans := n
    q := []int{}
    for i := 1; i <= n; i++ {
        for len(q) > 0 && pref[i] - pref[q[0]] < k {
            q = q[1:]
        }
        for len(q) > 0 && pref[i] - pref[q[len(q)-1]] == pref[i] - pref[q[0]] {
            q = q[:len(q)-1]
        }
        q = append(q, i)
        ans = min(ans, i-q[0])
    }
    return ans
}
```

**解析：** 

1. 首先计算前缀和数组 `pref`。
2. 使用单调栈或双指针方法找到满足条件的子数组。
3. 对于每个前缀和 `pref[i]`，我们尝试找到最小的 `j` 使得 `pref[i] - pref[j] >= k`。
4. 更新答案为 `i - j`。
5. 重复这个过程直到处理完所有的前缀和。

**复杂度分析：** 

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(n)。

### 2. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**示例：**
```plaintext
输入：[100, 4, 200, 1, 3, 2]
输出：4
解释：最长连续序列是 [1, 2, 3, 4]，它的长度为 4。
```

**答案：**

```go
func longestConsecutive(nums []int) int {
    m := make(map[int]bool)
    for _, x := range nums {
        m[x] = true
    }
    ans := 0
    for x := range m {
        if !m[x-1] {
            y := x
            for m[y+1] {
                y++
            }
            ans = max(ans, y-x+1)
        }
    }
    return ans
}
```

**解析：** 

1. 使用哈希表 `m` 存储数组中每个元素是否存在。
2. 对于每个元素 `x`，如果 `x-1` 不在 `m` 中，那么从 `x` 开始计算连续序列的长度。
3. 更新最长连续序列的长度。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(n)。

### 3. 和为 k 的最长子数组

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，找到和为 `k` 的最长子数组长度。

**示例：**
```plaintext
输入：nums = [1,2,3,4], k = 6
输出：9
解释：最长子数组是 [1,2,3,4]，其和为 10，大于 6。
```

**答案：**

```go
func longestSubarray(nums []int, k int) int {
    ans := 0
    s := 0
    m := map[int]int{}
    for e, v := range nums {
        s += v
        if s >= k {
            ans = max(ans, e-m[s-k]+1)
        }
        if _, ok := m[s]; !ok {
            m[s] = e
        }
    }
    return ans
}
```

**解析：** 

1. 使用滑动窗口的方法计算每个窗口的元素和。
2. 如果当前窗口的元素和大于或等于 `k`，则更新答案。
3. 使用哈希表 `m` 记录每个和第一次出现的索引。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(n)。

### 4. 最小移动次数使数组元素相等

**题目：** 给定一个整数数组 `nums`，找出移动所有数组元素所需要的最小移动次数，使得数组中的每个数都相等。

**示例：**
```plaintext
输入：nums = [1,2,3]
输出：3
解释：只需要三次移动就能使数组中的每个元素相等，分别是 [2,1,3]、[1,3,2] 和 [3,2,1]。
```

**答案：**

```go
func minMoves2(nums []int) int {
    sort.Ints(nums)
    ans := 0
    median := nums[len(nums)/2]
    for _, x := range nums {
        ans += abs(x - median)
    }
    return ans
}
```

**解析：** 

1. 将数组排序。
2. 计算数组中每个元素与中位数的绝对差值之和。

**复杂度分析：**

- 时间复杂度：O(nlogn)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(logn)。

### 5. 滑动窗口的最大值

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，找出滑动窗口中最大值。

**示例：**
```plaintext
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```

**答案：**

```go
func maxSlidingWindow(nums []int, k int) []int {
    ans := []int{}
    q := []int{}
    for i, v := range nums {
        for len(q) > 0 && q[len(q)-1] < v {
            q = q[:len(q)-1]
        }
        q = append(q, v)
        if i >= k-1 {
            ans = append(ans, q[0])
            if q[0] == nums[i-k+1] {
                q = q[1:]
            }
        }
    }
    return ans
}
```

**解析：** 

1. 维护一个单调递增的队列 `q`，队列中的元素代表当前窗口中的可能的最大值。
2. 遍历数组 `nums`，将小于当前元素的元素从队列中移除。
3. 将当前元素添加到队列中。
4. 当遍历到第 `k` 个元素时，将队列的首元素添加到结果数组 `ans` 中。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(k)。

### 6. 子数组最大平均数 I

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，找出平均数最大且长度为 `k` 的连续子数组。

**示例：**
```plaintext
输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数是 (12-5-6+50)/4 = 51/4 = 12.75
```

**答案：**

```go
func findMaxAverage(nums []int, k int) float64 {
    sum := 0
    for i := 0; i < k; i++ {
        sum += nums[i]
    }
    mx := sum
    for i := k; i < len(nums); i++ {
        sum += nums[i] - nums[i-k]
        mx = max(mx, sum)
    }
    return float64(mx) / float64(k)
}
```

**解析：** 

1. 计算前 `k` 个元素的和。
2. 从 `k` 开始遍历数组，每次更新和，并与当前最大和比较。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(1)。

### 7. 子数组最小值 II

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，找到一个最小化数组元素和的最小子数组长度 `k`。

**示例：**
```plaintext
输入：nums = [3,1,2,2,4], k = 2
输出：2
解释：最小化数组元素和的最小子数组是 [2,2]，长度为 2。
```

**答案：**

```go
func minSumOfSubarraySizes(nums []int, k int) int {
    ans := 0
    s := 0
    m := map[int]int{}
    for i, v := range nums {
        s += v
        if i >= k-1 {
            s -= nums[i-k+1]
        }
        if j, ok := m[s]; ok {
            ans = max(ans, i-j+1)
        }
        if i >= k-1 {
            m[s] = i
        }
    }
    return ans
}
```

**解析：** 

1. 使用滑动窗口的方法计算每个窗口的和。
2. 使用哈希表 `m` 记录每个和第一次出现的索引。
3. 更新最小子数组长度。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(n)。

### 8. 两数之和 II - 输入有序数组

**题目：** 给定一个已按照升序排列的整数数组 `nums` ，和一个目标值 `target` ，请你在数组中找到两个数，使得它们的和等于 `target` ，然后返回这两个下标值。

**示例：**
```plaintext
输入：nums = [2,7,11,15], target = 9
输出：[1,2]
解释：因为 nums[1] + nums[2] = 2 + 7 = 9 ，返回 [1, 2] 。
```

**答案：**

```go
func twoSum(nums []int, target int) []int {
    l, r := 0, len(nums)-1
    for l < r {
        s := nums[l] + nums[r]
        if s == target {
            return []int{l + 1, r + 1}
        } else if s < target {
            l++
        } else {
            r--
        }
    }
    return []int{}
}
```

**解析：** 

1. 使用双指针方法在数组中寻找两个数，使得它们的和等于目标值。
2. 根据当前和与目标值的关系，移动左右指针。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(1)。

### 9. 最小堆组

**题目：** 设计一个堆组，支持添加和找出最小值。

**示例：**
```plaintext
输入：
["HeapGroup", "add", "add", "getMin", "add", "getMin"]
[[], [2], [5], [], [3], []]
输出：
[null, null, null, 2, null, 3]
```

**答案：**

```go
type HeapGroup struct {
    minHeap *heap.Heap
}

func Constructor() HeapGroup {
    return HeapGroup{&heap.Heap{}}
}

func (this *HeapGroup) Add(val int)  {
    this.minHeap.Push(val)
}

func (this *HeapGroup) GetMin() int {
    if this.minHeap.Empty() {
        return -1
    }
    return this.minHeap.Peek()
}
```

**解析：** 

1. 使用最小堆存储元素，提供添加和获取最小值操作。

**复杂度分析：**

- 时间复杂度：O(logn)，其中 n 是堆中元素的数量。
- 空间复杂度：O(n)。

### 10. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 

1. 对区间数组按起始值排序。
2. 遍历区间数组，合并重叠的区间。

**复杂度分析：**

- 时间复杂度：O(nlogn)，其中 n 是区间数组的长度。
- 空间复杂度：O(n)。

### 11. 逆波兰表达式求值

**题目：** 根据逆波兰表达式，求表达式的值。

**示例：**
```plaintext
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：((2 + 1) * 3) = 9
```

**答案：**

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

**解析：** 

1. 使用栈存储中间结果。
2. 遍历逆波兰表达式，根据操作符进行相应的运算。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是 tokens 的长度。
- 空间复杂度：O(n)。

### 12. 合并有序链表

**题目：** 将两个升序链表合并为一个升序链表。

**示例：**
```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}
```

**解析：** 

1. 使用哑节点 `dummy` 作为合并链表的头节点。
2. 遍历两个链表，选择较小的节点添加到合并后的链表中。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是两个链表的长度之和。
- 空间复杂度：O(1)。

### 13. 寻找两个正序数组的中位数

**题目：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`，请从这两个数组中各自选择一个数字，找出它们的 中位数。如果中位数不是整数，结果需要取整数部分。

**示例：**
```plaintext
输入：nums1 = [1,3], nums2 = [2]
输出：2
解释：合并数组后 [1,2,3]，中位数是 2。
```

**答案：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i == m {
                minRight = nums2[j]
            } else if j == n {
                minRight = nums1[i]
            } else {
                minRight = min(nums1[i], nums2[j])
            }
            return float64(maxLeft+minRight) / 2
        }
    }
    return 0
}
```

**解析：** 

1. 使用二分查找，找到两个数组的中间索引。
2. 计算两个数组的中间值。

**复杂度分析：**

- 时间复杂度：O(log(min(m, n)))，其中 m 和 n 分别是两个数组的长度。
- 空间复杂度：O(1)。

### 14. 单调栈

**题目：** 使用单调栈解决一些常见的问题，如下一个更大元素、下一个更小元素等。

**示例：**
```plaintext
输入：[2,1,2,4,3]
输出：[4,4,-1,4,-1]
```

**答案：**

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    stack := []int{}
    for i := 2*n - 1; i >= 0; i-- {
        for len(stack) > 0 && nums[stack[len(stack)-1]] <= nums[i%n] {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            ans[i%n] = -1
        } else {
            ans[i%n] = nums[stack[len(stack)-1]]
        }
        stack = append(stack, i%n)
    }
    return ans
}
```

**解析：** 

1. 将数组重复一遍，以处理循环情况。
2. 使用单调栈找出每个元素之后的第一个更大元素。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(n)。

### 15. 计数器

**题目：** 设计一个特殊计数器，支持增加、减少和获取当前值的操作。

**示例：**
```plaintext
输入：
["Counter", "increase", "increase", "increase", "get"]
[[5], [2], [3], [1], []]
输出：
[null, null, null, null, 6]
```

**答案：**

```go
type Counter struct {
    m map[int]int
}

func Constructor() Counter {
    return Counter{m: map[int]int{}}
}

func (this *Counter) Increase(x int)  {
    this.m[x]++
}

func (this *Counter) Decrease(x int)  {
    this.m[x]--
}

func (this *Counter) Get() int {
    sum := 0
    for _, v := range this.m {
        sum += v
    }
    return sum
}
```

**解析：** 

1. 使用哈希表存储每个元素的值。
2. 实现增加、减少和获取当前值的操作。

**复杂度分析：**

- 时间复杂度：O(1)，对于每个操作。
- 空间复杂度：O(n)，其中 n 是哈希表中的元素数量。

### 16. 股票交易的最佳时机 III

**题目：** 给定一个数组，表示连续的股票价格，最多允许两次交易，求最大的利润。

**示例：**
```plaintext
输入：[3,3,5,0,0,3,1,4]
输出：6
解释：第一次交易为 [3,3]，第二次交易为 [5,4]。
```

**答案：**

```go
func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    f1, f2 := 0, -prices[0]
    s1, s2 := 0, -prices[0]
    for i := 1; i < len(prices); i++ {
        f1 = max(f1, s1-prices[i])
        f2 = max(f2, f1+prices[i])
        s1 = max(s1, s2-prices[i])
        s2 = max(s2, s1+prices[i])
    }
    return f2
}
```

**解析：** 

1. 使用动态规划方法，计算两次交易的最大利润。
2. 定义四个变量分别表示第一次买入、第一次卖出、第二次买入和第二次卖出的状态。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `prices` 的长度。
- 空间复杂度：O(1)。

### 17. 最小费用路径

**题目：** 给定一个加权图，找出从源点到达目标点的最小费用路径。

**示例：**
```plaintext
输入：
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出：7
解释：最小费用路径为 4 -> 2 -> 1 -> 3。
```

**答案：**

```go
func minCostPath(grid [][]int) int {
    n, m := len(grid), len(grid[0])
    dist := make([][]int, n)
    for i := range dist {
        dist[i] = make([]int, m)
        for j := range dist[i] {
            dist[i][j] = math.MaxInt32
        }
    }
    dist[0][0] = 0
    q := [][]int{{0, 0, 0}}
    for len(q) > 0 {
        v := q[0]
        q = q[1:]
        i, j, w := v[0], v[1], v[2]
        for _, dir := range [][]int{{0, -1}, {0, 1}, {1, 0}, {-1, 0}} {
            x, y := i+dir[0], j+dir[1]
            if x >= 0 && x < n && y >= 0 && y < m {
                nw := w + grid[x][y]
                if nw < dist[x][y] {
                    dist[x][y] = nw
                    q = append(q, []int{x, y, nw})
                }
            }
        }
    }
    return dist[n-1][m-1]
}
```

**解析：** 

1. 使用广度优先搜索算法，计算从源点到每个点的最短路径。
2. 遍历图中的每个节点，更新最短路径值。

**复杂度分析：**

- 时间复杂度：O(nm)，其中 n 和 m 分别是图中的节点数量。
- 空间复杂度：O(nm)。

### 18. 柱状图中最大矩形

**题目：** 给定一个柱状图，找出其中最大的矩形。

**示例：**
```plaintext
输入：
[
  [2,1,5,6,2,3],
  [9,0,6,7,0,1],
  [1,4,3,2,0,3]
]
输出：12
解释：最大的矩形为上面红色区域，面积为 12。
```

**答案：**

```go
func largestRectangleArea(heights []int) int {
    n := len(heights)
    stk := []int{}
    ans := 0
    for i := 0; i <= n {
        cur := -1
        if i < n && heights[i] >= heights[stk[len(stk)-1]] {
            cur = stk[len(stk)-1]
        } else {
            for len(stk) > 0 && (i == n || heights[stk[len(stk)-1]] < heights[i]) {
                cur = stk[len(stk)-1]
                stk = stk[:len(stk)-1]
            }
        }
        if cur == -1 {
            cur = 0
        }
        ans = max(ans, (i-cur-1)*heights[i])
    }
    return ans
}
```

**解析：** 

1. 使用栈维护当前连续下降段的左边界。
2. 对于每个元素，计算以该元素为高度的矩形面积。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `heights` 的长度。
- 空间复杂度：O(n)。

### 19. 单调栈

**题目：** 使用单调栈找出数组中的下一个更大元素。

**示例：**
```plaintext
输入：[2,1,2,4,3]
输出：[4,4,-1,4,-1]
```

**答案：**

```go
func nextGreaterElement(nums1 []int) []int {
    n := len(nums1)
    ans := make([]int, n)
    stk := []int{}
    for i := n - 1; i >= 0; i-- {
        for len(stk) > 0 && nums1[stk[len(stk)-1]-1] <= nums1[i] {
            stk = stk[:len(stk)-1]
        }
        if len(stk) == 0 {
            ans[i] = -1
        } else {
            ans[i] = nums1[stk[len(stk)-1]-1]
        }
        stk = append(stk, i+1)
    }
    return ans
}
```

**解析：** 

1. 将数组中的每个元素与栈顶元素比较，更新答案。
2. 将当前元素添加到栈中。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums1` 的长度。
- 空间复杂度：O(n)。

### 20. 扫描线

**题目：** 使用扫描线算法找出多边形中的最大矩形。

**示例：**
```plaintext
输入：
[
  [2,1,5,6,2,3],
  [9,0,6,7,0,1],
  [1,4,3,2,0,3]
]
输出：12
解释：最大的矩形为上面红色区域，面积为 12。
```

**答案：**

```go
func largestRectangleArea(heights [][]int) int {
    heights = append(heights, []int{})
    ans := 0
    stk := []int{}
    for i := range heights {
        for len(stk) > 0 && (len(heights[stk[len(stk)-1]]) < len(heights[i])) {
            j := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            ans = max(ans, (i-stk[len(stk)-1]-1)*heights[stk[len(stk)-1]])
        }
        stk = append(stk, i)
    }
    return ans
}
```

**解析：** 

1. 将二维数组扩展成一行，使用单调栈找出每行的最大矩形面积。
2. 更新最大面积。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `heights` 的长度。
- 空间复杂度：O(n)。

### 21. 矩形重叠

**题目：** 判断两个矩形是否重叠。

**示例：**
```plaintext
输入：
[
  [1, 2],
  [2, 3],
  [1, 4]
]
和
[
  [2, 3],
  [3, 5]
]
输出：
[
  [1, 2],
  [2, 3],
  [3, 4],
  [3, 5]
]
```

**答案：**

```go
func overlap(rect1, rect2 [][]int) [][]int {
    ans := [][]int{}
    if rect1[0][0] < rect2[0][0] {
        ans = append(ans, []int{rect1[0][0], rect2[0][0]})
    }
    if rect1[0][1] > rect2[0][1] {
        ans = append(ans, []int{rect2[0][1], rect1[0][1]})
    }
    if rect1[1][0] < rect2[1][0] {
        ans = append(ans, []int{rect1[1][0], rect2[1][0]})
    }
    if rect1[1][1] > rect2[1][1] {
        ans = append(ans, []int{rect2[1][1], rect1[1][1]})
    }
    return ans
}
```

**解析：** 

1. 计算两个矩形的重叠区域。
2. 返回重叠的矩形。

**复杂度分析：**

- 时间复杂度：O(1)。
- 空间复杂度：O(1)。

### 22. 汇总统计一

**题目：** 给定多个整数数组，统计每个数组中的最大值、最小值、平均值、中位数和众数。

**示例：**
```plaintext
输入：intervals = [[1,3],[3,5],[7,9]]
输出：
[
  [1.00000,4.00000,3.00000,3.00000],
  [3.00000,5.00000,4.00000,5.00000],
  [7.00000,9.00000,8.00000,8.00000]
]
```

**答案：**

```go
func arrayStatistics(intervals [][]int) [][]float64 {
    ans := make([][]float64, len(intervals))
    for i, interval := range intervals {
        ans[i] = make([]float64, 5)
        ans[i][0] = float64(interval[0])
        ans[i][1] = float64(interval[1])
        ans[i][2] = float64(interval[1]-interval[0]+1)
        if len(interval[0])%2 == 0 {
            ans[i][3] = float64(interval[0])
        } else {
            ans[i][3] = float64(interval[1])
        }
        cnt := make(map[int]int)
        mx := -1
        for _, x := range interval {
            cnt[x]++
            if x > mx {
                mx = x
            }
        }
        ans[i][4] = float64(mx)
        for k, v := range cnt {
            if v > ans[i][3] {
                ans[i][3] = float64(k)
            }
        }
    }
    return ans
}
```

**解析：** 

1. 对每个区间计算最大值、最小值、平均值、中位数和众数。
2. 使用哈希表统计每个元素出现的次数，找出众数。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是所有区间元素的数量。
- 空间复杂度：O(n)。

### 23. 汇总统计二

**题目：** 给定多个整数数组，统计每个数组中的最大值、最小值、平均值、中位数和众数。

**示例：**
```plaintext
输入：intervals = [[1,3],[3,5],[7,9]]
输出：
[
  [1.00000,4.00000,3.00000,3.00000],
  [3.00000,5.00000,4.00000,5.00000],
  [7.00000,9.00000,8.00000,8.00000]
]
```

**答案：**

```go
func arrayStatistics2(intervals [][]int) [][]float64 {
    ans := make([][]float64, len(intervals))
    for i, interval := range intervals {
        ans[i] = make([]float64, 5)
        ans[i][0] = float64(interval[0])
        ans[i][1] = float64(interval[1])
        ans[i][2] = float64(interval[1]-interval[0]+1)
        mid := interval[0] + (interval[1]-interval[0])/2
        if (interval[1]-interval[0])%2 == 0 {
            ans[i][3] = float64(mid)
        } else {
            ans[i][3] = float64(mid-1)
        }
        cnt := make(map[int]int)
        mx := -1
        for _, x := range interval {
            cnt[x]++
            if x > mx {
                mx = x
            }
        }
        ans[i][4] = float64(mx)
        for k, v := range cnt {
            if v > ans[i][3] {
                ans[i][3] = float64(k)
            }
        }
    }
    return ans
}
```

**解析：** 

1. 对每个区间计算最大值、最小值、平均值、中位数和众数。
2. 使用哈希表统计每个元素出现的次数，找出众数。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是所有区间元素的数量。
- 空间复杂度：O(n)。

### 24. 汇总统计三

**题目：** 给定多个整数数组，统计每个数组中的最大值、最小值、平均值、中位数和众数。

**示例：**
```plaintext
输入：intervals = [[1,3],[3,5],[7,9]]
输出：
[
  [1.00000,4.00000,3.00000,3.00000],
  [3.00000,5.00000,4.00000,5.00000],
  [7.00000,9.00000,8.00000,8.00000]
]
```

**答案：**

```go
func arrayStatistics3(intervals [][]int) [][]float64 {
    ans := make([][]float64, len(intervals))
    for i, interval := range intervals {
        ans[i] = make([]float64, 5)
        ans[i][0] = float64(interval[0])
        ans[i][1] = float64(interval[1])
        ans[i][2] = float64(interval[1]-interval[0]+1)
        mid := interval[0] + (interval[1]-interval[0])/2
        if (interval[1]-interval[0])%2 == 0 {
            ans[i][3] = float64(mid)
        } else {
            ans[i][3] = float64(mid-1)
        }
        cnt := make(map[int]int)
        mx := -1
        for _, x := range interval {
            cnt[x]++
            if x > mx {
                mx = x
            }
        }
        ans[i][4] = float64(mx)
        for k, v := range cnt {
            if v > ans[i][3] {
                ans[i][3] = float64(k)
            }
        }
    }
    return ans
}
```

**解析：** 

1. 对每个区间计算最大值、最小值、平均值、中位数和众数。
2. 使用哈希表统计每个元素出现的次数，找出众数。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是所有区间元素的数量。
- 空间复杂度：O(n)。

### 25. 汇总统计四

**题目：** 给定多个整数数组，统计每个数组中的最大值、最小值、平均值、中位数和众数。

**示例：**
```plaintext
输入：intervals = [[1,3],[3,5],[7,9]]
输出：
[
  [1.00000,4.00000,3.00000,3.00000],
  [3.00000,5.00000,4.00000,5.00000],
  [7.00000,9.00000,8.00000,8.00000]
]
```

**答案：**

```go
func arrayStatistics4(intervals [][]int) [][]float64 {
    ans := make([][]float64, len(intervals))
    for i, interval := range intervals {
        ans[i] = make([]float64, 5)
        ans[i][0] = float64(interval[0])
        ans[i][1] = float64(interval[1])
        ans[i][2] = float64(interval[1]-interval[0]+1)
        mid := interval[0] + (interval[1]-interval[0])/2
        if (interval[1]-interval[0])%2 == 0 {
            ans[i][3] = float64(mid)
        } else {
            ans[i][3] = float64(mid-1)
        }
        cnt := make(map[int]int)
        mx := -1
        for _, x := range interval {
            cnt[x]++
            if x > mx {
                mx = x
            }
        }
        ans[i][4] = float64(mx)
        for k, v := range cnt {
            if v > ans[i][3] {
                ans[i][3] = float64(k)
            }
        }
    }
    return ans
}
```

**解析：** 

1. 对每个区间计算最大值、最小值、平均值、中位数和众数。
2. 使用哈希表统计每个元素出现的次数，找出众数。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是所有区间元素的数量。
- 空间复杂度：O(n)。

### 26. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    ans := [][]int{}
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 

1. 对区间数组按起始值排序。
2. 遍历区间数组，合并重叠的区间。

**复杂度分析：**

- 时间复杂度：O(nlogn)，其中 n 是区间数组的长度。
- 空间复杂度：O(n)。

### 27. 滑动窗口的最大值

**题目：** 给定一个数组 `nums` 和一个整数 `k`，找出滑动窗口中最大值。

**示例：**
```plaintext
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```

**答案：**

```go
func maxSlidingWindow(nums []int, k int) []int {
    ans := []int{}
    q := []int{}
    for i, v := range nums {
        for len(q) > 0 && q[len(q)-1] < v {
            q = q[:len(q)-1]
        }
        q = append(q, v)
        if i >= k-1 {
            ans = append(ans, q[0])
            if q[0] == nums[i-k+1] {
                q = q[1:]
            }
        }
    }
    return ans
}
```

**解析：** 

1. 维护一个单调递增的队列 `q`，队列中的元素代表当前窗口中的可能的最大值。
2. 遍历数组 `nums`，将小于当前元素的元素从队列中移除。
3. 将当前元素添加到队列中。
4. 当遍历到第 `k` 个元素时，将队列的首元素添加到结果数组 `ans` 中。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(k)。

### 28. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    ans := [][]int{}
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 

1. 对区间数组按起始值排序。
2. 遍历区间数组，合并重叠的区间。

**复杂度分析：**

- 时间复杂度：O(nlogn)，其中 n 是区间数组的长度。
- 空间复杂度：O(n)。

### 29. 滑动窗口的最大值

**题目：** 给定一个数组 `nums` 和一个整数 `k`，找出滑动窗口中最大值。

**示例：**
```plaintext
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
```

**答案：**

```go
func maxSlidingWindow(nums []int, k int) []int {
    ans := []int{}
    q := []int{}
    for i, v := range nums {
        for len(q) > 0 && q[len(q)-1] < v {
            q = q[:len(q)-1]
        }
        q = append(q, v)
        if i >= k-1 {
            ans = append(ans, q[0])
            if q[0] == nums[i-k+1] {
                q = q[1:]
            }
        }
    }
    return ans
}
```

**解析：** 

1. 维护一个单调递增的队列 `q`，队列中的元素代表当前窗口中的可能的最大值。
2. 遍历数组 `nums`，将小于当前元素的元素从队列中移除。
3. 将当前元素添加到队列中。
4. 当遍历到第 `k` 个元素时，将队列的首元素添加到结果数组 `ans` 中。

**复杂度分析：**

- 时间复杂度：O(n)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(k)。

### 30. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    ans := [][]int{}
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 

1. 对区间数组按起始值排序。
2. 遍历区间数组，合并重叠的区间。

**复杂度分析：**

- 时间复杂度：O(nlogn)，其中 n 是区间数组的长度。
- 空间复杂度：O(n)。

