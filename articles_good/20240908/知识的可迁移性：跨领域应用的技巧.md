                 

### 知识的可迁移性：跨领域应用的技巧

在快速发展的技术领域，知识的可迁移性成为一个关键能力。无论是面试、日常工作，还是未来职业发展，掌握跨领域应用的技巧都是至关重要的。以下，我们精选了 20~30 道具备代表性的面试题和算法编程题，旨在帮助读者理解和应用这些技巧。

### 1. 算法题：两数之和

**题目来源：** 阿里巴巴

**问题描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**代码示例：**

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

**解析：** 使用哈希表存储数组元素及其索引，遍历数组的同时，判断当前元素是否为另一个元素的补数，从而实现时间复杂度为 O(n) 的两数之和问题。

### 2. 算法题：最长公共前缀

**题目来源：** 腾讯

**问题描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**代码示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

**解析：** 通过不断缩短前缀，直到找到所有字符串都匹配的公共前缀。这种方法的时间复杂度为 O(m*n)，其中 m 是字符串的平均长度，n 是字符串的数量。

### 3. 算法题：搜索旋转排序数组

**题目来源：** 字节跳动

**问题描述：** 搜索一个旋转排序数组中的某个目标值。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[right] and target <= nums[left]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 利用二分查找，并处理旋转数组的问题，从而实现时间复杂度为 O(log n) 的搜索算法。

### 4. 算法题：合并两个有序链表

**题目来源：** 京东

**问题描述：** 将两个升序链表合并为一个新的升序链表并返回。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 递归或迭代地合并两个有序链表，时间复杂度为 O(n+m)，其中 n 和 m 分别是两个链表的长度。

### 5. 算法题：设计推特

**题目来源：** 美团

**问题描述：** 设计一个简化版的推特(Twitter)系统，让它支持发送推文、关注/取消关注其他用户、和获取用户的推文流。

**代码示例：**

```python
class Twitter:
    def __init__(self):
        self.tweets = [[], []]
        self.users = {}

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets[0].append([userId, tweetId])
        if userId not in self.users:
            self.users[userId] = []
        self.users[userId].append([userId, tweetId])

    def follow(self, followerId: int, followeeId: int) -> None:
        if followerId not in self.users:
            self.users[followerId] = []
        if followeeId not in self.users:
            self.users[followeeId] = []
        self.users[followerId].append(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followerId in self.users:
            self.users[followerId].remove(followeeId)

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = []
        if userId in self.users:
            followees = self.users[userId]
            followees += [userId]
            for followee in followees:
                if followee in self.users:
                    for tweet in self.users[followee]:
                        if tweet not in self.tweets[1]:
                            self.tweets[1].append(tweet)
                            feed.append(tweet[1])
        else:
            for tweet in self.tweets[0]:
                if tweet not in self.tweets[1]:
                    self.tweets[1].append(tweet)
                    feed.append(tweet[1])
        return feed[:10]
```

**解析：** 使用哈希表记录用户和他们的推文，以及关注关系。获取新闻流时，遍历关注者及其推文，并返回前 10 个推文。

### 6. 算法题：两个链表的第一个公共节点

**题目来源：** 小红书

**问题描述：** 给定两个单链表，找出它们的第一个公共节点。

**代码示例：**

```python
# 定义单链表节点
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def getIntersectionNode(headA, headB):
    pa, pb = headA, headB
    while pa != pb:
        pa = pa.next if pa else headB
        pb = pb.next if pb else headA
    return pa
```

**解析：** 通过两次遍历，先求出两个链表的长度，然后对较长的链表先走 `L1-L2` 的步数，再同时遍历两个链表，找到第一个公共节点。

### 7. 算法题：最长公共子序列

**题目来源：** 拼多多

**问题描述：** 给定两个字符串，找出它们的最长公共子序列。

**代码示例：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    return dp[m][n]
```

**解析：** 使用动态规划求解最长公共子序列问题，时间复杂度为 O(m*n)。

### 8. 算法题：合并多个表

**题目来源：** 滴滴

**问题描述：** 合并多个表（例如订单表、库存表等），并返回合并后的结果。

**代码示例：**

```python
# 假设表结构为字典，key是表的名称
tables = {
    'orders': [
        {'id': 1, 'amount': 100},
        {'id': 2, 'amount': 200},
    ],
    'inventory': [
        {'id': 1, 'quantity': 10},
        {'id': 2, 'quantity': 20},
    ],
}

def merge_tables(tables):
    result = []
    for table in tables.values():
        for item in table:
            item['table_name'] = table['table_name']
            result.append(item)
    return result

merged_result = merge_tables(tables)
```

**解析：** 遍历所有表，并将每个表的数据添加到结果列表中。

### 9. 算法题：最短路径问题

**题目来源：** 字节跳动

**问题描述：** 给定一个包含加权边的无向图，求两个顶点之间的最短路径。

**代码示例：**

```python
import heapq

def dijkstra(graph, start):
    n = len(graph)
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        curr_dist, curr_node = heapq.heappop(pq)
        if curr_dist != dist[curr_node]:
            continue
        for neighbor, weight in graph[curr_node].items():
            distance = curr_dist + weight
            if distance < dist[neighbor]:
                dist[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    return dist

graph = {
    0: {1: 4, 7: 8},
    1: {0: 4, 2: 8, 7: 11},
    2: {1: 8, 3: 7, 6: 1},
    3: {2: 7, 4: 9, 6: 14},
    4: {3: 9, 5: 10},
    5: {4: 10, 6: 2},
    6: {2: 1, 3: 14, 5: 2, 7: 1},
    7: {0: 8, 1: 11, 6: 1},
}

start = 0
distances = dijkstra(graph, start)
print(distances)
```

**解析：** 使用 Dijkstra 算法求解单源最短路径问题，时间复杂度为 O((V+E)logV)，其中 V 是顶点数，E 是边数。

### 10. 算法题：删除链表的倒数第 N 个节点

**题目来源：** 阿里巴巴

**问题描述：** 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

**代码示例：**

```python
# 定义单链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head: ListNode, n: int) -> ListNode:
    dummy = ListNode(0)
    dummy.next = head
    slow = fast = dummy
    for _ in range(n + 1):
        fast = fast.next
    while fast:
        slow = slow.next
        fast = fast.next
    slow.next = slow.next.next
    return dummy.next
```

**解析：** 使用快慢指针的方法找到倒数第 n 个节点，并删除它。时间复杂度为 O(n)。

### 11. 算法题：搜索二维矩阵

**题目来源：** 百度

**问题描述：** 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行中的元素从左到右按升序排列。
- 每个元素均为不同的元素。

**代码示例：**

```python
def searchMatrix(matrix, target):
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1
    while row < rows and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False
```

**解析：** 将问题转化为二维数组中的二分查找，时间复杂度为 O(m + n)。

### 12. 算法题：寻找两个正序数组的中位数

**题目来源：** 字节跳动

**问题描述：** 给定两个大小分别为 m 和 n 的正序数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 中位数 。

**代码示例：**

```python
def findMedianSortedArrays(nums1, nums2):
    nums = sorted(nums1 + nums2)
    n = len(nums)
    if n % 2 == 0:
        return (nums[n // 2 - 1] + nums[n // 2]) / 2
    else:
        return nums[n // 2]
```

**解析：** 合并两个有序数组并找到中位数，时间复杂度为 O((m+n)log(m+n))。

### 13. 算法题：环形链表

**题目来源：** 美团

**问题描述：** 给定一个链表，判断链表中是否有环。

**代码示例：**

```python
# 定义单链表节点
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def hasCycle(head: ListNode) -> bool:
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**解析：** 使用快慢指针检测链表中是否有环，时间复杂度为 O(n)。

### 14. 算法题：二进制求和

**题目来源：** 小红书

**问题描述：** 写一个函数，计算两个二进制字符串的数字之和。

**代码示例：**

```python
def addBinary(a, b):
    max_len = max(len(a), len(b))
    a = a.zfill(max_len)
    b = b.zfill(max_len)
    carry = 0
    result = []
    for i in range(max_len - 1, -1, -1):
        sum = carry + int(a[i]) + int(b[i])
        result.append(str(sum % 2))
        carry = sum // 2
    if carry:
        result.append(str(carry))
    return ''.join(result[::-1])
```

**解析：** 从最低位开始相加，记录进位，并将结果存储在列表中。

### 15. 算法题：无重复字符的最长子串

**题目来源：** 腾讯

**问题描述：** 给定一个字符串，找出不含有重复字符的最长子串。

**代码示例：**

```python
from collections import defaultdict

def lengthOfLongestSubstring(s: str) -> int:
    n = len(s)
    ans = 0
    d = defaultdict(int)
    i = 0
    for j in range(n):
        while s[j] in d:
            d[s[i]] = 0
            i += 1
        d[s[j]] = 1
        ans = max(ans, j - i + 1)
    return ans
```

**解析：** 使用哈希表记录字符位置，并滑动窗口来更新最长子串的长度。

### 16. 算法题：合并两个有序链表

**题目来源：** 京东

**问题描述：** 将两个升序链表合并为一个新的升序链表并返回。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 递归或迭代地合并两个有序链表。

### 17. 算法题：爬楼梯

**题目来源：** 滴滴

**问题描述：** 一个爬楼梯问题，即给定 n 阶楼梯，每次可以爬 1 或 2 个台阶，求有多少种不同的方法可以爬到楼顶。

**代码示例：**

```python
def climbStairs(n: int) -> int:
    if n < 2:
        return n
    a, b = 0, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b
```

**解析：** 使用动态规划求解，时间复杂度为 O(n)。

### 18. 算法题：股票买卖

**题目来源：** 拼多多

**问题描述：** 给定一个数组 prices ，其中 prices[i] 是第 i 天的股票价格。如果可以只完成最多两笔交易，请返回你最多可以获取的利润。

**代码示例：**

```python
def maxProfit(prices):
    if not prices:
        return 0
    first, second = -prices[0], -prices[0]
    for price in prices:
        first = max(first, -price)
        second = max(second, first+price)
    return -second
```

**解析：** 使用动态规划求解，时间复杂度为 O(n)。

### 19. 算法题：单词搜索

**题目来源：** 字节跳动

**问题描述：** 给定一个二维网格和一个单词，找出该单词是否存在于网格中。

**代码示例：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = word[k]
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

**解析：** 使用深度优先搜索（DFS）来搜索单词。

### 20. 算法题：最大子序和

**题目来源：** 阿里巴巴

**问题描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**代码示例：**

```python
def maxSubArray(nums):
    if not nums:
        return 0
    cur_max = max_sum = nums[0]
    for num in nums[1:]:
        cur_max = max(num, cur_max + num)
        max_sum = max(max_sum, cur_max)
    return max_sum
```

**解析：** 使用动态规划求解最大子序和问题。

### 21. 算法题：编辑距离

**题目来源：** 腾讯

**问题描述：** 给定两个字符串 word1 和 word2，计算出将 word1 转换成 word2 所需要的最少操作次数。

**代码示例：**

```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
    return dp[m][n]
```

**解析：** 使用动态规划求解编辑距离问题。

### 22. 算法题：二叉树的层序遍历

**题目来源：** 拼多多

**问题描述：** 给定一个二叉树，返回其按层序遍历的节点值。即按从左到右，顶到底部的顺序遍历。

**代码示例：**

```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    queue = deque([root])
    ans = []
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        ans.append(level)
    return ans
```

**解析：** 使用广度优先搜索（BFS）实现二叉树的层序遍历。

### 23. 算法题：最长公共子序列

**题目来源：** 字节跳动

**问题描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**代码示例：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：** 使用动态规划求解最长公共子序列问题。

### 24. 算法题：有效的括号

**题目来源：** 小红书

**问题描述：** 给定一个包含括号的字符串，判断其是否有效。

**代码示例：**

```python
from collections import deque

def isValid(s):
    pairs = {')': '(', ']': '[', '}': '{'}
    stack = deque()
    for c in s:
        if c in pairs.values():
            if not stack or stack.pop() != pairs[c]:
                return False
        else:
            stack.append(c)
    return not stack
```

**解析：** 使用栈实现括号的匹配。

### 25. 算法题：单调栈

**题目来源：** 阿里巴巴

**问题描述：** 使用单调栈解决一些经典问题，如 Next Greater Element。

**代码示例：**

```python
def nextGreaterElements(nums):
    n = len(nums)
    stack, ans = [], [0] * n
    for i in range(n * 2 - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i % n]:
            stack.pop()
        ans[i % n] = stack[-1] if stack else -1
        stack.append(i % n)
    return ans
```

**解析：** 利用单调栈找出每个元素之后第一个更大的元素。

### 26. 算法题：字符串匹配算法

**题目来源：** 腾讯

**问题描述：** 实现字符串匹配算法，如 Knuth-Morris-Pratt 算法。

**代码示例：**

```python
def KMPP(next, s, p):
    i, j = 0, 0
    while i < len(s):
        if j == len(p) or s[i] == p[j]:
            i, j = i + 1, j + 1
        if j == len(p):
            return i - j
        else:
            j = next[j]
    return -1
```

**解析：** 使用 KMP 算法查找子串的位置。

### 27. 算法题：最小生成树

**题目来源：** 字节跳动

**问题描述：** 使用 Prim 算法或 Kruskal 算法求解最小生成树问题。

**代码示例（Prim 算法）：**

```python
import heapq

def prim(mgraph):
    n = len(mgraph)
    used = [False] * n
    edges = []
    start = 0
    used[start] = True
    for v in range(1, n):
        edges.append((mgraph[start][v], start, v))
    edges.sort()
    mst = []
    for w, u, v in edges:
        if not used[v]:
            mst.append((u, v, w))
            used[v] = True
            start = v
    return mst
```

**解析：** Prim 算法从任意一个节点开始，逐渐扩展到其它节点，构建最小生成树。

**代码示例（Kruskal 算法）：**

```python
def kruskal(edges):
    n = len(edges)
    uf = UnionFind(n)
    mst = []
    for w, u, v in sorted(edges, key=lambda x: x[0]):
        if not uf.isConnected(u, v):
            uf.union(u, v)
            mst.append((u, v, w))
    return mst

class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.size[rootX] > self.size[rootY]:
                self.p[rootY] = rootX
                self.size[rootX] += self.size[rootY]
            else:
                self.p[rootX] = rootY
                self.size[rootY] += self.size[rootX]

    def isConnected(self, x, y):
        return self.find(x) == self.find(y)
```

**解析：** Kruskal 算法按权值排序边，然后依次加入生成树，若加入边会形成环则丢弃。

### 28. 算法题：背包问题

**题目来源：** 京东

**问题描述：** 使用动态规划求解 01 背包问题。

**代码示例：**

```python
def knapsack(W, weights, values):
    n = len(values)
    dp = [[0] * (W + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for w in range(1, W + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]
    return dp[n][W]
```

**解析：** 使用二维数组 `dp` 记录当前背包容量 `w` 和前 `i` 个物品的最大价值。

### 29. 算法题：最长公共子串

**题目来源：** 拼多多

**问题描述：** 给定两个字符串，求它们的最长公共子串。

**代码示例：**

```python
def longestCommonSubstr(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_len = max(max_len, dp[i][j])
            else:
                dp[i][j] = 0
    return max_len
```

**解析：** 使用动态规划求解最长公共子串问题。

### 30. 算法题：最小路径和

**题目来源：** 字节跳动

**问题描述：** 给定一个包含正整数和负整数的二维网格，找出从左上角到右下角的最小路径和。

**代码示例：**

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]
    return dp[m][n]
```

**解析：** 使用动态规划求解最小路径和问题。

