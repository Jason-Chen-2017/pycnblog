                 

### 华为2024社招编程面试题精华总结

#### 一、算法与数据结构

##### 1. 快排的实现与优化

**题目：** 实现快速排序算法，并分析其平均和最坏情况的时间复杂度。

**答案：**

```go
package main

import "fmt"

func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }

    pivot := arr[len(arr)/2]
    left, right := 0, len(arr)-1

    for i := 0; i <= right; i++ {
        if arr[i] < pivot {
            arr[left], arr[i] = arr[i], arr[left]
            left++
        } else if arr[i] > pivot {
            arr[right], arr[i] = arr[i], arr[right]
            right--
        }
    }

    quickSort(arr[:left])
    quickSort(arr[left+1:])
}

func main() {
    arr := []int{9, 8, 7, 6, 5, 4, 3, 2, 1}
    quickSort(arr)
    fmt.Println(arr)
}
```

**解析：** 快速排序的基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

##### 2. 图的遍历算法

**题目：** 实现图的深度优先搜索（DFS）和广度优先搜索（BFS）算法。

**答案：**

```go
package main

import "fmt"

type Graph struct {
    V     int
    Adj   [][]int
}

func (g *Graph) DFS(v int) {
    visited := make([]bool, g.V)
    g.dfs(v, visited)
}

func (g *Graph) dfs(v int, visited []bool) {
    visited[v] = true
    fmt.Println(v)
    for _, w := range g.Adj[v] {
        if !visited[w] {
            g.dfs(w, visited)
        }
    }
}

func (g *Graph) BFS(v int) {
    visited := make([]bool, g.V)
    queue := []int{}
    queue = append(queue, v)
    visited[v] = true

    for len(queue) > 0 {
        v := queue[0]
        queue = queue[1:]
        fmt.Println(v)
        for _, w := range g.Adj[v] {
            if !visited[w] {
                queue = append(queue, w)
                visited[w] = true
            }
        }
    }
}

func main() {
    g := &Graph{V: 4}
    g.Adj = [][]int{{1, 2}, {0, 2, 3}, {0, 3}, {1, 3}}
    g.DFS(0)
    fmt.Println("--------------")
    g.BFS(0)
}
```

**解析：** 深度优先搜索（DFS）和广度优先搜索（BFS）是图遍历的两种基本方法。DFS是从一个顶点开始，尽可能深地探索图的分支；BFS则是从起始顶点开始，逐层遍历图的所有顶点。

##### 3. 最短路径算法

**题目：** 实现迪杰斯特拉算法（Dijkstra）求解单源最短路径。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func dijkstra(graph [][]int, start int) {
    dist := make([]int, len(graph))
    visited := make([]bool, len(graph))
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0

    for i := 0; i < len(graph); i++ {
        u := -1
        for j := range dist {
            if !visited[j] && (u == -1 || dist[j] < dist[u]) {
                u = j
            }
        }
        visited[u] = true

        for v, weight := range graph[u] {
            if !visited[v] && dist[u]+weight < dist[v] {
                dist[v] = dist[u] + weight
            }
        }
    }

    for i, d := range dist {
        if i == start {
            continue
        }
        fmt.Printf("最短路径从 %d 到 %d 的距离为 %d\n", start, i, d)
    }
}

func main() {
    graph := [][]int{
        {0, 4, 0, 0, 0},
        {4, 0, 8, 0, 2},
        {0, 8, 0, 1, 0},
        {0, 0, 1, 0, 7},
        {0, 2, 0, 7, 0},
    }
    dijkstra(graph, 0)
}
```

**解析：** 迪杰斯特拉算法是一种基于贪心的最短路径算法，适用于图中所有边的权值均为非负数。算法的核心思想是逐步找到当前未访问节点中与已访问节点距离最短的节点，并将其标记为已访问。

#### 二、系统设计

##### 1. 负载均衡算法

**题目：** 实现常用的负载均衡算法，如轮询、加权轮询、最小连接数等。

**答案：**

```go
package loadbalancer

import (
    "fmt"
    "math/rand"
    "sort"
)

type Server struct {
    Id       int
    Weight   int
    Connections int
}

func RoundRobin(servers []Server) {
    for _, server := range servers {
        fmt.Printf("分配请求到服务器 %d\n", server.Id)
    }
}

func WeightedRoundRobin(servers []Server) {
    totalWeight := 0
    for _, server := range servers {
        totalWeight += server.Weight
    }

    for {
        sort.Slice(servers, func(i, j int) bool {
            return servers[i].Weight*servers[i].Connections < servers[j].Weight*servers[j].Connections
        })

        for i, server := range servers {
            if server.Weight*servers[i].Connections < totalWeight {
                totalWeight -= server.Weight
                fmt.Printf("分配请求到服务器 %d\n", server.Id)
                server.Connections++
            } else {
                break
            }
        }
    }
}

func LeastConnections(servers []Server) {
    sort.Slice(servers, func(i, j int) bool {
        return servers[i].Connections < servers[j].Connections
    })

    for _, server := range servers {
        fmt.Printf("分配请求到服务器 %d\n", server.Id)
        server.Connections++
    }
}
```

**解析：** 负载均衡算法用于将请求分配到多个服务器上，以提高系统的整体性能。轮询算法是最简单的负载均衡算法，将请求按顺序分配给服务器；加权轮询算法则根据服务器的权重分配请求；最小连接数算法则将请求分配给当前连接数最少的服务器。

##### 2. 分布式锁的实现

**题目：** 实现一个分布式锁，支持跨节点锁。

**答案：**

```go
package distributedlock

import (
    "context"
    "fmt"
    "time"
)

type Lock interface {
    Lock(ctx context.Context) error
    Unlock(ctx context.Context) error
}

type RedisLock struct {
    key   string
    client *redis.Client
}

func NewRedisLock(key string, client *redis.Client) *RedisLock {
    return &RedisLock{
        key:   key,
        client: client,
    }
}

func (l *RedisLock) Lock(ctx context.Context) error {
    return l.client.SetNX(ctx, l.key, "locked", time.Minute).Err()
}

func (l *RedisLock) Unlock(ctx context.Context) error {
    return l.client.Eval(ctx, "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end", 1, l.key, "locked").Err()
}
```

**解析：** 分布式锁用于在分布式系统中确保操作的全局一致性。该示例使用 Redis 实现分布式锁，通过 Redis 的 `SETNX` 命令实现加锁，通过 Lua 脚本实现解锁，确保锁的原子性。

#### 三、编程实践

##### 1.defer语句的使用

**题目：** 说明 defer 语句的作用和用法。

**答案：**

```go
package main

import "fmt"

func main() {
    defer fmt.Println(".defer 1")
    defer fmt.Println("defer 2")

    fmt.Println("main begin")
    foo()
}

func foo() {
    defer fmt.Println("defer 3")
    defer fmt.Println("defer 4")

    fmt.Println("foo begin")
    bar()
}

func bar() {
    defer fmt.Println("defer 5")

    fmt.Println("bar begin")
    fmt.Println("bar end")
    fmt.Println("bar defer")
}

// 输出：
// main begin
// foo begin
// bar begin
// bar end
// bar defer
// defer 3
// defer 4
// foo defer
// defer 1
// defer 2
```

**解析：** defer 语句用于在函数返回前执行一些操作，其执行顺序是后进先出。defer 语句可以用于资源清理、日志记录等场景，确保在函数返回时这些操作能正确执行。

##### 2. 错误处理

**题目：** 说明 Go 语言中的错误处理机制。

**答案：**

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("打开文件失败:", err)
        return
    }
    defer file.Close()

    buf := make([]byte, 1024)
    n, err := file.Read(buf)
    if err != nil {
        fmt.Println("读取文件失败:", err)
        return
    }

    fmt.Println("读取到", n, "个字节")
}
```

**解析：** Go 语言中的错误处理主要通过 if-err 语句和 defer 语句实现。if-err 语句用于检查错误，并根据错误值进行相应处理；defer 语句用于在函数返回前执行一些清理操作，避免资源泄露。

##### 3. 闭包

**题目：** 说明闭包的概念及其在 Go 语言中的应用。

**答案：**

```go
package main

import "fmt"

func main() {
    outer := "外部作用域的变量"
    func() {
        inner := "内部作用域的变量"
        fmt.Println("内部作用域的变量:", inner)
        fmt.Println("外部作用域的变量:", outer)
    }()
}

// 输出：
// 内部作用域的变量: 内部作用域的变量
// 外部作用域的变量: 外部作用域的变量
```

**解析：** 闭包是一个函数和与其相关的环境的组合体，通常用来封装一些状态。在 Go 语言中，闭包可以捕获其定义时的外部作用域的变量，并在函数内部访问和修改这些变量。闭包常用于回调函数、数据处理等场景。

#### 四、编程挑战

##### 1. 字符串替换

**题目：** 实现一个函数，将字符串中的指定子串替换为另一个字符串。

**答案：**

```go
package main

import (
    "fmt"
)

func replace(s, old, new string) string {
    if old == "" {
        return s
    }

    buf := &bytes.Buffer{}
    for i := 0; i < len(s); i++ {
        if strings.HasPrefix(s[i:], old) {
            buf.WriteString(new)
            i += len(old) - 1
        } else {
            buf.WriteByte(s[i])
        }
    }

    return buf.String()
}

func main() {
    s := "Hello, world!"
    old := "world"
    new := "Golang"
    fmt.Println(replace(s, old, new))
}
```

**解析：** 通过遍历字符串，判断当前位置是否以指定子串开头，如果是，则将其替换为新子串，否则将其原样写入缓冲区。这种方法避免了使用正则表达式，简化了代码。

##### 2. 去重

**题目：** 实现一个函数，从一个整数数组中删除重复元素。

**答案：**

```go
package main

import (
    "fmt"
)

func removeDuplicates(nums []int) []int {
    if len(nums) == 0 {
        return nums
    }

    n := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[n-1] {
            nums[n] = nums[i]
            n++
        }
    }

    return nums[:n]
}

func main() {
    nums := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}
    fmt.Println(removeDuplicates(nums))
}
```

**解析：** 通过遍历数组，将不重复的元素移动到数组的前部，然后返回前 n 个元素组成的新数组。这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。

##### 3. 合并区间

**题目：** 给定一个区间的列表，合并所有重叠的区间。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }

    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ans := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        prev := ans[len(ans)-1]
        curr := intervals[i]

        if prev[1] >= curr[0] {
            prev[1] = max(prev[1], curr[1])
        } else {
            ans = append(ans, curr)
        }
    }

    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := [][]int{
        {1, 3},
        {2, 6},
        {8, 10},
        {15, 18},
    }
    fmt.Println(merge(intervals))
}
```

**解析：** 首先将区间列表按起始位置排序，然后遍历区间列表，合并重叠的区间。这种方法的时间复杂度为 O(nlogn)，空间复杂度为 O(n)。

##### 4. 最小覆盖区间

**题目：** 给定一个区间列表，找到需要覆盖所有区间的最小区间。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func minCover(intervals [][]int) (start int, end int) {
    if len(intervals) == 0 {
        return
    }

    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    start, end = intervals[0][0], intervals[0][1]
    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] <= end {
            end = max(end, intervals[i][1])
        } else {
            start, end = intervals[i][0], intervals[i][1]
        }
    }

    return
}

func main() {
    intervals := [][]int{
        {1, 4},
        {2, 5},
        {6, 8},
        {7, 10},
        {12, 15},
    }
    start, end := minCover(intervals)
    fmt.Printf("最小覆盖区间为 [%d, %d]\n", start, end)
}
```

**解析：** 首先将区间列表按起始位置排序，然后遍历区间列表，找到需要覆盖所有区间的最小区间。这种方法的时间复杂度为 O(nlogn)，空间复杂度为 O(n)。

##### 5. 求根到叶节点数字之和

**题目：** 给定一个二叉树，求从根到每个叶节点的数字之和。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func sumRootToLeaf(root *TreeNode) int {
    return dfs(root, 0)
}

func dfs(root *TreeNode, prevSum int) int {
    if root == nil {
        return 0
    }

    currSum := prevSum*10 + root.Val
    if root.Left == nil && root.Right == nil {
        return currSum
    }

    return dfs(root.Left, currSum) + dfs(root.Right, currSum)
}

func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}
    root.Right.Right = &TreeNode{Val: 6}
    fmt.Println(sumRootToLeaf(root))
}
```

**解析：** 使用深度优先搜索（DFS）遍历二叉树，在每个节点上累加从根到当前节点的数字之和。如果当前节点是叶子节点，则返回其值。

##### 6. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，查找一个给定目标值。

**答案：**

```go
package main

import (
    "fmt"
)

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1

    for left <= right {
        mid := (left + right) / 2

        if nums[mid] == target {
            return mid
        }

        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[right] && target <= nums[left] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        }
    }

    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println(search(nums, target))
}
```

**解析：** 通过二分查找算法在旋转排序的数组中查找目标值。首先确定旋转点的位置，然后根据目标值和旋转点的位置关系更新左右边界。

##### 7. 最大子序和

**题目：** 给定一个整数数组，找出其中最大子序和。

**答案：**

```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }

    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println(maxSubArray(nums))
}
```

**解析：** 通过前缀和和贪心算法求解。遍历数组，对于当前元素，将其与当前前缀和相加，取两者中的较大值作为新的前缀和。

##### 8. 盗贼无法拿到的最大价值

**题目：** 给定一个整数数组，代表房屋中的物品价值，一个盗贼每次可以拿走相邻两间房屋中的物品，求盗贼无法拿到的最大价值。

**答案：**

```go
package main

import (
    "fmt"
)

func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    } else if len(nums) == 1 {
        return nums[0]
    }

    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }

    return dp[len(nums)-1]
}

func main() {
    nums := []int{2, 7, 9, 3, 1}
    fmt.Println(rob(nums))
}
```

**解析：** 使用动态规划求解。定义状态 dp[i] 为到达第 i 个房间时的最大价值。状态转移方程为 dp[i] = max(dp[i-1], dp[i-2]+nums[i])。

##### 9. 删除链表的节点

**题目：** 给定一个单链表，删除节点值为 val 的节点。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }

    if head.Val == val {
        return head.Next
    }

    curr := head
    for curr.Next != nil && curr.Next.Val != val {
        curr = curr.Next
    }

    if curr.Next != nil {
        curr.Next = curr.Next.Next
    }

    return head
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next = &ListNode{Val: 5}

    fmt.Println(deleteNode(head, 3).Val)
}
```

**解析：** 通过遍历链表，找到值为 val 的节点，并将其删除。

##### 10. 字符串中的最大单词长度

**题目：** 给定一个字符串，求其中单词的最大长度。

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

func maxWordLength(s string) int {
    words := strings.Fields(s)
    maxLen := 0

    for _, word := range words {
        if len(word) > maxLen {
            maxLen = len(word)
        }
    }

    return maxLen
}

func main() {
    s := "hello world"
    fmt.Println(maxWordLength(s))
}
```

**解析：** 使用字符串的 Fields 函数将字符串分割为单词，然后遍历单词，找到最大长度。

##### 11. 求两个数的最大公约数

**题目：** 给定两个整数，求它们的最大公约数。

**答案：**

```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        t := b
        b = a % b
        a = t
    }
    return a
}

func main() {
    a := 60
    b := 48
    fmt.Println(gcd(a, b))
}
```

**解析：** 使用辗转相除法求解最大公约数。

##### 12. 求两个数的最小公倍数

**题目：** 给定两个整数，求它们的最小公倍数。

**答案：**

```go
package main

import (
    "fmt"
)

func lcm(a, b int) int {
    return a / gcd(a, b) * b
}

func main() {
    a := 15
    b := 20
    fmt.Println(lcm(a, b))
}
```

**解析：** 使用最大公约数求解最小公倍数。

##### 13. 求字符串的长度

**题目：** 给定一个字符串，求其长度。

**答案：**

```go
package main

import (
    "fmt"
)

func stringLength(s string) int {
    return len(s)
}

func main() {
    s := "Hello, world!"
    fmt.Println(stringLength(s))
}
```

**解析：** 直接使用字符串的 Len 方法。

##### 14. 判断字符串是否为回文

**题目：** 给定一个字符串，判断其是否为回文。

**答案：**

```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    n := len(s)
    for i := 0; i < n/2; i++ {
        if s[i] != s[n-i-1] {
            return false
        }
    }
    return true
}

func main() {
    s := "racecar"
    fmt.Println(isPalindrome(s))
}
```

**解析：** 通过比较字符串的首尾字符，判断字符串是否为回文。

##### 15. 判断字符串是否为数字

**题目：** 给定一个字符串，判断其是否为数字。

**答案：**

```go
package main

import (
    "fmt"
)

func isNumber(s string) bool {
    _, err := strconv.ParseFloat(s, 64)
    return err == nil
}

func main() {
    s := "123.456"
    fmt.Println(isNumber(s))
}
```

**解析：** 使用字符串转换为浮点数的函数，判断是否成功。

##### 16. 判断字符串是否为日期格式

**题目：** 给定一个字符串，判断其是否为日期格式（年-月-日）。

**答案：**

```go
package main

import (
    "fmt"
    "regexp"
)

func isDate(s string) bool {
    matched, _ := regexp.MatchString(`^\d{4}-\d{2}-\d{2}$`, s)
    return matched
}

func main() {
    s := "2023-03-14"
    fmt.Println(isDate(s))
}
```

**解析：** 使用正则表达式判断字符串是否符合日期格式。

##### 17. 删除字符串中的所有空格

**题目：** 给定一个字符串，删除其中的所有空格。

**答案：**

```go
package main

import (
    "fmt"
)

func removeSpaces(s string) string {
    return strings.Replace(s, " ", "", -1)
}

func main() {
    s := "Hello, world!"
    fmt.Println(removeSpaces(s))
}
```

**解析：** 使用字符串的 Replace 方法删除空格。

##### 18. 将字符串转换为整数

**题目：** 给定一个字符串，将其转换为整数。

**答案：**

```go
package main

import (
    "fmt"
    "strconv"
)

func stringToInteger(s string) int {
    i, err := strconv.Atoi(s)
    if err != nil {
        return 0
    }
    return i
}

func main() {
    s := "123"
    fmt.Println(stringToInteger(s))
}
```

**解析：** 使用字符串转换为整数的函数。

##### 19. 将整数转换为字符串

**题目：** 给定一个整数，将其转换为字符串。

**答案：**

```go
package main

import (
    "fmt"
    "strconv"
)

func integerToString(i int) string {
    return strconv.Itoa(i)
}

func main() {
    i := 123
    fmt.Println(integerToString(i))
}
```

**解析：** 使用整数转换为字符串的函数。

##### 20. 判断字符串是否为有效邮箱

**题目：** 给定一个字符串，判断其是否为有效邮箱。

**答案：**

```go
package main

import (
    "fmt"
    "regexp"
)

func isValidEmail(s string) bool {
    matched, _ := regexp.MatchString(`^\S+@\S+\.\S+$`, s)
    return matched
}

func main() {
    s := "test@example.com"
    fmt.Println(isValidEmail(s))
}
```

**解析：** 使用正则表达式判断字符串是否符合邮箱格式。

##### 21. 判断字符串是否为有效URL

**题目：** 给定一个字符串，判断其是否为有效URL。

**答案：**

```go
package main

import (
    "fmt"
    "regexp"
)

func isValidURL(s string) bool {
    matched, _ := regexp.MatchString(`^(http|https)://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}(/[a-zA-Z0-9._%&=+]*)?/?([a-zA-Z0-9._%&=+]*)?$`, s)
    return matched
}

func main() {
    s := "https://www.example.com/path/to/resource"
    fmt.Println(isValidURL(s))
}
```

**解析：** 使用正则表达式判断字符串是否符合URL格式。

##### 22. 计算字符串中单词的个数

**题目：** 给定一个字符串，计算其中单词的个数。

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

func countWords(s string) int {
    return len(strings.Fields(s))
}

func main() {
    s := "Hello, world! This is a test."
    fmt.Println(countWords(s))
}
```

**解析：** 使用字符串的 Fields 方法分割单词，然后计算单词的个数。

##### 23. 字符串中的最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长的公共前缀。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for _, str := range strs[1:] {
        for i := 0; i < len(prefix) && i < len(str); i++ {
            if prefix[i] != str[i] {
                prefix = prefix[:i]
                break
            }
        }
    }

    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs))
}
```

**解析：** 通过比较每个字符串的公共前缀，找到最长的公共前缀。

##### 24. 字符串的翻转

**题目：** 给定一个字符串，将其翻转。

**答案：**

```go
package main

import (
    "fmt"
)

func reverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i := 0; i < n/2; i++ {
        runes[i], runes[n-i-1] = runes[n-i-1], runes[i]
    }
    return string(runes)
}

func main() {
    s := "Hello, world!"
    fmt.Println(reverseString(s))
}
```

**解析：** 将字符串转换为 runes，然后通过交换首尾字符实现翻转。

##### 25. 求字符串中出现次数最多的子串

**题目：** 给定一个字符串，求其中出现次数最多的子串。

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

func mostFrequentSubstring(s string) string {
    cnt := make(map[string]int)
    n := len(s)
    for i := 0; i < n; i++ {
        for j := i + 1; j <= n; j++ {
            cnt[s[i:j]]++
        }
    }
    maxCount := 0
    maxSubstring := ""
    for substr, count := range cnt {
        if count > maxCount {
            maxCount = count
            maxSubstring = substr
        }
    }
    return maxSubstring
}

func main() {
    s := "Hello, world!Hello, world!Hello, world!"
    fmt.Println(mostFrequentSubstring(s))
}
```

**解析：** 通过遍历字符串的所有子串，统计每个子串出现的次数，然后找到出现次数最多的子串。

##### 26. 字符串中的最长重复子串

**题目：** 给定一个字符串，找出其中最长重复的子串。

**答案：**

```go
package main

import (
    "fmt"
)

func longestRepeatingSubstring(s string) string {
    n := len(s)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= n; j++ {
            if s[i-1] == s[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > 0 && dp[i][j] > len(maxSubstring) {
                    maxSubstring = s[i-dp[i][j]:i]
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return maxSubstring
}
```go
### 华为2024社招编程面试题精选与答案解析

在华为的社招编程面试中，常见的面试题涵盖了算法、数据结构、系统设计、编程实践等多个领域。以下精选了华为2024社招编程面试中的典型问题，并提供了详细的答案解析和源代码实例。

#### 一、算法与数据结构

##### 1. 单链表的反转

**题目：** 实现一个函数，反转一个单链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head

    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    newHead := reverseList(head)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 使用头插法反转单链表，通过迭代方式实现。每次迭代将当前节点插入到prev节点之前。

##### 2. 二分查找

**题目：** 实现一个二分查找函数，用于在有序数组中查找某个元素。

**答案：**

```go
package main

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

func main() {
    nums := []int{1, 3, 5, 6, 9, 11}
    target := 5
    result := search(nums, target)
    if result != -1 {
        fmt.Println("元素在数组中的索引为：", result)
    } else {
        fmt.Println("元素不在数组中。")
    }
}
```

**解析：** 二分查找是一种高效的搜索算法，时间复杂度为O(logn)。通过不断缩小区间来查找目标元素。

##### 3. 逆波兰表达式求值

**题目：** 实现一个函数，计算逆波兰表达式（Postfix Expression）的值。

**答案：**

```go
package main

func evalRPN(tokens []string) int {
    var stack []int
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a/b)
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(s string) int {
    i, _ := strconv.Atoi(s)
    return i
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    result := evalRPN(tokens)
    fmt.Println("逆波兰表达式的值为：", result)
}
```

**解析：** 使用栈模拟逆波兰表达式的计算过程，根据操作符进行相应的计算。

#### 二、系统设计与架构

##### 1. 简单的缓存实现

**题目：** 实现一个简单的缓存系统，支持添加、获取和删除操作。

**答案：**

```go
package main

import "sync"

type Cache struct {
    sync.Mutex
    map map[string]interface{}
    capacity int
}

func NewCache(capacity int) *Cache {
    return &Cache{
        map: make(map[string]interface{}),
        capacity: capacity,
    }
}

func (c *Cache) Add(key string, value interface{}) {
    c.Lock()
    defer c.Unlock()
    c.map[key] = value
    if len(c.map) > c.capacity {
        delete(c.map, c.map[0])
    }
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.Lock()
    defer c.Unlock()
    val, ok := c.map[key]
    return val, ok
}

func (c *Cache) Remove(key string) {
    c.Lock()
    defer c.Unlock()
    delete(c.map, key)
}

func main() {
    cache := NewCache(2)
    cache.Add("a", 1)
    cache.Add("b", 2)
    fmt.Println(cache.Get("a"))
    cache.Remove("a")
    fmt.Println(cache.Get("a"))
}
```

**解析：** 使用互斥锁（Mutex）保护并发访问，实现缓存的基本操作。当缓存容量超过设定的容量时，删除最旧的条目。

##### 2. 事件驱动模型

**题目：** 使用事件驱动模型实现一个简单的并发程序。

**答案：**

```go
package main

import (
    "fmt"
    "sync"
)

var wg sync.WaitGroup

func handleEvent(event string) {
    fmt.Println("处理事件:", event)
    wg.Done()
}

func main() {
    events := []string{"事件1", "事件2", "事件3"}
    for _, event := range events {
        wg.Add(1)
        go handleEvent(event)
    }
    wg.Wait()
}
```

**解析：** 使用 WaitGroup 等待所有事件处理完成。通过 goroutine 实现事件并行处理。

##### 3. 状态机

**题目：** 实现一个简单的状态机，处理用户登录和登出操作。

**答案：**

```go
package main

import (
    "fmt"
)

type UserState interface {
    Login() string
    Logout() string
}

type LoggedOut struct{}
type LoggedIn struct{}

func (LoggedOut) Login() string {
    return "登录成功"
}

func (LoggedIn) Logout() string {
    return "登出成功"
}

func main() {
    user := LoggedOut{}
    fmt.Println(user.Login())
    user = LoggedIn{}
    fmt.Println(user.Logout())
}
```

**解析：** 通过接口实现状态机。用户可以根据当前状态调用相应的操作。

#### 三、编程实践

##### 1. 时间转换

**题目：** 将一个表示时间的字符串转换为24小时制。

**答案：**

```go
package main

import (
    "fmt"
    "regexp"
)

func convertTime(timeStr string) (string, error) {
    matched, _ := regexp.MatchString(`^\d{1,2}:\d{2}$`, timeStr)
    if !matched {
        return "", fmt.Errorf("无效的时间格式")
    }
    hour, _ := strconv.Atoi(timeStr[:2])
    minute, _ := strconv.Atoi(timeStr[3:])
    if hour > 23 || minute > 59 {
        return "", fmt.Errorf("时间超出范围")
    }
    if hour >= 12 {
        hour -= 12
        if hour == 0 {
            hour = 12
        }
        suffix := "PM"
        if hour == 12 {
            suffix = "PM"
        }
    } else {
        suffix = "AM"
    }
    return fmt.Sprintf("%d:%02d %s", hour, minute, suffix), nil
}

func main() {
    timeStr := "15:45"
    result, err := convertTime(timeStr)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(result)
    }
}
```

**解析：** 使用正则表达式匹配时间格式，并转换为12小时制。如果时间超出范围，返回错误。

##### 2. 判断是否为合法IP地址

**题目：** 给定一个字符串，判断其是否为合法的IP地址。

**答案：**

```go
package main

import (
    "fmt"
    "regexp"
)

func isValidIP(ip string) bool {
    matched, _ := regexp.MatchString(`^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$`, ip)
    return matched
}

func main() {
    ip := "192.168.1.1"
    if isValidIP(ip) {
        fmt.Println(ip, "是一个合法的IP地址")
    } else {
        fmt.Println(ip, "不是一个合法的IP地址")
    }
}
```

**解析：** 使用正则表达式匹配IP地址的格式。每个部分必须在0到255的范围内。

##### 3. 计算器

**题目：** 实现一个简单的计算器，支持加、减、乘、除四种运算。

**答案：**

```go
package main

import (
    "fmt"
    "strconv"
)

func calculate(expression string) (float64, error) {
    tokens := tokenize(expression)
    stack := make([]float64, 0)
    ops := make(map[string]func(float64, float64) float64)

    ops["+"] = func(a, b float64) float64 { return a + b }
    ops["-"] = func(a, b float64) float64 { return a - b }
    ops["*"] = func(a, b float64) float64 { return a * b }
    ops["/"] = func(a, b float64) float64 { return a / b }

    for _, token := range tokens {
        if val, ok := ops[token]; ok {
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            result := val(a, b)
            stack = append(stack, result)
        } else {
            num, err := strconv.ParseFloat(token, 64)
            if err != nil {
                return 0, err
            }
            stack = append(stack, num)
        }
    }

    return stack[0], nil
}

func tokenize(expression string) []string {
    var tokens []string
    var token string
    for _, c := range expression {
        if c == '+' || c == '-' || c == '*' || c == '/' {
            if token != "" {
                tokens = append(tokens, token)
                token = string(c)
            } else {
                token = string(c)
            }
        } else {
            token += string(c)
        }
    }
    if token != "" {
        tokens = append(tokens, token)
    }
    return tokens
}

func main() {
    expression := "3 + 4 * 2 / ( 1 - 5 )"
    result, err := calculate(expression)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(expression, "的结果为：", result)
    }
}
```

**解析：** 使用逆波兰表达式（RPN）计算器，通过分词和栈实现。

#### 四、编程挑战

##### 1. 合并两个有序链表

**题目：** 将两个有序链表合并为一个有序链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 通过递归合并两个有序链表。

##### 2. 求最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

```go
package main

func longestCommonSubsequence(text1 string, text2 string) string {
    dp := make([][]int, len(text1)+1)
    for i := range dp {
        dp[i] = make([]int, len(text2)+1)
        for j := range dp[i] {
            if i == 0 || j == 0 {
                dp[i][j] = 0
            } else if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    idx := dp[len(text1)][len(text2)]
    res := make([]byte, idx)
    i, j := len(text1), len(text2)
    for idx > 0 {
        if text1[i-1] == text2[j-1] {
            res[idx-1] = text1[i-1]
            i--
            j--
            idx--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(res)
}

func main() {
    text1 := "ABCBDAB"
    text2 := "BDCABC"
    fmt.Println("最长公共子序列为：", longestCommonSubsequence(text1, text2))
}
```

**解析：** 使用动态规划求解最长公共子序列，然后回溯找出具体的子序列。

##### 3. 删除链表的节点

**题目：** 给定一个链表和一个节点，删除链表中的节点。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func deleteNode(head *ListNode, node *ListNode) *ListNode {
    if head == nil || node == nil {
        return head
    }
    if head == node {
        return head.Next
    }
    prev := head
    for prev.Next != nil && prev.Next != node {
        prev = prev.Next
    }
    if prev.Next == node {
        prev.Next = node.Next
    }
    return head
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next = &ListNode{Val: 5}
    node := head.Next.Next
    newHead := deleteNode(head, node)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 通过遍历找到需要删除的节点，然后将其前一个节点的next指向当前节点的next。

##### 4. 最小路径和

**题目：** 给定一个二维数组，找出从左上角到右下角的最小路径和。

**答案：**

```go
package main

func minPathSum(grid [][]int) int {
    rows, cols := len(grid), len(grid[0])
    dp := make([][]int, rows+1)
    for i := range dp {
        dp[i] = make([]int, cols+1)
    }
    for i := 1; i <= rows; i++ {
        for j := 1; j <= cols; j++ {
            dp[i][j] = grid[i-1][j-1] + min(dp[i-1][j], dp[i][j-1])
        }
    }
    return dp[rows][cols]
}

func main() {
    grid := [][]int{
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1},
    }
    fmt.Println("最小路径和为：", minPathSum(grid))
}
```

**解析：** 使用动态规划求解。dp[i][j] 表示从左上角到(i, j)的最小路径和。

##### 5. 合并两个有序数组

**题目：** 给定两个有序数组，将它们合并为一个新的有序数组。

**答案：**

```go
package main

func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    t := len(nums1)-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[t] = nums1[p1]
            p1--
        } else {
            nums1[t] = nums2[p2]
            p2--
        }
        t--
    }
    for p2 >= 0 {
        nums1[t] = nums2[p2]
        p2--
        t--
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    m := 3
    nums2 := []int{2, 5, 6}
    n := 3
    merge(nums1, m, nums2, n)
    for _, v := range nums1 {
        fmt.Println(v)
    }
}
```

**解析：** 通过两个指针从后向前比较，将较大的元素放到nums1的尾部。

##### 6. 最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长的公共前缀。

**答案：**

```go
package main

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println("最长公共前缀为：", longestCommonPrefix(strs))
}
```

**解析：** 通过逐个字符比较，找出最长公共前缀。

##### 7. 字符串相乘

**题目：** 给定两个字符串表示的非负整数，实现一个函数，计算它们的乘积。

**答案：**

```go
package main

func multiply(num1 string, num2 string) string {
    n1, n2 := len(num1), len(num2)
    var result [20000]int8
    var i, j int8
    for i = int8(0); i < n1; i++ {
        for j = int8(0); j < n2; j++ {
            result[i+j] += int8((num1[i] - '0') * (num2[j] - '0'))
        }
    }
    carry := int8(0)
    for i = int8(0); i < n1+n2; i++ {
        result[i] += carry
        carry = result[i] / 10
        result[i] %= 10
    }
    ans := ""
    for ; carry > 0 || result[n1+n2-1] > 0; n1+n2-- {
        ans = strconv.FormatInt(int64(result[n1+n2-1]), 10) + ans
    }
    return ans
}

func main() {
    num1 := "123"
    num2 := "456"
    fmt.Println("字符串乘积为：", multiply(num1, num2))
}
```

**解析：** 使用数组模拟乘法运算，注意进位处理。

##### 8. 颠倒整数

**题目：** 给定一个整数，将其颠倒。

**答案：**

```go
package main

func reverse(x int) int {
    const intMax = int32(1<<31 - 1)
    res := int32(0)
    for x > 0 {
        if res > intMax/10 || (res == intMax/10 && x%10 > 7) {
            return 0
        }
        res = res*10 + int32(x%10)
        if res > intMax || res < -intMax-1 {
            return 0
        }
        x /= 10
    }
    return int(res)
}

func main() {
    x := 123
    fmt.Println("颠倒后的整数为：", reverse(x))
}
```

**解析：** 通过取模和除法逐步取出整数的每一位，构建新的整数。

##### 9. 寻找两个正序数组的中位数

**题目：** 给定两个排序后的整数数组，找出它们的中位数。

**答案：**

```go
package main

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i == m {
                minRight = nums2[j]
            } else if j == n {
                minRight = nums1[i]
            } else {
                minRight = min(nums1[i], nums2[j])
            }
            return float64(maxLeft+minRight)/2
        }
    }
    return 0
}

func main() {
    nums1 := []int{1, 2}
    nums2 := []int{3, 4}
    fmt.Println("中位数为：", findMedianSortedArrays(nums1, nums2))
}
```

**解析：** 使用二分查找算法找到中位数，通过比较两个数组的中间元素，逐步缩小搜索范围。

##### 10. 找到旋转排序数组中的最小值

**题目：** 给定一个旋转排序的数组，找出数组中的最小元素。

**答案：**

```go
package main

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    fmt.Println("最小值为：", findMin(nums))
}
```

**解析：** 通过二分查找算法在旋转排序的数组中找到最小值。当 mid 的值大于 right 时，最小值在 mid 的右侧；否则在 mid 的左侧。

##### 11. 汇总区间

**题目：** 给定一个整数数组，返回其中所有区间的汇总。

**答案：**

```go
package main

func summaryRanges(nums []int) []string {
    if len(nums) == 0 {
        return nil
    }
    var ans []string
    for i, num := range nums {
        if i > 0 && num != nums[i-1]+1 {
            if nums[i-1]-nums[i]+1 == 1 {
                ans = append(ans, fmt.Sprintf("[%d]", nums[i-1]))
            } else {
                ans = append(ans, fmt.Sprintf("[%d,%d]", nums[i-1], nums[i-1]))
            }
        }
        for i < len(nums)-1 && num+1 == nums[i+1] {
            i++
            num++
        }
        if i == len(nums)-1 || num != nums[i+1]-1 {
            if num == nums[i+1]-1 {
                ans = append(ans, fmt.Sprintf("[%d]", num))
            } else {
                ans = append(ans, fmt.Sprintf("[%d,%d]", num, num))
            }
        }
    }
    return ans
}

func main() {
    nums := []int{0, 1, 2, 4, 5, 7}
    result := summaryRanges(nums)
    for _, r := range result {
        fmt.Println(r)
    }
}
```

**解析：** 通过遍历数组，判断当前元素和前一个元素的关系，构建区间的字符串表示。如果当前元素和前一个元素相差1，则构建单个元素的区间；如果相差大于1，则构建连续元素的区间。

##### 12. 组合总和

**题目：** 给定一个无重复元素的数组 candidates 和一个目标数 target，找出 candidates 中所有可以使数字和为 target 的组合。

**答案：**

```go
package main

var res [][]int

func combinationSum(candidates []int, target int) [][]int {
    sort.Ints(candidates)
    backtrack(candidates, target, 0, []int{})
    return res
}

func backtrack(candidates []int, target, start int, current []int) {
    if target < 0 {
        return
    }
    if target == 0 {
        res = append(res, append([]int{}, current...))
        return
    }
    for i := start; i < len(candidates); i++ {
        current = append(current, candidates[i])
        backtrack(candidates, target-candidates[i], i, current)
        current = current[:len(current)-1]
    }
}

func main() {
    candidates := []int{2, 3, 6, 7}
    target := 7
    result := combinationSum(candidates, target)
    for _, c := range result {
        fmt.Println(c)
    }
}
```

**解析：** 使用回溯算法，从 start 位置开始选择元素，直到找到所有可能的组合。如果当前组合的数字和小于 target，则继续递归；如果等于 target，则将当前组合添加到结果中；如果大于 target，则回溯。

##### 13. 合并两个有序链表

**题目：** 给定两个有序的链表，将它们合并为一个新的有序链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 通过比较两个链表的当前节点，选择较小的值作为下一个节点，递归地合并两个链表。

##### 14. 最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**答案：**

```go
package main

func longestCommonSubstr(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen, maxEnd := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    maxEnd = i - 1
                }
            }
        }
    }
    if maxLen == 0 {
        return ""
    }
    return s1[maxEnd-maxLen+1 : maxEnd+1]
}

func main() {
    s1 := "abcde"
    s2 := "ace"
    fmt.Println("最长公共子串为：", longestCommonSubstr(s1, s2))
}
```

**解析：** 使用动态规划求解最长公共子串，通过二维数组记录子串的长度。最后根据最大长度和结束位置，返回最长公共子串。

##### 15. 打家劫舍

**题目：** 你是一个盗贼，计划偷窃一条直线上的房屋，每间房内都藏有一定的现金。你不能盗窃两间相邻的房屋，计算你最多可以偷窃多少现金。

**答案：**

```go
package main

func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    return max(rob(nums[:len(nums)-1]), rob(nums[1:]))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{1, 2, 3, 1}
    fmt.Println("最多可以偷窃的现金为：", rob(nums))
}
```

**解析：** 使用递归和记忆化搜索，状态转移方程为 f(n) = max(f(n-1), f(n-2) + nums[n-1])。

##### 16. 删除链表的倒数第N个节点

**题目：** 给定一个链表，删除链表的倒数第 N 个节点，并返回链表的头结点。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Val: 0, Next: head}
    slow, fast := dummy, head
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}
    newHead := removeNthFromEnd(head, 2)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 使用快慢指针法，快指针先走N步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针即为倒数第N个节点。

##### 17. 有效的括号字符串

**题目：** 给定一个只包含 '('，')'，'{'，'}'，'['，']' 的字符串，判断是否有效。

**答案：**

```go
package main

func isValid(s string) bool {
    stack := []rune{}
    open := "([{"
    close := ")]}"
    for _, c := range s {
        if strContains(open, string(c)) {
            stack = append(stack, c)
        } else if strContains(close, string(c)) {
            if len(stack) == 0 || open[strings.Index(open, string(stack[len(stack)-1]))] != string(c) {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}

func strContains(s, substr string) bool {
    return strings.Contains(s, substr)
}

func main() {
    s := "()[]{}"
    fmt.Println("是否有效：", isValid(s))
}
```

**解析：** 使用栈实现，遇到左括号入栈，遇到右括号则出栈并比较。如果栈为空或者括号不匹配，则字符串无效。

##### 18. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    newHead := mergeTwoLists(l1, l2)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 通过递归合并两个链表，每次选择较小的值。

##### 19. 字符串匹配

**题目：** 给定一个文本字符串和一个模式字符串，实现一个支持 '.' 和 '*' 的正则表达式搜索的函数。

**答案：**

```go
package main

func isMatch(s string, p string) bool {
    dp := make([][]bool, len(s)+1)
    for i := range dp {
        dp[i] = make([]bool, len(p)+1)
        dp[i][0] = true
    }
    for j := 1; j <= len(p); j++ {
        dp[0][j] = false
        if p[j-1] == '*' {
            dp[0][j] = dp[0][j-2]
        }
    }
    for i := 1; i <= len(s); i++ {
        for j := 1; j <= len(p); j++ {
            if s[i-1] == p[j-1] || p[j-1] == '.' {
                dp[i][j] = dp[i-1][j-1]
            } else if p[j-1] == '*' {
                dp[i][j] = dp[i][j-2] || dp[i-1][j]
                if s[i-1] == p[j-2] || p[j-2] == '.' {
                    dp[i][j] = dp[i][j] || dp[i-2][j]
                }
            } else {
                dp[i][j] = false
            }
        }
    }
    return dp[len(s)][len(p)]
}

func main() {
    s := "aab"
    p := "c*a*b"
    fmt.Println("匹配结果：", isMatch(s, p))
}
```

**解析：** 使用动态规划实现正则表达式匹配，dp[i][j] 表示文本的前i个字符和模式的前j个字符是否匹配。

##### 20. 合并K个排序链表

**题目：** 给定K个排序后的链表，合并它们为一个新的排序链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    for len(lists) > 1 {
        lists = mergeTwoLists(lists[0], lists[1])
        lists = lists[1:]
    }
    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    lists := []*ListNode{
        &ListNode{Val: 1, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}},
        &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}},
        &ListNode{Val: 2, Next: &ListNode{Val: 6}},
    }
    newHead := mergeKLists(lists)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 使用分治策略，不断合并两个链表，直到所有链表合并为一个。

##### 21. 颠倒二叉树

**题目：** 翻转一棵二叉树。

**答案：**

```go
package main

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    temp := root.Left
    root.Left = invertTree(root.Right)
    root.Right = invertTree(temp)
    return root
}

func main() {
    root := &TreeNode{Val: 4, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 1, Left: nil, Right: nil}, Right: &TreeNode{Val: 3, Left: nil, Right: nil}}, Right: &TreeNode{Val: 7, Left: &TreeNode{Val: 6, Left: nil, Right: nil}, Right: &TreeNode{Val: 9, Left: nil, Right: nil}}}
    newRoot := invertTree(root)
    for newRoot != nil {
        fmt.Println(newRoot.Val)
        newRoot = newRoot.Right
    }
}
```

**解析：** 使用递归翻转二叉树的左右子树，然后交换左右子树。

##### 22. 删除链表的节点

**题目：** 给定一个单链表，删除某个节点。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    prev := head
    curr := head.Next
    for curr != nil && curr.Val != val {
        prev = curr
        curr = curr.Next
    }
    if curr != nil {
        prev.Next = curr.Next
    }
    return head
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}}
    newHead := deleteNode(head, 3)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 遍历链表，找到值为val的节点，然后将其删除。

##### 23. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    newHead := mergeTwoLists(l1, l2)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 通过比较两个链表的当前节点，选择较小的值作为下一个节点，递归地合并两个链表。

##### 24. 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```go
package main

func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
        for j := range dp[i] {
            if i == 0 || j == 0 {
                dp[i][j] = 0
            } else if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    idx := dp[m][n]
    res := make([]byte, idx)
    i, j := m, n
    for idx > 0 {
        if text1[i-1] == text2[j-1] {
            res[idx-1] = text1[i-1]
            i--
            j--
            idx--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(res)
}

func main() {
    text1 := "ABCBDAB"
    text2 := "BDCABC"
    fmt.Println("最长公共子序列为：", longestCommonSubsequence(text1, text2))
}
```

**解析：** 使用动态规划求解最长公共子序列，然后回溯找出具体的子序列。

##### 25. 合并K个排序链表

**题目：** 给定K个排序后的链表，合并它们为一个新的排序链表。

**答案：**

```go
package main

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    for len(lists) > 1 {
        lists = mergeTwoLists(lists[0], lists[1])
        lists = lists[1:]
    }
    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    lists := []*ListNode{
        &ListNode{Val: 1, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}},
        &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}},
        &ListNode{Val: 2, Next: &ListNode{Val: 6}},
    }
    newHead := mergeKLists(lists)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 使用分治策略，不断合并两个链表，直到所有链表合并为一个。

##### 26. 最长递增子序列

**题目：** 给定一个整数数组，返回它的最长递增子序列的长度。

**答案：**

```go
package main

func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    fmt.Println("最长递增子序列的长度为：", lengthOfLIS(nums))
}
```

**解析：** 使用动态规划求解最长递增子序列的长度，dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。

##### 27. 有效的括号字符串

**题目：** 给定一个只包含 '('，')'，'{'，'}'，'['，']' 的字符串，判断是否有效。

**答案：**

```go
package main

func isValid(s string) bool {
    stack := []rune{}
    open := "([{"
    close := ")]}"
    for _, c := range s {
        if strContains(open, string(c)) {
            stack = append(stack, c)
        } else if strContains(close, string(c)) {
            if len(stack) == 0 || open[strings.Index(open, string(stack[len(stack)-1]))] != string(c) {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}

func strContains(s, substr string) bool {
    return strings.Contains(s, substr)
}

func main() {
    s := "([{}])"
    fmt.Println("是否有效：", isValid(s))
}
```

**解析：** 使用栈实现，遇到左括号入栈，遇到右括号则出栈并比较。如果栈为空或者括号不匹配，则字符串无效。

##### 28. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

**答案：**

```go
package main

func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    t := len(nums1)-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[t] = nums1[p1]
            p1--
        } else {
            nums1[t] = nums2[p2]
            p2--
        }
        t--
    }
    for p2 >= 0 {
        nums1[t] = nums2[p2]
        p2--
        t--
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    m := 3
    nums2 := []int{2, 5, 6}
    n := 3
    merge(nums1, m, nums2, n)
    for _, v := range nums1 {
        fmt.Println(v)
    }
}
```

**解析：** 通过两个指针从后向前比较，将较大的元素放到nums1的尾部。

##### 29. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个搜索函数，搜索一个给定目标值。

**答案：**

```go
package main

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[right] && target <= nums[left] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        }
    }
    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println("目标值的索引为：", search(nums, target))
}
```

**解析：** 使用二分查找算法，在旋转排序的数组中查找目标值。首先确定旋转点的位置，然后根据目标值和旋转点的位置关系更新左右边界。

##### 30. 最小覆盖区间

**题目：** 给定一个区间列表，找到需要覆盖所有区间的最小区间。

**答案：**

```go
package main

func minCover(intervals [][]int) (start int, end int) {
    if len(intervals) == 0 {
        return
    }

    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    start, end = intervals[0][0], intervals[0][1]
    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] <= end {
            end = max(end, intervals[i][1])
        } else {
            start, end = intervals[i][0], intervals[i][1]
        }
    }

    return
}

func main() {
    intervals := [][]int{
        {1, 4},
        {2, 5},
        {6, 8},
        {7, 10},
        {12, 15},
    }
    start, end := minCover(intervals)
    fmt.Printf("最小覆盖区间为 [%d, %d]\n", start, end)
}
```

**解析：** 首先将区间列表按起始位置排序，然后遍历区间列表，找到需要覆盖所有区间的最小区间。这种方法的时间复杂度为 O(nlogn)，空间复杂度为 O(n)。

