
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


回文串（Palindrome）是一个关于单词、数字、符号等书写顺序而言的字符串，正向阅读和反向阅读都一样的单词或句子就是回文串。例如："racecar", "level"，"noon"等都是回文串。回文串的一个重要应用场景在于用来检查、验证用户输入是否正确。比如当用户注册时，要求输入一个包含数字、字母或者特殊字符的密码，如果用户输入了不合法的密码，则需要提示用户重新输入；另一种应用场景是在搜索引擎中检索关键字。搜索引擎会对用户查询的关键字进行分词，然后将其倒序排列形成一个新的字符串，然后进行比较。如果新生成的字符串与原始查询字符串相同，那么这个查询字符串就是一个回文字符串。对于一些比较复杂的任务来说，比如寻找两个字符串中的最长公共子序列（Longest Common Subsequence），也有着巨大的价值。这些任务通常用动态规划来解决。本文主要讨论如何有效地检测一个给定的字符串是否是回文字符串的问题。

# 2.核心概念与联系
回文串算法包括三个基本概念：正向扫描、逆向扫描以及中心扩展。正向扫描：从左向右读取字符串，通过判断当前位置和下一个位置是否匹配来进行扫描，直到扫描完成。逆向扫描：从右向左读取字符串，同样通过判断当前位置和上一个位置是否匹配来进行扫描，直到扫描完成。中心扩展：当某个字符与相邻的字符匹配且扫描方向是左右的情况，可以认为此时的扫描范围可以扩大，称为中心扩展。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 3.1 判断回文字符串
首先定义什么是回文串。所谓的回文串，是指一个字符串从左往右读和从右往左读都是一样的，比如“level”、“radar”、“civic”，等等。
### 3.1.1 暴力法
暴力法很简单，遍历整个字符串两次，每次比较前后两个字符是否相同，相同就继续，否则不是回文串。这种算法的时间复杂度是O(n^2)，不可取。
```python
def is_palindrome(s):
    n = len(s)
    for i in range(n//2):
        if s[i]!= s[n-i-1]:
            return False
    return True
```
### 3.1.2 正向扫描
正向扫描算法比较好理解，即从左向右读取字符串，判断当前位置和下一个位置是否匹配，如匹配则继续，不匹配则不是回文串。
#### 3.1.2.1 判断回文字符串的中心扩展算法
中心扩展算法：当某字符与相邻的字符匹配且扫描方向是左右的情况，那么可以认为该字符串可延伸至更大的回文串，直至回文串的边界。中心扩展可以有效减少字符串被标记为不是回文串的次数。
```python
def palindrome_check(s: str)-> bool:
    """
    函数功能：判断一个字符串是否是回文字符串
    :param s: str 待判断的字符串
    :return: bool 是否为回文字符串
    """
    # 将字符串转换为列表类型方便遍历
    lst = list(s)

    # 设置扫描的起点和终点
    left, right = 0, len(lst)-1
    
    while left < right:

        # 如果当前位置的字符与其相邻的字符不匹配，则不是回文串
        if lst[left]!= lst[right]:
            return False
        
        # 跳过扫描过的字符，以便更快的移动到其他可能的中心扩展位置
        elif (right - left + 1) % 2 == 1:
            left += 1
            
        else:
            # 中心扩展
            mid = (left+right)//2
            
            # 对称轴上的字符与字符之间没有间隔，因此只需考虑这三个位置
            if mid-1 >= 0 and lst[mid-1] == lst[mid]:
                right = mid-1
                
            elif mid+1 <= len(lst)-1 and lst[mid+1] == lst[mid]:
                left = mid+1
                
            else:
                break
            
    # 遍历完成，该字符串是一个回文串
    return True
```
#### 3.1.2.2 判断回文字符串的逆向扫描算法
逆向扫描算法：从右向左读取字符串，判断当前位置和上一个位置是否匹配，如匹配则继续，不匹配则不是回文串。由于逆向扫描不会漏掉任何信息，因此可以获得更多的信息。但是需要注意的是，由于逆向扫描可能会漏掉最早的信息，所以无法用于所有的回文串判断。
```python
def reverse_scan(s:str)->bool:
    """
    函数功能：判断一个字符串是否是回文字符串
    :param s: str 待判断的字符串
    :return: bool 是否为回文字符串
    """
    # 将字符串转换为列表类型方便遍历
    lst = list(s)
    
    # 设置扫描的起点和终点
    start, end = 0, len(lst)-1
    
    while start < end:
    
        # 如果当前位置的字符与其相邻的字符不匹配，则不是回文串
        if lst[start]!= lst[end]:
            return False
        
        start += 1
        end -= 1
        
    # 遍历完成，该字符串是一个回文串
    return True
```
### 3.1.3 总结
两种算法都不能一次性判断出所有回文串，它们都依赖于对称轴（中心点）以及对称轴上的字符之间的关系。为了进一步提升性能，还可以使用预处理方法快速判断单个字符是否是回文串。

## 3.2 查找最长回文子串
查找最长回文子串与查找最长公共子序列（LCS）类似，也是利用动态规划求解的问题。它与最长回文子序列不同，最大公共子序列不一定是回文串。为了找到最长回文子串，可以先尝试使用中心扩展的方法，然后再考虑逆向扫描的方法。下面介绍两种不同的算法。
### 3.2.1 使用中心扩展的最长回文子串算法
中心扩展的最长回文子串算法与判断回文串的中心扩展算法类似，它采用递归的方式，先确定中心位置，然后分别对左半边、右半边和中间部分进行判断。
```python
def longest_palindrome(s: str) -> str:
    """
    函数功能：查找给定字符串中的最长回文子串
    :param s: str 待查找的字符串
    :return: str 最长回文子串
    """
    def expand_around_center(s, left, right):
        """
        函数功能：在给定范围内，找到回文子串的中心
        :param s: str 待查找的字符串
        :param left: int 子串的左端点索引
        :param right: int 子串的右端点索引
        :return: tuple 返回回文子串的中心坐标（x，y）
        """
        # 当只有两个元素时，直接返回它们
        if left >= right:
            return left, right

        # 获取中心位置的字符
        center = (left + right) // 2
        c = s[center]

        # 从左向右查找回文
        l, r = center, center
        while l >= left and r < right and s[l] == s[r]:
            l -= 1
            r += 1
        l += 1
        r -= 1

        # 从右向左查找回文
        ll, rr = center, center
        while ll > left and rr < right and s[ll] == s[rr]:
            ll -= 1
            rr += 1
        ll += 1
        rr -= 1

        # 返回中心位置坐标
        return max(expand_around_center(s, left, l),
                   expand_around_center(s, r, right),
                   expand_around_center(s, ll, rr))

    # 在字符串的所有可能子串中查找最长的回文子串
    start, end = 0, 0
    for i in range(len(s)):
        # 以每个字符为中心，尝试扩展最长回文子串
        length = min((len(s) - i), expand_around_center(s, i, len(s)))
        if length > end - start:
            start = i - (length - 1) // 2
            end = i + length // 2

    # 返回最长回文子串
    return s[start:end+1]
```
### 3.2.2 使用逆向扫描的最长回文子串算法
逆向扫描的最长回文子串算法与判断回文串的逆向扫描算法类似，它根据子串的长度，向外扩展，直到发现一个回文串。但是并非所有子串都是回文串，所以需要多种方案来确保找到最长的回文串。
```python
def longest_palindrome(s: str) -> str:
    """
    函数功能：查找给定字符串中的最长回文子串
    :param s: str 待查找的字符串
    :return: str 最长回文子串
    """
    def extend_to_boundaries(s, left, right):
        """
        函数功能：尝试扩展最长回文子串至尽头
        :param s: str 待查找的字符串
        :param left: int 子串的左端点索引
        :param right: int 子串的右端点索引
        :return: tuple 返回回文子串的中心坐标（x，y）
        """
        # 当只有两个元素时，直接返回它们
        if left >= right:
            return left, right

        # 尝试扩展左边界
        l, r = left, right
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l -= 1
            r += 1
        l += 1
        r -= 1

        # 尝试扩展右边界
        ll, rr = left, right
        while ll >= 0 and rr < len(s) and s[ll] == s[rr]:
            ll -= 1
            rr += 1
        ll += 1
        rr -= 1

        # 返回最外侧界坐标
        return max(extend_to_boundaries(s, left, l),
                   extend_to_boundaries(s, r, right),
                   extend_to_boundaries(s, ll, rr))

    def shrink_from_middle(s, left, right):
        """
        函数功能：缩小回文子串中点，继续查找
        :param s: str 待查找的字符串
        :param left: int 子串的左端点索引
        :param right: int 子串的右端点索引
        :return: str|None 返回最长回文子串或None
        """
        # 当只有两个元素时，直接返回它们
        if left >= right:
            return None

        # 获取中心位置的字符
        center = (left + right) // 2
        c = s[center]

        # 根据奇偶长度分割子串
        middle = s[center:] if (right - left + 1) % 2 == 1 else s[center+1:]

        # 向外扩展至尽头
        result = extend_to_boundaries(''.join(reversed(s)), 0, len(middle)-1)

        # 合并结果
        x, y = result
        z, w = x + center - abs(result[0]-result[1]), y + center - abs(result[0]-result[1])
        if z == w or all([middle[i] == middle[w-j-1] for j in range(z-x)]):
            return ''.join(s[z:w+1])
        else:
            return None

    # 在字符串的所有可能子串中查找最长的回文子串
    start, end = 0, 0
    for i in range(len(s)):
        # 以每个字符为中心，尝试扩展最长回文子串
        substrings = [s[:i], s[i:]]
        for substring in substrings:
            if any([''.join(reversed(substring))[j:k] == substring[::-1][j:k]
                    and k-j > end-start
                    for j in range(max(i-2*(end-start)+1, 0), min(i+2*(end-start)+1, len(s)))
                    for k in range(j+2, min(i+(end-start)+1, len(s)))]):
                index = [''.join(reversed(substring))[j:k].index(substring[::-1][j:k])
                         for j in range(max(i-2*(end-start)+1, 0), min(i+2*(end-start)+1, len(s)))
                         for k in range(j+2, min(i+(end-start)+1, len(s)))].index(min([abs(i-j)
                                                                                         for i in range(max(i-2*(end-start)+1, 0), min(i+2*(end-start)+1, len(s)))
                                                                                         for j in range(i+2, min(i+(end-start)+1, len(s))))])
                start = max(i-2*(end-start)+1, 0) + index*2
                end = start + (end-start)*2
                continue

            # 根据中间位置来判断，该位置往左或右拼接一条子串，是否能找到更长的回文子串
            possible_starts = []
            possible_ends = []
            if (len(s)-i) % 2 == 1:
                for j in range(-int((len(s)-i)/2), int((len(s)-i)/2)+1):
                    if -j <= ((len(s)-i+j)%2-1):
                        possible_starts.append(max(0, i+j))
                        possible_ends.append(min(i+(len(s)-i+j)//2, len(s)-1))
            else:
                possible_starts.append(max(0, i-(len(s)-i)//2))
                possible_ends.append(min(i+(len(s)-i)//2, len(s)-1))

            for p_start, p_end in zip(possible_starts, possible_ends):

                # 拼接子串，尝试扩展最长回文子串
                combined = s[p_start:p_end+1]
                joined = combined + s[(i-len(combined)//2+1):(i+len(combined)//2)]
                if any([''.join(reversed(joined))[j:k] == joined[::-1][j:k]
                        and k-j > end-start
                        for j in range(max(i-2*(end-start)+1, p_start),
                                       min(i+2*(end-start)+1, len(s)-len(combined)+1))
                        for k in range(j+2, min(i+(end-start)+1, len(s)-len(combined))+1)]):

                    index = [''.join(reversed(joined))[j:k].index(joined[::-1][j:k])
                             for j in range(max(i-2*(end-start)+1, p_start),
                                            min(i+2*(end-start)+1, len(s)-len(combined)+1))
                             for k in range(j+2, min(i+(end-start)+1, len(s)-len(combined))+1)].index(min([abs(i-j)
                                                                                                         for i in range(max(i-2*(end-start)+1, p_start),
                                                                                                                    min(i+2*(end-start)+1, len(s)-len(combined)+1))
                                                                                                         for j in range(i+2, min(i+(end-start)+1, len(s)-len(combined))+1)]))
                    start = max(i-2*(end-start)+1, p_start) + index*2
                    end = start + (end-start)*2
                    continue
                
                # 不需要拼接，直接检查中间位置是否可行
                if middle := shrink_from_middle(s, max(i-2*(end-start)+1, 0),
                                                 min(i+(end-start)+1, len(s)-1)):
                    return middle
                    
    # 返回最长回文子串
    return '' if not s else s[start:end+1]
```