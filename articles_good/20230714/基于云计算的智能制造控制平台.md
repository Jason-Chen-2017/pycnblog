
作者：禅与计算机程序设计艺术                    
                
                
## 1.1 概述
智能制造领域是一个巨大的市场，每年都在产生海量的数据、计算资源、传感器设备等。为了提升生产效率，降低成本，智能制造控制系统应运而生。本文将基于云计算、机器学习及人工智能技术，通过云端部署模型，实现对生产过程中的各个环节的精确监控、控制。
## 1.2 关键词
基于云计算、智能制造、控制系统、工业互联网、机器学习、人工智能、云端部署模型、精确监控、控制、生产效率、降低成本
## 1.3 文章大纲
![image.png](https://upload-images.jianshu.io/upload_images/9176105-d1fb0c8a0e0f7b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
## 2.基本概念术语说明
### 2.1 生产自动化（Automation）
生产自动化是指从设计到产品生命周期的全产业链的各个环节自动化完成。如：从汽车设计到最终交付的一系列环节，都可被认为属于生产自动化的范畴。
### 2.2 模糊控制（Fuzzy Control）
模糊控制，又称多模态控制，是指用一系列模糊、不精确的运算方法或规则来获得更好的决策控制能力。其特点是模糊性，可以容忍一些复杂或未知因素的影响，使系统更加灵活、适应性强。模糊控制方法主要用于复杂环境下或物理系统存在非线性、不可预测性、随机干扰等因素的生产控制。
### 2.3 工业互联网 （Industrial Internet of Things ，IIoT）
工业互联网(Industrial Internet of Things, IIoT )是由数字孪生技术、物联网技术、信息安全技术、云计算技术、人工智能技术、以及区块链技术等融合而成的新型工业网格网络。它利用机器人、传感器、终端、云计算平台等软硬件设施将物理世界与数字世界连接起来，并构建起连接物理世界和数字世界的统一网络体系，实现自动化、智能化、协同化的工业生产管理。它将工业应用、生产流程、生产设备、人员信息、上下游供应链以及运输信息等所有相关数据集成并交换，创造出巨大的价值。
### 2.4 机器学习 （Machine Learning）
机器学习（英语：Machine learning），是人工智能研究领域的分支领域，涉及人工智能的学习、优化、统计建模、决策与推理。机器学习通过计算机编程的方式获取数据、训练算法、得出分析结果，从而实现对数据的分析和预测。它可以自动地改进自身的性能，使之逼近或者超过既定目标。
### 2.5 云计算 （Cloud Computing）
云计算（Cloud computing）是一种按需访问的服务模式，它将基础设施即软件、服务器、存储设备等资源通过互联网进行聚合，为用户提供计算、存储、数据库、网络等资源。云计算服务通常由第三方提供商或云服务提供商所提供，提供商根据用户需求按订购和使用方式收取费用。云计算服务通常提供高度可扩展性、可靠性和可用性。用户可以在云计算服务中快速部署应用程序，享受按需付费带来的经济效益。
### 2.6 云端部署模型 （Cloud Deployed Model）
云端部署模型是指在云端部署机器学习模型，模型的训练、实验、验证、推理、服务化和部署均在云端完成。这种模型部署方式有效解决了单机模型无法处理海量数据的问题，减轻了本地服务器的压力，还能够满足实时性的要求，实时反映模型效果。
### 2.7 精确监控（Precise Monitoring）
精确监控是指对生产现场实时的监控，包括生产过程控制参数的实时采集、实时传输、实时处理、实时显示、保存、检索。精确监控可以帮助生产者做到“知时知道”，掌握生产进度、工艺瓶颈、质量问题、缺陷等，避免出现意外情况。
### 2.8 控制系统（Control System）
控制系统，是指用来调节和控制生产企业或工厂某些特定过程或产品的各种设备和机制。控制系统一般由输入端、输出端、计算端组成，分别接收、转换、处理输入信号，输出信号，完成某种功能。控制系统控制着生产过程中的各项设备和活动，起到保障企业产品质量、服务水平和规模经济的作用。
### 2.9 生产效率（Efficiency）
生产效率，也称产出率，是指单位时间内完成某项工作或生产项目的能力，包括产能利用率、产品质量和生产成本之间的比例关系。生产效率高，能有效提高产品的整体利润率，降低成本。
### 2.10 降低成本（Cost Reduction）
降低成本，是指减少生产成本、降低生产成本，包括材料成本、设备成本、工具成本、劳动成本、工时成本、管理成本等。降低成本后，企业就有更多的时间和精力投入在创新科技创造上，提高竞争力。
# 3.核心算法原理和具体操作步骤以及数学公式讲解
## 3.1 基于模糊控制的单变量控制
模糊控制（Fuzzy Control）是指用一系列模糊、不精确的运算方法或规则来获得更好的决策控制能力。其特点是模糊性，可以容忍一些复杂或未知因素的影响，使系统更加灵活、适应性强。模糊控制方法主要用于复杂环境下或物理系统存在非线性、不可预测性、随机干扰等因素的生产控制。
假设某工厂某个生产任务的输入、输出量以摄氏度计，要求输出恒定的电流大小，如图2所示。该工厂采用的是电流驱动方式，在一定时间内输出恒定的电流，则需要消耗一定功率。在实际生产过程中，由于种种原因，可能导致电流波动或功率波动，因此需要对生产过程进行精准控制，保证电流输出和功率消耗在可接受范围内。
![image.png](https://upload-images.jianshu.io/upload_images/9176105-cfccdc20c508eeaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 3.1.1 操作步骤
1.定义模糊集M，并确定模糊集的边界：
   $ M = \lbrace x : -U < x < U,  0 <= u_i <= V\rbrace$, 其中：
    * $x$ 表示生产任务的输入输出量；
    * $u_i$ 表示模糊集M上的每个取值，即：$u_{min}$ 和 $u_{max}$ 是设定的最小、最大取值，$U$ 是中间取值的上下限，$V$ 表示取值个数，即$n=|u_{max} - u_{min}| + 1$ 。
    * 确定模糊集边界，即$u_{min}=0,u_{max}=\frac{P}{I},U=\frac{P}{I}$,其中$P$为单位功率，$I$为单位电流。

2.选择控制策略：
   在精确控制中，将控制系统分为三个部分：试验装置、控制策略和调节器。试验装置用于对控制系统的模拟，模拟系统在实际运行中的状态，可由仿真模型或实时控制台来实现。控制策略决定如何调整设备参数，以及在什么条件下调整，如图3所示。
  ![image.png](https://upload-images.jianshu.io/upload_images/9176105-d2a371fd961e1e5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
   调节器用于输出调整后的参数，调节器负责生成所需的电流或功率命令，并把它们发送给电流、功率装置来执行。调节器根据输入的精细化误差（如测量误差、温度误差等），实时地生成控制指令，将其转化成输出信号。

3.模拟控制系统：
   通过仿真模型建立模糊控制系统，模拟系统的实际状态，然后再用这一模型去模拟系统的输入输出关系。系统状态包括三个参数：电流、功率、输出量。

4.设计控制算法：
   根据模糊控制方法的基本原理和特征，设计模糊控制算法。模糊控制算法包括三个层次：模糊空间的划分、控制器的设计、控制循环的设计。

   a) 模糊空间的划分: 先确定模糊集的取值个数，即$V$的值，然后通过等距采样的方法，在$[-U,U]$范围内均匀地划分$n$个取值，构成模糊空间的划分。

   b) 控制器的设计: 对模糊系统状态变量和控制指令进行设计，如PID控制器。PID控制器的三要素是比例项（Kp）、积分项（Ki）、微分项（Kd）。其中，比例项用于保持系统处于稳定状态，使得电流输出达到设定值；积分项用于抗震荡，使系统稳定；微分项用于抑制系统过快的变化，使系统平滑。

   c) 控制循环的设计: 控制循环包括输入、输出、错误、控制指令之间的映射关系。控制指令的传递依赖于输入的误差，当输入的误差发生变化时，输出会发生相应的变化。控制循环的设计应保证输出的准确性。

5.模拟运行控制系统：
   将模糊控制算法应用到实际工况中，模拟系统的输入、输出关系，根据系统的状态变量估计输出的精确值，最后将所得结果与实际输出作比较。

6.优化控制策略：
   在模糊控制系统的实际运行中，如果出现波动或响应延迟，可能是由于系统的输出超出了控制指令的范围，此时可以通过优化控制策略来解决。优化控制策略包括参数调整、增益分配、系统输出的限制等。

   a) 参数调整：通过改变控制指令的参数值，改变模糊控制算法的行为，调整系统的输出。如将输出最小值修改为零，就可以让电流输出永远保持在设定的范围内，但同时也会增加系统的开销。

   b) 增益分配：增益分配是指增加或减少输入信号的幅度，调整系统的输出。如将输出的积分项增大，使系统稳定。

   c) 系统输出的限制：当系统的输出超出了模糊控制系统的范围时，可以通过系统输出的限制来限制输出的大小。

### 3.1.2 数学公式
设模糊系统的状态变量为$x=(x_1,...,x_k)$，输出变量为$y=(y_1,...,y_m)$，控制指令为$u=(u_1,...,u_p)$。输入输出函数：$H:\ B    imes X \rightarrow R^{m+k}$ ，其中$B$表示约束条件集合，表示系统在其可行区域内运行。其定义为：
$$ H(u,x)=\left[ \begin{matrix}\frac{\partial y_1}{\partial x_1}(x)\cdots\frac{\partial y_1}{\partial x_k}(x)\\...\\ \frac{\partial y_m}{\partial x_1}(x)\cdots\frac{\partial y_m}{\partial x_k}(x)\end{matrix}\right] $$ 

观察变量为$\Omega^+(t),\Omega^-(t)$ ，记作：
$$ \Omega^+:= \{x : H(u,\omega)+v\leq 0, \forall \omega \in B\}$$ 
$$ \Omega^-:= \{x : H(u,\omega)-v>0, \forall \omega \in B\}$$ 

输入输出函数：
$$ H(\omega):= \left[ \begin{array}{lll} \frac{\partial y_1}{\partial x_1}(\omega)&\cdots&\frac{\partial y_1}{\partial x_k}(\omega)\\...&...&\cdots\\ \frac{\partial y_m}{\partial x_1}(\omega)&\cdots&\frac{\partial y_m}{\partial x_k}(\omega) \end{array} \right]\in R^{mk} $$ 

模糊集$M$: $\lbrace x : -U<x<U,0<=u_i<=V\rbrace$,其中$u_{min}$,$u_{max}$ 为设定的最小、最大取值,$U$ 为中间取值的上下限,$V$ 表示取值个数，即$n=|u_{max}-u_{min}|+1$.

定义模糊精确控制算法如下：
1. 初始化：
   * 初始化$\xi_0=0,y_0=0,u_0=0,\bar{x}_0=0$, $\alpha_0, \beta_0, \gamma_0, \delta_0$等。
2. 模拟运行：
   * 更新模糊控制系统的状态：$x_{\bar t}=x_{t-\Delta t},u_{\bar t}=u_{t-\Delta t},\bar{x}_{\bar t}=x_{\bar t+\Delta t}$;
   * 计算模糊控制系统的输出：
      * 用当前的$x_{\bar t}$，计算模糊集边界上对应的控制指令$u_{\hat{\bar t}}$；
      * 用当前的$u_{\hat{\bar t}}$，计算输出变量$y_{\bar t}$；
   * 检查系统是否处于失配状态：如果$\bar{\Omega}^-(t_{\bar m}) \cap B
eq \emptyset$,说明系统处于失配状态；否则系统处于饱和状态；
   * 计算系统输出误差：$e_{\bar t}=y_{\bar t}-y_{t}$.
3. 控制策略更新：
   * 通过优化控制策略，得到新的控制指令$u_{t'}$；
   * 判断是否需要更新控制策略：如果系统处于饱和状态，则不需要更新控制策略。
4. 执行调整：
   * 如果系统处于饱和状态：停止运行；
   * 否则，通过调节器调整系统的输出，使得$e_{\bar t}=0$；
   * 更新状态：$y_{t}=y_{\bar t},\hat{u}_{t}=u_{\bar t}$;
   * 返回第2步。

# 4.具体代码实例和解释说明
## 4.1 数据清洗
首先，我们需要读取工况数据，然后进行一些数据清洗，比如将数据类型转化为float、int等。数据清洗的代码如下：

```python
import pandas as pd
data = pd.read_csv('data.txt', header=None, sep=' ') # 读入数据文件
cols = ['input_temp', 'output_temp', 'current'] # 列名
data.columns = cols 
data['input_temp'] = data['input_temp'].astype('float') # 转化为float
data['output_temp'] = data['output_temp'].astype('float')
data['current'] = data['current'].astype('float')
```
## 4.2 建立模糊控制系统
建立模糊控制系统最重要的步骤是定义模糊空间的边界以及模糊集上对应的控制指令。这里我将使用离散化方法来构造模糊集，即先设定模糊集上取值个数，然后将输入变量的取值范围分割为等份，将输出变量的取值范围等分为几个点，作为模糊集上对应的控制指令。

```python
from skfuzzy import trapmf
import numpy as np

def fuzzy_system():
    input_range = [-10, 10]
    output_range = [0, max(data['current'])*2]

    n_u = 10
    u_step = (input_range[1]-input_range[0])/n_u
    
    u_centers = np.linspace(*input_range, num=n_u+1)[1:]
    u_edges = u_centers[:-1]+u_step/2
    v_centers = np.linspace(*output_range, num=n_u//4+1)[1:-1]
    v_edges = v_centers[:-1]+(v_centers[1]-v_centers[0])/2
    mv_centers = list(zip(v_centers, v_edges))
    
    def generate_control_sets():
        ctrl_sets = []
        for i in range(len(u_centers)):
            center = u_centers[i]
            width = u_step
            
            if i == len(u_centers)-1:
                upper = None
            else:
                upper = u_centers[i+1]
                
            ctrl_sets.append((center-width/2, center+width/2, lower, upper))
            
        return ctrl_sets
        
    def get_u(x):
        idx = np.searchsorted(-np.abs(u_edges-x))
        left_idx = int(idx-1 if idx > 0 else 0)
        right_idx = int(idx if idx < len(u_edges) else len(u_edges)-1)
        
        lft_edge = u_edges[left_idx]
        rght_edge = u_edges[right_idx]
        
        return (-1)**(lft_edge >= x)*(1-trapmf([lft_edge], [rght_edge], [0],[input_range[1]])[0])
        
ctrl_sets = generate_control_sets()
    
for row in data.itertuples():
    print(get_u(row.input_temp)*mv_centers[(np.abs(v_centers-row.current)).argmin()])
```
## 4.3 PID控制器设计
PID控制器的设计可以根据误差项的权重，选择不同的控制器结构。PID控制器是一种常用的控制算法，经常被用来做直流电路的PID补偿，也可以用来做工况控制。在本文中，我将使用PID控制器来完成工况控制。

```python
class PidController:
    """
    PID控制器类
    """
    def __init__(self, kp=1, ki=0, kd=0, **kwargs):
        self._kp = kp
        self._ki = ki
        self._kd = kd
        self._last_error = 0
        self._integral = 0
        
    def update(self, error):
        """
        更新控制指令
        """
        proportional_term = self._kp*error
        integral_term = self._ki*(error+self._last_error)/2
        derivative_term = self._kd*(error-self._last_error)/(1e-8+self._dt())
        control_signal = proportional_term + integral_term + derivative_term
        self._integral += error*self._dt()
        self._last_error = error
        return control_signal
    
    def _dt(self):
        pass
    
class TimePidController(PidController):
    """
    时基PID控制器类
    """
    def __init__(self, dt=0.01, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._dt = lambda: dt

controller = TimePidController(dt=0.1)

for row in data.itertuples():
    controller.update(error=-1*(row.input_temp-10))
```

