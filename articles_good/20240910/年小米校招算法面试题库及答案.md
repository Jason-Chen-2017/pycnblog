                 

### 2024年小米校招算法面试题库及答案

#### 1. 简单排序算法实现及性能分析

**题目：** 请实现一个简单的排序算法，如冒泡排序或选择排序，并对算法的时间复杂度和空间复杂度进行分析。

**答案：**

**冒泡排序实现及性能分析：**

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

**性能分析：**
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

**选择排序实现及性能分析：**

```go
func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        minIndex := i
        for j := i+1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}
```

**性能分析：**
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)

#### 2. 二分查找算法实现及性能分析

**题目：** 请实现一个二分查找算法，并在已排序的数组中查找特定元素。

**答案：**

```go
func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}
```

**性能分析：**
- 时间复杂度：O(log n)
- 空间复杂度：O(1)

#### 3. 链表反转

**题目：** 实现一个函数，反转单链表。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

#### 4. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 {
            if !strings.HasPrefix(strs[i], prefix) {
                prefix = prefix[:len(prefix)-1]
            } else {
                break
            }
        }
        if prefix == "" {
            return ""
        }
    }
    return prefix
}
```

#### 5. 回文数

**题目：** 判断一个整数是否是回文数。

**答案：**

```go
func isPalindrome(x int) bool {
    if x < 0 || (x % 10 == 0 && x != 0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x = x / 10
    }
    return x == reversed || x == reversed/10
}
```

#### 6. 两数相加

**题目：** 不使用 + 或 - 运算符，实现两数相加。

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10}
        current = current.Next
    }

    if carry > 0 {
        current.Next = &ListNode{Val: carry}
    }

    return dummy.Next
}
```

#### 7. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：**

```go
func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }

    maxLen := 1
    for num := range numSet {
        if !numSet[num-1] {
            currNum := num
            currLen := 1
            for numSet[currNum+1] {
                currNum++
                currLen++
            }
            maxLen = max(maxLen, currLen)
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 8. 二进制中1的个数

**题目：** 请实现一个函数，输出一个整数的二进制表示中 1 的个数。

**答案：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

#### 9. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

#### 10. 逆序对

**题目：** 在数组中的两个数字，如果前面数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**答案：**

```go
func reversePairs(nums []int) int {
    count := mergeSort(nums)
    return count
}

func mergeSort(nums []int) int {
    if len(nums) <= 1 {
        return 0
    }
    mid := len(nums) / 2
    leftCount := mergeSort(nums[:mid])
    rightCount := mergeSort(nums[mid:])
    mergeCount := merge(nums[:mid], nums[mid:])
    return leftCount + rightCount + mergeCount
}

func merge(nums1, nums2 []int) int {
    i, j := 0, 0
    count := 0
    for i < len(nums1) && j < len(nums2) {
        if nums1[i] <= nums2[j] {
            i++
        } else {
            count += len(nums1) - i
            j++
        }
    }
    return count
}
```

#### 11. 二叉树的层序遍历

**题目：** 给定一个二叉树，返回其节点值的层序遍历。即按从左到右，从上到下的顺序依次遍历每一层的节点值。

**答案：**

```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }
    result := [][]int{}
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        level := []int{}
        for i := 0; i < len(queue); i++ {
            node := queue[i]
            level = append(level, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        result = append(result, level)
        queue = queue[len(queue)/2:]
    }
    return result
}
```

#### 12. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    if head == nil {
        return false
    }
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

#### 13. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 14. 最小栈

**题目：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

**答案：**

```go
type MinStack struct {
    stack  []int
    minVal []int
}

func Constructor() MinStack {
    return MinStack{[]int{}, []int{int(^uint(0) >> 1)}}
}

func (this *MinStack) Push(x int) {
    this.stack = append(this.stack, x)
    this.minVal = append(this.minVal, min(x, this.minVal[len(this.minVal)-1]))
}

func (this *MinStack) Pop() {
    this.stack = this.stack[:len(this.stack)-1]
    this.minVal = this.minVal[:len(this.minVal)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 15. 逆波兰表达式求值

**题目：** 根据逆波兰表达式求值。有效的运算符包括 '+', '-', '*', '/' 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**答案：**

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if b == 0 {
                return 0
            }
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    ans := 0
    for _, v := range token {
        ans = ans*10 + int(v-'0')
    }
    return ans * sign
}
```

#### 16. 最大子序和

**题目：** 给定一个整数数组 nums ，找到最大子序和。

**答案：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    curSum := nums[0]
    for i := 1; i < len(nums); i++ {
        curSum = max(nums[i], curSum+nums[i])
        maxSum = max(maxSum, curSum)
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 17. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

#### 18. 颜色分类

**题目：** 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

**答案：**

```go
func sortColors(nums []int) {
    zero, one, two := 0, 0, len(nums)
    for i := 0; i < two; i++ {
        if nums[i] == 0 {
            nums[zero], nums[i] = nums[i], nums[zero]
            zero++
        } else if nums[i] == 1 {
            nums[one], nums[i] = nums[i], nums[one]
            one++
        } else {
            nums[two-1], nums[i] = nums[i], nums[two-1]
            two--
            i--
        }
    }
}
```

#### 19. 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组。

**答案：**

```go
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := (l + r) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[l] <= nums[mid] {
            if nums[l] <= target && target < nums[mid] {
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[r] {
                l = mid + 1
            } else {
                r = mid - 1
            }
        }
    }
    return -1
}
```

#### 20. 最小路径和

**题目：** 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 21. 盛水

**题目：** 给你 n 个非负整数 a1，a2，...，an，每个整数表示一个坐标，n 个坐标构成一个二维平面上的 n 个点，其坐标最小值为 (0, 0) ，最大值为 (n-1, n-1) 。找到这些点能连成的且只包含边的最短线的长度。

**答案：**

```go
func minArea(heights []int) int {
    l, r := 0, len(heights)-1
    ans := math.MaxInt32
    for l < r {
        ans = min(ans, (r-l)*min(heights[l], heights[r]))
        if heights[l] < heights[r] {
            l++
        } else {
            r--
        }
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 22. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        last := ans[len(ans)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 23. 丑数

**题目：** 考虑所有小于非负整数 n 的数字 x ，求解构成 x 的质因数中，2，3，5 的数量。

**答案：**

```go
func numFactorizations(n int) int {
    count := 0
    for n > 0 {
        n /= 2
        count += n
    }
    for n > 0 {
        n /= 3
        count += n
    }
    for n > 0 {
        n /= 5
        count += n
    }
    return count
}
```

#### 24. 颜色边界和

**题目：** 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角路径上的整数总和最大的路径，并输出该路径的最大整数和。

**答案：**

```go
func maxPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 1; i < m; i++ {
        grid[i][0] += grid[i-1][0]
    }
    for j := 1; j < n; j++ {
        grid[0][j] += grid[0][j-1]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            grid[i][j] += max(grid[i-1][j], grid[i][j-1])
        }
    }
    return grid[m-1][n-1]
}
```

#### 25. 合并两个图

**题目：** 给定两个含有节点数量的图 G 和 H，要求合并这两个图，合并规则如下：

- 合并后的图节点数量为 G 和 H 节点数量之和。
- 合并后的图边的数量不超过 G 和 H 边的数量之和。
- 合并后的图必须保持连通。

**答案：**

```go
func mergeGraph(G, H *Graph) *Graph {
    merged := NewGraph(G.V + H.V)
    for v := 0; v < G.V; v++ {
        for w := 0; w < G.Adj[v].Len(); w++ {
            merged.AddEdge(v, G.Adj[v].Get(w))
        }
    }
    for v := 0; v < H.V; v++ {
        for w := 0; w < H.Adj[v].Len(); w++ {
            merged.AddEdge(G.V+v, H.Adj[v].Get(w))
        }
    }
    return merged
}
```

#### 26. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 27. 股票价格的最二买卖

**题目：** 给定一个整数数组 prices，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**答案：**

```go
func maxProfit(prices []int) int {
    maxProfit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            maxProfit += prices[i] - prices[i-1]
        }
    }
    return maxProfit
}
```

#### 28. 等差数列中的缺失项

**题目：** 给定一个整数数组 A，你需要从中找出一组数字，使得它们按顺序形成等差数列。如果找不到这样的数字，请输出 -1。

**答案：**

```go
func missingNumber(arr []int) int {
    n := len(arr)
    target := arr[0] + 2*(n-1)*(arr[0]-1)/2
    sum := 0
    for i := 0; i < n; i++ {
        sum += arr[i]
    }
    return target - sum
}
```

#### 29. 寻找两个正序数组的中位数

**题目：** 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数。

**答案：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        return findMedianSortedArrays(nums2, nums1)
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i < m {
                minOfRight = nums1[i]
            }
            if j < n {
                minOfRight = min(minOfRight, nums2[j])
            }
            return float64(maxOfLeft+minOfRight) / 2
        }
    }
    return 0
}
```

#### 30. 设计位运算

**题目：** 给定一个整数数组 A，设计并实现一个支持动态查询和更新位运算的 DataStructure 类。

- DataStructure() ：用空数组初始化数据结构。
- update(i, v)：将位于索引 i 的数字更新为 v。
- query(i)：返回从 0 到 i 的数字的位运算结果。

**答案：**

```go
type DataStructure struct {
    arr []int
    tree []int
}

func Constructor() DataStructure {
    n := 1 << 10
    arr := make([]int, n)
    tree := make([]int, n)
    return DataStructure{arr, tree}
}

func (this *DataStructure) update(i int, v int)  {
    if i >= len(this.arr) {
        this.arr = append(this.arr, make([]int, i-len(this.arr)+1)...)
        this.tree = append(this.tree, make([]int, i-len(this.arr)+1)...)
    }
    for i >= 0 {
        if i&1 == 1 {
            this.tree[i] = this.tree[i] ^ v
        }
        i = (i - 1) & (-i)
    }
    this.arr[i] = v
}

func (this *DataStructure) query(i int) int {
    res := 0
    for i > 0 {
        if i&1 == 1 {
            res = res ^ this.arr[i]
        }
        i = (i - 1) & (-i)
    }
    return res
}
```

