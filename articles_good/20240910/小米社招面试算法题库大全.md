                 

### 2025小米社招面试算法题库大全

在这篇博客中，我们将深入探讨小米社招面试中的典型算法问题。小米作为中国领先的互联网公司，其面试问题涵盖了从基础数据结构到高级算法的各个方面。以下我们将列出一些具有代表性的面试题，并提供详尽的答案解析和源代码实例。

#### 1. 单链表反转

**题目描述：** 实现一个函数，完成对单链表头尾互换的功能。

**示例代码：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev, curr *ListNode
    curr = head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**解析：** 通过迭代的方式，我们将链表中的每个节点反转其指向，最终得到反转后的链表。

#### 2. 两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的。将两数相加，并以相同形式返回一个表示和的链表。

**示例代码：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := carry + val1 + val2
        carry = sum / 10
        curr.Next = &ListNode{sum % 10, nil}
        curr = curr.Next
    }
    if carry > 0 {
        curr.Next = &ListNode{carry, nil}
    }
    return dummy.Next
}
```

**解析：** 通过逐位相加并处理进位，我们将两个链表中的数字相加，生成一个新的链表。

#### 3. 最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，找出在 text1 中是 text2 子序列的最长字符串。如果不存在这样的最长的字符串，则返回空字符串。

**示例代码：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    idx := dp[m][n]
    ans := make([]byte, idx)
    i, j := m, n
    for idx > 0 {
        if text1[i-1] == text2[j-1] {
            ans[idx-1] = text1[i-1]
            i--
            j--
            idx--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(ans)
}
```

**解析：** 使用动态规划解决最长公共子序列问题，通过填充一个二维数组来记录子序列长度，并最终回溯得到最长子序列。

#### 4. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 采用递归的方式，比较两个链表的头节点，将较小的节点连接到结果链表，并递归处理剩余链表。

#### 5. 最长回文子串

**题目描述：** 给定一个字符串 s，找到 s 中最长的回文子串。

**示例代码：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, mx := 0, 1
    for i := 0; i < n; i++ {
        l1, r1 := expand(s, i, i)
        l2, r2 := expand(s, i, i+1)
        if r1 - l1 > mx {
            mx = r1 - l1
            start = l1
        }
        if r2 - l2 > mx {
            mx = r2 - l2
            start = l2
        }
    }
    return s[start : start+mx]
}

func expand(s string, left int, right int) (start int, end int) {
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return left + 1, right - 1
}
```

**解析：** 扩展中心法找到最长回文子串，考虑奇数和偶数长度的情况。

#### 6. 二进制中1的个数

**题目描述：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**示例代码：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 通过位运算逐位检查数字的二进制表示，计算其中 1 的个数。

#### 7. 字符串转换大写字母

**题目描述：** 实现一个函数，将字符串转换为全部大写字母。

**示例代码：**

```go
func toUpperCase(s string) string {
    b := []byte(s)
    for i := range b {
        if b[i] >= 'a' && b[i] <= 'z' {
            b[i] -= 'a' - 'A'
        }
    }
    return string(b)
}
```

**解析：** 通过遍历字符串，将小写字母转换为大写字母。

#### 8. 二分查找

**题目描述：** 实现二分查找算法。

**示例代码：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**解析：** 二分查找通过不断缩小区间来查找目标元素。

#### 9. 合并两个有序数组

**题目描述：** 给定两个已排序的整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

**示例代码：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        k--
        j--
    }
}
```

**解析：** 从后向前合并，避免覆盖未处理的元素。

#### 10. 最小栈

**题目描述：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

**示例代码：**

```go
type MinStack struct {
    Stk []*int
    Min *int
}

func Constructor() MinStack {
    return MinStack{make([]*int, 0), new(int)}
}

func (this *MinStack) Push(x int) {
    this.Stk = append(this.Stk, &x)
    if this.Min == nil || *this.Min > x {
        this.Min = &x
    }
}

func (this *MinStack) Pop() {
    if len(this.Stk) == 0 {
        return
    }
    x := *this.Stk[len(this.Stk)-1]
    this.Stk = this.Stk[:len(this.Stk)-1]
    if this.Min == &x {
        this.Min = nil
        for _, v := range this.Stk {
            if this.Min == nil || *this.Min > *v {
                this.Min = v
            }
        }
    }
}

func (this *MinStack) Top() int {
    if len(this.Stk) == 0 {
        return 0
    }
    return *this.Stk[len(this.Stk)-1]
}

func (this *MinStack) GetMin() int {
    return *this.Min
}
```

**解析：** 使用辅助栈来记录当前的最小值。

#### 11. 逆波兰表达式求值

**题目描述：** 根据逆波兰表示法，求表达式的值。

**示例代码：**

```go
func evalRPN(tokens []string) int {
    stk := make([]int, 0)
    for _, token := range tokens {
        switch token {
        case "+":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a+b)
        case "-":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a-b)
        case "*":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a*b)
        case "/":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a/int64(b))
        default:
            stk = append(stk, atoi(token))
        }
    }
    return stk[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    ans := 0
    for _, c := range token {
        ans = ans*10 + int(c-'0')
    }
    return ans * sign
}
```

**解析：** 使用栈来模拟逆波兰表达式的计算过程。

#### 12. 二叉树的层次遍历

**题目描述：** 给你一个二叉树，请你返回其按层序遍历的节点值。 （即逐层地，从左到右访问所有节点）。

**示例代码：**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }
    ans := [][]int{{root.Val}}
    var q []*TreeNode
    q = append(q, root)
    for len(q) > 0 {
        t := make([]*TreeNode, 0)
        var v []int
        for _, node := range q {
            v = append(v, node.Val)
            if node.Left != nil {
                t = append(t, node.Left)
            }
            if node.Right != nil {
                t = append(t, node.Right)
            }
        }
        q = t
        ans = append(ans, v)
    }
    return ans
}
```

**解析：** 使用广度优先搜索（BFS）实现二叉树的层次遍历。

#### 13. 二叉搜索树的第 k 个节点

**题目描述：** 给定一个二叉搜索树的根节点 root 和一个整数 k，请你找出该树中第 k 大的节点。

**示例代码：**

```go
func findKthLargest(root *TreeNode, k int) int {
    var dfs func(*TreeNode) int
    dfs = func(node *TreeNode) int {
        if node == nil {
            return -1
        }
        res := dfs(node.Right)
        if res != -1 {
            return res
        }
        k--
        if k == 0 {
            return node.Val
        }
        return dfs(node.Left)
    }
    return dfs(root)
}
```

**解析：** 通过递归遍历右子树找到第 k 大的节点。

#### 14. 有效的括号

**题目描述：** 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断是否为有效括号。

**示例代码：**

```go
func isValid(s string) bool {
    stk := make([]rune, 0)
    m := map[rune]rune{'(': ')', '{': '}', '[': ']'}
    for _, c := range s {
        switch c {
        case ')', '}', ']':
            if len(stk) == 0 || m[stk[len(stk)-1]] != c {
                return false
            }
            stk = stk[:len(stk)-1
```go
            }
        default:
            stk = append(stk, c)
        }
    }
    return len(stk) == 0
}
```

**解析：** 使用栈来跟踪左括号，当遇到右括号时，检查是否与栈顶的左括号匹配。

#### 15. 汉明重量

**题目描述：** 给定两个整数，计算并返回两个数字的二进制表示中公共一位的个数。

**示例代码：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 通过位运算计算二进制表示中 1 的个数。

#### 16. 翻转整数

**题目描述：** 给定一个 32 位的有符号整数，将整数中的数字进行反转。

**示例代码：**

```go
func reverse(x int) int {
    const INT_MAX = 2147483647
    const INT_MIN = -2147483648
    ans := 0
    for x != 0 {
        if ans > INT_MAX/10 || ans < INT_MIN/10 {
            return 0
        }
        ans = ans*10 + x%10
        x /= 10
    }
    return ans
}
```

**解析：** 逐步将反转后的数字的每一位添加到答案中，并检查溢出情况。

#### 17. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归地将两个链表按值较小的节点连接在一起。

#### 18. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例代码：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(ans) && j < len(strs[i]); j++ {
            if ans[j] != strs[i][j] {
                ans = ans[:j]
                break
            }
        }
    }
    return ans
}
```

**解析：** 两两比较字符串的前缀，更新最长公共前缀。

#### 19. 缺失的第一个正数

**题目描述：** 找出数组中的第一个缺失的正整数。

**示例代码：**

```go
func firstMissingPositive(nums []int) int {
    if len(nums) == 0 {
        return 1
    }
    m := len(nums)
    for i := 0; i < m; i++ {
        for nums[i] > 0 && nums[i] <= m && nums[nums[i]-1] != nums[i] {
            t := nums[nums[i]-1]
            nums[nums[i]-1] = nums[i]
            nums[i] = t
        }
    }
    for i := 0; i < m; i++ {
        if nums[i] != i+1 {
            return i + 1
        }
    }
    return m + 1
}
```

**解析：** 利用数组的索引来标记是否出现过数字，从而找到第一个缺失的正整数。

#### 20. 合并两个有序数组

**题目描述：** 给定两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

**示例代码：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**解析：** 从后向前合并，确保不会覆盖尚未处理的元素。

#### 21. 字符串相乘

**题目描述：** 给定两个字符串表示的非负整数 num1 和 num2，返回用字符串表示的它们乘积的非负整数。

**示例代码：**

```go
func multiply(num1 string, num2 string) string {
    ans := "0"
    for i := len(num1) - 1; i >= 0; i-- {
        carry := 0
        for j := len(num2) - 1; j >= 0; j-- {
            mul := (int(num1[i]) - '0') * (int(num2[j]) - '0') + carry
            ans = strconv.Itoa(mul%10) + ans
            carry = mul / 10
        }
        if carry > 0 {
            ans = strconv.Itoa(carry) + ans
        }
        num1 = num1[:len(num1)-1]
    }
    return ans
}
```

**解析：** 模拟竖式乘法，逐位相乘并处理进位。

#### 22. 寻找旋转排序数组中的最小值

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例代码：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 使用二分查找找到旋转点后的最小值。

#### 23. 两数之和 II - 输入有序数组

**题目描述：** 给定一个已按照升序排列 的有序数组 numbers，请你找出两个数 numbers[index0] 和 numbers[index1]，使得它们加起来等于目标值 target。

**示例代码：**

```go
func twoSum(numbers []int, target int) []int {
    m := make(map[int]int)
    for i, v := range numbers {
        m[v] = i
    }
    for i, v := range numbers {
        x := target - v
        if p, ok := m[x]; ok && p != i {
            return []int{i + 1, p + 1}
        }
    }
    return nil
}
```

**解析：** 使用哈希表记录每个元素的索引，并在遍历过程中查找与之相加等于目标值的元素。

#### 24. 最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，找出在 text1 中是 text2 子序列的最长字符串。如果不存在这样的最长的字符串，则返回空字符串。

**示例代码：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    idx := dp[m][n]
    ans := make([]byte, idx)
    i, j := m, n
    for idx > 0 {
        if text1[i-1] == text2[j-1] {
            ans[idx-1] = text1[i-1]
            i--
            j--
            idx--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(ans)
}
```

**解析：** 使用动态规划解决最长公共子序列问题。

#### 25. 最长公共子串

**题目描述：** 给定两个字符串 text1 和 text2，找出在 text1 中是 text2 子串的最长字符串。如果不存在这样的最长的字符串，则返回空字符串。

**示例代码：**

```go
func longestCommonSubstring(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen, endIndex := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - maxLen
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return text1[endIndex : endIndex+maxLen]
}
```

**解析：** 使用动态规划计算最长公共子串。

#### 26. 前K个高频单词

**题目描述：** 给你一个单词列表 words 和一个整数 k ，请返回 list 中最频繁出现的 k 个单词。

**示例代码：**

```go
func topKFrequent(words []string, k int) []string {
    freq := make(map[string]int)
    for _, word := range words {
        freq[word]++
    }
    arr := make([][]string, 0, len(freq))
    for v, c := range freq {
        arr = append(arr, []string{v, strconv.Itoa(c)})
    }
    sort.Slice(arr, func(i, j int) bool {
        return arr[i][1] > arr[j][1]
    })
    ans := make([]string, k)
    for i := 0; i < k; i++ {
        ans[i] = arr[i][0]
    }
    return ans
}
```

**解析：** 使用哈希表记录每个单词的频率，并按频率排序。

#### 27. 长度最小的子数组

**题目描述：** 给定一个包含 n 个正数的数组 nums 和一个正整数 target 。找出该数组中满足其和 >= target 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0 。

**示例代码：**

```go
func minSubArrayLen(target int, nums []int) int {
    ans := 0
    left := 0
    sum := 0
    for right, v := range nums {
        sum += v
        for sum >= target {
            if ans == 0 || right-left+1 < ans {
                ans = right - left + 1
            }
            sum -= nums[left]
            left++
        }
    }
    return ans
}
```

**解析：** 使用滑动窗口的方法找到最小的子数组长度。

#### 28. 链表中倒数第k个节点

**题目描述：** 输入一个链表，输出该链表中倒数第 k 个节点。

**示例代码：**

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil {
        return nil
    }
    dummy := &ListNode{-1, head}
    pre, cur := dummy, head
    for cur != nil {
        tail := cur
        for i := 1; i < k && tail != nil; i++ {
            tail = tail.Next
        }
        if tail == nil {
            break
        }
        next := tail.Next
        pre.Next, cur.Next, cur = cur, next, pre
        pre = cur
        cur = next
    }
    return dummy.Next
}
```

**解析：** 通过反转链表的每一组 k 个节点来解决这个问题。

#### 29. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归地将两个链表按值较小的节点连接在一起。

#### 30. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 head 和一个整数 val，删除链表中值为 val 的节点。

**示例代码：**

```go
func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    pre := head
    curr := head.Next
    for curr != nil && curr.Val != val {
        pre = curr
        curr = curr.Next
    }
    if curr != nil {
        pre.Next = curr.Next
    }
    return head
}
```

**解析：** 通过迭代找到值为 val 的节点并删除。

通过以上30道小米社招面试中的典型算法问题，我们不仅了解了各种数据结构与算法的应用，还学习了如何将问题转化为具体的编程实现。希望这篇博客能对准备面试的你有所帮助。祝你好运！


