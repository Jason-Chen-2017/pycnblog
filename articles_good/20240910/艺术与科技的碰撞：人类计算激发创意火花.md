                 

### 1. 数据结构 - 链表反转

#### **题目描述**：

实现一个函数，输入一个单链表的头节点，将链表反转。例如，输入链表 1->2->3->4->5，输出链表 5->4->3->2->1。

#### **题目解析**：

此题主要考察链表的基本操作，特别是插入和删除操作。我们需要定义一个新的节点，然后逐个将原链表中的节点插入到新链表的头部。这样，当原链表结束时，新链表就是反转后的链表。

#### **代码实现**：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head: ListNode) -> ListNode:
    if not head:
        return None
    
    prev = None
    curr = head
    
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
        
    return prev
```

#### **代码解释**：

1. **初始化**：定义一个 `ListNode` 类，用于创建链表节点。`reverseList` 函数接收链表的头节点作为输入。

2. **初始化指针**：定义两个指针 `prev` 和 `curr`，`prev` 用于指向新链表的头部，初始值为 `None`。`curr` 用于遍历原链表。

3. **遍历链表**：在 `while` 循环中，我们逐个遍历原链表中的节点。每次循环，我们保存当前节点的下一个节点，然后将当前节点的 `next` 指针指向 `prev`，即实现节点的前插操作。

4. **更新指针**：更新 `prev` 和 `curr` 的值，`prev` 移动到当前节点的位置，`curr` 移动到下一个节点。

5. **返回结果**：当 `curr` 变为 `None` 时，说明原链表已经遍历完毕，`prev` 就是新链表的头部，返回 `prev` 即可。

### 2. 数据结构 - 合并两个有序链表

#### **题目描述**：

输入两个已经排序的单链表，将这两个链表合并为一个新的链表，要求新链表中的元素也是按照升序排列。

#### **题目解析**：

此题考察对链表操作的熟悉程度，特别是合并操作。我们需要比较两个链表当前节点的值，将较小的值插入到新链表中，并将该链表的指针指向下一个节点。重复此过程，直到一个链表结束。

#### **代码实现**：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    dummy = ListNode(0)
    curr = dummy

    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    curr.next = l1 if l1 else l2
    return dummy.next
```

#### **代码解释**：

1. **初始化**：创建一个虚拟头节点 `dummy`，用于简化操作。`curr` 指向 `dummy`，作为新链表的当前节点。

2. **合并过程**：在 `while` 循环中，比较 `l1` 和 `l2` 当前节点的值，将较小的节点插入到新链表中。

3. **更新指针**：将 `curr` 指向插入的节点，并将相应链表的指针指向下一个节点。

4. **处理剩余链表**：循环结束后，可能有一个链表还剩余节点，使用 `else` 语句将剩余链表接入新链表。

5. **返回结果**：返回 `dummy` 的下一个节点，即合并后的链表。

### 3. 数据结构 - 环形链表

#### **题目描述**：

给定一个链表，判断链表中是否有环。如果有，返回环的入口节点；如果没有，返回 `None`。

#### **题目解析**：

此题经典解法是使用快慢指针。快指针每次走两步，慢指针每次走一步。如果链表中有环，快指针最终会追上慢指针；如果没有环，快指针会到达链表末尾。

#### **代码实现**：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def detectCycle(head: ListNode) -> ListNode:
    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            break

    if not fast or not fast.next:
        return None

    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next

    return slow
```

#### **代码解释**：

1. **初始化**：定义快指针 `fast` 和慢指针 `slow`，都从链表头节点开始。

2. **判断环存在**：使用 `while` 循环，快指针每次走两步，慢指针每次走一步。如果快指针追上慢指针，说明链表中有环。

3. **定位环入口**：如果链表中有环，我们再次使用 `while` 循环，从链表头节点和快指针同时开始，每次都走一步，最终它们会在环的入口节点相遇。

4. **返回结果**：返回环的入口节点。

### 4. 栈与队列 - 栈的实现

#### **题目描述**：

使用链表实现一个栈。

#### **题目解析**：

链表实现栈的关键在于利用链表的插入和删除操作，可以在 O(1) 时间内完成。我们将链表的头部视为栈顶。

#### **代码实现**：

```python
class StackNode:
    def __init__(self, value):
        self.value = value
        self.next = None

class Stack:
    def __init__(self):
        self.top = None
        self.size = 0

    def push(self, value):
        new_node = StackNode(value)
        new_node.next = self.top
        self.top = new_node
        self.size += 1

    def pop(self):
        if self.is_empty():
            return None
        value = self.top.value
        self.top = self.top.next
        self.size -= 1
        return value

    def is_empty(self):
        return self.size == 0

    def peek(self):
        if self.is_empty():
            return None
        return self.top.value
```

#### **代码解释**：

1. **初始化**：定义栈节点类 `StackNode` 和栈类 `Stack`。

2. **push 操作**：创建新的栈节点，将其插入到链表头部，更新栈顶指针，并增加栈的大小。

3. **pop 操作**：检查栈是否为空，如果栈不为空，弹出栈顶节点，更新栈顶指针，并减少栈的大小，返回弹出的值。

4. **is_empty 操作**：检查栈是否为空。

5. **peek 操作**：检查栈是否为空，如果栈不为空，返回栈顶节点的值。

### 5. 栈与队列 - 队列的实现

#### **题目描述**：

使用链表实现一个队列。

#### **题目解析**：

队列是一种先进先出（FIFO）的数据结构，可以使用链表实现。队列通常有两个端点，一个用于入队，一个用于出队。

#### **代码实现**：

```python
class QueueNode:
    def __init__(self, value):
        self.value = value
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0

    def enqueue(self, value):
        new_node = QueueNode(value)
        if self.is_empty():
            self.front = new_node
        else:
            self.rear.next = new_node
        self.rear = new_node
        self.size += 1

    def dequeue(self):
        if self.is_empty():
            return None
        value = self.front.value
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        self.size -= 1
        return value

    def is_empty(self):
        return self.size == 0

    def peek(self):
        if self.is_empty():
            return None
        return self.front.value
```

#### **代码解释**：

1. **初始化**：定义队列节点类 `QueueNode` 和队列类 `Queue`。

2. **enqueue 操作**：创建新的队列节点，将其插入到链表尾部，更新队尾指针，并增加队列的大小。

3. **dequeue 操作**：检查队列是否为空，如果队列不为空，弹出链表头节点，更新队头指针，并减少队列的大小，返回弹出的值。

4. **is_empty 操作**：检查队列是否为空。

5. **peek 操作**：检查队列是否为空，如果队列不为空，返回链表头节点的值。

### 6. 排序算法 - 快速排序

#### **题目描述**：

实现快速排序算法，输入一个整数数组，将其排序。

#### **题目解析**：

快速排序是一种分治算法，其基本思想是通过递归地将数组分为两部分，一部分比基准值小，一部分比基准值大，然后对这两部分分别进行快速排序。

#### **代码实现**：

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

#### **代码解释**：

1. **基础情况**：如果数组长度小于等于 1，则返回原数组。

2. **选择基准值**：选择中间位置的元素作为基准值。

3. **分区**：将数组分为三部分：小于基准值的部分、等于基准值的部分和大于基准值的部分。

4. **递归**：对小于和大于基准值的部分分别进行快速排序，然后将三部分合并。

### 7. 排序算法 - 归并排序

#### **题目描述**：

实现归并排序算法，输入一个整数数组，将其排序。

#### **题目解析**：

归并排序是一种分治算法，其基本思想是将数组分为若干个子数组，分别对子数组进行排序，然后将排好序的子数组合并，得到最终的排序结果。

#### **代码实现**：

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

#### **代码解释**：

1. **基础情况**：如果数组长度小于等于 1，则返回原数组。

2. **递归分区**：将数组分为两部分，分别进行归并排序。

3. **合并**：将两个有序数组合并为一个有序数组。

### 8. 搜索算法 - 二分查找

#### **题目描述**：

在有序数组中查找一个目标值，返回其索引。如果没有找到，返回 -1。

#### **题目解析**：

二分查找算法通过不断缩小查找范围，将时间复杂度降低到 O(log n)。

#### **代码实现**：

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

#### **代码解释**：

1. **初始化**：定义左右边界。

2. **循环**：当左边界小于等于右边界时，计算中间值。

3. **比较**：如果中间值等于目标值，返回索引。

4. **调整边界**：根据目标值与中间值的比较结果，调整左右边界。

5. **返回结果**：如果找不到目标值，返回 -1。

### 9. 堆排序

#### **题目描述**：

实现堆排序算法，输入一个整数数组，将其排序。

#### **题目解析**：

堆排序利用二叉堆的特性，通过交换堆顶元素与堆的最后一个元素，然后重新调整堆结构，实现排序。

#### **代码实现**：

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
```

#### **代码解释**：

1. **heapify 函数**：将元素调整到合适位置，使其满足堆的性质。

2. **heap_sort 函数**：首先将数组转换成大顶堆，然后依次取出堆顶元素并调整堆，实现排序。

### 10. 字符串匹配算法 - KMP

#### **题目描述**：

实现 KMP 算法，找到字符串 `pattern` 在字符串 `text` 中的所有匹配位置。

#### **题目解析**：

KMP 算法通过构建部分匹配表（前缀表），避免不必要的字符比较，提高字符串匹配的效率。

#### **代码实现**：

```python
def compute_lps(pattern):
    lps = [0] * len(pattern)
    length = 0
    i = 1
    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    lps = compute_lps(pattern)
    i = j = 0
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            return i - j
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    return -1
```

#### **代码解释**：

1. **compute_lps 函数**：计算部分匹配值，构建前缀表。

2. **kmp_search 函数**：利用前缀表进行匹配，提高效率。

### 11. 前缀树

#### **题目描述**：

实现前缀树（Trie）的数据结构，并实现 `search` 和 `insert` 方法。

#### **题目解析**：

前缀树是一种树形结构，用于存储字符串。每个节点代表一个字符，从根节点到某个节点的路径表示一个字符串的前缀。

#### **代码实现**：

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word
```

#### **代码解释**：

1. **TrieNode 类**：定义前缀树节点，包含子节点字典和是否为单词结束标志。

2. **Trie 类**：实现插入和查找方法。

3. **insert 方法**：递归地插入单词，创建新节点并标记为单词结束。

4. **search 方法**：递归地查找单词，返回是否找到。

### 12. 集合与映射 - 哈希表

#### **题目描述**：

实现哈希表的数据结构，并实现 `insert`、`delete` 和 `search` 方法。

#### **题目解析**：

哈希表通过哈希函数将关键字转换成数组索引，实现对数据的快速插入、删除和查找。

#### **代码实现**：

```python
class HashTable:
    def __init__(self, size=1000):
        self.size = size
        self.table = [None] * size

    def hash_function(self, key):
        return key % self.size

    def insert(self, key, value):
        index = self.hash_function(key)
        if not self.table[index]:
            self.table[index] = [(key, value)]
        else:
            self.table[index].append((key, value))

    def delete(self, key):
        index = self.hash_function(key)
        if self.table[index]:
            self.table[index] = [pair for pair in self.table[index] if pair[0] != key]

    def search(self, key):
        index = self.hash_function(key)
        if self.table[index]:
            for pair in self.table[index]:
                if pair[0] == key:
                    return pair[1]
        return None
```

#### **代码解释**：

1. **HashTable 类**：定义哈希表类，包含哈希函数、插入、删除和查找方法。

2. **hash_function 方法**：实现哈希函数。

3. **insert 方法**：将关键字和值插入到哈希表中。

4. **delete 方法**：从哈希表中删除关键字。

5. **search 方法**：在哈希表中查找关键字并返回值。

### 13. 图算法 - 深度优先搜索

#### **题目描述**：

实现图的深度优先搜索（DFS）算法。

#### **题目解析**：

深度优先搜索是一种用于遍历或搜索图的数据结构，它从起点开始，沿着某一路径深入到尽可能远的节点，然后回溯。

#### **代码实现**：

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    def dfs(self, v, visited, result):
        visited[v] = True
        result.append(v)
        for neighbor in self.graph[v]:
            if not visited[neighbor]:
                self.dfs(neighbor, visited, result)

    def dfs_iterative(self, v):
        stack = [v]
        visited = [False] * (max(self.graph.keys()) + 1)
        result = []
        while stack:
            node = stack.pop()
            if not visited[node]:
                visited[node] = True
                result.append(node)
                stack.extend([neighbor for neighbor in self.graph[node] if not visited[neighbor]])
        return result

    def dfs_recursive(self, v):
        visited = [False] * (max(self.graph.keys()) + 1)
        result = []
        self.dfs(v, visited, result)
        return result
```

#### **代码解释**：

1. **Graph 类**：定义图类，包含添加边、深度优先搜索递归实现和迭代实现。

2. **add_edge 方法**：添加无向图边。

3. **dfs 方法**：递归实现深度优先搜索。

4. **dfs_iterative 方法**：迭代实现深度优先搜索。

5. **dfs_recursive 方法**：递归实现深度优先搜索。

### 14. 图算法 - 广度优先搜索

#### **题目描述**：

实现图的广度优先搜索（BFS）算法。

#### **题目解析**：

广度优先搜索是一种用于遍历或搜索图的数据结构，它从起点开始，依次访问起点相邻的节点，然后访问下一层的节点。

#### **代码实现**：

```python
from collections import deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    def bfs(self, start):
        visited = [False] * (max(self.graph.keys()) + 1)
        queue = deque([start])
        visited[start] = True
        result = []
        while queue:
            node = queue.popleft()
            result.append(node)
            for neighbor in self.graph[node]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        return result
```

#### **代码解释**：

1. **Graph 类**：定义图类，包含添加边和广度优先搜索方法。

2. **add_edge 方法**：添加无向图边。

3. **bfs 方法**：实现广度优先搜索。

### 15. 算法 - 最小生成树

#### **题目描述**：

实现 Prim 算法，求解无向图的最小生成树。

#### **题目解析**：

Prim 算法是一种用于求解最小生成树的贪心算法，它从一个节点开始，逐步增加新节点和边，直到覆盖所有节点。

#### **代码实现**：

```python
def prim_algorithm(graph):
    visited = [False] * (len(graph))
    min_edge = None
    min_index = -1
    start = 0
    result = []

    for _ in range(len(graph) - 1):
        visited[start] = True
        for index, edge in enumerate(graph[start]):
            if not visited[index]:
                if min_edge is None or edge < min_edge:
                    min_edge = edge
                    min_index = index

        result.append((start, min_index, min_edge))
        start = min_index

    return result
```

#### **代码解释**：

1. **初始化**：定义已访问节点列表、最小边和最小边索引。

2. **循环**：对于每次循环，选择一个未访问节点作为新节点，并将其加入生成树中。

3. **更新结果**：将新边添加到结果中。

### 16. 算法 - 最短路径

#### **题目描述**：

实现 Dijkstra 算法，求解图中两点之间的最短路径。

#### **题目解析**：

Dijkstra 算法是一种用于求解图中两点之间最短路径的贪心算法，它从起点开始，逐步扩展到其他节点，记录每个节点的最短路径。

#### **代码实现**：

```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances
```

#### **代码解释**：

1. **初始化**：定义距离字典和优先队列。

2. **循环**：从优先队列中取出距离最小的节点。

3. **更新距离**：对于每个邻居节点，计算新的距离，并将其加入优先队列。

4. **返回结果**：返回距离字典。

### 17. 算法 - 背包问题

#### **题目描述**：

实现 0-1 背包问题，求解给定物品的最大价值。

#### **题目解析**：

0-1 背包问题是一种经典的动态规划问题，它需要选择一定数量的物品放入容量为 W 的背包中，使得这些物品的总重量不超过 W，且总价值最大。

#### **代码实现**：

```python
def knapsack(W, weights, values):
    n = len(values)
    dp = [[0] * (W + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, W + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]

    return dp[n][W]
```

#### **代码解释**：

1. **初始化**：定义动态规划数组。

2. **循环**：对于每个物品和每个容量，计算是否将物品放入背包，并更新动态规划数组。

3. **返回结果**：返回最大价值。

### 18. 算法 - 动态规划

#### **题目描述**：

实现动态规划算法，求解斐波那契数列。

#### **题目解析**：

动态规划是一种通过保存子问题的解来避免重复计算的方法。斐波那契数列可以通过递归实现，但通过动态规划可以减少重复计算，提高效率。

#### **代码实现**：

```python
def fibonacci(n):
    dp = [0] * (n + 1)
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```

#### **代码解释**：

1. **初始化**：定义动态规划数组。

2. **循环**：根据斐波那契数列的定义，更新动态规划数组。

3. **返回结果**：返回斐波那契数列的第 n 项。

### 19. 算法 - 股票买卖

#### **题目描述**：

实现算法，找出只包含一对相邻交易的最有利利润。假设每笔交易需支付手续费 `fee`。

#### **题目解析**：

这是一个经典的动态规划问题，我们需要维护两个状态：持有股票和不持有股票。

#### **代码实现**：

```python
def maxProfit(prices, fee):
    hold, not_hold = -prices[0], 0

    for price in prices:
        hold, not_hold = max(hold, not_hold - fee), max(not_hold, hold + price)

    return not_hold
```

#### **代码解释**：

1. **初始化**：定义持有股票和不持有股票的初始状态。

2. **循环**：更新持有和不持有股票的状态。

3. **返回结果**：返回不持有股票的最大利润。

### 20. 算法 - 递归

#### **题目描述**：

实现递归算法，求斐波那契数列的第 n 项。

#### **题目解析**：

递归是一种编程范式，通过重复调用自身来解决问题。斐波那契数列可以通过递归直接实现。

#### **代码实现**：

```python
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
```

#### **代码解释**：

1. **基础情况**：当 n <= 1 时，返回 n。

2. **递归调用**：递归计算斐波那契数列的第 n-1 项和第 n-2 项，并相加。

### 21. 算法 - 股票买卖 II

#### **题目描述**：

实现算法，计算在一个无限资金的情况下，最多能完成多少笔交易以获取最大利润。假设每次交易的最低价格为前一次交易的最高价格。

#### **题目解析**：

这是一个贪心算法问题，我们可以通过每次找到当前价格与前一次交易价格之间的差值，并将其累加到总利润中。

#### **代码实现**：

```python
def maxProfitII(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    return profit
```

#### **代码解释**：

1. **循环**：遍历价格数组，每次找到价格上升的差值并累加到总利润。

2. **返回结果**：返回总利润。

### 22. 算法 - 合并区间

#### **题目描述**：

给定一组已排序的区间列表，合并所有重叠的区间。

#### **题目解析**：

我们可以通过遍历区间列表，合并重叠的区间。每次找到当前区间与上一个区间的交集，如果交集存在，则合并；否则，将当前区间加入结果列表。

#### **代码实现**：

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for interval in intervals[1:]:
        last_end, curr_start = result[-1][1], interval[0]
        curr_end = interval[1]

        if curr_start <= last_end:
            result[-1] = (result[-1][0], max(last_end, curr_end))
        else:
            result.append(interval)

    return result
```

#### **代码解释**：

1. **排序**：将区间列表按起始值排序。

2. **初始化**：将第一个区间加入结果列表。

3. **循环**：遍历区间列表，合并重叠区间。

4. **返回结果**：返回合并后的区间列表。

### 23. 算法 - 盒子翻转

#### **题目描述**：

给定一组盒子，每个盒子有一个不同的重量和高度，按照重量递增的顺序排列。你需要将所有盒子堆叠在一起，使得堆叠后的总高度最大。

#### **题目解析**：

我们可以使用贪心算法，每次选择当前最高盒子和下一个最高盒子的组合，堆叠后总高度最大。

#### **代码实现**：

```python
def maximumHeight(boxTypes):
    boxTypes.sort(key=lambda x: x[1])
    n = len(boxTypes)
    dp = [[False] * (n + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        dp[i][0] = True

    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if boxTypes[i - 1][0] > boxTypes[j - 1][0]:
                dp[i][j] = dp[i][j - 1]
            else:
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]

    result = 0
    for i in range(1, n + 1):
        if dp[n][i]:
            result = max(result, i * boxTypes[i - 1][1])

    return result
```

#### **代码解释**：

1. **排序**：将盒子按高度排序。

2. **初始化**：定义动态规划数组。

3. **循环**：更新动态规划数组。

4. **计算最大高度**：遍历动态规划数组，计算最大高度。

### 24. 算法 - 最大矩形

#### **题目描述**：

给定一个由 0 和 1 组成的二维矩阵，找到其中的最大矩形面积。

#### **题目解析**：

我们可以将问题转化为计算矩阵每一行的最大矩形面积，然后取最大值。对于每一行，我们可以将其看作一个高度数组，通过计算高度数组中的最大矩形面积。

#### **代码实现**：

```python
def maximalRectangle(matrix):
    if not matrix:
        return 0

    max_area = 0
    height = [0] * len(matrix[0])
    for row in matrix:
        for i in range(len(row)):
            if row[i] == '1':
                height[i] += 1
            else:
                height[i] = 0

        stack = [-1]
        for i in range(len(height)):
            while height[i] < height[stack[-1]]:
                h = height[stack.pop()]
                w = i - stack[-1] - 1
                max_area = max(max_area, h * w)

            stack.append(i)

    return max_area
```

#### **代码解释**：

1. **初始化**：定义高度数组。

2. **循环**：更新高度数组。

3. **计算最大矩形面积**：使用单调栈计算最大矩形面积。

### 25. 算法 - 接雨水

#### **题目描述**：

给定一个由 0 和 1 组成的二维矩阵，计算可以接雨水的最大容量。

#### **题目解析**：

我们可以将问题转化为计算矩阵每一列的最大高度，然后用这些高度计算可以接雨水的最大容量。对于每一列，我们可以将其看作一个高度数组，通过计算高度数组中的最大高度。

#### **代码实现**：

```python
def trap(matrix):
    if not matrix:
        return 0

    max_area = 0
    left_max = [0] * len(matrix[0])
    right_max = [0] * len(matrix[0])

    for i in range(1, len(matrix)):
        left_max[i] = max(left_max[i - 1], matrix[i - 1][0])

    for i in range(len(matrix) - 2, -1, -1):
        right_max[i] = max(right_max[i + 1], matrix[i + 1][len(matrix[0]) - 1])

    for i in range(len(matrix)):
        h = min(left_max[i], right_max[i]) - matrix[i][0]
        max_area += h * (i + 1)

    return max_area
```

#### **代码解释**：

1. **初始化**：定义左右最大高度数组。

2. **循环**：更新左右最大高度数组。

3. **计算最大容量**：计算每列可以接雨水的最大容量，并累加到总容量中。

### 26. 算法 - 矩阵中的路径

#### **题目描述**：

给定一个包含 'X' 和 'O' 的二维矩阵，找到从左上角到右下角的最短路径，路径只能向下或向右移动。

#### **题目解析**：

我们可以使用广度优先搜索（BFS）来找到最短路径。每次从队列中取出一个节点，尝试向下或向右移动，并将新位置加入队列。

#### **代码实现**：

```python
from collections import deque

def findShortestPath(matrix):
    rows, cols = len(matrix), len(matrix[0])
    q = deque([(0, 0)])
    visited = set()
    dist = [[float('inf')] * cols for _ in range(rows)]

    dist[0][0] = 0
    while q:
        i, j = q.popleft()
        for dir, new_i, new_j in [(0, i + 1, j), (1, i, j + 1)]:
            if 0 <= new_i < rows and 0 <= new_j < cols and matrix[new_i][new_j] == 'O' and (new_i, new_j) not in visited:
                visited.add((new_i, new_j))
                dist[new_i][new_j] = dist[i][j] + 1
                q.append((new_i, new_j))

    return dist[rows - 1][cols - 1]
```

#### **代码解释**：

1. **初始化**：定义队列、已访问节点集和距离数组。

2. **循环**：从队列中取出一个节点，尝试向下或向右移动，并更新距离数组。

3. **返回结果**：返回最短路径长度。

### 27. 算法 - 矩阵中的最长递增路径

#### **题目描述**：

给定一个包含整数的二维矩阵，找到矩阵中的最长递增路径的长度。

#### **题目解析**：

我们可以使用动态规划（DP）来解决这个问题。对于每个节点，计算到达该节点的最长递增路径长度，并更新全局最长路径长度。

#### **代码实现**：

```python
def longestIncreasingPath(matrix):
    if not matrix:
        return 0

    rows, cols = len(matrix), len(matrix[0])
    dp = [[1] * cols for _ in range(rows)]

    for i in range(rows):
        for j in range(cols):
            if matrix[i][j] > 0:
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    x, y = i + dx, j + dy
                    if 0 <= x < rows and 0 <= y < cols and matrix[x][y] > matrix[i][j]:
                        dp[i][j] = max(dp[i][j], dp[x][y] + 1)

    return max(max(row) for row in dp)
```

#### **代码解释**：

1. **初始化**：定义动态规划数组。

2. **循环**：对于每个节点，计算到达该节点的最长递增路径长度。

3. **返回结果**：返回最长路径长度。

### 28. 算法 - 单调栈

#### **题目描述**：

使用单调栈找出数组中的下一个更大元素。

#### **题目解析**：

我们可以使用单调栈来解决这个问题。对于每个元素，我们将其与栈顶元素进行比较，如果当前元素大于栈顶元素，则将栈顶元素弹出，并将下一个更大元素的索引入栈。

#### **代码实现**：

```python
def nextGreaterElements(nums):
    n = len(nums)
    result = [-1] * n
    stack = []

    for i in range(n * 2):
        while stack and nums[stack[-1]] < nums[i % n]:
            result[stack.pop()] = nums[i % n]
        if i < n:
            stack.append(i)

    return result
```

#### **代码解释**：

1. **初始化**：定义结果数组和栈。

2. **循环**：遍历数组，更新结果数组和栈。

3. **返回结果**：返回结果数组。

### 29. 算法 - 逆波兰表达式求值

#### **题目描述**：

给定一个逆波兰表达式，求其值。

#### **题目解析**：

逆波兰表达式（RPN）是一种后缀表示法，其中的运算符位于其运算对象的后面。我们可以使用栈来计算逆波兰表达式的值。

#### **代码实现**：

```python
def evalRPN(tokens):
    stack = []

    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            op2 = stack.pop()
            op1 = stack.pop()
            if token == "+":
                stack.append(op1 + op2)
            elif token == "-":
                stack.append(op1 - op2)
            elif token == "*":
                stack.append(op1 * op2)
            else:
                stack.append(float(op1) / float(op2))
        else:
            stack.append(int(token))

    return stack[-1]
```

#### **代码解释**：

1. **初始化**：定义栈。

2. **循环**：遍历逆波兰表达式，根据操作符进行计算。

3. **返回结果**：返回计算结果。

### 30. 算法 - 岛屿数量

#### **题目描述**：

给定一个由 '1'（陆地）和 '0'（水）组成的二维网格，计算网格中的岛屿数量。

#### **题目解析**：

我们可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来解决这个问题。每次找到一个新的岛屿，将其标记为已访问，并计数。

#### **代码实现**：

```python
def numIslands(grid):
    def dfs(i, j):
        grid[i][j] = '0'
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            x, y = i + dx, j + dy
            if 0 <= x < rows and 0 <= y < cols and grid[x][y] == '1':
                dfs(x, y)

    rows, cols = len(grid), len(grid[0])
    count = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1

    return count
```

#### **代码解释**：

1. **定义 DFS 函数**：递归地搜索并标记岛屿。

2. **初始化**：定义网格的行数和列数。

3. **循环**：遍历网格，使用 DFS 搜索并计数岛屿。

4. **返回结果**：返回岛屿数量。

