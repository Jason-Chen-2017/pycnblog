                 

### 1. 二分查找算法

**题目：** 实现一个二分查找算法，用于在一个有序数组中查找一个特定元素。

**答案：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1
```

**解析：** 二分查找算法是一种高效的搜索算法，它将搜索范围分成两半，逐步缩小搜索范围，直到找到目标元素或确定元素不存在。在每次迭代中，算法都通过比较中间元素和目标元素的关系来决定下一轮搜索的上下界。

### 2. 快速排序算法

**题目：** 实现一个快速排序算法，用于对一个数组进行排序。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)
```

**解析：** 快速排序是一种高效的排序算法，它通过递归地将数组分成较小的子数组，并对每个子数组进行排序。快速排序的时间复杂度为 O(nlogn)，在大多数情况下都优于其他排序算法。

### 3. 判断字符串是否回文

**题目：** 实现一个函数，判断一个字符串是否是回文。

**答案：**

```python
def is_palindrome(s):
    return s == s[::-1]
```

**解析：** 一个字符串是回文，意味着它从前往后读和从后往前读都是一样的。这个函数通过字符串切片的逆序操作，将字符串与原字符串进行比较，来判断是否为回文。

### 4. 计数排序

**题目：** 实现一个计数排序算法，用于对一个数组进行排序。

**答案：**

```python
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)

    for num in arr:
        count[num] += 1

    sorted_arr = []
    for i, freq in enumerate(count):
        sorted_arr.extend([i] * freq)

    return sorted_arr
```

**解析：** 计数排序是一种非比较排序算法，它利用数组的值作为索引，通过计数来排序。这个算法的时间复杂度为 O(n+k)，其中 k 是数组的最大值和最小值之差。

### 5. 红黑树

**题目：** 简述红黑树的特点和操作。

**答案：**

红黑树是一种自平衡的二叉搜索树，它具有以下特点：

* 每个节点都是红色或黑色。
* 根节点是黑色的。
* 每个叶节点（NIL节点）都是黑色的。
* 如果一个节点是红色的，则它的两个子节点都是黑色的。
* 从任何一个节点到其所有后代叶子节点的所有路径都包含相同数目的黑色节点。

红黑树的操作包括：

* 插入：在二叉搜索树中插入节点后，通过旋转和重新着色来保持树的平衡。
* 删除：在二叉搜索树中删除节点后，同样通过旋转和重新着色来保持树的平衡。

### 6. 动态规划

**题目：** 简述动态规划的基本思想。

**答案：** 动态规划是一种在数学、计算机科学和经济学等领域用于求解复杂问题的一种方法。它的基本思想是将问题分解为更小的子问题，并存储子问题的解，避免重复计算。

### 7. 最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]
```

**解析：** 最长公共子序列问题可以通过动态规划来解决，其中 dp[i][j] 表示 str1 的前 i 个字符和 str2 的前 j 个字符的最长公共子序列的长度。

### 8. 前缀树

**题目：** 实现一个前缀树，并实现以下功能：插入字符串、搜索字符串、搜索字符串前缀。

**答案：**

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

**解析：** 前缀树是一种树形数据结构，用于快速查找字符串和字符串前缀。每个节点包含一个字符和指向子节点的指针数组，以及一个标志来表示当前节点是否是某个单词的结尾。

### 9. 广度优先搜索

**题目：** 实现一个广度优先搜索算法，用于在一个无向图中查找最短路径。

**答案：**

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])

    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    print(neighbor)

    return visited
```

**解析：** 广度优先搜索（BFS）是一种遍历或搜索树或图的算法，它通过队列数据结构实现，首先访问起始节点，然后依次访问它的邻居节点，直到找到目标节点或遍历完整张图。

### 10. 深度优先搜索

**题目：** 实现一个深度优先搜索算法，用于在一个无向图中查找最短路径。

**答案：**

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    visited.add(start)
    print(start)

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

    return visited
```

**解析：** 深度优先搜索（DFS）是一种遍历或搜索树或图的算法，它通过递归实现，首先访问起始节点，然后递归地访问它的邻居节点，直到找到目标节点或遍历完整张图。

### 11. 字符串匹配算法（KMP）

**题目：** 实现一个字符串匹配算法（KMP），用于在一个字符串中查找一个子字符串。

**答案：**

```python
def compute_lps(pattern):
    lps = [0] * len(pattern)
    length = 0
    i = 1

    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1

    return lps

def kmp_search(text, pattern):
    lps = compute_lps(pattern)
    i = j = 0

    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            return i - j
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return -1
```

**解析：** Knuth-Morris-Pratt（KMP）算法是一种高效的字符串匹配算法。它通过计算最长公共前后缀（LPS）数组来减少不必要的比较，从而提高搜索效率。

### 12. 贪心算法

**题目：** 使用贪心算法求解背包问题。

**答案：**

```python
def knapsack(values, weights, capacity):
    n = len(values)
    items = [[values[i], weights[i]] for i in range(n)]
    items.sort(key=lambda x: x[0] / x[1], reverse=True)

    total_value = 0
    total_weight = 0
    for value, weight in items:
        if total_weight + weight <= capacity:
            total_value += value
            total_weight += weight
        else:
            fraction = (capacity - total_weight) / weight
            total_value += value * fraction
            break

    return total_value
```

**解析：** 背包问题是一种经典的贪心算法问题。在这个例子中，我们根据物品的价值与重量之比进行排序，并选择价值最大的物品装入背包，直到背包容量达到上限。

### 13. 二叉树遍历

**题目：** 实现二叉树的前序、中序和后序遍历。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_traversal(root):
    if root:
        print(root.val, end=' ')
        preorder_traversal(root.left)
        preorder_traversal(root.right)

def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print(root.val, end=' ')
        inorder_traversal(root.right)

def postorder_traversal(root):
    if root:
        postorder_traversal(root.left)
        postorder_traversal(root.right)
        print(root.val, end=' ')
```

**解析：** 二叉树遍历是树形数据结构的基础操作。前序遍历首先访问根节点，然后递归地遍历左子树和右子树；中序遍历首先递归地遍历左子树，然后访问根节点，最后递归地遍历右子树；后序遍历首先递归地遍历左子树，然后递归地遍历右子树，最后访问根节点。

### 14. 链表遍历

**题目：** 实现链表的前序、中序和后序遍历。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def print_list(head):
    while head:
        print(head.val, end=' ')
        head = head.next
```

**解析：** 链表遍历是链表数据结构的基础操作。在这个例子中，我们简单地通过循环遍历链表的每个节点，并打印节点的值。

### 15. 并查集

**题目：** 实现并查集（Union-Find），支持合并元素和查找元素是否在同一集合。

**答案：**

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            if self.size[root_x] < self.size[root_y]:
                self.parent[root_x] = root_y
                self.size[root_y] += self.size[root_x]
            else:
                self.parent[root_y] = root_x
                self.size[root_x] += self.size[root_y]
```

**解析：** 并查集是一种用于解决动态连通性问题（如社交网络中的好友关系、电子设备中的连通性等）的数据结构。在这个例子中，我们使用了路径压缩和按秩合并两种优化方法来提高查询和合并操作的效率。

### 16. 快排优化

**题目：** 改进快速排序算法，使其在最佳情况下也能保持 O(nlogn) 的时间复杂度。

**答案：**

```python
import random

def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = random.choice(arr)
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)
```

**解析：** 在原始的快速排序算法中，如果每次都选择第一个或最后一个元素作为 pivot，可能会导致最差情况下的时间复杂度为 O(n^2)。通过随机选择 pivot，可以避免这种情况，使平均时间复杂度保持在 O(nlogn)。

### 17. 设计LRU缓存

**题目：** 设计一个 LRU（Least Recently Used）缓存，支持插入和查询操作。

**答案：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key):
        if key not in self.cache:
            return -1
        else:
            self.cache.move_to_end(key)
            return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**解析：** LRU 缓存是一种基于最近最少使用（Least Recently Used）原则的缓存算法。在这个例子中，我们使用 OrderedDict 数据结构来实现 LRU 缓存，通过移动键值对到末尾来表示最近使用，并在缓存容量超过限制时移除最久未使用的键值对。

### 18. 滑动窗口最大值

**题目：** 设计一个滑动窗口最大值算法，给定一个数组和一个滑动窗口的大小，返回每个窗口中的最大值。

**答案：**

```python
from collections import deque

def max_sliding_window(nums, k):
    result = []
    window = deque()

    for i, num in enumerate(nums):
        if window and i - window[0][1] > k - 1:
            window.popleft()
        while window and window[-1][0] < num:
            window.pop()
        window.append((num, i))
        if i >= k - 1:
            result.append(window[0][0])

    return result
```

**解析：** 在这个算法中，我们使用一个双端队列（deque）来维护当前窗口中的最大值。对于每个新元素，我们首先将队列中不在当前窗口内的元素移除，然后从队列尾部移除小于当前元素的元素，最后将当前元素添加到队列的尾部。在每个窗口结束时，队列的头部元素即为该窗口的最大值。

### 19. 设计哈希表

**题目：** 设计一个哈希表，支持插入、删除和查询操作。

**答案：**

```python
class HashTable:
    def __init__(self):
        self.table_size = 100
        self.table = [None] * self.table_size

    def _hash(self, key):
        return hash(key) % self.table_size

    def insert(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    self.table[index][i] = (key, value)
                    return
            self.table[index].append((key, value))

    def delete(self, key):
        index = self._hash(key)
        if self.table[index]:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    del self.table[index][i]
                    return True
        return False

    def get(self, key):
        index = self._hash(key)
        if self.table[index]:
            for k, v in self.table[index]:
                if k == key:
                    return v
        return None
```

**解析：** 在这个哈希表中，我们使用一个长度为 100 的数组作为哈希表。插入操作通过哈希函数计算键的索引，并在该索引处添加键值对；删除操作通过哈希函数找到键的索引，并在该索引处删除键值对；查询操作通过哈希函数找到键的索引，并在该索引处查找键值对。

### 20. 设计堆

**题目：** 设计一个最大堆，支持插入和提取最大元素操作。

**答案：**

```python
import heapq

class MaxHeap:
    def __init__(self):
        self.heap = []

    def insert(self, val):
        heapq.heappush(self.heap, -val)

    def extract_max(self):
        if self.heap:
            return -heapq.heappop(self.heap)
        return None
```

**解析：** 在这个最大堆中，我们使用一个列表作为堆，并通过在元素前面添加负号来实现最大堆。插入操作通过 `heappush` 方法将元素添加到堆的尾部；提取最大元素操作通过 `heappop` 方法从堆的头部移除最大元素。

### 21. 设计优先队列

**题目：** 设计一个优先队列，支持插入、删除和获取最小元素操作。

**答案：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def insert(self, priority, value):
        heapq.heappush(self.heap, (priority, value))

    def remove(self, value):
        if self.heap:
            for i, (priority, v) in enumerate(self.heap):
                if v == value:
                    del self.heap[i]
                    heapq.heapify(self.heap)
                    return True
        return False

    def get_min(self):
        if self.heap:
            return self.heap[0][1]
        return None
```

**解析：** 在这个优先队列中，我们使用一个列表作为堆，并通过在元素前面添加优先级来实现。插入操作通过 `heappush` 方法将元素添加到堆的尾部；删除操作通过遍历堆并删除指定值的方法实现；获取最小元素操作通过获取堆的头部元素的方法实现。

### 22. 设计二叉搜索树

**题目：** 设计一个二叉搜索树，支持插入、删除和查找操作。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        else:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)

    def delete(self, val):
        if self.root:
            self.root = self._delete(self.root, val)

    def _delete(self, node, val):
        if node is None:
            return node

        if val < node.val:
            node.left = self._delete(node.left, val)
        elif val > node.val:
            node.right = self._delete(node.right, val)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            temp = self._find_min(node.right)
            node.val = temp.val
            node.right = self._delete(node.right, temp.val)

        return node

    def find(self, val):
        if self.root:
            return self._find(self.root, val)

    def _find(self, node, val):
        if node is None:
            return None

        if val == node.val:
            return node
        elif val < node.val:
            return self._find(node.left, val)
        else:
            return self._find(node.right, val)

    def _find_min(self, node):
        current = node
        while current.left:
            current = current.left
        return current
```

**解析：** 在这个二叉搜索树中，我们使用递归方法实现插入、删除和查找操作。插入操作通过比较当前节点的值和要插入的值来决定创建左子树或右子树；删除操作需要考虑三种情况：删除节点没有子节点、有一个子节点和有两个子节点；查找操作通过递归地搜索左右子树来找到目标节点。

### 23. 设计栈

**题目：** 设计一个栈，支持插入、删除和获取栈顶元素操作。

**答案：**

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, val):
        self.stack.append(val)

    def pop(self):
        if self.stack:
            return self.stack.pop()
        return None

    def top(self):
        if self.stack:
            return self.stack[-1]
        return None
```

**解析：** 在这个栈的实现中，我们使用一个列表来存储栈的元素。插入操作通过在列表的末尾添加元素实现；删除操作通过从列表的末尾移除元素实现；获取栈顶元素操作通过访问列表的最后一个元素实现。

### 24. 设计队列

**题目：** 设计一个队列，支持插入、删除和获取队首元素操作。

**答案：**

```python
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, val):
        self.queue.append(val)

    def dequeue(self):
        if self.queue:
            return self.queue.pop(0)
        return None

    def front(self):
        if self.queue:
            return self.queue[0]
        return None
```

**解析：** 在这个队列的实现中，我们使用一个列表来存储队列的元素。插入操作通过在列表的末尾添加元素实现；删除操作通过从列表的开头移除元素实现；获取队首元素操作通过访问列表的第一个元素实现。

### 25. 设计循环队列

**题目：** 设计一个循环队列，支持插入、删除和获取队首元素操作。

**答案：**

```python
class CircularQueue:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.head = self.tail = 0

    def enqueue(self, val):
        if (self.tail + 1) % self.capacity != self.head:
            self.queue[self.tail] = val
            self.tail = (self.tail + 1) % self.capacity
        else:
            print("Queue is full")

    def dequeue(self):
        if self.head != self.tail:
            val = self.queue[self.head]
            self.queue[self.head] = None
            self.head = (self.head + 1) % self.capacity
            return val
        else:
            print("Queue is empty")
            return None

    def front(self):
        if self.head != self.tail:
            return self.queue[self.head]
        else:
            print("Queue is empty")
            return None
```

**解析：** 在这个循环队列的实现中，我们使用一个固定大小的数组来存储队列的元素。插入操作和删除操作通过更新 head 和 tail 指针来实现，并在数组满了时循环回到开头。如果队列为空或已满，相应的操作会打印一条错误消息。

### 26. 设计单调栈

**题目：** 设计一个单调栈，用于找到数组中每个元素左边和右边第一个小于或等于它的元素。

**答案：**

```python
def next_smaller_elements(arr):
    stack = []
    result = [-1] * len(arr)

    for i in range(len(arr) - 1, -1, -1):
        while stack and arr[i] <= arr[stack[-1]]:
            stack.pop()
        if stack:
            result[i] = arr[stack[-1]]
        stack.append(i)

    return result

def previous_smaller_elements(arr):
    stack = []
    result = [-1] * len(arr)

    for i in range(len(arr)):
        while stack and arr[i] <= arr[stack[-1]]:
            stack.pop()
        if stack:
            result[i] = arr[stack[-1]]
        stack.append(i)

    return result
```

**解析：** 在这两个函数中，我们分别使用单调递增栈和单调递减栈来找到数组中每个元素左边和右边第一个小于或等于它的元素。对于单调递增栈，我们从数组的结尾开始，将小于或等于当前元素的索引弹出栈；对于单调递减栈，我们从数组的开头开始，将小于或等于当前元素的索引弹出栈。

### 27. 设计缓存

**题目：** 设计一个缓存系统，支持插入、删除和查找操作，并限制缓存大小。

**答案：**

```python
from collections import OrderedDict

class Cache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key):
        if key in self.cache:
            self.cache.move_to_end(key)
            return self.cache[key]
        else:
            return -1

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**解析：** 在这个缓存系统中，我们使用有序字典（OrderedDict）来实现缓存，并根据缓存大小限制来管理缓存。当插入新键值对时，如果缓存已满，则会移除最旧的键值对。

### 28. 设计缓存 - 使用有序数组

**题目：** 设计一个缓存系统，支持插入、删除和查找操作，并使用有序数组来优化缓存操作。

**答案：**

```python
from sortedcontainers import SortedList

class Cache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = SortedList()

    def get(self, key):
        if key in self.cache:
            self.cache.remove(key)
            self.cache.add(key)
            return self.cache.bisect_left(key)
        else:
            return -1

    def put(self, key):
        if len(self.cache) >= self.capacity:
            self.cache.remove(self.cache[0])
        self.cache.add(key)
```

**解析：** 在这个缓存系统中，我们使用 SortedList 来自动维护一个有序数组，以优化缓存操作。当插入新键值对时，如果缓存已满，则会移除最旧的键值对。

### 29. 设计LRU缓存 - 双向链表

**题目：** 设计一个基于双向链表和哈希表的 LRU 缓存。

**答案：**

```python
class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        if key in self.cache:
            node = self.cache[key]
            self._move_to_head(node)
            return node.val
        else:
            return -1

    def put(self, key, val):
        if key in self.cache:
            node = self.cache[key]
            node.val = val
            self._move_to_head(node)
        else:
            if len(self.cache) >= self.capacity:
                node = self.tail.prev
                self.cache.pop(node.key)
                self._delete_node(node)
            new_node = Node(key, val)
            self.cache[key] = new_node
            self._add_to_head(new_node)

    def _add_to_head(self, node):
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
        node.prev = self.head

    def _delete_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _move_to_head(self, node):
        self._delete_node(node)
        self._add_to_head(node)
```

**解析：** 在这个基于双向链表和哈希表的 LRU 缓存中，我们使用一个双向链表来维护最近访问的节点，并使用一个哈希表来快速访问节点。当访问或插入一个新的键值对时，我们会将其移动到双向链表的头部。

### 30. 设计双向链表

**题目：** 设计一个双向链表，支持插入、删除和遍历操作。

**答案：**

```python
class Node:
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, val):
        new_node = Node(val)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def remove(self, node):
        if node.prev:
            node.prev.next = node.next
        if node.next:
            node.next.prev = node.prev
        if node == self.head:
            self.head = node.next
        if node == self.tail:
            self.tail = node.prev
        node.prev = None
        node.next = None

    def print_list(self):
        current = self.head
        while current:
            print(current.val, end=' ')
            current = current.next
        print()
```

**解析：** 在这个双向链表的实现中，我们定义了一个 Node 类来表示链表的节点，并使用一个 DoublyLinkedList 类来实现链表的操作。插入操作通过创建新节点并将其添加到链表的末尾；删除操作通过更新前后节点的指针来实现；遍历操作通过从 head 开始逐个访问节点来实现。

