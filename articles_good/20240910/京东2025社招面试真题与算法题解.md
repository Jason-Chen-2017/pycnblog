                 

### 京东2025社招面试真题与算法题解

#### 1. 面试题

##### 1.1 设计一个算法，判断一个字符串是否为回文字符串

**题目描述：** 编写一个函数，判断一个给定的字符串是否为回文字符串。如果是，返回 true；否则，返回 false。

**示例：**

```go
func isPalindrome(s string) bool {
    // TODO
}
```

**答案：**

```go
func isPalindrome(s string) bool {
    s = strings.ToLower(s)
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

**解析：** 使用双指针法，一个指针指向字符串头部，一个指针指向字符串尾部，每次循环移动两个指针，如果两个指针指向的字符不同，则字符串不是回文字符串，否则继续移动。如果移动到中间，则字符串是回文字符串。

##### 1.2 设计一个堆排序算法

**题目描述：** 编写一个堆排序算法，对一个整数数组进行排序。

**示例：**

```go
func heapSort(nums []int) {
    // TODO
}
```

**答案：**

```go
func heapSort(nums []int) {
    n := len(nums)
    buildMaxHeap(nums)
    for i := n - 1; i > 0; i-- {
        nums[0], nums[i] = nums[i], nums[0]
        maxHeapify(nums, 0, i)
    }
}

func buildMaxHeap(nums []int) {
    n := len(nums)
    for i := n/2 - 1; i >= 0; i-- {
        maxHeapify(nums, i, n)
    }
}

func maxHeapify(nums []int, i, n int) {
    left := 2*i + 1
    right := 2*i + 2
    largest := i
    if left < n && nums[left] > nums[largest] {
        largest = left
    }
    if right < n && nums[right] > nums[largest] {
        largest = right
    }
    if largest != i {
        nums[i], nums[largest] = nums[largest], nums[i]
        maxHeapify(nums, largest, n)
    }
}
```

**解析：** 堆排序分为两个步骤：构建最大堆和排序。首先，构建一个最大堆，然后通过不断将堆顶元素（最大元素）移到数组尾部，再对剩余部分进行最大堆化，直到数组排序。

##### 1.3 设计一个二分查找算法

**题目描述：** 编写一个二分查找算法，在一个有序整数数组中查找一个特定的整数，如果找到，返回其索引；否则，返回 -1。

**示例：**

```go
func binarySearch(nums []int, target int) int {
    // TODO
}
```

**答案：**

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**解析：** 二分查找算法通过不断将搜索范围缩小一半，直到找到目标元素或确定目标元素不存在。在每次循环中，计算中间位置 `mid`，然后与目标元素比较，根据比较结果调整搜索范围。

##### 1.4 设计一个快速排序算法

**题目描述：** 编写一个快速排序算法，对一个整数数组进行排序。

**示例：**

```go
func quickSort(nums []int) {
    // TODO
}
```

**答案：**

```go
func quickSort(nums []int) {
    quickSortHelper(nums, 0, len(nums)-1)
}

func quickSortHelper(nums []int, left, right int) {
    if left >= right {
        return
    }
    pivotIndex := partition(nums, left, right)
    quickSortHelper(nums, left, pivotIndex-1)
    quickSortHelper(nums, pivotIndex+1, right)
}

func partition(nums []int, left, right int) int {
    pivot := nums[right]
    i := left
    for j := left; j < right; j++ {
        if nums[j] <= pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    nums[i], nums[right] = nums[right], nums[i]
    return i
}
```

**解析：** 快速排序通过选择一个基准元素，将数组划分为两部分，然后递归地对两部分进行快速排序。划分部分使用分区算法，将小于等于基准元素的放到左边，大于基准元素的放到右边。

##### 1.5 设计一个链表反转算法

**题目描述：** 编写一个函数，将一个单链表反转。

**示例：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    // TODO
}
```

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head
    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}
```

**解析：** 使用迭代方法，遍历链表，将当前节点的 `Next` 指针指向前一个节点，从而实现链表反转。

##### 1.6 设计一个合并两个有序链表算法

**题目描述：** 编写一个函数，合并两个有序单链表，返回合并后的链表。

**示例：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    // TODO
}
```

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

**解析：** 使用递归方法，比较两个链表的头节点，选择较小的值作为合并后的链表的头节点，然后递归地合并剩下的部分。

##### 1.7 设计一个排序链表算法

**题目描述：** 编写一个函数，对单链表进行排序。

**示例：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func sortList(head *ListNode) *ListNode {
    // TODO
}
```

**答案：**

```go
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    mid := middleNode(head)
    nextOfMid := mid.Next
    mid.Next = nil
    left := sortList(head)
    right := sortList(nextOfMid)
    return merge(left, right)
}

func merge(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = merge(l1.Next, l2)
        return l1
    } else {
        l2.Next = merge(l1, l2.Next)
        return l2
    }
}

func middleNode(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```

**解析：** 使用归并排序方法，首先找到链表的中点，将链表分成两部分，然后递归地对两部分进行排序，最后将排序后的两部分合并。

##### 1.8 设计一个反转整数算法

**题目描述：** 编写一个函数，反转一个整数。

**示例：**

```go
func reverse(x int) int {
    // TODO
}
```

**答案：**

```go
func reverse(x int) int {
    res := 0
    for x != 0 {
        if res > (1<<31)/2 || res < -(1<<31)/2 && x%10 < 0 {
            return 0
        }
        res = res*10 + x%10
        x /= 10
    }
    return res
}
```

**解析：** 使用迭代方法，每次取整数的最后一位，将其添加到结果的前面，然后去除最后一位，重复这个过程，直到整数变为 0。

##### 1.9 设计一个最长公共前缀算法

**题目描述：** 编写一个函数，找出字符串数组中的最长公共前缀。

**示例：**

```go
func longestCommonPrefix(strs []string) string {
    // TODO
}
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 首先取第一个字符串作为前缀，然后逐个与后续字符串比较，找出它们的公共前缀。比较时，从第一个字符开始，一旦发现不同的字符，就截取前缀。

##### 1.10 设计一个两个数组的交集 II 算法

**题目描述：** 给定两个整数数组 `nums1` 和 `nums2`，请编写一个函数来计算它们的交集。

**示例：**

```go
func intersect(nums1 []int, nums2 []int) []int {
    // TODO
}
```

**答案：**

```go
func intersect(nums1 []int, nums2 []int) []int {
    m := make(map[int]int)
    for _, v := range nums1 {
        m[v]++
    }
    var res []int
    for _, v := range nums2 {
        if m[v] > 0 {
            res = append(res, v)
            m[v]--
        }
    }
    return res
}
```

**解析：** 使用哈希表记录数组 `nums1` 中每个元素出现的次数，然后遍历数组 `nums2`，如果元素在哈希表中存在，并且其出现的次数大于 0，则将其添加到结果数组中，并将哈希表中该元素的出现次数减 1。

##### 1.11 设计一个有效的数独算法

**题目描述：** 编写一个函数，判断一个 9x9 数组是否为有效的数独。需要考虑以下几种情况：

1. 每行只包含 1 到 9 的唯一数字。
2. 每列只包含 1 到 9 的唯一数字。
3. 每个 3x3 子数组也只包含 1 到 9 的唯一数字。

**示例：**

```go
func isValidSudoku(board [][]byte) bool {
    // TODO
}
```

**答案：**

```go
func isValidSudoku(board [][]byte) bool {
    rows := [9][9]bool{}
    cols := [9][9]bool{}
    squares := [9][9]bool{}
    for i, row := range board {
        for j, v := range row {
            num := int(v - '0')
            if num > 0 {
                if rows[i][num] || cols[j][num] || squares[i/3*3+j/3][num] {
                    return false
                }
                rows[i][num] = true
                cols[j][num] = true
                squares[i/3*3+j/3][num] = true
            }
        }
    }
    return true
}
```

**解析：** 使用 3 个二维数组分别记录每行、每列、每个 3x3 子数组的元素情况。遍历数组，对于每个非空单元格，如果对应的行、列、子数组的值已经为 `true`，则说明该数独不合法，返回 `false`。

##### 1.12 设计一个三数之和算法

**题目描述：** 给定一个包含 n 个整数的数组 `nums` 和一个目标值 `target`，找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。

**示例：**

```go
func threeSumClosest(nums []int, target int) int {
    // TODO
}
```

**答案：**

```go
func threeSumClosest(nums []int, target int) int {
    sort.Ints(nums)
    closest := nums[0] + nums[1] + nums[2]
    for i := 0; i < len(nums)-2; i++ {
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                return target
            }
            if abs(target-sum) < abs(closest-target) {
                closest = sum
            }
            if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return closest
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

**解析：** 先对数组进行排序，然后使用双指针法找到与给定目标值最接近的三数之和。对于每个固定的第一个数，使用两个指针从第二个数和第三个数开始遍历，如果三数之和小于目标值，则将左指针右移；如果三数之和大于目标值，则将右指针左移。

##### 1.13 设计一个有效的字母异位词组算法

**题目描述：** 编写一个函数，返回一个包含在字符串 `words` 中每个单词的所有字母异位词的真集。

**示例：**

```go
func groupAnagrams(words []string) [][]string {
    // TODO
}
```

**答案：**

```go
func groupAnagrams(words []string) [][]string {
    m := map[string][]string{}
    for _, word := range words {
        sortString := sortString(word)
        m[sortString] = append(m[sortString], word)
    }
    res := make([][]string, 0, len(m))
    for _, v := range m {
        res = append(res, v)
    }
    return res
}

func sortString(s string) string {
    bytes := []byte(s)
    sort.Slice(bytes, func(i, j int) bool {
        return bytes[i] < bytes[j]
    })
    return string(bytes)
}
```

**解析：** 遍历字符串数组，将每个单词按字母排序后作为键存储在哈希表中。如果键已存在，则将单词添加到对应的值数组中。最后，遍历哈希表，将所有值数组添加到结果数组中。

##### 1.14 设计一个填充每个节点的下一个右侧节点指针 II 算法

**题目描述：** 给定一个完美二叉树，填充它的每个节点的下一个右侧节点指针，只需要将同一层的节点连接起来。填充完成后，预期整个树按层级遍历序列添加了下一个右侧节点指针，并满足：

1. 从任何节点出发，完全填充了所有节点的下一右侧节点指针；
2. 初始值为 `null`。

**示例：**

```go
func connect(root *Node) *Node {
    // TODO
}
```

**答案：**

```go
func connect(root *Node) *Node {
    if root == nil {
        return nil
    }
    connectTwoNodes(root.Left, root.Right)
    return root
}

func connectTwoNodes(node1, node2 *Node) {
    if node1 == nil || node2 == nil {
        return
    }
    node1.Next = node2
    connectTwoNodes(node1.Left, node1.Right)
    connectTwoNodes(node1.Right, node2.Left)
    connectTwoNodes(node1.Right, node2.Right)
}
```

**解析：** 使用递归方法，首先将当前层的两个节点连接起来，然后递归地对当前节点的左右子节点和下一个节点的左右子节点进行连接。

##### 1.15 设计一个合并区间算法

**题目描述：** 给定一个无重叠的区间列表 `intervals`，其中 `intervals[i] = [start` `i`, end` `i]` 表示第 `i` 个区间的起始和结束时间。请合并所有重叠的区间，并返回一个不重叠的区间列表。

**示例：**

```go
func merge(intervals [][]int) [][]int {
    // TODO
}
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var res [][]int
    res = append(res, intervals[0])
    for i := 1; i < len(intervals); i++ {
        last := res[len(res)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(intervals[i][1], last[1])
        } else {
            res = append(res, intervals[i])
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 首先将区间列表按起始时间排序，然后遍历区间列表，将当前区间与上一个区间合并，如果当前区间的起始时间小于或等于上一个区间的结束时间，则更新上一个区间的结束时间；否则，将当前区间添加到结果列表中。

##### 1.16 设计一个股票买卖算法

**题目描述：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果在一个明确 day `i` 购买股票并在后续的某一天 `j`（`j > i`）卖出股票，将获得 `prices[j] - prices[i]` 的利润。返回你可以从这些交易中获取的最大利润。这里不能同时参与多笔交易。

**示例：**

```go
func maxProfit(prices []int) int {
    // TODO
}
```

**答案：**

```go
func maxProfit(prices []int) int {
    maxProfit := 0
    for i := 1; i < len(prices); i++ {
        profit := prices[i] - prices[i-1]
        if profit > 0 {
            maxProfit += profit
        }
    }
    return maxProfit
}
```

**解析：** 遍历数组，对于每个连续的上升，累加利润。

##### 1.17 设计一个有效的日程表算法

**题目描述：** 实现 `MyScheduler` 类：

1. `MyScheduler()` 使用空构造函数初始化日程表对象。
2. `book(int start, int end)` 如果日程表可以安排这个活动，则添加到日程表中，否则返回 false。当两个活动之间存在时间冲突时（即，活动的开始时间相等，而结束时间不同），我们称它们为冲突的，返回 false。如果活动可以添加到日程表中，返回 true。

**示例：**

```go
var scheduler = Constructor();
scheduler.Book(10, 20); // 返回 true
scheduler.Book(50, 60); // 返回 true
scheduler.Book(10, 40); // 返回 true
scheduler.Book(5, 15);  // 返回 false，因为时间冲突
scheduler.Book(5, 10);  // 返回 true
```

**答案：**

```go
type Interval struct {
    Start int
    End   int
}

type MyScheduler struct {
    intervals []Interval
}

func Constructor() MyScheduler {
    return MyScheduler{}
}

func (this *MyScheduler) Book(start int, end int) bool {
    newInterval := Interval{Start: start, End: end}
    i := sort.Search(len(this.intervals), func(i int) bool {
        return this.intervals[i].End >= newInterval.Start
    })
    if i < len(this.intervals) && this.intervals[i].Start == newInterval.Start {
        return false
    }
    if i < len(this.intervals) && this.intervals[i].End >= newInterval.End {
        return false
    }
    this.intervals = append(this.intervals[:i], append([]Interval{newInterval}, this.intervals[i:]...)...)
    return true
}
```

**解析：** 使用二分查找找到新区间应插入的位置，检查是否有冲突，如果没有，将其插入到区间列表中。

##### 1.18 设计一个图像渲染算法

**题目描述：** 给你一个 m x n 的矩阵 image ，表示一幅图像。你收到一个由一些边界坐标组成的数组 rectangles ，其中 rectangles[i] = [x1, y1, x2, y2] 表示垂直或水平的一条线，该线面上的所有像素点都将进行颜色渲染。填充整个图像，并 返回最终的图像。

**示例：**

```go
func fill(image [][]int, sr int, sc int, newColor int) [][]int {
    // TODO
}
```

**答案：**

```go
func fill(image [][]int, sr int, sc int, newColor int) [][]int {
    rows, cols := len(image), len(image[0])
    visited := make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }
    dfs(image, sr, sc, newColor, &visited)
    return image
}

func dfs(image [][]int, i int, j int, newColor int, visited *[][]bool) {
    rows, cols := len(image), len(image[0])
    if i < 0 || i >= rows || j < 0 || j >= cols || visited[i][j] || image[i][j] == newColor {
        return
    }
    visited[i][j] = true
    image[i][j] = newColor
    dfs(image, i-1, j, newColor, visited) // 上
    dfs(image, i+1, j, newColor, visited) // 下
    dfs(image, i, j-1, newColor, visited) // 左
    dfs(image, i, j+1, newColor, visited) // 右
}
```

**解析：** 使用深度优先搜索（DFS）从起点开始填充颜色，对于每个相邻的节点，如果未访问且颜色不同，则继续搜索。

##### 1.19 设计一个递增子序列 II 算法

**题目描述：** 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵高度平衡二叉搜索树。

**示例：**

```go
func increasingBST(nums []int) *TreeNode {
    // TODO
}
```

**答案：**

```go
func increasingBST(nums []int) *TreeNode {
    if len(nums) == 0 {
        return nil
    }
    mid := len(nums) / 2
    root := &TreeNode{Val: nums[mid]}
    root.Left = increasingBST(nums[:mid])
    root.Right = increasingBST(nums[mid+1:])
    return root
}
```

**解析：** 找到中位数作为根节点，递归地对左右子数组进行相同的操作。

##### 1.20 设计一个有效的汉诺塔算法

**题目描述：** 你需要将一个长度为 n 的绳子剪成若干段最大长度为 k 的绳子，并且最大化绳子的总长度。请你设计一个函数，返回最大长度的绳子的总长度。

**示例：**

```go
func maxBrokenRopeLength(n int, k int) int {
    // TODO
}
```

**答案：**

```go
func maxBrokenRopeLength(n int, k int) int {
    if n < k {
        return n
    }
    mod := int64(1e9 + 7)
    dp := make([]int64, n+1)
    dp[0] = 0
    dp[1] = k
    for i := 2; i <= n; i++ {
        dp[i] = (dp[i-1] + int64(k) * dp[i-k]) % mod
    }
    return int(dp[n])
}
```

**解析：** 使用动态规划，`dp[i]` 表示剪成若干段最大长度为 k 的绳子的最大长度，状态转移方程为 `dp[i] = (dp[i-1] + k * dp[i-k]) % mod`。

##### 1.21 设计一个插入区间算法

**题目描述：** 给定一个无重叠的区间列表 `intervals`，其中 `intervals[i] = [start` `i`, end` `i]` 表示第 `i` 个区间的起始和结束时间。请你合并所有区间，以列表形式返回合并后的区间。

**示例：**

```go
func merge(intervals [][]int) [][]int {
    // TODO
}
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var res [][]int
    res = append(res, intervals[0])
    for i := 1; i < len(intervals); i++ {
        last := res[len(res)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(intervals[i][1], last[1])
        } else {
            res = append(res, intervals[i])
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 首先将区间列表按起始时间排序，然后遍历区间列表，将当前区间与上一个区间合并，如果当前区间的起始时间小于或等于上一个区间的结束时间，则更新上一个区间的结束时间；否则，将当前区间添加到结果列表中。

##### 1.22 设计一个数组的动态和算法

**题目描述：** 设计一个算法，计算出数组每个下标位置的动态和。

**示例：**

```go
func dynamicSum(nums []int) []int {
    // TODO
}
```

**答案：**

```go
func dynamicSum(nums []int) []int {
    n := len(nums)
    prefixSum := make([]int, n+1)
    for i := 1; i <= n; i++ {
        prefixSum[i] = prefixSum[i-1] + nums[i-1]
    }
    var res []int
    for i := 0; i < n; i++ {
        res = append(res, prefixSum[i+1])
    }
    return res
}
```

**解析：** 计算前缀和，然后遍历数组，对于每个元素，其动态和即为前缀和减去前一个元素的前缀和。

##### 1.23 设计一个最近请求时间的统计器

**题目描述：** 设计一个计数器，它可以计算一个数字在过去特定时间内的频率。例如，如果你设置时间窗口为 10 秒，那么在连续 10 秒内出现的数字会被记录下来，如果数字再次出现，计数器将忽略它。超过时间窗口后的数字将被计入新的计数周期。

**示例：**

```go
var Counter = NewCounter(10)
Counter.increment(1)  // 当前时间是 0
Counter.increment(2)  // 当前时间是 1
Counter.increment(2)  // 当前时间是 2
Counter.increment(3)  // 当前时间是 3
Counter.increment(2)  // 当前时间是 4
Counter.increment(1)  // 当前时间是 5
print(Counter.get())  // 输出应该为 [2, 2, 3, 2, 1]
```

**答案：**

```go
type Counter struct {
    intervals []Interval
    timeWindow int
}

func NewCounter(timeWindow int) *Counter {
    return &Counter{
        intervals:   []Interval{},
        timeWindow:  timeWindow,
    }
}

func (c *Counter) increment(num int) {
    for i := range c.intervals {
        if c.intervals[i].End+10 < time.Now().Unix() {
            c.intervals = append(c.intervals[:i], c.intervals[i+1:]...)
        }
    }
    i := sort.Search(len(c.intervals), func(i int) bool {
        return c.intervals[i].End+10 < time.Now().Unix()
    })
    c.intervals = append(c.intervals[:i], Interval{Start: time.Now().Unix(), End: time.Now().Unix(), Num: num})
}

func (c *Counter) get() []int {
    res := make([]int, 0, len(c.intervals))
    for _, interval := range c.intervals {
        res = append(res, interval.Num)
    }
    return res
}
```

**解析：** 使用区间列表存储每个数字的出现时间和频次，每当数字出现时，更新区间列表，并将过期的区间移除。最后，遍历区间列表，获取每个数字的频次。

##### 1.24 设计一个有变距限制的优先队列

**题目描述：** 设计一个有变距限制的优先队列，元素入队时，如果当前队列的元素数量超过限制，则移除队首元素。该优先队列应支持以下操作：

1. `add(num: int)`：向队列中添加一个元素。
2. `pop()`：从队列中移除并返回队首元素。
3. `peek()`：返回队首元素，但不移除它。

**示例：**

```go
pq = PriorityQueue(3)
pq.add(1)
pq.add(2)
pq.add(3)
pq.add(4)
print(pq.pop())  // 输出 1
print(pq.peek()) // 输出 2
```

**答案：**

```go
type PriorityQueue struct {
    queue []int
    limit int
}

func NewPriorityQueue(limit int) *PriorityQueue {
    return &PriorityQueue{
        queue: []int{},
        limit: limit,
    }
}

func (pq *PriorityQueue) add(num int) {
    pq.queue = append(pq.queue, num)
    if len(pq.queue) > pq.limit {
        pq.queue = pq.queue[1:]
    }
}

func (pq *PriorityQueue) pop() int {
    if len(pq.queue) == 0 {
        return -1
    }
    return pq.queue[0]
}

func (pq *PriorityQueue) peek() int {
    if len(pq.queue) == 0 {
        return -1
    }
    return pq.queue[0]
}
```

**解析：** 使用切片存储队列元素，如果队列长度超过限制，则移除队首元素。pop 和 peek 操作直接访问队首元素。

##### 1.25 设计一个按序打印字符的线程锁

**题目描述：** 有两个线程，一个线程打印字母 A，另一个线程打印字母 B，要求按照 "ABABAB" 的顺序交替打印。

**示例：**

```go
func printABSync() {
    // TODO
}
```

**答案：**

```go
var abMutex = &sync.Mutex{}
var abCond = sync.NewCond(abMutex)

func printA() {
    for {
        abMutex.Lock()
        if !first {
            abCond.Wait()
        }
        fmt.Println("A")
        first = !first
        abCond.Signal()
        abMutex.Unlock()
    }
}

var first = true

func printB() {
    for {
        abMutex.Lock()
        if first {
            abCond.Wait()
        }
        fmt.Println("B")
        first = !first
        abCond.Signal()
        abMutex.Unlock()
    }
}
```

**解析：** 使用互斥锁和条件变量实现线程同步。线程 A 和线程 B 分别持有互斥锁，并根据条件变量进行等待和通知。

##### 1.26 设计一个有序链表合并算法

**题目描述：** 给定两个有序链表 `list1` 和 `list2`，将它们合并成一个有序链表，并保持链表的排序。

**示例：**

```go
func mergeOrderedLists(list1, list2 *ListNode) *ListNode {
    // TODO
}
```

**答案：**

```go
func mergeOrderedLists(list1, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeOrderedLists(list1.Next, list2)
        return list1
    } else {
        list2.Next = mergeOrderedLists(list1, list2.Next)
        return list2
    }
}
```

**解析：** 使用递归方法，比较当前节点，将较小的节点连接到新的链表，并递归地对剩余部分进行合并。

##### 1.27 设计一个有序数组合并算法

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将它们合并成一个有序数组，并返回结果。

**示例：**

```go
func mergeSortedArrays(nums1 []int, nums2 []int) []int {
    // TODO
}
```

**答案：**

```go
func mergeSortedArrays(nums1 []int, nums2 []int) []int {
    n1, n2 := len(nums1), len(nums2)
    i, j := 0, 0
    var res []int
    for i < n1 && j < n2 {
        if nums1[i] < nums2[j] {
            res = append(res, nums1[i])
            i++
        } else {
            res = append(res, nums2[j])
            j++
        }
    }
    for i < n1 {
        res = append(res, nums1[i])
        i++
    }
    for j < n2 {
        res = append(res, nums2[j])
        j++
    }
    return res
}
```

**解析：** 使用两个指针遍历两个数组，将较小的元素添加到结果数组中。最后，将剩余的元素添加到结果数组中。

##### 1.28 设计一个有序链表合并算法

**题目描述：** 给定两个有序链表 `list1` 和 `list2`，将它们合并成一个有序链表，并保持链表的排序。

**示例：**

```go
func mergeOrderedLists(list1, list2 *ListNode) *ListNode {
    // TODO
}
```

**答案：**

```go
func mergeOrderedLists(list1, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeOrderedLists(list1.Next, list2)
        return list1
    } else {
        list2.Next = mergeOrderedLists(list1, list2.Next)
        return list2
    }
}
```

**解析：** 使用递归方法，比较当前节点，将较小的节点连接到新的链表，并递归地对剩余部分进行合并。

##### 1.29 设计一个排序链表算法

**题目描述：** 编写一个函数，对一个单链表进行排序。

**示例：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func sortList(head *ListNode) *ListNode {
    // TODO
}
```

**答案：**

```go
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    middle := middleNode(head)
    nextOfMiddle := middle.Next
    middle.Next = nil
    left := sortList(head)
    right := sortList(nextOfMiddle)
    return merge(left, right)
}

func merge(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = merge(l1.Next, l2)
        return l1
    } else {
        l2.Next = merge(l1, l2.Next)
        return l2
    }
}

func middleNode(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```

**解析：** 使用归并排序方法，首先找到链表的中点，将链表分成两部分，然后递归地对两部分进行排序，最后将排序后的两部分合并。

##### 1.30 设计一个排序矩阵中的元素算法

**题目描述：** 给定一个 `m x n` 的矩阵，其中每个元素都是唯一的，编写一个函数，将矩阵元素按照从最小的到最大的顺序排序。

**示例：**

```go
func sortMatrix(matrix [][]int) [][]int {
    // TODO
}
```

**答案：**

```go
func sortMatrix(matrix [][]int) [][]int {
    flat := make([]int, 0, len(matrix)*len(matrix[0]))
    for i := range matrix {
        for j := range matrix[i] {
            flat = append(flat, matrix[i][j])
        }
    }
    sort.Ints(flat)
    for i := range matrix {
        for j := range matrix[i] {
            matrix[i][j] = flat[i*len(matrix[0])+j]
        }
    }
    return matrix
}
```

**解析：** 将矩阵元素展开为一个一维数组，对其进行排序，然后重新填充到二维数组中。

