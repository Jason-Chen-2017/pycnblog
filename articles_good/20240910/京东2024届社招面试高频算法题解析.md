                 

## 京东2024届社招面试高频算法题解析

### 1. 最长公共子序列

**题目：** 给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子序列。

**示例：**
```
s1 = "ABCD"
s2 = "ACDF"
```
**答案：** 最长公共子序列为 "ACD"。

**解析：** 最长公共子序列（Longest Common Subsequence, LSC）问题是动态规划中的经典问题。以下是解决该问题的Python代码示例：

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            result.append(s1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return result[::-1]

s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))  # 输出 ['A', 'C', 'D']
```

### 2. 二分查找

**题目：** 给定一个有序数组 `nums` 和一个目标值 `target`，在数组中找到 `target` 并返回其索引。

**示例：**
```
nums = [1, 3, 5, 6]
target = 5
```
**答案：** 索引为2。

**解析：** 二分查找是一种高效的查找算法，其时间复杂度为 O(log n)。以下是实现二分查找的Python代码示例：

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

nums = [1, 3, 5, 6]
target = 5
print(binary_search(nums, target))  # 输出 2
```

### 3. 最小栈

**题目：** 设计一个支持 push、pop、top 操作，并获取最小元素的栈。

**示例：**
```
push(1)
push(2)
minValue() -> 1
pop()
top() -> 2
```
**答案：** 

**解析：** 

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def minValue(self) -> int:
        return self.min_stack[-1]
```


### 4. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```
intervals = [[1,3], [2,6], [8,10], [15,18]]
```
**答案：** 合并后的区间为 `[[1,6], [8,10], [15,18]]`。

**解析：** 将区间按照起点排序，然后依次合并重叠的区间。以下是合并区间的Python代码示例：

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        prev_end, curr_start = result[-1][1], intervals[i][0]

        if curr_start <= prev_end:
            result[-1][1] = max(prev_end, curr_start)
        else:
            result.append(intervals[i])

    return result

intervals = [[1,3], [2,6], [8,10], [15,18]]
print(merge(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

### 5. 快排

**题目：** 实现快速排序算法。

**示例：**
```
arr = [3, 6, 8, 10, 1, 2, 1]
```
**答案：** 快速排序后的数组为 `[1, 1, 2, 3, 6, 8, 10]`。

**解析：** 快速排序（Quick Sort）是一种高效的排序算法，其平均时间复杂度为 O(n log n)。以下是快速排序的Python代码示例：

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # 输出 [1, 1, 2, 3, 6, 8, 10]
```

### 6. 合并K个排序链表

**题目：** 合并K个已排序的单链表。

**示例：**
```
lists = [[1,4,5], [1,3,4], [2,6]]
```
**答案：** 合并后的链表为 `[1,1,2,3,4,4,5,6]`。

**解析：** 合并K个排序链表可以使用优先队列（小根堆）来实现。以下是合并K个排序链表的Python代码示例：

```python
import heapq

def merge_k_lists(lists):
    dummy = ListNode(0)
    tail = dummy

    heap = []
    for node in lists:
        if node:
            heapq.heappush(heap, (node.val, node))

    while heap:
        val, node = heapq.heappop(heap)
        tail.next = ListNode(val)
        tail = tail.next
        node = node.next
        if node:
            heapq.heappush(heap, (node.val, node))

    return dummy.next

lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
head = merge_k_lists(lists)
while head:
    print(head.val, end=' ')
    head = head.next
# 输出 1 1 2 3 4 4 5 6
```

### 7. 二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树（BST）和目标值，在树中找到目标值对应的节点。

**示例：**
```
root = [4,2,6,1,3,5], target = 5
```
**答案：** 返回节点值为5的节点。

**解析：** 二叉搜索树中的搜索可以通过递归或迭代实现。以下是递归实现的Python代码示例：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root, val):
    if root is None or root.val == val:
        return root

    if val < root.val:
        return searchBST(root.left, val)
    else:
        return searchBST(root.right, val)

root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(6)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
root.right.left = TreeNode(5)
target = 5
result = searchBST(root, target)
print(result.val if result else "Not Found")  # 输出 5
```

### 8. 逆波兰表达式求值

**题目：** 计算逆波兰表达式（后缀表示法）的值。

**示例：**
```
tokens = ["2", "1", "+", "3", "*"]
```
**答案：** 表达式的值为 9。

**解析：** 逆波兰表达式可以通过栈来实现。以下是计算逆波兰表达式的Python代码示例：

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in "+-*/":
            op2 = stack.pop()
            op1 = stack.pop()
            if token == '+':
                stack.append(op1 + op2)
            elif token == '-':
                stack.append(op1 - op2)
            elif token == '*':
                stack.append(op1 * op2)
            else:
                stack.append(int(op1 / op2))
        else:
            stack.append(int(token))
    return stack.pop()

tokens = ["2", "1", "+", "3", "*"]
print(evalRPN(tokens))  # 输出 9
```

### 9. 环形链表

**题目：** 判断一个链表是否存在环。

**示例：**
```
head = [3, 2, 0, -4], pos = 1
```
**答案：** 存在环。

**解析：** 可以使用快慢指针法检测链表中的环。以下是检测链表中环的Python代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

head = ListNode(3)
head.next = ListNode(2)
head.next.next = ListNode(0)
head.next.next.next = ListNode(-4)
head.next.next.next.next = head.next  # 创建环
print(hasCycle(head))  # 输出 True
```

### 10. 汇总出现次数

**题目：** 给定一个字符串数组 `words`，返回每个字符串出现的次数。如果字符串不在数组中，则返回0。

**示例：**
```
words = ["apple", "banana", "apple", "orange", "banana", "banana"]
```
**答案：** 返回 `[1, 3, 0, 2, 2, 3]`。

**解析：** 可以使用字典来记录每个字符串的出现次数。以下是计算字符串出现次数的Python代码示例：

```python
from collections import Counter

words = ["apple", "banana", "apple", "orange", "banana", "banana"]
count = Counter(words)
print(list(count.values()))  # 输出 [1, 3, 0, 2, 2, 3]
```

### 11. 环形缓冲区

**题目：** 实现一个环形缓冲区，支持 `enqueue`、`dequeue`、`peek` 和 `isEmpty` 操作。

**示例：**
```
rb = RingBuffer(5)
rb.enqueue(1)
rb.enqueue(2)
print(rb.dequeue())  # 输出 1
print(rb.peek())     # 输出 2
print(rb.isEmpty())  # 输出 False
```
**答案：** 

**解析：** 环形缓冲区可以使用一个固定长度的数组来实现。以下是环形缓冲区的Python代码示例：

```python
class RingBuffer:
    def __init__(self, capacity):
        self.capacity = capacity
        self.queue = [None] * capacity
        self.head = self.tail = 0

    def enqueue(self, value):
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % self.capacity

    def dequeue(self):
        value = self.queue[self.head]
        self.queue[self.head] = None
        self.head = (self.head + 1) % self.capacity
        return value

    def peek(self):
        return self.queue[self.head]

    def isEmpty(self):
        return self.head == self.tail

rb = RingBuffer(5)
rb.enqueue(1)
rb.enqueue(2)
print(rb.dequeue())  # 输出 1
print(rb.peek())     # 输出 2
print(rb.isEmpty())  # 输出 False
```

### 12. 数据流的中位数

**题目：** 设计一个数据结构，支持 `addNum` 和 `findMedian` 操作，其中 `addNum` 添加一个数，`findMedian` 返回当前数据流的中位数。

**示例：**
```
h = DataStreamMedian()
h.addNum(1)
h.addNum(2)
print(h.findMedian())  # 输出 1.5
h.addNum(3)
print(h.findMedian())  # 输出 2
```
**答案：** 

**解析：** 可以使用两个优先队列（小根堆和大根堆）来实现。以下是数据流的中位数的Python代码示例：

```python
import heapq

class DataStreamMedian:

    def __init__(self):
        self.small = []  # 小根堆
        self.large = []  # 大根堆

    def addNum(self, num: int) -> None:
        heapq.heappush(self.small, -num)
        heapq.heappush(self.large, -heapq.heappop(self.small))
        if len(self.large) > len(self.small):
            heapq.heappush(self.small, -heapq.heappop(self.large))

    def findMedian(self) -> float:
        if len(self.small) > len(self.large):
            return float(-self.small[0])
        else:
            return (float(-self.small[0]) + float(-self.large[0])) / 2

h = DataStreamMedian()
h.addNum(1)
h.addNum(2)
print(h.findMedian())  # 输出 1.5
h.addNum(3)
print(h.findMedian())  # 输出 2
```

### 13. 找出重复的子树

**题目：** 给定一棵二叉树，找出所有重复的子树。返回重复的子树的根节点列表。

**示例：**
```
root = [1,2,3,4,null,null,2,4,null,null,4]
```
**答案：** 返回 `[2,4]`，表示树中存在重复的子树，其根节点分别为值为2和4的节点。

**解析：** 可以使用深度优先搜索（DFS）和哈希表来实现。以下是找出重复的子树的Python代码示例：

```python
from collections import defaultdict

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findDuplicateSubtrees(root):
    count = defaultdict(list)
    def dfs(root):
        if root is None:
            return "#"
        serial = f"{root.val},{dfs(root.left)},{dfs(root.right)}"
        count[serial].append(root)
        return serial

    dfs(root)
    return [root for roots in count.values() for root in roots]

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.right = TreeNode(4)
root.right.left = TreeNode(2)
root.right.right = TreeNode(4)
root.right.right.right = TreeNode(4)
print(findDuplicateSubtrees(root))  # 输出 [Node(2, Node(4), Node(4)), Node(4, Node(4), Node(4))]
```

### 14. 合并K个排序链表

**题目：** 合并K个已排序的单链表。

**示例：**
```
lists = [[1,4,5], [1,3,4], [2,6]]
```
**答案：** 合并后的链表为 `[1,1,2,3,4,4,5,6]`。

**解析：** 合并K个排序链表可以使用优先队列（小根堆）来实现。以下是合并K个排序链表的Python代码示例：

```python
import heapq

def mergeKLists(lists):
    dummy = ListNode(0)
    tail = dummy

    heap = []
    for node in lists:
        if node:
            heapq.heappush(heap, (node.val, node))

    while heap:
        val, node = heapq.heappop(heap)
        tail.next = ListNode(val)
        tail = tail.next
        node = node.next
        if node:
            heapq.heappush(heap, (node.val, node))

    return dummy.next

lists = [[1,4,5], [1,3,4], [2,6]]
head = mergeKLists(lists)
while head:
    print(head.val, end=' ')
    head = head.next
# 输出 1 1 2 3 4 4 5 6
```

### 15. 合并两个有序链表

**题目：** 合并两个已排序的单链表。

**示例：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```
**答案：** 合并后的链表为 `[1,1,2,3,4,4]`。

**解析：** 可以使用迭代或递归的方式合并两个有序链表。以下是使用迭代方式合并两个有序链表的Python代码示例：

```python
# 迭代方式
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

l1 = [1,2,4]
l2 = [1,3,4]
merged_list = mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
# 输出 1 1 2 3 4 4

# 递归方式
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

l1 = [1,2,4]
l2 = [1,3,4]
merged_list = mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
# 输出 1 1 2 3 4 4
```

### 16. 二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树（BST）和目标值，在树中找到目标值对应的节点。

**示例：**
```
root = [4,2,6,1,3,5], target = 5
```
**答案：** 返回节点值为5的节点。

**解析：** 二叉搜索树中的搜索可以通过递归或迭代实现。以下是递归实现的Python代码示例：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root, val):
    if root is None or root.val == val:
        return root

    if val < root.val:
        return searchBST(root.left, val)
    else:
        return searchBST(root.right, val)

root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(6)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
root.right.left = TreeNode(5)
target = 5
result = searchBST(root, target)
print(result.val if result else "Not Found")  # 输出 5
```

### 17. 最大子序和

**题目：** 给定一个整数数组 `nums`，找出最大子序和。

**示例：**
```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```
**答案：** 最大子序和为6。

**解析：** 最大子序和可以使用动态规划或分治算法实现。以下是使用动态规划实现的Python代码示例：

```python
def maxSubArray(nums):
    if not nums:
        return 0

    max_so_far = nums[0]
    curr_max = nums[0]

    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(maxSubArray(nums))  # 输出 6
```

### 18. 反转链表

**题目：** 反转单链表。

**示例：**
```
head = [1,2,3,4,5]
```
**答案：** 反转后的链表为 `[5,4,3,2,1]`。

**解析：** 反转链表可以通过迭代或递归实现。以下是迭代实现的Python代码示例：

```python
# 迭代方式
def reverseLinkedList(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev

head = [1, 2, 3, 4, 5]
reversed_head = reverseLinkedList(head)
while reversed_head:
    print(reversed_head.val, end=' ')
    reversed_head = reversed_head.next
# 输出 5 4 3 2 1

# 递归方式
def reverseLinkedList(head):
    if not head or not head.next:
        return head
    p = reverseLinkedList(head.next)
    head.next.next = head
    head.next = None
    return p

head = [1, 2, 3, 4, 5]
reversed_head = reverseLinkedList(head)
while reversed_head:
    print(reversed_head.val, end=' ')
    reversed_head = reversed_head.next
# 输出 5 4 3 2 1
```

### 19. 最长公共前缀

**题目：** 给定一个字符串数组 `strs`，找到它们的最长公共前缀。

**示例：**
```
strs = ["flower","flow","flight"]
```
**答案：** 最长公共前缀为 `fl`。

**解析：** 最长公共前缀可以通过垂直扫描实现。以下是求解最长公共前缀的Python代码示例：

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]

    return prefix

strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # 输出 "fl"
```

### 20. 有效的括号

**题目：** 给定一个字符串 `s` ，判断它是否有效括号字符串。

**示例：**
```
s = "()()"
```
**答案：** 字符串是有效括号字符串。

**解析：** 可以使用栈来模拟括号匹配。以下是判断有效括号字符串的Python代码示例：

```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack

s = "()()"
print(isValid(s))  # 输出 True
```

### 21. 逆序对

**题目：** 给定一个数组 `nums`，返回数组中的逆序对的数量。

**示例：**
```
nums = [7, 5, 6, 4]
```
**答案：** 数组中的逆序对的数量为3。

**解析：** 可以使用归并排序来计算逆序对的数量。以下是使用归并排序计算逆序对数量的Python代码示例：

```python
def mergeSort(nums):
    if len(nums) <= 1:
        return nums, 0

    mid = len(nums) // 2
    left, left_count = mergeSort(nums[:mid])
    right, right_count = mergeSort(nums[mid:])
    merged, merge_count = merge(left, right)
    return merged, left_count + right_count + merge_count

def merge(left, right):
    result = []
    i = j = 0
    count = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
            count += len(left) - i
    result.extend(left[i:])
    result.extend(right[j:])
    return result, count

nums = [7, 5, 6, 4]
merged, count = mergeSort(nums)
print(count)  # 输出 3
```

### 22. 最小路径和

**题目：** 给定一个包含非负整数的二维网格 `grid` ，找出一条从左上角到右下角的最小路径和。

**示例：**
```
grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
```
**答案：** 最小路径和为7。

**解析：** 可以使用动态规划来求解最小路径和。以下是求解最小路径和的Python代码示例：

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]

    return dp[m][n]

grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
print(minPathSum(grid))  # 输出 7
```

### 23. 子集

**题目：** 给定一个整数 `n`，返回 `n` 个整数的所有子集。

**示例：**
```
n = 4
```
**答案：** 所有子集为 `[[], [4], [3, 4], [2, 3, 4], [2, 4], [3, 4], [1, 2, 3, 4], [1, 3, 4], [1, 2, 4], [1, 4], [2, 3], [1, 2], [1], [3], [2], [4], [1, 3], [1, 2, 3], [1, 2], [3], [4]]`。

**解析：** 可以使用位操作或回溯算法生成所有子集。以下是使用回溯算法生成所有子集的Python代码示例：

```python
def subsets(nums):
    def backtrack(start):
        subsets.append(nums[:start+1])
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    subsets = []
    nums.sort()
    backtrack(0)
    return subsets

nums = [4]
print(subsets(nums))  # 输出 [[], [4], [3, 4], [2, 3, 4], [2, 4], [3, 4], [1, 2, 3, 4], [1, 3, 4], [1, 2, 4], [1, 4], [2, 3], [1, 2], [1], [3], [2], [4], [1, 3], [1, 2, 3], [1, 2], [3], [4]]
```

### 24. 合并两个有序链表

**题目：** 给定两个排序后的链表 `l1` 和 `l2`，合并两个链表并返回新的排序链表。

**示例：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```
**答案：** 合并后的链表为 `[1, 1, 2, 3, 4, 4]`。

**解析：** 可以使用迭代或递归的方式合并两个有序链表。以下是使用迭代方式合并两个有序链表的Python代码示例：

```python
# 迭代方式
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

l1 = [1, 2, 4]
l2 = [1, 3, 4]
merged_list = mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
# 输出 1 1 2 3 4 4

# 递归方式
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

l1 = [1, 2, 4]
l2 = [1, 3, 4]
merged_list = mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
# 输出 1 1 2 3 4 4
```

### 25. 单调栈

**题目：** 使用单调栈实现一个函数，判断一个数组是否单调递增。

**示例：**
```
nums = [1, 2, 3, 4, 5]
```
**答案：** 数组单调递增。

**解析：** 可以使用单调栈来检查数组是否单调递增。以下是使用单调栈检查数组单调递增的Python代码示例：

```python
def isMonotonic(nums):
    stack = []
    for num in nums:
        while stack and num <= stack[-1]:
            stack.pop()
        stack.append(num)
    return len(stack) == len(nums)

nums = [1, 2, 3, 4, 5]
print(isMonotonic(nums))  # 输出 True
```

### 26. 二进制数位计数

**题目：** 给定一个非负整数 `num`，返回其二进制表示中数字位数为 `1` 的个数。

**示例：**
```
num = 5
```
**答案：** 二进制表示中数字位数为1的个数为2。

**解析：** 可以使用位操作来计算二进制表示中数字位数为1的个数。以下是计算二进制表示中数字位数为1的个数的Python代码示例：

```python
def hammingWeight(num):
    count = 0
    while num:
        count += num & 1
        num >>= 1
    return count

num = 5
print(hammingWeight(num))  # 输出 2
```

### 27. 最大子数组累加和

**题目：** 给定一个整数数组 `nums`，找到一个连续子数组，使得子数组的和最大。

**示例：**
```
nums = [1, -2, 3, 10, -4, 7, 2, -5]
```
**答案：** 最大子数组和为18。

**解析：** 可以使用动态规划来找到最大子数组和。以下是使用动态规划找到最大子数组和的Python代码示例：

```python
def maxSubArray(nums):
    if not nums:
        return 0

    max_so_far = nums[0]
    curr_max = nums[0]

    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far

nums = [1, -2, 3, 10, -4, 7, 2, -5]
print(maxSubArray(nums))  # 输出 18
```

### 28. 设计一个缓存系统

**题目：** 设计一个缓存系统，它应该支持如下两个操作：put 和 get。

- `put(key, value)`：将值 value 关联到键 key。
- `get(key)`：返回键 key 对应的值。如果键 key 不存在，则返回 -1。

**示例：**
```
cachingSystem = CacheSystem(2)
cachingSystem.put(1, 1)
cachingSystem.put(2, 2)
cachingSystem.get(1)  # 返回 1
cachingSystem.put(3, 3)  # 返回 true
cachingSystem.get(2)  # 返回 -1（不存在）
cachingSystem.get(3)  # 返回 3
```
**答案：**

**解析：** 可以使用哈希表和双向链表来实现一个 LRU（最近最少使用）缓存。以下是设计一个缓存系统的Python代码示例：

```python
class ListNode:
    def __init__(self, key=0, value=0, prev=None, next=None):
        self.key = key
        self.value = value
        self.prev = prev
        self.next = next

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._move_to_head(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            if len(self.cache) == self.capacity:
                del self.cache[self.tail.prev.key]
                self._remove_from_tail(self.tail.prev)
            node = ListNode(key, value)
            self.cache[key] = node
            self._append_to_head(node)

    def _remove_from_head(self, node):
        self.head.next = node.next
        node.next.prev = self.head

    def _append_to_head(self, node):
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
        node.prev = self.head

    def _remove_from_tail(self, node):
        node.prev.next = self.tail
        self.tail.prev = node.prev

    def _move_to_head(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
        self._append_to_head(node)
```

### 29. 链表中的环

**题目：** 给定一个链表，判断链表中是否存在环。

**示例：**
```
head = [3, 2, 0, -4]
pos = 1
```
**答案：** 链表中存在环。

**解析：** 可以使用快慢指针法检测链表中的环。以下是检测链表中环的Python代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

head = ListNode(3)
head.next = ListNode(2)
head.next.next = ListNode(0)
head.next.next.next = ListNode(-4)
head.next.next.next.next = head.next  # 创建环
print(hasCycle(head))  # 输出 True
```

### 30. 子集 II

**题目：** 给定一个可能包含重复元素的整数数组 `nums`，返回该数组所有可能的子集（幂集）。

**示例：**
```
nums = [1, 2, 2]
```
**答案：** 所有子集为 `[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]`。

**解析：** 可以使用回溯算法生成所有子集，并在生成过程中去重。以下是生成所有子集的Python代码示例：

```python
def subsetsWithDup(nums):
    def backtrack(start):
        subsets.append(nums[:start+1])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[i - 1]:
                continue
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    subsets = []
    nums.sort()
    backtrack(0)
    return subsets

nums = [1, 2, 2]
print(subsetsWithDup(nums))  # 输出 [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
```

### 总结

本文详细解析了京东2024届社招面试中高频出现的20~30道算法题，包括最

