                 

### 百度2025社招面试真题与算法题解：典型问题解析

#### 1. 链表反转问题

**题目：** 实现一个函数，反转单链表。

**答案：** 可以使用递归或迭代的方法来反转单链表。

**递归实现：**

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

**迭代实现：**

```go
func reverseList(head *ListNode) *ListNode {
    prev := nil
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**解析：** 以上两种方法都可以实现链表反转。递归方法简单直观，但可能存在栈溢出的问题；迭代方法更适用于复杂度较高的场景。

#### 2. 快排算法

**题目：** 实现快速排序算法。

**答案：** 快速排序是一种基于分治思想的排序算法。

```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)
    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }
    return append(quickSort(left), append(middle, quickSort(right)...)...)
}
```

**解析：** 快排的核心是选取一个基准元素，将数组分为三个部分：小于基准元素的左子数组、等于基准元素的中子数组、大于基准元素的右子数组。然后对左右子数组递归地进行快排。

#### 3. 二分查找

**题目：** 实现二分查找算法，查找一个有序数组中的目标元素。

**答案：**

```go
func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := low + (high-low)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}
```

**解析：** 二分查找算法的基本思想是逐步缩小查找范围，每次将中间元素与目标元素比较，根据比较结果将查找范围缩小一半。时间复杂度为 O(log n)。

#### 4. 双指针算法

**题目：** 给定一个链表，实现一个函数，找到链表中的第一个重复节点。

**答案：**

```go
func findFirstDuplicateNode(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            slow = head
            for slow != fast {
                slow = slow.Next
                fast = fast.Next
            }
            return slow
        }
    }
    return nil
}
```

**解析：** 双指针算法的核心思想是使用快慢指针，快指针每次走两步，慢指针每次走一步。如果链表中存在重复节点，快指针一定会追上慢指针。找到重复节点后，再从链表头开始使用两个指针一起遍历，找到第一个重复节点。

#### 5. 字符串匹配算法

**题目：** 实现字符串匹配算法，给定一个主串和一个模式串，找出主串中模式串的所有出现位置。

**答案：**

```go
func findSubstring(s string, p string) []int {
    n, m := len(s), len(p)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    for i := 0; i <= n; i++ {
        for j := 0; j <= m; j++ {
            if i == 0 || j == 0 {
                dp[i][j] = 0
            } else if s[i-1] == p[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = 0
            }
        }
    }
    ans := []int{}
    for i := 0; i <= n-m; i++ {
        if dp[n][m] > 0 {
            ans = append(ans, i)
        }
    }
    return ans
}
```

**解析：** 动态规划算法，使用二维数组 `dp` 记录子串的匹配情况。状态转移方程为：`dp[i][j] = dp[i-1][j-1] + 1`（当字符匹配时），否则为0。最后根据 `dp[n][m]` 的值判断是否存在匹配。

#### 6. 红黑树实现

**题目：** 实现红黑树，支持插入、删除、查找等操作。

**答案：** 红黑树是一种自平衡的二叉搜索树，每个节点包含一个颜色属性，可以是红色或黑色。

```go
type Node struct {
    Val   int
    Color string
    Left  *Node
    Right *Node
    Parent *Node
}

type RBTree struct {
    Root *Node
}

func (t *RBTree) Insert(val int) {
    // 插入操作
    // ...
    // 调整红黑树
    // ...
}

func (t *RBTree) Delete(val int) {
    // 删除操作
    // ...
    // 调整红黑树
    // ...
}

func (t *RBTree) Find(val int) *Node {
    // 查找操作
    // ...
}
```

**解析：** 红黑树的实现需要处理插入、删除操作后的颜色调整，确保树的平衡性。红黑树的基本性质包括：每个节点要么是红色，要么是黑色；根节点是黑色；每个叶节点（NIL节点，叶子节点的子节点）都是黑色；如果一个节点是红色，则其子节点都是黑色；从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。

#### 7. 贪心算法

**题目：** 给定一个数组，实现一个函数，找出数组中的最大子序列和，该子序列中相邻元素不能重复。

**答案：**

```go
func maxSubArraySum(nums []int) int {
    prev := 0
    curr := 0
    for _, num := range nums {
        curr = max(prev+num, num)
        prev = curr
    }
    return curr
}
```

**解析：** 贪心算法的基本思想是每一步选择最优解，从而得到整体最优解。在这个问题中，每次选择当前元素或者当前元素加上前一个元素的最大值。

#### 8. 并发编程

**题目：** 使用协程和通道实现一个生产者消费者模型。

**答案：**

```go
func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}

func consumer(ch <-chan int) {
    for v := range ch {
        fmt.Println(v)
    }
}

func main() {
    ch := make(chan int, 5)
    go producer(ch)
    consumer(ch)
}
```

**解析：** 生产者消费者模型是并发编程中常见的场景，生产者负责生成数据，消费者负责消费数据。使用协程和通道可以实现异步的生产者和消费者。

#### 9. 缓存算法

**题目：** 实现一个LRU（最近最少使用）缓存算法。

**答案：**

```go
type LRUCache struct {
    m     map[int]*list.Element
    c     *list.List
    cap   int
}

func NewLRUCache(cap int) *LRUCache {
    return &LRUCache{
        m:     make(map[int]*list.Element),
        c:     list.New(),
        cap:   cap,
    }
}

func (c *LRUCache) Get(key int) int {
    if v, ok := c.m[key]; ok {
        c.c.MoveToFront(v)
        return v.Value.(int)
    }
    return -1
}

func (c *LRUCache) Put(key int, value int) {
    if _, ok := c.m[key]; ok {
        c.c.Remove(c.m[key])
    } else if c.Len() >= c.cap {
        t := c.c.Back()
        c.c.Remove(t)
        delete(c.m, t.Value.(int))
    }
    e := c.c.PushFront(value)
    c.m[key] = e
}
```

**解析：** LRU缓存算法是一种基于最近最少使用原则的缓存算法。使用一个哈希表和一个双向链表来实现，哈希表用于快速查找节点，双向链表用于维护节点的顺序。

#### 10. 回溯算法

**题目：** 实现一个函数，找出所有可能的子集。

**答案：**

```go
func subsets(nums []int) [][]int {
    res := [][]int{}
    subset := []int{}
    dfs(nums, &res, &subset, 0)
    return res
}

func dfs(nums []int, res *[][]int, subset *[]int, idx int) {
    if idx == len(nums) {
        t := make([]int, len(*subset))
        copy(t, *subset)
        *res = append(*res, t)
        return
    }
    dfs(nums, res, subset, idx+1)
    *subset = append(*subset, nums[idx])
    dfs(nums, res, subset, idx+1)
    *subset = (*subset)[:len(*subset)-1]
}
```

**解析：** 回溯算法是一种用于解决组合问题的算法。通过递归地尝试所有可能的组合，然后回溯到上一个步骤，继续尝试其他组合。这里使用一个切片 `subset` 来存储当前组合，每次递归调用时，将当前元素添加到 `subset` 中，然后继续递归。最后，将 `subset` 添加到结果列表 `res` 中。

#### 11. 设计模式

**题目：** 实现一个单例模式。

**答案：**

```go
type Singleton struct {
    // ...
}

var instance *Singleton

func GetInstance() *Singleton {
    if instance == nil {
        instance = &Singleton{}
    }
    return instance
}
```

**解析：** 单例模式是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。在这里，使用一个全局变量 `instance` 来存储单例对象，通过 `GetInstance` 方法提供访问。

#### 12. 二进制搜索树

**题目：** 实现一个二进制搜索树，支持插入、删除、查找等操作。

**答案：**

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func (t *TreeNode) Insert(val int) {
    if val < t.Val {
        if t.Left == nil {
            t.Left = &TreeNode{Val: val}
        } else {
            t.Left.Insert(val)
        }
    } else {
        if t.Right == nil {
            t.Right = &TreeNode{Val: val}
        } else {
            t.Right.Insert(val)
        }
    }
}

func (t *TreeNode) Delete(val int) {
    // 删除操作
    // ...
}

func (t *TreeNode) Find(val int) *TreeNode {
    if t == nil {
        return nil
    }
    if val < t.Val {
        return t.Left.Find(val)
    } else if val > t.Val {
        return t.Right.Find(val)
    } else {
        return t
    }
}
```

**解析：** 二进制搜索树（BST）是一种特殊的树，对于任意节点，其左子树中的所有节点的值都小于该节点的值，其右子树中的所有节点的值都大于该节点的值。在这里，实现了插入、删除和查找操作。

#### 13. 快排算法

**题目：** 实现快速排序算法。

**答案：**

```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)
    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }
    return append(quickSort(left), append(middle, quickSort(right)...)...)
}
```

**解析：** 快速排序是一种基于分治思想的排序算法，选取一个基准元素，将数组分为三个部分：小于基准元素的左子数组、等于基准元素的中子数组、大于基准元素的右子数组。然后对左右子数组递归地进行快排。

#### 14. 滑动窗口算法

**题目：** 给定一个数组和一个滑动窗口的大小，实现一个函数，找出所有滑动窗口中的最大值。

**答案：**

```go
func maxSlidingWindow(nums []int, k int) []int {
    deque := []int{}
    ans := []int{}
    for i, v := range nums {
        for len(deque) > 0 && nums[deque[len(deque)-1]] <= v {
            deque = deque[:len(deque)-1]
        }
        deque = append(deque, i)
        if i >= k-1 {
            ans = append(ans, nums[deque[0]])
            if deque[0] == i-k+1 {
                deque = deque[1:]
            }
        }
    }
    return ans
}
```

**解析：** 滑动窗口算法是一种通过维护一个窗口来处理连续数据的方法。在这个问题中，使用一个双端队列（deque）来维护当前窗口中的最大值。每次遍历数组时，将当前元素与 deque 中的元素进行比较，更新 deque。然后，将 deque 的头部元素（当前窗口的最大值）添加到结果数组中。

#### 15. 栈和队列

**题目：** 使用栈和队列实现一个函数，计算字符串中的括号匹配情况。

**答案：**

```go
func isValid(s string) bool {
    stk := []rune{}
    for _, v := range s {
        if v == '(' || v == '[' || v == '{' {
            stk = append(stk, v)
        } else if len(stk) == 0 || (v == ')' && stk[len(stk)-1] != '(') || (v == ']' && stk[len(stk)-1] != '[') || (v == '}' && stk[len(stk)-1] != '{') {
            return false
        }
        stk = stk[:len(stk)-1]
    }
    return len(stk) == 0
}
```

**解析：** 使用栈来存储当前未匹配的括号。遍历字符串时，遇到左括号将其入栈，遇到右括号时，检查栈顶元素是否匹配，若匹配则出栈，否则返回 false。最后，如果栈为空，说明所有括号均已匹配。

#### 16. 贪心算法

**题目：** 给定一个数组，实现一个函数，找出数组中的最大子序列和，该子序列中相邻元素不能重复。

**答案：**

```go
func maxSubArraySum(nums []int) int {
    prev := 0
    curr := 0
    for _, num := range nums {
        curr = max(prev+num, num)
        prev = curr
    }
    return curr
}
```

**解析：** 贪心算法的基本思想是每一步选择最优解，从而得到整体最优解。在这个问题中，每次选择当前元素或者当前元素加上前一个元素的最大值。

#### 17. 链表

**题目：** 实现一个链表，支持插入、删除、查找等操作。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func (l *ListNode) Insert(val int) {
    newNode := &ListNode{Val: val}
    if l == nil {
        l = newNode
    } else {
        curr := l
        for curr.Next != nil {
            curr = curr.Next
        }
        curr.Next = newNode
    }
}

func (l *ListNode) Delete(val int) {
    if l == nil {
        return
    }
    if l.Val == val {
        l = l.Next
        return
    }
    curr := l
    for curr.Next != nil && curr.Next.Val != val {
        curr = curr.Next
    }
    if curr.Next != nil {
        curr.Next = curr.Next.Next
    }
}

func (l *ListNode) Find(val int) *ListNode {
    curr := l
    for curr != nil && curr.Val != val {
        curr = curr.Next
    }
    return curr
}
```

**解析：** 链表是一种常见的数据结构，由一系列节点组成，每个节点包含一个值和一个指向下一个节点的指针。这里实现了插入、删除和查找操作。

#### 18. 双指针算法

**题目：** 给定一个链表，实现一个函数，找到链表中的第一个重复节点。

**答案：**

```go
func findFirstDuplicateNode(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            slow = head
            for slow != fast {
                slow = slow.Next
                fast = fast.Next
            }
            return slow
        }
    }
    return nil
}
```

**解析：** 双指针算法的核心思想是使用快慢指针，快指针每次走两步，慢指针每次走一步。如果链表中存在重复节点，快指针一定会追上慢指针。找到重复节点后，再从链表头开始使用两个指针一起遍历，找到第一个重复节点。

#### 19. 位运算

**题目：** 给定一个整数，实现一个函数，将其二进制表示中的第 i 位设置为 1。

**答案：**

```go
func setBit(num int, i int) int {
    mask := 1 << i
    return num | mask
}
```

**解析：** 使用位运算中的左移操作将 1 移到第 i 位，然后使用按位或操作将这个值与原数进行运算，即可将第 i 位设置为 1。

#### 20. 深度优先搜索

**题目：** 实现一个函数，找出二叉树的所有路径。

**答案：**

```go
func paths(root *TreeNode) [][]int {
    res := [][]int{}
    dfs(root, []int{}, &res)
    return res
}

func dfs(node *TreeNode, path []int, res *[][]int) {
    if node == nil {
        return
    }
    path = append(path, node.Val)
    if node.Left == nil && node.Right == nil {
        t := make([]int, len(path))
        copy(t, path)
        *res = append(*res, t)
    } else {
        dfs(node.Left, path, res)
        dfs(node.Right, path, res)
    }
    path = path[:len(path)-1]
}
```

**解析：** 深度优先搜索（DFS）是一种遍历树的算法。在这里，从根节点开始递归地遍历树的每个节点，将路径存储在一个切片中。如果当前节点是叶子节点，将路径添加到结果数组中。

#### 21. 广度优先搜索

**题目：** 实现一个函数，找出二叉树的最短路径。

**答案：**

```go
func shortestPathBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }
    q := []*TreeNode{root}
    depth := 0
    for len(q) > 0 {
        nextLevel := []*TreeNode{}
        for _, node := range q {
            if node.Left != nil {
                nextLevel = append(nextLevel, node.Left)
            }
            if node.Right != nil {
                nextLevel = append(nextLevel, node.Right)
            }
        }
        q = nextLevel
        depth++
    }
    return depth
}
```

**解析：** 广度优先搜索（BFS）是一种遍历树的算法。在这里，使用一个队列来存储当前层级的节点，然后逐层遍历树。每次遍历一层，深度加一。最后，返回深度即为最短路径的长度。

#### 22. 冒泡排序

**题目：** 实现一个函数，使用冒泡排序算法对数组进行排序。

**答案：**

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

**解析：** 冒泡排序是一种简单的排序算法。通过重复遍历要排序的数列，每次比较两个相邻的元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复进行直到没有再需要交换，也就是说该数列已经排序完成。

#### 23. 快速选择

**题目：** 实现一个函数，使用快速选择算法找出数组中的第 k 个最大元素。

**答案：**

```go
func quickSelect(nums []int, k int) int {
    n := len(nums)
    left, right := 0, n-1
    for {
        pivot := partition(nums, left, right)
        if pivot == k {
            return nums[pivot]
        } else if pivot < k {
            left = pivot + 1
        } else {
            right = pivot - 1
        }
    }
}

func partition(nums []int, left int, right int) int {
    pivot := nums[right]
    i := left
    for j := left; j < right; j++ {
        if nums[j] < pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    nums[i], nums[right] = nums[right], nums[i]
    return i
}
```

**解析：** 快速选择算法是一种用于找出数组中的第 k 个最大元素的算法。它利用了快速排序的思想，通过选择一个基准元素，将数组划分为小于基准元素和大于基准元素的两组。然后递归地在这两组中继续查找第 k 个最大元素。

#### 24. 优先队列

**题目：** 实现一个优先队列，支持插入、删除最小元素等操作。

**答案：**

```go
type PriorityQueue struct {
    heap []int
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{
        heap: []int{0},
    }
}

func (pq *PriorityQueue) Insert(val int) {
    pq.heap = append(pq.heap, val)
    siftUp(pq, len(pq.heap)-1)
}

func (pq *PriorityQueue) DeleteMin() int {
    if len(pq.heap) == 1 {
        return pq.heap[1]
    }
    min := pq.heap[1]
    pq.heap[1] = pq.heap[len(pq.heap)-1]
    pq.heap = pq.heap[:len(pq.heap)-1]
    siftDown(pq, 1)
    return min
}

func siftUp(pq *PriorityQueue, i int) {
    for i > 1 && pq.heap[i/2] > pq.heap[i] {
        pq.heap[i/2], pq.heap[i] = pq.heap[i], pq.heap[i/2]
        i = i / 2
    }
}

func siftDown(pq *PriorityQueue, i int) {
    l := i*2
    r := i*2 + 1
    smallest := i
    if l < len(pq.heap) && pq.heap[l] < pq.heap[smallest] {
        smallest = l
    }
    if r < len(pq.heap) && pq.heap[r] < pq.heap[smallest] {
        smallest = r
    }
    if smallest != i {
        pq.heap[i], pq.heap[smallest] = pq.heap[smallest], pq.heap[i]
        siftDown(pq, smallest)
    }
}
```

**解析：** 优先队列是一种特殊的队列，元素按照优先级排序。在这里，使用一个数组来实现优先队列，通过 siftUp 和 siftDown 函数来实现插入和删除最小元素的操作。

#### 25. 双端队列

**题目：** 实现一个双端队列，支持在头部和尾部添加和删除元素。

**答案：**

```go
type Deque struct {
    front *ListNode
    rear  *ListNode
}

func (d *Deque) PushFront(val int) {
    newNode := &ListNode{Val: val}
    if d.front == nil {
        d.front = newNode
        d.rear = newNode
    } else {
        newNode.Next = d.front
        d.front = newNode
    }
}

func (d *Deque) PushRear(val int) {
    newNode := &ListNode{Val: val}
    if d.rear == nil {
        d.front = newNode
        d.rear = newNode
    } else {
        d.rear.Next = newNode
        d.rear = newNode
    }
}

func (d *Deque) PopFront() int {
    if d.front == nil {
        return -1
    }
    val := d.front.Val
    d.front = d.front.Next
    if d.front == nil {
        d.rear = nil
    }
    return val
}

func (d *Deque) PopRear() int {
    if d.rear == nil {
        return -1
    }
    val := d.rear.Val
    if d.rear == d.front {
        d.front = nil
        d.rear = nil
    } else {
        prev := d.front
        for prev.Next != d.rear {
            prev = prev.Next
        }
        prev.Next = nil
        d.rear = prev
    }
    return val
}
```

**解析：** 双端队列是一种支持在头部和尾部添加和删除元素的队列。在这里，使用两个指针 `front` 和 `rear` 来表示队列的头部和尾部。

#### 26. 计数排序

**题目：** 实现一个函数，使用计数排序算法对数组进行排序。

**答案：**

```go
func countingSort(nums []int) []int {
    max := nums[0]
    for _, num := range nums {
        if num > max {
            max = num
        }
    }
    count := make([]int, max+1)
    for _, num := range nums {
        count[num]++
    }
    ans := []int{}
    for i, v := range count {
        for v > 0 {
            ans = append(ans, i)
            v--
        }
    }
    return ans
}
```

**解析：** 计数排序算法是一种非比较型整数排序算法，其核心思想是统计数组中每个元素的个数，然后按照元素的个数进行排序。在这里，首先找出数组中的最大元素，然后创建一个计数数组，统计每个元素的个数，最后按照计数数组进行排序。

#### 27. 桶排序

**题目：** 实现一个函数，使用桶排序算法对数组进行排序。

**答案：**

```go
func bucketSort(nums []int) []int {
    max := nums[0]
    for _, num := range nums {
        if num > max {
            max = num
        }
    }
    bucketCount := (max - min) / bucketSize + 1
    buckets := make([][]int, bucketCount)
    for i := range buckets {
        buckets[i] = []int{}
    }
    for _, num := range nums {
        index := (num - min) / bucketSize
        buckets[index] = append(buckets[index], num)
    }
    ans := []int{}
    for _, bucket := range buckets {
        insertionSort(bucket)
        ans = append(ans, bucket...)
    }
    return ans
}

func insertionSort(nums []int) {
    for i := 1; i < len(nums); i++ {
        key := nums[i]
        j := i - 1
        for j >= 0 && nums[j] > key {
            nums[j+1] = nums[j]
            j--
        }
        nums[j+1] = key
    }
}
```

**解析：** 桶排序算法是一种基于比较的排序算法，其核心思想是将待排序的元素分配到不同的桶中，然后对每个桶中的元素进行排序。在这里，首先计算最大值和最小值，然后计算桶的数量和大小，将元素分配到对应的桶中，最后对每个桶进行插入排序。

#### 28. 堆排序

**题目：** 实现一个函数，使用堆排序算法对数组进行排序。

**答案：**

```go
func heapify(nums []int, n, i int) {
    largest := i
    l := 2*i + 1
    r := 2*i + 2
    if l < n && nums[l] > nums[largest] {
        largest = l
    }
    if r < n && nums[r] > nums[largest] {
        largest = r
    }
    if largest != i {
        nums[i], nums[largest] = nums[largest], nums[i]
        heapify(nums, n, largest)
    }
}

func heapSort(nums []int) {
    n := len(nums)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(nums, n, i)
    }
    for i := n - 1; i > 0; i-- {
        nums[0], nums[i] = nums[i], nums[0]
        heapify(nums, i, 0)
    }
}
```

**解析：** 堆排序算法是一种基于比较的排序算法，其核心思想是构建一个大顶堆，然后将堆顶元素与最后一个元素交换，再将剩余的元素重新调整为堆，重复这个过程直到堆的大小为 1。在这里，首先从最后一个非叶子节点开始构建堆，然后对堆进行排序。

#### 29. 环形链表

**题目：** 实现一个函数，判断一个链表是否为环形链表。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 使用快慢指针算法来判断链表是否为环形链表。快指针每次走两步，慢指针每次走一步。如果链表中存在环形结构，快指针一定会追上慢指针。

#### 30. 单调栈

**题目：** 实现一个函数，找到数组的下一个更大元素。

**答案：**

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stk := []int{}
    ans := make([]int, len(nums1), len(nums1))
    for i, v := range nums2 {
        for len(stk) > 0 && stk[len(stk)-1] < v {
            ans[stk[len(stk)-1]] = v
            stk = stk[:len(stk)-1]
        }
        stk = append(stk, i)
    }
    for i := range ans {
        if ans[i] == 0 {
            ans[i] = -1
        }
    }
    return ans
}
```

**解析：** 使用单调栈来找到下一个更大元素。遍历 nums2，将 nums1 中对应位置的元素入栈，如果栈顶元素小于当前元素，说明当前元素是栈顶元素的下一个更大元素，将答案更新为当前元素，然后出栈。最后，将答案中为 0 的位置更新为 -1，表示没有下一个更大元素。

