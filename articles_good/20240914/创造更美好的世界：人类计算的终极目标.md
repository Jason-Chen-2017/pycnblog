                 

### 创造更美好的世界：人类计算的终极目标

#### 面试题库与算法编程题库

##### 1. 贪心算法之活动选择问题

**题目描述：** 给定一个会议时间表，每个会议有一个开始时间和结束时间，且时间不会重叠。设计一个算法来选择会议数量最大化，且确保会议之间有至少一个时间间隔。

**答案：** 通过贪心算法，选择结束时间最早的会议，并跳过下一个会议的开始时间。以下是Python代码实现：

```python
def activity_selection(meetings):
    meetings.sort(key=lambda x: x[1])
    selected_meetings = [meetings[0]]
    last_end = meetings[0][1]
    for start, end in meetings[1:]:
        if start > last_end:
            selected_meetings.append((start, end))
            last_end = end
    return selected_meetings
```

**解析：** 此算法保证了每次选择结束时间最早的会议，从而最大化会议数量。

##### 2. 并查集之社交网络分组

**题目描述：** 给定一个无向图，表示社交网络中的用户及其关系。设计一个算法来找出最小的分组数量，使得每个分组内的用户都是直接或间接的朋友。

**答案：** 通过并查集算法，合并有关系的用户，并计数分组数。以下是Python代码实现：

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]

def min_community_users(n, edges):
    uf = UnionFind(n)
    for u, v in edges:
        uf.union(u, v)
    return len(set(uf.find(i) for i in range(n)))
```

**解析：** 并查集算法用于处理连通性问题时非常高效。

##### 3. 广度优先搜索之岛屿数量

**题目描述：** 给定一个由`1`（陆地）和`0`（水）组成的二维网格，计算岛屿的数量。

**答案：** 通过广度优先搜索（BFS）来遍历岛屿。以下是Java代码实现：

```java
import java.util.LinkedList;
import java.util.Queue;

public class Solution {
    public int numIslands(char[][] grid) {
        int m = grid.length, n = grid[0].length;
        int numIslands = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    numIslands++;
                    bfs(grid, i, j);
                }
            }
        }
        return numIslands;
    }

    private void bfs(char[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        Queue<int[]> q = new LinkedList<>();
        q.offer(new int[]{i, j});
        grid[i][j] = '0';
        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];
            if (x + 1 < m && grid[x + 1][y] == '1') {
                q.offer(new int[]{x + 1, y});
                grid[x + 1][y] = '0';
            }
            if (y + 1 < n && grid[x][y + 1] == '1') {
                q.offer(new int[]{x, y + 1});
                grid[x][y + 1] = '0';
            }
            if (x - 1 >= 0 && grid[x - 1][y] == '1') {
                q.offer(new int[]{x - 1, y});
                grid[x - 1][y] = '0';
            }
            if (y - 1 >= 0 && grid[x][y - 1] == '1') {
                q.offer(new int[]{x, y - 1});
                grid[x][y - 1] = '0';
            }
        }
    }
}
```

**解析：** 广度优先搜索用于遍历图或网格，找到所有的岛屿。

##### 4. 深度优先搜索之路径总和

**题目描述：** 给定一个二叉树，找到所有路径总和等于给定数值的路径。

**答案：** 通过深度优先搜索（DFS）来遍历二叉树。以下是C++代码实现：

```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        vector<vector<int>> res;
        if (!root) return res;
        dfs(root, sum, res, {});
        return res;
    }

private:
    void dfs(TreeNode* node, int sum, vector<vector<int>>& res, vector<int>& path) {
        if (!node) return;
        path.push_back(node->val);
        if (node->val == sum && !node->left && !node->right) {
            res.push_back(path);
        } else {
            dfs(node->left, sum - node->val, res, path);
            dfs(node->right, sum - node->val, res, path);
        }
        path.pop_back();
    }
};
```

**解析：** 深度优先搜索用于遍历树结构，找到满足条件的路径。

##### 5. 动态规划之最长递增子序列

**题目描述：** 给定一个无序数组，找出最长递增子序列的长度。

**答案：** 通过动态规划（DP）来求解。以下是Python代码实现：

```python
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**解析：** 动态规划用于求解最优子结构问题，找到最长递增子序列。

##### 6. 树状数组之区间更新与查询

**题目描述：** 使用树状数组实现一个支持区间更新和查询的函数。

**答案：** 通过树状数组实现。以下是C++代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 1e5 + 10;
int tree[N];
int n;

void update(int x, int val) {
    while (x <= n) {
        tree[x] += val;
        x += x & (-x);
    }
}

int query(int x) {
    int res = 0;
    while (x > 0) {
        res += tree[x];
        x -= x & (-x);
    }
    return res;
}
```

**解析：** 树状数组用于高效解决区间更新与查询问题。

##### 7. 背包问题之01背包

**题目描述：** 给定一组物品和它们的价值与重量，设计一个算法来计算最大价值，且不超过背包的容量。

**答案：** 通过动态规划实现。以下是Java代码实现：

```java
public int knapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n + 1][capacity + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (weights[i - 1] <= j) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[n][capacity];
}
```

**解析：** 动态规划用于解决背包问题，找到最大价值。

##### 8. 快速幂算法

**题目描述：** 给定一个整数和一个正整数指数，设计一个算法计算整数的大指数次幂。

**答案：** 通过快速幂算法实现。以下是Python代码实现：

```python
def fast_power(x, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        return fast_power(x * x, n // 2)
    return x * fast_power(x * x, (n - 1) // 2)
```

**解析：** 快速幂算法通过递归减少计算次数，提高效率。

##### 9. 高精度计算

**题目描述：** 实现高精度整数加法。

**答案：** 通过字符串处理实现。以下是Java代码实现：

```java
public String high_precision_add(String num1, String num2) {
    int len1 = num1.length(), len2 = num2.length();
    int carry = 0;
    int i = len1 - 1, j = len2 - 1;
    StringBuilder sb = new StringBuilder();
    while (i >= 0 || j >= 0 || carry > 0) {
        int x = i >= 0 ? num1.charAt(i--) - '0' : 0;
        int y = j >= 0 ? num2.charAt(j--) - '0' : 0;
        int sum = x + y + carry;
        sb.append(sum % 10);
        carry = sum / 10;
    }
    return sb.reverse().toString();
}
```

**解析：** 高精度计算通过字符串处理，避免整数溢出。

##### 10. 回溯算法之八皇后问题

**题目描述：** 在8×8格子上放置8个皇后，使得它们不会相互攻击。

**答案：** 通过回溯算法实现。以下是C++代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 8;
int ok;
vector<vector<int>> board;

bool check(int row, int col) {
    for (int i = 0; i < board.size(); i++) {
        if (board[i][col] == 1 || abs(i - row) == abs(board[i][col] - col)) {
            return false;
        }
    }
    return true;
}

void dfs(int row) {
    if (row == N) {
        ok = 1;
        return;
    }
    for (int col = 0; col < N; col++) {
        if (check(row, col)) {
            board[row][col] = 1;
            dfs(row + 1);
            board[row][col] = 0;
        }
    }
}

void print_solution() {
    cout << "One possible solution is:" << endl;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (board[i][j]) cout << "Q ";
            else cout << ". ";
        }
        cout << endl;
    }
}

int main() {
    board = vector<vector<int>>(N, vector<int>(N, 0));
    ok = 0;
    dfs(0);
    if (ok == 0) cout << "No solution." << endl;
    else print_solution();
    return 0;
}
```

**解析：** 回溯算法用于解决八皇后问题，找到所有可能的解决方案。

##### 11. 前缀树之单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断单词是否存在于网格中。

**答案：** 通过前缀树实现。以下是Java代码实现：

```java
class Trie {
    Trie[] children = new Trie[26];
    boolean isEnd = false;

    public void insert(String word) {
        Trie node = this;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new Trie();
            }
            node = node.children[idx];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        Trie node = this;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                return false;
            }
            node = node.children[idx];
        }
        return node.isEnd;
    }
}

public boolean exist(char[][] board, String word) {
    int m = board.length, n = board[0].length;
    Trie trie = new Trie();
    for (char c : word.toCharArray()) {
        trie.insert(c + "");
    }
    boolean[][] visited = new boolean[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (search(board, trie, word, i, j, visited)) {
                return true;
            }
        }
    }
    return false;
}

private boolean search(char[][] board, Trie trie, String word, int i, int j, boolean[][] visited) {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || !trie.search(board[i][j] + "")) {
        return false;
    }
    visited[i][j] = true;
    if (word.length() == 1) {
        return true;
    }
    boolean res = search(board, trie, word.substring(1), i - 1, j, visited) || search(board, trie, word.substring(1), i + 1, j, visited) ||
                  search(board, trie, word.substring(1), i, j - 1, visited) || search(board, trie, word.substring(1), i, j + 1, visited);
    visited[i][j] = false;
    return res;
}
```

**解析：** 前缀树用于快速查找单词是否存在。

##### 12. 贪心算法之会议时间安排

**题目描述：** 给定一系列会议，每个会议有一个开始时间和结束时间，设计一个算法安排会议，使得任意两个会议之间都有至少一个时间间隔。

**答案：** 通过贪心算法实现。以下是Python代码实现：

```python
def schedule_meetings(meetings):
    meetings.sort(key=lambda x: x[1])
    result = []
    result.append(meetings[0])
    for i in range(1, len(meetings)):
        if meetings[i][0] >= result[-1][1]:
            result.append(meetings[i])
    return result
```

**解析：** 贪心算法用于选择结束时间最早的会议，确保会议之间有至少一个时间间隔。

##### 13. 双指针法之寻找两个正序数组的中位数

**题目描述：** 给定两个排序后的整数数组，找到它们的第k大元素。

**答案：** 通过双指针法实现。以下是Java代码实现：

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int m = nums1.length, n = nums2.length;
    int left = 0, right = m;
    while (left <= right) {
        int mid1 = (left + right) / 2;
        int mid2 = (m + n + 1) / 2 - mid1;
        int a = (mid1 == 0) ? Integer.MIN_VALUE : nums1[mid1 - 1];
        int b = (mid2 == 0) ? Integer.MIN_VALUE : nums2[mid2 - 1];
        int c = (mid1 == m) ? Integer.MAX_VALUE : nums1[mid1];
        int d = (mid2 == n) ? Integer.MAX_VALUE : nums2[mid2];
        if (a <= d && b <= c) {
            if ((m + n) % 2 == 0) {
                return (max(a, b) + min(c, d)) / 2.0;
            } else {
                return max(a, b);
            }
        } else if (a > d) {
            right = mid1 - 1;
        } else {
            left = mid1 + 1;
        }
    }
    throw new IllegalArgumentException("Input arrays are not sorted.");
}
```

**解析：** 双指针法用于找到两个排序数组的第k大元素。

##### 14. 并查集之最小生成树

**题目描述：** 给定一个无向图和边权，设计一个算法计算图的最小生成树。

**答案：** 通过并查集实现。以下是Python代码实现：

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]

def kruskal(edges, n):
    uf = UnionFind(n)
    edges.sort(key=lambda x: x[2])
    mst = []
    for u, v, w in edges:
        if uf.find(u) != uf.find(v):
            uf.union(u, v)
            mst.append((u, v, w))
    return mst
```

**解析：** 并查集用于计算图的最小生成树，找到最小权重的边。

##### 15. 堆排序

**题目描述：** 实现堆排序算法。

**答案：** 通过堆实现。以下是C++代码实现：

```cpp
#include <iostream>
#include <vector>
using namespace std;

void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heap_sort(vector<int>& arr) {
    int n = arr.size();

    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    for (int i = n - 1; i >= 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    heap_sort(arr);
    for (int i : arr) {
        cout << i << " ";
    }
    cout << endl;
    return 0;
}
```

**解析：** 堆排序利用堆的性质，实现高效的排序算法。

##### 16. 排序算法之冒泡排序

**题目描述：** 实现冒泡排序算法。

**答案：** 通过冒泡排序实现。以下是Python代码实现：

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

**解析：** 冒泡排序通过反复交换相邻的逆序元素，实现排序。

##### 17. 双指针法之寻找重复的数

**题目描述：** 给定一个包含n+1个整数的数组nums，其中只有一个整数重复了，但不知道哪个。请找出并返回这个重复的数。

**答案：** 通过双指针法实现。以下是Java代码实现：

```java
public int findDuplicate(int[] nums) {
    int fast = 0, slow = 0;
    do {
        fast = nums[nums[fast]];
        slow = nums[slow];
    } while (fast != slow);
    fast = 0;
    while (fast != slow) {
        fast = nums[fast];
        slow = nums[slow];
    }
    return slow;
}
```

**解析：** 双指针法用于找到数组中的重复元素，采用快慢指针循环。

##### 18. 二分查找法之寻找旋转排序数组中的最小值

**题目描述：** 给定一个可能包含重复元素的旋转排序数组，编写一个函数来找出并返回数组中的最小元素。

**答案：** 通过二分查找法实现。以下是Python代码实现：

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = left + (right - left) / 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：** 二分查找法用于在旋转排序数组中找到最小值。

##### 19. 红黑树

**题目描述：** 实现红黑树。

**答案：** 通过红黑树实现。以下是C++代码实现：

```cpp
#include <iostream>
using namespace std;

enum Color { RED, BLACK };

struct Node {
    int val;
    bool color;
    Node *left, *right, *parent;
    Node(int x) : val(x), color(RED), left(NULL), right(NULL), parent(NULL) {}
};

class RBTree {
public:
    RBTree() : root(NULL) {}
    void insert(int x);
    void inorder_traversal(Node* node);
private:
    Node* root;
    void insert_fixup(Node* node);
    void left_rotate(Node* node);
    void right_rotate(Node* node);
};

void RBTree::insert(int x) {
    Node* node = new Node(x);
    Node* parent = NULL;
    Node* current = root;
    while (current != NULL) {
        parent = current;
        if (node->val < current->val)
            current = current->left;
        else
            current = current->right;
    }
    node->parent = parent;
    if (parent == NULL)
        root = node;
    else if (node->val < parent->val)
        parent->left = node;
    else
        parent->right = node;
    insert_fixup(node);
}

void RBTree::insert_fixup(Node* node) {
    while (node->parent != NULL && node->parent->color == RED) {
        if (node->parent == node->parent->parent->left) {
            Node* uncle = node->parent->parent->right;
            if (uncle != NULL && uncle->color == RED) {
                node->parent->color = BLACK;
                uncle->color = BLACK;
                node->parent->parent->color = RED;
                node = node->parent->parent;
            } else {
                if (node == node->parent->right) {
                    left_rotate(node->parent);
                    node = node->left;
                }
                right_rotate(node->parent->parent);
                swap(node->parent->parent->color, node->parent->color);
            }
        } else {
            Node* uncle = node->parent->parent->left;
            if (uncle != NULL && uncle->color == RED) {
                node->parent->color = BLACK;
                uncle->color = BLACK;
                node->parent->parent->color = RED;
                node = node->parent->parent;
            } else {
                if (node == node->parent->left) {
                    right_rotate(node->parent);
                    node = node->right;
                }
                left_rotate(node->parent->parent);
                swap(node->parent->parent->color, node->parent->color);
            }
        }
    }
    root->color = BLACK;
}

void RBTree::left_rotate(Node* node) {
    Node* right_child = node->right;
    node->right = right_child->left;
    if (right_child->left != NULL)
        right_child->left->parent = node;
    right_child->parent = node->parent;
    if (node->parent == NULL)
        root = right_child;
    else if (node == node->parent->left)
        node->parent->left = right_child;
    else
        node->parent->right = right_child;
    right_child->left = node;
    node->parent = right_child;
}

void RBTree::right_rotate(Node* node) {
    Node* left_child = node->left;
    node->left = left_child->right;
    if (left_child->right != NULL)
        left_child->right->parent = node;
    left_child->parent = node->parent;
    if (node->parent == NULL)
        root = left_child;
    else if (node == node->parent->right)
        node->parent->right = left_child;
    else
        node->parent->left = left_child;
    left_child->right = node;
    node->parent = left_child;
}

void RBTree::inorder_traversal(Node* node) {
    if (node == NULL)
        return;
    inorder_traversal(node->left);
    cout << node->val << " ";
    inorder_traversal(node->right);
}

int main() {
    RBTree tree;
    tree.insert(10);
    tree.insert(15);
    tree.insert(20);
    tree.insert(25);
    tree.insert(30);
    tree.insert(5);
    tree.insert(7);
    tree.insert(2);
    tree.insert(1);
    tree.inorder_traversal(tree.root);
    return 0;
}
```

**解析：** 红黑树是一种自平衡的二叉查找树，保证了树的平衡，提高了查找效率。

##### 20. 字符串匹配算法之KMP

**题目描述：** 实现KMP算法，用于字符串匹配。

**答案：** 通过KMP算法实现。以下是C++代码实现：

```cpp
#include <iostream>
#include <string>
using namespace std;

vector<int> compute_lps(string pat) {
    int len = pat.length();
    vector<int> lps(len, 0);
    int len_match = 0;
    for (int i = 1; i < len;) {
        if (pat[i] == pat[len_match]) {
            lps[i] = ++len_match;
            i++;
        } else {
            if (len_match != 0) {
                len_match = lps[len_match - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

int kmp_search(string txt, string pat) {
    int n = txt.length();
    int m = pat.length();
    vector<int> lps = compute_lps(pat);
    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    while (i < n) {
        if (pat[j] == txt[i]) {
            i++;
            j++;
        }
        if (j == m) {
            return i - j;
        } else if (i < n && pat[j] != txt[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i = i + 1;
            }
        }
    }
    return -1;
}

int main() {
    string txt = "ABABDABACD";
    string pat = "ABABCABAB";
    int index = kmp_search(txt, pat);
    if (index != -1)
        cout << "Pattern found at index " << index << endl;
    else
        cout << "Pattern not found" << endl;
    return 0;
}
```

**解析：** KMP算法通过预处理模式字符串，避免了不必要的比较，提高了字符串匹配的效率。

##### 21. 前缀树之单词搜索II

**题目描述：** 给定一个二维网格和一个单词列表，实现一个函数来返回网格中所有的单词。

**答案：** 通过前缀树实现。以下是Java代码实现：

```java
class Trie {
    Trie[] children;
    boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }

    public void insert(String word) {
        Trie node = this;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        Trie node = this;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (node.children[index] == null) {
                return false;
            }
            node = node.children[index];
        }
        return node.isEnd;
    }
}

public List<String> findWords(char[][] board, String[] words) {
    Trie trie = new Trie();
    for (String word : words) {
        trie.insert(word);
    }
    List<String> result = new ArrayList<>();
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            dfs(board, i, j, trie, result);
        }
    }
    return result;
}

private void dfs(char[][] board, int i, int j, Trie trie, List<String> result) {
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == '#' || !trie.search(board[i][j] + "")) {
        return;
    }
    char temp = board[i][j];
    board[i][j] = '#';
    if (trie.search(temp + "")) {
        result.add(temp + "");
        trie.search(temp + "");
    }
    dfs(board, i + 1, j, trie, result);
    dfs(board, i - 1, j, trie, result);
    dfs(board, i, j + 1, trie, result);
    dfs(board, i, j - 1, trie, result);
    board[i][j] = temp;
}
```

**解析：** 前缀树用于快速查找单词是否存在，并用于实现单词搜索II。

##### 22. 二分查找法之在排序数组中查找元素的第一个和最后一个位置

**题目描述：** 给定一个已排序的整数数组，找到给定元素第一个和最后一个位置。

**答案：** 通过二分查找法实现。以下是Java代码实现：

```java
public int[] searchRange(int[] nums, int target) {
    int[] result = new int[]{-1, -1};
    result[0] = binary_search(nums, target, true);
    result[1] = binary_search(nums, target, false);
    return result;
}

private int binary_search(int[] nums, int target, boolean first) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            if (first) {
                if (mid == 0 || nums[mid - 1] != target) {
                    return mid;
                } else {
                    right = mid - 1;
                }
            } else {
                if (mid == nums.length - 1 || nums[mid + 1] != target) {
                    return mid;
                } else {
                    left = mid + 1;
                }
            }
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

**解析：** 二分查找法用于在排序数组中查找元素的第一个和最后一个位置。

##### 23. 贪心算法之最优装载问题

**题目描述：** 给定一系列物品的体积和车辆的容量，设计一个算法计算装载最多物品的车辆数量。

**答案：** 通过贪心算法实现。以下是C++代码实现：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int max_load(vector<int>& items, int capacity) {
    sort(items.rbegin(), items.rend());
    int count = 0;
    int remaining_capacity = capacity;
    for (int item : items) {
        if (item <= remaining_capacity) {
            remaining_capacity -= item;
            count++;
        } else {
            break;
        }
    }
    return count;
}

int main() {
    vector<int> items = {2, 3, 4, 5, 6};
    int capacity = 10;
    cout << "Maximum number of items that can be loaded: " << max_load(items, capacity) << endl;
    return 0;
}
```

**解析：** 贪心算法用于计算最优装载问题，每次选择体积最大的物品装载。

##### 24. 并查集之统计连通分量

**题目描述：** 给定一个无向图，统计图中连通分量的数量。

**答案：** 通过并查集实现。以下是Python代码实现：

```python
def count_components(edges):
    n = len(edges)
    uf = UnionFind(n)
    for u, v in edges:
        uf.union(u, v)
    return len(set(uf.find(i) for i in range(n)))

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]]
```

**解析：** 并查集用于统计无向图中的连通分量。

##### 25. 贪心算法之最小费用路径

**题目描述：** 给定一个带权重的图和起点、终点，设计一个算法计算从起点到终点的最小费用路径。

**答案：** 通过贪心算法实现。以下是Python代码实现：

```python
def min_cost_path(graph, start, end):
    nodes = list(graph.keys())
    nodes.sort(key=lambda x: graph[x][0])
    cost = 0
    visited = set()
    for node in nodes:
        if node in visited:
            continue
        if node == end:
            cost += graph[node][0]
            break
        cost += graph[node][0]
        visited.add(node)
    return cost

graph = {
    'A': (1, 4),
    'B': (1, 2),
    'C': (2, 2),
    'D': (2, 1),
    'E': (3, 1),
    'F': (3, 2),
    'G': (4, 2),
    'H': (4, 3),
    'I': (5, 3),
    'J': (5, 4),
    'K': (6, 4),
    'L': (6, 5),
    'M': (7, 5),
    'N': (7, 6),
    'O': (8, 6),
    'P': (8, 7),
    'Q': (9, 7),
    'R': (9, 8),
    'S': (10, 8),
    'T': (10, 9)
}

start = 'A'
end = 'T'
min_cost = min_cost_path(graph, start, end)
print("Minimum cost from", start, "to", end, "is", min_cost)
```

**解析：** 贪心算法用于计算带权图中从起点到终点的最小费用路径。

##### 26. 快速选择算法

**题目描述：** 给定一个无序数组，设计一个算法找出第k大的元素。

**答案：** 通过快速选择算法实现。以下是Java代码实现：

```java
public int findKthLargest(int[] nums, int k) {
    return quickSelect(nums, 0, nums.length - 1, nums.length - k);
}

private int quickSelect(int[] nums, int left, int right, int k) {
    if (left == right) {
        return nums[left];
    }
    int pivot = nums[right];
    int i = left;
    for (int j = left; j < right; j++) {
        if (nums[j] <= pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, i, right);
    if (i == k) {
        return nums[i];
    } else if (i > k) {
        return quickSelect(nums, left, i - 1, k);
    } else {
        return quickSelect(nums, i + 1, right, k);
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

**解析：** 快速选择算法是一种高效的找第k大元素的算法，基于快速排序的分割思想。

##### 27. 贪心算法之最优装载问题

**题目描述：** 给定一系列物品的体积和车辆的容量，设计一个算法计算装载最多物品的车辆数量。

**答案：** 通过贪心算法实现。以下是C++代码实现：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int max_load(vector<pair<int, int>>& items, int capacity) {
    sort(items.begin(), items.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second < b.second;
    });
    int count = 0;
    int remaining_capacity = capacity;
    for (auto item : items) {
        if (item.first <= remaining_capacity) {
            remaining_capacity -= item.first;
            count++;
        } else {
            break;
        }
    }
    return count;
}

int main() {
    vector<pair<int, int>> items = {
        {2, 4}, {3, 6}, {4, 8}, {5, 10}, {6, 12}
    };
    int capacity = 10;
    cout << "Maximum number of items that can be loaded: " << max_load(items, capacity) << endl;
    return 0;
}
```

**解析：** 贪心算法用于计算最优装载问题，每次选择体积最大的物品装载。

##### 28. 动态规划之最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**答案：** 通过动态规划实现。以下是Python代码实现：

```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

str1 = "ABCD"
str2 = "ACDF"
lcs_length = longest_common_subsequence(str1, str2)
print("Length of the longest common subsequence:", lcs_length)
```

**解析：** 动态规划用于计算最长公共子序列，通过构建一个二维数组来存储中间结果。

##### 29. 单调栈法之下一个更大元素

**题目描述：** 给定一个数组，返回每个元素的下一个更大元素。如果不存在更大元素，则用-1填充。

**答案：** 通过单调栈实现。以下是Java代码实现：

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {
    Stack<Integer> stack = new Stack<>();
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums2) {
        while (!stack.isEmpty() && stack.peek() <= num) {
            stack.pop();
        }
        map.put(num, stack.isEmpty() ? -1 : stack.peek());
        stack.push(num);
    }
    int[] result = new int[nums1.length];
    for (int i = 0; i < nums1.length; i++) {
        result[i] = map.get(nums1[i]);
    }
    return result;
}
```

**解析：** 单调栈法用于找到每个元素的下一个更大元素，通过维护一个递减的栈来高效地查找。

##### 30. 广度优先搜索之拓扑排序

**题目描述：** 给定一个有向无环图（DAG），设计一个算法进行拓扑排序。

**答案：** 通过广度优先搜索实现。以下是Python代码实现：

```python
from collections import deque

def topological_sort(edges, num_nodes):
    indegrees = [0] * (num_nodes + 1)
    for u, v in edges:
        indegrees[v] += 1
    queue = deque()
    for i in range(1, num_nodes + 1):
        if indegrees[i] == 0:
            queue.append(i)
    result = []
    while queue:
        node = queue.popleft()
        result.append(node)
        for v in edges[node]:
            indegrees[v] -= 1
            if indegrees[v] == 0:
                queue.append(v)
    return result

edges = [(1, 2), (1, 3), (2, 4), (3, 4)]
num_nodes = 5
topological_order = topological_sort(edges, num_nodes)
print("Topological order:", topological_order)
```

**解析：** 广度优先搜索用于实现拓扑排序，通过计算每个节点的入度并使用队列进行排序。

