                 

## 《知识的开放获取：消除信息鸿沟的努力》 - 面试题和算法编程题集

### 1. 数据结构 - 栈与队列

**题目：** 实现一个最小值栈。

**答案：** 利用辅助栈来记录每个元素对应的最小值。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self) -> None:
        if self.stack:
            x = self.stack.pop()
            if x == self.min_stack[-1]:
                self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1] if self.stack else None

    def getMin(self) -> int:
        return self.min_stack[-1] if self.min_stack else None
```

**解析：** 这个实现中，我们维护一个辅助栈 `min_stack`，用来记录当前栈中的最小值。每次push和pop时，都要检查当前元素是否小于或等于 `min_stack` 的顶部元素。

### 2. 算法 - 排序算法

**题目：** 实现快速排序算法。

**答案：** 快速排序的基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序。

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

**解析：** 快速排序的核心是选择一个基准元素 `pivot`，然后将数组分成小于 `pivot` 和大于 `pivot` 的两部分，递归地对这两部分进行排序。

### 3. 算法 - 二分查找

**题目：** 在排序数组中查找元素的第一个和最后一个位置。

**答案：** 利用二分查找，分别寻找第一个和最后一个出现的位置。

```python
def searchRange(nums, target):
    def findFirst():
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left if left < len(nums) and nums[left] == target else -1

    def findLast():
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right if right >= 0 and nums[right] == target else -1

    return [findFirst(), findLast()]
```

**解析：** 需要分别定义两个函数 `findFirst` 和 `findLast` 来查找第一个和最后一个目标元素的位置。

### 4. 算法 - 股票买卖最佳时机

**题目：** 给定一个数组 prices，其中 prices[i] 是第 i 天的股票价格。如果你最多只允许完成一笔交易，设计一个算法来找到最大的利润。

**答案：** 计算数组中相邻元素的最大差值。

```python
def maxProfit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        max_profit = max(max_profit, prices[i] - prices[i - 1])
    return max_profit
```

**解析：** 遍历数组，计算相邻两天股票价格的差值，更新最大利润。

### 5. 算法 - 链表遍历

**题目：** 实现一个链表遍历的功能。

**答案：** 使用循环或递归来遍历链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def printList(head):
    while head:
        print(head.val, end=" -> ")
        head = head.next
    print("None")
```

**解析：** 遍历链表，依次打印每个节点的值。

### 6. 数据结构 - 哈希表

**题目：** 实现一个带限制的LRU缓存。

**答案：** 利用哈希表和双向链表实现。

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hashmap = {}
        self.dummy_head = ListNode(0, None)
        self.dummy_tail = ListNode(0, None)
        self.dummy_head.next = self.dummy_tail
        self.dummy_tail.prev = self.dummy_head

    def get(self, key: int) -> int:
        if key not in self.hashmap:
            return -1
        node = self.hashmap[key]
        self.moveToHead(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.hashmap:
            node = self.hashmap[key]
            node.val = value
            self.moveToHead(node)
        else:
            if len(self.hashmap) >= self.capacity:
                lru_key = self.dummy_head.next.val
                pop_node = self.hashmap.pop(lru_key)
                self.removeNode(pop_node)
            new_node = ListNode(key, value)
            self.hashmap[key] = new_node
            self.addtoList(new_node)

    def removeNode(self, node):
        prev_node = node.prev
        next_node = node.next
        prev_node.next = next_node
        next_node.prev = prev_node

    def addtoList(self, node):
        last_node = self.dummy_tail.prev
        last_node.next = node
        self.dummy_tail.prev = node
        node.next = self.dummy_tail
        node.prev = last_node

    def moveToHead(self, node):
        self.removeNode(node)
        self.addtoList(node)
```

**解析：** 使用双向链表来记录最近最少使用的节点，通过哈希表快速访问。

### 7. 算法 - 爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶。请计算有多少种不同的方法可以爬到楼顶。

**答案：** 使用动态规划解决。

```python
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    a, b = 1, 2
    for i in range(2, n):
        a, b = b, a + b
    return b
```

**解析：** 使用变量 `a` 和 `b` 分别记录前两个数的值，迭代更新。

### 8. 算法 - 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈进行计算。

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            elif token == "/":
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack[-1]
```

**解析：** 遍历 tokens，对于运算符，从栈顶弹出两个元素进行运算，并将结果入栈。

### 9. 算法 - 合并区间

**题目：** 给定一个区间的列表，合并所有重叠的区间。

**答案：** 排序后合并相邻区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort()
    ans = [intervals[0]]
    for i in range(1, len(intervals)):
        if ans[-1][1] >= intervals[i][0]:
            ans[-1][1] = max(ans[-1][1], intervals[i][1])
        else:
            ans.append(intervals[i])
    return ans
```

**解析：** 首先对区间排序，然后合并相邻的区间。

### 10. 算法 - 柯里化函数

**题目：** 实现一个柯里化函数。

**答案：** 使用闭包实现。

```python
def curry(func):
    def curried(*args):
        if len(args) == len(func.__code__.co_argcount):
            return func(*args)
        else:
            return lambda *args2: curried(*args + args2)
    return curried
```

**解析：** 柯里化是将一个函数从多个参数变成多个函数的过程。

### 11. 算法 - 单调栈

**题目：** 使用单调栈实现下一个更大元素。

**答案：** 利用栈来找到每个元素的下一个更大元素。

```python
def nextGreaterElements(nums):
    n = len(nums)
    ans = [-1] * n
    stack = []
    for i in range(2 * n - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i]:
            stack.pop()
        if stack:
            ans[i % n] = nums[stack[-1]]
        stack.append(i % n)
    return ans
```

**解析：** 遍历数组，使用单调栈找到每个元素的下一个更大元素。

### 12. 算法 - 最长公共前缀

**题目：** 找出最长的公共前缀。

**答案：** 从字符串的最前面开始逐个字符比较。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        for i, c in enumerate(s):
            if i >= len(prefix) or s[i] != prefix[i]:
                prefix = prefix[:i]
                break
    return prefix
```

**解析：** 依次比较每个字符串的字符，直到找到不同的字符。

### 13. 算法 - 分割等和子集

**题目：** 判断是否存在两个子集，使得它们的和相等。

**答案：** 使用动态规划解决。

```python
def canPartition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    dp = [[False] * (target + 1) for _ in range(len(nums) + 1)]
    dp[0][0] = True
    for i, num in enumerate(nums, 1):
        for j in range(target + 1):
            if j >= num:
                dp[i][j] = dp[i - 1][j - num] or dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[-1][-1]
```

**解析：** 创建一个动态规划数组，判断是否能将数组分割成和为 `target` 的两个子集。

### 14. 算法 - 两数相加

**题目：** 不使用加法、不使用递归、不使用乘法，实现加法运算。

**答案：** 使用位运算实现。

```python
def add(a, b):
    while b:
        a, b = (a ^ b) ^ (a & b), ((a & b) << 1)
    return a
```

**解析：** 使用位运算 `^` 和 `&` 进行加法运算。

### 15. 算法 - 单词搜索

**题目：** 给定一个二维字符网格和一个单词，判断该单词是否存在于网格中。

**答案：** 使用深度优先搜索。

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if (
            i < 0
            or i >= len(board)
            or j < 0
            or j >= len(board[0])
            or board[i][j] != word[k]
            or visited[i][j]
        ):
            return False
        visited[i][j] = True
        if dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1):
            return True
        visited[i][j] = False
        return False

    visited = [[False] * len(board[0]) for _ in range(len(board))]
    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

**解析：** 使用深度优先搜索遍历网格，检查是否能够找到单词。

### 16. 算法 - 最长有效括号

**题目：** 给定一个字符串，找到最长的有效括号子串。

**答案：** 使用栈。

```python
def longestValidParentheses(s):
    stack = [-1]
    ans = 0
    for i, c in enumerate(s):
        if c == "(":
            stack.append(i)
        else:
            stack.pop()
            if not stack:
                stack.append(i)
            else:
                ans = max(ans, i - stack[-1])
    return ans
```

**解析：** 使用栈来记录有效括号的起始位置。

### 17. 算法 - 翻转字符串中的单词

**题目：** 给定一个字符串，将其中的单词翻转过来。

**答案：** 使用两个栈。

```python
def reverseWords(s):
    stack = []
    for c in s:
        if c == " ":
            if stack:
                stack.append(" ")
            while stack and stack[-1] == " ":
                stack.pop()
        else:
            stack.append(c)
    return "".join(stack[::-1])
```

**解析：** 将字符串中的空格和单词分别存入栈中，然后出栈得到结果。

### 18. 算法 - 盛水问题

**题目：** 给定一个容器，求容器能装下的最大水量。

**答案：** 双指针。

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    ans = 0
    while left < right:
        ans = max(ans, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return ans
```

**解析：** 双指针法，比较左右两边的最小值，并移动指针。

### 19. 算法 - 扑克牌中的顺子

**题目：** 判断一副扑克牌是否是顺子。

**答案：** 排序后检查相邻元素。

```python
def isStraight(nums):
    nums.sort()
    for i in range(4):
        if nums[i] == 0:
            continue
        if nums[i] != nums[i + 1] - 1:
            return False
    return True
```

**解析：** 首先将牌排序，然后检查是否存在连续的四个不同的牌。

### 20. 算法 - 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**解析：** 递归合并两个有序链表。

### 21. 算法 - 最长公共子序列

**题目：** 求最长公共子序列。

**答案：** 使用动态规划。

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：** 创建一个二维数组，记录子序列的长度。

### 22. 算法 - 二进制中1的个数

**题目：** 计算一个32位无符号整数的二进制表示中1的个数。

**答案：** 使用位操作。

```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

**解析：** 使用位与操作和右移操作计数。

### 23. 算法 - 合并K个排序链表

**题目：** 合并K个已经排序的链表。

**答案：** 使用优先队列。

```python
import heapq

def mergeKLists(lists):
    heap = []
    for l in lists:
        if l:
            heapq.heappush(heap, (l.val, l))
    dummy = ListNode(0)
    curr = dummy
    while heap:
        _, node = heapq.heappop(heap)
        curr.next = node
        curr = curr.next
        if node.next:
            heapq.heappush(heap, (node.next.val, node.next))
    return dummy.next
```

**解析：** 使用最小堆来保持当前最小的节点。

### 24. 算法 - 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组。

**答案：** 二分查找。

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 判断中间值是否在左侧排序区域，根据情况调整左右边界。

### 25. 算法 - 打家劫舍

**题目：** 你是一个小偷，面临一排房屋，决定从中选择若干房屋进行盗窃，但不能连续盗窃两间房屋。求盗窃所能获得的最大金额。

**答案：** 使用动态规划。

```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    a, b = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        c = max(b, a + nums[i])
        a, b = b, c
    return b
```

**解析：** 维护前两个房屋的最大金额，迭代更新。

### 26. 算法 - 设计循环队列

**题目：** 实现一个循环队列。

**答案：** 使用数组。

```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.queue = [0] * k
        self.head = self.tail = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % len(self.queue)
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.head = (self.head + 1) % len(self.queue)
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.head]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.tail - 1]

    def isEmpty(self) -> bool:
        return self.head == self.tail

    def isFull(self) -> bool:
        return (self.tail + 1) % len(self.queue) == self.head
```

**解析：** 使用数组实现循环队列，利用模运算处理循环边界。

### 27. 算法 - 计数排序

**题目：** 使用计数排序对一个整数数组进行排序。

**答案：** 使用额外的数组计数。

```python
def countSort(nums):
    if not nums:
        return []
    min_val, max_val = min(nums), max(nums)
    count = [0] * (max_val - min_val + 1)
    for num in nums:
        count[num - min_val] += 1
    idx = 0
    for i, c in enumerate(count):
        while c > 0:
            nums[idx] = i + min_val
            idx += 1
            c -= 1
    return nums
```

**解析：** 计算每个数的出现次数，然后依次放入原数组。

### 28. 算法 - 设计哈希映射

**题目：** 设计一个哈希映射（HashMap）的数据结构，支持插入、删除和查找操作。

**答案：** 使用哈希表。

```python
class MyHashMap:

    def __init__(self):
        self.size = 10000
        self.table = [[] for _ in range(self.size)]

    def put(self, key: int, value: int) -> None:
        idx = hash(key) % self.size
        bucket = self.table[idx]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))

    def get(self, key: int) -> int:
        idx = hash(key) % self.size
        bucket = self.table[idx]
        for k, v in bucket:
            if k == key:
                return v
        return -1

    def remove(self, key: int) -> None:
        idx = hash(key) % self.size
        bucket = self.table[idx]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                return
```

**解析：** 使用链地址法解决冲突。

### 29. 算法 - 设计前缀树

**题目：** 设计前缀树（Trie）的数据结构。

**答案：**

```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, word: str) -> None:
        node = self
        for char in word:
            idx = ord(char) - ord("a")
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end = True

    def search(self, word: str) -> bool:
        node = self
        for char in word:
            idx = ord(char) - ord("a")
            if node.children[idx] is None:
                return False
            node = node.children[idx]
        return node.is_end

    def startsWith(self, prefix: str) -> bool:
        node = self
        for char in prefix:
            idx = ord(char) - ord("a")
            if node.children[idx] is None:
                return False
            node = node.children[idx]
        return True
```

**解析：** Trie 用于存储字符串，支持插入、查找和前缀匹配。

### 30. 算法 - 设计优先队列

**题目：** 设计一个优先队列，支持插入、删除和获取最小元素。

**答案：** 使用小根堆。

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def insert(self, priority, item):
        heapq.heappush(self.heap, (priority, item))

    def delete(self, item):
        self.heap = [(p, i) for p, i in self.heap if i != item]
        heapq.heapify(self.heap)

    def get_min(self):
        if not self.heap:
            return None
        return self.heap[0][1]

    def min(self):
        if not self.heap:
            return None
        return self.heap[0][0]
```

**解析：** 使用 Python 的 heapq 库实现优先队列。

