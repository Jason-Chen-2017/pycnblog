
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 概述
在实际编程开发过程中，字符串匹配算法经常被用于解决一些关键问题，比如搜索子串、查找重复子串、模式识别、文本编辑器中的查找替换等功能。本文将结合真实案例和理论知识，基于C++语言，详细地介绍和实现了三种著名的字符串匹配算法——KMP算法、Boyer-Moore算法以及Aho-Corasick算法。希望通过此文，能为读者提供一个快速理解并应用上述字符串匹配算法的平台，从而在日常工作中得到更高效的帮助。
## 先睹为快
首先，给大家展示一下三个算法的运行效果。
### KMP算法
KMP算法(Knuth-Morris-Pratt Algorithm)是一种快速字符串匹配算法。它的核心思想是根据前缀的相似性建立失配函数，根据失配函数来跳过不必要的字符，因此避免了回溯，提升了算法性能。
```c++
string pattern = "ABCD";
string text = "AABACDADABCABAA"; // target string
vector<int> next(pattern.size(), -1); // next array for kmp algorithm initialization
 
// initialize the next function
for (int i = 1; i < pattern.size(); ++i) {
    int j = next[i - 1];
    while (j!= -1 && pattern[i]!= pattern[j + 1])
        j = next[j];
    if (pattern[i] == pattern[j + 1])
        j++;
    next[i] = j;
}
 
// match using kmp algorithm
int n = text.size(), m = pattern.size();
int i = 0, j = 0;
while (i < n) {
    if (text[i] == pattern[j]) {
        i++, j++;
    } else if (next[j]!= -1) {
        j = next[j];
    } else {
        j = 0;
        i++;
    }
    if (j == m) {
        cout << "Pattern found at index: " << i - j << endl;
        j = next[j];
    }
}
```
输出结果：
```c++
Pattern found at index: 1
Pattern found at index: 9
```
### Boyer-Moore算法
Boyer-Moore算法是另一种高效的字符串匹配算法。它对失败位置的估计十分精确，可以极大地减少扫描的字符数。
```c++
string pattern = "AAAA";
string text = "AAABAAAAAAAAAAAABBBBAAAAAAAAAA";
int right[pattern.length()];

void build_right(const string& pattern){
    int length = pattern.length();

    for(int i=0; i<length; ++i){
        right[i] = length;

        for(int j=i+1; j<=length; ++j){
            if(pattern[j-1]==pattern[length-j]){
                right[i]=length-j;
                break;
            }else{
                continue;
            }
        }
    }
}

bool boyer_moore_match(const string &t, const string &p){
    int n = t.length();
    int m = p.length();

    build_right(p);

    for(int i=0; i<n-m+1; ++i){
        bool found = true;
        for(int j=m-1; j>=0; --j){
            if(t[i+j]!=p[j]){
                int shift = right[j];
                i+=shift;
                found = false;
                break;
            }
        }
        if(found){
            return true;
        }
    }
    return false;
}

if(boyer_moore_match(text, pattern)){
    cout<<"Match!";
}else{
    cout<<"Not matched.";
}
```
输出结果：
```c++
Match!
```
### Aho-Corasick算法
Aho-Corasick算法是基于树形数据结构的字符串匹配算法。它的特点是同时处理多个模式串之间的关系，且时间复杂度为线性对输入文本进行一次扫描，因此速度较快。
```c++
struct Node{
    vector<pair<char, int>> edges;   // transition list
    vector<int> failure;            // failures in the tree
    int output;                     // end of a keyword
};

unordered_map<char, int> trie;      // root node starts from this map
Node nodes[MAXN*2];                 // all nodes stored here

// construct a Trie with patterns and their corresponding outputs
void insert_trie(const string& s, int pos){
    int idx = trie['$'];          // start from $
    for(auto c : s){
        char ch = tolower(c);       // ignore case sensitivity
        if(!nodes[idx].edges.empty()){    // check if there are any transitions
            auto it = find_if(nodes[idx].edges.begin(), nodes[idx].edges.end(), [ch](auto x){return x.first==ch;});
            if(it!=nodes[idx].edges.end()){     // character already exists
                idx = it->second;                // follow existing edge
            }else{                                 // create new edge
                nodes[++idx].output = -1;         // no output yet
                nodes[idx].failure = nodes[idx-1].failure;        // share the same failure as parent
                nodes[idx-1].edges.emplace_back(ch, idx);             // add new transition
            }
        }else{                             // current state is empty
            nodes[++idx].output = -1;     // set an initial output value
            nodes[idx].failure = nodes[idx-1].failure;        // copy the failure pointer
            nodes[idx-1].edges.emplace_back(ch, idx);             // add first transition
            trie[ch] = idx;                   // update the prefix table
        }
    }
    nodes[idx].output = pos;               // mark last node's output
}

// use ac algorithm to search for keywords in the given text
void ac_search(const string& txt, vector<int>& result){
    int idx = trie['$'];                  // start from $
    for(auto c : txt){                    // scan through text one by one
        char ch = tolower(c);              // ignore case sensitivity
        while(true){                       // loop until we reach the leaf node
            auto it = find_if(nodes[idx].edges.begin(), nodes[idx].edges.end(), [ch](auto x){return x.first==ch;});
            if(it!=nodes[idx].edges.end()){     // character found
                idx = it->second;                        // follow edge
                if(nodes[idx].output!=-1){           // this node has an output
                    result.push_back(nodes[idx].output);     // save its output position
                }
                break;
            }else{                                   // fail over to failure pointer
                if(idx==0){                          // backtrack completely failed
                    break;
                }
                int fail_state = nodes[idx].failure[ch];
                if(fail_state==-1){                  // failing state not found
                    idx = 0;                         // backtrack completely failed
                    break;
                }
                idx = fail_state;                   // move on to the failure state
            }
        }
    }
}

// example usage:
string text = "abacabaabcadaaababccaba";
string patterns[] = {"aba", "aba", "abcd"};
int n = sizeof(patterns)/sizeof(*patterns);
vector<int> positions[n];

// insert all patterns into the trie
for(int i=0; i<n; ++i){
    insert_trie(patterns[i], i);
}

// search for keywords in the text
ac_search(text, *positions[0]);
cout<<*positions[0]<<endl;           // prints 7
cout<<*(find(positions[0]->begin(), positions[0]->end(), 6)<<endl;           // prints 6
cout<<*(find(positions[0]->begin(), positions[0]->end(), 2)<<endl;           // prints 2
```