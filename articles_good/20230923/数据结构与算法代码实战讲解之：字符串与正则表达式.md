
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 概述

本文主要讲解了字符串匹配相关的一些基础知识，以及字符串匹配算法的原理及具体实现。文章主要面向对数据结构、算法、计算机底层原理有一定了解，有兴趣的同学可以收获颇丰。阅读本文不需要任何编程经验。

## 作者简介

郭兆基，四川大学电子科技学院，信息科学与技术学院研究生（电气工程），现任阿里巴巴集团高级技术专家，曾就职于百度、微软等互联网企业。擅长数据结构和算法的研究，尤其擅长字符串匹配相关算法的研究。2007年出版《数据结构与算法分析:C语言描述》一书，专著作者之一。

## 写作目的与读者对象

本文用于分享一些数据结构、算法方面的论文及技术文章，并通过阅读这些文章加深对数据结构、算法和编程的理解。文章面向初中及以上级别的计算机专业学生，也可作为自学或进阶参考用书。

## 文章主题与范围

文章将从以下几个方面进行阐述：

1. 字符串匹配算法概述
2. KMP字符串匹配算法
3. Aho-Corasick字符串匹配算法
4. BM算法
5. Trie树
6. AC自动机

除此之外，本文还会给出一些应用上的建议和注意事项，对于初学者比较友好。

## 文章结构及所用工具

文章使用Markdown语言撰写，编辑软件为MacDown。建议写作过程中配合练习题一起参与编写，可以帮助自己提升写作水平，并获得反馈，帮助改善文章质量。
# 2.字符串匹配算法概述

## 什么是字符串匹配？

**字符串匹配**：在一个主串(string)中查找一个模式串(pattern)，或者说判断一个字符串是否是另一个字符串的子序列。换句话说，就是寻找在主串中首次出现的某个模式串，或者说找到使模式串能够完全覆盖主串的最短的子串，而不用考虑顺序。

例如：

```
1. 字符串匹配算法可以用来检索和替换文本中的特定字符串。
2. DNA序列比对可以用于快速找到两条DNA序列间相似区域。
3. 在游戏中，搜索敌人的名字可以提高FPS。
```

## 如何解决字符串匹配问题？

字符串匹配算法广泛存在着，目前共有三种基本方法：

### 朴素字符串匹配法（Naive String Matching）

该算法是最简单的字符串匹配算法，其时间复杂度为O(n*m)，其中n为待匹配的主串长度，m为模式串长度。朴素字符串匹配法最多需要检查每一个可能的匹配位置，因此效率很低。

### 蛮力字符串匹配法（Brute Force String Matching）

该算法是朴素字符串匹配法的优化版本，其思想是枚举所有可能的起始位置，然后依次往后移动模式串，直到匹配失败为止，如果找到了一个匹配，就返回它的起始位置。这种方法的时间复杂度仍然为O(n*m)。

### 模式匹配算法（Pattern Matching Algorithms）

模式匹配算法是利用字符串之间的一些性质和关系来减少模式串与主串匹配的次数。其中最流行的是KMP算法，其时间复杂度为O(n+m)，但实际上KMP算法的空间复杂度为O(m)，所以当模式串长度较短时，KMP算法速度优于蛮力字符串匹配法。

在模式匹配算法中，还有其他一些算法比如Aho-Corasick算法、BM算法、Trie树、AC自动机等。

# 3.KMP算法

## 算法原理

KMP算法的全称是“Knuth-Morris-Pratt”算法。KMP算法是基于生成函数理论的一类字符串匹配算法，其利用了字符串之间的一些统计规律来预处理模式串，避免不必要的字符比较。

KMP算法的基本想法是：在模式串中根据某些特征找出所有“不动点”，即模式串中所有的下标i，使得模式串中第i个字符之前的最长的前缀和后缀的长度相等，这样就可以避免比较重复的字符。

假设有两个字符串S和P，它们满足如下条件：

1. S是P的子序列；
2. P的所有后缀都包含在S中；
3. 对任意的i∈[1,|P|],P[1..i]是P的某个前缀。

那么，如果要在S中找出P的一个匹配项，最坏情况下只能做Θ(|P|)次比较。

由此引申出的三个重要概念：

1. 边界（Border）：如果字符串S的长度为n，并且字符串S的第i个字符等于字符串P的第i个字符，那么称字符串S[1..i-1]是一个边界；否则，称字符串S[1..i-1]不是一个边界。

2. 不动点（Non-critical Point）：如果字符串S的第i个字符等于字符串P的第j个字符，且i<j，那么称整数i是一个非重心字符。

3. “后缀函数”（Suffix Function）：定义f(i)为最小的非重心字符j>i,使得S[j…|S|]的前缀和S[i…|S|]的后缀相等。

KMP算法首先建立边界数组b，其中b[i]表示字符串S[1...i-1]的边界数量。在创建这个数组的时候，注意要初始化b[0]=-1，因为字符串的第一个字符没有边界，因此边界计数值应该初始化为-1。

然后，KMP算法根据上述概念，计算后缀函数f(i),使得它表示每个字符串的“最长递增子序列”。如果不存在这样的非重心字符，那么就把f(i)=0。

接着，KMP算法遍历主串S，对于当前的主串指针i，如果模式串指针j=0，说明已经匹配成功，返回i-j的下标；否则，如果S[i]!=P[j]，则尝试从模式串的f(j)处重新匹配，如果找不到这样的匹配项，说明模式串和主串之间无关，直接跳过该字符，即i=i+1;如果找到这样的匹配项，说明这可能是一个潜在的匹配项，需要继续检查，即j=f(j)。如果S[i]==P[j]，则说明找到了一个匹配，继续查找下一个匹配项。

KMP算法的平均时间复杂度为O(m+n)，其中m为模式串长度，n为主串长度。

## 算法实现

C++语言实现的代码如下：

```cpp
#include <iostream>
using namespace std;

int main() {
    string s = "abcabdabcab"; //主串
    string p = "bcabd";      //模式串

    int n = s.length();     //主串长度
    int m = p.length();     //模式串长度

    //边界数组
    vector<int> border(m);
    border[0] = -1;         //初始化边界计数器
    for (int i = 1, j = -1; i < m; ++i) {
        while (j > -1 && p[i]!= p[j + 1])
            j = border[j];        //更新边界
        if (p[i] == p[j + 1])    //新边界
            ++j;
        border[i] = j;           //保存边界
    }

    //后缀函数
    vector<int> suffix(m);
    for (int i = 0, j = -1; i < m; ) {
        while (j > -1 && p[i]!= p[j + 1])
            j = border[j];              //更新边界
        if (++i <= m)                  //新边界
            suffix[i] = j = max(border[j], suffix[i]);   //更新后缀函数
    }

    //字符串匹配
    int pos = -1, cnt = 0;                   //初始化变量
    for (int i = 0, j = 0; i < n;) {          //主串指针
        while (j >= 0 && s[i]!= p[j])       //模式串指针回溯
            j = suffix[j];                 //前移模式串指针
        if (s[i] == p[j])                    //匹配成功
            ++cnt;                           //计数器累加
            if (j == m - 1) {                //匹配结束
                cout << "Found match at position "
                     << i - m + 1 << endl;   //输出结果
                j = suffix[j];             //前移模式串指针
            } else
                ++i, --j;                     //前进主串指针和模式串指针
        else                                //字符不匹配
            j = suffix[j];                     //前移模式串指针
    }
    return 0;
}
```

## 时间复杂度分析

KMP算法的时间复杂度取决于边界数组的计算，计算复杂度为O(m^2)，但由于后缀函数的存在，当m<=n时，其计算复杂度大约为O(m)，因此KMP算法的平均时间复杂度为O(m+n)。

## 空间复杂度分析

KMP算法的空间复杂度为O(m)，主要消耗在边界数组和后缀函数上。

## 应用场景

KMP算法通常被用于文本搜索、数据压缩、模式识别领域，如正则表达式匹配、字典匹配、词频统计、字符串搜索等。

# 4.Aho-Corasick算法

## 算法原理

Aho-Corasick算法是一种多模匹配算法，它通过构造“fail指针”表来保证效率，使得字符串匹配算法能够处理大文件。

假设有一个输入字符串t，希望在其上做多模匹配，也就是对多个模式串进行匹配，每个模式串均为一个小字符串，其特点是“不能回头”，即已匹配的文本中的模式串的最后一位不能再匹配到另一个模式串中。为了提高效率，一般要求模式串都是单词而不是短语。

Aho-Corasick算法的基本想法是：维护一个状态转移图，使得对于模式串集合中每一个模式串Pi，其fail指针指向某个模式串Pj，使得Pj中所有后缀均能够接受Pi作为前缀，这里Pi的长度大于等于Pj，且具有最大的不重叠前缀。因此，如果我们能构造这样的状态转移图，便可以方便地处理多模匹配问题。

首先，构建一个根节点，并向其每个儿子添加一条边（空字符），表示其本身是自己的父亲。

然后，构造每个模式串的fail指针表，使得状态转移图能够正确构造，过程如下：

- 初始化每个结点的子结点。
- 从根结点出发，按照模式串的后缀顺序，为每个结点找到最大的能匹配其前缀的前驱结点。
- 每个结点维护一个值f，代表从它到根结点的最大的相同字符的距离。

最后，通过对模式串进行预处理，可以快速确定每个模式串的fail指针。

## 算法实现

C++语言实现的代码如下：

```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int N = 1e5 + 5;
struct Node {
    Node *next[26];     // 存储子结点
    int fail, len;      // fail指针和模式串长度
    char c;            // 当前字符
    bool flag;          // 是否终结符
    Node():fail(-1),len(0),flag(false) {}
};

// 根据模式串构造子树
void insert_str(Node *root, const string &s) {
    Node *p = root;
    for (int i = 0; i < s.size(); ++i) {
        int k = s[i] - 'a';
        if (!p->next[k])
            p->next[k] = new Node;
        p = p->next[k];
        p->c = s[i];
        ++p->len;
    }
    p->flag = true;     // 标记为终止符
}

// 构造fail指针表
void build_fail(Node *root) {
    queue<Node *> q;
    for (int i = 0; i < 26; ++i)
        if (root->next[i]) {
            root->next[i]->fail = root;
            q.push(root->next[i]);
        }
    while (!q.empty()) {
        Node *u = q.front();
        q.pop();
        for (int i = 0; i < 26; ++i) {
            Node *v = u->fail;
            while (v &&!v->next[i])
                v = v->fail;
            if (!v)
                continue;
            Node *w = v->next[i];
            w->len += u->len;
            if (w->len < u->len || w->len == u->len && w->flag)
                w->fail = u;
            else
                break;
            q.push(w);
        }
    }
}

// Aho-Corasick算法
vector<int> ac_search(const string& t, Node* root) {
    vector<int> res;
    int n = t.size(), j = 0;
    Node *p = root;
    while (j < n) {
        int k = t[j++] - 'a';
        while(!p->next[k]) 
            p = p->fail;
        if (!p->next[k]->flag)
            continue;
        int last = j - p->next[k]->len;
        while (last <= j && t.substr(last, j - last).find(p->next[k]->c)!= string::npos)
            last = t.find(p->next[k]->c, last) + p->next[k]->len;
        if (last > j) {
            res.push_back(j - 1);
            p = root;
        }
        j = last;
    }
    return res;
}

int main() {
    Node *root = new Node;
    string s[] = {"she", "he", "his"};
    for (auto it : s) 
        insert_str(root, it);
    build_fail(root);
    string t = "ushersheeshisher";
    auto ret = ac_search(t, root);
    for (auto it : ret)
        cout << it << " ";
    cout << endl;
    return 0;
}
```

## 时间复杂度分析

Aho-Corasick算法的时间复杂度取决于构造fail指针的过程，其计算复杂度为O(nm), 其中n为字符串个数，m为最长字符串长度。由于该过程只需要进行一次，所以实际运行时间可能会更快一些。

## 空间复杂度分析

Aho-Corasick算法的空间复杂度取决于状态转移图的大小，最坏情况下可能需要建立一个状态转移图，大小为O(nm)。但事实上，常见的字符串仅占字符串空间的一小部分，因此实际空间需求很小。

## 应用场景

Aho-Corasick算法可以在线文档查询、压缩文件索引、模式识别等方面有广泛应用。

# 5.BM算法

## 算法原理

BM算法是一种字符串匹配算法，与KMP算法类似，也是利用了字符串的一些统计规律。与KMP不同的是，BM算法针对的是整个模式串进行处理，其时间复杂度为O(m+n)，其中m为模式串长度，n为主串长度。

BM算法与KMP算法的区别在于：KMP算法依赖于模式串的前缀信息，计算出了后缀信息，而BM算法则需要先进行局部匹配才能判断是否成功。

该算法使用了一种被称为“bad character”的启发式规则。当模式串Pi遇到主串Si时，如果 Si[j]≠Pi[i]，则认为Pi[i]是不匹配的，而且Pi[i]的下一步将会跳到Si[j+1]的地方去，并不停地尝试匹配，直到遇到另一个匹配的字符时才重新从Pi[i]开始匹配。因此，该算法非常灵活。

同时，该算法使用了“好后缀”的概念，该概念是指从某一字符位置i向右匹配，使得模式串与主串匹配，并不影响后续的匹配。因此，它可以在后续的局部匹配中快速跳过一定的字符，从而提高效率。

BM算法利用了模式串Pi中“不匹配”信息和“好后缀”信息，因此可以达到O(m+n)的时间复杂度。

## 算法实现

C++语言实现的代码如下：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
char a[MAXN], b[MAXN];
int next[MAXN][256];
int len[MAXN], base[MAXN];

void getNext(char pattern[]){
  memset(next, 0, sizeof(next));
  int L = strlen(pattern);

  len[0] = -1;
  for(int i=0; i<L; i++){
    len[i+1] = len[i]+1;
    base[i+1] = base[i] + 1;
  }
  for(int i=0; i<L-1; i++){
    int j = next[base[i]][pattern[i]];
    while(j!=-1 && j<len[i]-1){
      if(pattern[j+1]==pattern[i]){
        j++;
      }else{
        break;
      }
    }
    next[base[i]][pattern[i]] = j;
  }
}

void bmSearch(){
  getNext(b);
  int n = strlen(a), m = strlen(b), i = 0, j = 0;
  
  while(i<n&&j<m){
    if(j==-1||a[i]==b[j]){
      i++;
      j++;
    }else{
      j+=max(1, j-next[0][a[i]]);
    }
  }
  if(j>=m){
    printf("%d\n", i-m);
  }else{
    printf("-1\n");
  }
}

int main(){
  scanf("%s %s", a, b);
  bmSearch();
  return 0;
}
```

## 时间复杂度分析

BM算法的时间复杂度为O(n+m)，其中n为主串长度，m为模式串长度。

## 空间复杂度分析

BM算法的空间复杂度为O(n+m)，主要消耗在next数组上。

## 应用场景

BM算法通常用于模式识别，如DNA序列比对、数据压缩等。