                 

### 京东2025社招编程面试题精华总结

#### 面试题库与算法编程题库

本篇博客将为您精选京东2025社招编程面试题精华总结，涵盖数据结构与算法、编程基础、系统设计等领域的典型问题。我们将以详尽的答案解析和丰富的源代码实例，帮助您更好地理解和应对面试挑战。

#### 面试题解析

##### 1. 如何判断一个链表是否为回文结构？

**题目描述：** 给定一个链表的头节点 head，请判断该链表是否为回文结构。

**答案解析：**

1. **快慢指针法**：使用两个指针，一个快指针 fast 和一个慢指针 slow，分别从链表的头节点开始遍历。当快指针到达链表末尾时，慢指针位于链表的中点。
2. **反转链表后半部分**：将链表后半部分反转，方法同上一题。
3. **比较前后半部分链表节点值**：从链表的头节点和反转后的后半部分链表的头节点开始遍历，依次比较节点值，若全部相等，则链表为回文结构。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def is_palindrome(head: ListNode) -> bool:
    # 快慢指针法
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    # 反转链表后半部分
    prev = None
    while slow:
        next_node = slow.next
        slow.next = prev
        prev = slow
        slow = next_node
    
    # 比较前后半部分链表节点值
    left, right = head, prev
    while left and right:
        if left.val != right.val:
            return False
        left = left.next
        right = right.next
    
    return True
```

##### 2. 如何在一个未排序的数组中找到第 k 个最大的元素？

**题目描述：** 给定一个未排序的数组 nums 和一个整数 k，请找出数组中第 k 个最大的元素。

**答案解析：**

1. **快速选择算法**：基于快速排序的思想，选择一个基准元素，将数组划分为两部分，左侧部分都比基准元素小，右侧部分都比基准元素大。根据 k 的位置返回结果。
2. **堆排序算法**：使用大顶堆实现，将数组中的元素依次插入堆中，构建大顶堆。当堆的大小大于 k 时，弹出堆顶元素。最后堆中的元素个数为 k，堆顶元素即为第 k 个最大的元素。

**代码示例：**

```python
import heapq

def find_kth_largest(nums: List[int], k: int) -> int:
    # 快速选择算法
    def partition(left, right):
        pivot = nums[right]
        i = left
        for j in range(left, right):
            if nums[j] > pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[right] = nums[right], nums[i]
        return i

    left, right = 0, len(nums) - 1
    while True:
        p = partition(left, right)
        if p == k - 1:
            return nums[p]
        elif p > k - 1:
            right = p - 1
        else:
            left = p + 1

    # 堆排序算法
    def build_max_heap(nums):
        n = len(nums)
        for i in range(n // 2 - 1, -1, -1):
            heapify(nums, i, n)

    def heapify(nums, i, n):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        if left < n and nums[left] > nums[largest]:
            largest = left
        if right < n and nums[right] > nums[largest]:
            largest = right
        if largest != i:
            nums[i], nums[largest] = nums[largest], nums[i]
            heapify(nums, largest, n)

    build_max_heap(nums)
    for _ in range(k - 1):
        heapq.heappop(nums)
    return nums[0]
```

##### 3. 如何实现一个最小生成树算法？

**题目描述：** 给定一个无向图，请使用一种最小生成树算法实现并返回该无向图的最小生成树。

**答案解析：**

1. **Prim 算法**：从图中的一个顶点开始，逐步增加新顶点和新边，直到所有顶点都被包含在最小生成树中。
2. **Kruskal 算法**：将所有边按照权值从小到大排序，依次选择边加入最小生成树，如果该边连接的两个顶点已经在最小生成树中，则不加入。

**代码示例：**

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a, b):
        root_a = self.find(a)
        root_b = self.find(b)
        if root_a != root_b:
            if self.size[root_a] > self.size[root_b]:
                self.parent[root_b] = root_a
                self.size[root_a] += self.size[root_b]
            else:
                self.parent[root_a] = root_b
                self.size[root_b] += self.size[root_a]
            return True
        return False


def prim(n, edges):
    # Prim 算法
    uf = UnionFind(n)
    mst = []
    for i in range(1, n):
        min_edge = None
        for j in range(len(edges)):
            u, v, w = edges[j]
            if uf.find(u) != uf.find(v) and (min_edge is None or w < min_edge[2]):
                min_edge = (u, v, w)
        if min_edge:
            uf.union(min_edge[0], min_edge[1])
            mst.append(min_edge)
            edges.remove(min_edge)
    return mst


def kruskal(n, edges):
    # Kruskal 算法
    edges = sorted(edges, key=lambda x: x[2])
    uf = UnionFind(n)
    mst = []
    for u, v, w in edges:
        if uf.union(u, v):
            mst.append((u, v, w))
    return mst
```

#### 总结

以上是京东2025社招编程面试题精华总结的一部分，涵盖了数据结构与算法、编程基础和系统设计等领域的高频问题。通过详尽的答案解析和丰富的源代码实例，希望您能够更好地掌握这些知识点，为面试做好准备。接下来，我们将继续为大家带来更多精彩内容，敬请期待！

