                 

### 小米2025届社招算法工程师面试真题解密

#### 面试题1：排序算法

**题目：** 实现一个快速排序算法，并分析其时间复杂度和空间复杂度。

**答案：**

快速排序算法的基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**代码示例：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [10, 7, 8, 9, 1, 5]
print("排序前：", arr)
sorted_arr = quick_sort(arr)
print("排序后：", sorted_arr)
```

**解析：**

时间复杂度：最坏情况下为 \(O(n^2)\)，平均情况下为 \(O(n\log n)\)。

空间复杂度：最坏情况下为 \(O(n)\)，平均情况下为 \(O(\log n)\)。

#### 面试题2：二分查找

**题目：** 实现一个二分查找算法，并分析其时间复杂度。

**答案：**

二分查找算法的基本思想是在有序数组中，通过不断比较中间元素和目标元素的大小关系，将查找范围逐步缩小，直到找到目标元素或确定目标元素不存在。

**代码示例：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
result = binary_search(arr, target)
if result != -1:
    print("元素在数组中的索引为：", result)
else:
    print("元素不在数组中。")
```

**解析：**

时间复杂度：\(O(\log n)\)。

#### 面试题3：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

最长公共子序列（Longest Common Subsequence，LCS）是两个序列中公共的最长子序列。

**代码示例：**

```python
def lcs(X, Y):
    m = len(X)
    n = len(Y)
    L = [[0] * (n + 1) for i in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])
    return L[m][n]

X = "ABCBDAB"
Y = "BDCAB"
print("最长公共子序列的长度为：", lcs(X, Y))
```

**解析：**

时间复杂度：\(O(mn)\)。

空间复杂度：\(O(mn)\)。

#### 面试题4：最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**答案：**

最长公共子串（Longest Common Substring）是两个序列中公共的最长子串。

**代码示例：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    longest = 0
    longest_end = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > longest:
                    longest = dp[i][j]
                    longest_end = i
            else:
                dp[i][j] = 0
    return s1[longest_end - longest: longest_end]

s1 = "abcdefg"
s2 = "zabcxy"
print("最长公共子串为：", longest_common_substring(s1, s2))
```

**解析：**

时间复杂度：\(O(mn)\)。

空间复杂度：\(O(mn)\)。

#### 面试题5：动态规划求最大子序和

**题目：** 使用动态规划求解给定数组中的最大子序和。

**答案：**

动态规划解决最大子序和问题的基本思路是：设 \(f(i)\) 为以第 \(i\) 个元素为结尾的最大子序和，那么 \(f(i) = \max(f(i-1) + arr[i], arr[i])\)。

**代码示例：**

```python
def max_subsequence_sum(arr):
    max_sum = float('-inf')
    current_sum = 0
    for num in arr:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)
    return max_sum

arr = [1, -2, 3, 4, -5, 8]
print("最大子序和为：", max_subsequence_sum(arr))
```

**解析：**

时间复杂度：\(O(n)\)。

空间复杂度：\(O(1)\)。

#### 面试题6：图遍历

**题目：** 实现图的广度优先搜索（BFS）和深度优先搜索（DFS）。

**答案：**

广度优先搜索（BFS）的基本思路是：从初始节点开始，逐层遍历图中的所有节点，直到找到目标节点或遍历完整张图。

深度优先搜索（DFS）的基本思路是：从初始节点开始，尽可能深地搜索图的分支。

**代码示例：**

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node)
            visited.add(node)
            queue.extend(graph[node])
    return visited

def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    print(start)
    visited.add(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
print("BFS 遍历结果：", bfs(graph, 'A'))
print("DFS 遍历结果：", dfs(graph, 'A'))
```

**解析：**

时间复杂度：\(O(V+E)\)，其中 \(V\) 是节点数，\(E\) 是边数。

空间复杂度：\(O(V)\)。

#### 面试题7：二叉树遍历

**题目：** 实现二叉树的先序遍历、中序遍历和后序遍历。

**答案：**

二叉树的遍历分为先序遍历、中序遍历和后序遍历。

先序遍历的顺序是：根节点 -> 左子树 -> 右子树。

中序遍历的顺序是：左子树 -> 根节点 -> 右子树。

后序遍历的顺序是：左子树 -> 右子树 -> 根节点。

**代码示例：**

```python
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.val = value
        self.left = left
        self.right = right

def preorderTraversal(root):
    if root:
        print(root.val)
        preorderTraversal(root.left)
        preorderTraversal(root.right)

def inorderTraversal(root):
    if root:
        inorderTraversal(root.left)
        print(root.val)
        inorderTraversal(root.right)

def postorderTraversal(root):
    if root:
        postorderTraversal(root.left)
        postorderTraversal(root.right)
        print(root.val)

# 创建二叉树
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("先序遍历：")
preorderTraversal(root)
print("\n中序遍历：")
inorderTraversal(root)
print("\n后序遍历：")
postorderTraversal(root)
```

**解析：**

时间复杂度：\(O(n)\)，其中 \(n\) 是二叉树的节点数。

空间复杂度：\(O(h)\)，其中 \(h\) 是二叉树的高度。

#### 面试题8：链表问题

**题目：** 实现单链表的插入、删除、查找和反转功能。

**答案：**

单链表是一种线性数据结构，每个节点包含一个数据和指向下一个节点的指针。

**代码示例：**

```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def insert(head, value):
    new_node = ListNode(value)
    if not head:
        return new_node
    current = head
    while current.next:
        current = current.next
    current.next = new_node
    return head

def delete(head, value):
    if not head:
        return None
    if head.value == value:
        return head.next
    current = head
    while current.next:
        if current.next.value == value:
            current.next = current.next.next
            return head
        current = current.next
    return head

def find(head, value):
    current = head
    while current:
        if current.value == value:
            return True
        current = current.next
    return False

def reverse(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev

# 创建单链表
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)

print("插入节点 5：")
head = insert(head, 5)
print("删除节点 3：")
head = delete(head, 3)
print("查找节点 2：")
print(find(head, 2))
print("反转链表：")
head = reverse(head)
```

**解析：**

时间复杂度：插入、删除、查找和反转的时间复杂度均为 \(O(n)\)，其中 \(n\) 是链表的长度。

空间复杂度：插入、删除和查找的空间复杂度均为 \(O(1)\)，反转的空间复杂度为 \(O(n)\)。

#### 面试题9：哈希表

**题目：** 实现一个哈希表，支持添加、删除和查找操作。

**答案：**

哈希表（Hash Table）是一种用于快速查找和插入数据的数据结构。

**代码示例：**

```python
class HashTable:
    def __init__(self, size=100):
        self.size = size
        self.table = [None] * self.size

    def _hash(self, key):
        return key % self.size

    def put(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    self.table[index][i] = (key, value)
                    return
            self.table[index].append((key, value))

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

    def delete(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return

# 创建哈希表
hash_table = HashTable()
hash_table.put("apple", 1)
hash_table.put("banana", 2)
hash_table.put("orange", 3)

print("查找 apple：", hash_table.get("apple"))
print("删除 banana：", hash_table.delete("banana"))
print("查找 banana：", hash_table.get("banana"))
```

**解析：**

时间复杂度：添加、删除和查找的时间复杂度均为 \(O(1)\)，其中 \(n\) 是哈希表的大小。

空间复杂度：\(O(n)\)，其中 \(n\) 是哈希表的大小。

#### 面试题10：堆排序

**题目：** 实现一个堆排序算法。

**答案：**

堆排序算法的基本思想是：将数组构造成一个大顶堆，然后交换堆顶元素和数组最后一个元素，再将剩余的元素重新调整成大顶堆，重复此过程直到堆的长度为 1。

**代码示例：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("排序后的数组：", arr)
```

**解析：**

时间复杂度：\(O(n\log n)\)。

空间复杂度：\(O(1)\)。

#### 面试题11：查找算法

**题目：** 实现二分查找和二分查找递归。

**答案：**

二分查找算法的基本思想是在有序数组中，通过不断比较中间元素和目标元素的大小关系，将查找范围逐步缩小，直到找到目标元素或确定目标元素不存在。

**代码示例：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

def binary_search_recursive(arr, target, low, high):
    if low > high:
        return -1
    mid = (low + high) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, high)
    else:
        return binary_search_recursive(arr, target, low, mid - 1)

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
print("使用非递归的二分查找：", binary_search(arr, target))
print("使用递归的二分查找：", binary_search_recursive(arr, target, 0, len(arr) - 1))
```

**解析：**

时间复杂度：\(O(\log n)\)。

空间复杂度：非递归版本为 \(O(1)\)，递归版本为 \(O(\log n)\)。

#### 面试题12：快速排序

**题目：** 实现快速排序算法。

**答案：**

快速排序算法的基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**代码示例：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [10, 7, 8, 9, 1, 5]
print("排序前：", arr)
sorted_arr = quick_sort(arr)
print("排序后：", sorted_arr)
```

**解析：**

时间复杂度：最坏情况下为 \(O(n^2)\)，平均情况下为 \(O(n\log n)\)。

空间复杂度：最坏情况下为 \(O(n)\)，平均情况下为 \(O(\log n)\)。

#### 面试题13：最长递增子序列

**题目：** 给定一个无序数组，找出最长递增子序列的长度。

**答案：**

最长递增子序列（LIS）是指一个序列中，最长且递增的子序列。

**代码示例：**

```python
def longest_increasing_subsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

nums = [10, 9, 2, 5, 3, 7, 101, 18]
print("最长递增子序列的长度为：", longest_increasing_subsequence(nums))
```

**解析：**

时间复杂度：\(O(n^2)\)。

空间复杂度：\(O(n)\)。

#### 面试题14：最小覆盖子串

**题目：** 给定一个字符串 \(S\) 和一个字符集合 \(T\)，找到 \(S\) 中包含 \(T\) 所有字符的最小子串。

**答案：**

我们可以使用滑动窗口的方法来解决这道题。

**代码示例：**

```python
from collections import Counter

def min_window(s, t):
    if not s or not t:
        return ""

    need = Counter(t)
    window = Counter()
    left = right = 0
    valid = 0
    start = end = 0
    need_len = len(need)
    t_len = len(t)

    while right < len(s):
        c = s[right]
        right += 1
        window[c] += 1
        if window[c] == need[c]:
            valid += 1

        while valid == need_len:
            if right - left < end - start:
                start, end = left, right

            d = s[left]
            left += 1
            window[d] -= 1
            if window[d] < need[d]:
                valid -= 1

    return "" if end == 0 else s[start:end]

s = "ADOBECODEBANC"
t = "ABC"
print(min_window(s, t))
```

**解析：**

时间复杂度：\(O(n)\)，其中 \(n\) 是字符串 \(s\) 的长度。

空间复杂度：\(O(m)\)，其中 \(m\) 是字符串 \(t\) 中不同字符的数量。

#### 面试题15：股票买卖

**题目：** 给定一个整数数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**答案：**

我们可以使用动态规划的方法来解决这个问题。

**代码示例：**

```python
def max_profit(prices):
    n = len(prices)
    dp = [[0] * 2 for _ in range(n)]
    for i in range(1, n):
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = max(dp[i - 1][1], -prices[i])
    return dp[-1][0]

prices = [3, 3, 5, 0, 0, 3, 1, 4]
print("最大利润为：", max_profit(prices))
```

**解析：**

时间复杂度：\(O(n)\)。

空间复杂度：\(O(n)\)。

#### 面试题16：字符串匹配

**题目：** 实现字符串的匹配算法。

**答案：**

我们可以使用暴力匹配算法和 KMP 算法来解决字符串匹配的问题。

**暴力匹配算法：**

暴力匹配算法的基本思想是从主串的每一个位置开始，依次与模式串进行比较，一旦找到匹配点就返回，否则返回-1。

**代码示例：**

```python
def brute_force_search(s, p):
    m, n = len(s), len(p)
    for i in range(m - n + 1):
        j = 0
        while j < n:
            if s[i + j] != p[j]:
                break
            if j == n - 1:
                return i
        return -1
    return -1

s = "ABCDABD"
p = "BD"
print("使用暴力匹配算法：", brute_force_search(s, p))
```

**KMP 算法：**

KMP 算法（Knuth-Morris-Pratt Algorithm）是一种高效字符串匹配算法。

**代码示例：**

```python
def kmp_search(s, p):
    def build_next(p):
        n = len(p)
        next = [0] * n
        j = 0
        i = 1
        while i < n:
            if p[i] == p[j]:
                j += 1
                next[i] = j
                i += 1
            elif j > 0:
                j = next[j - 1]
            else:
                next[i] = 0
                i += 1
        return next

    next = build_next(p)
    m, n = len(s), len(p)
    j = 0
    for i in range(m):
        while j > 0 and s[i] != p[j]:
            j = next[j - 1]
        if s[i] == p[j]:
            j += 1
        if j == n:
            return i - j + 1
    return -1

s = "ABCDABD"
p = "BD"
print("使用 KMP 算法：", kmp_search(s, p))
```

**解析：**

时间复杂度：暴力匹配算法为 \(O(mn)\)，KMP 算法为 \(O(m + n)\)。

空间复杂度：暴力匹配算法为 \(O(1)\)，KMP 算法为 \(O(n)\)。

#### 面试题17：最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

我们可以使用垂直扫描的方法来解决这个问题。

**代码示例：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix

strs = ["flower", "flow", "flight"]
print("最长公共前缀为：", longest_common_prefix(strs))
```

**解析：**

时间复杂度：\(O(NM)\)，其中 \(N\) 是字符串数组中的字符串数量，\(M\) 是最长公共前缀的长度。

空间复杂度：\(O(1)\)。

#### 面试题18：最长回文子串

**题目：** 给定一个字符串 \(s\) ，找到其最长的回文子串。你可以假设 \(s\) 的最大长度为 \(1000\)。

**答案：**

我们可以使用动态规划的方法来解决这个问题。

**代码示例：**

```python
def longest_palindromic_substring(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_len = 1
    for i in range(n):
        dp[i][i] = True
        if i < n - 1 and s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2
    for i in range(n - 3, -1, -1):
        for j in range(i + 2, n):
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                if j - i + 1 > max_len:
                    start = i
                    max_len = j - i + 1
    return s[start:start + max_len]

s = "babad"
print("最长回文子串为：", longest_palindromic_substring(s))
```

**解析：**

时间复杂度：\(O(N^2)\)。

空间复杂度：\(O(N^2)\)。

#### 面试题19：三数和

**题目：** 给定一个包含 \(n\) 个整数的数组 \(nums\)，判断 \(nums\) 中是否存在三个元素 \(a，b，c\) ，使得 \(a + b + c = 0\) ？找出所有满足条件且不重复的三元组。

**答案：**

我们可以使用排序和双指针的方法来解决这个问题。

**代码示例：**

```python
def three_sum(nums):
    nums.sort()
    result = []
    n = len(nums)
    for i in range(n - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, n - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result

nums = [-1, 0, 1, 2, -1, -4]
print("三数和为零的三元组为：", three_sum(nums))
```

**解析：**

时间复杂度：\(O(N^2)\)。

空间复杂度：\(O(1)\)。

#### 面试题20：最小栈

**题目：** 设计一个支持 push，pop，top 操作的栈，同时能查询栈的最小元素。

**答案：**

我们可以使用一个辅助栈来记录每个位置上的最小元素。

**代码示例：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**解析：**

时间复杂度：\(O(1)\)。

空间复杂度：\(O(N)\)，其中 \(N\) 是栈的大小。

#### 面试题21：两数之和

**题目：** 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

我们可以使用哈希表来解决这个问题。

**代码示例：**

```python
def two_sum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

nums = [2, 7, 11, 15]
target = 9
print("两数之和的索引为：", two_sum(nums, target))
```

**解析：**

时间复杂度：\(O(N)\)。

空间复杂度：\(O(N)\)。

#### 面试题22：有效的括号

**题目：** 给定一个字符串 s ，判断字符串是否只由括号组成，并返回字符串的有效括号对的数量。

**答案：**

我们可以使用栈来解决这个问题。

**代码示例：**

```python
def valid_parentheses(s):
    stack = []
    count = 0
    for char in s:
        if char == '(' or char == ')':
            if len(stack) == 0:
                stack.append(char)
            elif char == ')' and stack[-1] == '(':
                stack.pop()
                count += 1
            else:
                stack.append(char)
    return count

s = "(()())()"
print("有效括号对的数量为：", valid_parentheses(s))
```

**解析：**

时间复杂度：\(O(N)\)。

空间复杂度：\(O(N)\)。

#### 面试题23：爬楼梯

**题目：** 假设你正在爬楼梯。需要 \(n\) 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**答案：**

我们可以使用动态规划的方法来解决这个问题。

**代码示例：**

```python
def climb_stairs(n):
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

n = 3
print("爬楼梯的不同方法数为：", climb_stairs(n))
```

**解析：**

时间复杂度：\(O(N)\)。

空间复杂度：\(O(N)\)。

#### 面试题24：合并区间

**题目：** 给一个无序的区间列表，合并所有重叠的区间。

**答案：**

我们可以先对区间进行排序，然后合并重叠的区间。

**代码示例：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        last_end = result[-1][1]
        if interval[0] <= last_end:
            result[-1][1] = max(last_end, interval[1])
        else:
            result.append(interval)
    return result

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print("合并后的区间为：", merge(intervals))
```

**解析：**

时间复杂度：\(O(N\log N)\)，其中 \(N\) 是区间的数量。

空间复杂度：\(O(N)\)。

#### 面试题25：打家劫舍

**题目：** 你是一个专业的小偷，计划偷窃一整条街道上的房屋。每间房屋只能偷窃一次，房屋之间相邻，且相邻的房屋装有相互连通的防盗系统。问你最多能偷窃多少金额？

**答案：**

我们可以使用动态规划的方法来解决这个问题。

**代码示例：**

```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]

nums = [2, 7, 9, 3, 1]
print("最多能偷窃的金额为：", rob(nums))
```

**解析：**

时间复杂度：\(O(N)\)。

空间复杂度：\(O(N)\)。

#### 面试题26：合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

我们可以使用迭代的方法来解决这个问题。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = merge_two_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**解析：**

时间复杂度：\(O(N+M)\)，其中 \(N\) 和 \(M\) 分别是两个链表的长度。

空间复杂度：\(O(1)\)。

#### 面试题27：旋转数组

**题目：** 给定一个整数数组 \([0,1,\ldots,n-1]\) 和一个未排序的数组 \([a_1,a_2,\ldots,a_n]\)。请问，原数组如何旋转得到目标数组？

**答案：**

我们可以使用哈希表来解决这个问题。

**代码示例：**

```python
def find RotationIndex(nums):
    nums.sort()
    for i, num in enumerate(nums):
        if num == 0:
            return i
    return -1

nums = [4, 3, 2, 1, 0]
print("旋转索引为：", find_RotationIndex(nums))
```

**解析：**

时间复杂度：\(O(N\log N)\)。

空间复杂度：\(O(N)\)。

#### 面试题28：判断子序列

**题目：** 给定字符串 \([s_1,s_2,\ldots,s_m]\) 和 \([t_1,t_2,\ldots,t_n]\)，请编写一个函数，判断 \(t\) 是否为 \(s\) 的子序列。

**答案：**

我们可以使用双指针的方法来解决这个问题。

**代码示例：**

```python
def isSubsequence(s, t):
    si, ti = 0, 0
    while si < len(s) and ti < len(t):
        if s[si] == t[ti]:
            si += 1
        ti += 1
    return si == len(s)

s = "abc"
t = "ahbgdc"
print("t 是否为 s 的子序列：", isSubsequence(s, t))
```

**解析：**

时间复杂度：\(O(M+N)\)，其中 \(M\) 和 \(N\) 分别是字符串 \(s\) 和 \(t\) 的长度。

空间复杂度：\(O(1)\)。

#### 面试题29：逆波兰表达式求值

**题目：** 根据逆波兰表达式，求出其对应的值。

有效的运算符包括 \(+, -, \*, /\)。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**答案：**

我们可以使用栈来解决这个问题。

**代码示例：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            op2 = stack.pop()
            op1 = stack.pop()
            if token == "+":
                stack.append(op1 + op2)
            elif token == "-":
                stack.append(op1 - op2)
            elif token == "*":
                stack.append(op1 * op2)
            elif token == "/":
                stack.append(int(op1 / op2))
        else:
            stack.append(int(token))
    return stack.pop()

tokens = ["2", "1", "+", "3", "*"]
print("逆波兰表达式的值为：", evalRPN(tokens))
```

**解析：**

时间复杂度：\(O(N)\)，其中 \(N\) 是逆波兰表达式的长度。

空间复杂度：\(O(N)\)。

#### 面试题30：最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

我们可以使用分治的方法来解决这个问题。

**代码示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix

strs = ["flower", "flow", "flight"]
print("最长公共前缀为：", longestCommonPrefix(strs))
```

**解析：**

时间复杂度：\(O(NM)\)，其中 \(N\) 是字符串数组中的字符串数量，\(M\) 是最长公共前缀的长度。

空间复杂度：\(O(1)\)。

#### 面试题31：验证回文串

**题目：** 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**答案：**

我们可以使用双指针的方法来解决这个问题。

**代码示例：**

```python
def isPalindrome(s):
    left, right = 0, len(s) - 1
    while left < right:
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
        if s[left].lower() != s[right].lower():
            return False
        left, right = left + 1, right - 1
    return True

s = "A man, a plan, a canal: Panama"
print("是否是回文串：", isPalindrome(s))
```

**解析：**

时间复杂度：\(O(N)\)，其中 \(N\) 是字符串的长度。

空间复杂度：\(O(1)\)。

#### 面试题32：最长有效括号

**题目：** 给定一个字符串，找出其中最长的有效括号子串。

**答案：**

我们可以使用栈来解决这个问题。

**代码示例：**

```python
def longestValidParentheses(s):
    stack = [-1]
    max_len = 0
    for i, char in enumerate(s):
        if char == '(':
            stack.append(i)
        else:
            stack.pop()
            if stack:
                max_len = max(max_len, i - stack[-1])
            else:
                stack.append(i)
    return max_len

s = "(()"
print("最长有效括号子串的长度为：", longestValidParentheses(s))
```

**解析：**

时间复杂度：\(O(N)\)。

空间复杂度：\(O(N)\)。

#### 面试题33：搜索旋转排序数组

**题目：** 整数数组 nums 按升序排列，数组中的值 0 到 n-1 都出现一次，可能存在数字重复。未知一个数字 k ，请找出并返回它在数组中的索引。数组中可能包含重复的数值。

**答案：**

我们可以使用二分查找的方法来解决这个问题。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < nums[right]:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
        else:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
    return -1

nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
print("目标值的索引为：", search(nums, target))
```

**解析：**

时间复杂度：\(O(\log N)\)，其中 \(N\) 是数组长度。

空间复杂度：\(O(1)\)。

#### 面试题34：在排序数组中查找元素的第一个和最后一个位置

**题目：** 给定一个已经排序好的数组和一个目标值，找出数组中目标值出现的第一个和最后一个位置。

**答案：**

我们可以使用二分查找的方法来解决这个问题。

**代码示例：**

```python
def searchRange(nums, target):
    def binary_search_left(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left

    def binary_search_right(nums, target):
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid - 1
        return right

    left = binary_search_left(nums, target)
    if left == len(nums) or nums[left] != target:
        return [-1, -1]
    right = binary_search_right(nums, target)
    return [left, right]

nums = [5, 7, 7, 8, 8, 10]
target = 8
print("第一个和最后一个位置分别为：", searchRange(nums, target))
```

**解析：**

时间复杂度：\(O(\log N)\)，其中 \(N\) 是数组长度。

空间复杂度：\(O(1)\)。

#### 面试题35：复杂度分析

**题目：** 请分析以下代码的时间复杂度和空间复杂度。

```python
def function(n):
    for i in range(n):
        for j in range(n):
            print(i + j)
```

**答案：**

时间复杂度：\(O(n^2)\)。

空间复杂度：\(O(1)\)。

**解析：**

时间复杂度：由于有两层嵌套循环，循环变量 \(i\) 和 \(j\) 分别从 0 到 \(n-1\) 变化，因此循环次数是 \(n \times n\)，即 \(O(n^2)\)。

空间复杂度：该函数没有使用额外的空间来存储数据，因此空间复杂度是 \(O(1)\)。

