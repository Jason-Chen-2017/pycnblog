                 

### 华为社招编程面试题精选与解答

#### 1. 链表反转

**题目描述：** 实现一个函数，对链表进行反转。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# 链表反转函数
def reverseList(head: ListNode) -> ListNode:
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**答案解析：**

该函数通过迭代方式实现链表反转。主要步骤如下：

1. 初始化两个指针 `prev` 和 `curr`，其中 `prev` 指向当前节点的上一个节点，`curr` 指向当前节点。
2. 循环遍历链表，每次循环将当前节点 `curr` 的 `next` 指针指向 `prev`，然后将 `prev` 和 `curr` 分别向后移动一步。
3. 当循环结束时，`prev` 指针指向新的头节点，返回 `prev` 即可。

#### 2. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

**答案解析：**

该函数通过哈希表实现，主要步骤如下：

1. 创建一个空哈希表 `hashmap` 用于存储遍历过程中出现的数字及其索引。
2. 遍历数组 `nums`，对于当前遍历到的数字 `num`，计算其补数 `complement`。
3. 检查补数 `complement` 是否存在于哈希表中，如果存在，则返回补数的索引和当前数字的索引。
4. 如果不存在，将当前数字及其索引存储在哈希表中。

#### 3. 三数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那三个整数，并返回他们的索引。

**示例：**

```python
def threeSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return result
```

**答案解析：**

该函数通过排序加双指针实现，主要步骤如下：

1. 对数组 `nums` 进行排序。
2. 遍历数组 `nums`，对于当前遍历到的数字 `nums[i]`，使用双指针 `left` 和 `right` 分别指向 `i + 1` 和 `len(nums) - 1`。
3. 根据三个数字的和 `total` 与目标值 `target` 的比较结果，调整 `left` 或 `right` 的位置。
4. 当找到一组解时，将解添加到结果列表 `result` 中，并跳过与当前数字相同的重复元素，继续寻找下一组解。
5. 返回结果列表。

#### 4. 盛最多水的容器

**题目描述：** 给定一个长度为 `n` 的整数数组 `height` ，有 `n` 个竖直线，其 `i``th` 个线段的高度为 `height[i]` 。找出其中的两条线，使得它们与 `x` 轴所形成的容器可以容纳最多的水。

**示例：**

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**答案解析：**

该函数通过双指针实现，主要步骤如下：

1. 初始化两个指针 `left` 和 `right`，分别指向数组的第一个和最后一个元素。
2. 初始化 `max_area` 为 0，表示当前容器的最大面积。
3. 在 `left` 小于 `right` 的条件下，计算当前容器的面积，更新 `max_area`。
4. 根据高度较小的一端移动指针，以尝试增加容器的面积。

#### 5. 两数相加

**题目描述：** 给出两个 **非空** 的链表 `l1` 和 `l2` ，每个链表中的元素都是 `0-9` 的一位数，将这两个数相加，并以链表形式返回结果。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**答案解析：**

该函数通过链表实现，主要步骤如下：

1. 创建一个哑节点 `dummy` 作为结果链表的头节点。
2. 初始化 `carry` 为 0，表示当前是否有进位。
3. 在 `l1` 或 `l2` 或 `carry` 不为 `None` 的条件下，进行循环计算。
4. 根据链表节点 `l1` 和 `l2` 的值计算和以及进位。
5. 将计算得到的和的个位数作为新节点添加到结果链表中。
6. 更新 `carry` 为和的十位数，用于下一轮计算。
7. 如果 `l1` 或 `l2` 还未结束，继续遍历。

#### 6. 搜索旋转排序数组

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**答案解析：**

该函数通过二分搜索实现，主要步骤如下：

1. 初始化两个指针 `left` 和 `right`，分别指向数组的第一个和最后一个元素。
2. 在 `left` 小于等于 `right` 的条件下，进行循环搜索。
3. 计算中间索引 `mid`。
4. 根据中间元素和边界元素的值判断旋转方向。
5. 根据目标值和边界值的关系更新 `left` 或 `right`。
6. 如果找到目标值，返回索引；否则返回 -1。

#### 7. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 创建一个哑节点 `dummy` 作为新链表的头节点。
2. 初始化指针 `curr` 指向哑节点。
3. 在 `l1` 和 `l2` 都不为 `None` 的条件下，比较两个链表的头节点值。
4. 将较小的值作为新链表的下一个节点，并移动相应的链表指针。
5. 当其中一个链表结束时，将另一个链表的剩余部分添加到新链表的末尾。
6. 返回新链表的头节点。

#### 8. 爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

**示例：**

```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 1
    for i in range(2, n):
        a, b = b, a + b
    return b
```

**答案解析：**

该函数通过动态规划实现，主要步骤如下：

1. 初始化前两个数 `a` 和 `b`，分别表示爬到第一阶和第二阶的方法数，都为 1。
2. 从第三阶开始，每次迭代计算当前阶的方法数，即前两阶的方法数之和。
3. 返回最后一阶的方法数。

#### 9. 合并两个有序数组

**题目描述：** 将两个按升序排列的数组合并为一个数组。

**示例：**

```python
def merge(nums1, m, nums2, n):
    i, j, k = 0, 0, 0
    while i < m and j < n:
        if nums1[i] < nums2[j]:
            nums1[k] = nums1[i]
            i += 1
        else:
            nums1[k] = nums2[j]
            j += 1
        k += 1
    while i < m:
        nums1[k] = nums1[i]
        i += 1
        k += 1
    while j < n:
        nums1[k] = nums2[j]
        j += 1
        k += 1
```

**答案解析：**

该函数通过双指针实现，主要步骤如下：

1. 初始化三个指针 `i`、`j` 和 `k`，分别指向 `nums1` 的开始位置、`nums2` 的开始位置和新数组的开始位置。
2. 比较 `nums1[i]` 和 `nums2[j]` 的大小，将较小的值放入新数组中，并移动相应的指针。
3. 当其中一个数组结束时，将另一个数组的剩余部分添加到新数组中。

#### 10. 翻转整数

**题目描述：** 编写一种算法，如果输入是一个正数，则输出该数的翻转；如果是负数，则输出它的绝对值的翻转。

**示例：**

```python
def reverse(x):
    res = 0
    while x:
        res = res * 10 + x % 10
        x //= 10
    return res if -(2**31) <= res < 2**31 else 0
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 初始化结果变量 `res` 为 0。
2. 在 `x` 不为 0 的条件下，不断将 `x` 的个位数添加到 `res` 的末尾，同时将 `x` 除以 10。
3. 当 `x` 为 0 时，结束循环。
4. 返回 `res`。
5. 检查 `res` 是否在 `32` 位整数的范围内，如果不是，则返回 0。

#### 11. 字符串转换整数 (atoi)

**题目描述：** 实现一个函数，将字符串转换成整数。

**示例：**

```python
def myAtoi(s: str) -> int:
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    sign = 1
    res = 0
    i = 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i < len(s) and (s[i] == '+' or s[i] == '-'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        digit = ord(s[i]) - ord('0')
        if res > (INT_MAX - digit) // 10:
            return INT_MAX if sign == 1 else INT_MIN
        res = res * 10 + digit
        i += 1
    return sign * res
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 初始化符号 `sign` 为 1。
2. 初始化结果 `res` 为 0。
3. 移动指针 `i`，跳过字符串开头的空格。
4. 如果 `s[i]` 是正负号，更新 `sign`。
5. 在 `s[i]` 是数字的条件下，更新结果 `res`。
6. 检查是否超出 `32` 位整数的范围。
7. 返回符号与结果的乘积。

#### 12. 两数相加 II

**题目描述：** 不使用溢出条件，实现一个函数，将两个链表代表的数相加。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**答案解析：**

该函数通过链表实现，主要步骤如下：

1. 创建一个哑节点 `dummy` 作为结果链表的头节点。
2. 初始化进位 `carry` 为 0。
3. 在 `l1` 或 `l2` 或 `carry` 不为 `None` 的条件下，进行循环计算。
4. 根据链表节点 `l1` 和 `l2` 的值计算和以及进位。
5. 将计算得到的和的个位数作为新节点添加到结果链表中。
6. 更新 `carry` 为和的十位数，用于下一轮计算。
7. 如果 `l1` 或 `l2` 还未结束，继续遍历。

#### 13. 有效数字

**题目描述：** 判断一个字符串是否是一个有效数字。

**示例：**

```python
def isNumber(s: str) -> bool:
    dot_count = 0
    e_count = 0
    sign_count = 0
    for char in s:
        if char.isdigit():
            continue
        elif char in ['+', '-']:
            if sign_count > 0 or dot_count > 0 or e_count > 0:
                return False
            sign_count += 1
        elif char == '.':
            if dot_count > 0 or e_count > 0:
                return False
            dot_count += 1
        elif char == 'e':
            if e_count > 0 or dot_count > 0:
                return False
            e_count += 1
        else:
            return False
    return True
```

**答案解析：**

该函数通过遍历实现，主要步骤如下：

1. 初始化变量 `dot_count`（小数点计数）、`e_count`（指数计数）和 `sign_count`（符号计数）为 0。
2. 对于字符串 `s` 的每个字符，进行判断：
    - 如果是数字，跳过。
    - 如果是加号或减号，检查是否在非法位置，跳过。
    - 如果是小数点，检查是否在非法位置，跳过。
    - 如果是字母 e，检查是否在非法位置，跳过。
    - 如果是其他字符，返回 False。
3. 返回 True。

#### 14. 三数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出三个数，使它们的和与 `target` 相等。

**示例：**

```python
def threeSum(nums: List[int], target: int) -> List[List[int]]:
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return result
```

**答案解析：**

该函数通过排序加双指针实现，主要步骤如下：

1. 对数组 `nums` 进行排序。
2. 遍历数组 `nums`，对于当前遍历到的数字 `nums[i]`，使用双指针 `left` 和 `right` 分别指向 `i + 1` 和 `len(nums) - 1`。
3. 根据三个数字的和 `total` 与目标值 `target` 的比较结果，调整 `left` 或 `right` 的位置。
4. 当找到一组解时，将解添加到结果列表 `result` 中，并跳过与当前数字相同的重复元素，继续寻找下一组解。
5. 返回结果列表。

#### 15. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 初始化前缀 `prefix` 为字符串数组中的第一个字符串。
2. 对于字符串数组中的每个字符串，从后往前遍历前缀，检查是否是当前字符串的前缀。
3. 如果不是，则去掉最后一个字符，重复检查。
4. 如果找到一个公共前缀，返回该前缀；否则返回空字符串。

#### 16. 两数相加

**题目描述：** 给出两个 非空 的链表 `l1` 和 `l2` ，每个链表中的元素都是 `0-9` 的一位数，将这两个数相加，并以链表形式返回结果。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**答案解析：**

该函数通过链表实现，主要步骤如下：

1. 创建一个哑节点 `dummy` 作为结果链表的头节点。
2. 初始化进位 `carry` 为 0。
3. 在 `l1` 或 `l2` 或 `carry` 不为 `None` 的条件下，进行循环计算。
4. 根据链表节点 `l1` 和 `l2` 的值计算和以及进位。
5. 将计算得到的和的个位数作为新节点添加到结果链表中。
6. 更新 `carry` 为和的十位数，用于下一轮计算。
7. 如果 `l1` 或 `l2` 还未结束，继续遍历。
8. 返回结果链表。

#### 17. 电话号码的字母组合

**题目描述：** 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

**示例：**

```python
def letterCombinations(digits: str) -> List[str]:
    phone = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    if not digits:
        return []
    res = [""]
    for i, d in enumerate(digits):
        p = len(res)
        for j in range(p):
            for c in phone[int(d) - 2]:
                res[j + p] = res[j] + c
    return res
```

**答案解析：**

该函数通过递归实现，主要步骤如下：

1. 创建一个映射数组 `phone`，其中包含每个数字对应的字母。
2. 初始化结果列表 `res` 为一个空字符串列表。
3. 对于字符串 `digits` 的每个数字，扩展 `res`：
    - 将 `res` 的长度扩展到当前数字的长度。
    - 对于每个新位置，将前一个位置的字符串与当前数字的字母组合。
4. 返回结果列表。

#### 18. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `s` 是否是 `t` 的字母异位词。

**示例：**

```python
def isAnagram(s: str, t: str) -> bool:
    return sorted(s) == sorted(t)
```

**答案解析：**

该函数通过排序实现，主要步骤如下：

1. 对字符串 `s` 和 `t` 进行排序。
2. 比较排序后的字符串是否相同。
3. 如果相同，返回 `True`；否则返回 `False`。

#### 19. 字符串转换整数 (atoi)

**题目描述：** 实现一个函数，将字符串转换成整数。

**示例：**

```python
def myAtoi(s: str) -> int:
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    sign = 1
    res = 0
    i = 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i < len(s) and (s[i] == '+' or s[i] == '-'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        digit = ord(s[i]) - ord('0')
        if res > (INT_MAX - digit) // 10:
            return INT_MAX if sign == 1 else INT_MIN
        res = res * 10 + digit
        i += 1
    return sign * res
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 初始化符号 `sign` 为 1。
2. 初始化结果 `res` 为 0。
3. 移动指针 `i`，跳过字符串开头的空格。
4. 如果 `s[i]` 是正负号，更新 `sign`。
5. 在 `s[i]` 是数字的条件下，更新结果 `res`。
6. 检查是否超出 `32` 位整数的范围。
7. 返回符号与结果的乘积。

#### 20. 删除链表的节点

**题目描述：** 给定一个单链表，删除链表中某个特定的节点，您将只被给定需要删除的节点的 `next` 节点。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

**答案解析：**

该函数通过链表实现，主要步骤如下：

1. 将当前节点的值替换为下一个节点的值。
2. 将当前节点的 `next` 指针指向下一个节点的 `next` 指针。
3. 实现删除节点功能。

#### 21. 搜索旋转排序数组

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转，请找出并返回数组中的最小元素。

**示例：**

```python
def searchMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**答案解析：**

该函数通过二分搜索实现，主要步骤如下：

1. 初始化两个指针 `left` 和 `right`，分别指向数组的第一个和最后一个元素。
2. 在 `left` 小于 `right` 的条件下，进行循环搜索。
3. 计算中间索引 `mid`。
4. 根据中间元素和边界元素的值判断旋转方向。
5. 更新 `left` 或 `right`。
6. 返回最小元素。

#### 22. 两数相加

**题目描述：** 给出两个 非空 的链表 `l1` 和 `l2` ，每个链表的节点依次表示一个 `decimal` 数字。将这两个数相加，返回一个表示和的链表。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**答案解析：**

该函数通过链表实现，主要步骤如下：

1. 创建一个哑节点 `dummy` 作为结果链表的头节点。
2. 初始化进位 `carry` 为 0。
3. 在 `l1` 或 `l2` 或 `carry` 不为 `None` 的条件下，进行循环计算。
4. 根据链表节点 `l1` 和 `l2` 的值计算和以及进位。
5. 将计算得到的和的个位数作为新节点添加到结果链表中。
6. 更新 `carry` 为和的十位数，用于下一轮计算。
7. 如果 `l1` 或 `l2` 还未结束，继续遍历。
8. 返回结果链表。

#### 23. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 创建一个哑节点 `dummy` 作为新链表的头节点。
2. 初始化指针 `curr` 指向哑节点。
3. 在 `l1` 和 `l2` 都不为 `None` 的条件下，比较两个链表的头节点值。
4. 将较小的值作为新链表的下一个节点，并移动相应的链表指针。
5. 当其中一个链表结束时，将另一个链表的剩余部分添加到新链表的末尾。
6. 返回新链表的头节点。

#### 24. 罗马数字转整数

**题目描述：** 罗马数字包含以下七种字符: `I`, `V`, `X`, `L`, `C`, `D` 和 `M`。

**示例：**

```python
def romanToInt(s):
    roman_to_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    prev, total = 0, 0
    for c in reversed(s):
        curr = roman_to_int[c]
        if curr > prev:
            total += curr - 2 * prev
        else:
            total += curr
        prev = curr
    return total
```

**答案解析：**

该函数通过迭代实现，主要步骤如下：

1. 创建一个映射字典 `roman_to_int`，其中包含每个罗马数字对应的整数。
2. 初始化前一个字符的值 `prev` 和总结果 `total`。
3. 从后往前遍历字符串 `s`，对于每个字符，计算对应的整数值 `curr`。
4. 如果 `curr` 大于 `prev`，说明当前字符是一个减法字符，从总结果中减去两倍的 `prev`。
5. 否则，直接将 `curr` 加到总结果中。
6. 更新 `prev` 为当前字符的值。
7. 返回总结果。

#### 25. 合并K个排序链表

**题目描述：** 合并 `K` 个已排序的链表，返回合并后的链表。`K` 个链表中的链表数为 `k`，链表的长度为 `l`。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None
    while len(lists) > 1:
        temp = []
        for i in range(0, len(lists), 2):
            if i + 1 < len(lists):
                temp.append(mergeTwoLists(lists[i], lists[i + 1]))
            else:
                temp.append(lists[i])
        lists = temp
    return lists[0]
```

**答案解析：**

该函数通过递归实现，主要步骤如下：

1. 如果链表列表为空，返回 `None`。
2. 当链表列表的长度大于 1 时，进行循环合并：
   - 初始化一个空列表 `temp`。
   - 对于链表列表中的每两个链表，使用 `mergeTwoLists` 函数合并它们，并将合并后的链表添加到 `temp`。
   - 如果链表列表的长度为奇数，将最后一个链表直接添加到 `temp`。
   - 更新链表列表为 `temp`。
3. 返回合并后的链表。

#### 26. 翻转字符串里的单词

**题目描述：** 实现一个函数，对字符串 `s` 进行反转操作，其中 `s` 是以空格分隔开的一组单词。

**示例：**

```python
def reverseWords(s: str) -> str:
    words = s.split()
    words.reverse()
    return ' '.join(words)
```

**答案解析：**

该函数通过分割和反向遍历实现，主要步骤如下：

1. 使用空格分割字符串 `s`，得到单词列表 `words`。
2. 反向遍历单词列表 `words`。
3. 使用空格连接单词列表 `words`，得到反转后的字符串。

#### 27. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**示例：**

```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
```

**答案解析：**

该函数通过双指针实现，主要步骤如下：

1. 初始化三个指针 `i`、`j` 和 `k`，分别指向 `nums1` 的最后一个元素、`nums2` 的最后一个元素和 `nums1` 的最后一个可插入位置。
2. 在 `i` 大于等于 0 且 `j` 大于等于 0 的条件下，比较两个指针指向的元素。
3. 将较大的元素放入 `nums1` 的 `k` 位置，并移动相应的指针。
4. 当其中一个数组结束时，将另一个数组的剩余部分添加到 `nums1`。

#### 28. 字符串匹配

**题目描述：** 给定一个文本字符串和一个模式，实现一个支持 `'.'` 和 `'*'` 的正则表达式搜索模式的函数。

**示例：**

```python
def isMatch(s, p):
    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
    dp[-1][-1] = True
    for i in range(len(s), -1, -1):
        for j in range(len(p), -1, -1):
            if p[j] == '*':
                dp[i][j] = dp[i + 1][j] or dp[i][j + 1]
            elif p[j] == '.' or s[i] == p[j]:
                dp[i][j] = dp[i + 1][j + 1]
    return dp[0][0]
```

**答案解析：**

该函数通过动态规划实现，主要步骤如下：

1. 创建一个二维布尔数组 `dp`，其中 `dp[i][j]` 表示字符串 `s` 的前 `i` 个字符与模式 `p` 的前 `j` 个字符是否匹配。
2. 初始化 `dp[-1][-1]` 为 `True`，表示空字符串与空模式匹配。
3. 从后向前遍历字符串 `s` 和模式 `p`：
   - 如果模式字符是 `'*'`，则 `dp[i][j]` 取决于 `dp[i + 1][j]` 和 `dp[i][j + 1]`。
   - 如果模式字符是 `.`，则 `dp[i][j]` 等于 `dp[i + 1][j + 1]`。
   - 如果模式字符与字符串字符相同，则 `dp[i][j]` 等于 `dp[i + 1][j + 1]`。
4. 返回 `dp[0][0]`。

#### 29. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**示例：**

```python
def longestCommonSubsequence(text1, text2):
    dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
    for i in range(1, len(text1) + 1):
        for j in range(1, len(text2) + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**答案解析：**

该函数通过动态规划实现，主要步骤如下：

1. 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符与 `text2` 的前 `j` 个字符的最长公共子序列的长度。
2. 初始化第一行和第一列为 0，因为空字符串与任意字符串的最长公共子序列长度为 0。
3. 从左到右遍历字符串 `text1` 和 `text2`：
   - 如果当前字符相同，则 `dp[i][j]` 等于 `dp[i - 1][j - 1] + 1`。
   - 如果当前字符不同，则 `dp[i][j]` 等于 `dp[i - 1][j]` 和 `dp[i][j - 1]` 中的最大值。
4. 返回 `dp[-1][-1]`。

#### 30. 最长公共子串

**题目描述：** 给定两个字符串 `s` 和 `t`，返回它们的公共最长子串的长度。

**示例：**

```python
def longestCommonSubstring(s, t):
    max_len = 0
    start = 0
    m, n = len(s), len(t)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    start = i - max_len
            else:
                dp[i][j] = 0
    return s[start:start + max_len]
```

**答案解析：**

该函数通过动态规划实现，主要步骤如下：

1. 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s` 的前 `i` 个字符与 `t` 的前 `j` 个字符的最长公共子串的长度。
2. 初始化第一行和第一列为 0，因为空字符串与任意字符串的最长公共子串长度为 0。
3. 从左到右遍历字符串 `s` 和 `t`：
   - 如果当前字符相同，则 `dp[i][j]` 等于 `dp[i - 1][j - 1] + 1`。
   - 如果当前字符不同，则 `dp[i][j]` 重置为 0。
4. 记录最长公共子串的长度和起始位置。
5. 返回最长公共子串。

