                 

### 国内头部一线大厂典型高频面试题和算法编程题解析

#### 阿里巴巴

**1. TCP 和 UDP 的区别？**

**答案：** TCP（传输控制协议）和 UDP（用户数据报协议）都是网络传输协议，但它们有不同的特点和应用场景。

- **TCP：** 面向连接，提供可靠的数据传输，确保数据的顺序性和完整性。TCP 使用三次握手和四次挥手来建立和断开连接。
- **UDP：** 无连接，提供不可靠的数据传输，适用于实时应用，如视频通话和在线游戏。

**解析：** TCP适用于对数据完整性和可靠性要求较高的应用，而UDP适用于对延迟敏感、对数据丢失不敏感的应用。

**2. 如何保证数据的幂等性？**

**答案：** 幂等性指的是无论执行多少次操作，结果都是一致的。

- **加锁：** 通过加锁，确保同一时间只有一个操作在执行。
- **使用唯一标识：** 使用唯一标识（如ID），避免重复执行相同的操作。
- **幂等性操作：** 设计操作使其无论执行多少次，结果都相同，如将值设置为已知的值。

**解析：** 保证数据的幂等性可以避免重复操作带来的副作用，提高系统的稳定性。

#### 百度

**3. 如何避免缓存雪崩？**

**答案：** 缓存雪崩是指缓存服务器在短时间内大量失效，导致大量请求直接访问数据库。

- **过期时间随机化：** 随机化缓存的过期时间，避免同时失效。
- **缓存预热：** 在缓存即将过期前，提前加载缓存。
- **过期时间分层：** 对不同重要性的数据设置不同的过期时间，避免所有数据同时失效。

**解析：** 避免缓存雪崩可以提高系统的可用性和性能。

**4. 请实现一个LRU（最近最少使用）缓存算法。**

**答案：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：** LRUCache 通过OrderedDict实现，最近最少使用的数据会被移到字典末尾，超出容量时移除最久未使用的数据。

#### 腾讯

**5. 请解释一下二叉搜索树（BST）和红黑树。**

**答案：** 

- **BST：** 二叉搜索树是一种特殊的二叉树，左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值。BST 的时间复杂度为O(logn)。
- **红黑树：** 红黑树是一种自平衡二叉搜索树，通过旋转和重新着色来保持树的平衡。红黑树的时间复杂度也为O(logn)。

**解析：** 红黑树通过自平衡特性，在维持二叉搜索树特性同时，保证了操作的时间复杂度为O(logn)。

#### 字节跳动

**6. 请实现一个LRU缓存算法。**

**答案：**

```java
import java.util.HashMap;
import java.util.Map;

class LRUCache {
    private final int capacity;
    private final Map<Integer, Node> map;
    private final Node head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<>();
        this.head = new Node(0, 0);
        this.tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        Node node = map.get(key);
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            moveToHead(node);
        } else {
            Node newNode = new Node(key, value);
            map.put(key, newNode);
            addNode(newNode);
            if (map.size() > capacity) {
                Node lastNode = tail.prev;
                removeNode(lastNode);
                map.remove(lastNode.key);
            }
        }
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addNode(node);
    }

    private void addNode(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    static class Node {
        int key, value;
        Node prev, next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

**解析：** LRUCache 通过双向链表和HashMap实现，最近最少使用的数据会被移到链表头部。

#### 拼多多

**7. 请解释一下哈希表的工作原理。**

**答案：** 哈希表是一种基于哈希函数的数据结构，通过哈希函数将键映射到数组索引，从而实现快速查找、插入和删除操作。

- **哈希函数：** 哈希函数将键转换为数组索引。
- **数组：** 哈希表内部使用一个数组来存储键值对。
- **冲突处理：** 当多个键映射到同一索引时，需要通过冲突处理方法解决。

**解析：** 哈希表通过哈希函数和数组实现，时间复杂度为O(1)。

#### 京东

**8. 请实现一个LRU缓存算法。**

**答案：**

```c++
#include <list>
#include <unordered_map>

using namespace std;

class LRUCache {
public:
    struct Node {
        int key;
        int val;
        Node(int _key, int _val): key(_key), val(_val) {}
    };

    unordered_map<int, list<Node>::iterator> map;
    list<Node> cache;
    int cap;

    LRUCache(int capacity) : cap(capacity) {}

    int get(int key) {
        if (map.count(key) == 0) {
            return -1;
        }
        auto it = map[key];
        cache.splice(cache.begin(), cache, it);
        return it->val;
    }

    void put(int key, int value) {
        if (map.count(key)) {
            auto it = map[key];
            it->val = value;
            cache.splice(cache.begin(), cache, it);
        } else {
            if (cache.size() == cap) {
                auto it = cache.end();
                map.erase(it->key);
                cache.pop_back();
            }
            Node node(key, value);
            cache.push_front(node);
            map[key] = cache.begin();
        }
    }
};
```

**解析：** LRUCache 通过双向链表和哈希表实现，最近最少使用的数据会被移到链表头部。

#### 美团

**9. 请解释一下快排的原理。**

**答案：** 快速排序（Quick Sort）是一种高效的排序算法，基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

- **基准元素选择：** 选择序列中的某个元素作为基准元素。
- **分区操作：** 将序列分成两部分，一部分小于基准元素，另一部分大于基准元素。
- **递归排序：** 对小于和大于基准元素的两部分递归地进行快速排序。

**解析：** 快排通过递归和分区操作，将问题分解为规模更小的子问题，时间复杂度为O(nlogn)。

#### 快手

**10. 请解释一下位运算的作用。**

**答案：** 位运算是对二进制位进行操作的一系列运算，主要包括按位与（&）、按位或（|）、按位异或（^）、按位取反（~）和左移（<<）右移（>>）。

- **按位与：** 逐位比较两个二进制数的每一位，相同为1，不同为0。
- **按位或：** 逐位比较两个二进制数的每一位，相同或不同为1。
- **按位异或：** 逐位比较两个二进制数的每一位，相同为0，不同为1。
- **按位取反：** 对二进制数的每一位取反。
- **左移和右移：** 将二进制数的某位向左或向右移动指定的位数。

**解析：** 位运算可以优化算法和代码性能，减少内存占用，常用于位操作相关的算法和数据结构。

#### 滴滴

**11. 请实现一个LRU缓存算法。**

**答案：**

```java
import java.util.HashMap;
import java.util.Map;

class LRUCache {
    private final int capacity;
    private final Map<Integer, Node> map;
    private final Node head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.map = new HashMap<>();
        this.head = new Node(0, 0);
        this.tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        Node node = map.get(key);
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node node = map.get(key);
            node.value = value;
            moveToHead(node);
        } else {
            Node newNode = new Node(key, value);
            map.put(key, newNode);
            addNode(newNode);
            if (map.size() > capacity) {
                Node lastNode = tail.prev;
                removeNode(lastNode);
                map.remove(lastNode.key);
            }
        }
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addNode(node);
    }

    private void addNode(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    static class Node {
        int key, value;
        Node prev, next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

**解析：** LRUCache 通过双向链表和哈希表实现，最近最少使用的数据会被移到链表头部。

#### 小红书

**12. 请解释一下线程和协程的区别。**

**答案：**

- **线程：** 线程是操作系统层面的并发单元，线程在操作系统中运行，操作系统为每个线程分配资源，如堆栈和CPU时间片。
- **协程：** 协程是用户层面的并发单元，协程是由用户自己管理调度的，通常运行在一个线程中，不需要操作系统参与调度。

区别：

- **调度：** 线程由操作系统调度，协程由用户自己调度。
- **性能：** 协程相比线程有更好的性能，因为不需要操作系统参与调度。
- **资源：** 线程需要操作系统分配资源，协程则由用户自己管理资源。

**解析：** 线程和协程都是实现并发的方式，但协程更加轻量级，适用于异步编程和事件驱动应用。

#### 蚂蚁支付宝

**13. 请解释一下数据库的隔离级别。**

**答案：** 数据库的隔离级别用来保证多个事务之间不会相互干扰，常见的隔离级别包括：

- **读未提交（Read Uncommitted）：** 允许事务读取未提交的变更，容易出现脏读。
- **读已提交（Read Committed）：** 事务可以读取已经提交的变更，解决了脏读问题。
- **可重复读（Repeatable Read）：** 事务可以重复读取同一数据集，避免了不可重复读问题。
- **串行化（Serializable）：** 事务按照顺序执行，保证了数据的完整性和一致性。

**解析：** 不同隔离级别在保证数据一致性和性能方面有不同的权衡，根据实际需求选择合适的隔离级别。

#### 阿里云

**14. 请实现一个二叉搜索树（BST）。**

**答案：**

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        else:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)

    def search(self, val):
        return self._search(self.root, val)

    def _search(self, node, val):
        if node is None:
            return False
        if val == node.val:
            return True
        elif val < node.val:
            return self._search(node.left, val)
        else:
            return self._search(node.right, val)

    def inorder_traversal(self):
        self._inorder_traversal(self.root)
        print()

    def _inorder_traversal(self, node):
        if node:
            self._inorder_traversal(node.left)
            print(node.val, end=' ')
            self._inorder_traversal(node.right)
```

**解析：** BST 通过递归方式实现，支持插入、搜索和遍历操作。

#### 网易

**15. 请解释一下Redis的数据结构。**

**答案：** Redis是一种基于内存的键值数据库，支持多种数据结构，包括：

- **字符串（String）：** 最基本的数据结构，可以存储字符串、数字等。
- **列表（List）：** 双向链表结构，可以用于存储字符串或数字序列。
- **集合（Set）：** 基于哈希表实现，用于存储唯一的字符串元素。
- **哈希（Hash）：** 类似于键值对，可以存储多个字段。
- **有序集合（Sorted Set）：** 类似于集合，但元素带有分数，可以按分数排序。

**解析：** Redis的数据结构丰富，适用于多种场景，如缓存、消息队列、分布式锁等。

#### 爱奇艺

**16. 请实现一个有序链表。**

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class OrderedLinkedList:
    def __init__(self):
        self.head = None

    def insert(self, val):
        new_node = ListNode(val)
        if not self.head or val < self.head.val:
            new_node.next = self.head
            self.head = new_node
        else:
            curr = self.head
            while curr.next and curr.next.val < val:
                curr = curr.next
            new_node.next = curr.next
            curr.next = new_node

    def remove(self, val):
        if not self.head or self.head.val == val:
            self.head = self.head.next
            return
        curr = self.head
        while curr.next and curr.next.val != val:
            curr = curr.next
        if curr.next:
            curr.next = curr.next.next

    def inorder_traversal(self):
        curr = self.head
        while curr:
            print(curr.val, end=' ')
            curr = curr.next
        print()

# Example usage
ll = OrderedLinkedList()
ll.insert(3)
ll.insert(1)
ll.insert(4)
ll.insert(2)
ll.inorder_traversal()  # Output: 1 2 3 4
ll.remove(3)
ll.inorder_traversal()  # Output: 1 2 4
```

**解析：** OrderedLinkedList 通过链表实现，支持插入、删除和遍历操作。

### 17. 请解释一下深度优先搜索（DFS）和广度优先搜索（BFS）。

**答案：**

- **深度优先搜索（DFS）：** 一种搜索算法，沿着某一路径一直探索到该路径的尽头，然后回溯到上一个节点，继续沿着其他路径探索。DFS 可以用于图的遍历、拓扑排序、求解迷宫等问题。
- **广度优先搜索（BFS）：** 一种搜索算法，先访问当前节点，然后依次访问其相邻的节点，再访问相邻节点的相邻节点，以此类推。BFS 可以用于图的最短路径问题、层序遍历等。

区别：

- **搜索顺序：** DFS 先深后广，BFS 先广后深。
- **空间复杂度：** DFS 的空间复杂度较低，BFS 的空间复杂度较高。
- **适用场景：** DFS 适用于需要遍历所有节点的情况，BFS 适用于需要找到最短路径的情况。

**解析：** DFS 和 BFS 是两种常用的图遍历算法，根据问题的特点选择合适的算法。

### 18. 请实现一个二叉树的前序、中序和后序遍历。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinaryTree:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        else:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)

    def preorder_traversal(self):
        self._preorder_traversal(self.root)
        print()

    def _preorder_traversal(self, node):
        if node:
            print(node.val, end=' ')
            self._preorder_traversal(node.left)
            self._preorder_traversal(node.right)

    def inorder_traversal(self):
        self._inorder_traversal(self.root)
        print()

    def _inorder_traversal(self, node):
        if node:
            self._inorder_traversal(node.left)
            print(node.val, end=' ')
            self._inorder_traversal(node.right)

    def postorder_traversal(self):
        self._postorder_traversal(self.root)
        print()

    def _postorder_traversal(self, node):
        if node:
            self._postorder_traversal(node.left)
            self._postorder_traversal(node.right)
            print(node.val, end=' ')

# Example usage
bt = BinaryTree()
bt.insert(1)
bt.insert(2)
bt.insert(3)
bt.insert(4)
bt.insert(5)
bt.preorder_traversal()  # Output: 1 2 4 5 3
bt.inorder_traversal()  # Output: 4 2 5 1 3
bt.postorder_traversal()  # Output: 4 5 2 3 1
```

**解析：** BinaryTree 通过递归方式实现，支持前序、中序和后序遍历操作。

### 19. 请解释一下哈希表的工作原理。**

**答案：** 哈希表（Hash Table）是一种基于哈希函数的数据结构，通过哈希函数将键映射到数组索引，从而实现快速查找、插入和删除操作。

- **哈希函数：** 哈希函数将键转换为数组索引。
- **数组：** 哈希表内部使用一个数组来存储键值对。
- **冲突处理：** 当多个键映射到同一索引时，需要通过冲突处理方法解决。

**解析：** 哈希表通过哈希函数和数组实现，时间复杂度为O(1)。

### 20. 请实现一个斐波那契数列的递归和动态规划解法。

**答案：**

```python
# 递归解法
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

# 动态规划解法
def fibonacci_dp(n):
    if n <= 1:
        return n
    fib = [0] * (n+1)
    fib[1] = 1
    for i in range(2, n+1):
        fib[i] = fib[i-1] + fib[i-2]
    return fib[n]

# Example usage
print(fibonacci_recursive(10))  # Output: 55
print(fibonacci_dp(10))  # Output: 55
```

**解析：** 斐波那契数列可以通过递归和动态规划两种方式实现，递归解法时间复杂度为O(2^n)，动态规划解法时间复杂度为O(n)。

### 21. 请解释一下时间复杂度和空间复杂度的概念。**

**答案：** 时间复杂度和空间复杂度是分析算法性能的重要指标。

- **时间复杂度：** 描述算法执行的时间增长趋势，通常用大O符号表示，如O(n)、O(nlogn)等。时间复杂度越高，算法的执行时间越长。
- **空间复杂度：** 描述算法执行过程中所需的最大内存空间，也用大O符号表示，如O(1)、O(n)等。空间复杂度越高，算法的内存消耗越大。

**解析：** 时间复杂度和空间复杂度是评估算法性能的重要指标，选择合适的时间复杂度和空间复杂度可以优化算法的执行效率和资源利用率。

### 22. 请实现一个快速排序算法。

**答案：**

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)

# Example usage
arr = [3, 6, 8, 10, 1, 2, 1]
print(quicksort(arr))  # Output: [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 快速排序算法通过递归方式实现，时间复杂度为O(nlogn)。

### 23. 请解释一下动态规划的概念和应用场景。**

**答案：** 动态规划（Dynamic Programming，DP）是一种解决最优化问题的算法思想，将复杂问题分解成重叠子问题，通过保存已解决的子问题的解来避免重复计算。

应用场景：

- **最短路径问题：** 如Dijkstra算法、Floyd算法。
- **背包问题：** 如01背包、完全背包、多重背包。
- **最长公共子序列：** 如LCS算法。
- **最长公共子串：** 如最长公共前缀。

**解析：** 动态规划通过优化子问题的解，避免了重复计算，提高了算法的效率。

### 24. 请实现一个二分查找算法。

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Example usage
arr = [1, 3, 5, 7, 9]
print(binary_search(arr, 5))  # Output: 2
print(binary_search(arr, 10))  # Output: -1
```

**解析：** 二分查找算法通过递归或循环方式实现，时间复杂度为O(logn)。

### 25. 请解释一下贪心算法的概念和应用场景。**

**答案：** 贪心算法（Greedy Algorithm）是一种在每一步选择当前最优解的策略，不考虑未来的影响，适用于某些优化问题。

应用场景：

- **背包问题：** 如0-1背包、完全背包。
- **最短路径问题：** 如Dijkstra算法。
- **区间调度问题：** 如会议调度。
- **活动选择问题：** 如最小生成树、单源最短路径。

**解析：** 贪心算法通过每一步选择最优解，逐步逼近最优解，但需要证明其全局最优性。

### 26. 请实现一个冒泡排序算法。

**答案：**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array:", arr)  # Output: Sorted array: [11, 12, 22, 25, 34, 64, 90]
```

**解析：** 冒泡排序算法通过多次遍历和交换相邻的元素，实现数组排序，时间复杂度为O(n^2)。

### 27. 请解释一下堆（Heap）的概念和应用场景。**

**答案：** 堆（Heap）是一种特殊的树形数据结构，满足堆的性质，分为最大堆和最小堆。

概念：

- **最大堆：** 父节点的值大于或等于子节点的值。
- **最小堆：** 父节点的值小于或等于子节点的值。

应用场景：

- **优先队列：** 如Dijkstra算法。
- **拓扑排序：** 如Kruskal算法、Prim算法。
- **动态规划：** 如背包问题。

**解析：** 堆通过调整树结构实现高效的数据操作，适用于优先级队列和拓扑排序等问题。

### 28. 请实现一个归并排序算法。

**答案：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = merge_sort(arr)
print("Sorted array:", sorted_arr)  # Output: Sorted array: [11, 12, 22, 25, 34, 64, 90]
```

**解析：** 归并排序算法通过递归方式实现，将数组分为两半，分别排序后再合并，时间复杂度为O(nlogn)。

### 29. 请解释一下查找算法（如二分查找）和排序算法（如冒泡排序）的区别。**

**答案：** 查找算法和排序算法的主要区别在于目标不同。

- **查找算法：** 用于在数据结构中查找特定元素，如二分查找、线性查找。
- **排序算法：** 用于将数据结构中的元素按照一定顺序排列，如冒泡排序、快速排序。

区别：

- **目标：** 查找算法的目标是查找特定元素，排序算法的目标是排列数据。
- **时间复杂度：** 查找算法的时间复杂度通常与数据规模有关，如二分查找的时间复杂度为O(logn)；排序算法的时间复杂度与数据规模和排序方式有关，如冒泡排序的时间复杂度为O(n^2)。
- **应用场景：** 查找算法适用于需要查找特定元素的场景，排序算法适用于需要对数据进行排序的场景。

**解析：** 查找算法和排序算法在目标、时间复杂度和应用场景方面有明显的区别。

### 30. 请实现一个最小栈。**

**答案：**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack:
            val = self.stack.pop()
            if val == self.min_stack[-1]:
                self.min_stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]

    def getMin(self) -> int:
        if self.min_stack:
            return self.min_stack[-1]

# Example usage
minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
print(minStack.getMin())  # Output: -3
minStack.pop()
print(minStack.top())  # Output: 0
print(minStack.getMin())  # Output: -2
```

**解析：** MinStack 通过两个栈实现，一个栈存储元素，另一个栈存储最小元素，支持push、pop、top和getMin操作。

