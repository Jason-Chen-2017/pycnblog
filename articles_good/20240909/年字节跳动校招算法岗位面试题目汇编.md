                 

### 2024年字节跳动校招算法岗位面试题目汇编

在2024年，字节跳动作为科技行业领军企业，其校招算法岗位面试题目汇编引起了广泛关注。下面我们将精选一些典型问题，并提供详尽的答案解析和源代码实例，帮助各位考生备战字节跳动校招。

#### 1. 数组中的最长递增子序列

**题目：** 给定一个无序数组，找出其中最长递增子序列的长度。

**示例：**
```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

# 输入：[10, 9, 2, 5, 3, 7, 101, 18]
# 输出：4
```

**解析：** 使用动态规划（DP）方法，dp[i]表示以nums[i]结尾的最长递增子序列的长度。

#### 2. 二维数组中的查找

**题目：** 在一个二维数组中，给定一个数字，判断数组中是否存在这个数字。

**示例：**
```python
def findNumber(array, target):
    row, col = 0, len(array[0]) - 1
    while row < len(array) and col >= 0:
        if array[row][col] == target:
            return True
        elif array[row][col] > target:
            col -= 1
        else:
            row += 1
    return False

# 输入：array = [[1,3,5,7], [10,11,16,20], [23,30,34,50]], target = 3
# 输出：True
```

**解析：** 采用“右上角”法，根据当前元素与目标值的大小关系，决定是向下还是向左移动。

#### 3. 单词搜索

**题目：** 给定一个二维字符网格和一个单词，判断该单词是否可以在网格中按照单词列表中的顺序遍历。

**示例：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False

# 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
# 输出：True
```

**解析：** 使用深度优先搜索（DFS）遍历网格，每次搜索尝试四个方向：上、下、左、右。

#### 4. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last = ans[-1]
        if interval[0] <= last[1]:
            last[1] = max(last[1], interval[1])
        else:
            ans.append(interval)
    return ans

# 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
# 输出：[[1,6],[8,10],[15,18]]
```

**解析：** 首先对区间按起始位置排序，然后遍历区间，合并重叠的区间。

#### 5. 二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树和目标值，判断树中是否含有该值。

**示例：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root, val):
    while root:
        if root.val == val:
            return True
        elif root.val < val:
            root = root.right
        else:
            root = root.left
    return False

# 输入：root = [4,2,7,1,3], val = 2
# 输出：True
```

**解析：** 直接递归或迭代遍历二叉搜索树，与目标值比较。

#### 6. 最长公共前缀

**题目：** 找出几个字符串中的最长公共前缀。

**示例：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        for i, c in enumerate(s):
            if i == len(prefix) or c != prefix[i]:
                prefix = prefix[:i]
                break
    return prefix

# 输入：strs = ["flower","flow","flight"]
# 输出："fl"
```

**解析：** 从第一个字符串开始，依次比较后续字符串的前缀。

#### 7. 反转整数

**题目：** 给定一个 32 位有符号整数，将整数按位反转。

**示例：**
```python
def reverse(x):
    res = 0
    while x != 0:
        res = res * 10 + x % 10
        x //= 10
    return res if res <= 2**31-1 and res >= -2**31 else 0

# 输入：x = 123
# 输出：321
```

**解析：** 使用整数除法和求余操作，将整数反转。

#### 8. 整数转换罗马数字

**题目：** 给一个整数，将其转换为罗马数字。

**示例：**
```python
def intToRoman(num):
    val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    rom = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    ans = ""
    for i in range(len(val)):
        while num >= val[i]:
            ans += rom[i]
            num -= val[i]
    return ans

# 输入：num = 1994
# 输出："MCMXCIV"
```

**解析：** 通过遍历数值和罗马数字的映射表，将整数转换为罗马数字。

#### 9. 合并两个有序链表

**题目：** 合并两个有序链表。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(l1, l2):
    dummy = ListNode()
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 输入：l1 = [1,2,4], l2 = [1,3,4]
# 输出：[1,1,2,3,4,4]
```

**解析：** 通过比较两个链表的当前节点值，选择较小的值，将其添加到新的链表中。

#### 10. 三数和

**题目：** 给定一个整数数组，找出所有三个数的组合，使得它们的和等于一个特定的目标数。

**示例：**
```python
def threeSum(nums, target):
    nums.sort()
    ans = []
    for i in range(len(nums)-2):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, len(nums)-1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                ans.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return ans

# 输入：nums = [-1, 0, 1, 2, -1, -4], target = 0
# 输出：[[-1, -1, 2], [-1, 0, 1]]
```

**解析：** 使用排序和双指针法，减少不必要的重复计算。

#### 11. 盒子模拟

**题目：** 给定一个长度为 n 的数组 boxes，其中 boxes[i] 表示第 i 个盒子的最大宽高比。你需要将所有盒子堆叠起来，使得宽高比最大。返回可能的最大宽高比。

**示例：**
```python
def maximumWidthRatio(boxes):
    boxes = sorted(boxes, key=lambda x: x[1] / x[0], reverse=True)
    ans = 0
    s = 0
    for w, h in boxes:
        s += w
        ans = max(ans, h * len(boxes) / s)
    return ans

# 输入：boxes = [[2, 3], [5, 5], [4, 4], [5, 6]]
# 输出：5.0
```

**解析：** 使用排序和模拟法，计算每个盒子加入后的宽高比。

#### 12. 奇妙序列

**题目：** 给定一个正整数 n，返回 n 的 奇妙序列。奇妙序列定义如下：对于任何正整数 n，构造一个序列 a1, a2, a3, ..., an，其中：

- a1 = n
- 当 i > 1 时，ai 等于前两个数的最大公约数。

**示例：**
```python
def奇妙序列（n）：
    a = [n]
    for i in range（2，n+1）：
        a.append（math.gcd（a[i-1]，a[i-2]））
    return a

# 输入：n = 6
# 输出：[6, 3, 3, 1, 1, 1]
```

**解析：** 使用循环遍历，计算每两个连续数的最大公约数。

#### 13. 买卖股票的最佳时机

**题目：** 给你一个整数数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。你只能 持有一股股票 ，但你可以按任意次数买卖股票。在买入和卖出股票之间，你最多可以持有股票 k 天。返回你能获取的最大利润。

**示例：**
```python
def maxProfit(prices, k):
    dp = [[0] * (k + 1) for _ in range(len(prices))]
    for i in range(1, len(prices)):
        for j in range(1, k + 1):
            dp[i][j] = max(dp[i - 1][j], prices[i] + max(dp[i - 2][j - 1], dp[i - 1][j - 1]))
    return dp[-1][-1]

# 输入：prices = [3,2,6,5,0,3], k = 2
# 输出：7
```

**解析：** 使用动态规划，更新每一天的最大利润。

#### 14. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
    return prefix

# 输入：strs = ["flower","flow","flight"]
# 输出："fl"
```

**解析：** 通过遍历第一个字符串和后续字符串的前缀，找到最长公共前缀。

#### 15. 有效的括号字符串

**题目：** 给你一个只包含 '('、')' 和 '*' 的字符串 expression，你需要实现一个解析它的函数，返回所有可能的解析方式。

**示例：**
```python
def parseExpression(expression):
    def expand(a, b):
        return [a * b] if b else [a]

    def multiply(a, b):
        return [a * b] if b else []

    def parse(expr):
        if not expr:
            return [[]]
        if expr[0] == '*':
            res = []
            for v in parse(expr[1:]):
                res.extend(expand(2, v))
            return res
        op = expr[0]
        if op == '(':
            idx = expression.index(')')
            res = parse(expression[1:idx])
            res = [item for sublist in res for item in sublist]
            return [[')'] + r for r in res]
        return [[op] + r for r in parse(expression[1:])]

    return [item for sublist in parse(expression) for item in sublist]

# 输入：expression = "(*))"
# 输出：[["(*)"],["(*())"],["(*)()"]]
```

**解析：** 使用递归解析字符串，并考虑 * 的特殊处理。

#### 16. 最大子序和

**题目：** 给你一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**示例：**
```python
def maxSubArray(nums):
    if not nums:
        return 0
    max_sum = nums[0]
    cur_sum = nums[0]
    for i in range(1, len(nums)):
        cur_sum = max(nums[i], cur_sum + nums[i])
        max_sum = max(max_sum, cur_sum)
    return max_sum

# 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
# 输出：6
```

**解析：** 使用动态规划，当前最大和为前一个最大和和当前元素的最大值。

#### 17. 回文子串

**题目：** 给定一个字符串 s，返回不同的回文子串的数量。

**示例：**
```python
def countSubstrings(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    ans = 0
    for i in range(n):
        dp[i][i] = True
        ans += 1
    for j in range(n - 1, -1, -1):
        for i in range(j + 1, n):
            if s[i] == s[j]:
                dp[j][i] = (i - j < 2) or dp[j + 1][i - 1]
                if dp[j][i]:
                    ans += 1
    return ans

# 输入：s = "abca"
# 输出：5
```

**解析：** 使用动态规划，判断子串是否为回文，并计数。

#### 18. 搜索旋转排序数组

**题目：** 给定一个排序好的数组，你需要在数组中查找一个目标值，该数组已经按照升序和旋转排序。

**示例：**
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

# 输入：nums = [4,5,6,7,0,1,2], target = 0
# 输出：4
```

**解析：** 使用二分查找，同时考虑旋转数组的特点。

#### 19. 汇总区间

**题目：** 给定一个无序的整数数组 nums，返回其中不含有重复数字的最短连续子序列。子序列中所有数字必须按升序排列。

**示例：**
```python
from collections import defaultdict

def shortestUnsortedContinuousSubarray(nums):
    min_val, max_val = min(nums), max(nums)
    left, right = 0, 0
    for i, num in enumerate(nums):
        min_val = min(min_val, num)
        max_val = max(max_val, num)
        if num < min_val or num > max_val:
            left = i
            max_val = max(max_val, num)
    for i in range(len(nums) - 1, -1, -1):
        num = nums[i]
        if num < min_val or num > max_val:
            right = i
            min_val = min(min_val, num)
    return right - left + 1

# 输入：nums = [1,2,4,5]
# 输出：1
```

**解析：** 找到最小值和最大值，然后遍历数组找到最短子序列。

#### 20. 合并区间

**题目：** 给你一个区间列表，请你合并所有重叠的区间。

**示例：**
```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last = ans[-1]
        if interval[0] <= last[1]:
            last[1] = max(last[1], interval[1])
        else:
            ans.append(interval)
    return ans

# 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
# 输出：[[1,6],[8,10],[15,18]]
```

**解析：** 使用排序和双指针，合并重叠区间。

#### 21. 岛屿数量

**题目：** 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

**示例：**
```python
def numIslands(grid):
    def dfs(i, j):
        grid[i][j] = '0'
        for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            x, y = i + a, j + b
            if 0 <= x < m and 0 <= y < n and grid[x][y] == '1':
                dfs(x, y)

    m, n = len(grid), len(grid[0])
    ans = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                dfs(i, j)
                ans += 1
    return ans

# 输入：grid = [
#   ["1", "1", "1", "1", "0"],
#   ["1", "1", "0", "1", "0"],
#   ["1", "1", "0", "1", "0"],
#   ["1", "1", "1", "1", "0"]
# ]
# 输出：1
```

**解析：** 使用深度优先搜索（DFS）标记岛屿，并计数。

#### 22. 寻找旋转排序数组中的最小值

**题目：** 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，找出并返回数组中的最小元素。

**示例：**
```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

# 输入：nums = [3,4,5,1,2]
# 输出：1
```

**解析：** 使用二分查找，找到最小元素。

#### 23. 子数组的最小值之和

**题目：** 给你一个整数数组 arr 和一个整数 k 。你需要将数组 arr 分成 k 个子数组。满足：

- 对于所有 1 <= i <= k ，子数组 arr[i] 的元素都是严格递增的。
- 子数组 arr[i] 有可能为空，也就是说不含任何元素。

你的任务是找出符合题意的 k 子数组划分，使得所有子数组中的元素之和最小。

**示例：**
```python
def minSumOfSubarrays(arr, k):
    n = len(arr)
    pre = [0] * (n + 1)
    for i in range(1, n + 1):
        pre[i] = pre[i - 1] + arr[i - 1]
    ans = float('inf')
    for j in range(1, n - k + 1):
        left = pre[j] - pre[0]
        right = pre[n] - pre[j + k]
        ans = min(ans, left + right)
    return ans

# 输入：arr = [3,5,6,7], k = 2
# 输出：6
```

**解析：** 使用前缀和和双指针，计算每个窗口的最小和。

#### 24. 求最大值

**题目：** 给定一个长度为 n 的数组 arr ，返回 arr 中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例：**
```python
def findKthLargest(nums, k):
    nums.sort(reverse=True)
    return nums[k - 1]

# 输入：nums = [3,2,1,5,6,4], k = 2
# 输出：5
```

**解析：** 使用排序，然后取第 k 个最大的元素。

#### 25. 逆波兰表达式求值

**题目：** 给你一个有效的括号字符串表示的一个二叉树，请你将其还原为二叉树并返回。结果应该层序遍历序列化表示它，其中序列化值由字符串表示，并且没有 " \n"。

**示例：**
```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def deserializejalonenodevolution(expression):
    def dfs(queue):
        node = queue.popleft()
        if node.val == ',':
            return None
        node.left = dfs(queue)
        node.right = dfs(queue)
        return node

    queue = deque([TreeNode(ord(c) - ord('0')) for c in expression if c != ','])
    root = dfs(queue)
    while queue:
        node = queue.popleft()
        if node.left is not None:
            node.val = node.left.val
            queue.append(node.left)
        if node.right is not None:
            node.val = node.right.val
            queue.append(node.right)
    return root

# 输入：expression = "1,2,3,4,null,null,5,6,null,null,null,7,8,9"
# 输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**解析：** 使用队列和递归，将逆波兰表达式还原为二叉树。

#### 26. 设计前缀树

**题目：** 设计一个前缀树（字典树）的数据结构。它可以用于高效地查找一个字符串列表中的字符串，设计一个搜索建议的函数 search 去实现这个功能：

- search(prefix)：搜索给定的前缀，返回以该前缀开头的字符串列表。

**示例：**
```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, word):
        node = self
        for c in word:
            idx = ord(c) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end = True

    def search(self, prefix):
        node = self
        for c in prefix:
            idx = ord(c) - ord('a')
            if node.children[idx] is None:
                return []
            node = node.children[idx]
        return self.searchHelper(node, prefix)

    def searchHelper(self, node, prefix):
        ans = []
        if node.is_end:
            ans.append(prefix)
        for idx, child in enumerate(node.children):
            if child:
                next_prefix = prefix + chr(ord('a') + idx)
                ans.extend(self.searchHelper(child, next_prefix))
        return ans

# 输入：
# trie = Trie()
# trie.insert("apple")
# trie.insert("app")
# trie.insert("bat")
# trie.search("ap")
# 输出：["app", "apple"]

# 输入：
# trie = Trie()
# trie.insert("hello")
# trie.insert("hello")
# trie.search("hello")
# 输出：["hello", "hello"]
```

**解析：** 使用数组存储子节点，并标记单词的结尾。

#### 27. 设计有限集

**题目：** 设计一个有限集，实现 Add、Remove 和 Check functions。

- Add(value)：插入元素到集合中，如果该元素已经存在，则不进行任何操作；
- Remove(value)：从集合中移除元素，如果该元素不存在，则不进行任何操作；
- Check(value)：检查元素是否在集合中，返回 true 或 false。

**示例：**
```python
class CustomSet:
    def __init__(self):
        self.set = set()

    def add(self, value: int) -> None:
        self.set.add(value)

    def remove(self, value: int) -> None:
        self.set.discard(value)

    def check(self, value: int) -> bool:
        return value in self.set

# 输入：
# cs = CustomSet()
# cs.add(1)
# cs.add(2)
# cs.remove(1)
# cs.check(2)
# 输出：True
```

**解析：** 使用集合存储元素，实现快速插入、删除和查找。

#### 28. 滑动窗口平均值

**题目：** 给定一个数组和滑动窗口的大小，计算每一个滑动窗口中数字的平均值。

**示例：**
```python
def movingAverage(nums, size):
    ans = []
    window_sum = sum(nums[:size])
    ans.append(window_sum / size)
    for i in range(1, len(nums) - size + 1):
        window_sum += nums[i + size - 1] - nums[i - 1]
        ans.append(window_sum / size)
    return ans

# 输入：nums = [1,3,7,2], size = 3
# 输出：[1.0,2.0,4.0]
```

**解析：** 使用滑动窗口，计算每个窗口内的平均值。

#### 29. 数据流中的中位数

**题目：** 设计一个数据结构，实现获取数据流中第 k 大元素的功能。请实现 `MedianFinder` 类：

- MedianFinder() 初始化中位数类。
- void addNum(int num) 将元素添加到数据流中。
- int findMedian() 返回当前数据流的中位数。

**示例：**
```python
from sortedcontainers import SortedList

class MedianFinder:

    def __init__(self):
        self.l = SortedList()
        self.r = SortedList()

    def addNum(self, num: int) -> None:
        if len(self.l) == len(self.r):
            self.r.add(num)
            self.l.add(self.r.pop())
        else:
            self.l.add(num)
            self.r.add(self.l.pop())

    def findMedian(self) -> int:
        if len(self.l) > len(self.r):
            return self.l[-1]
        else:
            return (self.l[-1] + self.r[-1]) // 2

# 输入：
# mf = MedianFinder()
# mf.addNum(1)
# mf.addNum(2)
# mf.findMedian()
# 输出：1.5
```

**解析：** 使用两个排序链表，一个保存较小的一半，一个保存较大的一半，中位数取决于两个链表的大小。

#### 30. 寻找峰值元素

**题目：** 在一个数组中，找到峰值元素。峰值元素是指其值大于左右相邻值的元素。

**示例：**
```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[mid + 1]:
            right = mid
        else:
            left = mid + 1
    return left

# 输入：nums = [1,2,3,1]
# 输出：2
```

**解析：** 使用二分查找，找到峰值元素。

以上是2024年字节跳动校招算法岗位的典型面试题目汇编，涵盖了数组、链表、二叉树、动态规划、排序等多个知识点，希望对备战字节跳动校招的同学们有所帮助。持续关注我们的更新，了解更多面试题和算法编程题的解析。祝大家面试成功！

