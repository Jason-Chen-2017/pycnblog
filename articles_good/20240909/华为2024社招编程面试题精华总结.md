                 

# 华为2024社招编程面试题精华总结

## 1. 链表相关题目

### 1.1. 删除链表的节点

**题目：** 给定一个单链表和一个节点，删除该节点。

**答案：** 要删除链表中的一个节点，首先判断该节点是否为链表尾节点。如果是，则需修改前一个节点的 `next` 指针为 `nil`。如果该节点不是尾节点，则将前一个节点的 `next` 指针指向当前节点的 `next` 指针，然后释放当前节点的内存。

```go
func deleteNode(head *ListNode, node *ListNode) *ListNode {
    if node == nil || head == nil {
        return head
    }
    if node == head {
        head = head.Next
    } else {
        nodePre := head
        for nodePre != nil && nodePre.Next != node {
            nodePre = nodePre.Next
        }
        if nodePre != nil {
            nodePre.Next = node.Next
        }
    }
    return head
}
```

### 1.2. 反转链表

**题目：** 给定一个单链表，实现一个函数，反转链表。

**答案：** 通过迭代或递归方式，将当前节点的 `next` 指针指向其前一个节点，实现链表反转。

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head
    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}
```

### 1.3. 合并两个有序链表

**题目：** 给定两个有序链表，实现一个函数，合并这两个有序链表。

**答案：** 创建一个新的链表，然后遍历两个链表，比较当前节点值，将较小值的节点添加到新链表中，并移动对应的链表指针。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

## 2. 数组相关题目

### 2.1. 数组中重复的元素

**题目：** 给定一个整数数组，找出重复的元素。

**答案：** 可以使用哈希表或排序方法来找出重复的元素。以下是一种使用哈希表的实现：

```go
func findDuplicates(nums []int) []int {
    m := make(map[int]int)
    res := []int{}
    for _, num := range nums {
        if v, ok := m[num]; ok {
            if v == 1 {
                res = append(res, num)
            }
            m[num]++
        } else {
            m[num] = 1
        }
    }
    return res
}
```

### 2.2. 数组中的第K个最大元素

**题目：** 给定一个整数数组和一个整数 k，找到数组中的第 k 个最大元素。

**答案：** 可以使用快速选择算法或堆排序算法。以下是一种使用快速选择算法的实现：

```go
func findKthLargest(nums []int, k int) int {
    n := len(nums)
    target := n - k
    var partition func([]int, int, int) int
    partition = func(nums []int, l, r int) int {
        pivot := nums[r]
        i := l
        for j := l; j < r; j++ {
            if nums[j] > pivot {
                nums[i], nums[j] = nums[j], nums[i]
                i++
            }
        }
        nums[i], nums[r] = nums[r], nums[i]
        return i
    }
    for l, r := 0, n-1; l < r; {
        p := partition(nums, l, r)
        if p == target {
            return nums[p]
        } else if p < target {
            l = p + 1
        } else {
            r = p - 1
        }
    }
    return nums[l]
}
```

## 3. 二叉树相关题目

### 3.1. 二叉树的层序遍历

**题目：** 实现一个函数，完成二叉树的层序遍历。

**答案：** 可以使用队列实现层序遍历。

```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }
    res := [][]int{}
    q := []*TreeNode{root}
    for len(q) > 0 {
        t := []int{}
        for i := 0; i < len(q); i++ {
            node := q[i]
            t = append(t, node.Val)
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        res = append(res, t)
        q = q[len(q):]
    }
    return res
}
```

### 3.2. 二叉搜索树的最近公共祖先

**题目：** 给定一个二叉搜索树和两个节点 p 和 q，找到它们的最近公共祖先。

**答案：** 由于二叉搜索树的特点，我们可以通过比较 p 和 q 的值与当前节点的值来找到它们的最近公共祖先。

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    if root.Val > p.Val && root.Val > q.Val {
        return lowestCommonAncestor(root.Left, p, q)
    } else if root.Val < p.Val && root.Val < q.Val {
        return lowestCommonAncestor(root.Right, p, q)
    }
    return root
}
```

## 4. 字符串相关题目

### 4.1. 字符串匹配（KMP算法）

**题目：** 实现字符串匹配算法，找出字符串 s 中的子串 t 的第一个匹配位置。

**答案：** KMP算法通过构建部分匹配表（Next数组）来优化字符串匹配过程。以下是一种 KMP算法的实现：

```go
func strStr(s, t string) int {
    if t == "" || s == "" {
        return 0
    }
    p, i, n := 0, 0, len(s)
    next := make([]int, n+1)
    next[0], next[1] = -1, 0
    for i = 1; i < n; i++ {
        if t[p] == s[i] {
            next[i+1] = next[i] + 1
            p++
        } else {
            if p > 0 {
                p = next[p]
                i--
            } else {
                next[i+1] = 0
            }
        }
    }
    if p < len(t) {
        return n - len(t) + next[n]
    }
    return -1
}
```

### 4.2. 字符串转换整数（atoi）

**题目：** 实现函数，将字符串转换为整数。

**答案：** 遍历字符串，根据ASCII码计算数字，同时处理符号、溢出等特殊情况。

```go
func myAtoi(s string) int {
    const (
        maxInt32 = 1<<31 - 1
        minInt32 = -1 << 31
    )
    i, sign, ans := 0, 1, 0
    for i < len(s) && s[i] == ' ' {
        i++
    }
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        sign = 1 - 2 * (s[i] == '-')
        i++
    }
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        ans = ans*10 + int(s[i]-'0')
        if ans > maxInt32 {
            return maxInt32*sign
        }
        i++
    }
    return ans * sign
}
```

## 5. 图相关题目

### 5.1. 单源最短路径（Dijkstra算法）

**题目：** 给定一个带权重的无向图和起点，实现单源最短路径算法。

**答案：** Dijkstra算法使用优先队列（最小堆）来选择当前未处理的距离最小的节点。

```go
import "container/heap"

type Item struct {
    Value    int // The value of the item; integer type
    Index    int // The index of the item in the original slice
    Priority int // The priority of the item in the heap
}

type PriorityQueue []*Item

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    // We want Pop to give us the highest, not lowest, priority so we use greater than here.
    return pq[i].Priority < pq[j].Priority
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    item := x.(*Item)
    *pq = append(*pq, item)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    old[n-1] = nil // avoid memory leak
    *pq = old[0 : n-1]
    return item
}

func dijkstra(edges [][]int, src int) (dist []int) {
    n := len(edges)
    dist = make([]int, n)
    dist[src] = 0
    pq := &PriorityQueue{}
    item := &Item{
        Value:    src,
        Index:    src,
        Priority: 0,
    }
    heap.Push(pq, item)
    for pq.Len() > 0 {
        item = heap.Pop(pq).(*Item)
        u := item.Value
        if dist[u] < item.Priority {
            continue
        }
        for _, edge := range edges[u] {
            v, w := edge[0], edge[1]
            if dist[v] > dist[u]+w {
                dist[v] = dist[u] + w
                item := &Item{
                    Value:    v,
                    Index:    v,
                    Priority: dist[v],
                }
                heap.Push(pq, item)
            }
        }
    }
    return
}
```

### 5.2. 图的深度优先搜索（DFS）

**题目：** 给定一个无向图和起点，实现深度优先搜索算法。

**答案：** DFS算法可以通过递归或迭代方式实现。

```go
// 递归实现
func dfs(graph map[int][]int, v int, visited *map[int]bool) {
    (*visited)[v] = true
    for _, w := range graph[v] {
        if !(*visited)[w] {
            dfs(graph, w, visited)
        }
    }
}

// 迭代实现
func dfsIter(graph map[int][]int, v int) {
    visited := make(map[int]bool)
    stack := []int{v}
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if !visited[node] {
            visited[node] = true
            for _, w := range graph[node] {
                if !visited[w] {
                    stack = append(stack, w)
                }
            }
        }
    }
}
```

## 6. 动态规划相关题目

### 6.1. 最长递增子序列

**题目：** 给定一个整数数组，找出最长递增子序列的长度。

**答案：** 动态规划算法，使用一个数组 `dp` 存储以每个位置为结尾的最长递增子序列的长度。

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = 1
    for i := 1; i < len(nums); i++ {
        maxLen := 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                maxLen = max(maxLen, dp[j]+1)
            }
        }
        dp[i] = maxLen
    }
    return max(dp...)
}
```

### 6.2. 不同路径

**题目：** 给定一个 m 行 n 列的网格，求从左上角到右下角的不同路径数量。

**答案：** 动态规划算法，可以使用一个二维数组 `dp` 来存储到达每个位置的不同路径数量。

```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i == 0 || j == 0 {
                dp[i][j] = 1
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }
    return dp[m-1][n-1]
}
```

## 7. 数学相关题目

### 7.1. 素数判定

**题目：** 判断一个整数是否为素数。

**答案：** 可以通过试除法来判断一个数是否为素数。

```go
func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}
```

### 7.2. 最大子序和

**题目：** 给定一个整数数组，找出最大子序和。

**答案：** 动态规划算法，通过比较当前元素与当前元素加上前一个子序列的最大和来更新最大子序和。

```go
func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    maxEndingHere := nums[0]
    for i := 1; i < len(nums); i++ {
        maxEndingHere = max(maxEndingHere+nums[i], nums[i])
        maxSoFar = max(maxSoFar, maxEndingHere)
    }
    return maxSoFar
}
```

## 8. 算法设计与分析

### 8.1. 最大正方形

**题目：** 给定一个矩阵，找到最大的正方形子矩阵。

**答案：** 动态规划算法，通过计算以每个单元格为右下角的最大正方形边长。

```go
func maximalSquare(matrix [][]byte) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }
    m, n := len(matrix), len(matrix[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    maxSide := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == '1' {
                if i == 0 || j == 0 {
                    dp[i][j] = 1
                } else {
                    dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1
                }
                maxSide = max(maxSide, dp[i][j])
            }
        }
    }
    return maxSide * maxSide
}
```

### 8.2. 合并区间

**题目：** 给定一组区间，合并重叠的区间。

**答案：** 可以通过排序区间然后合并相邻重叠区间的方法来实现。

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    res := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        prev := res[len(res)-1]
        if intervals[i][0] <= prev[1] {
            prev[1] = max(prev[1], intervals[i][1])
        } else {
            res = append(res, intervals[i])
        }
    }
    return res
}
```

## 9. 系统设计相关题目

### 9.1. 负载均衡算法

**题目：** 实现一个负载均衡算法。

**答案：** 负载均衡算法有多种实现方式，以下是一种基于轮询的负载均衡算法。

```go
type LoadBalancer struct {
    servers []*Server
    index   int
}

type Server struct {
    IP      string
    Weight  int
}

func NewLoadBalancer(servers []*Server) *LoadBalancer {
    lb := &LoadBalancer{
        servers: servers,
        index:   0,
    }
    sort.Slice(servers, func(i, j int) bool {
        return servers[i].Weight > servers[j].Weight
    })
    return lb
}

func (lb *LoadBalancer) Next() *Server {
    server := lb.servers[lb.index]
    lb.index = (lb.index + 1) % len(lb.servers)
    return server
}
```

### 9.2. 缓存一致性协议

**题目：** 设计一个缓存一致性协议。

**答案：** 缓存一致性协议有多种，以下是一种基于消息传递的缓存一致性协议。

```go
type Cache struct {
    data map[string]string
    net  Network
}

type Network struct {
    Send func(sender, receiver string, msg interface{})
}

func (c *Cache) Update(key, value string) {
    c.data[key] = value
    c.net.Send("CPU", key, value)
}

func (c *Cache) Get(key string) (string, bool) {
    if val, ok := c.data[key]; ok {
        return val, true
    }
    val := c.net.Receive("CPU", key)
    c.data[key] = val
    return val, true
}
```

## 10. 编码与解码

### 10.1. 序列化和反序列化二叉树

**题目：** 实现二叉树的序列化和反序列化。

**答案：** 可以使用前序遍历进行序列化，使用前序遍历和递归来实现反序列化。

```go
func serialize(root *TreeNode) string {
    if root == nil {
        return "null"
    }
    return fmt.Sprintf("%d,%s", root.Val, serialize(root.Left)+serialize(root.Right))
}

func deserialize(data string) *TreeNode {
    values := strings.Split(data, ",")
    var build func() *TreeNode
    build = func() *TreeNode {
        if values[0] == "null" {
            values = values[1:]
            return nil
        }
        node := &TreeNode{Val: atoi(values[0])}
        values = values[1:]
        node.Left = build()
        node.Right = build()
        return node
    }
    return build()
}
```

### 10.2. 序列化和反序列化字符串

**题目：** 实现字符串的序列化和反序列化。

**答案：** 可以使用 Base64 编码进行序列化和反序列化。

```go
import (
    "encoding/base64"
    "strings"
)

func serialize(s string) string {
    return base64.StdEncoding.EncodeToString([]byte(s))
}

func deserialize(s string) string {
    bytes, _ := base64.StdEncoding.DecodeString(s)
    return string(bytes)
}
```

## 11. 其他面试题

### 11.1. 单调栈

**题目：** 实现一个单调栈，用于解决一些问题，如：下一个更大元素、下一个更小元素。

**答案：** 单调栈用于维护一个递增或递减的栈，用于快速找到下一个更大或更小的元素。

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    m := make(map[int]int)
    for _, num := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] <= num {
            stack = stack[:len(stack)-1]
        }
        if len(stack) > 0 {
            m[num] = stack[len(stack)-1]
        }
        stack = append(stack, num)
    }
    res := make([]int, len(nums1))
    for i, num := range nums1 {
        res[i] = m[num]
    }
    return res
}
```

### 11.2. 有限状态机

**题目：** 实现一个有限状态机，用于处理字符串匹配问题。

**答案：** 有限状态机（FSM）是一种用于表示有限个状态以及在这些状态之间转换的模型。

```go
type FSM struct {
    states    map[string]int
    transitions map[string]map[string]int
}

func (f *FSM) AddState(name string, state int) {
    f.states[name] = state
}

func (f *FSM) AddTransition(from string, to string, state int) {
    if f.transitions[from] == nil {
        f.transitions[from] = make(map[string]int)
    }
    f.transitions[from][to] = state
}

func (f *FSM) Run(input string) int {
    state := 0
    for _, char := range input {
        state = f.transitions[string(char)][state]
    }
    return state
}
```

### 11.3. 计算器

**题目：** 实现一个计算器，支持加、减、乘、除等运算。

**答案：** 可以使用栈实现计算器，处理四则运算。

```go
type Calculator struct {
    stack Stack
}

func (c *Calculator) Calculate(expression string) int {
    for _, char := range expression {
        switch char {
        case '+':
            a := c.stack.Pop()
            b := c.stack.Pop()
            c.stack.Push(a+b)
        case '-':
            a := c.stack.Pop()
            b := c.stack.Pop()
            c.stack.Push(b-a)
        case '*':
            a := c.stack.Pop()
            b := c.stack.Pop()
            c.stack.Push(a * b)
        case '/':
            a := c.stack.Pop()
            b := c.stack.Pop()
            c.stack.Push(b / a)
        default:
            c.stack.Push(int(char - '0'))
        }
    }
    return c.stack.Pop()
}
```

### 11.4. 快速幂算法

**题目：** 实现快速幂算法。

**答案：** 快速幂算法通过递归或迭代方式，减少幂运算的次数。

```go
func quickPow(base int, exp int) int {
    if exp == 0 {
        return 1
    }
    if exp%2 == 0 {
        half := quickPow(base, exp/2)
        return half * half
    } else {
        return base * quickPow(base, exp-1)
    }
}
```

### 11.5. 设计一个栈

**题目：** 设计一个具有最小元素的栈。

**答案：** 可以使用两个栈，一个用于存储元素，另一个用于存储当前最小元素。

```go
type MinStack struct {
    stack  Stack
    minStack Stack
}

func (m *MinStack) Push(val int) {
    m.stack.Push(val)
    if m.minStack.Len() == 0 || val <= m.minStack.Peek().(int) {
        m.minStack.Push(val)
    }
}

func (m *MinStack) Pop() {
    if m.stack.Peek().(int) == m.minStack.Peek().(int) {
        m.minStack.Pop()
    }
    m.stack.Pop()
}

func (m *MinStack) Top() int {
    return m.stack.Peek().(int)
}

func (m *MinStack) GetMin() int {
    return m.minStack.Peek().(int)
}
```

### 11.6. 设计一个队列

**题目：** 设计一个支持循环队列的队列。

**答案：** 可以使用数组实现循环队列，通过头部和尾部的指针来维护队列的状态。

```go
type CircularQueue struct {
    data []int
    head int
    tail int
}

func NewCircularQueue(capacity int) *CircularQueue {
    return &CircularQueue{
        data: make([]int, capacity),
    }
}

func (q *CircularQueue) EnQueue(value int) {
    q.data[q.tail] = value
    q.tail = (q.tail + 1) % len(q.data)
}

func (q *CircularQueue) DeQueue() bool {
    if q.head == q.tail {
        return false
    }
    q.head = (q.head + 1) % len(q.data)
    return true
}

func (q *CircularQueue) Front() int {
    if q.head == q.tail {
        return -1
    }
    return q.data[q.head]
}

func (q *CircularQueue) Rear() int {
    if q.head == q.tail {
        return -1
    }
    return q.data[(q.tail-1+len(q.data))%len(q.data)]
}
```

### 11.7. 设计一个哈希表

**题目：** 设计一个哈希表。

**答案：** 可以使用拉链法解决哈希冲突，使用链表作为哈希表的桶。

```go
type HashTable struct {
    Buckets []*LinkedList
    Size     int
}

func NewHashTable(size int) *HashTable {
    return &HashTable{
        Buckets: make([]*LinkedList, size),
        Size:    size,
    }
}

type LinkedListNode struct {
    Key   interface{}
    Value interface{}
    Next  *LinkedListNode
}

type LinkedList struct {
    Head *LinkedListNode
    Tail *LinkedListNode
}

func (l *LinkedList) Insert(key, value interface{}) {
    newNode := &LinkedListNode{Key: key, Value: value}
    if l.Head == nil {
        l.Head = newNode
        l.Tail = newNode
    } else {
        l.Tail.Next = newNode
        l.Tail = newNode
    }
}

func (h *HashTable) Insert(key, value interface{}) {
    index := hash(key, h.Size)
    if h.Buckets[index] == nil {
        h.Buckets[index] = &LinkedList{}
    }
    h.Buckets[index].Insert(key, value)
}

func (h *HashTable) Get(key interface{}) (interface{}, bool) {
    index := hash(key, h.Size)
    if h.Buckets[index] == nil {
        return nil, false
    }
    node := h.Buckets[index].Head
    for node != nil {
        if node.Key == key {
            return node.Value, true
        }
        node = node.Next
    }
    return nil, false
}
```

### 11.8. 设计一个优先级队列

**题目：** 设计一个优先级队列。

**答案：** 可以使用最小堆实现优先级队列。

```go
import (
    "container/heap"
)

type PriorityQueue []interface{}

func (pq PriorityQueue) Len() int { return len(pq) }

func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].(int) < pq[j].(int)
}

func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x)
}

func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    x := old[len(old)-1]
    *pq = old[0 : len(old)-1]
    return x
}

type Item struct {
    Value    int    // The value of the item; integer type
    Priority int    // The priority of the item in the heap
    Index    int    // The index of the item in the heap
}

func (pq *PriorityQueue) PushItem(item *Item) {
    item.Index = len(*pq)
    *pq = append(*pq, item)
    heap.Fix(pq, item.Index)
}

func (pq *PriorityQueue) PopItem() *Item {
    item := heap.Pop(pq).(*Item)
    return item
}
```

### 11.9. 设计一个最小生成树

**题目：** 设计一个最小生成树。

**答案：** 可以使用 Prim 算法或 Kruskal 算法来实现最小生成树。

```go
// Prim算法
func prim(edges [][]int, n int) (int, [][]int) {
    mst := [][]int{}
    key := make([]int, n)
    visited := make([]bool, n)
    key[0] = 0
    for i := 0; i < n; i++ {
        u := -1
        minKey := INT_MAX
        for j := 0; j < n; j++ {
            if !visited[j] && key[j] < minKey {
                u = j
                minKey = key[j]
            }
        }
        if u == -1 {
            break
        }
        visited[u] = true
        mst = append(mst, edges[u])
        for j := 0; j < n; j++ {
            if !visited[j] && edges[u][j] < key[j] {
                key[j] = edges[u][j]
            }
        }
    }
    return sumEdges(mst), mst
}

// Kruskal算法
type Edge struct {
    u, v, weight int
}

type EdgeSort []Edge

func (es EdgeSort) Less(i, j int) bool {
    return es[i].weight < es[j].weight
}

func (es EdgeSort) Swap(i, j int) {
    es[i], es[j] = es[j], es[i]
}

func (es EdgeSort) Len() int {
    return len(es)
}

func kruskal(edges [][]int, n int) (int, [][]int) {
    mst := [][]int{}
    union := make([]int, n)
    for i := range union {
        union[i] = i
    }
    es := EdgeSort{}
    for _, e := range edges {
        es = append(es, Edge{u: e[0], v: e[1], weight: e[2]})
    }
    sort.Sort(es)
    mstCount := 0
    for _, e := range es {
        rootU := find(union, e.u)
        rootV := find(union, e.v)
        if rootU != rootV {
            union[rootU] = rootV
            mst = append(mst, []int{e.u, e.v, e.weight})
            mstCount++
            if mstCount == n-1 {
                break
            }
        }
    }
    return sumEdges(mst), mst
}

func sumEdges(edges [][]int) int {
    sum := 0
    for _, e := range edges {
        sum += e[2]
    }
    return sum
}

func find(union []int, p int) int {
    if union[p] != p {
        union[p] = find(union, union[p])
    }
    return union[p]
}
```

### 11.10. 设计一个字典树

**题目：** 设计一个字典树（Trie）。

**答案：** 字典树是一种用于存储字符串的树形结构，通过减少重复字符串的存储来提高空间效率。

```go
type TrieNode struct {
    children [26]*TrieNode
    isEnd    bool
}

type Trie struct {
    root *TrieNode
}

func NewTrie() *Trie {
    return &Trie{
        root: &TrieNode{},
    }
}

func (t *Trie) Insert(word string) {
    node := t.root
    for _, ch := range word {
        idx := ch - 'a'
        if node.children[idx] == nil {
            node.children[idx] = &TrieNode{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t.root
    for _, ch := range word {
        idx := ch - 'a'
        if node.children[idx] == nil {
            return false
        }
        node = node.children[idx]
    }
    return node.isEnd
}
```

### 11.11. 设计一个LRU缓存

**题目：** 设计一个LRU（Least Recently Used）缓存。

**答案：** LRU缓存通过记录访问顺序来实现缓存淘汰策略。

```go
type LRUCache struct {
    capacity int
    items    map[int]*Node
    head, tail *Node
}

type Node struct {
    key   int
    value int
    prev  *Node
    next  *Node
}

func Constructor(capacity int) LRUCache {
    cache := LRUCache{
        capacity: capacity,
        items:    map[int]*Node{},
    }
    cache.head = &Node{}
    cache.tail = &Node{}
    cache.head.next = cache.tail
    cache.tail.prev = cache.head
    return cache
}

func (this *LRUCache) Get(key int) int {
    if _, ok := this.items[key]; !ok {
        return -1
    }
    node := this.items[key]
    this.moveToFront(node)
    return node.value
}

func (this *LRUCache) Put(key int, value int) {
    if _, ok := this.items[key]; ok {
        node := this.items[key]
        node.value = value
        this.moveToFront(node)
        return
    }
    node := &Node{key: key, value: value}
    this.items[key] = node
    this.addToFront(node)
    if len(this.items) > this.capacity {
        this.removeFromTail()
    }
}

func (this *LRUCache) moveToFront(node *Node) {
    this.removeFromNode(node)
    this.addToFront(node)
}

func (this *LRUCache) removeFromNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) addToFront(node *Node) {
    node.next = this.head.next
    node.prev = this.head
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeFromTail() {
    node := this.tail.prev
    this.removeFromNode(node)
    delete(this.items, node.key)
}
```

