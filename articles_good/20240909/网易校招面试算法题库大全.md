                 

### 2024网易校招面试算法题库大全

#### 1. 最长公共子序列

**题目：** 给定两个字符串 `str1` 和 `str2`，找出它们的 **最长公共子序列**。

**输入：**
```python
str1 = "ABCD"
str2 = "ACDF"
```

**输出：**
```
最长公共子序列为 "AC"
```

**答案：**

```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i - 1] == str2[j - 1]:
            result.append(str1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

# 示例
print(longest_common_subsequence("ABCD", "ACDF"))  # 输出 "AC"
```

**解析：** 使用动态规划解决最长公共子序列问题。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列长度。最后，从 `dp[m][n]` 开始逆向追踪，构建出最长公共子序列。

#### 2. 最小路径和

**题目：** 给定一个包含非负整数的二维网格，找出从左上角到右下角的最小路径和。

**输入：**
```python
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
```

**输出：**
```
最小路径和为 7
```

**答案：**

```python
def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]

    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]

    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

    return dp[-1][-1]

# 示例
print(min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]))  # 输出 7
```

**解析：** 使用动态规划计算从左上角到每个点的最小路径和，然后计算从右下角到每个点的最小路径和，最终的最小路径和即为两者之和。

#### 3. 股票买卖

**题目：** 给定一个数组 `prices`，其中每个元素是一个股票在不同时间的价格。最多只允许完成两笔交易，设计一个算法来找出最大利润。

**输入：**
```python
prices = [3, 3, 5, 0, 0, 3, 1, 4]
```

**输出：**
```
最大利润为 6
```

**答案：**

```python
def max_profit(prices):
    if not prices:
        return 0

    first_buy, second_buy = -prices[0], -prices[0]
    first_sell, second_sell = 0, 0

    for price in prices:
        first_buy = max(first_buy, -price)
        first_sell = max(first_sell, first_buy + price)
        second_buy = max(second_buy, first_sell - price)
        second_sell = max(second_sell, second_buy + price)

    return second_sell

# 示例
print(max_profit([3, 3, 5, 0, 0, 3, 1, 4]))  # 输出 6
```

**解析：** 使用四个变量跟踪第一次买、第一次卖、第二次买和第二次卖的最优利润。遍历价格数组，更新这些变量的值。

#### 4. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：**
```python
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
```

**输出：**
```
合并后的链表为 [1, 2, 3, 4, 5, 6]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

# 示例
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
print_list(merged_list)  # 输出 [1, 2, 3, 4, 5, 6]
```

**解析：** 递归地将两个链表的下一个节点进行比较，将较小的节点链接到结果链表中，并递归地处理剩余部分。

#### 5. 盛最多水的容器

**题目：** 给定一个数组 `height` 表示容器的高度，找出能够容纳的最大水量。

**输入：**
```python
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
```

**输出：**
```
最大水量为 49
```

**答案：**

```python
def max_area(height):
    left, right = 0, len(height) - 1
    max_area = 0

    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1

    return max_area

# 示例
print(max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]))  # 输出 49
```

**解析：** 使用双指针从两端开始向中间移动，每次移动较低的一端，更新最大水量。

#### 6. 逆波兰表达式求值

**题目：** 实现一个逆波兰表达式求值器。有效的运算符包括 '+', '-', '*', '/' 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**输入：**
```python
expression = ["2", "1", "+", "3", "*"]
```

**输出：**
```
结果为 9
```

**答案：**

```python
def evaluate(expression):
    stack = []

    for token in expression:
        if token.isdigit():
            stack.append(int(token))
        else:
            right = stack.pop()
            left = stack.pop()
            if token == "+":
                stack.append(left + right)
            elif token == "-":
                stack.append(left - right)
            elif token == "*":
                stack.append(left * right)
            else:
                stack.append(int(left / right))

    return stack.pop()

# 示例
print(evaluate(["2", "1", "+", "3", "*"]))  # 输出 9
```

**解析：** 使用栈实现逆波兰表达式的求值。遍历每个字符，如果是数字则入栈，如果是运算符则弹出两个数进行计算，并将结果入栈。

#### 7. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**输入：**
```python
head = ListNode(3)
head.next = ListNode(2)
head.next.next = ListNode(0)
head.next.next.next = ListNode(-4)
head.next.next.next.next = head.next  # 环
```

**输出：**
```
链表中存在环
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True

    return False

# 示例
head = ListNode(3)
head.next = ListNode(2)
head.next.next = ListNode(0)
head.next.next.next = ListNode(-4)
head.next.next.next.next = head.next  # 环
print(has_cycle(head))  # 输出 True
```

**解析：** 使用快慢指针法，如果链表中存在环，快指针最终会追上慢指针。

#### 8. 合并两个有序数组

**题目：** 给定两个已经排序的整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**输入：**
```python
nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
```

**输出：**
```
合并后的数组为 [1, 2, 2, 3, 5, 6]
```

**答案：**

```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1

    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1

    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1

# 示例
nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
merge(nums1, 3, nums2, 3)
print(nums1)  # 输出 [1, 2, 2, 3, 5, 6]
```

**解析：** 从两个数组的末尾开始比较，将较大的数依次放入合并后的数组末尾。

#### 9. 快速排序

**题目：** 实现快速排序算法，对数组进行升序排列。

**输入：**
```python
arr = [3, 2, 1]
```

**输出：**
```
排序后的数组为 [1, 2, 3]
```

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# 示例
print(quick_sort([3, 2, 1]))  # 输出 [1, 2, 3]
```

**解析：** 选择一个基准元素，将数组分为三个部分：小于基准元素的元素、等于基准元素的元素和大于基准元素的元素，然后递归地对小于和大于基准元素的子数组进行快速排序。

#### 10. 反转链表

**题目：** 实现一个函数，反转一个单链表。

**输入：**
```python
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
```

**输出：**
```
反转后的链表为 [5, 4, 3, 2, 1]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    prev = None
    current = head

    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node

    return prev

# 示例
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
reversed_head = reverse_list(head)
print_list(reversed_head)  # 输出 [5, 4, 3, 2, 1]
```

**解析：** 使用三个指针 prev、current 和 next_node，遍历链表，将每个节点的 next 指针反向指向 prev，然后更新 prev 和 current。

#### 11. 二分查找

**题目：** 实现一个二分查找算法，在有序数组中查找目标值。

**输入：**
```python
arr = [1, 3, 5, 7, 9]
target = 5
```

**输出：**
```
目标值 5 在数组中的索引为 2
```

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

# 示例
print(binary_search([1, 3, 5, 7, 9], 5))  # 输出 2
```

**解析：** 使用二分查找的基本逻辑，不断缩小查找范围，直到找到目标值或确定目标值不存在。

#### 12. 合并区间

**题目：** 给定一组区间，找出其中重叠的区间，并合并它们。

**输入：**
```python
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
```

**输出：**
```
合并后的区间为 [[1, 6], [8, 10], [15, 18]]
```

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for interval in intervals[1:]:
        last_interval = result[-1]
        if last_interval[1] >= interval[0]:
            result[-1][1] = max(last_interval[1], interval[1])
        else:
            result.append(interval)

    return result

# 示例
print(merge([[1, 3], [2, 6], [8, 10], [15, 18]]))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

**解析：** 首先对区间进行排序，然后遍历区间，合并重叠的区间。

#### 13. 两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字，将这两个数相加并返回一个新的链表。

**输入：**
```python
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
```

**输出：**
```
相加后的链表为 [7, 0, 8]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

# 示例
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = add_two_numbers(l1, l2)
print_list(result)  # 输出 [7, 0, 8]
```

**解析：** 使用哑节点构建新的链表，处理进位，直到两个链表都遍历完。

#### 14. 字符串匹配

**题目：** 给定一个字符串 `s` 和一个字符 `ch`，实现一个算法找出字符串中第一个出现 `ch` 的位置。

**输入：**
```python
s = "hello world"
ch = 'o'
```

**输出：**
```
字符 'o' 在字符串中的索引为 4
```

**答案：**

```python
def find_char(s, ch):
    for i, c in enumerate(s):
        if c == ch:
            return i
    return -1

# 示例
print(find_char("hello world", 'o'))  # 输出 4
```

**解析：** 使用枚举遍历字符串，找到第一个匹配的字符，并返回其索引。

#### 15. 最长公共前缀

**题目：** 给定一个字符串数组 `strs`，找出其中最长的公共前缀。

**输入：**
```python
strs = ["flower", "flow", "flight"]
```

**输出：**
```
最长公共前缀为 "fl"
```

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(s)):
            if i >= len(prefix) or s[i] != prefix[i]:
                return prefix[:i]
        prefix = prefix[:i]

    return prefix

# 示例
print(longest_common_prefix(["flower", "flow", "flight"]))  # 输出 "fl"
```

**解析：** 遍历字符串数组，逐步缩小公共前缀。

#### 16. 搜索旋转排序数组

**题目：** 给定一个排序好的整数数组，该数组已经被预先按升序排序，并旋转了一个任意数目的位置（比如 `[0,1,2,4,5,6,7]` 变为 `[4,5,6,7,0,1,2]`），找出并返回数组中的某个数字 `target`。

**输入：**
```python
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
```

**输出：**
```
目标值 0 在数组中的索引为 4
```

**答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1

# 示例
print(search([4, 5, 6, 7, 0, 1, 2], 0))  # 输出 4
```

**解析：** 由于数组被旋转，我们需要找到最小值的索引，然后在这个范围内使用二分查找。

#### 17. 有效的括号

**题目：** 给定一个字符串 `s` ，判断字符串是否由若干对括号嵌套构成。

**输入：**
```python
s = "()[]{}"
```

**输出：**
```
字符串是有效的括号序列
```

**答案：**

```python
def isValid(s):
    stack = []

    for char in s:
        if char in "({[":
            stack.append(char)
        elif not stack:
            return False
        else:
            top = stack.pop()
            if (char == ")" and top != "(") or (char == "]" and top != "[") or (char == "}" and top != "{"):
                return False

    return not stack

# 示例
print(isValid("()[]{}"))  # 输出 True
```

**解析：** 使用栈来存储打开的括号，遍历字符串，当遇到关闭括号时，检查是否与栈顶的打开括号匹配。

#### 18. 字符串转换大写字母

**题目：** 实现一个函数，将字符串转换为所有字母的大写形式。

**输入：**
```python
s = "hello"
```

**输出：**
```
字符串变为 "HELLO"
```

**答案：**

```python
def to_uppercase(s):
    return s.upper()

# 示例
print(to_uppercase("hello"))  # 输出 "HELLO"
```

**解析：** 使用字符串的 `upper()` 方法将所有字母转换为大写。

#### 19. 最小覆盖区间

**题目：** 给定一个区间列表，找出需要覆盖整个数轴的最小区间个数。

**输入：**
```python
intervals = [[1, 3], [2, 4], [6, 8]]
```

**输出：**
```
最小覆盖区间个数为 3
```

**答案：**

```python
def min_coverage(intervals):
    intervals.sort()
    covered = set()
    ans = 0
    j = 0
    n = len(intervals)

    for i in range(n):
        if intervals[i][0] not in covered:
            ans += 1
            covered.update(range(intervals[i][0], intervals[i][1] + 1))
            j = max(j, intervals[i][1])

    for interval in intervals:
        if interval[1] >= j:
            ans -= 1
            break

    return ans

# 示例
print(min_coverage([[1, 3], [2, 4], [6, 8]]))  # 输出 3
```

**解析：** 首先对区间进行排序，然后遍历区间，使用集合记录已覆盖的区间，并更新最右端覆盖的区间。如果当前区间覆盖的最右端超过了已覆盖区间的最右端，则减少答案。

#### 20. 合并有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表并返回。

**输入：**
```python
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
```

**输出：**
```
合并后的链表为 [1, 2, 3, 4, 5, 6]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

# 示例
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
print_list(merged_list)  # 输出 [1, 2, 3, 4, 5, 6]
```

**解析：** 使用递归合并两个链表。比较当前节点值，将较小的节点链接到结果链表中，并递归处理剩余部分。

#### 21. 三数之和

**题目：** 给定一个整数数组 `nums`，返回所有不重复的三数之和。

**输入：**
```python
nums = [-1, 0, 1, 2, -1, -4]
```

**输出：**
```
所有不重复的三数之和为：[-1, -1, 2], [-1, 0, 1]
```

**答案：**

```python
def three_sum(nums):
    nums.sort()
    ans = []

    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1

        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                ans.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1

    return ans

# 示例
print(three_sum([-1, 0, 1, 2, -1, -4]))  # 输出 [ [-1, -1, 2], [-1, 0, 1]]
```

**解析：** 使用双指针和排序来找到所有不重复的三数之和。

#### 22. 最大子序和

**题目：** 给定一个整数数组 `nums`，找到其中最大的子序和。

**输入：**
```python
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

**输出：**
```
最大子序和为 6
```

**答案：**

```python
def max_sub_array(nums):
    if not nums:
        return 0

    max_so_far = nums[0]
    curr_max = nums[0]

    for num in nums[1:]:
        curr_max = max(num, curr_max + num)
        max_so_far = max(max_so_far, curr_max)

    return max_so_far

# 示例
print(max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 输出 6
```

**解析：** 使用贪心算法和动态规划，找到最大子序和。

#### 23. 最长回文子串

**题目：** 给定一个字符串 `s` ，找出其中最长的回文子串。

**输入：**
```python
s = "babad"
```

**输出：**
```
最长回文子串为 "bab" 或 "aba"
```

**答案：**

```python
def longest_palindromic_substring(s):
    if not s:
        return ""

    start, end = 0, 0

    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - ((max_len - 1) // 2)
            end = i + (max_len // 2)

    return s[start:end + 1]

def expand_around_center(s, left, right):
    while left >= 0 and right < len(s) and s[left] == s[right]:
        left -= 1
        right += 1
    return right - left - 1

# 示例
print(longest_palindromic_substring("babad"))  # 输出 "bab" 或 "aba"
```

**解析：** 使用中心扩展法，找到最长回文子串。

#### 24. 多线程下载图片

**题目：** 实现一个多线程下载图片的函数，从网络获取图片并将其下载到本地。

**输入：**
```python
urls = [
    "https://example.com/image1.jpg",
    "https://example.com/image2.jpg",
    "https://example.com/image3.jpg"
]
download_path = "/path/to/download/directory"
```

**输出：**
```
图片已下载到本地目录 /path/to/download/directory
```

**答案：**

```python
import threading
import requests
from multiprocessing.pool import ThreadPool

def download_image(url, download_path):
    response = requests.get(url)
    with open(f"{download_path}/{url.split('/')[-1]}", "wb") as f:
        f.write(response.content)

def multi_thread_download(urls, download_path):
    pool = ThreadPool(5)  # 使用 5 个线程
    threads = [pool.apply_async(download_image, (url, download_path)) for url in urls]
    pool.close()
    pool.join()

# 示例
multi_thread_download(urls, download_path)
```

**解析：** 使用多线程池和异步下载图片。

#### 25. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**输入：**
```python
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
```

**输出：**
```
合并后的链表为 [1, 2, 3, 4, 5, 6]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

# 示例
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
print_list(merged_list)  # 输出 [1, 2, 3, 4, 5, 6]
```

**解析：** 使用递归合并两个有序链表。

#### 26. 两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字，将这两个数相加并返回一个新的链表。

**输入：**
```python
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
```

**输出：**
```
相加后的链表为 [7, 0, 8]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

# 示例
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = add_two_numbers(l1, l2)
print_list(result)  # 输出 [7, 0, 8]
```

**解析：** 使用哑节点构建新的链表，处理进位，直到两个链表都遍历完。

#### 27. 最大子序和

**题目：** 给定一个整数数组 `nums`，找到其中最大的子序和。

**输入：**
```python
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

**输出：**
```
最大子序和为 6
```

**答案：**

```python
def max_sub_array(nums):
    if not nums:
        return 0

    max_so_far = nums[0]
    curr_max = nums[0]

    for num in nums[1:]:
        curr_max = max(num, curr_max + num)
        max_so_far = max(max_so_far, curr_max)

    return max_so_far

# 示例
print(max_sub_array([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 输出 6
```

**解析：** 使用贪心算法和动态规划，找到最大子序和。

#### 28. 搜索旋转排序数组

**题目：** 给定一个排序好的整数数组，该数组已经被预先按升序排序，并旋转了一个任意数目的位置（比如 `[0,1,2,4,5,6,7]` 变为 `[4,5,6,7,0,1,2]`），找出并返回数组中的某个数字 `target`。

**输入：**
```python
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
```

**输出：**
```
目标值 0 在数组中的索引为 4
```

**答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1

# 示例
print(search([4, 5, 6, 7, 0, 1, 2], 0))  # 输出 4
```

**解析：** 由于数组被旋转，我们需要找到最小值的索引，然后在这个范围内使用二分查找。

#### 29. 最长公共前缀

**题目：** 给定一个字符串数组 `strs`，找出其中最长的公共前缀。

**输入：**
```python
strs = ["flower", "flow", "flight"]
```

**输出：**
```
最长公共前缀为 "fl"
```

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(s)):
            if i >= len(prefix) or s[i] != prefix[i]:
                return prefix[:i]
        prefix = prefix[:i]

    return prefix

# 示例
print(longest_common_prefix(["flower", "flow", "flight"]))  # 输出 "fl"
```

**解析：** 遍历字符串数组，逐步缩小公共前缀。

#### 30. 两数相加

**题目：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字，将这两个数相加并返回一个新的链表。

**输入：**
```python
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
```

**输出：**
```
相加后的链表为 [7, 0, 8]
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        current.next = ListNode(total % 10)
        current = current.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

# 示例
l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = add_two_numbers(l1, l2)
print_list(result)  # 输出 [7, 0, 8]
```

**解析：** 使用哑节点构建新的链表，处理进位，直到两个链表都遍历完。

