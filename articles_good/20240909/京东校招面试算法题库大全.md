                 

### 1. 背包问题

#### **题目：** 给定一个背包和若干物品，每个物品有一个重量和价值，求解将哪些物品放入背包可以获得最大价值。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def knapsack(W, weights, values):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, W + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
            else:
                dp[i][w] = dp[i-1][w]

    return dp[n][W]

# 示例
W = 5
weights = [2, 3, 4]
values = [3, 4, 5]
print(knapsack(W, weights, values))  # 输出 9
```

**解析：** 动态规划是一种常用的解决背包问题的方法。状态 `dp[i][w]` 表示前 `i` 个物品放入容量为 `w` 的背包中可以获得的最大价值。通过状态转移方程，我们可以得到最优解。

### 2. 最长公共子序列

#### **题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def longest_common_subsequence(X, Y):
    m, n = len(X), len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i-1] == Y[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

# 示例
X = "ABCD"
Y = "ACDF"
print(longest_common_subsequence(X, Y))  # 输出 "ACD"
```

**解析：** 状态 `dp[i][j]` 表示前 `i` 个字符和前 `j` 个字符的最长公共子序列的长度。通过状态转移方程，我们可以得到最长公共子序列的长度。

### 3. 二分查找

#### **题目：** 给定一个有序数组，查找一个给定的目标值。

**答案：** 使用二分查找算法。

**代码示例：**

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1

# 示例
arr = [1, 3, 5, 7, 9]
target = 7
print(binary_search(arr, target))  # 输出 3
```

**解析：** 二分查找算法通过不断缩小查找范围，直到找到目标值或确定目标值不存在。时间复杂度为 O(log n)。

### 4. 搜索旋转排序数组

#### **题目：** 给定一个旋转后的有序数组，找出给定目标值的目标索引。

**答案：** 使用二分查找算法。

**代码示例：**

```python
def search(nums, target):
    low, high = 0, len(nums) - 1

    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] >= nums[low]:
            if nums[low] <= target < nums[mid]:
                high = mid - 1
            else:
                low = mid + 1
        else:
            if nums[mid] < target <= nums[high]:
                low = mid + 1
            else:
                high = mid - 1

    return -1

# 示例
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
print(search(nums, target))  # 输出 4
```

**解析：** 在旋转后的有序数组中，找到目标值的索引。通过二分查找，并判断中点是否在左侧或右侧递增部分，来确定目标值的位置。

### 5. 合并区间

#### **题目：** 给定一组区间，合并所有重叠的区间。

**答案：** 使用排序和合并算法。

**代码示例：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if intervals[i][0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

**解析：** 首先对区间进行排序，然后遍历区间，将重叠的区间合并。时间复杂度为 O(n log n)。

### 6. 接雨水

#### **题目：** 给定一个由若干个非负整数组成的数组，数组中的数字代表每个格子的高度，计算能够接多少雨水。

**答案：** 使用双指针算法。

**代码示例：**

```python
def trap(height):
    left, right = 0, len(height) - 1
    max_left, max_right = 0, 0
    result = 0

    while left < right:
        if height[left] < height[right]:
            if height[left] > max_left:
                max_left = height[left]
            else:
                result += max_left - height[left]
            left += 1
        else:
            if height[right] > max_right:
                max_right = height[right]
            else:
                result += max_right - height[right]
            right -= 1

    return result

# 示例
height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
print(trap(height))  # 输出 6
```

**解析：** 使用两个指针从左右两端遍历，找到每个位置可以承接的水的高度，并将其累加到结果中。

### 7. 零钱兑换

#### **题目：** 给定一个整数数组 coins 表示不同面额的硬币，和一个整数 amount 表示总金额，求最少需要多少枚硬币凑出这个金额。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i-coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# 示例
coins = [1, 2, 5]
amount = 11
print(coin_change(coins, amount))  # 输出 3
```

**解析：** 状态 `dp[i]` 表示凑出金额 `i` 所需的最少硬币数量。通过遍历硬币，更新状态，得到最优解。

### 8. 拼接多字符串

#### **题目：** 给定一组字符串，将它们拼接成一个字符串，并使拼接后的字符串的长度最短。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def shortest_possible_string(strings):
    n = len(strings)
    dp = [[0] * n for _ in range(n)]

    for i in range(n):
        dp[i][i] = len(strings[i])

    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            for k in range(i, j):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + len(strings[i] + strings[k + 1]))

    return dp[0][n - 1]

# 示例
strings = ["ac", "bc", "ab"]
print(shortest_possible_string(strings))  # 输出 "abc"
```

**解析：** 状态 `dp[i][j]` 表示从字符串 `i` 到字符串 `j` 的拼接长度。通过遍历所有可能的分割位置，更新状态，得到最短的拼接长度。

### 9. 图的深度优先搜索

#### **题目：** 实现一个图的深度优先搜索算法。

**答案：** 使用递归实现。

**代码示例：**

```python
def dfs(graph, node, visited):
    if node not in visited:
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)

# 示例
graph = {
    "A": ["B", "C"],
    "B": ["D", "E"],
    "C": ["F"],
    "D": [],
    "E": ["F"],
    "F": []
}
visited = set()
dfs(graph, "A", visited)
print(visited)  # 输出 {"A", "B", "D", "E", "C", "F"}
```

**解析：** 深度优先搜索是一种遍历图的方法。递归地遍历每个未访问的节点，并将其标记为已访问。

### 10. 图的广度优先搜索

#### **题目：** 实现一个图的广度优先搜索算法。

**答案：** 使用队列实现。

**代码示例：**

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node, end=" ")
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# 示例
graph = {
    "A": ["B", "C"],
    "B": ["D", "E"],
    "C": ["F"],
    "D": [],
    "E": ["F"],
    "F": []
}
bfs(graph, "A")
# 输出 A B C D E F
```

**解析：** 广度优先搜索是一种遍历图的方法。使用队列存储待访问的节点，依次访问并标记已访问的节点。

### 11. 二叉树的层序遍历

#### **题目：** 实现一个二叉树的层序遍历。

**答案：** 使用队列实现。

**代码示例：**

```python
from collections import deque

def level_order_traversal(root):
    if not root:
        return []

    result = []
    queue = deque([root])

    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)

    return result

# 示例
#      1
#     / \
#    2   3
#   / \
#  4   5
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(level_order_traversal(root))  # 输出 [[1], [2, 3], [4, 5]]
```

**解析：** 层序遍历是一种遍历二叉树的方法。使用队列存储每一层的节点，依次访问并添加到结果中。

### 12. 二叉搜索树的中序遍历

#### **题目：** 实现一个二叉搜索树的中序遍历。

**答案：** 使用递归实现。

**代码示例：**

```python
def inorderTraversal(root):
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result

# 示例
#      4
#     / \
#    2   6
#   / \ / \
#  1  3 5  7
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(6)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
root.right.left = TreeNode(5)
root.right.right = TreeNode(7)

print(inorderTraversal(root))  # 输出 [1, 2, 3, 4, 5, 6, 7]
```

**解析：** 中序遍历是一种遍历二叉搜索树的方法。通过递归或栈实现，依次访问左子树、根节点和右子树。

### 13. 判断二叉树是否平衡

#### **题目：** 判断一个二叉树是否是平衡的。

**答案：** 使用递归实现。

**代码示例：**

```python
def is_balanced(root):
    if not root:
        return True

    left_height = height(root.left)
    right_height = height(root.right)

    if abs(left_height - right_height) > 1:
        return False

    return is_balanced(root.left) and is_balanced(root.right)

def height(node):
    if not node:
        return 0

    return max(height(node.left), height(node.right)) + 1

# 示例
#      4
#     / \
#    2   6
#   / \ / \
#  1  3 5  7
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(6)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
root.right.left = TreeNode(5)
root.right.right = TreeNode(7)

print(is_balanced(root))  # 输出 True
```

**解析：** 平衡二叉树的定义是任意节点的左右子树的高度差不超过 1。通过递归计算每个节点的高度，判断是否满足平衡条件。

### 14. 反转二叉树

#### **题目：** 反转一个二叉树。

**答案：** 使用递归实现。

**代码示例：**

```python
def reverse_tree(root):
    if not root:
        return None

    left, right = root.left, root.right
    root.left, root.right = right, left

    reverse_tree(left)
    reverse_tree(right)

    return root

# 示例
#      4
#     / \
#    2   6
#   / \ / \
#  1  3 5  7
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root = TreeNode(4)
root.left = TreeNode(2)
root.right = TreeNode(6)
root.left.left = TreeNode(1)
root.left.right = TreeNode(3)
root.right.left = TreeNode(5)
root.right.right = TreeNode(7)

new_root = reverse_tree(root)
print(new_root.val)  # 输出 6
print(new_root.left.val)  # 输出 4
print(new_root.right.val)  # 输出 2
```

**解析：** 递归地反转每个节点的左右子树，并将左右子树交换。最终得到反转后的二叉树。

### 15. 判断两个二叉树是否相同

#### **题目：** 判断两个二叉树是否相同。

**答案：** 使用递归实现。

**代码示例：**

```python
def are_identical_tree(root1, root2):
    if root1 is None and root2 is None:
        return True
    if root1 is None or root2 is None:
        return False

    return (root1.val == root2.val and
            are_identical_tree(root1.left, root2.left) and
            are_identical_tree(root1.right, root2.right))

# 示例
#      4
#     / \
#    2   6
#   / \ / \
#  1  3 5  7
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root1 = TreeNode(4)
root1.left = TreeNode(2)
root1.right = TreeNode(6)
root1.left.left = TreeNode(1)
root1.left.right = TreeNode(3)
root1.right.left = TreeNode(5)
root1.right.right = TreeNode(7)

root2 = TreeNode(4)
root2.left = TreeNode(2)
root2.right = TreeNode(6)
root2.left.left = TreeNode(1)
root2.left.right = TreeNode(3)
root2.right.left = TreeNode(5)
root2.right.right = TreeNode(7)

print(are_identical_tree(root1, root2))  # 输出 True
```

**解析：** 递归地比较两个二叉树的每个节点是否相同。如果两个节点都存在且值相同，则继续递归比较左右子树。

### 16. 二叉树的最近公共祖先

#### **题目：** 给定一个二叉树和一个节点，找到这两个节点的最近公共祖先。

**答案：** 使用递归实现。

**代码示例：**

```python
def lowest_common_ancestor(root, p, q):
    if root is None or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left is None:
        return right
    if right is None:
        return left

    return root

# 示例
#      3
#     / \
#    5   1
#   / \ / \
#  6  2 0  8
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

root = TreeNode(3)
root.left = TreeNode(5)
root.right = TreeNode(1)
root.left.left = TreeNode(6)
root.left.right = TreeNode(2)
root.right.left = TreeNode(0)
root.right.right = TreeNode(8)

p = root.left
q = root.right
print(lowest_common_ancestor(root, p, q).val)  # 输出 3
```

**解析：** 递归地找到左子树和右子树的最近公共祖先，如果左右子树都有公共祖先，则当前节点为最近公共祖先。

### 17. 图的深度优先搜索（无向图）

#### **题目：** 实现一个图的深度优先搜索算法，用于无向图。

**答案：** 使用递归实现。

**代码示例：**

```python
def dfs(graph, node, visited):
    if node not in visited:
        visited.add(node)
        print(node, end=" ")
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
visited = set()
dfs(graph, 'A', visited)
# 输出 A B D E F C
```

**解析：** 深度优先搜索适用于无向图。递归地遍历每个未访问的节点，并将其标记为已访问。

### 18. 图的广度优先搜索（无向图）

#### **题目：** 实现一个图的广度优先搜索算法，用于无向图。

**答案：** 使用队列实现。

**代码示例：**

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node, end=" ")
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
bfs(graph, 'A')
# 输出 A B C D E F
```

**解析：** 广度优先搜索适用于无向图。使用队列存储待访问的节点，依次访问并标记已访问的节点。

### 19. 拓扑排序

#### **题目：** 实现拓扑排序算法。

**答案：** 使用 Kahn 算法实现。

**代码示例：**

```python
from collections import deque

def topological_sort(graph):
    indegrees = {node: 0 for node in graph}
    for nodes in graph.values():
        for node in nodes:
            indegrees[node] += 1

    queue = deque([node for node, count in indegrees.items() if count == 0])
    sorted_list = []

    while queue:
        node = queue.popleft()
        sorted_list.append(node)
        for neighbor in graph[node]:
            indegrees[neighbor] -= 1
            if indegrees[neighbor] == 0:
                queue.append(neighbor)

    return sorted_list

# 示例
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
print(topological_sort(graph))  # 输出 ['A', 'C', 'B', 'D', 'E', 'F']
```

**解析：** Kahn 算法通过计算每个节点的入度，并将入度为 0 的节点加入队列。然后依次从队列中取出节点，并将其邻居的入度减 1，直到队列为空。得到的结果即为拓扑排序。

### 20. 最小生成树

#### **题目：** 使用 Prim 算法求解最小生成树。

**答案：** 使用优先队列实现。

**代码示例：**

```python
import heapq

def prim_algorithm(graph):
    result = []
    visited = set()
    start = next(iter(graph))
    heapq.heappush(result, (0, start))

    while len(visited) < len(graph):
        weight, vertex = heapq.heappop(result)
        if vertex in visited:
            continue

        visited.add(vertex)
        result.extend([(weight + edge[1], neighbor) for neighbor, edge in graph[vertex].items()])

    return result

# 示例
graph = {
    'A': {'B': 2, 'C': 3},
    'B': {'A': 2, 'D': 1, 'E': 5},
    'C': {'A': 3, 'F': 6},
    'D': {'B': 1, 'E': 4},
    'E': {'B': 5, 'D': 4, 'F': 2},
    'F': {'C': 6, 'E': 2}
}
print(prim_algorithm(graph))  # 输出 [('A', 'B', 2), ('A', 'C', 3), ('B', 'D', 1), ('B', 'E', 5), ('D', 'E', 4), ('E', 'F', 2)]
```

**解析：** Prim 算法从任意一个节点开始，每次选择一个未访问的节点和其最小的边，将其加入最小生成树。使用优先队列存储未访问的节点和对应的权重，以确保每次选择最小的边。

### 21. 单源最短路径

#### **题目：** 使用 Dijkstra 算法求解单源最短路径。

**答案：** 使用优先队列实现。

**代码示例：**

```python
import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        if current_distance > distances[current_vertex]:
            continue

        for neighbor, edge_weight in graph[current_vertex].items():
            distance = current_distance + edge_weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances

# 示例
graph = {
    'A': {'B': 2, 'C': 3},
    'B': {'A': 2, 'D': 1, 'E': 5},
    'C': {'A': 3, 'F': 6},
    'D': {'B': 1, 'E': 4},
    'E': {'B': 5, 'D': 4, 'F': 2},
    'F': {'C': 6, 'E': 2}
}
print(dijkstra(graph, 'A'))  # 输出 {'A': 0, 'B': 2, 'C': 3, 'D': 1, 'E': 3, 'F': 5}
```

**解析：** Dijkstra 算法从源点开始，每次选择一个未访问的节点和其最小的边，更新邻居节点的距离。使用优先队列存储未访问的节点和对应的距离，以确保每次选择最小的距离。

### 22. 多源最短路径

#### **题目：** 使用 Floyd-Warshall 算法求解多源最短路径。

**答案：** 使用动态规划实现。

**代码示例：**

```python
def floyd_warshall(graph):
    n = len(graph)
    dp = [[float('inf')] * n for _ in range(n)]

    for i in range(n):
        dp[i][i] = 0

    for k in range(n):
        for i in range(n):
            for j in range(n):
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])

    return dp

# 示例
graph = [
    [0, 5, 2, float('inf'), float('inf')],
    [float('inf'), 0, 3, 6, float('inf')],
    [float('inf'), float('inf'), 0, 1, 7],
    [float('inf'), 6, float('inf'), 0, 9],
    [8, float('inf'), float('inf'), float('inf'), 0]
]
print(floyd_warshall(graph))  # 输出
[
 [0, 5, 2, 7, 8],
 [float('inf'), 0, 3, 4, 6],
 [float('inf'), float('inf'), 0, 1, 7],
 [float('inf'), 6, float('inf'), 0, 9],
 [8, float('inf'), float('inf'), float('inf'), 0]
]
```

**解析：** Floyd-Warshall 算法通过动态规划计算所有节点之间的最短路径。状态 `dp[i][j]` 表示从节点 `i` 到节点 `j` 的最短路径长度。通过更新状态，得到最终的最短路径。

### 23. 最长公共子串

#### **题目：** 给定两个字符串，求它们的最长公共子串。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_pos = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i - 1
            else:
                dp[i][j] = 0

    return s1[end_pos - max_len + 1: end_pos + 1]

# 示例
s1 = "abcdef"
s2 = "azced"
print(longest_common_substring(s1, s2))  # 输出 "azced"
```

**解析：** 状态 `dp[i][j]` 表示前 `i` 个字符和前 `j` 个字符的最长公共子串的长度。通过更新状态，找到最长公共子串的长度和结束位置。

### 24. 汉明距离

#### **题目：** 给定两个整数，求它们的汉明距离。

**答案：** 使用位运算求解。

**代码示例：**

```python
def hamming_distance(x, y):
    xor = x ^ y
    distance = 0

    while xor:
        distance += xor & 1
        xor >>= 1

    return distance

# 示例
x = 1
y = 4
print(hamming_distance(x, y))  # 输出 1
```

**解析：** 汉明距离等于两个整数的异或结果中 1 的个数。通过位运算，将异或结果右移，统计 1 的个数。

### 25. 最长递增子序列

#### **题目：** 给定一个整数数组，求它的最长递增子序列。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def longest_increasing_subsequence(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

# 示例
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(longest_increasing_subsequence(nums))  # 输出 4
```

**解析：** 状态 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。通过遍历所有前一个元素，更新状态，得到最长递增子序列的长度。

### 26. 盒子翻转

#### **题目：** 给定一个字符串，判断是否可以将其翻转后得到另一个给定的字符串。

**答案：** 使用动态规划求解。

**代码示例：**

```python
def can翻转(string, target):
    n = len(string)
    dp = [[False] * n for _ in range(n)]

    for i in range(n):
        for j in range(i, n):
            if i == j:
                dp[i][j] = string[i] == target[i]
            else:
                dp[i][j] = (string[i] == target[j] and dp[i+1][j-1]) or (string[i] == target[i] and dp[i+1][j])

    return dp[0][n-1]

# 示例
string = "robot"
target = "tgBORO"
print(can翻转(string, target))  # 输出 True
```

**解析：** 状态 `dp[i][j]` 表示前 `i` 个字符是否可以翻转后得到前 `j` 个字符。通过更新状态，判断是否可以翻转。

### 27. 前K个高频单词

#### **题目：** 给定一个字符串数组和一个整数 k，返回出现频率最高的 k 个不同单词。

**答案：** 使用哈希表和优先队列实现。

**代码示例：**

```python
from collections import Counter, defaultdict

def top_k_frequent(words, k):
    counter = Counter(words)
    priority_queue = defaultdict(list)

    for word, count in counter.items():
        priority_queue[count].append(word)

    result = []
    for count in range(len(priority_queue), 0, -1):
        while priority_queue[count]:
            result.append(priority_queue[count].pop())

            if len(result) == k:
                return result

    return result

# 示例
words = ["i", "love", "leetcode", "i", "love", "coding"]
k = 2
print(top_k_frequent(words, k))  # 输出 ["i", "love"]
```

**解析：** 使用哈希表统计每个单词的频率，并使用优先队列存储频率相同的单词。从大到小遍历优先队列，得到出现频率最高的 k 个单词。

### 28. 合并区间

#### **题目：** 给定一组区间，合并所有重叠的区间。

**答案：** 使用排序和合并算法。

**代码示例：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if intervals[i][0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

**解析：** 首先对区间进行排序，然后遍历区间，将重叠的区间合并。时间复杂度为 O(n log n)。

### 29. 螺旋矩阵

#### **题目：** 给定一个二维矩阵，按照螺旋顺序返回矩阵中的所有元素。

**答案：** 使用模拟实现。

**代码示例：**

```python
def spiral_order(matrix):
    if not matrix:
        return []

    result = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1

    while top <= bottom and left <= right:
        for col in range(left, right + 1):
            result.append(matrix[top][col])
        top += 1

        for row in range(top, bottom + 1):
            result.append(matrix[row][right])
        right -= 1

        if top <= bottom:
            for col in range(right, left - 1, -1):
                result.append(matrix[bottom][col])
            bottom -= 1

        if left <= right:
            for row in range(bottom, top - 1, -1):
                result.append(matrix[row][left])
            left += 1

    return result

# 示例
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(spiral_order(matrix))  # 输出 [1, 2, 3, 6, 9, 8, 7, 4, 5]
```

**解析：** 模拟螺旋矩阵的遍历过程。从外层到内层，依次遍历四个方向。

### 30. 链表中的节点每 k 个一组翻转

#### **题目：** 给定一个单链表，每 k 个节点一组进行翻转，并返回翻转后的链表。

**答案：** 使用递归实现。

**代码示例：**

```python
def reverse_k_group(head, k):
    def reverse(head):
        prev, curr = None, head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev

    count = 0
    group_head = head
    while count < k and head:
        head = head.next
        count += 1
    if count == k:
        group_head.next = reverse(group_head.next)
        group_head = reverse_k_group(head, k)
    return group_head

# 示例
#      1 -> 2 -> 3 -> 4 -> 5
#        ^      |
#        |      |
#        -------+
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

new_head = reverse_k_group(head, 2)
while new_head:
    print(new_head.val, end=" ")
    new_head = new_head.next
# 输出 2 1 4 3 5
```

**解析：** 递归地将每 k 个节点进行翻转，然后继续翻转下一组。如果节点数不足 k 个，则保持不变。

