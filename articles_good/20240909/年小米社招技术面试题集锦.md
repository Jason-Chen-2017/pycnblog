                 

### 2024年小米社招技术面试题集锦

#### 一、编程题

**1. 不使用循环，实现一个函数，返回字符串中第一个不重复的字符。**

**题目：** 编写一个函数 `firstUniqChar(s: str) -> int`，返回字符串 `s` 中第一个不重复的字符的索引，如果不存在返回 `-1`。

**答案：** 可以使用哈希表统计每个字符出现的次数，然后遍历字符串，找到第一个出现次数为1的字符。

```python
def firstUniqChar(s):
    freq = {}
    for c in s:
        freq[c] = freq.get(c, 0) + 1
    for c in s:
        if freq[c] == 1:
            return s.index(c)
    return -1
```

**解析：** 该函数首先创建一个字典 `freq` 来记录每个字符的出现次数，然后遍历字符串 `s`，查找第一个出现次数为1的字符，并返回其索引。如果不存在，则返回 `-1`。

**2. 实现一个函数，判断一个二进制数是否是另一个二进制数的子序列。**

**题目：** 编写一个函数 `isSubSequence(A: str, B: str) -> bool`，判断二进制数 `A` 是否是二进制数 `B` 的子序列。

**答案：** 可以从 `A` 和 `B` 的开头开始遍历，若 `A` 的当前字符在 `B` 中出现，则继续比较 `A` 和 `B` 的下一个字符，否则返回 `False`。

```python
def isSubSequence(A, B):
    i, j = 0, 0
    while i < len(A) and j < len(B):
        if A[i] == B[j]:
            i += 1
        j += 1
    return i == len(A)
```

**解析：** 该函数使用两个指针 `i` 和 `j` 分别指向 `A` 和 `B`，如果 `A` 的当前字符在 `B` 中出现，则 `i` 移动到下一个字符，`j` 也移动到下一个字符，否则 `j` 移动到下一个字符。如果 `i` 到达 `A` 的末尾，则返回 `True`，否则返回 `False`。

**3. 实现一个函数，找出数组中第K大的元素。**

**题目：** 编写一个函数 `findKthLargest(nums: List[int], k: int) -> int`，找出数组 `nums` 中第 `k` 大的元素。

**答案：** 可以使用快速选择算法，时间复杂度为 O(n)。

```python
def findKthLargest(nums, k):
    left, right = 0, len(nums) - 1
    while True:
        pivot = nums[right]
        i = left
        for j in range(left, right):
            if nums[j] > pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[right] = nums[right], nums[i]
        if i == len(nums) - k:
            return nums[i]
        elif i < len(nums) - k:
            right = i - 1
        else:
            left = i + 1
```

**解析：** 该函数使用快速选择算法来找到第 `k` 大的元素。在每次迭代中，选择数组中的一个元素作为基准值（pivot），然后将数组分为两部分，大于 pivot 的元素放在 pivot 的右侧，小于 pivot 的元素放在 pivot 的左侧。根据 pivot 的位置来决定下一次迭代的范围。

#### 二、算法题

**4. 单调栈。**

**题目：** 实现一个单调栈，支持以下操作：push(x), pop(), top(), increase(k)。其中，push(x) 将元素 x 入栈，pop() 将栈顶元素出栈，top() 返回栈顶元素，increase(k) 将栈中所有小于 x 的元素的值增加 k。

**答案：**

```python
class MonotonicStack:
    def __init__(self):
        self.stack = []

    def push(self, x):
        while self.stack and self.stack[-1] < x:
            self.pop()
        self.stack.append(x)

    def pop(self):
        return self.stack.pop()

    def top(self):
        return self.stack[-1]

    def increase(self, k):
        while self.stack:
            if self.stack[-1] < k:
                self.pop()
            else:
                self.stack[-1] += k
```

**解析：** 在 `push(x)` 操作中，我们遍历栈顶元素，如果栈顶元素小于 x，则将其弹出，直到栈顶元素大于等于 x 或栈为空。在 `increase(k)` 操作中，我们遍历栈顶元素，如果栈顶元素小于 k，则将其弹出，并将 k 加到下一个元素上，否则将 k 加到当前元素上。

**5. 二分查找。**

**题目：** 给定一个无重复元素的有序数组 `nums` 和一个目标值 `target`，找出 `nums` 中最接近 `target` 的元素。

**答案：**

```python
def findClosestElement(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：** 该函数使用二分查找算法找到最接近 `target` 的元素。在每次迭代中，比较 `target` 与中间元素的大小，根据比较结果更新左右边界，直到找到最接近 `target` 的元素。

#### 三、系统设计题

**6. 设计一个缓存系统。**

**题目：** 设计一个缓存系统，支持以下操作：set(key, value)，get(key)。其中，set(key, value) 将键值对存入缓存，如果缓存已满，则将最早未使用的键值对替换；get(key) 返回键对应的值，如果键不存在，则返回 -1。

**答案：**

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.order = deque()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.order.remove(key)
        self.order.append(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.order.remove(key)
        elif len(self.cache) == self.capacity:
            k = self.order.popleft()
            del self.cache[k]
        self.cache[key] = value
        self.order.append(key)
```

**解析：** 该缓存系统使用哈希表和双端队列来实现。当缓存已满时，将最早未使用的键值对替换。在 `put` 操作中，如果缓存已满，则先将双端队列的左端元素（即最早未使用的键值对）出队，并将其从哈希表中删除。在 `get` 操作中，如果键存在，则将其移动到双端队列的右端。

**7. 设计一个博客系统。**

**题目：** 设计一个博客系统，支持以下操作：post(title: str, content: str)，get(id: int) -> str，delete(id: int)。其中，post(title, content) 将一篇文章的标题和内容存入系统，get(id) 返回文章的标题和内容，delete(id) 删除文章。

**答案：**

```python
class BlogSystem:
    def __init__(self):
        self.blogs = {}
        self.next_id = 1

    def post(self, title: str, content: str) -> int:
        id = self.next_id
        self.next_id += 1
        self.blogs[id] = (title, content)
        return id

    def get(self, id: int) -> str:
        if id not in self.blogs:
            return ""
        return self.blogs[id][1]

    def delete(self, id: int) -> None:
        if id in self.blogs:
            del self.blogs[id]
``` 

**解析：** 该博客系统使用哈希表和整数来存储文章的标题、内容和ID。在 `post` 操作中，生成新的ID，并将文章的标题和内容存储在哈希表中。在 `get` 操作中，根据ID获取文章的内容。在 `delete` 操作中，根据ID删除文章。

**8. 设计一个在线教育系统。**

**题目：** 设计一个在线教育系统，支持以下操作：addCourse(title: str)，enrollCourse(student: str, courseID: int)，listCourses(student: str) -> List[str]。其中，addCourse(title) 添加一门新的课程，enrollCourse(student, courseID) 将学生报名一门课程，listCourses(student) 列出学生已经报名的所有课程。

**答案：**

```python
class OnlineEducation:
    def __init__(self):
        self.courses = {}
        self.students = {}

    def addCourse(self, title: str) -> int:
        courseID = len(self.courses) + 1
        self.courses[courseID] = title
        return courseID

    def enrollCourse(self, student: str, courseID: int) -> None:
        if courseID not in self.courses:
            return
        if student not in self.students:
            self.students[student] = set()
        self.students[student].add(courseID)

    def listCourses(self, student: str) -> List[str]:
        if student not in self.students:
            return []
        courses = []
        for courseID in self.students[student]:
            courses.append(self.courses[courseID])
        return courses
```

**解析：** 该在线教育系统使用哈希表和集合来实现。在 `addCourse` 操作中，生成新的课程ID，并将课程信息存储在哈希表中。在 `enrollCourse` 操作中，将学生和课程ID关联起来。在 `listCourses` 操作中，返回学生已经报名的所有课程。

#### 四、数据结构题

**9. 实现一个栈。**

**题目：** 使用链表实现一个栈，支持以下操作：push(x), pop(), top(), isEmpty()。

**答案：**

```python
class Stack:
    def __init__(self):
        self.head = None
        self.size = 0

    def push(self, x):
        node = ListNode(x)
        node.next = self.head
        self.head = node
        self.size += 1

    def pop(self):
        if self.isEmpty():
            return
        node = self.head
        self.head = self.head.next
        node.next = None
        self.size -= 1
        return node.val

    def top(self):
        if self.isEmpty():
            return
        return self.head.val

    def isEmpty(self):
        return self.size == 0
```

**解析：** 该栈使用链表实现，通过在链表头部插入和删除节点来实现栈的操作。

**10. 实现一个队列。**

**题目：** 使用链表实现一个队列，支持以下操作：enqueue(x), dequeue(), front(), isEmpty()。

**答案：**

```python
class Queue:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def enqueue(self, x):
        node = ListNode(x)
        if self.isEmpty():
            self.head = node
        else:
            self.tail.next = node
        self.tail = node
        self.size += 1

    def dequeue(self):
        if self.isEmpty():
            return
        node = self.head
        self.head = self.head.next
        if self.isEmpty():
            self.tail = None
        node.next = None
        self.size -= 1
        return node.val

    def front(self):
        if self.isEmpty():
            return
        return self.head.val

    def isEmpty(self):
        return self.size == 0
```

**解析：** 该队列使用链表实现，通过在链表尾部插入和删除节点来实现队列的操作。

**11. 实现一个双端队列。**

**题目：** 使用链表实现一个双端队列，支持以下操作：enqueueFront(x), enqueueRear(x), dequeueFront(), dequeueRear(), front(), rear(), isEmpty()。

**答案：**

```python
class Deque:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def enqueueFront(self, x):
        node = ListNode(x)
        if self.isEmpty():
            self.head = node
            self.tail = node
        else:
            node.next = self.head
            self.head = node
        self.size += 1

    def enqueueRear(self, x):
        node = ListNode(x)
        if self.isEmpty():
            self.head = node
            self.tail = node
        else:
            self.tail.next = node
            self.tail = node
        self.size += 1

    def dequeueFront(self):
        if self.isEmpty():
            return
        node = self.head
        self.head = self.head.next
        if self.isEmpty():
            self.tail = None
        node.next = None
        self.size -= 1
        return node.val

    def dequeueRear(self):
        if self.isEmpty():
            return
        node = self.tail
        prev_tail = self.head
        while prev_tail.next != self.tail:
            prev_tail = prev_tail.next
        prev_tail.next = None
        self.tail = prev_tail
        node.next = None
        self.size -= 1
        return node.val

    def front(self):
        if self.isEmpty():
            return
        return self.head.val

    def rear(self):
        if self.isEmpty():
            return
        return self.tail.val

    def isEmpty(self):
        return self.size == 0
```

**解析：** 该双端队列使用链表实现，通过在链表头部和尾部插入和删除节点来实现双端队列的操作。

#### 五、数据库题

**12. 使用 SQL 查询满足条件的记录。**

**题目：** 表 `employees` 存储了公司所有员工的信息，字段包括 `id`, `name`, `salary`。编写 SQL 语句，查询薪资在 8000 到 10000 之间的员工姓名。

**答案：**

```sql
SELECT name FROM employees WHERE salary BETWEEN 8000 AND 10000;
```

**解析：** 该查询使用 `BETWEEN` 操作符来查询薪资在 8000 到 10000 之间的记录。

**13. 使用 SQL 进行分组和聚合。**

**题目：** 表 `sales` 存储了各月销售额的信息，字段包括 `month`, `amount`。编写 SQL 语句，查询每个月的总销售额，并按月份排序。

**答案：**

```sql
SELECT month, SUM(amount) as total_sales FROM sales GROUP BY month ORDER BY month;
```

**解析：** 该查询使用 `GROUP BY` 对 `month` 进行分组，使用 `SUM` 函数计算每个月的总销售额，并使用 `ORDER BY` 对月份进行排序。

**14. 使用 SQL 进行连接查询。**

**题目：** 表 `orders` 存储了订单信息，字段包括 `id`, `customer_id`，表 `customers` 存储了客户信息，字段包括 `id`, `name`。编写 SQL 语句，查询每个订单的客户名称。

**答案：**

```sql
SELECT orders.id, orders.customer_id, customers.name FROM orders
JOIN customers ON orders.customer_id = customers.id;
```

**解析：** 该查询使用 `JOIN` 操作将 `orders` 和 `customers` 表进行连接，使用 `ON` 子句指定连接条件。

#### 六、网络题

**15. HTTP 请求的常见状态码。**

**题目：** 列出 HTTP 请求的常见状态码，并解释每个状态码的含义。

**答案：**

| 状态码 | 含义 |
| --- | --- |
| 200 | 成功 |
| 201 | 创建成功 |
| 202 | 已接受 |
| 204 | 无内容 |
| 301 | 永久重定向 |
| 302 | 临时重定向 |
| 400 | 错误请求 |
| 401 | 未授权 |
| 403 | 禁止访问 |
| 404 | 未找到 |
| 500 | 内部服务器错误 |

**解析：** 这些状态码表示 HTTP 请求的结果。例如，200 表示请求成功，404 表示请求的资源未找到。

**16. HTTPS 工作原理。**

**题目：** 简要描述 HTTPS 的工作原理。

**答案：** HTTPS 是在 HTTP 上建立加密传输层的一种协议，工作原理如下：

1. 客户端发送请求，服务器发送证书。
2. 客户端验证证书是否有效，并生成随机数作为客户端密钥。
3. 客户端使用服务器的公钥加密客户端密钥，并发送给服务器。
4. 服务器使用私钥解密客户端密钥。
5. 服务器和客户端使用客户端密钥进行加密和解密通信。

**解析：** HTTPS 通过使用证书和对称加密算法，确保客户端和服务器之间的通信是加密的，防止中间人攻击。

#### 七、其他技术题

**17. 算法面试题：排序算法。**

**题目：** 请简要描述快速排序算法的过程。

**答案：** 快速排序算法的基本过程如下：

1. 选择一个基准元素。
2. 将数组分为两部分，一部分小于基准元素，一部分大于基准元素。
3. 对小于和大于基准元素的两个子数组重复步骤1和步骤2，直到所有子数组都是有序的。

**解析：** 快速排序算法通过递归调用，将数组划分为越来越小的子数组，然后对每个子数组进行排序，直到整个数组有序。

**18. 算法面试题：查找算法。**

**题目：** 请简要描述二分查找算法的过程。

**答案：** 二分查找算法的基本过程如下：

1. 确定中间元素。
2. 如果中间元素等于目标值，则返回中间元素的索引。
3. 如果中间元素大于目标值，则在左子数组中继续查找。
4. 如果中间元素小于目标值，则在右子数组中继续查找。
5. 重复步骤1至步骤4，直到找到目标值或子数组为空。

**解析：** 二分查找算法通过不断将查找范围缩小一半，从而实现高效查找。

**19. 算法面试题：动态规划。**

**题目：** 请简要描述动态规划解决最长公共子序列问题的过程。

**答案：** 动态规划解决最长公共子序列问题的基本过程如下：

1. 定义状态 dp[i][j]，表示字符串 A 的前 i 个字符和字符串 B 的前 j 个字符的最长公共子序列长度。
2. 初始化 dp[0][j] = dp[i][0] = 0，因为空字符串的最长公共子序列长度为 0。
3. 对于 i 从 1 到 m，j 从 1 到 n：
    - 如果 A[i-1] == B[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1。
    - 如果 A[i-1] != B[j-1]，则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。
4. 最终结果为 dp[m][n]。

**解析：** 动态规划通过将问题分解为子问题，并使用状态转移方程来计算最终结果，从而实现高效计算。

**20. 算法面试题：图算法。**

**题目：** 请简要描述 Dijkstra 算法求解单源最短路径的过程。

**答案：** Dijkstra 算法求解单源最短路径的基本过程如下：

1. 初始化距离数组 dist，其中 dist[v] 表示从源点 s 到达顶点 v 的最短距离，初始时 dist[s] = 0，dist[v] = ∞（无穷大）。
2. 创建一个优先队列，用于存储顶点和当前的最短距离。
3. 将源点 s 加入优先队列，优先级为 0。
4. 当优先队列为空时，重复以下步骤：
    - 弹出优先队列中的最小距离顶点 u。
    - 对于与 u 相邻的每个顶点 v：
        - 计算从 s 到 v 的距离 dist[v] = dist[u] + 边 (u, v) 的权重。
        - 如果 dist[v] < 原来的 dist[v]，则更新 dist[v]，并将 v 加入优先队列。
5. 最终结果为距离数组 dist，其中 dist[v] 表示从源点 s 到达顶点 v 的最短距离。

**解析：** Dijkstra 算法使用优先队列来选择下一个距离源点最近的顶点，并逐步更新所有顶点的最短距离。通过这种方式，可以找到从单源点出发到达其他所有顶点的最短路径。

**21. 算法面试题：字符串匹配。**

**题目：** 请简要描述 KMP 算法求解字符串匹配的过程。

**答案：** KMP 算法求解字符串匹配的基本过程如下：

1. 对于模式字符串 P，构建部分匹配表 next：
    - next[0] = -1
    - next[i] = max(next[i-1], longest non-border common substring length of P[0...i-1])
2. 使用 next 表和 i 指针遍历主字符串 S：
    - 当 S[i] != P[j] 时，i 左移，j = next[j]
    - 当 S[i] == P[j] 时，i 和 j 同时右移，更新 next[j+1]
3. 当 j 达到模式字符串长度时，说明匹配成功，返回起始位置 i - j。

**解析：** KMP 算法通过预处理模式字符串，使得当匹配失败时，可以跳过一些已匹配的部分，从而提高字符串匹配的效率。

**22. 操作系统面试题：进程调度算法。**

**题目：** 请简要描述时间片轮转调度算法的过程。

**答案：** 时间片轮转调度算法的基本过程如下：

1. 将所有进程放入就绪队列。
2. 调度器每次选择就绪队列的第一个进程执行。
3. 如果进程在执行过程中被中断，则将其放入就绪队列的末尾。
4. 当进程执行时间超过时间片时，将其中断，并将其放入就绪队列的末尾，同时选择就绪队列的第一个进程执行。

**解析：** 时间片轮转调度算法通过将CPU时间分配给每个进程，确保每个进程都能获得一定的执行时间，从而实现公平调度。

**23. 操作系统面试题：内存管理。**

**题目：** 请简要描述分页存储管理的方式。

**答案：** 分页存储管理的基本过程如下：

1. 将物理内存划分为固定大小的页框。
2. 将逻辑地址空间划分为固定大小的页。
3. 在内存管理器中维护一个页表，用于记录每个逻辑地址对应的物理页框。
4. 当进程访问逻辑地址时，先查页表找到对应的物理页框，然后从物理页框中读取数据。
5. 如果所需的页不在内存中，则发生页面缺失，内存管理器会从磁盘读取所需的页，并替换一个不常用的页。

**解析：** 分页存储管理通过将内存分为固定大小的块，从而简化内存管理，提高内存利用率。

**24. 计算机网络面试题：TCP 连接建立。**

**题目：** 请简要描述 TCP 连接建立的三个阶段。

**答案：** TCP 连接建立的三个阶段如下：

1. 三次握手：
    - 客户端发送 SYN 包到服务器，表示请求建立连接。
    - 服务器收到后，发送 SYN + ACK 包到客户端，表示同意建立连接。
    - 客户端收到后，发送 ACK 包到服务器，表示确认连接建立。
2. 数据传输：
    - 客户端和服务器开始传输数据。
3. 四次挥手：
    - 客户端发送 FIN 包到服务器，表示客户端请求断开连接。
    - 服务器收到后，发送 ACK 包到客户端，表示收到断开连接的请求。
    - 服务器发送 FIN 包到客户端，表示服务器请求断开连接。
    - 客户端收到后，发送 ACK 包到服务器，表示确认断开连接。

**解析：** TCP 连接建立通过三次握手来确保双方都同意建立连接，数据传输完成后，通过四次挥手来确保双方都同意断开连接。

**25. 计算机网络面试题：HTTP 请求和响应。**

**题目：** 请简要描述 HTTP 请求和响应的过程。

**答案：** HTTP 请求和响应的基本过程如下：

1. 客户端发起 HTTP 请求，包含请求行、请求头和请求体。
2. 服务器接收到请求后，处理请求并生成响应。
3. 响应包含状态行、响应头和响应体。
4. 服务器将响应发送给客户端。

**解析：** HTTP 请求和响应是通过客户端发送请求，服务器处理请求并返回响应的过程，HTTP 协议定义了请求和响应的格式。

**26. 软件工程面试题：设计模式。**

**题目：** 请简要描述单例模式的设计思路。

**答案：** 单例模式的设计思路如下：

1. 创建一个私有构造函数，防止外部直接实例化。
2. 创建一个静态私有成员变量，用于保存唯一的实例。
3. 创建一个公共静态方法，用于获取或创建单例。

**解析：** 单例模式确保一个类只有一个实例，并提供一个全局访问点，通过控制实例的创建和访问，实现单例。

**27. 软件工程面试题：软件测试。**

**题目：** 请简要描述黑盒测试和白盒测试的区别。

**答案：** 黑盒测试和白盒测试的区别如下：

- 黑盒测试：测试人员不了解程序的内部实现，仅根据需求规格说明进行测试，主要关注输入输出是否符合预期。
- 白盒测试：测试人员了解程序的内部实现，通过分析代码逻辑进行测试，主要关注代码的覆盖率和执行路径。

**解析：** 黑盒测试和

