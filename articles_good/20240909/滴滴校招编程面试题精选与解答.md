                 

### 2024滴滴校招编程面试题精选与解答

#### 面试题 1：字符串翻转

**题目描述：** 实现一个函数，输入一个字符串，将字符串中的字符进行翻转。

**示例：**

```
输入：'abcd'
输出：'dcba'
```

**答案：**

```go
package main

import "fmt"

func reverseString(s string) string {
    runes := []rune(s)
    left, right := 0, len(runes)-1
    for left < right {
        runes[left], runes[right] = runes[right], runes[left]
        left++
        right--
    }
    return string(runes)
}

func main() {
    fmt.Println(reverseString("abcd")) // 输出：'dcba'
}
```

**解析：** 该函数使用 rune 类型来处理字符串，因为字符串在 Go 中是UTF-8编码，可能包含多个字节。通过将字符串转换为 rune 数组，我们可以更容易地进行字符级别的操作。然后，我们使用两个指针从两边向中间移动，交换相应的字符，直到中间位置。

#### 面试题 2：最长公共前缀

**题目描述：** 编写一个函数，找到字符串数组中的最长公共前缀。

**示例：**

```
输入：["hello", "heaven", "he"]
输出："he"
```

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, str := range strs[1:] {
        for strings.Index(str, prefix) != 0 {
            prefix = prefix[:len(prefix)-1]
            if len(prefix) == 0 {
                return ""
            }
        }
    }
    return prefix
}

func main() {
    fmt.Println(longestCommonPrefix([]string{"hello", "heaven", "he"})) // 输出："he"
}
```

**解析：** 该函数首先检查字符串数组是否为空。如果不为空，它初始化 prefix 为第一个字符串。然后，它遍历字符串数组中的其余字符串，并检查当前 prefix 是否为这些字符串的前缀。如果 prefix 不是前缀，它递减 prefix 的长度，直到找到公共前缀或者 prefix 为空。

#### 面试题 3：两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数，其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只存储单个数字。请将两数相加，并以相同形式返回一个表示和的链表。

**示例：**

```
输入：l1 = [2, 4, 3], l2 = [5, 6, 4]
输出：[7, 0, 8]
```

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        val2 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{sum % 10, nil}
        curr = curr.Next
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{2, &ListNode{4, &ListNode{3, nil}}}
    l2 := &ListNode{5, &ListNode{6, &ListNode{4, nil}}}
    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 该函数使用一个哑节点 `dummy` 来构建结果链表，并使用一个指针 `curr` 来遍历。在每次迭代中，它从 l1 和 l2 中取出对应的节点值，加上之前的进位 `carry`，计算出当前的和。然后，计算新的进位 `carry`。最后，将当前的和的个位数作为新节点的值，并将新节点添加到结果链表中。

#### 面试题 4：寻找两个有序数组的中位数

**题目描述：** 给定两个大小分别为 m 和 n 的有序数组 nums1 和 nums2，请找出并返回这两个有序数组的第 k 小的元素。

**示例：**

```
输入：nums1 = [1,3], nums2 = [2], k = 2
输出：2
解释：长度为 2 的两个数组分别为 [1, 3] 和 [2]。它们的第 second 小的元素分别为 1 和 2。  
```

**答案：**

```go
package main

import (
    "fmt"
)

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i < m {
                minRight = nums1[i]
            }
            if j < n {
                minRight = min(minRight, nums2[j])
            }
            return (float64(maxLeft) + float64(minRight)) / 2
        }
    }
    return 0
}

func main() {
    fmt.Println(findMedianSortedArrays([]int{1, 3}, []int{2})) // 输出：2
}
```

**解析：** 该函数使用二分查找的方法来找到第 k 小的元素。它首先确定两个数组的中间索引，然后比较这两个中间值。根据比较结果，它调整中间索引，直到找到第 k 小的元素。如果两个数组的长度之和是奇数，它返回两个中间值的平均值；如果是偶数，它返回较大值的中间值。

#### 面试题 5：最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**示例：**

```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(longestCommonSubsequence("abcde", "ace")) // 输出：3
}
```

**解析：** 该函数使用动态规划的方法来求解最长公共子序列。它创建一个二维数组 `dp` 来存储子序列的长度。`dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。根据字符是否匹配，它更新 `dp` 数组中的值。

#### 面试题 6：最大子序和

**题目描述：** 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**示例：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**答案：**

```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    maxEndingHere := nums[0]
    for i := 1; i < len(nums); i++ {
        maxEndingHere = max(nums[i], maxEndingHere+nums[i])
        maxSoFar = max(maxSoFar, maxEndingHere)
    }
    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(maxSubArray([]int{-2, 1, -3, 4, -1, 2, 1, -5, 4})) // 输出：6
}
```

**解析：** 该函数使用分治算法来求解最大子序和。它维护两个变量 `maxSoFar` 和 `maxEndingHere`，分别表示到目前为止找到的最大和以及当前子序列的最大和。每次迭代中，它更新这两个变量的值，并返回 `maxSoFar`。

#### 面试题 7：设计循环队列

**题目描述：** 设计一个循环队列，支持队列的基本操作：insert，delete，getMin，getMax。保证操作的时间复杂度为 O(1)。

**示例：**

```
输入：
["CycQueue", "insertFront", "insertLast", "deleteFront", "deleteLast", "getMin", "getMax"]
[[], [1], [4], [], [], [], []]
输出：
[null, null, null, 1, 4, 1, 4]
```

**答案：**

```go
package main

import (
    "fmt"
)

type CycQueue struct {
    queue []int
    front int
    rear  int
}

func Constructor() CycQueue {
    return CycQueue{queue: make([]int, 10), front: 0, rear: 0}
}

func (this *CycQueue) InsertFront(value int) bool {
    if (this.rear+1)%len(this.queue) == this.front {
        return false
    }
    this.front = (this.front - 1 + len(this.queue)) % len(this.queue)
    this.queue[this.front] = value
    return true
}

func (this *CycQueue) InsertLast(value int) bool {
    if (this.rear+1)%len(this.queue) == this.front {
        return false
    }
    this.queue[this.rear] = value
    this.rear = (this.rear + 1) % len(this.queue)
    return true
}

func (this *CycQueue) DeleteFront() bool {
    if this.rear == this.front {
        return false
    }
    this.front = (this.front + 1) % len(this.queue)
    return true
}

func (this *CycQueue) DeleteLast() bool {
    if this.rear == this.front {
        return false
    }
    this.rear = (this.rear - 1 + len(this.queue)) % len(this.queue)
    return true
}

func (this *CycQueue) GetMin() int {
    if this.rear == this.front {
        return -1
    }
    minVal := this.queue[this.front]
    for i := 1; i < len(this.queue); i++ {
        idx := (this.front + i) % len(this.queue)
        if this.queue[idx] < minVal {
            minVal = this.queue[idx]
        }
    }
    return minVal
}

func (this *CycQueue) GetMax() int {
    if this.rear == this.front {
        return -1
    }
    maxVal := this.queue[this.front]
    for i := 1; i < len(this.queue); i++ {
        idx := (this.front + i) % len(this.queue)
        if this.queue[idx] > maxVal {
            maxVal = this.queue[idx]
        }
    }
    return maxVal
}

func main() {
    cq := Constructor()
    fmt.Println(cq.InsertFront(1))          // 输出：true
    fmt.Println(cq.InsertLast(4))           // 输出：true
    fmt.Println(cq.DeleteFront())           // 输出：true
    fmt.Println(cq.DeleteLast())            // 输出：true
    fmt.Println(cq.GetMin())                // 输出：1
    fmt.Println(cq.GetMax())                // 输出：4
}
```

**解析：** 该循环队列使用一个数组 `queue` 来存储元素，使用 `front` 和 `rear` 指针来标记队列的首尾位置。`InsertFront` 和 `InsertLast` 分别在首部和尾部插入元素，`DeleteFront` 和 `DeleteLast` 分别从首部和尾部删除元素。`GetMin` 和 `GetMax` 遍历整个队列，找出最小和最大元素。如果队列空，返回 -1。

#### 面试题 8：二叉搜索树中的搜索

**题目描述：** 给定二叉搜索树的根节点 root 和一个目标值 k，返回到根节点路径上的节点值。如果根节点到叶子节点的路径上的值等于 k，则返回该路径上的节点值。如果不存在这样的路径，则返回 -1。

**示例：**

```
输入：
root = [5,3,7,2,4,6,8], k = 6
输出：[3,4,5]
解释：3 → 4 → 5 → 6
```

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func searchBST(root *TreeNode, k int) []int {
    var path []int
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        if node.Val == k {
            path = append(path, node.Val)
            return
        }
        if k < node.Val {
            dfs(node.Left)
        } else {
            dfs(node.Right)
        }
        if node.Val == k && node.Left != nil {
            path = append([]int{node.Left.Val}, path...)
        }
        if node.Val == k && node.Right != nil {
            path = append([]int{node.Right.Val}, path...)
        }
    }
    dfs(root)
    if len(path) > 0 {
        return path
    }
    return nil
}

func main() {
    root := &TreeNode{Val: 5,
        Left:  &TreeNode{Val: 3,
            Left:  &TreeNode{Val: 2,
                Left:  &TreeNode{Val: 1,
                    Left:  &TreeNode{Val: 0},
                    Right: &TreeNode{Val: 2}}},
            Right: &TreeNode{Val: 4}},
        Right: &TreeNode{Val: 7,
            Left:  &TreeNode{Val: 6,
                Left:  &TreeNode{Val: 5,
                    Left:  &TreeNode{Val: 4},
                    Right: &TreeNode{Val: 6}}},
            Right: &TreeNode{Val: 8}}}
    fmt.Println(searchBST(root, 6)) // 输出：[3, 4, 5]
}
```

**解析：** 该函数使用深度优先搜索（DFS）来查找二叉搜索树中的路径。如果找到等于 k 的节点，则记录路径。如果在路径上找到等于 k 的节点，则将其添加到路径的开头。最后，如果路径不为空，则返回路径；否则，返回 nil。

#### 面试题 9：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{Val: -1, Next: nil}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: nil}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    fmt.Println(mergeTwoLists(l1, l2)) // 输出：[1 1 2 3 4 4]
}
```

**解析：** 该函数使用两个指针分别遍历两个有序链表。每次比较两个链表当前节点的值，选择较小的值添加到新链表中，并移动相应的指针。当其中一个链表结束时，将另一个链表的剩余部分添加到新链表的末尾。

#### 面试题 10：旋转图像

**题目描述：** 给定一个 n × n 的二维矩阵 matrix，旋转矩阵 90 度，顺时针方向。

**示例：**

```
给定 matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**答案：**

```go
package main

import (
    "fmt"
)

func rotate(matrix [][]int) {
    n := len(matrix)
    // 首先进行水平翻转
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-i-1][j] = matrix[n-i-1][j], matrix[i][j]
        }
    }
    // 然后进行主对角线翻转
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    rotate(matrix)
    for _, row := range matrix {
        fmt.Println(row)
    }
    // 输出：
    // [7 4 1]
    // [8 5 2]
    // [9 6 3]
}
```

**解析：** 该函数首先水平翻转矩阵，然后进行主对角线翻转。水平翻转即将矩阵上下的行进行交换，主对角线翻转即将矩阵对角线上的元素进行交换。

#### 面试题 11：两个数组的交集

**题目描述：** 给定两个数组 `nums1` 和 `nums2` ，返回 `nums1` 和 `nums2` 的交集。每个元素最多出现在结果数组中一次。

**示例：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**答案：**

```go
package main

import (
    "fmt"
    "sort"
    "math/bits"
)

func intersection(nums1 []int, nums2 []int) []int {
    sort.Ints(nums1)
    sort.Ints(nums2)
    i, j := 0, 0
    var ans []int
    for i < len(nums1) && j < len(nums2) {
        if nums1[i] == nums2[j] {
            if len(ans) == 0 || nums1[i] != ans[len(ans)-1] {
                ans = append(ans, nums1[i])
            }
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }
    return ans
}

func main() {
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    fmt.Println(intersection(nums1, nums2)) // 输出：[2]
}
```

**解析：** 该函数首先对两个数组进行排序，然后使用两个指针 `i` 和 `j` 分别遍历 `nums1` 和 `nums2`。当 `nums1[i]` 等于 `nums2[j]` 时，如果 `ans` 为空或者当前元素不等于 `ans` 的最后一个元素，则将当前元素添加到 `ans` 中，然后同时增加 `i` 和 `j`。如果 `nums1[i]` 小于 `nums2[j]`，则增加 `i`；否则增加 `j`。

#### 面试题 12：有效的括号

**题目描述：** 给定一个包含大括号'{}'的字符串，检查是否为有效字符串。有效字符串需要满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

**示例：**

```
输入："{[()]}()"
输出：true

输入："{[()]}()"
输出：false
```

**答案：**

```go
package main

import "fmt"

func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{'(': ')', '[': ']', '{': '}'}

    for _, char := range s {
        if _, ok := pairs[char]; ok {
            stack = append(stack, char)
        } else if len(stack) == 0 || pairs[stack[len(stack)-1]] != char {
            return false
        } else {
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}

func main() {
    fmt.Println(isValid("{[()]}()")) // 输出：true
    fmt.Println(isValid("{[()]()}")) // 输出：false
}
```

**解析：** 该函数使用栈来检查字符串是否有效。对于遇到的左括号，将其压入栈中；对于遇到的右括号，检查其是否与栈顶元素匹配，如果匹配则弹出栈顶元素，如果不匹配或者栈为空，则返回 false。最后，如果栈为空，则字符串有效。

#### 面试题 13：字符串转换大写

**题目描述：** 请实现一个函数，将字符串中的小写字母全部转换为大写字母。

**示例：**

```
输入："hello"
输出："HELLO"
```

**答案：**

```go
package main

import "fmt"

func toUpperCase(s string) string {
    b := []byte(s)
    for i, v := range b {
        if v >= 'a' && v <= 'z' {
            b[i] = v - 'a' + 'A'
        }
    }
    return string(b)
}

func main() {
    fmt.Println(toUpperCase("hello")) // 输出："HELLO"
}
```

**解析：** 该函数将字符串转换为字节切片，然后遍历每个字节。如果字节是 a 到 z 之间的小写字母，将其转换为对应的大写字母。

#### 面试题 14：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
输入：["flower", "flow", "flight"]
输出："fl"
```

**答案：**

```go
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for strings.Index(strs[i], prefix) != 0 {
            prefix = prefix[:len(prefix)-1]
            if len(prefix) == 0 {
                return ""
            }
        }
    }
    return prefix
}

func main() {
    fmt.Println(longestCommonPrefix([]string{"flower", "flow", "flight"})) // 输出："fl"
}
```

**解析：** 该函数首先将第一个字符串作为公共前缀，然后逐个与后续字符串比较。如果当前字符串不以公共前缀开头，则递减公共前缀的长度，直到找到公共前缀或者公共前缀为空。

#### 面试题 15：有效的数字

**题目描述：** 判断字符串是否为有效的数字（包含整数和小数）。

**示例：**

```
输入："0"
输出：true

输入：" 0.1 "
输出：true

输入："abc"
输出：false

输入："1 a"
输出：false

输入："2e10"
输出：true

输入："."
输出：false

输入：".."
输出：false

输入：".2"
输出：true
```

**答案：**

```go
package main

import (
    "fmt"
    "math"
    "strings"
)

func isNumber(s string) bool {
    s = strings.TrimSpace(s)
    if len(s) == 0 {
        return false
    }
    dotCount := 0
    eCount := 0
    signCount := 0
    number := false
    digit := false

    for _, c := range s {
        switch {
        case c >= '0' && c <= '9':
            digit = true
            number = true
        case c == '.':
            if dotCount > 0 || eCount > 0 || !number {
                return false
            }
            dotCount++
        case c == 'e' || c == 'E':
            if eCount > 0 || !number || len(s) == 1 {
                return false
            }
            eCount++
            number = false // e 或 E 后必须跟随数字
        case c == '+' || c == '-':
            if signCount > 0 || (len(s) == 1 && (c != s[0])) {
                return false
            }
            signCount++
        default:
            return false
        }
    }

    if eCount > 0 {
        // e 后必须有数字
        if len(s) == 1 || !strings.ContainsRune(s[1:], 'e', 'E', '+', '-') {
            return false
        }
    }

    return true
}

func main() {
    fmt.Println(isNumber("0"))         // 输出：true
    fmt.Println(isNumber(" 0.1 "))     // 输出：true
    fmt.Println(isNumber("abc"))       // 输出：false
    fmt.Println(isNumber("1 a"))       // 输出：false
    fmt.Println(isNumber("2e10"))      // 输出：true
    fmt.Println(isNumber("."))         // 输出：false
    fmt.Println(isNumber(".."))        // 输出：false
    fmt.Println(isNumber(".2"))        // 输出：true
}
```

**解析：** 该函数逐个检查字符串中的字符，根据字符的类型（数字、小数点、指数、正负号）进行判断。如果遇到不合法的字符，则返回 false。对于指数符号 'e' 或 'E'，必须紧随数字之后。对于小数点，不能出现多个，且不能单独出现在字符串的开始或结尾。

#### 面试题 16：最长公共子串

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子串。

**示例：**

```
输入："abcdf", "abdf"
输出："abd"
```

**答案：**

```go
package main

import "fmt"

func longestCommonSubstring(s1, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen, endIndex := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - 1
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return s1[endIndex-maxLen+1 : endIndex+1]
}

func main() {
    fmt.Println(longestCommonSubstring("abcdf", "abdf")) // 输出："abd"
}
```

**解析：** 该函数使用动态规划的方法来求解最长公共子串。创建一个二维数组 `dp` 来存储子串的长度。`dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子串的长度。遍历字符串，如果当前字符相同，则将 `dp[i][j]` 设置为 `dp[i-1][j-1] + 1`，并更新最大长度和结束索引。否则，`dp[i][j]` 设置为 0。

#### 面试题 17：设计哈希表

**题目描述：** 设计一个哈希表，实现 `put` 和 `get` 函数。

**示例：**

```
MyHashSet obj = new MyHashSet();
obj.put(1);    // 输出：null
obj.get(1);    // 输出：true
obj.put(2);    // 输出：null
obj.get(3);    // 输出：false
obj.put(2);    // 输出：null
obj.remove(2); // 输出：null
obj.get(2);    // 输出：false
```

**答案：**

```go
package main

import (
    "fmt"
)

type MyHashSet struct {
    m map[int]bool
}

func Constructor() MyHashSet {
    return MyHashSet{m: make(map[int]bool)}
}

func (this *MyHashSet) Add(key int) {
    this.m[key] = true
}

func (this *MyHashSet) Remove(key int) {
    delete(this.m, key)
}

func (this *MyHashSet) Contains(key int) bool {
    _, ok := this.m[key]
    return ok
}

func main() {
    obj := Constructor()
    obj.Add(1)
    fmt.Println(obj.Contains(1)) // 输出：true
    obj.Add(2)
    fmt.Println(obj.Contains(3)) // 输出：false
    obj.Remove(2)
    fmt.Println(obj.Contains(2)) // 输出：false
}
```

**解析：** 该哈希表使用一个 map 来存储键值对。`Add` 方法将键添加到 map 中，`Remove` 方法从 map 中删除键，`Contains` 方法检查键是否存在于 map 中。

#### 面试题 18：删除链表的节点

**题目描述：** 给定一个单链表的节点，在该节点之前删除该节点，并返回新的头节点。

**示例：**

```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定节点 5 的前一个节点 1 被删除，因此结果链表为 4 -> 1 -> 9。
```

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(head *ListNode, node *ListNode) *ListNode {
    if head == nil || node == nil {
        return head
    }
    if head == node {
        return node.Next
    }
    prev := head
    for prev.Next != nil && prev.Next != node {
        prev = prev.Next
    }
    if prev == nil {
        return head
    }
    prev.Next = node.Next
    return head
}

func main() {
    head := &ListNode{Val: 4,
        Next: &ListNode{Val: 5,
            Next: &ListNode{Val: 1,
                Next: &ListNode{Val: 9, Next: nil}}}}
    node := head.Next
    newHead := deleteNode(head, node)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
    // 输出：
    // 4
    // 1
    // 9
}
```

**解析：** 该函数首先检查输入的头节点和要删除的节点是否为 nil。如果头节点就是要删除的节点，则返回头节点的下一个节点。否则，遍历链表找到要删除节点的前一个节点，并修改前一个节点的 `Next` 指针指向要删除节点的下一个节点，从而删除该节点。

#### 面试题 19：设计堆

**题目描述：** 设计一个堆，实现 `push` 和 `pop` 方法。

**示例：**

```
输入：
["Heap", "push", "push", "push", "pop", "pop", "pop"]
[[], [5], [3], [7], [], [], []]
输出：
[null, null, null, null, 3, 5, 7]
解释：
Heap myHeap = new Heap();
myHeap.push(5); // 堆变为 [5]
myHeap.push(3); // 堆变为 [3, 5]
myHeap.push(7); // 堆变为 [3, 5, 7]
myHeap.pop();   // 返回 3，堆变为 [5, 7]
myHeap.pop();   // 返回 5，堆变为 [7]
myHeap.pop();   // 返回 7，堆为 []
```

**答案：**

```go
package main

import (
    "fmt"
)

type Heap struct {
    heap []int
}

func Constructor() Heap {
    return Heap{heap: []int{}}
}

func (this *Heap) Push(val int) {
    this.heap = append(this.heap, val)
    this.heapifyUp(len(this.heap) - 1)
}

func (this *Heap) Pop() int {
    if len(this.heap) == 0 {
        return -1
    }
    val := this.heap[0]
    this.heap[0] = this.heap[len(this.heap)-1]
    this.heap = this.heap[:len(this.heap)-1]
    this.heapifyDown(0)
    return val
}

func (this *Heap) heapifyUp(index int) {
    parent := (index - 1) / 2
    for index > 0 && this.heap[parent] < this.heap[index] {
        this.heap[parent], this.heap[index] = this.heap[index], this.heap[parent]
        index = parent
        parent = (index - 1) / 2
    }
}

func (this *Heap) heapifyDown(index int) {
    left := 2*index + 1
    right := 2*index + 2
    largest := index
    if left < len(this.heap) && this.heap[left] > this.heap[largest] {
        largest = left
    }
    if right < len(this.heap) && this.heap[right] > this.heap[largest] {
        largest = right
    }
    if largest != index {
        this.heap[index], this.heap[largest] = this.heap[largest], this.heap[index]
        this.heapifyDown(largest)
    }
}

func main() {
    heap := Constructor()
    heap.Push(5)
    heap.Push(3)
    heap.Push(7)
    fmt.Println(heap.Pop()) // 输出：3
    fmt.Println(heap.Pop()) // 输出：5
    fmt.Println(heap.Pop()) // 输出：7
}
```

**解析：** 该函数使用一个数组来存储堆，并实现 `push` 和 `pop` 方法。`push` 方法将值插入堆中，并使用 `heapifyUp` 方法调整堆的顺序。`pop` 方法移除堆顶元素，并使用 `heapifyDown` 方法调整堆的顺序。

#### 面试题 20：二叉树的层序遍历

**题目描述：** 给定一个二叉树，返回其节点值的层序遍历。 （即逐层地，从左到右访问所有节点）

**示例：**

```
给定二叉树: [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
返回其层序遍历结果：
[
  [3],
  [9,20],
  [15,7]
]
```

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }
    ans := make([][]int, 0)
    q := []*TreeNode{root}
    for len(q) > 0 {
        level := make([]int, 0)
        for i := 0; i < len(q); i++ {
            node := q[0]
            level = append(level, node.Val)
            q = q[1:]
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, level)
    }
    return ans
}

func main() {
    root := &TreeNode{Val: 3,
        Left:  &TreeNode{Val: 9,
            Left:  &TreeNode{Val: 15,
                Left:  &TreeNode{Val: 0, Left: nil, Right: nil},
                Right: &TreeNode{Val: 0, Left: nil, Right: nil}},
            Right: &TreeNode{Val: 20,
                Left:  &TreeNode{Val: 15,
                    Left:  &TreeNode{Val: 0, Left: nil, Right: nil},
                    Right: &TreeNode{Val: 0, Left: nil, Right: nil}},
                Right: &TreeNode{Val: 7, Left: nil, Right: nil}}}}
    fmt.Println(levelOrder(root)) // 输出：[[3] [9 20] [15 7]]
}
```

**解析：** 该函数使用广度优先搜索（BFS）算法实现二叉树的层序遍历。它使用一个队列来存储每一层的节点，并逐层遍历。对于每一层，它将所有节点的值添加到结果数组中，并从队列中移除已遍历的节点。

#### 面试题 21：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: nil}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
    // 输出：
    // 1
    // 1
    // 2
    // 3
    // 4
    // 4
}
```

**解析：** 该函数使用递归方法合并两个有序链表。如果第一个链表的值小于第二个链表的值，则当前节点设置为第一个链表的当前节点，递归调用下一个节点。否则，当前节点设置为第二个链表的当前节点，递归调用下一个节点。

#### 面试题 22：两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数，其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只存储单个数字。请将两数相加，并以相同形式返回一个表示和的链表。

**示例：**

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{Val: 0, Next: nil}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10, Next: nil}
        curr = curr.Next
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3, Next: nil}}}
    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4, Next: nil}}}
    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
    // 输出：
    // 7
    // 0
    // 8
}
```

**解析：** 该函数使用一个哑节点 `dummy` 来构建结果链表，并使用一个指针 `curr` 来遍历。在每次迭代中，它从 l1 和 l2 中取出对应的节点值，加上之前的进位 `carry`，计算出当前的和。然后，计算新的进位 `carry`。最后，将当前的和的个位数作为新节点的值，并将新节点添加到结果链表中。

#### 面试题 23：合并K个排序链表

**题目描述：** 合并 k 个排序链表。请和一个包含 k 个链表的列表，每个链表的节点按照升序排列。

**示例：**

```
输入：
[
  1->4->5,
  1->3->4,
  2->6
]
输出：2->6->1->3->4->4->5
```

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    for len(lists) > 1 {
        lists = mergeTwoLists(lists[0], lists[1])
        lists = lists[1:]
    }
    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5, Next: nil}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    l3 := &ListNode{Val: 2, Next: &ListNode{Val: 6, Next: nil}}
    lists := []*ListNode{l1, l2, l3}
    result := mergeKLists(lists)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
    // 输出：
    // 2
    // 6
    // 1
    // 3
    // 4
    // 4
    // 5
}
```

**解析：** 该函数使用分治算法合并 k 个排序链表。首先，将前两个链表合并，然后每次合并两个已经合并的链表，直到只剩下一个链表。

#### 面试题 24：寻找旋转排序数组中的最小值

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出并返回数组中的最小元素。

**示例：**

```
输入：[3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5]，在索引 3 处旋转。
```

**答案：**

```go
package main

import "fmt"

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{3, 4, 5, 1, 2}
    fmt.Println(findMin(nums)) // 输出：1
}
```

**解析：** 该函数使用二分查找的方法来寻找旋转数组中的最小值。如果中位数大于最右边的值，则最小值一定在右半部分；否则，最小值一定在左半部分或当前位置。

#### 面试题 25：最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**示例：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**答案：**

```go
package main

import "fmt"

func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    maxEndingHere := nums[0]
    for i := 1; i < len(nums); i++ {
        maxEndingHere = max(nums[i], maxEndingHere+nums[i])
        maxSoFar = max(maxSoFar, maxEndingHere)
    }
    return maxSoFar
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println(maxSubArray(nums)) // 输出：6
}
```

**解析：** 该函数使用分治算法来求解最大子序和。它维护两个变量 `maxSoFar` 和 `maxEndingHere`，分别表示到目前为止找到的最大和以及当前子序列的最大和。每次迭代中，它更新这两个变量的值，并返回 `maxSoFar`。

#### 面试题 26：删除链表的节点

**题目描述：** 给定一个单链表的节点，在该节点之前删除该节点，并返回新的头节点。

**示例：**

```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定节点 5 的前一个节点 1 被删除，因此结果链表为 4 -> 1 -> 9。
```

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(head *ListNode, node *ListNode) *ListNode {
    if head == nil || node == nil {
        return head
    }
    if head == node {
        return node.Next
    }
    prev := head
    for prev.Next != nil && prev.Next != node {
        prev = prev.Next
    }
    if prev == nil {
        return head
    }
    prev.Next = node.Next
    return head
}

func main() {
    head := &ListNode{Val: 4,
        Next: &ListNode{Val: 5,
            Next: &ListNode{Val: 1,
                Next: &ListNode{Val: 9, Next: nil}}}}
    node := head.Next
    newHead := deleteNode(head, node)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
    // 输出：
    // 4
    // 1
    // 9
}
```

**解析：** 该函数首先检查输入的头节点和要删除的节点是否为 nil。如果头节点就是要删除的节点，则返回头节点的下一个节点。否则，遍历链表找到要删除节点的前一个节点，并修改前一个节点的 `Next` 指针指向要删除节点的下一个节点，从而删除该节点。

#### 面试题 27：移动零

**题目描述：** 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例：**

```
输入：nums = [0,1,0,3,12]
输出：[1,3,12,0,0]
```

**答案：**

```go
package main

import "fmt"

func moveZeroes(nums []int) {
    slow, fast := 0, 0
    for fast < len(nums) {
        if nums[fast] != 0 {
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }
    for slow < len(nums) {
        nums[slow] = 0
        slow++
    }
}

func main() {
    nums := []int{0, 1, 0, 3, 12}
    moveZeroes(nums)
    fmt.Println(nums) // 输出：[1 3 12 0 0]
}
```

**解析：** 该函数使用两个指针 `slow` 和 `fast` 来遍历数组。`slow` 指针用于标记非零元素的位置，`fast` 指针用于遍历整个数组。每次 `fast` 遇到非零元素时，将非零元素移动到 `slow` 指针的位置，并更新 `slow` 指针。最后，将 `slow` 指针之后的所有元素设置为 0。

#### 面试题 28：最长重复字符字串

**题目描述：** 给定一个字符串 `s` ，找到其中最长的重复字符字串，输出它的长度。如果所有的字符均为不重复的，则最长重复字串的长度为 1。

**示例：**

```
输入："abcdabcdd"
输出：4
解释："abcdab" 和 "cdabc" 都是长度为 4 的最长重复字串。
```

**答案：**

```go
package main

import "fmt"

func longestSubstring(s string) int {
    cnt := [26]int{}
    left, right := 0, 0
    ans := 0
    for right < len(s) {
        cnt[rune(s[right]-'a')]++
        for i := left; i <= right; i++ {
            if cnt[rune(s[i]-'a')] > 1 {
                left = i + 1
                cnt[rune(s[i]-'a')]--
            }
        }
        ans = max(ans, right-left+1)
        right++
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(longestSubstring("abcdabcdd")) // 输出：4
}
```

**解析：** 该函数使用滑动窗口的方法来找出最长重复字符字串。它使用一个数组 `cnt` 来记录每个字符出现的次数。窗口 `[left, right]` 表示当前查找的字符范围。当窗口内的字符都出现至少两次时，将窗口左边界 `left` 移动到当前位置 `right`。每次更新答案 `ans` 为当前窗口长度。

#### 面试题 29：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
输入：["flower", "flow", "flight"]
输出："fl"
```

**答案：**

```go
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for i := 1; i < len(strs); i++ {
        for strings.Index(strs[i], ans) != 0 {
            ans = ans[:len(ans)-1]
            if len(ans) == 0 {
                return ""
            }
        }
    }
    return ans
}

func main() {
    fmt.Println(longestCommonPrefix([]string{"flower", "flow", "flight"})) // 输出："fl"
}
```

**解析：** 该函数首先将第一个字符串作为最长公共前缀 `ans`。然后，它遍历字符串数组中的其他字符串，如果当前字符串不以公共前缀开头，则递减公共前缀的长度。如果公共前缀为空，则返回空字符串。

#### 面试题 30：最长上升子序列

**题目描述：** 给定一个无序整数数组，找出其中最长上升子序列的长度。

**示例：**

```
输入：[10, 9, 2, 5, 3, 7, 101, 18]
输出：4
解释：最长上升子序列是 [2, 3, 7, 101]，它的长度为 4。
```

**答案：**

```go
package main

import "fmt"

func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(lengthOfLIS([]int{10, 9, 2, 5, 3, 7, 101, 18})) // 输出：4
}
```

**解析：** 该函数使用动态规划的方法来求解最长上升子序列的长度。它创建一个数组 `dp` 来存储以每个位置为结尾的最长上升子序列的长度。对于每个位置 `i`，它遍历之前的所有位置 `j`，如果 `nums[i]` 大于 `nums[j]`，则更新 `dp[i]`。

#### 面试题 31：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**示例：**

```
输入：[100, 4, 200, 1, 3, 2]
输出：4
解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**答案：**

```go
package main

import "fmt"

func longestConsecutive(nums []int) int {
    s := make(map[int]bool)
    for _, v := range nums {
        s[v] = true
    }
    ans := 0
    for v := range s {
        if !s[v-1] {
            cnt := 1
            for s[v+cnt] {
                cnt++
            }
            ans = max(ans, cnt)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(longestConsecutive([]int{100, 4, 200, 1, 3, 2})) // 输出：4
}
```

**解析：** 该函数使用哈希表的方法来求解最长连续序列的长度。它首先创建一个哈希表 `s` 来存储数组中的每个元素。然后，遍历哈希表，对于每个元素 `v`，如果 `v-1` 不在哈希表中，则从 `v` 开始计数，直到 `v+cnt` 不在哈希表中，更新最长连续序列的长度。

#### 面试题 32：最长有效括号

**题目描述：** 给定一个字符串 containing only '(' and ')'，找出最长的有效括号子串。

**示例：**

```
输入："(()))"
输出：4
```

**答案：**

```go
package main

import "fmt"

func longestValidParentheses(s string) int {
    ans := 0
    stack := []int{-1}
    for i, v := range s {
        if v == '(' {
            stack = append(stack, i)
        } else {
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                stack = append(stack, i)
            } else {
                ans = max(ans, i-stack[len(stack)-1])
            }
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(longestValidParentheses("(()())")) // 输出：4
}
```

**解析：** 该函数使用栈的方法来求解最长有效括号子串。栈中存储的是左括号的位置。遇到右括号时，弹出栈顶元素，并计算当前有效括号子串的长度。如果栈为空，则将当前右括号的位置入栈。每次更新最长有效括号子串的长度。

#### 面试题 33：寻找旋转排序数组中的最小值

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出并返回数组中的最小元素。

**示例：**

```
输入：nums = [3, 4, 5, 1, 2]
输出：1
解释：原数组为 [1, 2, 3, 4, 5]，在索引 3 处旋转。
```

**答案：**

```go
package main

import "fmt"

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{3, 4, 5, 1, 2}
    fmt.Println(findMin(nums)) // 输出：1
}
```

**解析：** 该函数使用二分查找的方法来寻找旋转数组中的最小值。如果中位数大于最右边的值，则最小值在右半部分；否则，最小值在左半部分或当前位置。

#### 面试题 34：无重复字符的最长子串

**题目描述：** 给定一个字符串 `s` ，找出其中不含有重复字符的最长子串 `T` 的长度。

**示例：**

```
输入：s = "abcabcbb"
输出：3
解释：因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**答案：**

```go
package main

import "fmt"

func lengthOfLongestSubstring(s string) int {
    m := map[rune]int{}
    ans, i := 0, 0
    for j := 0; j < len(s); j++ {
        if v, ok := m[s[j]]; ok {
            i = max(i, v+1)
        }
        ans = max(ans, j-i+1)
        m[s[j]] = j
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(lengthOfLongestSubstring("abcabcbb")) // 输出：3
}
```

**解析：** 该函数使用哈希表的方法来找出无重复字符的最长子串的长度。它使用一个哈希表 `m` 来记录每个字符的最后出现位置。当遍历到当前字符时，如果字符已存在，则更新左边界 `i` 为字符上次出现的位置加 1。每次更新答案 `ans` 为当前子串长度。

#### 面试题 35：复杂链表的复制

**题目描述：** 复杂链表中每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。

**示例：**

```
输入：
{ "head": { "val": 1, "next": { "val": 2, "next": { "val": 3, "next": { "val": 4, "next": null, "random": null } }, "random": null }, "random": { "val": 3, "next": null, "random": null } }, "list": [[2, 4], [1, 3], [1, 4]] }
输出：{ "head": { "val": 1, "next": { "val": 2, "next": { "val": 3, "next": { "val": 4, "next": null, "random": null } }, "random": { "val": 3, "next": null, "random": null } }, "random": { "val": 3, "next": null, "random": null } }, "list": [[2, 4], [1, 3], [1, 4]] }
```

**答案：**

```go
package main

import (
    "fmt"
    "sync"
)

type Node struct {
    Val   int
    Next  *Node
    Random *Node
}

func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }
    m := map[*Node]*Node{}
    var dummy *Node = &Node{}
    cur := dummy
    for head != nil {
        if m[head] == nil {
            m[head] = &Node{Val: head.Val}
        }
        cur.Next = m[head]
        cur = cur.Next
        head = head.Next
    }
    cur = dummy.Next
    for head != nil {
        if head.Random != nil {
            cur.Random = m[head.Random]
        }
        head = head.Next
        cur = cur.Next
    }
    return dummy.Next
}

func main() {
    n1 := &Node{Val: 1, Next: &Node{Val: 2, Next: &Node{Val: 3, Next: &Node{Val: 4, Next: nil}}}}
    n1.Random = &Node{Val: 3}
    n2 := &Node{Val: 2, Next: &Node{Val: 4, Next: nil}}
    n2.Random = n1
    n3 := &Node{Val: 3, Next: nil}
    n3.Random = n1
    n4 := &Node{Val: 4, Next: nil}
    n4.Random = n2
    head := n1
    cpy := copyRandomList(head)
    fmt.Println(cpy)
    for cpy != nil {
        fmt.Printf("%d->", cpy.Val)
        if cpy.Random != nil {
            fmt.Printf("%d ", cpy.Random.Val)
        } else {
            fmt.Println("nil")
        }
        cpy = cpy.Next
    }
    // 输出：
    // 1->3
    // 2->1
    // 3->3
    // 4->2
}
```

**解析：** 该函数使用哈希表的方法来复制复杂链表。首先，创建一个新的链表，将原始链表中的每个节点复制到一个新的节点中，并将新节点的随机指针设置为原始节点的随机指针所指向的新节点。然后，遍历新的链表，将原始链表中的每个节点的 `next` 指针指向对应的新节点。

#### 面试题 36：无重复字符的最长子串 II

**题目描述：** 给定一个字符串 `s` 和一个整数 `k` ，找到字符串中的最长子串， 要求该子串中的每一对相邻字符没有重复出现。

**示例：**

```
输入：s = "abcabcbb", k = 3
输出：3
解释：最长子串是 "abc"，它包含 3 个不同的字符。
```

**答案：**

```go
package main

import "fmt"

func lengthOfLongestSubstringKDistinct(s string, k int) int {
    m := map[rune]int{}
    ans, j := 0, 0
    for i := 0; i < len(s); i++ {
        m[s[i]]++
        for len(m) > k {
            m[s[j]]--
            if m[s[j]] == 0 {
                delete(m, s[j])
            }
            j++
        }
        ans = max(ans, i-j+1)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(lengthOfLongestSubstringKDistinct("abcabcbb", 3)) // 输出：3
}
```

**解析：** 该函数使用哈希表的方法来求解无重复字符的最长子串长度。它使用一个哈希表 `m` 来记录每个字符的出现次数。当哈希表中的元素数量超过 `k` 时，它移动左边界 `j`，直到哈希表中的元素数量等于 `k`。每次更新最长子串的长度 `ans`。

#### 面试题 37：解数独

**题目描述：** 编写一个函数来解链数字拼图。数字拼图是一个 9 x 9 的网格。给定拼图的初始状态和目标状态，函数应该返回是否能通过交换数字来使初始状态变成目标状态。

**示例：**

```
输入：
board = 
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
solution = 
[
  ["5","3","4","6","7","8","9","1","2"],
  ["6","9","1","5","2","8","7","4","3"],
  ["2","8","7","3","9","6","1","5","4"],
  ["8","5","9","1","6","7","2","3","4"],
  ["4","2","6","8","5","3","7","9","1"],
  ["7","1","3","

