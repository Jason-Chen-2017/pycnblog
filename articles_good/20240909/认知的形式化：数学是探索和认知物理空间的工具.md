                 

### 认知的桥梁：数学在探索物理空间中的作用

#### 题目库与算法编程题库

##### 1. 数组中的最大子序和

**题目描述：** 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**示例：**  
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]  
输出：6  
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。

**算法思路：** 动态规划，通过比较当前元素与当前元素加上前一个子数组和的大小，更新最大子序和。

**答案解析：**

```python
class Solution:
    def maxSubArray(nums: List[int]) -> int:
        if not nums:
            return 0

        max_sum = nums[0]
        curr_sum = nums[0]

        for i in range(1, len(nums)):
            curr_sum = max(nums[i], curr_sum + nums[i])
            max_sum = max(max_sum, curr_sum)

        return max_sum
```

##### 2. 单词搜索

**题目描述：** 给定一个二维网格和一个单词，找出该单词是否存在于网格中。

**示例：**  
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"  
输出：true

**算法思路：** 回溯法，从每个单元格出发，尝试是否能够找到单词。

**答案解析：**

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, k):
            if k == len(word):
                return True
            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
                return False
            
            temp = board[i][j]
            board[i][j] = '#'
            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
            board[i][j] = temp
            
            return res

        for i in range(len(board)):
            for j in range(len(board[0])):
                if dfs(i, j, 0):
                    return True
        return False
```

##### 3. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**  
输入：strs = ["flower","flow","flight"]  
输出："fl"

**算法思路：** 暴力法，依次比较字符串的前缀。

**答案解析：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        prefix = ""
        for i, c in enumerate(strs[0]):
            for other in strs[1:]:
                if i >= len(other) or other[i] != c:
                    return prefix
            prefix += c
        
        return prefix
```

##### 4. 电话号码的字母组合

**题目描述：** 给定一个字符串 digits，返回所有能从该字符串计算机数字所组成的字母组合。

**示例：**  
输入："23"  
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]

**算法思路：** 回溯法，递归尝试所有可能的组合。

**答案解析：**

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        def backtrack(start):
            if start == len(digits):
                res.append(''.join(t))
                return
            for c in phone_book[digits[start]]:
                t.append(c)
                backtrack(start + 1)
                t.pop()

        phone_book = {
            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
        }
        res = []
        t = []
        backtrack(0)
        return res
```

##### 5. 盛水的容器

**题目描述：** 给定一个整数数组 height ，表示一个容器的高度，返回容器能装的最大水量。

**示例：**  
输入：height = [1,8,6,2,5,4,8,3,7]  
输出：49

**算法思路：** 双指针法，从两端开始向中间移动，找到当前能装水的最大容量。

**答案解析：**

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0
        
        while left < right:
            max_area = max(max_area, min(height[left], height[right]) * (right - left))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1

        return max_area
```

##### 6. 两数之和

**题目描述：** 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**  
输入：nums = [2, 7, 11, 15], target = 9  
输出：[0, 1]  
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。

**算法思路：** 哈希表，遍历数组，用哈希表记录已遍历的数字及其下标。

**答案解析：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_dict = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in nums_dict:
                return [nums_dict[complement], i]
            nums_dict[num] = i
        return []
```

##### 7. 最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**示例：**  
输入：text1 = "abcde", text2 = "ace"  
输出：3  
解释：最长公共子序列为 "ace"，所以长度为 3。

**算法思路：** 动态规划，构建一个二维数组，存储子问题的解。

**答案解析：**

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[m][n]
```

##### 8. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
输入：l1 = [1,2,4], l2 = [1,3,4]  
输出：[1,1,2,3,4,4]

**算法思路：** 递归或迭代，比较两个链表的头节点，选择较小的节点，并将较小节点的下一个节点指向合并后的链表。

**答案解析：**

```python
# 递归法
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

# 迭代法
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy

        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next

        curr.next = list1 or list2
        return dummy.next
```

##### 9. 搜索旋转排序数组

**题目描述：** 整数数组 nums 按升序排列，数组中的值 互不相同 。在传输过程中可能会出现数字的旋转。

给定一个旋转后可能存在重复元素的整数数组，编写一个函数来判断一个给定的目标值是否存在于数组中。如果数组中存在这个目标值，则返回 true，否则返回 false。

**示例：**  
输入：nums = [2,5,6,0,0,1,2], target = 0  
输出：true

**算法思路：** 二分查找，判断中间元素与两端元素的大小关系，缩小查找范围。

**答案解析：**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return True
            
            # 如果 mid 的值大于 left 的值
            if nums[mid] >= nums[left]:
                # 如果 target 在 mid 的左侧
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                # 如果 mid 的值小于 right 的值
                # 如果 target 在 mid 的右侧
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        
        return False
```

##### 10. 二进制求和

**题目描述：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**  
输入：a = "11", b = "1"  
输出："100"

**算法思路：** 字符串反转，从低位开始相加，处理进位。

**答案解析：**

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        max_len = max(len(a), len(b))
        a = a.zfill(max_len)
        b = b.zfill(max_len)
        res = []

        carry = 0
        for i in range(max_len - 1, -1, -1):
            sum_ = carry
            sum_ += 1 if a[i] == '1' else 0
            sum_ += 1 if b[i] == '1' else 0
            res.append(str(sum_ % 2))
            carry = sum_ // 2

        if carry:
            res.append('1')

        return ''.join(res[::-1])
```

##### 11. 拓扑排序

**题目描述：** 无向图中有 n 个节点，按从 0 到 n-1 编号。图是简单的无向图，这意味着任何两个节点之间最多只有一条边，且不存在自环（即，0 不连接自身，1 不连接 1，等等）。图包含 n 个节点和 m 条无向边。给出图的一个表示法：一个包含 m 行的二维整数数组 edges ，其中 edges[i] = [fromi, toi] 表示从 beforei 指向 afteri的一条边。完成给定边的任务后，返回能够到达 nodes 数组中所有节点的最小边数。如果不能到达所有节点，返回 -1。

**示例：**  
输入：nodes = [1,2,3,4], edges = [[0,1],[1,2],[2,3],[3,4]], time = [3,2,5,10]  
输出：7  
解释：要使所有节点都连通，我们可以在 1-2、3-4 之间建立直接连接。需要 3 + 10 + 2 + 5 = 20 分钟。

**算法思路：** 拓扑排序 + 最短路问题。

**答案解析：**

```python
from collections import defaultdict, deque
from heapq import heappop, heappush

class Solution:
    def minTime(self, nodes: List[int], edges: List[List[int]], time: List[int]) -> int:
        n = len(nodes)
        indeg = [0] * n
        g = defaultdict(list)

        for u, v in edges:
            g[u].append(v)
            indeg[v] += 1

        q = deque()
        for i in range(n):
            if indeg[i] == 0:
                q.append(i)

        ans = 0
        while q:
            u = q.popleft()
            ans += time[u]
            for v in g[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        for i in range(n):
            if indeg[i] != 0:
                return -1

        return ans
```

##### 12. 合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**  
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]  
输出：[[1,6],[8,10],[15,18]]

**算法思路：** 排序 + 合并。

**答案解析：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        res = []

        for interval in intervals:
            if not res or res[-1][1] < interval[0]:
                res.append(interval)
            else:
                res[-1][1] = max(res[-1][1], interval[1])

        return res
```

##### 13. 螺旋矩阵

**题目描述：** 给定一个包含 m x n 个元素的矩阵（m 行、n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例：**  
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]  
输出：[1,2,3,6,9,8,7,4,5]

**算法思路：** 分层打印。

**答案解析：**

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []

        m, n = len(matrix), len(matrix[0])
        vis = [[False] * n for _ in range(m)]
        ans = []

        t = 0
        while len(ans) < m * n:
            if t == 0 or t == m-1:
                for j in range(n):
                    if not vis[t][j]:
                        ans.append(matrix[t][j])
                        vis[t][j] = True
                t += 1
            elif t == 1 or t == n-1:
                for i in range(m):
                    if not vis[i][t]:
                        ans.append(matrix[i][t])
                        vis[i][t] = True
                t += 1
            else:
                for j in range(n-1, 0, -1):
                    if not vis[t][j]:
                        ans.append(matrix[t][j])
                        vis[t][j] = True
                for i in range(m-1, 0, -1):
                    if not vis[i][t]:
                        ans.append(matrix[i][t])
                        vis[i][t] = True
                t += 1

        return ans
```

##### 14. 合并K个排序链表

**题目描述：** 合并K个已排序的链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例：**  
输入：lists = [[1,4,5],[1,3,4],[2,6]]  
输出：[1,1,2,3,4,4,5,6]

**算法思路：** 分治 + 优先队列。

**答案解析：**

```python
from heapq import heappop, heappush

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        if not lists:
            return None

        dummy = ListNode()
        curr = dummy
        q = []
        for head in lists:
            if head:
                heappush(q, (head.val, head))

        while q:
            _, node = heappop(q)
            curr.next = node
            curr = curr.next
            if node.next:
                heappush(q, (node.next.val, node.next))

        return dummy.next
```

##### 15. 最大子序和

**题目描述：** 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。返回其最大和。

**示例：**  
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]  
输出：6  
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。

**算法思路：** 动态规划，通过比较当前元素与当前元素加上前一个子数组和的大小，更新最大子序和。

**答案解析：**

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if not nums:
            return 0

        max_sum = nums[0]
        curr_sum = nums[0]

        for i in range(1, len(nums)):
            curr_sum = max(nums[i], curr_sum + nums[i])
            max_sum = max(max_sum, curr_sum)

        return max_sum
```

##### 16. 买卖股票的最佳时机

**题目描述：** 给定一个数组 prices ，其中 prices[i] 是在第 i 天买入股票的价格。你只能一次性完成一笔交易。假设你在这天买入股票，并在随后的一天卖出。返回你能够获取的最大利润。

**示例：**  
输入：prices = [7,1,5,3,6,4]  
输出：5  
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润为 6 - 1 = 5 。

**算法思路：** 暴力法，枚举所有买卖的时机。

**答案解析：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        max_profit = 0
        for i in range(len(prices)):
            for j in range(i + 1, len(prices)):
                profit = prices[j] - prices[i]
                max_profit = max(max_profit, profit)
        return max_profit
```

##### 17. 最长连续序列

**题目描述：** 给定一个未经排序的整数数组，找到最长且 连续的的序列。返回该序列的长度。连续的序列定义为元素连续出现的序列。

**示例：**  
输入：[100, 4, 200, 1, 3, 2]  
输出：4  
解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

**算法思路：** 排序 + 遍历。

**答案解析：**

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0

        nums.sort()
        max_len = 1
        curr_len = 1

        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1] + 1:
                curr_len += 1
                max_len = max(max_len, curr_len)
            else:
                curr_len = 1

        return max_len
```

##### 18. 三数之和

**题目描述：** 给定一个包含 n 个整数的数组 nums，判断是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请找出所有满足条件且不重复的三元组。

**示例：**  
输入：nums = [-1, 0, 1, 2, -1, -4]  
输出：[[-1, -1, 2], [-1, 0, 1]]

**算法思路：** 排序 + 双指针。

**答案解析：**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []

        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            left, right = i + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return res
```

##### 19. 寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

**示例：**  
输入：nums1 = [1, 3], nums2 = [2]  
输出：2.00000  
解释：合并数组 = [1, 2, 3] ，中位数 2

**算法思路：** 二分查找 + 对数时间复杂度。

**答案解析：**

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m

        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums2[j - 1] > nums1[i]:
                imin = i + 1
            elif i > 0 and nums1[i - 1] > nums2[j]:
                imax = i - 1
            else:
                if i == 0:
                    max_of_left = nums2[j - 1]
                elif j == 0:
                    max_of_left = nums1[i - 1]
                else:
                    max_of_left = max(nums1[i - 1], nums2[j - 1])
                if (m + n) % 2 == 1:
                    return max_of_left

                if i == m:
                    min_of_right = nums2[j]
                elif j == n:
                    min_of_right = nums1[i]
                else:
                    min_of_right = min(nums1[i], nums2[j])
                return (max_of_left + min_of_right) / 2
```

##### 20. 删除链表的节点

**题目描述：** 请编写一个函数，使其可以删除单个链表中的任意节点，传播该节点的值到节点前面的节点。对已传入给函数的当前节点来说，调用这个函数必须既能删除该节点，又能将链表中该节点的值传播到前一个节点。

**示例：**  
输入：head = [4,5,1,9], node = 5  
输出：[4,1,9]，且原链表 1->9 已修改为 4->1->9

**算法思路：** 链表操作，复制下一个节点的值。

**答案解析：**

```python
# Definition for a singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```

##### 21. 最大子矩阵

**题目描述：** 给你一个二进制矩阵 matrix，请你找出一个最大子矩阵，该子矩阵中的所有元素都是 1 ，且有一个边界与矩阵的边界重合。如果矩阵中没有这样的子矩阵，请返回空矩阵 []。

**示例：**  
输入：matrix = [[1,0,1],[0,1,0],[1,1,0]]  
输出：[[0,0],[1,1]]  
解释：最大的子矩阵是 [1,1] ，边界与矩阵的边界重合。

**算法思路：** 动态规划，计算以每个元素为右下角的最大子矩阵。

**答案解析：**

```python
class Solution:
    def maxMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if matrix[i - 1][j - 1] == 1:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = 0

        max_area = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                area = dp[i][j] * (i - dp[i][j]) * (j - dp[i][j])
                max_area = max(max_area, area)

        if max_area == 0:
            return []

        max_x = 0
        max_y = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if dp[i][j] == max_area // (i - dp[i][j]) // (j - dp[i][j]):
                    max_x = i - 1
                    max_y = j - 1
                    break

        return [[max_x, max_y], [max_x + dp[max_x + 1][max_y], max_y + dp[max_x][max_y + 1]]]
```

##### 22. 逆波兰表达式求值

**题目描述：** 根据逆波兰表示法，求表达式的值。

有效的运算符包括 '+', '-', '*', '/' 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**示例：**  
输入：tokens = ["2","1","+","3","*"]  
输出：9  
解释：该算式可以从前往后计算。从左到右进行计算得到 2 * (1 + 3) = 9

**算法思路：** 栈，遇到数字直接入栈，遇到运算符则弹出栈顶两个元素进行运算。

**答案解析：**

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []

        for token in tokens:
            if token in "+-*/":
                b = stack.pop()
                a = stack.pop()
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                elif token == "/":
                    stack.append(int(a / b))
            else:
                stack.append(int(token))

        return stack[-1]
```

##### 23. 整数转换英文表示法

**题目描述：** 将一个非负整数转换为其对应的英文表示。

**示例：**  
输入：num = 123  
输出："One Hundred Twenty Three"

**算法思路：** 分段处理，分别处理亿、万、个位。

**答案解析：**

```python
class Solution:
    def intToEnglish(self, num: int) -> str:
        def words(n):
            if 10 <= n < 20:
                return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"][n - 10]
            elif n < 100:
                return ["Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"][n // 10 - 1] + ("One" if n % 10 else "")
            else:
                return ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"][n // 100 - 1] + " Hundred" + (words(n % 100) if n % 100 else "")

        if num == 0:
            return "Zero"
        res = ""
        if num // 1000000000:
            res += words(num // 1000000000) + " Billion"
            num %= 1000000000
        if num // 10000:
            res += words(num // 10000) + " Million"
            num %= 10000
        if num:
            res += words(num)
        return res
```

##### 24. 打家劫舍

**题目描述：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃能量的只有连续的房屋中，任意相邻的房屋装有相互连通的防盗系统， 如果 2 个相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**示例：**  
输入：[1,2,3,1]  
输出：4  
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  

**算法思路：** 动态规划，状态转移方程。

**答案解析：**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]
```

##### 25. 合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**  
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]  
输出：[[1,6],[8,10],[15,18]]

**算法思路：** 排序 + 合并。

**答案解析：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        ans = []
        for interval in intervals:
            if not ans or ans[-1][1] < interval[0]:
                ans.append(interval)
            else:
                ans[-1][1] = max(ans[-1][1], interval[1])
        return ans
```

##### 26. 最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**示例：**  
输入：text1 = "abcde", text2 = "ace"    
输出：3    
解释：最长公共子序列为 "ace"，所以长度为 3。

**算法思路：** 动态规划，构建一个二维数组，存储子问题的解。

**答案解析：**

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[m][n]
```

##### 27. 三数之和

**题目描述：** 给你一个整数数组 nums ，判断是否存在三个数 nums[i] ，nums[j] 和 nums[k] 使得它们两两之和等于 0 。请判断是否存在这样的三个数。

**示例：**  
输入：nums = [-1, 0, 1, 2, -1, -4]    
输出：[[-1, 0, 1], [-1, -1, 2]]

**算法思路：** 双指针。

**答案解析：**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left, right = i + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total == 0:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < 0:
                    left += 1
                else:
                    right -= 1

        return ans
```

##### 28. 计数二进制子串

**题目描述：** 给定一个字符串 s ，统计并通过返回字符 "0" 和 "1" 下出现的次数，来统计这个字符串中的连续 0 和 1 子串的数量。

**示例：**  
输入："00110"      
输出：4      
解释：下面列出了所有的 0 和 1 子串：
- "0" 出现 2 次。
- "1" 出现 2 次。
- "01" 出现 2 次。
- "10" 出现 1 次。
- "0011" 出现 1 次。

**算法思路：** 双指针，统计 0 和 1 的数量。

**答案解析：**

```python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        ans = prev = 0
        for i in range(1, len(s)):
            if s[i] != s[i - 1]:
                ans += min(prev, i - prev)
                prev = i
        return ans
```

##### 29. 最长重复子串

**题目描述：** 给你一个字符串 s ，找出其中最长的重复子串，输出它的长度。

**示例：**  
输入："banana"    
输出：3

**算法思路：** 二分查找 + 哈希。

**答案解析：**

```python
class Solution:
    def longestRepeatingSubstring(self, s: str) -> int:
        def check(k):
            seen = set()
            for i in range(len(s) - k + 1):
                t = s[i: i + k]
                if t in seen:
                    return True
                seen.add(t)
            return False

        left, right = 0, len(s)
        while left < right:
            mid = (left + right) >> 1
            if check(mid):
                left = mid + 1
            else:
                right = mid
        return right - 1
```

##### 30. 最小路径和

**题目描述：** 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**示例：**  
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]  
输出：7

**算法思路：** 动态规划，从左上角开始更新。

**答案解析：**

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]

        return dp[m][n]
```

