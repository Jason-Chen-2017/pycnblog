
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、什么是网络空间安全保障？
网络空间安全（NSS）主要指保护计算机系统、信息网络、传输链路和路由器等构成信息基础设施的安全，包括网络设备、计算机网络、应用系统和网络服务等。NSS技术与网络结构密切相关，对网络安全的影响也十分复杂。随着技术的不断发展，新的攻击手段、威胁途径和绕过技术层出不穷。因此，对NSS进行科学管理和有效管控，是保障网络安全的基石之一。

《网络空间安全保障》(Network Space Security Assurance，简称NSSA)是华为自主研发的一系列安全技术，旨在提升运营商网络的整体安全水平，确保用户数据和网络业务正常运行，并满足全球客户的需求。

## 二、什么是霍尔效应？
霍尔效应（Halting Problem）是指计算机无法解决的问题，即某些规模的问题不能在有限的时间内得到一个正确的解。此问题存在于许多领域，例如排队论、递归函数、哈密顿回路等。然而，有些问题实质上不存在计算困难或者时间限制，却无法用有效的方法求解。霍尔效应的产生原因在于其难以判定解决方法的准确性。

霍尔效应意味着计算问题无可避免地存在矛盾，需要通过更精细的分析才能找到合适的方法。当前，很多研究者已经提出了一些有效的近似算法来缓解霍尔效应。随着技术的进步，越来越多的算法被开发出来，但是对于复杂问题来说，仍然无法在有限的时间内找到满意的解。

## 三、为什么要做网络空间安全保障？
网络空间安全对企业及运营商的网络环境、IT基础设施和核心业务都具有重要意义。网络安全风险一直是一个很大的突破口，特别是在移动互联网、云计算、物联网、人工智能等新兴技术带来的全新的网络环境中。网络空间安全可以提供以下优势：

1. 提高网络安全性：运营商的网络环境越来越复杂、变化频繁。对网络空间安全的控制是企业获得保障的关键，它能够有效抵御各种攻击和入侵行为，保障网络资源的持续可用。

2. 保障核心业务：NSS可以有效防止核心业务的中断，同时支持公司快速响应、应对突发事件。

3. 促进网络管理：NSS可以有效提升网络的管理能力，支持运营商的日常维护和监测工作，帮助运营商在技术与管理上的平衡，实现网络稳定、高效运营。

总结以上优势，网络空间安全保障应成为各级政府、各类运营商、互联网服务供应商和消费者共同关注的重点课题，推动网络空间安全与运营商的商业模式、生态圈以及未来发展方向相结合，共同构建起高安全、高性能、高易用、高扩展、高韧性的网络环境。

# 2.核心概念与联系
## 1.网络安全的定义
网络安全是指保护计算机系统、信息网络、传输链路和路由器等构成信息基础设施的安全，包括网络设备、计算机网络、应用系统和网络服务等。网络安全包括认证、授权、审计、检测、防范、记录、处置五个方面，涉及到网络的完整生命周期。网络安全的关键在于解决网络安全边界，定义良好的安全策略，统一、可控的网络管理和运营流程，以及完善的应急预案。

## 2.运营商网络安全的特性
- 节点的动态性：网络中的每一个设备都可能会发生变化，如设备掉电、被攻击或被替换，对网络安全的影响也是不可忽视的；
- 多方参与的复杂性：由于涉及不同部门之间的协作，网络安全也会受到多方面因素的影响，如操作系统和应用软件的不当行为，业务的混乱，运营商的内部纠纷等；
- 大规模复杂的攻击环境：网络安全的目标是最大程度上保障网络运行的稳定性和可用性，但是由于网络规模庞大且复杂，安全攻击环境不容小视。网络攻击、防御、检测、响应、报警等环节都会受到高度的变化和升级。
- 深层次的网络特征：网络不仅包括数据流经的网络链路，还包括网络之上的各种协议和应用程序。因为复杂的网络结构带来了新的安全问题，比如防火墙、DNS服务器、负载均衡、VPN、SSL/TLS、网络管理等。

## 3.网络空间安全与运营商网络的关系
网络空间安全关注的是整个互联网系统的安全，而运营商网络安全则是保护运营商内部的网络系统安全。网络空间安全是面向全球的网络安全，侧重点是如何更好地保障各类网络的安全、规范和可靠运行。在网络空间安全领域，越来越多的研究论文涌现出来，试图找出新的网络安全方法、工具、平台。

网络空间安全和运营商网络安全之间有较强的依赖性。只有构建起符合要求的安全策略、流程和管理机制，才能真正有效地保障运营商网络的安全。通过互联网、云计算、物联网、人工智能等新技术的发展，越来越多的运营商开始采用多元化的网络架构，这些架构由不同的设备和协议组成，它们之间又存在密切的交互作用。网络空间安全需要充分考虑到这一多样化的网络架构，把握网络安全边界，制定出统一的、可控的安全策略，建立健全的网络管理体系，防范攻击者的入侵，提升运营商网络的整体安全水平。

## 4.加密、认证、访问控制、授权、审计、防火墙、数据中心隔离、容器技术、虚拟网络、终端安全、漏洞扫描等

加密：加密是保障网络通信过程中的信息安全的一种方法。加密方法是为了防止敏感数据被窃取、篡改、改变，而将数据转换为不可读的信息，只有知道加密密码的人才能解密。常用的加密方法有DES、AES、RSA等。

认证：认证是指验证实体身份、提供身份认证。其中最常用的就是用户名密码方式，网站或软件登录时输入用户名和密码，服务器根据数据库中保存的用户名和密码进行匹配校验，如果成功就认为用户已成功登录。

访问控制：访问控制是网络安全的一种重要机制，用于限制特定用户或主机对网络的访问权限。常用的访问控制方式有IP白名单、MAC地址黑名单、VLAN分区、ACL表等。

授权：授权是指控制对网络、数据的访问权限。授权的方式有角色-用户绑定、基于密钥的访问控制、基于数据加密的访问控制等。

审计：审计是记录用户活动、系统运行情况的过程。审计功能能够检查网络的安全日志，记录每个用户的登录、操作、数据变更等行为，便于管理员对网络的运行状况、安全事件进行监督和跟踪。

防火墙：防火墙是网络安全的重要组成部分。它是一种屏蔽入侵连接、阻止恶意攻击的软硬件设备。防火墙通常安装在网络出口和网络核心设备上，具备抵御攻击、保护网络免受攻击等多个功能。

数据中心隔离：数据中心隔离是指在不同的物理环境下部署不同的虚拟网络，使得一个物理网络上的数据不被其他物理网络上的实体获取、泄露。数据中心隔离可以有效降低数据泄露、恶意攻击的风险。

容器技术：容器技术是一种轻量级虚拟化技术，能够将软件打包成独立的软件单元，从而实现应用的自动化、标准化和部署。容器技术有利于实现微服务架构、弹性伸缩、高可用和灰度发布。

虚拟网络：虚拟网络是指将物理网络划分成逻辑网络，使得两个逻辑网络间可以通过路由器、交换机等网络设备连接起来。每个虚拟网络可以分配独立的IP地址范围，实现私有网络的创建。

终端安全：终端安全是指网络设备的固件和软件的更新和配置，对网络设备的攻击和入侵行为予以识别、过滤、阻断。终端安全的做法一般是通过设备的接口、系统监控、事件监测等手段，实时发现安全威胁。

漏洞扫描：漏洞扫描是通过检测软件或硬件产品是否存在漏洞，并对其修补、更新等保护措施来保护网络设备的安全。漏洞扫描是网络安全的重要一环，可以为网络管理员发现网络的潜在风险并对其进行预防和处理。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 1.判定算法DFA（Deterministic Finite Automaton,确定有穷自动机）
### （1）概述
DFA（Deterministic Finite Automaton,确定有穷自动机），是一种最简单的形式状态自动机，它具有线性时间复杂度，可用于判断字符串是否属于某个语言，尤其用于判定一个字符串是否合法。其定义如下：

q_0&: Q\\\\
F&:\cup_{s\in F}S\\
\delta(q,a): q\in Q,\quad a\in\Sigma, q'\in Q\Rightarrow \delta(q,a)=q'\\\Rightarrow 
\begin{array}{l}
Q=\\{q_1,q_2,\cdots,q_n\\}\in Q\\\\
\Sigma=\{a_1,a_2,\cdots,a_m\\}\in \Sigma\\\\
\end{array}\quad s.t.\quad q_i\neq q_j,|\delta(q_i,a)|=1, i,j=1,2,\cdots,n,\forall a\in\Sigma.

### （2）算法原理
DFA的执行过程可以表示为：输入串|w|，初始状态q0，转移序列Δ，最终状态集F，如果存在一条路径|w|=n，使得最后停留在F中的状态q_(n+1)，那么接受，否则拒绝。

DFA的算法原理如下：

1. 判断输入串w是否为空，若为空，则返回FALSE；
2. 从q0开始，依据转移表Δ执行转移，直至转移到q_(n+1)，或到达n，如果q_(n+1)\in F，返回TRUE；否则返回FALSE。

DFA的存储结构：状态转移表|δ|(q,a), δ(qi,ai)=qj表示在状态qi下，接收字符ai后的状态为qj。DFA的状态集合Q={q1,q2,...,qn},符号表Σ={a1,a2,...,am}.

## 2.识别算法NFA（Nondeterministic Finite Automaton,非确定有穷自动机）
### （1）概述
NFA（Nondeterministic Finite Automaton,非确定有穷自动机）是一种复杂形式状态自动机，具有非线性时间复杂度，可用于判定字符串是否属于某个语言，也可以用于生成所有属于该语言的字符串。其定义如下：

q_0&: Q\\\\
F&:\cup_{s\in F}P\\
\delta((q,b),\epsilon):\{(q',p')\mid (q',p')\in\delta(q,b),(q',p')\notin\epsilon\}\\
\delta((q,b),(c\sigma)): \{(q',p')\mid (q',p')\in\delta(q,bc), p'=(p\sigma)\cap P,(q'\neq\emptyset)\}\\\Rightarrow \\
\begin{array}{l}
Q=\\{q_1,q_2,\cdots,q_n\\}\in Q\\\\
\Sigma=\{a_1,a_2,\cdots,a_m\\}\in \Sigma\\\\
\end{array}\quad s.t.\quad q_i\neq q_j, |\delta(q_i,a)|\leq K_{\delta}, i,j=1,2,\cdots,n,\forall a\in\Sigma.

### （2）算法原理
NFA的执行过程可以表示为：输入串|w|，初始状态q0，转移表Δ，最终状态集F，如果存在一条路径|w|=n，使得最后停留在F中的状态q_(n+1)，或到达n，并且所有前面状态都有ε转移，那么接受，否则拒绝。

NFA的算法原理如下：

1. 判断输入串w是否为空，若为空，则返回FALSE；
2. 如果ε∈Σ，则从q0开始，分别对输入串w的第i个元素执行ε∈Σ的ε转移，结果为状态集E；否则从q0开始，依据转移表Δ执行转移，直至转移到q_(n+1)，或到达n，并且所有前面状态都有ε转移，然后返回TRUE；否则返回FALSE。

NFA的存储结构：状态转移表|δ|(q,a), δ(qi,ai)=qj*p表示在状态qi下，接收字符ai后的状态集qj,状态标记p。NFA的状态集合Q={q1,q2,...,qn},符号表Σ={a1,a2,...,am}.

## 3.克努斯-莫里斯范式
### （1）概述
克努斯-莫里斯范式（Kleene's form）是一个语法表示形式，是对正则表达式的一种表达形式。克努斯-莫里斯范式是一种替代正则表达式的形式，采用等价的形式表示正则表达式，且比正则表达式的运算速度快。克努斯-莫里斯范式是非确定有穷自动机的形式，表示正则表达式p和q的差集用~p表示。

### （2）关系式
- 对任意字符集合Σ，~p，p，q∈Λ*；
- ~ϕ~=ϕ；
- ~(p|q)~=~p~\&\&~q；
- ~(p+q)~=~p~\&\&~q；
- ~~ϕ~~=ϕ。

## 4.卢卡斯-艾奇公式
### （1）概述
卢卡斯-艾奇公式（Rice-Chaos Formula）是一种矩阵理论，用于计算最小的包含所有字符串的集合，或者可以划分为一个包含所有正则表达式的集合。它可以在多项式时间内计算出集合，并给出最小的集合。

### （2）计算步骤
1. 构建含有ε的初始状态的有穷自动机M∈Λ*(Q,Σ,{ε},{q0});
2. 若Ω∉Λ*，则令Ω={ε};
3. 重复下列过程直至收敛：
   - 寻找q∈Q使得δ(q,ε)!=∅;
   - 将δ(q,ε)∪{ε}加入Ω;
   - 删除M中所有δ(q,β)∈M;
   - 更新M的状态集合Q;
4. 返回Ω.

### （3）计算矩阵
矩阵C[i][j]代表从状态q_i出发，可以接受长度为j的串的个数。


其中，δ(qr)表示从状态q出发，接收r个字符后，进入状态r。

### （4）计算矩阵行列式
行列式的值表示可以接受的串的数量，值越小越好。


## 5.霍尔弗雷特算法（Halting Problem Algorithm）
### （1）概述
霍尔弗雷特算法（Halting Problem Algorithm）是一种用来判断一个通用计算程序是否永远不会终止运行的算法。它利用了“从先前计算出的中间结果推导出未来计算的结论”这一困难的数学问题。计算模型为确定性有穷自动机（DFA）。该算法能直接判定DFA是否会无限循环。

### （2）基本思想
本质上，霍尔弗雷特算法通过构建一个DFA，模拟各种可能性，并检查其是否能终止运行。算法假设有一个特殊的初始状态，当它被激活时，则算法认为程序无限期地运行，因为它不知道何时停止。为了使算法能够正确地判断计算程序是否会终止运行，必须设计合适的转移规则，使之能够精准地模拟各种可能性。

具体步骤如下：

1. 初始化一个空的计算栈和一个特殊的初始状态，压入栈顶。
2. 当栈非空时，弹出栈顶的状态q，如果q是最终状态，则返回TRUE，程序无限期地运行；否则，对q的所有邻接状态进行遍历，对每一个邻接状态进行如下操作：
   1. 按顺序从栈顶开始，将与q有关的历史状态全部移除栈顶，压入刚才访问到的状态。
   2. 将q压入栈顶。
   3. 在栈顶添加该状态的边，即使将q的任意一个邻接状态压入栈顶。
   4. 检查是否有从q出发的循环存在，如果有，则说明该计算程序会无限期地运行，返回FALSE；否则继续循环。
3. 如果栈为空，则程序可能终止运行，返回TRUE。

### （3）存在性定理
对于任意的DFA M，存在算法HALT，能够判定DFA是否会无限期地运行。

存在性定理可以表述为：存在算法HALT，能够判定任意DFA M是否会无限期地运行，这实际上意味着存在一种方法，可以确切地模拟任意DFA M在各种可能性下的运行，并检查其是否能无限期地运行。

### （4）优化
优化方案如下：

1. 不再从初始状态开始模拟，而是从其余各状态开始模拟，这样可以加速算法的运行，只需检查从栈底的各状态是否能导致程序无限期地运行即可。
2. 可以将所有有向图转化为无向图，这样可以减少算法的时间复杂度。
3. 根据需要设置参数k，表示从初始状态开始模拟时，需要保留栈顶的状态数量，超过k后再抛弃状态。

# 4.具体代码实例和详细解释说明
## 1.判定算法DFA（Deterministic Finite Automaton,确定有穷自动机）
```python
def DFA(input_str, dfa):
    """
    input_str: str, the string to be tested.
    dfa: dict {state: {(char, next_state)}, final_states},
         state is int from 0, char is in '01', and state can't repeat itself as key.

    return True if input_str is valid by given DFA else False.
    
    Example:
    >>> # Define DFA with initial state 0 and final states [3].
    >>> # States of DFA are represented as numbers 0, 1, 2, 3. 
    >>> # Transition rules are {(from_state, input_char): next_state}.
    >>> dfa = {0: {'0': 1, '1': 2},
   ...        1: {'0': 1, '1': 3},
   ...        2: {'0': 3, '1': 3},
   ...        3: {}}
    >>> print(DFA('0101', dfa))  # Output: True
    >>> print(DFA('0110', dfa))  # Output: False
    """
    current_states = set([0])   # Set current states to start.
    for char in input_str:
        new_current_states = set()
        for current_state in current_states:
            for rule in dfa[current_state]:
                if rule == char:
                    new_current_states.add(dfa[current_state][rule])
        current_states = new_current_states
        
    if len(current_states & dfa['final_states']):    # If there exists any final state in intersection of both sets, accept it.
        return True
    else:
        return False


if __name__ == '__main__':
    import doctest
    doctest.testmod()
```
## 2.识别算法NFA（Nondeterministic Finite Automaton,非确定有穷自动机）
```python
class NFA():
    def __init__(self, nstates, alphabets, delta, start_states, final_states):
        self._nstates = nstates      # Number of states.
        self._alphabets = list(alphabets)     # List of characters that represents inputs.
        self._start_states = start_states      # Starting state(s).
        self._final_states = final_states      # Final state(s).

        self._delta = {}                # Dict to store transition rules.
                                            # Format: {state: [(next_state, output),...]}
        for state in range(nstates):
            self._delta[state] = []
        
        # Initialize transitions.
        for rule in delta:               # Rule format: ((prev_state, prev_output), next_state)
            prev_state, prev_output = rule[0]
            next_state = rule[1]

            self._delta[prev_state].append((next_state, prev_output))


    @property
    def num_states(self):
        return self._nstates
    

    def run(self, inputs):
        """
        Run nondeterministic finite automaton on given inputs.
        
        Args:
          inputs: A sequence of characters.
          
        Returns:
          Return True if all strings accepted or False otherwise.
        
        Example:
        >>> # Define NFA with two starting states and one final state. 
        >>> # There are three states 0, 1, 2 representing respectively S, ε, F. 
        >>> # State 1 accepts only '0'. It has epsilon transitions to state 2.
        >>> # From state 0, it could either go to state 1 via character '0' or state 2 via epsilon.
        >>> nfa = NFA(nstates=3, alphabets={'0'}, delta=[(((0,), ''), 1), (((1,), '0'), 2)], 
       ...           start_states=[0], final_states=[2])
        >>> print(nfa.run(['0']))  # Output: False
        >>> print(nfa.run([]))    # Output: True
        """
        stack = [(self._start_states, '')]       # Stack stores tuples (states, outputs) where each tuple indicates
                                                # which states have been visited so far and what their corresponding
                                                # output should be concatenated before transitioning to the next state.
        
        while stack:
            current_states, outputs = stack.pop()
            
            if not current_states:                  # If no more current states exist, check whether we have found at least
                                                    # one path ending in a final state. Otherwise, reject this string.
                continue
                
            last_state = max(current_states)        # Find the last added state among current ones.
            
            if last_state in self._final_states:     # We've reached a final state, accept this string.
                return True
            
            output = ''                             # Concatenate existing output first.
            for c in reversed(outputs):
                output += c
            
            for input_symbol in self._alphabets:     # Generate input symbols after current position to add to stack later.
                next_states = set()                 # Next possible states due to this symbol.

                for curr_state in current_states:
                    for trans_rule in self._delta[(curr_state, input_symbol)]:
                        _, next_state = trans_rule

                        if isinstance(next_state, tuple):
                            next_state, output_string = next_state

                            output += output_string

                        next_states.add(next_state)
                        
                stack.append((next_states, output + input_symbol))

        return False


if __name__ == '__main__':
    import doctest
    doctest.testmod()
```
## 3.克努斯-莫里斯范式
```python
import re

class RegexParser:
    def parse(self, regex):
        try:
            tree = re.compile(regex)             # Compile regular expression into AST.
        except re.error:
            raise ValueError("Invalid Regular Expression")

        parser = self._build_parser()          # Use Parser Expression Grammar to construct postfix notation.
        postfix_notation = parser.parse(tree)
        
        return postfix_notation

    
    class _BuildParser:
        def __init__(self):
            pass


        def parse(self, node):
            method_name = "visit_" + type(node).__name__

            visitor = getattr(self, method_name, None)

            if not visitor:
                raise NotImplementedError("Method visit_%s not implemented" % type(node).__name__)

            result = visitor(node)

            return result
            
        
        def visit_Concat(self, node):
            left_expr = self.parse(node.left)
            right_expr = self.parse(node.right)

            return ['CONCAT'] + left_expr + right_expr


        def visit_Or(self, node):
            left_expr = self.parse(node.left)
            right_expr = self.parse(node.right)

            return ['OR'] + left_expr + right_expr

        
        def visit_Repeat(self, node):
            expr = self.parse(node.expr)

            if not expr[-1] == 'CONCAT':
                raise ValueError("Regular expressions must be of the form a* b.")

            repeated_part = expr[:-1]

            prefix = ['REPEAT'] * node.min + ['OPTIONAL'] * node.max

            return prefix + repeated_part


        def visit_Literal(self, node):
            return [node.value]


    def compile(self, postfix_expr):
        stack = []                         # Stack used to evaluate postfix notation.
        for token in postfix_expr:
            if token in ('AND', 'OR', 'NOT'):
                right_operand = stack.pop()
                left_operand = stack.pop()

                if token == 'AND':
                    result = lambda x: left_operand(x) and right_operand(x)
                elif token == 'OR':
                    result = lambda x: left_operand(x) or right_operand(x)
                elif token == 'NOT':
                    result = lambda x: not left_operand(x)
                    
            else:                            # Token is an atom like '(foo)', '[bar]', etc. 
                value = ''.join(token)[1:-1]
                
                if '[' in value and ']' in value:
                    result = lambda x: value[1:-1] in x                     # Character classes.
                else:
                    result = lambda x: value in x                           # String literals.

                
            stack.append(result)             # Push evaluated function onto stack.
        
        compiled_expr = stack.pop()

        return compiled_expr
    
if __name__ == "__main__":
    regex_parser = RegexParser()
    postfix_notation = regex_parser.parse("(a|b)*abb")
    compiled_expr = regex_parser.compile(postfix_notation)

    assert compiled_expr('') == True
    assert compiled_expr('ababba') == True
    assert compiled_expr('aba') == False
    assert compiled_expr('bbbbbbbbbaaaabaaabaaa') == True
```
## 4.卢卡斯-艾奇公式
```python
import numpy as np
import networkx as nx

def rice_chasies_algorithm(G):
    """
    G: A NetworkX graph object.
    
    Compute minimum accepting set of Rice Chasies algorithm using graph G.

    Example:
    >>> G = nx.DiGraph()
    >>> G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 4), (3, 4)])
    >>> print(rice_chasies_algorithm(G))  # Output: {2, 3, 4}
    """
    edges = set()                          # Edges in minimal accepting set.
    vertices = set(range(len(G)))          # All nodes in graph.
    accepting_nodes = set()                # Nodes in minimal accepting set.
    subgraphs = []                         # List of disjoint subgraphs obtained during iteration.
    queue = []                             # Queue of unexplored subgraphs.

    # Add initial subgraph containing all nodes to queue.
    subgraphs.append(vertices)
    queue.append(subgraphs[0])

    while queue:
        V = queue.pop(0)                    # Get oldest subgraph from front of queue.
        E = frozenset(map(tuple, sorted(nx.subgraph(G, V).edges())))            # Obtain canonical edge ordering for this subgraph.

        if E not in edges:                   # Check whether edge ordering has already been seen before.
            edges.add(E)                      # Add edge ordering to history.

            neighbours = map(lambda v: (v, V & set(G.neighbors(v))), V)
            incoming_neighbourhoods = [V | set([u]) for u, v in neighbours]      # Incoming neighbourhoods for each vertex in subgraph.

            # Update neighbors of current subgraph based on incoming neighbourhoods of previous iterations.
            for W, X in zip(incoming_neighbourhoods, subgraphs[:len(incoming_neighbourhoods)]):
                union = W | X

                if union!= V:
                    if union not in subgraphs:           # Check whether subgraph has already been explored.
                        subgraphs.append(union)          # Append new subgraph to list.

                    idx = subgraphs.index(W)              # Index of subgraph to insert adjacent subgraph.
                    inserted = False

                    for j in range(idx, len(subgraphs)):
                        if subgraphs[j] >= union < subgraphs[j-1]:   # Insert new subgraph between adjacent existing subgraphs.
                            subgraphs.insert(j, union)
                            inserted = True
                            break

                    if not inserted:                                    # New subgraph is largest, append to end of list.
                        subgraphs.append(union)

                    queue.append(union)                        # Add new subgraph to queue for exploration.

            if V <= G.nodes():                     # If current subgraph covers all nodes, update acceptance condition.
                accepting_nodes |= V

        else:                                   # Edge ordering has already been seen before, stop searching.
            continue

    return accepting_nodes


if __name__ == '__main__':
    G = nx.DiGraph()
    G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 4), (3, 4)])
    assert rice_chasies_algorithm(G) == {2, 3, 4}
```