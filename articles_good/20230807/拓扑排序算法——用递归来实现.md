
作者：禅与计算机程序设计艺术                    

# 1.简介
         
19世纪70年代，约翰·冯·诺伊曼（<NAME>）提出了著名的拓扑排序算法“拓扑结构”（Topology），其思想就是把复杂系统中的元素按照它们之间关系的层级结构进行分类，从而使各个元素能够按一定次序彼此联系起来，形成一个系统的总体视图或者功能视图。具体到计算机领域，可以对一个软件系统或硬件系统中存在的各种计算实体之间的依赖关系进行一种树形结构的组织，并使得它能够顺利运行、正常工作。因此，拓扑排序算法自然成为各种工程应用中的重要工具之一。今天，随着人工智能、云计算、物联网、大数据等新一代信息技术的发展，拓扑排序算法也得到越来越多的人们关注。
         在本文中，将通过比较、分析、实践三方面来讲解拓扑排序算法。首先，我们会介绍一下该算法的一些基本概念及术语，然后介绍拓扑排序算法的主要思路及算法流程。最后，我们会展示一些拓扑排序算法的相关实例代码，并在此基础上进行详细阐述。
         # 2.基本概念及术语
         ## 2.1 图（Graph）
         “图”是拓扑排序算法的核心数据结构。一般情况下，一个图是一个由边（edge）和节点（node）组成的集合，其中边表示两个节点间的连接关系，节点则表示某种资源或活动。在拓扑排序算法中，每个节点对应于系统的一个活动或实体，而边则表示活动之间的相互依赖关系，两者合称作“图”。如下图所示:


         上图中，左边的虚线箭头表示存在依赖关系，右边的虚线箭头则表示不存在依赖关系。

         有向无环图（Directed Acyclic Graph, DAG）是最简单的一种图。它由顶点的有限集V和边的有限集E组成，满足下面两个条件：

         1. 每条边都指向一个前驱顶点，即从源点开始，沿着一条有限路径遍历图时遇到的顶点恰好只有一条路径上的边；
         2. 没有回路，即不存在从任何顶点到达目的地的回路。

         当且仅当图中不存在回路时，图才具有拓扑序列。

         ## 2.2 拓扑序（Topological Order）
         拓扑序是指在图G中所有顶点的一种排列顺序，使得任意两个相邻顶点之间都存在一条直接的路径，即如果$u$和$v$之间存在一条路径，那么它们也同时在拓扑序中。拓扑序是一个序列，对于任意两个顶点u和v，如果$u$在$v$之前出现，则u先于v进入拓扑序；如果$u$和$v$之间没有任何边，则u和v可以不分先后进入拓平序。例如，在下图的DAG中，{1,2,3,4}和(5,6,7)都是拓扑序，但{4,2,1,3}不是。


         ## 2.3 强连通性（Strongly Connected Component）
         如果图G中存在环，则称G为有向图，否则为无向图。无向图G=(V, E)可以转化为有向图Gd=(Vd, Ed), 其中Vd是G的顶点集，Ed={(u, v): u∈Vd, v∈Vd, (u, v)∈E 或 (v, u)∈E}, d(u)=max{d(x)|x∈Vd, (u, x)∈E}. 如果(u, v)∉E, 则d(u)>d(v)。

         Gd的强连通组件（SCC, Strongly Connected Components）是形如C = {v1,v2,...vk}的所有有向子图，对于每个v∈C，设Gi=(Vi,Ei)是将G限制至C和以v为根的子图，Ei={(u,v): u∈Vi, v∈Ci, (u, v)∈E}, Dg(i)=min{Dg(j)|j∈C，vj∈Ni}, Ni是Gi的顶点集，使得Dg(i)<+inf。比如在下面的图中，C={A,B,C}对应的DGi为{Ai,Bi,Ci}。


         对上图的DG(i)，由于其链路长度为0或负值，故不存在Dg(i)<+inf。故{A,B,C}为图G的强连通组件。

         ## 2.4 二叉树（Binary Tree）
         二叉树是一个节点序列，第一个节点被称作根节点，其他节点均有且仅有一个前驱节点，可以有零个或多个后继节点。二叉树具有下列性质：

         1. 每个节点都有且仅有一个父节点，除了根节点；
         2. 每个非根节点都有且仅有一个左孩子和一个右孩子；
         3. 中序遍历，即左孩子，根节点，右孩子。

         二叉树的另一种形式是满二叉树，它是一棵深度为k且有2^k-1个叶子节点的二叉树。


         上图展示的是一棵满二叉树，第一行显示的是节点的编号，第二行显示的是父节点编号。

         ## 2.5 最小生成树（Minimum Spanning Tree, MST）
         最小生成树（MST）是指连接所有的节点构成的子图，它的权重是所有边权重的最小值，并且不含回路。以下是一些不同的算法可以用来寻找最小生成树：

         1. Kruskal's algorithm (Kruskal): 是一种贪心算法，每次选择一条权最小的边加入最小生成树，直至不能再加入为止。时间复杂度为O(|E|+|V|log|V|)。

         2. Prim's algorithm (Prim): 从一个单独的节点出发，依据选取边的权重，在最小生成树中选择一条连接节点的最小权值的边，每一次都要保证图中存在这样一条边。时间复杂度为O(|E|^2).

         3. Boruvka's algorithm: 是一种比较快的算法，其基本思想是将图划分成一些更小的子图，并递归地求解这些子图的最小生成树，之后合并得到最终的结果。时间复杂度为O(|E|log|V|)。

         下面给出一个例子，给定一张带权图，要求找到一个具有最小权值的生成树，可以使用Kruskal的算法来解决这个问题。


         此图是一个带权图，黑色代表源节点，红色代表目标节点，蓝色代表可能的节点，边的权重分别是3, 6, 5, 2, 7, 3, 5, 7。采用Kruskal算法，每次将一条边加入生成树，得到的结果为：


         此时边的权重为12，可以看出，这是一条最小生成树。

         # 3. 拓扑排序算法的思路及算法流程
         拓扑排序算法的主体思路是对DAG图的每个节点进行拓扑排序，从而获得每个节点的执行顺序。拓扑排序算法可以分为三个步骤：

         1. DFS遍历：先以某节点为起点进行DFS遍历，然后根据访问顺序更新拓扑序列。

         2. 删除节点：删除已确定完成的节点及其关联的边。

         3. 确认是否结束：当图为空时，拓扑排序已经结束。

         ## 3.1 DFS遍历
         DFS遍历是拓扑排序算法的一个基本过程。对一个有向图的DFS遍历可以分为两个阶段：深度优先搜索（DFS）阶段和回溯阶段。

         1. 深度优先搜索（DFS）阶段：从某个节点开始，沿着其可达路径一直到图的底端。

            * 设置一个栈用于存放需要探索的节点，初始压入栈的是起始节点。
            * 循环处理栈内的节点：
                - 将当前节点标记为“已访问”，并弹出节点；
                - 查看当前节点的每个邻接节点：
                    + 如果邻接节点没有被访问过，就压入栈中，并设置邻接节点为“当前节点”；
                    + 如果邻接节点已经被访问过，就检查它的父节点是不是当前节点。如果不是，说明它已经被删掉，需要重新创建一条连接它的边。

             DFS结束后，整个图的所有节点都应该都处于“已访问”状态。

         2. 回溯阶段：回溯阶段是用来消除标记“已访问”的节点的。

             * 检查所有节点是否都被标记为“已访问”，如果没被标记，说明有回路。
             * 如果图中有回路，则从某个节点出发，沿着回路查找最近的已访问节点作为终止节点。
               - 根据回路中边的方向，逆序判断是否已经访问过的节点；
               - 逆序推算每个节点的祖先；
               - 保留所有“祖先”中与回路中第一个已访问节点相关的边。
             
           可以看到，DFS遍历过程中，每访问一个节点，都要维护堆栈和已访问节点列表。为了减少内存的使用，可以在遍历图的同时记录当前正在访问的节点。当某个节点被删掉时，要重新建立与它相关的边，这就需要保存边的信息。

           假设一个节点被压入堆栈，则在回溯过程中，只需检查它的子节点是否还在堆栈中即可。因为如果该节点的子节点被删掉了，就无法继续访问。

        ## 3.2 删除节点
        图的节点有两种情况：第一种是已经确定的，比如系统中的活动，另一种是尚未确定，比如等待启动的任务。对于已经确定的节点，就可以在算法的执行过程中，把它及其关联的边全部删掉。

        ## 3.3 确认是否结束
        一旦所有节点都被删掉，则表明拓扑排序已经结束。算法的时间复杂度为O(|V|+|E|)，其中|V|为图中顶点的数量，|E|为边的数量。

        # 4. 拓扑排序算法的实例代码
        ## 4.1 基于DFS的代码
        ```python
        def topological_sort(graph):
            visited = set()    # 已访问节点集合
            stack = []        # DFS栈
            order = []        # 拓扑序列

            for node in graph:      # 遍历图中所有节点
                if node not in visited and len(list(graph[node])) == 0:   # 若节点尚未访问，且无邻接节点，则压入栈
                    visited.add(node)
                    stack.append(node)
            
            while stack:           # DFS遍历
                current = stack.pop()    # 弹出栈顶元素
                order.append(current)    # 添加到拓扑序列
                
                for neighbor in graph[current]:   # 遍历当前节点的所有邻居
                    if neighbor not in visited:     # 若邻居尚未访问
                        visited.add(neighbor)       # 标记为已访问
                        stack.append(neighbor)       # 把邻居压入栈
            
            return order          # 返回拓扑序列
        
        # 测试
        g = {'A': ['B', 'D'], 'B': ['C'], 'C': [], 'D': ['C']}
        print(topological_sort(g))   # ['D', 'B', 'A', 'C']
        ```

        ## 4.2 基于DFS的优化版代码
        ### （1）去除无后效性的边
        因为在回溯阶段需要对边进行标记，因此对于图中的每个节点，都需要存储其所有的邻接节点，即便只有一个邻接节点，也需要进行完整的遍历。因此，可以通过创建一个新的图，把那些无后效性的边去掉，来降低内存使用。

        ### （2）高效的删除节点
        删除节点的操作比较麻烦，需要修改所有的邻接节点信息。因此，可以通过创建一个“临时邻接表”来记录待删除节点的邻接节点，在回溯阶段再对邻接表进行更新。

        ### （3）基于Python实现
        ```python
        class Node:
            def __init__(self, name=''):
                self.name = name
                self.indegree = 0
                self.outedges = {}  # 以字典方式记录邻接节点及其权重
        
        def create_graph():
            """创建图"""
            nodes = {}
            edges = [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C')]
            for edge in edges:
                start, end = edge
                if start not in nodes:
                    nodes[start] = Node(start)
                if end not in nodes:
                    nodes[end] = Node(end)
                nodes[start].outedges[nodes[end]] = 1
                
            return nodes
                
        def delete_node(node, graph):
            """删除节点及其邻接边"""
            del graph[node.name]
            for parent, child in list(graph.items()):
                if child is None or isinstance(child, str): continue
                if node in child.outedges:
                    del child.outedges[node]
                    
        def dfs(root, graph):
            """DFS遍历"""
            visited = set([root])
            stack = [root]
            while stack:
                current = stack[-1]
                unvisited_children = [n for n in current.outedges if n not in visited]
                if unvisited_children:
                    next_node = min(unvisited_children, key=lambda x: x.indegree)
                    stack.append(next_node)
                    visited.add(next_node)
                    update_indegree(next_node, graph)
                else:
                    stack.pop()
                    yield current.name
            
        def update_indegree(node, graph):
            """更新入度"""
            for child in node.outedges:
                child.indegree -= 1
                if child.indegree == 0:
                    queue.append((len(graph)-len(node.outedges)+1, child))
                        
        def get_order(graph):
            """获取拓扑序列"""
            queue = [(len(n.outedges), n) for n in graph.values()]
            result = []
            while queue:
                _, node = heapq.heappop(queue)
                result.append(node.name)
                delete_node(node, graph)
                if len(result) == len(graph): break
                    
                for child in node.outedges:
                    child.indegree += 1
                    heapq.heappush(queue, (child.indegree, child))
                    
            assert len(result) == len(graph)
            return result
        
        graph = create_graph()
        order = get_order(graph)
        print('拓扑序列:', order)
        ```

    本文通过比较、分析、实践三方面讲解了拓扑排序算法。首先介绍了图、拓扑序、强连通性、二叉树、最小生成树的基本概念和术语，介绍了拓扑排序算法的主体思路及算法流程。然后通过拓扑排序算法的实例代码，展示了如何利用DFS进行拓扑排序，以及如何优化DFS的代码。