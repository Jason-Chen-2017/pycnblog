
作者：禅与计算机程序设计艺术                    

# 1.简介
  

当今，企业越来越依赖云计算服务来获得快速、经济和弹性伸缩的能力。云原生架构正逐渐成为主流，而容器技术也已经在为企业提供更灵活、更高效的开发环境。

本文将从云原生架构和容器技术的角度出发，结合实际应用场景，系统全面剖析容器化及云原生架构的设计模式及优缺点，并为读者提供参考指导。
# 2.背景介绍
## 什么是云原生？
云原生（Cloud Native）的概念源于 Google 在 Kubernetes 上构建的容器编排系统 - Google Container Engine（GKE）。它是一种关于基础设施如何被设计来支持应用的观念。

云原生架构关注的是应用如何有效地利用云平台资源，并且可以应对不断变化的业务需求。云原生应用由一组自动化的组件构成，这些组件遵循云原生最佳实践，能够轻松部署、管理和扩展。云原生架构提倡按需分配资源、按量付费、高度抽象化以及可移植性等理念，因此使应用具有高度可扩展性、弹性和韧性。

云原生是一种架构风格，而不是一个产品或工具。它关注的是构建可移植且弹性的软件，旨在满足云计算平台上运行的应用所需的所有要求。

## 为什么需要云原生架构？
云原生架构作为一种架构风格，它适用于应用程序和基础设施之间的接口，它通过定义良好的方法和流程，帮助开发人员创建和维护可移植且可靠的软件，同时确保云服务供应商的竞争优势。

### 可扩展性
云原生架构鼓励通过自动化进行扩展，包括自动扩容、动态负载均衡以及弹性伸缩等功能，从而确保应用能够随着时间的推移保持性能最佳状态。

此外，云原生应用的设计模式也允许通过基于微服务架构模式的分离来实现可扩展性，因此可以独立地扩展各个服务而无需考虑整个应用的总体性能。

### 运维自动化
云原生架构利用容器技术和微服务架构，因此提供了大规模分布式系统的快速部署、弹性伸缩和自动修复的能力。因此，通过云原生架构，可以自动化和简化应用程序生命周期的管理，提升运维效率和响应速度。

### 可移植性
云原生架构通过抽象化和标准化底层硬件和软件，能够让应用程序在不同的云平台上无缝运行，从而实现应用程序的可移植性。

### 更灵活的开发环境
云原生架构能够给开发人员更多的灵活选择，例如，通过 Docker 和 Kubernetes 提供的工具和框架可以更快、更便捷地开发应用程序。

此外，云原生应用的设计模式还鼓励采用声明式编程模型，因此可以更轻松地更改运行时的配置，从而实现应用程序的高度灵活性。

### 敏捷开发和部署
云原生架构通过自动化和精益的工程实践，确保了开发人员和操作人员可以频繁交付新版本的应用程序，而不会导致停机或者数据丢失。这降低了开发和运营团队之间的沟通成本，缩短了恢复服务的时间，并保证了业务的连续性。

## 什么是容器？
容器是一个标准化的打包方式，用于发布软件应用程序。容器封装了应用、其运行时环境、依赖项和配置文件，使其可以在任何地方运行，无论是物理服务器还是虚拟机中。

容器通过隔离应用执行环境和依赖项，消除了由于环境差异导致的运行时错误，并减少了开发、测试和生产环境之间差异带来的影响。

## 为什么要使用容器？
容器具有以下几种优点：

1. 轻量级：容器共享主机操作系统内核，因此占用的内存较小，启动速度也较快。
2. 易于部署：只需一条指令即可完成容器的部署工作，无须繁琐的配置过程。
3. 一致的环境：容器镜像使得相同的软件可以在任意数量的主机上运行，从而降低了环境复杂性。
4. 弹性可扩展：通过添加更多的容器副本来扩展应用，并通过调度器自动处理调度问题，实现应用的高可用。

## 什么是Kubernetes？
Kubernetes 是 Google 在2014年公布的开源系统，用于自动化容器集群的部署、资源调度和管理。Kubernetes 是建立在 Docker 和 Linux 之上的容器编排系统，基于 RESTful API 的命令行工具，以及一个仪表板界面。

Kubernetes 可以管理跨多个云提供商、内部部署、私有云和混合环境的容器化应用。Kubernetes 具备了如下几个主要特点：

1. 服务发现和负载均衡：Kubernetes 提供的 DNS 解析和负载均衡功能，使应用能够通过自定义域名访问其他服务。
2. 存储编排：Kubernetes 提供了强大的存储编排功能，支持多种存储系统，如本地磁盘、云端储存、网络文件存储等。
3. 滚动升级：可以通过滚动升级的方式，升级 Kubernetes 中的某些节点上的应用，而不影响其他节点上的应用。
4. 自我修复：Kubernetes 会监控应用程序的健康状况，并自动替换出现故障的 Pod。

## 为什么要使用Kubernetes？
Kubernetes 有以下几个重要优点：

1. 自动化协调：Kubernetes 使用控制器机制来管理容器集群，无需人工干预，自动进行服务发现、资源分配、存储卷管理等任务。
2. 弹性伸缩：Kubernetes 支持水平扩展，允许用户根据当前负载情况动态增加或减少容器副本的个数，达到最大程度的利用集群资源的目的。
3. 自我修复：Kubernetes 根据用户设置的健康检查策略，检测容器的健康状况，并在需要时自动重启容器。
4. 可观测性：Kubernetes 提供了一套完整的可观测性解决方案，包括日志采集、指标收集和仪表盘展示等，帮助用户掌握集群的运行状态。

# 3.基本概念术语说明
## 什么是服务网格？
服务网格（Service Mesh）是一个微服务架构下用于实现服务间通信的基础设施层。其目标是在不修改应用程序代码的情况下，透明地向服务间添加可靠性、流量控制和安全防护等功能。

服务网格通过一系列轻量级的代理组件（Sidecar Proxy）拦截服务间所有的网络通信，然后在边界中插入网格中央的控制平面来管理和控制流量行为。

目前市面上主流的服务网格产品包括 Istio、Linkerd、Conduit、NGINX Service Mesh等。

## 什么是Istio？
Istio 是目前最流行的服务网格开源项目，由 Google、IBM、Lyft 和 Linode 公司共同创始，是一款为 Kubernetes 提供流量管理和安全服务的开源产品。

Istio 具有以下几个主要特征：

1. 流量管理：Istio 通过管理微服务间的流量，以及在流量出现故障时进行弹出保护，有效地实现服务的稳定性。
2. 可观测性：Istio 提供详细的流量日志、监控数据和跟踪，方便管理员和开发人员理解系统的运行情况。
3. 安全性：Istio 提供对服务间通信进行加密、认证和授权的功能，有效防止网络攻击、恶意行为、数据泄露等安全威胁。
4. 灰度发布：Istio 提供流量管理功能，支持应用的蓝绿发布、金丝雀发布等方式，将影响系统的部分流量引导至新版本上线。

## 什么是linkerd？
linkerd 是由 Criteo 开发的服务网格产品，旨在统一和简化微服务应用中的服务调用，由 Linkerd 控制面、Tap 分析、路由、速率限制等多个部分组成。

linkerd 具有以下几个主要特性：

1. 透明传输：linkerd 可以让微服务间的网络调用被完全地隐藏起来，避免服务调用方感受到被服务网格拦截的影响。
2. 应用级别路由：linkerd 提供丰富的路由规则，可以针对不同服务和请求路径设置不同权重的路由规则。
3. 熔断机制：linkerd 可以提供应用级的熔断机制，可以识别出服务的慢调用并直接返回失败的响应，从而避免整体服务的过载。
4. 多协议支持：linkerd 对 HTTP/1、HTTP/2、gRPC、Websockets 等协议都提供了完整的支持。

## 什么是Kubernetes Operator？
Kubernetes Operator 是一种通过自定义控制器来管理 Kubernetes 集群中一组相关的自定义资源的技术手段。Operator 以 Custom Resource Definition (CRD) 的形式定义新的资源类型，控制器会根据 CRD 中的定义来管理集群的某个应用或功能。

Kubernetes Operator 拥有以下几个主要优点：

1. 可扩展性：Operator 通过 CRD 提供的接口，使得第三方开发者可以自由地编写自己的 Operator 来管理自定义资源。
2. 自动化运维：Operator 将复杂的运维工作转变为 Kubernetes 集群中自动化的配置和管理，提升集群的运维效率。
3. 最终一致性：Operator 应用的配置和资源会在整个集群中最终保持一致的状态，不需要人工参与。

## 什么是云原生定义域模型？
云原生定义域模型（Cloud Native Computing Foundation Domain-Specific Language，CNCF DSM）是一个开放的、云原生的语言，描述了云原生应用开发的标准。该模型为开发者提供了一套完整的技术栈，可以用来构建和维护符合云原生规范的应用。

CNCF DSM 中有很多重要术语，如：容器、服务、编排、可观测性、服务网格、Kubernetes 等。这些术语在不同技术栈中可能有不同的翻译，但它们所表达的含义应该是相同的。

# 4.核心算法原理和具体操作步骤以及数学公式讲解
# 4.1 什么是部署 Kubernetes 集群？
为了部署 Kubernetes 集群，首先需要准备好集群所需要的机器。比如说，根据 Kubernetes 的官方文档，至少需要三个主节点和两个工作节点才能组成一个 Kubernetes 集群。

然后，分别安装 Docker、kubelet 和 kubectl。kubelet 是 Kubernetes 的核心组件，负责维护节点的生命周期，包括容器的创建和销毁；kubectl 是 Kubernetes 命令行客户端，可以用来管理 Kubernetes 集群；Docker 是 Kubernetes 集群容器运行环境，用于拉取镜像并启动容器。

最后，就可以按照 Kubernetes 安装文档一步步部署 Kubernetes 集群，包括初始化 master 节点、安装 kube-proxy、安装 flanneld 或 Weave Net、配置 kubelet 参数、安装 Dashboard、启用 Heapster 以获取集群性能数据。

# 4.2 Kubernetes 对象模型
Kubernetes 中的对象模型由五种主要类型构成：Pod、Node、Namespace、Service 和 Deployment。下面将介绍每个对象的基本属性，并给出一些示例用法。

## Pod
Pod 是 Kubernetes 集群的最小单位，表示一个或者多个容器的组合。

Pod 具有以下几个主要属性：

1. 唯一标识符：Pod 有一个唯一的 ID，称作 pod name。
2. IP地址和端口信息：Pod 会分配一个唯一的 IP 地址和端口范围，供其中的容器使用。
3. 紧密耦合的容器集合：Pod 中的所有容器共享 IP 地址空间和端口空间，彼此可以相互通信。
4. 存储：Pod 可以指定临时目录、共享卷或持久化存储。
5. 生命周期：Pod 会一直保持RUNNING状态，除非它的所有容器都结束了运行，或者被手动销毁。
6. 调度约束：Pod 可以设置调度约束条件，包括 CPU 和内存的要求，对特定 Label 的匹配，以及所需的 NodeSelector。

**示例用法**：

创建一个 nginx Pod：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
    ports:
    - containerPort: 80
```

注：通过 `labels` 属性给 Pod 指定标签，之后可以通过标签来过滤 Pod。

创建一个带有多个容器的 Pod：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: busybox-pod
  labels:
    env: test
spec:
  volumes:
  - name: emptydir-volume
    emptyDir: {}
  initContainers:
  - name: volume-init
    image: busybox
    command: ["sh", "-c", "sleep 30; touch /data/test"]
    volumeMounts:
    - mountPath: /data
      name: emptydir-volume
  containers:
  - name: busybox
    image: busybox
    command: ["/bin/sh","-c","echo Hello from Kubernetes cluster; sleep 3600"]
    volumeMounts:
    - mountPath: /data
      name: emptydir-volume
  terminationGracePeriodSeconds: 30
```

这个例子创建了一个名为 `busybox-pod` 的 Pod，其中包含了一个 `initContainer`，用于在 Pod 创建前初始化数据卷；还有多个 `containers`，分别运行 `BusyBox` 命令、永久运行。

## Node
Node 表示 Kubernetes 集群中的工作节点。每个节点都有运行 Kubelet 进程，用于维护容器的生命周期。

Node 具有以下几个主要属性：

1. 唯一标识符：Node 有自己唯一的名字和标签，可以用来区分不同的节点。
2. 主机名称：每个节点都有一个与之对应的主机名，可以使用 hostname 命令查看。
3. 容器运行时：每台 Node 都需要安装并运行指定的容器运行时，比如 Docker 或者 rkt。
4. 当前状态：Node 可以处于不同的状态，包括 Ready、NotReady、Unknown 等。
5. 容量信息：Node 可以查看当前系统资源的容量，包括 CPU、内存、磁盘空间等。
6. 操作系统信息：Node 可以查看当前节点的操作系统版本、内核版本、和 Docker 的版本信息。

**示例用法**：

查看所有 Node 列表：

```bash
$ kubectl get nodes
NAME      STATUS    ROLES     AGE       VERSION
node1     Ready     <none>    2h        v1.9.3
node2     Ready     <none>    2h        v1.9.3
```

查看指定的 Node 信息：

```bash
$ kubectl describe node node1 | grep -i capacity
Capacity: cpu:4 memory:16Gi pods:110
```

## Namespace
Namespace 是 Kubernetes 的逻辑隔离单位，用于划分集群资源。

Namespace 具有以下几个主要属性：

1. 命名空间名称：Namespace 有自己唯一的名字，使用时需要加上命名空间前缀，比如 default namespace 的名字叫做 `default`。
2. 命名空间标签：Namespace 可以设置标签，通过标签来过滤属于该 Namespace 的资源。
3. 资源配额：Namespace 可以设置资源配额，比如每个命名空间的 Pod 数量不能超过某个值。
4. 默认资源限制：Namespace 中的每个 Pod 默认只能使用分配给它的 CPU 和内存资源。
5. 终止事件：Namespace 可以设置当某些事件发生时，所有属于该 Namespace 的 Pod 会被删除。

**示例用法**：

创建一个新的命名空间：

```bash
$ kubectl create ns newns
namespace "newns" created
```

查看命名空间列表：

```bash
$ kubectl get namespaces
NAME          STATUS    AGE
default       Active    3h
kube-public   Active    3h
kube-system   Active    3h
newns         Active    5m
```

查看指定命名空间的信息：

```bash
$ kubectl describe ns newns | grep -i resource
Resource Quotas:
Name:            memory
Used:            0
Limit:           Not specified
Name:            pods
Used:            0
Limit:           Unbounded
```

## Service
Service 是 Kubernetes 中的服务发现和负载均衡器，提供单个 IP 地址和多个端口，让外部的客户端应用可以访问集群内的服务。

Service 具有以下几个主要属性：

1. 唯一标识符：Service 有自己唯一的名字和选择子，选择子决定了 Service 的路由策略，比如基于 label 选择，基于 IP 地址选择。
2. 负载均衡策略：Service 可以设置负载均衡策略，比如轮询、随机、基于 header 的内容哈希。
3. 服务发现：Service 可以通过服务发现机制来动态获取后端 Pod 的地址列表。
4. 连接代理：Service 可以提供连接代理，比如 Squid、HAProxy，用于隐藏后端真实 IP 地址，并提供其他高级功能。
5. 健康检查：Service 可以通过健康检查机制来监控后端 Pod 的健康状态，并自动移除不健康的 Pod。

**示例用法**：

创建一个 nginx Service：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  labels:
    app: myapp
spec:
  type: ClusterIP # 可选参数：ClusterIP、NodePort、LoadBalancer
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP # 可选参数：TCP、UDP、SCTP
  selector:
    app: myapp
```

这里的 `selector` 属性用于指定 Service 需要路由哪些 Pod，通过 labels 选择器来实现。

创建一个负载均衡 Service：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: myloadbalancer-service
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 80
    protocol: TCP
  selector:
    app: myapp
```

这里的 `type` 设置为 `LoadBalancer`，可以自动创建一个公网负载均衡器。

## Deployment
Deployment 是 Kubernetes 中的资源控制器，用来实现应用的声明式更新。它可以管理多个 ReplicaSet，负责实现应用的滚动更新、回滚和暂停/继续。

Deployment 具有以下几个主要属性：

1. 唯一标识符：Deployment 有自己唯一的名字和选择子，选择子决定了 Deployment 管理的 Pod 模版。
2. 镜像升级策略：Deployment 可以设置镜像升级策略，比如每次只升级一个 Pod，或者批次升级。
3. 发布时间：Deployment 可以设置发布时间，只有到指定的时间才会开始发布。
4. 回滚：Deployment 可以设置回滚策略，当发布失败时，可以回滚到之前的版本。
5. 历史记录：Deployment 可以保存发布历史，可以通过历史记录来回滚到之前的版本。

**示例用法**：

创建一个 nginx Deployment：

```yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: myapp-deployment
  labels:
    app: myapp
spec:
  replicas: 3 # 每次发布都会创建三个 Pod，也可以修改或增加副本数量
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

注：这里的 apiVersion 是 apps/v1beta1，这是因为 Deployment 这个资源是在 v1.9 中引入的，之前的版本没有。

创建一个带有多个容器的 Deployment：

```yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: busybox-deployment
  labels:
    env: test
spec:
  replicas: 3
  strategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
  minReadySeconds: 5
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: busybox
  template:
    metadata:
      labels:
        app: busybox
    spec:
      volumes:
      - name: emptydir-volume
        emptyDir: {}
      initContainers:
      - name: volume-init
        image: busybox
        command: ["sh", "-c", "sleep 30; touch /data/test"]
        volumeMounts:
        - mountPath: /data
          name: emptydir-volume
      containers:
      - name: busybox
        image: busybox
        command: ["/bin/sh","-c","echo Hello from Kubernetes cluster; sleep 3600"]
        volumeMounts:
        - mountPath: /data
          name: emptydir-volume
      restartPolicy: Always
```

这个例子创建了一个名为 `busybox-deployment` 的 Deployment，其中包含了一个 `initContainer`，用于在 Pod 创建前初始化数据卷；还有多个 `containers`，分别运行 `BusyBox` 命令、永久运行。

# 5.具体代码实例和解释说明
## 例子：创建一个简单的 Kubernetes Pod
假设我们有一个容器镜像 `myimage:latest` ，希望创建一个名称为 `myapp-pod` 的 Kubernetes Pod，Pod 里仅运行一个容器 `myapp-container`，该容器运行在 Pod 的 IP 地址上。

首先，创建一个名为 `myapp-pod.yml` 的 YAML 文件，内容如下：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
spec:
  containers:
  - name: myapp-container
    image: myimage:latest
```

然后，使用 `kubectl apply` 命令将 Pod 部署到 Kubernetes 集群：

```bash
$ kubectl apply -f myapp-pod.yml
pod/myapp-pod created
```

这条命令通过 `myimage:latest` 拉取镜像，然后创建一个名称为 `myapp-pod` 的 Pod，Pod 包含一个容器，容器的名称为 `myapp-container`。

可以通过 `kubectl get pods` 命令查看 Pod 的状态：

```bash
$ kubectl get pods
NAME       READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          2m
```

## 例子：创建一个部署 Nginx 容器的 Kubernetes Deployment
假设我们有一个容器镜像 `nginx:latest` ，希望创建一个名称为 `nginx-deployment` 的 Kubernetes Deployment，Pod 里包含一个容器 `nginx-container`，该容器运行在 Deployment 的 IP 地址上，可以用来接收 HTTP 请求。

首先，创建一个名为 `nginx-deployment.yml` 的 YAML 文件，内容如下：

```yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx-container
        image: nginx:latest
```

然后，使用 `kubectl apply` 命令将 Deployment 部署到 Kubernetes 集群：

```bash
$ kubectl apply -f nginx-deployment.yml
deployment.apps/nginx-deployment created
```

这条命令通过 `nginx:latest` 拉取镜像，然后创建一个名称为 `nginx-deployment` 的 Deployment， Deployment 包含三个副本 (`replicas`)，每个副本包含一个容器 `nginx-container`。

可以通过 `kubectl get deployments` 命令查看 Deployment 的状态：

```bash
$ kubectl get deployment nginx-deployment
NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           2m
```

## 例子：创建简单 HTTP 服务
假设我们有一个 Kubernetes Pod `backend-pod` ，运行了一个 Web 服务，监听在端口 8080 上。我们希望创建另一个 Kubernetes Pod `frontend-pod`，运行一个前端程序，监听在端口 80 上。前端程序需要调用 `backend-pod` 的 Web 服务。

首先，创建一个名为 `backend-pod.yml` 的 YAML 文件，内容如下：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: backend-pod
spec:
  containers:
  - name: backend-container
    image: somecompany/web-server:latest
    ports:
    - containerPort: 8080
```

然后，使用 `kubectl apply` 命令将 `backend-pod` 部署到 Kubernetes 集群：

```bash
$ kubectl apply -f backend-pod.yml
pod/backend-pod created
```

接下来，创建一个名为 `frontend-pod.yml` 的 YAML 文件，内容如下：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend-pod
spec:
  containers:
  - name: frontend-container
    image: somecompany/web-ui:latest
    ports:
    - containerPort: 80
```

但是，由于 `frontend-pod` 需要调用 `backend-pod` 的 Web 服务，所以需要在 `frontend-pod` 中定义 `backend-pod` 的 Service 名称。

创建一个名为 `backend-service.yml` 的 YAML 文件，内容如下：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-svc
spec:
  selector:
    app: web-server
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 8080
```

然后，使用 `kubectl apply` 命令将 `backend-service` 部署到 Kubernetes 集群：

```bash
$ kubectl apply -f backend-service.yml
service/backend-svc created
```

`backend-service` 定义了一个名称为 `web-server` 的 `label`，可以通过这个 `label` 来选择目标 Pod。`targetPort` 字段的值为 `8080`，表示将流量发送到 `web-server` 端口 8080。

现在，可以编辑 `frontend-pod.yml` 文件，添加 `backend-svc` 的 Service 名称：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend-pod
spec:
  containers:
  - name: frontend-container
    image: somecompany/web-ui:latest
    ports:
    - containerPort: 80
    env:
    - name: BACKEND_SERVICE_HOST
      valueFrom:
        fieldRef:
          fieldPath: status.podIP
    - name: BACKEND_SERVICE_PORT
      value: "8080"
```

这里，`env` 块添加了两个环境变量，用于连接 `backend-pod` 的 Service，分别为 `BACKEND_SERVICE_HOST` 和 `BACKEND_SERVICE_PORT`。`valueFrom` 引用 `status.podIP`，表示将 IP 地址发送到环境变量。

然后，使用 `kubectl apply` 命令将 `frontend-pod` 部署到 Kubernetes 集群：

```bash
$ kubectl apply -f frontend-pod.yml
pod/frontend-pod created
```

这条命令将创建一个名称为 `frontend-pod` 的 Pod，Pod 包含一个容器，容器的名称为 `frontend-container`，在端口 80 上接收 HTTP 请求。

可以通过 `kubectl get services`、`kubectl get pods` 命令查看资源的状态：

```bash
$ kubectl get svc
NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
backend-svc  ClusterIP   10.0.0.123    <none>        8080/TCP  1m

$ kubectl get pods
NAME          READY     STATUS    RESTARTS   AGE
backend-pod   1/1       Running   0          1m
frontend-pod  1/1       Running   0          4m
```