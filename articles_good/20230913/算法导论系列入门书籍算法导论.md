
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 一、课程简介
《算法导论》是一本由布莱恩·克尼根(<NAME>)、艾伦·麦克法兰(<NAME>)、马修·卡尔曼(<NAME>)、约翰·霍尔巴赫(<NAME>)等著，英文版由J.K. Tarjan译成中文的经典计算机科学教材。《算法导论》共七章，分别从最基础的数据结构和算法理论，到实际应用和工程上的算法设计技巧，包含大量有益的图形、动画和代码示例。

## 二、阅读对象
《算法导论》适合作为高校计算机及相关专业本科生或研究生的算法基础教程。

## 三、适用范围
- 本科生或研究生计算机相关专业
- 对数据结构、算法、概率论、信息论、数理统计、计算复杂性、机器学习有一定了解的学生群体

## 四、购买方式
- 电子版：可以直接在线阅读或下载PDF版本，购买电子版不需打印
- 纸质版：需要购买，多种供应商，定价根据个人情况而定，建议选择国际标准出版社的畅销书。

# 2.背景介绍
## 数据结构
算法导论中的数据结构是指用于存储、组织数据的方式，包括数组、链表、栈、队列、散列表、树、堆、图等。数据结构决定了算法的空间和时间复杂度。比如，对于一个大小为n的数组来说，删除其中的元素的时间复杂度是O(1)；对于一棵大小为n的完全二叉树来说，寻找最大值的时间复杂度是O(log n)。

## 算法
算法是用来解决特定类别的问题的指令集或子程序。数据结构是为算法服务的，它使得算法能够有效地执行。举个例子，求解整数序列中前k大的数字，这个过程可以使用堆排序算法，步骤如下：
1. 创建一个大小为k的最小堆（或者优先级队列）
2. 从输入序列中读取一个数字并插入到堆中
3. 如果插入的数字比堆顶数字大，则替换堆顶数字
4. 将堆顶元素输出并删除它，直至堆为空
5. 返回剩余的元素组成的序列

按照这样的步骤，就可以找到输入序列中前k大的数字。这种方法的时间复杂度是O(n log k)，其中n表示输入序列的长度，因为第2步、第3步和第4步都涉及插入和删除操作，每次操作的时间复杂度是O(log k)，总共进行n次操作。

# 3.基本概念术语说明
## 1.数据类型
计算机通常只能处理有限的几种简单的数据类型，如整数、浮点数、字符、字符串等。不同语言对这些类型支持也不尽相同，如有的语言支持长整型，有的语言仅支持无符号整数。所以，在算法分析中，常常会把数据类型分为两类——内置数据类型和抽象数据类型。

### 1.1 内置数据类型
- 整型：byte、short、int、long
- 浮点型：float、double
- 逻辑型：boolean
- 字符型：char
- 引用型：reference

### 1.2 抽象数据类型
抽象数据类型（Abstract Data Type，ADT），又称数据类型定义（Data Type Definition，DTD）。它是一个数学概念，用来描述如何存储和处理数据的集合，即用数据类型定义来刻画某个问题领域中所涉及的数据结构以及数据之间的关系。通俗地说，就是把一些具有相似属性的数据的集合及对该集合的基本操作（如访问某一成员、添加/删除成员）进行封装，以便于复用。

常用的抽象数据类型有队列、栈、链表、集合、树、图、哈希表等。

## 2.时间复杂度
算法执行的资源消耗，主要取决于输入规模n。时间复杂度描述的是运行完整个算法所需要的时间。它反映的是每当输入规模增加，算法的运行时间随之增加的速度。算法的最坏时间复杂度表示的是算法在最糟糕情况下（所有输入均为最坏输入）下的运行时间。常用的时间复杂度有以下五种：

1. O(1)：常数阶，比如O(1)、O(log n)、O(n)、O(n^c)，其中c是常数系数。常数阶算法的运行时间与数据规模无关，一般在常数时间内就能完成任务，如获取系统时钟。
2. O($\log_b{n}$)：对数阶，其中$b$是底数，比如O($\log_{2}{n}$)。对数阶算法的性能与数据规模的对数成正比。
3. O(n):线性阶，意味着随着数据规模的增大，算法的运行时间与数据规模呈线性关系。
4. O(n $\times$ m):二次方程，意味着数据规模与算法运行时间之间存在着多项式关系。
5. O(2^n):指数阶，意味着随着数据规模的增大，算法的运行时间急剧增长。

## 3.空间复杂度
空间复杂度描述的是算法运行过程中占用多少内存空间。它反映的是算法在最坏情况下需要多少辅助存储单元才能正常工作。常用的空间复杂度有以下四种：

1. O(1)：算法需要固定数量的辅助存储单元，且不会随数据规模的变化而变化。例如，计数排序、桶排序都是O(1)的算法。
2. O($n$)：算法需要额外的辅助存储单元与数据规模相同，比如顺序查找算法。
3. O($n \times c$)：算法需要额外的辅助存储单元与数据规模的乘积相同，但随数据规模的变化而线性增长。
4. O(n!):指数级复杂度。存在很多算法的空间复杂度达到了这种级别，比如组合优化问题。

# 4.核心算法原理和具体操作步骤以及数学公式讲解
## 1.排序算法
排序算法分为内部排序算法和外部排序算法两种。

### 1.1 内部排序算法
内部排序算法是指待排序的记录可以全部放入内存进行排序的一种算法。具体分类有插入排序、冒泡排序、选择排序、归并排序、快速排序、堆排序、希尔排序。

#### 插入排序
插入排序（Insertion Sort）是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。


```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j+1] = key
```

#### 冒泡排序
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就交换它们。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。


```python
def bubble_sort(arr):
    n = len(arr)
    # Traverse through all array elements
    for i in range(n):
        # Last i elements are already sorted
        for j in range(0, n-i-1):
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

#### 选择排序
选择排序（Selection Sort）是一种简单直观的排序算法，它的工作原理是首先在未排序序列中找到最小（大）元素，存放到起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。


```python
def selection_sort(arr):
    n = len(arr)
    # One by one move boundary of unsorted subarray
    for i in range(n):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i+1, n):
            if arr[min_idx] > arr[j]:
                min_idx = j
        # Swap the found minimum element with the first element        
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```

#### 归并排序
归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。


```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr)//2
        left_half = arr[:mid]
        right_half = arr[mid:]
        
        # Recursive call on each half
        merge_sort(left_half)
        merge_sort(right_half)
        
        i = j = k = 0
        
        # Merge two halves into a single sorted output
        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1
            
        # Copy any remaining elements from left or right half to output array
        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1
```

#### 快速排序
快速排序（QuickSort）是对冒泡排序的一种改进版本。它利用分治法（Divide and Conquer）策略来把一个串行（列表）分为两个子序列，其中一子序列元素的值都比另一个子序列元素的值小，则可分别对这两个子序列继续进行排序，直到整个序列有序。


```python
import random

def quick_sort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        
        # Recursively apply this function to left and right partitions
        quick_sort(arr, low, pivot_index-1)
        quick_sort(arr, pivot_index+1, high)
        
def partition(arr, low, high):
    # Choose last element as pivot (can be changed to median value or some other strategy)
    pivot = arr[high]
    
    # Move pivot to end of array
    arr[high], arr[low] = arr[low], arr[high]
    
    # Initialize index pointers for swapping
    i = low - 1
    j = low
    
    while j <= high:
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
        j += 1
        
    # Put pivot at its correct position
    arr[i+1], arr[low] = arr[low], arr[i+1]

    return i+1
    
# Test driver code
arr = [random.randint(-100, 100) for _ in range(10)]
print("Unsorted:", arr)
quick_sort(arr, 0, len(arr)-1)
print("Sorted:", arr)
```

#### 堆排序
堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是不稳定的排序方法，原因是：在堆排序过程中，如果存在两个元素key1、key2，而且key1>key2，在排序过程中，可能被放置在了错误的位置。因此，堆排序不是基于比较的排序算法。但是，由于堆排序算法的实现较为容易，而且效率很高，因此有些编程语言都提供了相关函数，用于快速实现堆排序功能。


```python
import heapq

def heapify(arr, n, i):
    largest = i 
    l = 2 * i + 1    
    r = 2 * i + 2  
  
    # If left child is larger than root   
    if l < n and arr[largest] < arr[l]: 
        largest = l 
  
    # If right child is larger than largest so far 
    if r < n and arr[largest] < arr[r]: 
        largest = r 
  
    # Change root, if needed 
    if largest!= i: 
        arr[i],arr[largest] = arr[largest],arr[i]  # swap 
  
        # Heapify the root. 
        heapify(arr, n, largest) 

def heap_sort(arr):
    n = len(arr) 
  
    # Build maxheap. 
    for i in range(n//2 - 1, -1, -1): 
        heapify(arr, n, i) 
  
    # One by one extract elements 
    for i in range(n-1, 0, -1): 
        arr[i], arr[0] = arr[0], arr[i]   # swap 
        heapify(arr, i, 0) 
```

#### 梳排序
梳排序（Bead Sort）是另一种原址排序算法，它利用扭曲的方式对数组元素进行排列，使其看起来更像一块扭曲的珠子，并在数组中随机跳跃，并最终形成一个扁平的数组。


```python
def bead_sort(arr):
    n = len(arr)
    gap = 1
    
    # Create gaps between values based on their distance from center point
    while gap < n:
        offset = 0
        
        for i in range(gap, n):
            temp = arr[i]
            
            # Shift current value closer to center point
            j = i
            while j >= gap and abs((temp - arr[j-gap]) % gap) == 0:
                arr[j] = temp
                j -= gap
                
            # If no space available, increase gap size
            if j < gap:
                gap *= 2
                offset += 1
        
        # Adjust gap to maintain uniform distribution after shifts
        gap = int(((gap / 2) ** 2)) - offset
    
        # Finally, shift remaining values towards center point using final gap
        for i in range(n // gap):
            bead_shift(arr, gap, n-i*gap-1)
            
def bead_shift(arr, gap, idx):
    center = ((gap * (gap+1)) // 2)
    start = center - (gap//2)
    dest = start + gap
    
    curr_val = arr[start]
    prev_diff = None
    dest_idx = start
    
    # Find destination index where previous value should go
    for j in range(center, center+gap):
        diff = abs(curr_val - arr[j%len(arr)])
        
        if prev_diff is None or diff < prev_diff:
            prev_diff = diff
            dest_idx = j % len(arr)
            
    # Insert current value in appropriate location before shifted values
    for j in range(dest_idx, start, -gap):
        arr[(j-gap)%len(arr)], arr[j%len(arr)] = arr[j%len(arr)], arr[(j-gap)%len(arr)]
        
    # Update destination index if it has been overwritten by previous insertions
    if dest_idx < start + gap:
        dest_idx += len(arr)
        
    # Insert new value at desired position
    for j in range(start+gap-1, dest_idx, -gap):
        arr[j%len(arr)], arr[(j-gap)%len(arr)] = arr[(j-gap)%len(arr)], arr[j%len(arr)]
```

### 1.2 外部排序算法
外部排序算法是指数据量过大，无法全部加载到内存中进行排序的排序算法，可以借助磁盘文件和内存之间的交换来进行排序。具体分类有归并排序、基数排序、桶排序、堆排序。

#### 归并排序
归并排序的原理是采用分治法（Divide and Conquer）策略，递归地把当前序列切分成较小的子序列，直到子序列个数足够少，然后再合并回原来的序列中。


```python
from functools import reduce

def external_merge_sort(file_name, chunk_size=100000):
    def read_chunk():
        lines = []
        with open(file_name, 'rb') as f:
            while True:
                line = f.readline().decode()
                if not line:
                    break
                lines.append(line[:-1].split(','))
                if len(lines) == chunk_size:
                    yield lines
                    del lines[:]
        if lines:
            yield lines
    
    chunks = list(read_chunk())
    
    while len(chunks) > 1:
        merged = []
        for i in range(0, len(chunks), 2):
            merged.extend(reduce(lambda x, y: cmp_and_join(x, y),
                                  zip(*chunks[i:i+2]), [])[-1:])
        chunks = [(merged,) if isinstance(merged, str) else merged
                  for merged in split_list(merged, chunk_size)]
    
    result = list(chunks[0][0])
    with open('output.csv', 'wb') as out:
        for row in result:
            print(','.join([str(col) for col in row]), file=out)

def cmp_and_join(row1, row2):
    rows = ([elem1, elem2] for elem1, elem2 in zip(row1, row2)
            if elem1 < elem2)
    return ''.join('\t'.join(map(str, pair)).encode()
                   for pair in rows).decode(), ''
    
def split_list(lst, n):
    """Split lst into lists of length n"""
    return [lst[i:i+n] for i in range(0, len(lst), n)]
```

#### 基数排序
基数排序是一种非比较排序算法，它的工作原理是先按低位的关键字排序，然后收集，按高位的关键字排序，直到整个序列变成有序序列。


```python
def radix_sort(arr):
    exp = 1
    
    # Determine maximum number to know number of digits
    max_num = max(arr)
    
    while max_num // exp > 0:
        counting_sort(arr, exp)
        exp *= 10
        
def counting_sort(arr, exp):
    count = [0] * 10
    output = [0] * len(arr)
    ans = ""
    
    # Store count of occurrences in count[]
    for i in range(len(arr)):
        index = (arr[i]/exp)
        count[int((index)%10)]+=1
    
    # Change count[i] so that count[i] now contains actual position of this digit in output[]
    for i in range(1,10):
        count[i]+=count[i-1]
    
    # Build the output array
    for i in range(len(arr)-1,-1,-1):
        index=(arr[i]/exp)
        output[count[int((index)%10)]-1]=arr[i]
        count[int((index)%10)]-=1
        
    # Copying the output array to arr[], so that arr now contains sorted numbers according to current digit
    for i in range(len(arr)):
        arr[i]=output[i]
```

#### 桶排序
桶排序（Bucket Sort）是计数排序的扩展，它的基本思想是使用一组 buckets 来存储元素，每个 bucket 对应一个元素的关键值，不同关键值的元素放在不同的 bucket 中，最后对每个 bucket 中的元素进行排序。


```python
def bucket_sort(arr):
    # Find the maximum value in the given array
    max_val = float('-inf')
    for num in arr:
        if num > max_val:
            max_val = num
            
    # Define the number of buckets equal to the number of integers in the range of the input array
    num_buckets = max_val - min_val + 1
    
    # Make an empty bucket list to hold the elements
    buckets = [[] for _ in range(num_buckets)]
    
    # Distribute the elements into different buckets based on their range
    for num in arr:
        bucket_id = num - min_val
        buckets[bucket_id].append(num)
    
    # Sort each non-empty bucket using standard sorting algorithm
    for buc in buckets:
        if len(buc) > 1:
            buc.sort()
    
    # Concatenate the contents of all buckets back into a single list and return
    res = []
    for buc in buckets:
        res.extend(buc)
    return res
```

#### 堆排序
堆排序（Heap Sort）是利用堆这种数据结构所设计的一种排序算法。堆是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是不稳定的排序方法，原因是：在堆排序过程中，如果存在两个元素key1、key2，而且key1>key2，在排序过程中，可能被放置在了错误的位置。因此，堆排序不是基于比较的排序算法。但是，由于堆排序算法的实现较为容易，而且效率很高，因此有些编程语言都提供了相关函数，用于快速实现堆排序功能。


```python
import heapq

def external_heap_sort(input_file, output_file, buffer_size=1000000):
    # Read data from input file and store it in memory buffer
    buffer = []
    with open(input_file, 'rb') as inp:
        while True:
            data = inp.read(buffer_size * 1024)
            if not data:
                break
            buffer.append(data.decode().strip().split(','))
            if len(buffer) == buffer_size:
                process_buffer(buffer, output_file)
                buffer = []
                
    # Process the remaining data
    if buffer:
        process_buffer(buffer, output_file)

def process_buffer(buffer, output_file):
    # Convert strings representing numeric values to Python's integer type
    converted_buffer = [[int(cell) for cell in row] for row in buffer]
    
    # Perform heap sort on the buffer
    heapq.heapify(converted_buffer)
    sorted_rows = []
    while converted_buffer:
        sorted_rows.append(heapq.heappop(converted_buffer))
    
    # Write sorted rows to disk
    with open(output_file, 'ab+') as out:
        for row in sorted_rows:
            print(','.join(map(str, row)), file=out)
```