
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在面向对象编程中，创建型模式是用来创建对象的一种模式。它描述了“怎样创建一个对象，以及这个对象是什么”。通过创建型模式，我们能够将对象的创建与使用分离开来。当创建了一个对象后，就可以直接使用它而不用再去创建或者管理它。创建型模式可以帮助我们更加有效地管理系统资源、减少重复的代码、提升可读性等。本文主要阐述设计模式中的“创建”模式，并介绍其中两种重要的模式：工厂方法模式（Factory Method）和抽象工厂模式（Abstract Factory）。

# 2.背景介绍
## 2.1 为什么需要创建型模式？
在软件开发过程中，创建对象是一个常见的需求，例如创建窗口、数据库连接、网络套接字、文件流等。为了实现这一目标，软件设计者会将创建对象的过程抽象出来，形成一套创建对象的方法论或指南，即所谓的创建型模式。创建型模式解决以下两个主要问题：

1. 对象的创建和对象的生命周期管理

创建型模式解决的是如何创建对象的问题。创建型模式通过解耦对象创建的过程与对象使用的过程，从而让两者之间建立松耦合关系。例如，对象由一个工厂类负责创建，而不是客户端直接调用构造函数。对象在创建之后，可以通过对象自身的接口来获取、控制或销毁它。

2. 对象重用的频率和程度

创建型模式还要考虑到对对象的重用。由于创建型模式为创建对象的行为提供了统一的标准，因此可以使得同种类的对象被创建时具有共同的模式，从而提高对象的重用频率和程度。比如，如果不同的对象创建方式相同，只需修改工厂类的某些参数即可。

## 2.2 创建型模式概览
### 2.2.1 工厂方法模式
工厂方法模式（Factory Method Pattern）又称为工厂模式，属于类的创建模式。该模式为创建对象提供一个超级类，而且该超级类可以决定哪个子类对象应该被实例化。工厂方法模式是简单工厂模式的进一步抽象和推广。

在工厂方法模式中，一个抽象的类负责定义创建产品对象的接口，每个产品都有一个对应的子类。当客户需要一个产品时，他无需知道具体产品类的类名，只需给出相应的配置文件或参数，就可由工厂方法返回对应产品对象；在工厂方法模式下，核心的工厂类不仅创建对象，同时也负责判断创建哪个对象，确保系统的灵活性和扩展性。

### 2.2.2 抽象工厂模式
抽象工厂模式（Abstract Factory Pattern）是围绕着一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂，这种类型的设计模式属于创建型模式。

在抽象工厂模式中，存在多个工厂角色，它们可以按照其产品类型创建一系列相关的产品对象。客户无需知道所选工厂的细节，只需通过抽象的接口来使用这些产品对象即可。抽象工厂模式与工厂方法模式最大的区别在于它提供创建一系列相关或相互依赖对象的接口，而不只是创建一个对象。

### 2.2.3 建造者模式Builder Pattern
建造者模式（Builder Pattern）将一个复杂对象的构建与它的表示分离，使得同一个构建过程可以创建不同表现形式。建造者模式属于对象创建型模式。

在建造者模式中，用户只需要指定需要建造的类型，不需要知道该类型具体怎么建造，建造者模式可以将对象的创建过程与表示过程分离开来，使得同一个建造过程可以创建出不同的产品对象。建造者模式提供了一种优雅的方式来创建复杂对象的各个部件，并允许用户只通过指定复杂对象的类型和内容就可以创建该对象。

## 2.3 使用场景
### 2.3.1 何时使用工厂方法模式？
当一个类不知道它所必须创建的对象的类的时候，可以使用工厂方法模式。如游戏角色的创建，抽象工厂用于创建游戏内的各种物品。

### 2.3.2 何时使用抽象工厂模式？
当一个系统要独立于它的产品的创建、组合和表示时，可以使用抽象工厂模式。如JDBC驱动器的创建。

### 2.3.3 何时使用建造者模式？
当构造一个对象的算法应该独立于该对象的组成部分以及它们的装配方式时，可以采用建造者模式。如汽车的创建。

# 3.基本概念术语说明
## 3.1 对象
在面向对象编程（Object-Oriented Programming，简称OOP）中，对象是类的实例，通过消息传递与接收来完成任务。对象拥有状态信息和行为信息，可以通过访问其属性和调用其方法来与之交互。

## 3.2 类（Class）
类是用来描述客观事物特征和方法的集合。类包括数据成员（Attribute）和操作成员（Method），用来表示对象的状态和行为。类可以作为创建对象的模板，也可以生成多个实例对象。

## 3.3 方法（Method）
方法是对象行为的一个实现。方法通常包括输入、输出参数，还有返回值。方法定义了对象执行特定功能的方式。方法通过传入参数，对其进行处理，然后返回计算结果。

## 3.4 属性（Attribute）
属性是对象内部的变量，它的值可以被读取和修改。

## 3.5 接口（Interface）
接口是一些方法签名的集合，它是定义用于不同类的行为的协议。接口定义了一种契约，约定了参与方需遵守的规则。

## 3.6 抽象类（Abstract Class）
抽象类是不能够创建对象的基类，它包括抽象方法和抽象属性。抽象方法是没有实现的虚方法，它不能在抽象类中实现，只能由派生类实现。抽象属性是不能被初始化的变量。

## 3.7 面向对象设计的五大原则
SOLID原则是面向对象设计的五大原则之一。SOLID原则认为，软件设计中要注意以下几个方面：单一职责原则（Single Responsibility Principle，SRP），开闭原则（Open Close Principle，OCP），里氏替换原则（Liskov Substitution Principle，LSP），依赖倒置原则（Dependence Inversion Principle，DIP），接口隔离原则（Interface Segregation Principle，ISP）。

## 3.8 工厂方法模式
工厂方法模式（Factory method pattern）是最常用的设计模式之一。顾名思义，就是定义一个用于创建对象的接口，让子类决定实例化哪一个类。在工厂方法模式中，我们首先明确地定义一个接口来声明工厂方法，然后再提供一个接口的默认实现。

## 3.9 抽象工厂模式
抽象工厂模式（Abstract factory pattern）与工厂方法模式很类似，也是创建一系列相关或相互依赖对象的接口，但它们之间的区别在于工厂方法模式要求一个类仅创建一个对象，而抽象工厂模式要求一个工厂可以创建一系列相关对象。

## 3.10 建造者模式
建造者模式（Builder pattern）也叫做生成器模式。它可以将一个复杂对象的构建与它的表示分离，使得同一个构建过程可以创建不同表现形式。建造者模式提供了一种优雅的方式来创建复杂对象，用户只需指定复杂对象的类型和内容就可以创建该对象。

## 3.11 多态性
多态性（Polymorphism）是指允许不同类的对象对同一消息作出响应。多态机制使得对象获得拓展能力，即具有不同形态的对象可以通过统一的接口interact。多态在面向对象编程中扮演着至关重要的角色，因为它允许我们创建复杂的继承体系，同时避免了代码重复。

## 3.12 反射（Reflection）
反射（Reflection）是一种动态加载机制，它允许运行时的Java程序加载、解析、使用、修改它本身运行的状态。通过反射，可以动态地创建对象，绑定对象方法，控制反转（IoC），利用注解（annotation）等特性来改善软件的可维护性。

# 4.工厂方法模式
## 4.1 概念
工厂方法模式（Factory Method Pattern）是对象的创建型模式，又称虚拟构造器模式或者多态工厂模式。该模式允许一个类把对象的创建委托给子类，但是父类并非始终自己实例化对象，而是根据传入的类型来确定应该实例化哪一个子类。

## 4.2 结构
工厂方法模式包含如下角色：

1. Product（产品类）：它是创建对象的类，包含创建产品对象的具体逻辑。

2. ConcreteProduct（具体产品类）：具体产品类是 Product 的子类，实现了 Product 中的抽象方法。

3. Creator（Creator类）：Creator 是工厂方法模式的核心类，含有工厂方法 createProduct()，返回一个 Product 对象。

4. ConcreteCreator（具体Creator类）：它继承于 Creator ，实现了其抽象方法 createProduct()，返回一个 ConcreteProduct 对象。


## 4.3 适用场景
在以下情况下可以考虑使用工厂方法模式：

1. 一个类不知道它所必须创建的对象的类：在工厂方法模式中，客户端不需要知道所使用的对象的具体类。这使得应用变得灵活，可以在不改变具体工厂类的情况下引进新产品。

2. 一个类希望由它的子类来指定它所创建的对象：在工厂方法模式中，对于抽象工厂模式，客户端不需要知道具体产品类的类名，只需要知道他们所需产品的相关信息。由于这种特点，屏蔽了具体的创建逻辑，使得系统在不修改原有代码的前提下引进新产品。

3. 将创建对象的职责委托给多个帮助子类中的某一个，而用户只需要知道最终想要的产品：在这种模式中，工厂方法模式的好处就是将对象的创建委托给子类实现。这样一来，当增加新的子类时，不需要修改工厂类，就可以添加新的产品对象。

## 4.4 模式优点
1. 隐藏了对象的创建逻辑，简化了对象创建过程。

2. 更加容易维护，符合开闭原则。

3. 扩展性良好，符合单一职责原则。

## 4.5 模式缺点
1. 每次增加新产品时都需要增加一个具体产品类，会导致类的个数增加，增加系统复杂度。

2.  products 的数量多于 creators，creators 会比较笨重，影响性能。

# 5.抽象工厂模式
## 5.1 概念
抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂，这种类型的设计模式属于创建型模式。

在抽象工厂模式中，存在多个工厂角色，它们可以按照其产品类型创建一系列相关的产品对象。客户无需知道所选工厂的细节，只需通过抽象的接口来使用这些产品对象即可。抽象工厂模式与工厂方法模式最大的区别在于它提供创建一系列相关或相互依赖对象的接口，而不只是创建一个对象。

## 5.2 结构
抽象工厂模式包含如下角色：

1. AbstractFactory（抽象工厂类）：它 declares the creation of abstract products.

2. ConcreteFactory1、ConcreteFactory2（具体工厂类）：它们实现了抽象工厂类的工厂方法，分别创建一系列的具体产品。

3. AbstractProductA、AbstractProductB（抽象产品类）：它们是产品类的共同接口。

4. ConcreteProductA1、ConcreteProductA2、ConcreteProductB1、ConcreteProductB2（具体产品类）：它们是抽象产品类的实现。


## 5.3 适用场景
在以下情况下可以考虑使用抽象工厂模式：

1. 一组产品中有多个供应商时，抽象工厂模式提供了一种比工厂方法模式更好的选择。这是因为在抽象工厂模式中，客户端无需知道具体工厂类的类名，只需知道相关的产品信息即可。换句话说，客户端不需要在工厂中切换具体工厂。

2. 当一个产品族中的多个对象被设计成一起工作时，抽象工厂模式提供了一种通用的途径来创建他们。

3. 当一个对象有多个的层次结构时，抽象工厂模式尤为重要。每一个层次结构对应于一个工厂，包含多个相关的产品对象。

## 5.4 模式优点
1. 分离了具体的产品类和具体的工厂类，使得代码结构清晰。

2. 提供了更多的灵活性。当增加新的产品时，无需修改抽象工厂类和抽象产品类，只需增加新的具体工厂类和具体产品类即可。

3. 降低了系统的复杂性，因为Abstractions工厂类仅仅是一些指向产品类的指针。

## 5.5 模式缺点
1. 添加新产品困难，产品较多时，可能导致类膨胀，出现很多具体类。

2. 在扩展时，抽象工厂模式无法支持开放/关闭原则，因为对于抽象工厂类来说，产品类已经集成在里面了，不允许增加新产品。

# 6.建造者模式
## 6.1 概念
建造者模式（Builder Pattern）是对象创建型模式，它允许用户按步骤构建一个复杂对象。Builder 模式可以一步一步构建复杂对象，并且可以返回一个完整对象。建造者模式属于对象创建型模式，是最复杂的模式之一。

## 6.2 结构
建造者模式包含如下角色：

1. Builder（抽象构建者）：它为创建 product 对象的各个部件指定一个抽象接口。

2. ConcreteBuilder（具体构建者）：它实现 Builder 接口，并定义和装配 product 对象的各个部件。

3. Product（产品类）：它是被 builder 创建的复杂对象，包含多个组成部件。

4. Director（指挥者）：它貌似于经理一样，指导 builder 如何构建产品对象，指导 builder 执行构建的顺序。


## 6.3 适用场景
在以下情况下可以考虑使用建造者模式：

1. 需要生成的对象具有复杂的内部结构。

2. 产品对象需要多个步骤来构造。

3. 对象的创建过程必需独立于对象的内部表示。

4. 隔离复杂对象的创建和使用，并使得同一个构建过程可以创建不同表现形式。

5. 初始化对象过程麻烦，需要大量参数。

## 6.4 模式优点
1. 封装性好。

建造者模式提供了对构造过程的抽象，即用户无需了解产品的创建过程，而只需知道如何使用该建造者。这有助于提高系统的稳定性和灵活性。

2. 建造者独立，易扩展。

建造者模式允许用户自定义创建过程，而不会影响到其他对象创建代码。这意味着你可以很容易地增加产品的创建类和配置项。

3. 便于控制创建顺序。

由于建造者类一般只有一个，因此可以在创建产品的过程进行控制，这样可保证生产出的产品满足一定规范。

4. 可变对象创建。

由于在建造者模式中，产品是一步步构建起来的，所以不存在产品类的所有信息都必须在编译期间提供。这就可以允许我们自由地指定创建哪些产品部件。

## 6.5 模式缺点
1. 如果对象的创建流程复杂的话，可能会导致建造者类过于复杂。

2. 如果产品对象的构建流程需要大量细节，那么客户端需要了解这些细节才能正确使用建造者模式。