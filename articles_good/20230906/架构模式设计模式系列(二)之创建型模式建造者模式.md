
作者：禅与计算机程序设计艺术                    

# 1.简介
  

建造者模式是构建一个复杂对象的算法，它将一个复杂对象逐步构建成各个部分，并且允许用户只给定最终想要的结果即可。建造者模式可以分为简单构造器模式、雇佣者模式和抽象建造者模式三种类型。

简单的说，建造者模式的主要目的是用来创建复杂的对象，特别是在内部模块的构造方面。

建造者模式通过一步步构造复杂对象的过程，将产品的创建过程与产品的表现形式分离开来。这样做可以提高可扩展性，并有助于实现对复杂对象的精细控制。建造者模式适用于以下场景：

1. 当创建复杂对象时，这个对象的各个部分经常面临着互相依赖，或者需要多个步骤来创建；
2. 对象创建过程中的各个步骤具有明显的顺序要求；
3. 在创建复杂对象的同时，还要保证其初始化的正确性，这一点很重要；
4. 创建复杂对象的一部分变得复杂时，系统应该提供一种方式来构造它的不同组成部分，而不是简单的创建一个对象并设置好所有的属性值。

建造者模式一般由两部分组成，一个是建造者（Builder）类，负责创建复杂对象；另一个是指挥者（Director）类，负责指导建造者进行部件的装配。

建造者模式的优点包括：

1. 分离了创建目标和表现形式；
2. 可以更容易地改变产品的内部表示；
3. 可用性较强；
4. 不再受限于产品本身的内部结构；
5. 提供多种风格的建造方法；
6. 消除了构造函数参数过多的问题。

当然，建造者模式也存在一些缺点：

1. 如果没有合适的建造者模式的接口，就无法让客户知道如何使用建造者模式；
2. 客户端代码可能会非常冗长；
3. 在复杂对象的创建过程中，隐藏了部分逻辑，这使得程序中出现很多职责不清晰的地方。

建造者模式在软件工程中的应用不仅仅局限于以上提到的那些情况，它还有很多其它实用的应用。比如，当创建对象时，需要调用几个不同的类或者对象，就可以考虑使用建造者模式来实现它们之间的交互关系，而不需要暴露太多的实现细节。

# 2.架构模式概述
建造者模式属于创建型模式，在面向对象编程中，是一个将一个复杂对象的创建流程抽象出来，将创建复杂对象的过程与对象的实际表示分离开来的设计模式。建造者模式可以将一个复杂的对象分解成多个步骤的过程，每一个步骤都对应着一个方法，在最后一步中，建造者会返回一个完整的对象，而不是逐个构造其各个子组件。建造者模式可以降低一个复杂对象的创建难度，简化对象创建的过程，从而实现“一步到位”的目的。建造者模式的角色有建造者和指挥者，建造者则负责创建最终的对象，而指挥者则指导建造者一步步地构造复杂的对象。建造者模式通常包含四个角色：

1. Product: 抽象产品类，也就是所要生成的复杂对象。

2. Builder: 抽象建造者类，定义并封装了创建Product的各个部件的接口。

3. ConcreteBuilder: 具体建造者类，实现Builder接口，实现对Product的每个部件的具体创建。

4. Director: 指挥者类，指导如何使用Builder类的部件来构造产品。

建造者模式的流程如下图所示：


如上图所示，建造者模式包含四个角色，其中Product表示复杂对象，Builder表示抽象建造者，ConcreteBuilder表示具体建造者，Director表示指挥者。建造者模式的任务就是通过多个部件来创建Product对象。建造者模式的作用主要是用来隔离一个产品的创建和表现，解决复合类的创建难题。

# 3.类图描述
下面我们用类图的方式对建造者模式进行描述：


如上图所示，建造者模式包含一个抽象的产品类Product和一个抽象的建造者类Builder，两个具体的建造者类ConcreteBuilder1和ConcreteBuilder2，以及一个指挥者类Director。Builder是一个抽象类，主要提供产品的组成及建造过程，而ConcreteBuilder1和ConcreteBuilder2是具体的实现类，继承自Builder并重载相关方法，完成具体的产品建造。Director负责制定建造顺序，协调各个部件的生产，最终完成对象的生成。

# 4.建造者模式的适用性
建造者模式能够降低创建复杂对象的复杂程度，提高了软件的可维护性，并有利于更好的组织系统的代码。

建造者模式的适应场景有：

1. 有多个构造函数参数或无默认构造函数的情况下，可以通过建造者模式来进行参数的传递。建造者模式可以使用构造函数的参数来设置对象间的依赖关系，避免代码中出现构造函数过多的情况。

2. 建造者模式可有效防止构造函数过多，同时可以支持链式调用。在系统中加入了新的建造者时，仅需增加新的具体建造者，而无需修改其他已有代码。

3. 建造者模式能够有效地隔离对象的创建代码和表现形式，可在运行时动态地选择适合的建造者类，确保对象的创建符合预期。

4. 当复杂对象的创建涉及到较多行代码，而这些代码又需要被重复使用时，可以考虑使用建造者模式。在程序中，如果出现大量的构造函数，往往意味着代码的重复，这时候可以使用建造者模式来消除这种重复，并使代码更加易读、易维护。

5. 使用建造者模式可以有效地实现单例模式，当系统中只需要唯一的一个对象实例时，可以使用建造者模式。通过调用同一个建造者类的不同方法，可以创建不同的对象实例，达到实例的唯一性。

6. 当子系统可能包含多种类型的对象，并且创建这些对象时，可以使用建造者模式来实现各个对象的创建。通过定义不同的建造者类，可以在运行时动态地指定哪种建造者类来创建对象。

7. 在游戏开发中，建造者模式还可以提升资源加载的效率，因为它可以将各个物体的加载过程及其依赖关系分开，使得资源的加载不会导致长时间的等待。

# 5.建造者模式的优点

- 通过分离了创建对象的方法和表现形式，建造者模式可以有效地提高代码的灵活性、可读性和扩展性；
- 建造者模式的使用促进了组合复用，即零件可以根据需要组装成不同的作品，从而降低了代码的耦合度；
- 建造者模式提供了一种分步创建复杂对象的途径，而且允许用户按自己的需求进行自定义。因此，在某些特殊情况下，建造者模式可以提高程序的性能和功能性。

# 6.建造者模式的缺点

- 对新手来说，建造者模式初看起来可能比较复杂，学习曲线陡峭。但其实，掌握建造者模式的关键就是习惯性地去使用它，熟练地运用它的各种方法，否则可能会遇到一些问题；
- 建造者模式存在着一些缺陷，例如由于复杂对象构造过程中的各个步骤之间存在严格的先后顺序，因此如果建造者模式编写得不规范，也可能造成建造出来的产品质量不符合要求；
- 建造者模式只能单独使用，不能与其他模式一起共同使用，如策略模式、模板方法模式等。

# 7.建造者模式的使用示例
假设我们有如下三个部件：螺栓，轴承，支座。每一项部件都是一层复杂的实体，都可能拥有多种形态。如果直接按照顺序来创建对象，那么代码将非常臃肿且难以阅读。而使用建造者模式，就可以将这些部件一步步地构造成为一个完整的机器人。

首先，我们定义一个基类Part：

```c++
class Part {
  public:
    virtual void construct() = 0; //构造函数声明
    virtual ~Part() {}           //析构函数声明
};
```

Part是所有部件的父类，定义了一个构造虚函数construct()和析构函数。

然后，我们定义三个具体的部件类：

```c++
//螺栓类
class Spindle : public Part {
  public:
    Spindle() {}

    void construct() override {
        std::cout << "Spindle created." << std::endl;
    }

    ~Spindle() override {
        std::cout << "Spindle destroyed." << std::endl;
    }
};

//轴承类
class Rotor : public Part {
  public:
    Rotor() {}

    void construct() override {
        std::cout << "Rotor created." << std::endl;
    }

    ~Rotor() override {
        std::cout << "Rotor destroyed." << std::endl;
    }
};

//支座类
class Support : public Part {
  public:
    Support() {}

    void construct() override {
        std::cout << "Support created." << std::endl;
    }

    ~Support() override {
        std::cout << "Support destroyed." << std::endl;
    }
};
```

每个部件都继承自Part，重载了构造函数和析构函数，打印相应的创建和销毁信息。

接下来，我们定义一个Builder基类：

```c++
class Builder {
  public:
    virtual void build_spindle() = 0;   //构建螺栓虚函数
    virtual void build_rotor() = 0;     //构建轴承虚函数
    virtual void build_support() = 0;   //构建支座虚函数
    virtual Robot getResult() = 0;      //获得结果虚函数
    virtual void reset() = 0;           //重置虚函数
};
```

Builder是所有Builder的基类，包含四个虚函数：build_spindle()、build_rotor()、build_support()、getResult()。Builder的子类RobotBuilder将真正创建复杂对象，并返回一个完整的对象。reset()函数可以重置当前builder的所有状态，以便重新开始构建。

最后，我们定义Robot类，作为建造者模式的最终产物：

```c++
class Robot {
  private:
    Spindle spindle_;    //螺栓成员变量
    Rotor rotor_;        //轴承成员变量
    Support support_;    //支座成员变量

  public:
    void show() const {
        std::cout << "The robot has the following parts:" << std::endl;
        std::cout << "- Spindle" << std::endl;
        std::cout << "- Rotor" << std::endl;
        std::cout << "- Support" << std::endl;
    }
};

class RobotBuilder : public Builder {
  private:
    Robot product_;  //建造出的产品

  public:
    void build_spindle() override {
        product_.spindle_.construct();
    }

    void build_rotor() override {
        product_.rotor_.construct();
    }

    void build_support() override {
        product_.support_.construct();
    }

    Robot getResult() override {
        return product_;
    }

    void reset() override {
        delete &product_;  //销毁当前的产品
        new (&product_) Robot();  //重建空的产品
    }
};
```

Robot类代表建造出的机器人，有一个Spindle成员变量、一个Rotor成员变量和一个Support成员变量。show()函数输出机器人的整体结构。RobotBuilder实现Builder基类的虚函数，重载了每个部件的构造函数，并完成了整个机器人的构造。getResult()函数返回已经构建好的机器人，reset()函数可以清空当前的产品并创建空白的产品。

现在，我们可以使用RobotBuilder来创建Robot实例：

```c++
int main() {
    auto builder = std::make_unique<RobotBuilder>();
    builder->build_spindle();
    builder->build_rotor();
    builder->build_support();

    auto result = builder->getResult();
    result.show();

    builder->reset();

    return 0;
}
```

main()函数首先生成了一个RobotBuilder实例，并使用build_spindle()、build_rotor()和build_support()三个虚函数来构建机器人的各个部件。然后，调用getResult()函数得到已经构建好的机器人，显示其结构。最后，调用reset()函数重置当前的产品并创建空白的产品。

程序的运行结果为：

```
Spindle created.
Rotor created.
Support created.
The robot has the following parts:
- Spindle
- Rotor
- Support
Spindle destroyed.
Rotor destroyed.
Support destroyed.
```

从运行结果可以看到，程序成功地使用了建造者模式，将一个复杂的对象一步步地构造成为一个完整的对象。