
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## SaltStack简介
SaltStack 是一个开源的自动化工具，基于 Python 开发，它可以轻松地管理复杂的环境部署、配置管理和运行期管理等任务。其主要功能包括配置管理（包括服务器、网络设备、虚拟机等）、远程命令执行、软件部署、流程编排、监控和报警等。它的强大的能力来源于其模块化架构和统一管理界面，使得管理人员能够通过简单易用的 Web 界面进行各种管理任务的配置。

SaltStack 由 Python 编写，具有良好的文档和活跃的社区支持，甚至还拥有专门的用户组，得到广泛应用在各行各业中。目前，它已经成为管理大型复杂系统的关键工具。

本篇文章将详细介绍 SaltStack 的基本用法及相关知识点。由于篇幅限制，很多细节的讲述可能无法覆盖到，因此在阅读时一定要结合实际需求来理解。另外，文章的内容并不局限于 SaltStack，可能会涉及到其他自动化工具或技术，如 Puppet 或 Ansible。

## 本文假定读者具备以下基本技能：
- Linux 操作系统及 Shell 命令
- 基本的网络通信协议（TCP/IP、HTTP/HTTPS）
- 基本的Web服务（Web Server、DNS服务器等）
- 了解云计算平台及相关基础设施（如VPC、负载均衡器等）

本文不会对上述知识点做过多阐述，只会着重介绍 SaltStack 相关的知识。如需进一步学习，可自行参考相关资料。

# 2.自动化运维概览
## 2.1 SaltStack的特点
### 高度模块化架构
SaltStack 以插件化的架构模式实现了高度模块化。这是 SaltStack 得以优秀的地方之一。因为模块化允许第三方开发者向 Salt 中添加更多功能，比如增加新的模块、新增运行库、提供新的功能等。同时，每个模块都有其独立的版本控制系统，方便开发者进行版本更新和 bug 修复。

### 高可用性
SaltStack 通过分布式架构实现高可用性。一台 Salt Master 可以管理多个 Salt Minion，从而保证整个集群的高可用性。其中，Master 使用 ZeroMQ 消息队列作为通信通道，保证集群间的通信安全和数据完整性。Minion 负责接收来自 Master 的指令，根据指令进行操作。如果 Master 节点出现故障，那么集群中的其他节点将接管 Master 的角色，继续工作。

### 数据加密传输
SaltStack 支持通过 HTTPS 和 AES 对数据进行加密传输。这是为了防止中间人攻击、防止信息泄露。但是，这个机制不是绝对的，因为仍然存在被攻击的可能性。而且，这种加密传输也不能完全阻止攻击者获取敏感的信息，例如访问权限、私钥等。

### 跨平台支持
SaltStack 支持多种主流操作系统，包括 Ubuntu、CentOS、Windows、MacOS 等。这是因为 Salt 是用 Python 语言编写的，可以在不同平台上运行。另外，还有一些第三方的模块可以支持 Salt 在其他平台上的运行。

### 命令执行模块
SaltStack 提供命令执行模块，用于远程执行命令。这些命令可以通过 Web 界面、API 调用、Salt 命令行工具或客户端工具来执行。

### 包管理模块
SaltStack 提供包管理模块，可在各种服务器上安装、卸载、更新软件包。可以通过 API 接口调用或 Salt 命令行工具完成相关操作。

### 文件传输模块
SaltStack 提供文件传输模块，可在远程主机之间传输文件。可以使用 salt cp 命令进行文件传输，也可以使用自定义模块实现更复杂的文件传输功能。

### 服务管理模块
SaltStack 提供服务管理模块，可以控制远程主机的启动和停止等操作。可以调用 Salt 命令或 API 来控制服务的开启和关闭。

### 状态监控模块
SaltStack 提供状态监控模块，可以监测远程主机的各种资源状态，包括硬件资源、软件资源、网络资源、进程资源等。可以使用 Salt Event 模块订阅远程主机的事件，实时监控主机的运行状况。

### 定时任务模块
SaltStack 提供定时任务模块，可以设置远程主机的定时任务。可以通过 Salt Scheduler 模块或 API 来设置定时任务。

### 配置管理模块
SaltStack 提供配置管理模块，可以对远程主机的配置文件进行修改，并且对变更后的配置进行校验。可以通过模板方式生成配置文件，或者直接调用 Salt State 模块进行配置管理。

### 部署管理模块
SaltStack 提供部署管理模块，可以将编译后的软件包部署到远程主机上，并启动相应的服务。通过调用 Salt Cloud 模块或 API ，可以快速部署到不同的云平台。

### 流程编排模块
SaltStack 提供流程编排模块，可以帮助运维人员编制复杂的任务流程。比如，启动远程主机的初始化流程，然后根据流程顺序依次启动不同服务、进行特定操作等。可以调用 Salt Cloud 模块或 API 将流程部署到远程主机。

### 远程命令执行模块
SaltStack 提供远程命令执行模块，可以让运维人员直接在远程主机上执行任意命令。可以调用 Salt Runners 模块或 API 执行命令。

## 2.2 SaltStack的安装与使用
### 安装SaltStack
#### 下载SaltStack安装包
首先，需要到官方网站下载最新版的 SaltStack 安装包，本文以 CentOS 7 为例：
```bash
wget https://repo.saltstack.com/py3/redhat/7/x86_64/archive/2019.2.0/SALTSTACK-GPG-KEY.pub -O /etc/pki/rpm-gpg/RPM-GPG-KEY-SaltStack
rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-SaltStack
cat <<EOF > /etc/yum.repos.d/salt.repo
[saltstack-repo]
name=SaltStack repo for Rhel/Centos $releasever
baseurl=https://repo.saltstack.com/$basearch/redhat/$releasever/$basearch/archive/${VERSION}/
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-SaltStack
EOF
yum install -y salt-master salt-minion salt-syndic salt-cloud salt-api
systemctl enable salt-master
systemctl start salt-master
```
这里的 `${VERSION}` 表示所要安装的 SaltStack 版本号，取决于实际情况。通常建议选择最新版本的 SaltStack 。

#### 检查SaltStack是否安装成功
检查一下 SaltStack 是否安装成功：
```bash
rpm -qa | grep salt
```
如果看到类似这样的输出，就说明安装成功：
```bash
python3-CherryPy-10.2.1-5.el7.noarch
python3-Mako-1.0.6-5.el7.noarch
python3-PyMySQL-0.9.3-3.el7.noarch
python3-cherrypy-process-checker-1.0.0-1.el7.noarch
python3-cryptography-2.4.2-1.el7.centos.noarch
python3-msgpack-0.5.6-3.el7.x86_64
python3-psutil-5.4.3-1.el7.x86_64
python3-pygit2-0.26.0-1.el7.x86_64
python3-requests-2.20.0-1.el7.noarch
python3-six-1.11.0-2.el7.noarch
salt-api-2019.2.0-1.el7.noarch
salt-cloud-2019.2.0-1.el7.noarch
salt-master-2019.2.0-1.el7.noarch
salt-minion-2019.2.0-1.el7.noarch
salt-syndic-2019.2.0-1.el7.noarch
```
### 配置SaltStack Master
#### 设置SaltStack监听地址和端口
默认情况下，SaltStack 会监听 `tcp://0.0.0.0:4505`，`tcp://:::4505`。如果需要修改监听地址和端口，可以编辑 `/etc/salt/master` 文件：
```yaml
interface: <listen address>   # 默认值为 0.0.0.0
publish_port: <listen port>    # 默认值为 4505
ret_port: <return port>        # 默认值为 4506
```
#### 设置Master加密密码
默认情况下，SaltStack Master 只接受本地连接，所以需要添加一个加密密码：
```bash
echo "your_password" | passwd --stdin root
sed -i's/^/        /' /etc/salt/master         # 添加注释以保持格式一致
echo -e "\n\n" >> /etc/salt/master               # 添加空行
echo "# SaltStack master settings\nauto_accept:\n  - minions\nexternal_auth:\n  pam:\n    username1:\n      -.*"\
>> /etc/salt/master                               # 添加外部认证配置，并设置root账户的认证规则为所有权限
service salt-master restart                       # 重新启动SaltStack Master服务
```
`- minions` 表示该账户只能管理 Salt Minion ，不能管理 Master；`.*` 表示该账户可以进行任何操作。用户名 `username1` 根据实际情况进行替换。

#### 验证Master的连接
执行 `test.ping` 命令来验证Master的连接：
```bash
salt '*' test.ping
```
如果看到类似如下输出，说明Master已经连接成功：
```bash
<hostname>:
    True
```
### 配置SaltStack Minion
#### 安装SaltStack Minion
安装SaltStack Minion 时不需要指定具体的SaltStack版本号。只需要使用标准的Yum安装命令即可：
```bash
yum install -y salt-minion
```
#### 设置Minion ID
默认情况下，SaltStack Minion 会自动生成唯一标识符作为ID。如果需要手动设置ID，可以编辑 `/etc/salt/minion` 文件：
```yaml
id: <minion id>           # 指定Minion的ID
```
#### 设置Master地址和认证信息
SaltStack Minion 需要知道Master的地址才能与Master通信。默认情况下，Minion 会自动从 Master 获取地址。如果需要手动设置地址，可以编辑 `/etc/salt/minion` 文件：
```yaml
master: <master IP or FQDN>                   # 指定Master的IP或FQDN
master_port: <master listening port>          # 指定Master的监听端口，默认为4505
username: <master user name>                 # 如果Master启用了登录认证，则需要设置用户名
password: <master password>                  # 如果Master启用了登录认证，则需要设置密码
```
#### 验证Minion的连接
执行 `test.ping` 命令来验证Minion的连接：
```bash
salt '*' test.ping
```
如果看到类似如下输出，说明Minion已经连接成功：
```bash
<minion hostname>:
    True
```
# 3.基本概念术语说明
## 3.1 SaltStack术语
- Salt Master：SaltStack 集群中的中心节点，负责管理工作的分配，监视各个节点的运行状态，并发送任务到各个节点进行执行。
- Salt Minion：SaltStack 集群中的节点，负责响应 Salt Master 的命令，并执行相应的操作。
- Grains：系统特征信息。Grains 是包含了关于某个实体（如服务器、网络设备、容器等）的静态信息的字典对象。
- Pillar：全局变量。Pillar 是在 Salt 术语中用来指代所有 Salt 管理对象的一个通用术语，用来存储跨越多个模块和文件的配置数据。
- State Tree：定义了一个预期状态。State Tree 是一系列文件，描述了 Salt 模块应该如何对某些资源进行修改，以及这些修改应该满足什么样的条件。
- Module：一种插件形式的扩展函数，用来实现对系统的各种操作，如服务管理、包管理、文件传输等。
- Runner：一种调用特殊的 Salt 模块的函数，用来对系统进行批量操作。
- Highstate：对所有服务器执行一次“highstate”操作。Highstate 是一种 Salt 术语，它会读取服务器配置的 SLS 文件，并按照定义的状态进行操作。
- SLS：Salt State Language 的缩写，表示 Salt 模块的定义文件。SLS 文件使用 YAML 语法定义了一系列的资源，以及它们应该遵循的状态。
- Salt Proxy：SaltProxy 是 Salt 中的一个概念，它代表一个客户端代理。SaltProxy 可以和 Salt Master 进行通信，也可以使用 API 和 Salt 命令行工具进行交互。
- External Authentication System：外部认证系统，是 SaltStack 提供的一套权限管理解决方案。

## 3.2 SaltStack术语之间的关系

# 4.核心算法原理和具体操作步骤
## 4.1 SaltStack模块
### 介绍
SaltStack 模块提供了 SaltStack 集群内的功能扩展，是 SaltStack 的核心组件。每个模块都可以单独安装、升级、删除、启动和停止。当 SaltStack 需要提供新的功能时，一般都会通过编写模块的方式来实现。

模块的加载路径分为系统级和用户级两种。系统级模块安装在 `/usr/lib/pythonX.Y/site-packages/salt/modules/` 下，由 Salt Core 自动加载；用户级模块安装在 `~/.local/lib/pythonX.Y/site-packages/salt/modules/` 下，可以被指定的目录下的文件夹指定加载。

### 用法
模块通过 Python 函数实现，一般遵循如下步骤：

1. 创建一个 Python 函数，函数名必须以 `mod_` 开头，后面紧跟模块的名称，比如 mod_apache。
2. 函数需要接受一个字典参数，里面包含了所有的模块传入的参数。
3. 函数返回一个字典对象，里面的键值对将会以 `key:value` 的形式传给 Salt Master。

举个例子：

```python
def mod_apache(data):
    status = os.system("apachectl configtest")
    if status == 0:
        return {"result":True}
    else:
        return {"result":False,
                "comment":"Apache configuration error"}
```

在该模块的作用范围内，Apache 配置错误将会导致结果为 False，其它情况则返回 True。

### 实例
为了演示模块的使用方法，我们可以创建一个 Python 脚本来在 Salt Master 上安装 Apache。

```bash
#!/bin/sh

sudo yum update -y && sudo yum install httpd -y
touch /var/www/html/index.html
echo "<h1>Welcome to my web page</h1>" > /var/www/html/index.html
echo "<p>This is a sample HTML file.</p>" >> /var/www/html/index.html
chmod o+r /var/www/html/*
service httpd start
chkconfig httpd on
```

我们先把该脚本保存成文件 `install_apache.sh`，然后就可以在 Salt Master 上安装 Apache 了。

```bash
[root@localhost ~]# curl -o install_apache.sh https://gist.githubusercontent.com/AnsibleChina/c03580a1a8b53f9a7a0befaae6797651/raw/bbdc5ddcf3fb1b7ea6fc2cd8c08a842db493d264/install_apache.sh
[root@localhost ~]# chmod +x install_apache.sh
[root@localhost ~]# ls install*
install_apache.sh
[root@localhost ~]#./install_apache.sh
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   261  100   261    0     0    637      0 --:--:-- --:--:-- --:--:--   637
  0 13.6M    0 6085k    0     0  6438k      0 --:--:-- --:--:-- --:--:-- 6744k
100 13.6M  100 13.6M    0     0  11.6M      0  0:00:01  0:00:01 --:--:-- 11.6M
Redirecting to /bin/systemctl start httpd.service
Redirecting to /bin/systemctl start firewalld.service
Job for httpd.service failed because the control process exited with error code. See "systemctl status httpd.service" and "journalctl -xe" for details.
[root@localhost ~]# service httpd status
● httpd.service - The Apache HTTP Server
   Loaded: loaded (/usr/lib/systemd/system/httpd.service; disabled;)
   Active: inactive (dead)
     Docs: man:httpd.service(8)
```

看到上面的报错信息吗？好像是因为没有配置防火墙导致的，我们尝试一下查看防火墙状态：

```bash
[root@localhost ~]# systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/firewalld/firewalld.service; enabled; vendor preset: disabled)
   Active: active (running) since Mon 2019-06-05 10:53:32 CST; 1 day 4h ago
     Docs: man:firewalld(1)
 Main PID: 581 (firewalld)
    Tasks: 1
   Memory: 2.4M
      CPU: 13ms
   CGroup: /system.slice/firewalld.service
           └─581 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid
Warning: Journal has been rotated since unit was started. Log output is incomplete or unavailable.
[root@localhost ~]# firewall-cmd --zone=public --add-port=80/tcp --permanent
success
[root@localhost ~]# firewall-cmd --reload
success
```

可以看到，防火墙已经打开了 80 端口。现在再次执行 `./install_apache.sh` 命令看看是否成功安装 Apache：

```bash
[root@localhost ~]#./install_apache.sh
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   261  100   261    0     0    614      0 --:--:-- --:--:-- --:--:--   614
  0 13.6M    0 7694k    0     0  5507k      0 --:--:-- --:--:-- --:--:-- 6744k^C
[root@localhost ~]# lsof -i :80
COMMAND     PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
httpd    22412 root    4u  IPv4   2573      0t0  TCP *:http (LISTEN)
```

可以看到，Apache 正在监听 80 端口。

```bash
[root@localhost ~]# curl localhost:80
<!DOCTYPE html>
<html>
<head>
<title>Welcome to my web page</title>
</head>
<body>
<h1>Welcome to my web page</h1>
<p>This is a sample HTML file.</p>
</body>
</html>
```

如果看到上面那串 HTML 内容，就说明 Apache 安装成功了。

## 4.2 SaltStack Grains
### 介绍
Grains 是包含了关于某个实体（如服务器、网络设备、容器等）的静态信息的字典对象。它包含的信息如 CPU 类型、内存大小、操作系统、主机名、域名、IP 地址等，通常会被用作判断条件，判断出当前系统属于哪种类型的机器。

Grains 在 Salt 中主要用来做两件事情：

1. 在 Master 上进行系统信息收集，用于标识目标系统的身份信息。
2. 在 Minion 上安装模块或渲染配置文件时提供配置模板。

Grains 对象是一个字典，里面包含了许多字段。每一个字段的值都是唯一的，可以从系统中收集得到。

### 用法
Grains 有两种获取方式：

1. 从系统中直接获取。Grains 会从系统中获取信息，并根据具体的系统环境构建字典。可以直接通过 `grains.items()` 方法获得当前系统的所有 Grains。
2. 生成自定义 Grains 文件。Grains 文件必须以 `.sls` 为扩展名，并且放在 `_grains` 目录中。文件内部只能有一个顶层结构，必须是字典类型。顶层的键值对会被合并到全网范围的 Grains 中。

举个例子，如果有一个叫 `server1.example.com` 的服务器，它有三个磁盘，分别是 `/dev/sda`, `/dev/sdb`, `/dev/sdc`：

```yaml
diskspace:
  /dev/sda:
    size: 20000 MB
  /dev/sdb:
    size: 50000 MB
  /dev/sdc:
    size: 80000 MB
```

这个 Grains 文件可以放到 `/srv/salt/_grains/server1.example.com.sls` 文件中，该文件会被同步到所有服务器上。在 Salt Master 上执行命令 `salt server1.example.com grains.item diskspace`，可以看到对应的 Grains 文件被应用到了服务器上：

```bash
[root@localhost ~]# salt server1.example.com grains.item diskspace
server1.example.com:
    ----------
    /dev/sda:
        ----------
        size:
            20000 MB
    /dev/sdb:
        ----------
        size:
            50000 MB
    /dev/sdc:
        ----------
        size:
            80000 MB
```

此外，还有一些 Grains 文件会在 Salt Minion 上自动生成，包括 `kernelversion`，`nodename`，`os`，`osfullname`，`osrelease`，`oscodename`，`num_cpus`，`mem_total`，`mem_swap`，`cpu_model`。

### 实例
#### 查看 Grains
我们可以查看当前服务器的 Grains 信息：

```bash
[root@localhost ~]# salt'server*' grains.items
server1.example.com:
    ----------
    cpu_model:
        Intel(R) Xeon(R) CPU E5-2620 v3 @ 2.40GHz
    cpu_flags:
        fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 monitor ds_cpl vmx est tm2 ssse3 cx16 xtpr pdcm pcid sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx lahf_lm epb cat_l3 cdp_l3 intel_ppin md_clear
    num_cpus:
        2
    kernelrelease:
        3.10.0-862.el7.x86_64
    mem_total:
        12506 MiB
    mem_free:
        10264 MiB
    nodename:
        server1.example.com
    os:
        RedHat
    os_family:
        RedHat
    osfullname:
        Red Hat Enterprise Linux Server
    osmajorrelease:
        7
    osrelease:
        7.5
```

#### 生成 Grains 文件

#### 使用 Grains 文件

## 4.3 SaltStack Pillar
### 介绍
Pillar 是在 Salt 术语中用来指代所有 Salt 管理对象的一个通用术语，用来存储跨越多个模块和文件的配置数据。Pillar 可以用来设置 SSH 凭据、应用程序配置、数据库配置等。Pillar 是通过集成的文件服务器，而非通过像 Git 或 Mercurial 那样的版本控制系统，来存储的。

Pillar 对象是一个字典，包含了各种字段，每个字段的值可以是字符串、列表或字典。Pillar 可以用来跨越模块和配置文件，实现灵活的配置管理。

### 用法
Pillar 有两种获取方式：

1. Pillar SLS 文件。Pillar SLS 文件必须以 `.sls` 为扩展名，并且放在 `_pillar` 目录中。文件内部只能有一个顶层结构，必须是字典类型。Pillar SLS 文件中可以引用模块和函数，也可以被用来动态的生成配置。
2. 外部 pillar 数据源。可以通过配置接口（RESTful API、ZeroMQ PubSub 等），从外部系统获取 Pillar 数据。

举个例子：

```yaml
user1:
  ssh_private_key: |
    -----BEGIN RSA PRIVATE KEY-----
    abcdefg...
   ...xyz
    -----END RSA PRIVATE KEY-----
  authorized_keys:
    - ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDAW...
    - ssh-rsa BBBBBBBBBBBBBBBB...
```

在该示例中，用户 `user1` 的 SSH 私钥和密匙都保存在 Pillar 文件中，这些数据可以在 Salt Master 和 Minion 上使用。

另一个例子：

```yaml
users:
  - user1
  - user2
  - user3

ssh_config:
  Port: 22
  Protocol: 2
  HostKeyAlgorithms: rsa,dsa

  default:
    User: root
    IdentityFile: /etc/ssh/id_rsa

  user*:
    ForwardAgent: yes

    command1: echo Hello World!
    command2: tail /var/log/messages

  db*:
    User: postgres
    Port: 5432
    DBName: test
    Password: {{pillar['passwords']['postgres']}}
```

在该示例中，SSH 配置段包含了一些字段和值的默认值，并且在后面通过 `command1` 和 `command2` 两个命令进行了扩展。密码可以通过 `{{pillar['passwords']['postgres']}}` 的方式从外部 pillar 数据源获取。

### 实例
#### 导入 Pillar 数据
在 Master 和 Minion 上，都可以使用 `pillar.get` 函数来获取 Pillar 数据。

例如，在 Minion 上：

```bash
[root@localhost ~]# salt-call pillar.get users
local:
    - user1
    - user2
    - user3
```

#### 导出 Pillar 数据
Master 上的 Pillar 数据也可以通过接口来导出。

例如，在 Master 上：

```bash
[root@localhost ~]# curl -H "Accept: application/json" http://localhost:8000/run \
  -d client='runner' \
  -d tgt='server1.example.com' \
  -d fun='pillar.show_pillar'
{
    "minions": {
        "server1.example.com": {
            "data": {
                "_errors": [],
                "user1": {
                    "authorized_keys": [
                        "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDAWfJyDzZzrcHvA10jvNdDtkKZRSqgVuiEuKHIiiZbZPl3XzFnIp/VZhwRBLmaOT1lnvFvVrMYvJ9jUHTQbKZeOVLZq8zlrIuxRwGjHyhz79yzZ0avszLExq4rm68WSkGSVHPmh8="
                    ], 
                    "ssh_private_key": "-----BEGIN RSA PRIVATE KEY-----\nabcdefg...\n...xyz\n-----END RSA PRIVATE KEY-----"
                }, 
                "user2": {
                    "authorized_keys": [
                        "ssh-rsa BBBBBBBBBBBBBBBBaTcHJpdmFjeXogb2RmZXkybmRlYm8gYWRkaXRpb25hbCBmb3JtYXQuCmNlZmVyZW5jZSBwcm9kdWNlczA=\n"
                    ]
                }, 
                "user3": {}
            }
        }
    }, 
    "success": true
}
```

#### 渲染 Pillar 数据
Pillar 数据也可以通过 Jinja 渲染引擎进行渲染。

例如，在 Minion 上：

```bash
[root@localhost ~]# salt-call pillar.get'mysql.db*.Password|join(",")'
local:
    MySuperSecretPassword,MyOtherSecretPassword
```

#### 修改 Pillar 数据
Pillar 数据也可以通过 API 接口进行修改。

例如，在 Master 上：

```bash
[root@localhost ~]# curl -X PUT http://localhost:8000/run \
  -d client='wheel' \
  -d fun='key.list_all' \
  -d match='test.*' \
  -d token='mytoken'
{
    "minions": {
        "server1.example.com": {
            "data": []
        }, 
        "server2.example.com": {
            "data": [
                "bar", 
                "foo", 
                "test."
            ]
        }
    }, 
    "perms": {}, 
    "starttime": "2019, Jun 11 05:39:38.734823", 
    "success": true, 
    "tok": null
}
```

#### 生成 Pillar 文件
除了可以从外部数据源导入数据，Pillar 还可以通过 `pillar.set` 等函数，在 Master 和 Minion 上生成新的 Pillar 文件。

例如，在 Master 上：

```bash
[root@localhost ~]# curl -X POST http://localhost:8000/run \
  -d client='wheel' \
  -d fun='key.gen' \
  -d keyname='newsecret'
{
    "jid": "20190611054725417377", 
    "tag": "salt/wheel/20190611054725417377", 
    "tgt_type": "glob", 
    "tgt": "*", 
    "user": "root", 
    "fun": "key.gen", 
    "arg": [
        "newsecret"
    ], 
    "kwargs": {}, 
    "ret": "", 
    "success": true, 
    "full_ret": [
        {
            "jid": "20190611054725417377", 
            "minions": [
                "*"
            ], 
            "missing": []
        }
    ]
}
```