
作者：禅与计算机程序设计艺术                    

# 1.简介
  

Websockets 是一种用于实时通信的协议，允许服务器主动向客户端推送数据。在实时的应用场景中，它非常有用，如聊天室、游戏、股票行情等。WebSockets 基于TCP协议，相对于轮询(polling)的方式，可以显著提高性能。本文将带领读者实现一个基于 Node.js 的 WebSocket 服务端，包括服务端的设计、搭建、配置、部署和维护。

# 2.基础知识
## 2.1 WebSockets
WebSocket 是 HTML5 开始提供的一种新的网络通信协议，用于实现可靠的双向通信信道。WebSocket 是建立在 TCP 协议之上的一种协议，可以更有效地进行实时通信。其特点如下：

1. 建立在 TCP 协议上， reliable and fast;
2. 同源策略限制了跨域通信；
3. 没有同源策略限制，可以发送请求到任意域名下的资源；
4. 支持全双工通信，实时性更好；
5. 握手阶段类似 HTTPS 协议；
6. 可扩展性良好，支持自定义协议。

## 2.2 HTTP vs WebSocket
| Features     | WebSocket | HTTP   |
| ------------ | --------- | ------ |
| Connection   | Bi-directional      | One way only    |
| Type         | Full-duplex          | Request/Response |
| Security     | TLS support          | SSL/TLS support |
| Latency      | Low latency          | Higher latency |
| Data format  | Binary               | Text            |
| Message size | Unlimited            | Limited to URL length (less than ~4KB) |
| Efficiency   | Faster               | Slower           |


## 2.3 Node.js
Node.js 是一个开源的 JavaScript 运行环境，可以用于开发各种类型的应用，如 web 应用、命令行工具、后台服务等。它具有以下特性：

1. 事件驱动、非阻塞I/O模型；
2. 轻量级并发模型；
3. 模块化、NPM生态圈；
4. 更高效、更易于使用。

# 3. Designing the Socket Server
## 3.1 Requirements Gathering
首先，确定项目需求，确定服务端功能范围。列出项目功能需求清单，包含：

1. 用户登录认证：用户输入用户名密码后，服务端验证通过后返回token给客户端，后续接口调用需要token；
2. 聊天室：允许多个用户之间互发消息，同时支持私聊；
3. 在线状态监控：展示当前在线用户列表及历史记录；
4. 文件传输：支持浏览器上传文件到服务端，支持客户端下载文件；
5. 日志管理：保存所有聊天记录、登录登出记录、异常报错记录。

## 3.2 Project Architecture
设计架构图如下：


可以看出，项目分为前端、后端两个部分。前端负责渲染页面，后端负责处理请求逻辑。我们需要在前端加入 WebSocket API，使得浏览器与后端建立 WebSocket 长连接。后端主要由 Node.js + Express + MongoDB 组成。其中：

1. Node.js 提供事件驱动、异步 I/O 模型，支持服务端编程；
2. Express 为 Node.js 平台提供了快速、开放且极具表现力的 Web 框架；
3. MongoDB 是最流行的 NoSQL 数据库之一。

我们还需考虑安全性，需要采用 Token 机制。用户登录成功后生成 token 返回给客户端，后续接口请求都需要带上这个 token，服务端对 token 校验通过才允许访问。

## 3.3 APIs
目前已经确定了接口需求，定义如下：

1. login: 用户登录
2. getOnlineUsers: 获取在线用户列表
3. postMessage: 发送消息至聊天室
4. privateChat: 私聊
5. uploadFile: 上传文件
6. downloadFile: 下载文件

## 3.4 Database Schema
接下来需要设计数据库表结构。我们会创建5个表：user, message, file, online_users 和 log。

### user
```javascript
{
    "_id": ObjectId("..."), // id, autogenerated by MongoDB
    "username": String, // username for login authentication
    "passwordHash": String, // password hash value after hashed using bcrypt algorithm
    "createTime": Date, // create time when creating an account
    "lastLoginTime": Date, // last login time of this user
    "avatarUrl": String, // url of avatar image file, optional
    "status": Number, // status of current user, default is 0 (offline)
}
```

### message
```javascript
{
    "_id": ObjectId("..."), // id, autogenerated by MongoDB
    "fromUserId": ObjectId, // sender's id
    "toUserId": ObjectId, // receiver's id, can be empty if it is a broadcast message
    "content": String, // content of the message
    "type": String, // type of the message, can be text or file, etc.
    "createTime": Date, // create time when sending the message
    "isRead": Boolean, // whether read by recipient, default is false
}
```

### file
```javascript
{
    "_id": ObjectId("..."), // id, autogenerated by MongoDB
    "userId": ObjectId, // owner's id
    "fileName": String, // name of the file
    "fileSize": Number, // size of the file in bytes
    "uploadDate": Date, // date of uploading the file
}
```

### online_users
```javascript
{
    "_id": ObjectId("..."), // id, autogenerated by MongoDB
    "userId": ObjectId, // connected user's id
    "sessionId": String, // session ID generated by socket.io server
    "lastActiveTime": Date, // last active time of this user
}
```

### log
```javascript
{
    "_id": ObjectId("..."), // id, autogenerated by MongoDB
    "userId": ObjectId, // operator's id, can be null if no related user exists (e.g., system operation logs)
    "operationName": String, // name of the operation performed
    "operationDetail": String, // detailed information of the operation
    "operationResult": String, // result of the operation
    "createTime": Date, // time when performing the operation
}
```

# 4. Building the Server
## 4.1 Environment Setup
首先安装 Node.js 和 npm。选择 LTS 版本下载。然后安装 MongoDB Community Edition。

创建工作目录，打开终端切换到该目录，执行以下命令安装依赖包：

```bash
npm init -y
npm install express mongoose body-parser cors ws bcrypt jsonwebtoken multer socket.io
```

## 4.2 Creating Folders and Files
创建以下文件夹和文件：

```text
+-- config
    └── index.js
+-- controllers
    ├── chatController.js
    ├── fileController.js
    ├── index.js
    ├── logController.js
    └── userController.js
+-- middleware
    ├── authMiddleware.js
    ├── errorHandlingMiddleware.js
    ├── loggerMiddleware.js
    ├── responseFormatMiddleware.js
    └── tokenValidationMiddleware.js
+-- models
    ├── File.js
    ├── Log.js
    ├── Message.js
    ├── OnlineUser.js
    └── User.js
+-- routes
    ├── chatRoutes.js
    ├── fileRoutes.js
    ├── index.js
    ├── logRoutes.js
    └── userRoutes.js
+-- utils
    ├── constants.js
    ├── dbUtils.js
    ├── jwtUtils.js
    └── sendEmail.js
app.js
package.json
server.js
```

## 4.3 Configuring Dependencies
打开 `config` 文件夹中的 `index.js`，配置依赖项：

```javascript
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const multer = require('multer');
const { Server } = require('socket.io');
require('dotenv').config();

// Connect to database
mongoose.connect(process.env.MONGODB_URI ||'mongodb://localhost/chatdb', { useNewUrlParser: true });

// Initialize app and configure middleware
const app = express();
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());
app.use(cors());
app.use('/uploads/', express.static(__dirname + '/uploads'));
app.use((req, res, next) => {
  console.log(`Request from ${req.ip}`);
  next();
});

// Configure multer for handling uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, __dirname + '/uploads/');
  },
  filename: (req, file, cb) => {
    const ext = file.mimetype.split('/')[1];
    cb(null, `${new Date().getTime()}.${ext}`);
  },
});
const upload = multer({ storage }).single('file');

// Initialize socket io server and configure options
const httpServer = require('http').createServer(app);
const io = new Server(httpServer, {
  cors: { origin: '*', methods: ['GET', 'POST'] },
  allowEIO3: true,
});

module.exports = {
  app,
  httpServer,
  io,
  bcrypt,
  jwt,
  multer,
  upload,
};
```

## 4.4 Setting up Routes and Controllers
打开 `routes` 文件夹中的 `index.js`，设置路由和控制器：

```javascript
const express = require('express');
const router = express.Router();
const userRoutes = require('./userRoutes');
const chatRoutes = require('./chatRoutes');
const fileRoutes = require('./fileRoutes');
const logRoutes = require('./logRoutes');

router.get('/', (req, res) => {
  res.sendStatus(200);
});

router.use('/api/users', userRoutes);
router.use('/api/chats', chatRoutes);
router.use('/api/files', fileRoutes);
router.use('/api/logs', logRoutes);

module.exports = router;
```

分别在 `controllers`, `middleware`, `models`, `utils` 文件夹中创建对应的路由和控制器。

## 4.5 Defining Models and Middlewares
在 `models` 文件夹中创建 `User`, `Message`, `File`, `OnlineUser`, `Log` 模型。`User` 模型示例如下：

```javascript
const mongoose = require('mongoose');
const crypto = require('crypto');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Username cannot be blank'],
    unique: true,
    trim: true,
    minlength: 3,
    maxlength: 50,
  },
  passwordHash: {
    type: String,
    required: true,
  },
  createTime: {
    type: Date,
    default: Date.now(),
  },
  lastLoginTime: {
    type: Date,
  },
  avatarUrl: {
    type: String,
  },
  status: {
    type: Number,
    default: 0, // offline, will set it to 1 on successful login
  },
});

// Hash user's password before saving into the database
userSchema.pre('save', function saveHook(next) {
  const user = this;

  if (!user.isModified('passwordHash')) return next();

  bcrypt.hash(user.passwordHash, 10).then((hash) => {
    user.passwordHash = hash;
    next();
  });
});

// Compare incoming passwords with saved hash values
userSchema.methods.comparePassword = function comparePassword(candidatePassword, callback) {
  bcrypt.compare(candidatePassword, this.passwordHash, callback);
};

const User = mongoose.model('User', userSchema);

module.exports = User;
```

在 `middlewares` 文件夹中创建 `authMiddleware`, `errorHandlingMiddleware`, `loggerMiddleware`, `responseFormatMiddleware`, `tokenValidationMiddleware`。

`authMiddleware` 中间件示例如下：

```javascript
const jwt = require('jsonwebtoken');

function verifyToken(req, res, next) {
  const token = req.headers['x-access-token'];

  if (!token) {
    return res.status(401).json({
      success: false,
      message: 'Authentication failed. Missing token.',
    });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded._id;
    next();
  } catch (err) {
    return res.status(401).json({
      success: false,
      message: 'Invalid token.',
    });
  }
}

module.exports = verifyToken;
```

`errorHandlingMiddleware` 中间件示例如下：

```javascript
function handleError(err, req, res, next) {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    message: err.message,
  });
}

module.exports = handleError;
```

`loggerMiddleware` 中间件示例如下：

```javascript
function logOperation(req, res, next) {
  console.log(`${req.method} ${req.url}`);
  next();
}

module.exports = logOperation;
```

`responseFormatMiddleware` 中间件示例如下：

```javascript
function formatResponse(req, res, next) {
  res.setHeader('Content-Type', 'application/json');
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'X-Requested-With');
  next();
}

module.exports = formatResponse;
```

`tokenValidationMiddleware` 中间件示例如下：

```javascript
function validateToken(req, res, next) {
  let userId;

  try {
    const token = req.headers['x-access-token'];

    if (!token) throw new Error('Missing token.');

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    userId = decoded._id;
  } catch (err) {
    return res.status(401).json({
      success: false,
      message: 'Invalid token.',
    });
  }

  User.findByIdAndUpdate(
    userId,
    { $set: { lastLoginTime: Date.now() } },
    { upsert: true, new: true },
    (err, user) => {
      if (err) return res.status(500).json({ success: false, message: 'Failed to update user data.' });

      if (!user)
        return res
         .status(401)
         .json({ success: false, message: 'Token validation failed. User not found.' });

      req.user = user;
      next();
    }
  );
}

module.exports = validateToken;
```

## 4.6 Defining Controllers and Routes
在 `controllers` 文件夹中创建 `userController`, `chatController`, `fileController`, `logController`。`chatController` 示例如下：

```javascript
const jwt = require('jsonwebtoken');
const moment = require('moment');
const Message = require('../models/Message');
const OnlineUser = require('../models/OnlineUser');
const { checkObjectId } = require('../middleware/checkObjectId');
const { encryptMessage } = require('../utils/jwtUtils');

function generateAccessToken(userId) {
  return jwt.sign({ _id: userId }, process.env.ACCESS_TOKEN_SECRET, { expiresIn: '1h' });
}

async function fetchMessagesFromDbAndFilterPrivateChats(userId, otherUserId) {
  const messages = await Message.find({
    $or: [{ fromUserId: userId, toUserId: otherUserId }, { fromUserId: otherUserId, toUserId: userId }],
  })
   .sort('-createTime')
   .limit(100);

  const filteredMessages = [];

  messages.forEach((msg) => {
    const encryptedMsg = encryptMessage(msg, userId === msg.fromUserId? 'private' : 'group');
    filteredMessages.push(encryptedMsg);
  });

  return filteredMessages;
}

async function fetchOnlineUsersList(userId) {
  const onlineUsers = await OnlineUser.find({ userId });

  const formattedOnlineUsers = onlineUsers.map((onlineUser) => ({
    sessionId: onlineUser.sessionId,
    lastActiveTime: moment(onlineUser.lastActiveTime).format('YYYY-MM-DD HH:mm:ss'),
  }));

  return formattedOnlineUsers;
}

async function sendMessageToDb(userId, message) {
  const now = new Date();
  const messageId = new mongoose.Types.ObjectId();
  const encryptedMsg = encryptMessage(message, 'public');

  const createdMsg = await Message.create({
    _id: messageId,
    fromUserId: userId,
    toUserId: encryptedMsg.toUserId,
    content: encryptedMsg.content,
    type: encryptedMsg.type,
    createTime: now,
    isRead: false,
  });

  return createdMsg;
}

async function markMessageAsRead(messageId, userId) {
  await Message.updateOne({ _id: messageId }, { $set: { isRead: true } });
}

module.exports = {
  generateAccessToken,
  fetchMessagesFromDbAndFilterPrivateChats,
  fetchOnlineUsersList,
  sendMessageToDb,
  markMessageAsRead,
};
```

`fileController` 示例如下：

```javascript
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const { checkObjectId } = require('../middleware/checkObjectId');
const File = require('../models/File');

async function deleteFileFromDisk(filePath) {
  return new Promise((resolve, reject) => {
    fs.unlink(filePath, (err) => {
      if (err) return reject(err);
      resolve();
    });
  });
}

async function storeUploadedFile(userId, file) {
  const fileName = uuidv4();
  const filePath = `./uploads/${fileName}`;
  const fileSize = parseInt(file.size / 1024, 10); // convert byte to KB

  const storedFile = new File({
    _id: new mongoose.Types.ObjectId(),
    userId,
    fileName,
    fileSize,
    uploadDate: new Date(),
  });

  await new Promise((resolve, reject) => {
    file.mv(filePath, async (err) => {
      if (err) return reject(err);
      await storedFile.save();
      resolve(storedFile);
    });
  });

  return storedFile;
}

async function fetchStoredFilesList(userId) {
  const files = await File.find({ userId });

  return files.map(({ _id, fileName, fileSize, uploadDate }) => ({
    _id: _id.toString(),
    fileName,
    fileSize,
    uploadDate: moment(uploadDate).format('YYYY-MM-DD HH:mm:ss'),
  }));
}

async function streamFile(res, file) {
  const filePath = `./uploads/${file.fileName}`;

  return new Promise((resolve, reject) => {
    const reader = fs.createReadStream(filePath);
    reader.on('error', (err) => {
      reject(err);
    });

    reader.pipe(res);

    reader.on('end', () => {
      resolve();
    });
  });
}

async function deleteStoredFile(userId, fileId) {
  const fileToDelete = await File.findOne({ _id: fileId, userId });

  if (!fileToDelete) return null;

  const filePath = `./uploads/${fileToDelete.fileName}`;

  await deleteFileFromDisk(filePath);

  return fileToDelete;
}

module.exports = {
  deleteFileFromDisk,
  storeUploadedFile,
  fetchStoredFilesList,
  streamFile,
  deleteStoredFile,
};
```

`logController` 示例如下：

```javascript
const Log = require('../models/Log');

async function recordOperation(req, operationName, operationDetail, operationResult) {
  const now = new Date();
  const logMessage = new Log({
    userId: req.user,
    operationName,
    operationDetail,
    operationResult,
    createTime: now,
  });

  return await logMessage.save();
}

async function fetchLogsFromDb(userId) {
  const logs = await Log.find({ userId });

  return logs.map(({ _id, operationName, operationDetail, operationResult, createTime }) => ({
    _id: _id.toString(),
    operationName,
    operationDetail,
    operationResult,
    createTime: moment(createTime).format('YYYY-MM-DD HH:mm:ss'),
  }));
}

module.exports = {
  recordOperation,
  fetchLogsFromDb,
};
```

`userController` 示例如下：

```javascript
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const moment = require('moment');
const User = require('../models/User');
const { encryptMessage } = require('../utils/jwtUtils');

async function registerUser(userData) {
  userData.passwordHash = await bcrypt.hash(userData.password, 10);
  const createdUser = await User.create(userData);
  const accessToken = jwt.sign({ _id: createdUser._id }, process.env.JWT_SECRET, { expiresIn: '1d' });

  return {...createdUser.toObject(), accessToken };
}

async function loginUser(loginData) {
  const user = await User.findOne({ username: loginData.username });

  if (!user) throw new Error('Invalid credentials.');

  const isValidPassword = await bcrypt.compare(loginData.password, user.passwordHash);

  if (!isValidPassword) throw new Error('Invalid credentials.');

  const accessToken = jwt.sign({ _id: user._id }, process.env.JWT_SECRET, { expiresIn: '1d' });

  return {...user.toObject(), accessToken };
}

async function getUserInfo(userId) {
  const userInfo = await User.findById(userId).select('+passwordHash');

  return {...userInfo.toObject(), avatarUrl: userInfo.avatarUrl || '' };
}

async function updateUserInfo(userId, userData) {
  if ('password' in userData && userData.password!== '') userData.passwordHash = await bcrypt.hash(userData.password, 10);

  await User.findByIdAndUpdate(userId, userData);

  const updatedUser = await User.findById(userId).select('+passwordHash');

  return {...updatedUser.toObject(), avatarUrl: updatedUser.avatarUrl || '' };
}

async function changeAvatarImage(userId, formData) {
  const oldFileId = await updateUserInfo(userId, { avatarUrl: '', removeOldFile: true });
  const uploadedFile = await storeUploadedFile(userId, formData.file);

  if (oldFileId!= null) await deleteStoredFile(userId, oldFileId);

  return uploadedFile;
}

async function logoutUser(userId, sessionId) {
  const affectedCount = await OnlineUser.deleteMany({ userId, sessionId });

  return affectedCount > 0;
}

async function disconnectSocket(socketIoInstance, socketId) {
  const onlineUser = await OnlineUser.findOneAndDelete({ sessionId: socketId });

  if (!onlineUser) return;

  socketIoInstance.in(`u_${userId}`).emit('logout', { userId });
}

module.exports = {
  registerUser,
  loginUser,
  getUserInfo,
  updateUserInfo,
  changeAvatarImage,
  logoutUser,
  disconnectSocket,
};
```

# 5. Running the Server
## 5.1 Starting the Server
创建一个 `server.js` 文件，启动服务端：

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const morgan = require('morgan');
const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;
const cookieSession = require('cookie-session');
const dotenv = require('dotenv');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');

dotenv.config();

const app = express();
const port = process.env.PORT || 3000;
const limiter = rateLimit({ windowMs: 15 * 60 * 1000, max: 100 });

if (process.env.NODE_ENV === 'production') {
  app.use(limiter);
  app.enable('trust proxy');
  app.use(helmet());
  app.use(compression());
} else {
  app.use(morgan('dev'));
}

app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

app.use(
  cookieSession({
    name:'session',
    secret: process.env.SESSION_SECRET,
    secure: process.env.NODE_ENV === 'production',
  }),
);

app.use(passport.initialize());
app.use(passport.session());

app.use('/api', require('./routes'));

app.listen(port, () => {
  console.log(`Listening at http://localhost:${port}/`);
});
```

## 5.2 Testing the Server
为了测试服务端是否正常运行，我们可以使用 Postman 测试注册、登录、获取用户信息、发送消息、上传文件、下载文件、修改头像、获取历史记录、获取在线用户等接口。

# 6. Deploying the Server
部署服务端可根据实际情况选择云服务器、Docker 或 Kubernetes。这里不详细讨论。