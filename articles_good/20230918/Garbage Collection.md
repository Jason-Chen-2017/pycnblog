
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 概述
垃圾收集（Garbage Collection）是计算机内存管理技术中最重要的部分。当程序运行时会产生各种各样的对象（Object），这些对象需要在堆上进行存储。由于程序执行过程中动态创建的对象很多，因此堆上的空间不足时，需要对占用内存较多的对象进行回收释放空间。而垃�桶收集（GC）就是负责回收垃圾的一种自动化技术。通过自动分析程序中对象之间的引用关系，并确定哪些对象可以回收、哪些对象不能回收，从而达到释放内存的目的。

JVM使用的GC机制叫做基于标记-清除算法。该算法分两步：首先遍历所有的对象，标记活着的对象，然后回收非活跃对象的内存空间。缺点是无法解决碎片化的问题，导致后续分配大对象的时候性能下降。

Sun HotSpot JVM中的GC机制更加复杂，它引入了分代收集算法，将堆划分成不同的区域，每一个区域采用不同的GC算法。新生代（Young Generation）采用复制算法，老年代（Tenured Generation）采用标记-整理算法。根据HotSpot VM参数配置，JVM也可以将不同类型的对象分别放入不同的区域。

## 相关知识
### 分代收集算法（Generational Garbage Collection）
分代收集算法把堆内存分成两个相互独立的区域——新生代和老年代。新生代一般占据堆的较大一部分，主要是存放短期存活的对象。老年代则存放长期存活的对象。JVM使用分代收集算法能够避免频繁回收新生代，因为新生代的对象生命周期较短；同时也减少了全堆扫描造成的停顿。

### 标记-清除算法
标记-清除算法是一种简单的垃圾收集算法。其基本思路是扫描所有正在使用的对象，并标记出其中可回收的对象。然后再回收被标记的对象所占用的内存空间。但是这种方法会出现“空间碎片”，即已回收的对象之间还有些许的空闲空间，如果要分配较大的对象，就可能出现内存不够用的情况。

### 复制算法
复制算法把堆内存分成两块相同的大小，每次只使用其中一块。当这一块的空间耗尽时，就将还存活的对象复制到另一块上面，并把当前的一块空间一次清理掉。这样使得每次都有足够的空间容纳新生代中的对象。

### 标记-整理算法
标记-整理算法也是一种简单而高效的算法。它的基本思想是扫描所有正在使用的对象，标记出其中可回收的对象，之后将所有的对象依次拷贝到内存的一端，然后直接清理掉边界外的内存。

### 年轻代垃圾收集算法
年轻代垃圾收集算法主要有串行（Serial）、并行（Parallel）、CMS（Concurrent Mark Sweep）和G1四种。

#### Serial（单线程）
Serial是最古老、最简单、最稳定的一种算法。对于新生代的垃圾收集，它是一个单线程、标记-复制的算法，初始标记、最终标记、复制三个步骤组成。初始标记只是标记一下 GC Roots 能直接关联到的对象，速度很快；然后完成扫描，记录可达的对象；最后筛选出回收的对象，复制到老年代中。

#### Parallel（并行）
Parallel 是使用多线程实现的算法。它的优点是系统吞吐量比较高，缺点是每个工作线程都有内存的本地副本，可能导致内存占用过多。如果对象非常大，可能会导致额外开销。

#### CMS（并发标记清除）
CMS 是 Concurrent Mode Failure 的缩写。它是一种以获取最短回收时间为目标的垃圾回收器。整个过程包括四个阶段：初始标记、并发标记、重新标记、并发清除。

初始标记：初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快；
并发标记：此时 GC 启动了一个类似于「stop the world」的暂停阶段，所有应用线程被冻结，只有 GC 线程并发的工作，标记所有可达的对象；
重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的状态，这个阶段的任务就是再次进行并发标记；
并发清除：最后，并发清除会清理掉标记完毕的对象，释放他们占用的空间。虽然在这个阶段用户线程仍然处于停顿状态，但是其实已经没有多少消耗了。

#### G1（Garbage First）
G1 垃圾回收器是 JDK7 中提出的垃圾回收器，主要针对具有多个 Region（代）的内存布局设计的。如图1所示，G1 把堆内存分割为大小相同、数量级略大于年轻代的 Region。每个 Region 都可以按照自己的大小、比例自适应调节自己的堆大小。同时，G1 在后台维护了一个优先列表，根据 Region 的回收概率、可回收空间等综合信息决定回收哪些 Region。在回收期间用户线程不会感受到明显的卡顿。


### 老年代垃圾收集算法
老年代垃圾收集算法主要有标记-压缩、标记-清除、标记-整理三种。

#### 标记-压缩
标记-压缩算法也称为标记-移动算法。它与标记-清除算法类似，不过在回收结束后将存活的对象向内存空间起始位置移动，并且将移动后的对象的大小字段设为零，并将其在内存中的位置连同其后面未被覆盖的对象一起清理掉。这样做的目的是使得内存空间能够尽量被利用起来。

#### 标记-清除
标记-清除算法也称为计数标记-清除算法。它首先扫描堆中所有的对象，标记出存活的对象，然后再将所有死亡对象在内存中清除掉。这种算法最大的问题就是执行效率低下。当程序中对象较多或者运行时间较长时，这种算法可能会导致严重的性能问题。

#### 标记-整理
标记-整理算法也称为复制标记-清除算法。它与前两种算法的不同之处是，在回收完成后并不是直接清理掉死亡对象，而是将存活对象整理到一端，然后再让所有空间都是空闲的。通过这种方式，内存空间才能够得到有效的利用。

# 2.基本概念术语说明
## 对象
在 Java 中，对象指的是由类定义的数据结构实例。例如，假设有一个 Person 类，它定义了名、姓、年龄等属性。那么我可以通过以下方式创建一个 Person 对象：

Person p = new Person();

p 的值就是 Person 对象，其中包含了对应类的成员变量的值。Person 对象可以拥有任意数量的属性，这些属性可以是基本类型的值或是其他对象的引用。

## 引用
Java 中的引用就是变量用于指向某个对象的指针或句柄。在 Java 中，任何时候都只存在引用，而不是实际对象。引用指向某个特定的对象，而且它是确切地知道该对象在内存中的地址。引用一旦建立，就可以通过引用访问对象的方法和属性。

## 内存
在计算机中，内存是随机存储器。其内部是字节，每个字节都有一个唯一的编号，CPU 可以按顺序读取这些字节。

内存分为以下几个部分：

1. 静态内存：在程序编译时就已经分配好的内存，包括全局变量和静态变量。
2. 栈内存：存放局部变量、函数调用的参数、返回地址以及临时数据。每当一个函数被调用时，就分配一段新的栈内存。栈内存在函数调用结束时自动释放。
3. 堆内存：用于动态地创建对象，像 C++ 中的 malloc() 函数。程序员通过 new 操作符来申请堆内存。
4. 方法区（Non-Heap memory）：用于存放永久性的 class、method 数据、常量池以及动态生成的代码。

## 可达性分析
可达性分析（Reachability Analysis）是指通过一系列的引用关系，从某一根结点（称为 GC Roots）开始，判定哪些对象是可达的。通过可达性分析，可以判断哪些对象是可以被回收的。

在 JVM 里，GC Roots 有以下几种：

1. 虚拟机栈（Stack）中的引用对象。
2. 方法区中类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法接口（Native Method）中的引用对象。

可达性分析会根据上面的规则，从 GC Roots 开始，递归搜索引用链条上的对象。若一个对象到 GC Roots 的任何引用路径上都没找到，则认为该对象不可达，也就是说，该对象是可以被回收的。

# 3.核心算法原理和具体操作步骤以及数学公式讲解
## 堆内存
堆内存又称为运行时数据区（Runtime Data Area）、存储区或内存池，在 Java 中堆内存是由物理内存（RAM）中一块特殊的内存区域，用来存放对象的实例及其数据。堆内存除了用于存放对象以外，还提供对象创建和回收的功能，保证JVM中动态分配的内存均匀分布在堆内存中。堆内存由垃圾回收器管理。

堆内存分为新生代和老年代。新生代又称为 eden 区，老年代又称为 survivor 区。新生代的特点是每次分配较小的对象，生命周期较短，老年代的特点是生命周期较长的对象，在新生代中经历了minor GC，在老年代中经历了major GC。

堆内存的配置通常是根据堆中对象的预估大小来设置的。如果预估的对象太大，则可能导致新生代占满，而老年代却很小，导致频繁 Full GC。如果预估的对象太小，则可能导致内存浪费。因此，需要设置一个合理的初始堆内存大小，同时通过监控堆内存的使用情况，动态调整堆内存大小。

## 新生代垃圾回收算法
新生代垃圾回收算法主要有复制算法、标记-清除算法和标记-整理算法。

### 复制算法
复制算法是将内存分成两块相同的大小，每次只使用其中一块，当这一块的空间耗尽时，就将还存活的对象复制到另一块上面，并把当前的一块空间一次清理掉。这种算法的好处是简单易懂，缺点是需要对对象进行整理，使得内存碎片化。

### 标记-清除算法
标记-清除算法是简单粗暴的垃圾回收算法。它的基本思想是扫描所有正在使用的对象，标记出存活的对象，然后再将所有死亡对象在内存中清除掉。这种算法最大的问题就是执行效率低下。当程序中对象较多或者运行时间较长时，这种算法可能会导致严重的性能问题。

### 标记-整理算法
标记-整理算法与前两种算法的不同之处是，在回收完成后并不是直接清理掉死亡对象，而是将存活对象整理到一端，然后再让所有空间都是空闲的。通过这种方式，内存空间才能够得到有效的利用。

## 老年代垃圾回收算法
老年代垃圾回收算法主要有标记-压缩算法、标记-清除算法、标记-整理算法。

### 标记-压缩算法
标记-压缩算法也称为标记-移动算法。它与标记-清除算法类似，不过在回收结束后将存活的对象向内存空间起始位置移动，并且将移动后的对象的大小字段设为零，并将其在内存中的位置连同其后面未被覆盖的对象一起清理掉。这种算法的好处是不用移动对象，减少了内存碎片化，缺点是牺牲了一部分空间换取了时间，效率有待提高。

### 标记-清除算法
标记-清除算法也称为计数标记-清除算法。它首先扫描堆中所有的对象，标记出存活的对象，然后再将所有死亡对象在内存中清除掉。这种算法最大的问题就是执行效率低下。当程序中对象较多或者运行时间较长时，这种算法可能会导致严重的性能问题。

### 标记-整理算法
标记-整理算法也称为复制标记-清除算法。它与前两种算法的不同之处是，在回收完成后并不是直接清理掉死亡对象，而是将存活对象整理到一端，然后再让所有空间都是空闲的。通过这种方式，内存空间才能够得到有效的利用。

## 全自动垃圾回收器
基于分代收集理论，开发出了全自动垃圾回收器，可以使用不同的垃圾回收算法及回收策略。如图2所示，完整的垃圾回收流程可以分为五个步骤：

1. 初始标记：标记所有的 GC Roots 能直接关联到的对象。
2. 并发标记：进行并发标记，这个阶段中，应用程序线程和垃圾回收器线程一起工作，标记阶段会触发 STW （Stop The World）暂停，所以应用程序线程需要停止运行，等待垃圾回收器线程完成标记工作。
3. 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的状态，这个阶段的任务就是再次进行并发标记。
4. 并发清除：并发清除，这个阶段的任务是清理标记完毕的对象，释放他们占用的内存空间。并发清除不会导致应用程序的停顿，但会增加处理器的负载。
5. 并发重置：将堆中复用过的内存空间（空闲列表）归还给操作系统，方便后面程序使用。


# 4.具体代码实例和解释说明
## 代码实例1

```java
public void test() {
    byte[] bytes1 = new byte[1 * 1024 * 1024]; // 1MB
    System.out.println("Allocation completed");

    int sum = 0;
    for (int i = 0; i < Integer.MAX_VALUE / 1024; i++) {
        sum += i + sum * 2;
    }

    System.out.println(sum);

    byte[] bytes2 = new byte[2 * 1024 * 1024]; // 2MB
    System.out.println("Reallocated completed");

    // Dead object reference and allocation
    String str = "Test";
    str = null;
    Object obj = new Object();
}
```

执行结果：

```
Allocation completed
9223372036854775807
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at MainClass.test(MainClass.java:15)
	at MainClass.main(MainClass.java:8)
```

注：代码中分配了1MB和2MB的内存，运行一段时间后发生 OutOfMemoryError 错误，原因是堆内存过小，没有足够的空间容纳这两个对象。这段代码无意义，仅供演示堆内存分配。

## 代码实例2

```java
import java.util.*;

class HeapObj implements Comparable<HeapObj> {
  public int value;

  public HeapObj(int v) {
    this.value = v;
  }

  @Override
  public int compareTo(HeapObj o) {
    return this.value - o.value;
  }
}

public class GCExample {
  public static void main(String[] args) throws Exception{
    List<HeapObj> list = new ArrayList<>();

    while (true){
      list.add(new HeapObj((int)(Math.random()*10)));

      if (list.size() % 10 == 0) {
        System.out.printf("Size of list:%d\n", list.size());

        // Allocate more objects to trigger garbage collection
        allocateMoreObjects(list);
      }
    }
  }

  private static void allocateMoreObjects(List<HeapObj> list) throws InterruptedException {
    Thread.sleep(1000L);
    
    Random rand = new Random();
    int size = rand.nextInt(100) + 1;
    System.out.printf("\tAllocating %d more objects...\n", size);

    for (int i=0;i<size;i++){
      list.add(new HeapObj((int)(Math.random()*10)));
    }
  }
}
```

执行结果：

```
Size of list:10
		Allocating 4 more objects...
		Allocating 8 more objects...
Size of list:20
		Allocating 1 more objects...
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at GCExample.allocateMoreObjects(GCExample.java:22)
	at GCExample$1.run(GCExample.java:17)
	at java.base/java.lang.Thread.run(Thread.java:834)
```

这段代码模拟了堆内存溢出的场景。首先声明了一个 `HeapObj` 对象，并在循环中添加到列表中。每当列表中元素的个数等于 10 的倍数时，就执行 `allocateMoreObjects()` 方法，该方法随机分配一些 `HeapObj`，增大列表元素个数。

程序正常运行过程中，随着 `HeapObj` 的不断添加到列表中，列表的大小逐渐增大，直至列表中总共有超过 `-Xmx` 限制的对象时，程序抛出 OutOfMemoryError。

注：`-Xmx` 参数指定了 JVM 的最大堆内存，默认值为最大可用内存。当应用程序申请到内存超过这个限制时，JVM 会报 OOM 异常。