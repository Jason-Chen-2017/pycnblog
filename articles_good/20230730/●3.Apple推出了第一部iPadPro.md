
作者：禅与计算机程序设计艺术                    

# 1.简介
         
1月7日，Apple公司宣布推出了一款名为iPad Pro的超级本，在发布会上展示了它独特的高端显示屏、强大的性能、丰富的应用商店和一流的性能表现。
         2月9日，iPad Pro 升级版12.9寸发布，配备了A12 Bionic处理器、与最新MacBooks Pro配套的M1芯片等显著性能更新。此外，在刚刚过去的WWDC大会上，Apple还推出了Apple Watch Series 6。这些产品的出现标志着苹果终于成功地将自己的产品线变得前卫。
         自从WWDC大会上首次提及iPad Pro推出并展示后，就迅速占领了IT界的视野。从iPad Pro到Apple Watch系列产品，几乎每一个苹果新品都要充斥着数十亿美元的市场份额。然而，对于消费者来说，谁又能想到它会成为其生活中不可或缺的一部分呢？
         2019年7月，Google推出了Pixel 4和Pixel 4 XL，分别搭载Qualcomm的骁龙865和Adreno 640图形处理器，刷新了谷歌旗舰手机的市场占有率。与之不同的是，苹果在该产品系列上做出的贡献更加惊艳。据称，华尔街日报预计在明年上半年推出一款基于Arm处理器的旗舰智能手表Series 5，这也是Apple在手机市场取得重大突破的一个信号。而今年，苹果还推出了Apple Watch Series 6，为AppleWatch进入新时代的序曲。不仅如此，苹果还推出了一系列iPhone X系列新机型。
         1月7日的发布会上，Apple宣布了iPad Pro的独特超高端外观。这台笔记本电脑有着9英寸的超薄触摸屏，拥有5倍镜头和可折叠接口设计，将空间的利用效率提升到了极致。它的厚度为1.67英尺，重量为1.5吨，使用全金属设计，可以轻松清洗且防滑。它还配备了高端A12 Bionic处理器，在高性能计算、机器学习和图形处理等方面性能出众。与此同时，它也配备了4G通信和增强型雷达传感系统，完美满足消费者对游戏性能的需求。
         # 2.概念术语说明
         ## iPad Pro
         ### 定义
         iPad Pro 是Apple于2018年5月9日推出的一款超级本。与以往iPad的大小相比，Pro版本在尺寸、重量、性能上均进行了升级，采用12.9英寸的LCD、A12 Bionic处理器、支持5G Wi-Fi、增强型雷达传感系统，同时还配备了可折叠的设计、具有全金属支撑结构等功能。
         ### 优点
         1. 重量轻盈，厚度适中，防水防潮；
         2. 12.9英寸LCD屏幕，视网膜光学防眩光；
         3. A12 Bionic处理器，内置四核GPU和集成运动估计单元（IMU），性能极佳；
         4. 支持5G Wi-Fi，下载速度快捷、稳定性强；
         5. 有线连接采用Bluetooth 4.2或BTLE协议，支持无线双向互连；
         6. 多核CPU，支持多个App同时运行；
         7. 可拆卸式设计，方便随身携带；
         8. 按键较少，屏幕密度较高；
         9. USB-C接口，多种供电方式，适合长期使用。
         ### 缺点
         1. 价格昂贵，仅售1399美元起；
         2. 缺乏背光键盘，有些用户受限于眼睛疲劳；
         3. 没有辅助输入设备，无法直接控制手机、平板电脑等其他设备。
         ### 应用场景
         iPad Pro可作为个人电脑、工作站、办公室用途，适用于写作、创作、办公、视频制作、视听娱乐等多种需要快速反应和处理信息的应用场景。同时，iPad Pro也很适合学生、老年人阅读、学习、游戏、高性能计算、影像处理等高强度应用场景。
         ## Apple Watch Series 6
         ### 定义
         Apple Watch Series 6 是Apple于2019年7月22日推出的智能手表系列，最早起源于Apple Watch SE，2018年底将其升级为Apple Watch S6，2020年的第三个年度更新版本。全新的六项功能增强了手表的能力，包括Face ID登录、果冻定位、运动监测、手势解锁、定时提醒、Siri助手等。
         ### 主要功能
         * 指纹识别Face ID：实现秒级免密登录，同时具备人脸识别功能，保护隐私安全。
         * 果冻定位：提供高精准定位，帮助用户随时掌握当前位置。
         * 运动监测：为用户提供实时的健康跟踪、分析数据，助力运动目标管理。
         * 手势解锁：智能匹配用户经常使用的手势，让手表解锁更便捷。
         * 定时提醒：根据用户设定的时间，智能提醒用户交代任务、设置闹钟、提醒吃饭、约会等。
         * Siri助手：通过语音命令，访问应用、查看天气、查询联系人、发短信、打电话等。
         ### 使用场景
         * 健康追踪：通过果冻定位功能，及时掌握身体状况，运动监测功能，提供有效的运动指导和分析建议。
         * 投资规划：通过定时提醒和财务分析，帮助投资者安排收益管理，为股票策略提供更科学的建议。
         * 事务协同：通过Face ID登录、Siri助手功能，使人们在不同设备间完成任务更加方便，提升工作效率。
         # 3.核心算法原理和具体操作步骤以及数学公式讲解
         Apple历年来推出许多高端的新品牌产品，其基本的算法原理和具体操作步骤，还有复杂的数学公式都是值得我们好好研究学习的。
         在iPad Pro的发布会上，Apple就专门针对硬件产品进行了相关的技术细节讲解，主要是iPad Pro的CPU架构、图形渲染引擎、系统架构、网络协议栈等，通过这些技巧和知识，我们就可以对Apple推出的新产品有一个比较完整的认识。
         例如，iPad Pro采用了高通骁龙865芯片，这是一种高性能的芯片，它结合了NVIDIA Maxwell和ARM Mali GPU的能力，在图像处理、计算、机器学习等方面性能出色。当今移动互联网的普及和发展，尤其是在5G的通信、低延迟、高带宽等方面带来的巨大红利，都要求PC端的处理性能必不可少。所以，对于iPad Pro这样高端的产品，其GPU架构必然是至关重要的。
         1. 什么是GPU
         Graphics Processing Unit，即“显卡”的意思，它是一种计算能力很强的神奇机器，能运行图形、动画和游戏，是现代电脑的必备部件。但是，如果只是拿来跑游戏或者浏览网页的话，你肯定无法想象它的性能能够跟得上这个应用场景。实际上，GPU是一个复杂的芯片，它有很多的子组件组成，如指令集执行单元、缓存、状态调度、片段着色器、几何着色器、多媒体处理单元等，它们共同作用才能完成图形渲染。
        ![](https://upload-images.jianshu.io/upload_images/1777715-b9e906ecabfc6a7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
         上图是Intel显卡的架构示意图，其中红色部分为GPU组件。

         可以看到，显卡有很多个部件组成，其中最重要的就是指令集执行单元。它负责处理指令集，也就是图形渲染所需的大量的数学运算和逻辑判断。由此可见，GPU的计算能力在图形渲染等领域发挥着至关重要的作用。
         2. GPU架构进化
         从上世纪九十年代开始，显卡架构就一直沿袭着Intel架构，因为它过分简单、低延迟，且在处理计算密集型任务上性能良好。随着摩尔定律的失效，Intel越来越关注核心计算能力的提升，从Pentium4开始， Intel逐渐推出了基于ARM架构的处理器。ARM架构的优点是功耗低、散热好、尺寸小，并且支持嵌入式系统，因此在智能手机、平板电脑、穿戴设备等各类应用领域广泛应用。
        ![](https://upload-images.byteimg.com/micropub/uYPeJyNaxvQ9pytTpFy-pRWdPLprKMXhDdhw==/f022660d-3c72-49d5-82fe-fa3cfbbbced1.png?auto=compress&format=jpeg&width=600&height=400&fit=crop)
         在上图中，左侧的蓝色框表示目前主流的两种处理器架构，分别是x86架构和ARM架构，右侧的黑色框表示GPU架构演进历史，红色代表Intel、黄色代表AMD、绿色代表Nvidia，蓝色代表ARM。可以看到，从Pentium4开始，CPU架构和GPU架构才逐步统一，这项工程历时五十多年。
         3. 深度学习和神经网络
         机器学习、深度学习、神经网络是人工智能的三大领域，这两年非常火爆的AI应用也离不开这几个关键词。
         深度学习，也叫做深层神经网络，是一类应用于图像识别、语音识别、无人驾驶汽车等领域的机器学习技术。深度学习通过构建多层的神经网络模型来解决复杂的问题。由于复杂的关系网络结构，使得深度学习可以自动提取特征，并自动适应新的输入，从而改善系统性能。
         神经网络，由多个节点（或称“神经元”）组成，每个节点接收输入、传递信号，激活后产生输出。通过调整网络结构、优化参数、引入正则化、迭代训练，神经网络可以模拟出复杂的非线性关系，从而解决一些复杂的问题。
         通过数百万台服务器计算，以及超算中心集群的训练，深度学习技术已经成为当前AI领域的主流技术。
         # 4.具体代码实例和解释说明
         当我们对某个领域的技术知识掌握得足够扎实，就可以动手编写代码了，下面就以iPad Pro的设计方案为例，阐述其核心算法原理。
         为了优化iPad Pro的显示效果，其设计方案包含三个方面的改进：
         1. 变焦技术：相对于普通显示屏，iPad Pro的变焦功能可以让用户自由缩放屏幕分辨率，方便用户调整到最佳视野。
         2. 分屏模式：Apple在这次iPad Pro的升级版中加入了三种分屏模式：一画中知美、滑动预览、多任务分屏，用户可以根据自己的需求进行选择。
         3. 无边框显示屏：iPad Pro采用了硅胶材料，实现了无边框显示屏，既保证了功能性，又保留了iPad Pro的高端外观。
         下面我将用Swift语言描述一下如何实现iPad Pro的以上三个设计方案：
         ```swift
        // 1. 变焦技术
        let scale = UIScreen.main.scale // 获取当前屏幕缩放系数
        let size = viewController?.view.frame.size?? CGSize(width: UIScreen.main.bounds.size.width / scale, height:UIScreen.main.bounds.size.height / scale) // 获取屏幕的尺寸
        
        // 创建自定义View，用于显示变焦后的图片
        class ImageView: UIView {
            var image: UIImage?
            
            override func draw(_ rect: CGRect) {
                guard let image = self.image else { return }
                
                if UIScreen.main.scale!= 1 {
                    UIGraphicsBeginImageContextWithOptions(CGSize(width: image.size.width*UIScreen.main.scale, height: image.size.height*UIScreen.main.scale), false, 0.0)
                    
                    defer {
                        UIGraphicsEndImageContext()
                    }
                    
                    image.draw(in: CGRect(origin:.zero, size: image.size))
                        
                    let scaledImage = UIGraphicsGetImageFromCurrentImageContext()!
                    
                    context?.clear(rect)
                    
                    context?.saveGState()
                    context?.clip(to: bounds)
                    context?.scaleBy(x: UIScreen.main.scale, y: UIScreen.main.scale)
                    context?.translateBy(x: -image.size.width*(1-UIScreen.main.scale)/2, y:-image.size.height*(1-UIScreen.main.scale)/2)
                    context?.drawImage(scaledImage!.cgImage!, in: CGRect(origin:.zero, size: image.size*UIScreen.main.scale).insetBy(dx: -UIScreen.main.bounds.size.width/2 + (bounds.width-image.size.width*UIScreen.main.scale)/2, dy: -UIScreen.main.bounds.size.height/2+(bounds.height-image.size.height*UIScreen.main.scale)/2))
                    context?.restoreGState()
                } else {
                    context?.clear(rect)
                    image.draw(in: rect)
                }
            }
        }

        // 将ImageView添加到屏幕上
        let imageView = ImageView(frame: CGRect(origin:.zero, size: size))
        imageView.image = UIImage(named: "background") // 加载背景图片
        viewController?.view.addSubview(imageView)
        
        2. 分屏模式
        lazy var splitViewController: UISplitViewController = { [unowned self] in
            let splitVC = UIStoryboard(name: "Main", bundle: nil).instantiateViewController(withIdentifier: "SplitViewController") as! UISplitViewController
            splitVC.delegate = self
            return splitVC
        }()

        override func viewDidLoad() {
            super.viewDidLoad()
            view.backgroundColor =.white
            
            // 设置多任务模式
            if SplitScreenMode ==.threeDots {
                setupThreeDots()
            } else if SplitScreenMode ==.slideOver {
                setupSlideOver()
            } else {
                setupFullScreen()
            }
            
        }

        private enum SplitScreenMode {
            case threeDots
            case slideOver
            case fullScreen
        }
        
        private let threeDotsWidth: CGFloat = 54.0
        private let cornerRadius: CGFloat = 12.0

        fileprivate func setupThreeDots() {
            // 添加按钮栏
            let buttonBar = UIToolbar(frame: CGRect(origin: CGPoint(x: 0, y: 0), size: CGSize(width: view.bounds.width, height: threeDotsWidth)))
            buttonBar.barStyle =.black
            buttonBar.tintColor =.white
            buttonBar.isTranslucent = true

            // 添加3个按钮
            let centerButtonItem = UIBarButtonItem(barButtonSystemItem:.centerStack, target: nil, action: nil)
            let leftButtonItem = UIBarButtonItem(title: "", style:.plain, target: self, action:#selector(handleSlideToLeft))
            leftButtonItem.image = UIImage(systemName: "chevron.left")
            let rightButtonItem = UIBarButtonItem(title: "", style:.plain, target: self, action:#selector(handleSlideToRight))
            rightButtonItem.image = UIImage(systemName: "chevron.right")

            buttonBar.items = [leftButtonItem, centerButtonItem, rightButtonItem]
            view.insertSubview(buttonBar, at: 0)

            // 将主视图控制器添加到容器视图中
            childViewControllers[.primary].extendedLayoutIncludesOpaqueBars = false
            addChildViewController(childViewControllers[.primary])
            view.addSubview(childViewControllers[.primary].view)
            NSLayoutConstraint.activate([
                childViewControllers[.primary].view.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor, constant: 0),
                childViewControllers[.primary].view.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: twoDotsHeight+UIEdgeInsetsInsetRect(buttonBar.frame, view.safeAreaInsets).height),
                childViewControllers[.primary].view.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor, constant: 0),
                childViewControllers[.primary].view.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: 0)])
            backgroundColor =.lightGray

            handleDeviceOrientationChange()
        }

        @objc private func handleSlideToLeft() {
            switch mode {
            case.splitPrimary,.twoPanesHorizontal: break
            case.onePane(.left):
                setMode(.onePane(.center))
            case.onePane(.center):
                setMode(.onePane(.right))
            case.twoPanesVertical:
                previousPrimaryContentOffset = primaryContentViewFrame.origin.x
                setMode(.splitPrimary)
            }
        }

        @objc private func handleSlideToRight() {
            switch mode {
            case.splitPrimary,.twoPanesHorizontal: break
            case.onePane(.right):
                setMode(.onePane(.center))
            case.onePane(.center):
                setMode(.onePane(.left))
            case.twoPanesVertical:
                nextPrimaryContentOffset = max(previousPrimaryContentOffset, -(primaryContentViewFrame.origin.x+primaryContentViewFrame.size.width)-primaryContentViewMargin-margin)
                setMode(.splitPrimary)
            }
        }
        
        @objc public func toggleSlideover() {
            isEditingEnabled? setMode(.splitPrimary) : setMode(.slideOver)
        }
        
        
        private enum Mode {
            case onePane((direction))
            case twoPanesVertical
            case splitPrimary
            case slideOver
        }
        private var mode = Mode.twoPanesVertical
        private var previousPrimaryContentOffset: CGFloat = 0
        private var nextPrimaryContentOffset: CGFloat = 0
        
        private func setMode(_ newMode: Mode) {
            switch (newMode, mode) {
            case (.onePane(.left), _),
                 (.onePane(.center),.onePane(.center)),
                 (.onePane(.right),.onePane(.left)):
                break
                
            case (.onePane(.center),.onePane(.right)),
                 (.onePane(.center),.onePane(.left)):
                childViewControllers[.secondary].extendedLayoutIncludesOpaqueBars = false
                removeChildViewController(childViewControllers[.secondary])
                childViewControllers[.secondary].view.removeFromSuperview()

                mode = newMode
                
            case (_,.twoPanesVertical),
                 (.twoPanesVertical, _) where isEditingEnabled &&!self.isInCompactWidthRange():
                mode =.splitPrimary
                
            case (_,.twoPanesVertical),
                 (.twoPanesVertical, _):
                mode =.slideOver
                
            default:
                break
            }
        }
        
        private func isInCompactWidthRange() -> Bool {
            if UIScreen.main.traitCollection.horizontalSizeClass ==.compact || UIScreen.main.nativeBounds.size.width < compactWidthBound {
                return true
            }
            return false
        }

        
        private func updateViewControllerPositionsForTwoPanesVerticalMode() {
            primaryContentViewFrame.origin.x = margin + secondaryContentViewFrame.size.width
            primaryContentViewFrame.size.width -= secondaryContentViewFrame.size.width + primaryContentViewMargin
            secondaryContentViewFrame.origin.x += primaryContentViewFrame.size.width + primaryContentViewMargin
            self.layoutIfNeeded()
        }
        
        
        private lazy var panGestureRecognizer: UIPanGestureRecognizer = { [weak self] in
            let recognizer = UIPanGestureRecognizer()
            recognizer.target = self
            recognizer.action = #selector(pan(sender:))
            return recognizer
        }()
        
        private func layoutViewsForOnePaneHorizontalMode() {
            secondaryContentViewFrame.origin.y = margin + primaryContentViewFrame.size.height
            secondaryContentViewFrame.size.height -= primaryContentViewFrame.size.height + primaryContentViewMargin
            primaryContentViewFrame.origin.x += secondaryContentViewFrame.size.width + primaryContentViewMargin
            self.layoutIfNeeded()
        }
        
        private func layoutViewsForTwoPanesHorizontalMode() {
            primaryContentViewFrame.size.width /= 2
            secondaryContentViewFrame.size.width /= 2
            primaryContentViewFrame.origin.x += margin + primaryContentViewMargin
            secondaryContentViewFrame.origin.x = primaryContentViewFrame.origin.x + primaryContentViewFrame.size.width + primaryContentViewMargin
            primaryContentViewFrame.origin.y += margin + primaryContentViewMargin
            secondaryContentViewFrame.origin.y = primaryContentViewFrame.origin.y + primaryContentViewFrame.size.height + primaryContentViewMargin
            self.layoutIfNeeded()
        }
        
        private func layoutViewsForSplitPrimaryMode() {
            primaryContentViewFrame.origin.x = nextPrimaryContentOffset
            primaryContentViewFrame.origin.y = margin
            primaryContentViewFrame.size.width = primaryContentViewFrame.size.width <= margin? min(primaryContentViewFrame.size.width, UIScreen.main.bounds.size.width-(margin*2))/2 : min(primaryContentViewFrame.size.width, primaryContentViewFrame.size.width/2)-(margin*2)
            primaryContentViewFrame.size.height -= margin*2
            secondaryContentViewFrame.origin.x = primaryContentViewFrame.origin.x + primaryContentViewFrame.size.width + primaryContentViewMargin
            secondaryContentViewFrame.origin.y = margin + primaryContentViewFrame.size.height
            secondaryContentViewFrame.size.width = secondScaleContentViewFrame.size.width
            secondaryContentViewFrame.size.height -= margin*2
            
            scrollView.contentSize = CGSize(width: primaryContentViewFrame.size.width + margin*2 + secondScaleContentViewFrame.size.width, height: max(primaryContentViewFrame.size.height, secondScaleContentViewFrame.size.height))
            scrollView.frame = contentViewFrame
            secondScaleScrollView.frame = firstScaleContentViewFrame
            scrollView.bounces = false
            
            refreshControl?.scrollIndicatorInsets = UIEdgeInsetsZero
        }
        
        private func adjustScrollableArea() {
            primaryScrollView.maximumZoomScale = max(minimumZoomScale, minimumZoomScale+self.zoomLevel/(maxZoomedOutScale-minZoomedOutScale)*abs(maxZoomedOutScale-minZoomedOutScale))
            secondaryScrollView.maximumZoomScale = max(minimumZoomScale, minimumZoomScale+self.zoomLevel/(maxZoomedOutScale-minZoomedOutScale)*abs(maxZoomedOutScale-minZoomedOutScale))
            
            prevMaximumZoomScale = maximumZoomScale
            
            zoomScale = clampedZoomScale
            primaryContentViewFrame.size.width *= zoomScale
            primaryContentViewFrame.size.height *= zoomScale
            secondaryContentViewFrame.size.width *= zoomScale
            secondaryContentViewFrame.size.height *= zoomScale
            
            layoutViewsForSplitPrimaryMode()
            fadeViewsForSplitPrimaryMode()
            refreshControl?.endRefreshing()
            
            calculateSizesForStatusBarAndContentViewFrames()
            handleDeviceRotation()
        }
        
        
        // 模拟滑动切换视图
        func pan(sender: UIPanGestureRecognizer) {
            if sender.state ==.began {
                oldCenterX = view.center.x
            } else if sender.state ==.changed {
                moveDistanceX = sender.translation(in: view).x
                
                if abs(moveDistanceX) > swipeThreshold {
                    shouldHideControlsAfterDragStop = true
                    modeBeforeDrag = mode
                    setMode(.slideOver)
                    showControlsAnimated(false)
                }
                
                if fabs(moveDistanceX) >= fabs(oldMoveDistanceX) {
                    lastDirectionX = directionX
                    moveDistanceX = moveDistanceX * smoothnessFactor
                }
                
                var transformTranslation = TransformTranslation.identity
                
                if lastDirectionX ==.center {
                    if fabs(moveDistanceX) > 1 {
                        lastDirectionX = sign(moveDistanceX)
                        
                        transformTranslation = TransformTranslation(-sign(moveDistanceX)*(fabs(moveDistanceX)+biasValue)*min(fabs(moveDistanceX)/threshold, thresholdValue), 0.0)

                        animateViewsForModeTransition(transformTranslation)
                    }
                } else {
                    if lastDirectionX!= sign(moveDistanceX) {
                        lastDirectionX = sign(moveDistanceX)
                            
                        transformTranslation = TransformTranslation(lastDirectionX*biasValue, 0.0)

                        animateViewsForModeTransition(transformTranslation)
                    }

                    translationX = 0
                }
                
                movementFraction = fabs(moveDistanceX)/(fabs(moveDistanceX)+biasValue)*1.2
                
                performTransformationsWithProgress(movementFraction)
                
                oldMoveDistanceX = moveDistanceX
                
                handleScrolling()
                
                resetBackgroundAndShadowViews(shouldShowOrHideBackgroundViews())
            } else if sender.state ==.ended {
                userInteracted = true
                
                if shouldAnimateBackToPreviousMode {
                    hideControlsAnimated(!userInteractionEnabled, completion:{
                        if animationDuration > 0 {
                            UIView.animate(withDuration: animationDuration, animations: {
                                self.mode = self.modeBeforeDrag
                                self.performTransformationsWithProgress(0.0)
                                
                                self.shouldHideControlsAfterDragStop = false

                                self.hideViewsForSplitPrimaryMode()
                                self.fadeViewsForSplitPrimaryMode()
                            }, completion: completionHandler)
                        } else {
                            self.mode = self.modeBeforeDrag
                            self.performTransformationsWithProgress(0.0)
                            
                            self.shouldHideControlsAfterDragStop = false

                            self.hideViewsForSplitPrimaryMode()
                            self.fadeViewsForSplitPrimaryMode()
                            completionHandler?(true)
                        }
                    })
                } else {
                    hideControlsAnimated(!userInteractionEnabled) { [weak self] (_) in
                        if fabs(moveDistanceX) > biasValue {
                            self?.showCustomizedTextView()
                        } else {
                            self?.hideCustomizedTextView()
                        }
                    }
                }
                
                userInteracted = false
            }
        }
        
        @objc public func performTransformationsWithProgress(_ progress: CGFloat) {
            applyViewTransform(progress, duration: mode ==.twoPanesVertical? transitionDuration : 0)
        }
        
        private func calculateSizesForStatusBarAndContentViewFrames() {
            statusBarFrame = CGRect(x: 0, y: 0, width: view.bounds.width, height: safeAreaInsets.top)
            
            contentViewFrame = CGRect(x: 0, y: statusBarFrame.height, width: view.bounds.width, height: view.bounds.height-statusBarFrame.height)
            
            firstScaleContentViewFrame = contentViewFrame
            firstScaleContentViewFrame.size.height -= 20
            firstScaleContentViewFrame.origin.y += statusBarFrame.height
            
            secondScaleContentViewFrame = CGRect(x: 0, y: 0, width: view.bounds.width, height: (firstScaleContentViewFrame.size.height-margin)/2+margin)
            secondScaleContentViewFrame.origin.y += margin
            secondScaleContentViewFrame.size.height -= margin*2
        }
        
        private func handleScrolling() {
            if dragAttempting {
                dragGestureRecognizedInThisSession = true
            } else if swipedOpenOrClosed {
                setUserInteractionEnabled(true)
                dragAttempting = false
                swipedOpenOrClosed = false
            } else if movementFraction!= 0 {
                primaryScrollView.setContentOffset(CGPoint(x: primaryScrollView.contentOffset.x-movementFraction*(primaryScrollView.frame.size.width-primaryContentViewFrame.size.width)/2, y: primaryScrollView.contentOffset.y), animated: false)
            }
        }
        
         3. 无边框显示屏
        无边框显示屏是一个颇具争议的概念，很多厂商虽然声称采用无缝边框的LCD显示屏，但在物理结构上仍然存在一些缺陷，导致屏幕质量不佳。
        此次苹果推出iPad Pro，它的LCD屏幕采用了新一代LED光学反射技术，虽然看起来更加光滑，但是却并没有完全消除。而且，苹果也声称为了避免屏幕出现像素变形，采用了高像素密度、高对比度的技术。
        那么，究竟采用何种技术，最终是否真的会真正解决像素变形问题呢？
        为了验证这个疑问，我们首先来看一下苹果在iPad Pro的LCD屏幕上的显示效果：
       ![](https://upload-images.jianshu.io/upload_images/1777715-c97ba38e995bf503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
        从图中可以看出，iPad Pro的LCD显示屏的左右两边分别是以黑、蓝、灰、橙、黄等颜色的LED灯条作为基底，然后在上面绘制了镀锌玻璃、锂电池等各类模拟材料，但这并不能解决像素变形的问题。
        如果要真正解决像素变形的问题，就只能依赖更先进的无缝边框技术，比如微边缘平滑显示等，但由于这些技术仍处于积极开发阶段，暂时还没有得到广泛应用。

