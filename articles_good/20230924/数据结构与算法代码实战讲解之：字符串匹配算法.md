
作者：禅与计算机程序设计艺术                    

# 1.简介
  

字符串匹配（String Matching）问题是计算机科学领域中一个重要且基本的问题，其一般形式可以定义为：给定一个模式串P和一个主串T，找出所有在T中出现的P的下一次出现位置（next occurrence）。
如：给定字符串"AABAACAADAABAAAC",子串"AAA"的下一次出现位置为4，7，10，分别对应于第四个、第七个、第十个字符。
传统解决此类问题的方法主要有三种：暴力匹配法、KMP算法和Aho-Corasick算法。下面将详细介绍这三个算法并用python语言实现。
# 2.基本概念及术语说明
## 1.1 字符串匹配算法
字符串匹配算法（string matching algorithm）是查找两个或多个字符串文本中是否含有相同或相似模式的过程。它属于信息检索和数据压缩领域的一种基础算法。字符串匹配算法被广泛应用于文本编辑器、文件搜索引擎、序列分析等方面。
## 1.2 KMP算法
KMP算法（Knuth-Morris-Pratt algorithm），由D.E.Knuth、J.H.Morris和L.R.Pratt三人于1977年提出。KMP算法是一种改进的Boyer-Moore算法，其特点是不回溯已匹配过的字符，从而避免了回溯造成的时间开销。
## 2.1 Boyer-Moore算法
Boyer-Moore算法，又称后文预测算法，是著名的字符串匹配算法。它的基本思路是维护好坏位移表（good suffix shift table）和坏字符规则表（bad character rule table）。后文预测算法能够处理掉某些“坏字符”的影响，从而保证匹配正确率。
## 2.2 Aho-Corasick算法
Aho-Corasick算法是一个多模态字符串匹配算法。它构造了一个多叉树，每个节点代表着前缀的状态转移过程。当需要进行匹配时，算法利用该多叉树对文本串逐个字符地扫描，并同时记录各个字符串出现的位置。
# 3.核心算法原理及具体操作步骤
## 1. 暴力匹配法
暴力匹配法即枚举所有的子串位置，判断是否与目标串相同。该方法的时间复杂度为O(nm)，n为待匹配串的长度，m为子串的长度，所以效率非常低下。
```python
def brute_force(s, t):
    m = len(t)
    n = len(s)
    for i in range(n - m + 1):
        if s[i:i+m] == t:
            return True
    return False
```

## 2. KMP算法
KMP算法是改进的Boyer-Moore算法，其特点是不回溯已匹配过的字符，从而避免了回溯造成的时间开销。KMP算法的关键在于构造失配函数，该函数在遇到失配时，能够知道在当前位置之前已经匹配过多少字符，直接跳过这些字符，从而避免回溯。
### （1）失配函数的构造
失配函数pi[k]表示模式串p0...pk中最后k个字符在主串中的最长共同前后缀的长度。其中pi[0]=0, pi[k]的值可以通过计算得到。
计算pi[k]值的过程如下：
1. j=pi[k-1]
2. while (j>0 and p[j]!= p[k]):
      j=pi[j-1]
3. 如果j=0 or p[j] == p[k]:
   pi[k]=j+1   #因为j始终指向pi[j-1]对应的最长公共前缀，因此这里要加1.

### （2）主串匹配算法
KMP算法的主串匹配算法的基本思想是通过计算失配函数pi[]确定当前位置匹配失败时的下一步移动方向。如果主串的第i个字符恰好与模式串的第j个字符匹配，则i++,j++；否则如果pi[j]>0，说明模式串已经匹配了一部分，那么就令i+=pi[j]-1，也就是回退pi[j]-1步。直至其中任一值小于0或者i>=n。

```python
def kmp_match(s, t):
    m = len(t)
    n = len(s)
    pi = compute_prefix(t)    # 计算失配函数
    i = 0       # 当前主串指针
    j = 0       # 模式串指针
    while i < n:
        if s[i] == t[j]:      # 如果匹配成功，指针向后移
            i += 1
            j += 1
        elif pi[j] > 0:       # 如果失配，根据失配值计算下一步移动方向
            j = pi[j]        # j更新为当前位置最大的失配值，这样可以避免回溯
        else:                  # 如果没找到匹配的字符，整个模式串都匹配失败
            break
    
    if j >= m:                 # 判断是否完全匹配
        return i - m           # 返回匹配位置
    else:                      # 不匹配返回-1
        return -1


def compute_prefix(pattern):     # 计算失配函数
    m = len(pattern)           
    prefix = [0] * m            
    j = 0                       
    for i in range(1, m): 
        while j > 0 and pattern[j]!= pattern[i]:
            j = prefix[j-1]   # 更新失配值
        if pattern[j] == pattern[i]:
            j += 1
        prefix[i] = j          # 计算失配值
    return prefix
```

## 3. Aho-Corasick算法
Aho-Corasick算法是一种多模态字符串匹配算法。它构造了一个多叉树，每个节点代表着前缀的状态转移过程。当需要进行匹配时，算法利用该多叉树对文本串逐个字符地扫描，并同时记录各个字符串出现的位置。
### （1）构建多叉树
Aho-Corasick算法首先构建一个多叉树，每个节点代表着前缀的状态转移过程。对于输入的N个模式串Pi，建立一个长度为N的数组边集合E。节点vi的数据结构包括三个字段：char c；list next；int fail；其中c是一个字符，用于标识该节点的字符，next是一个列表，用于存储该节点的所有子节点，fail是一个整数，用来指向该节点的失败点。
初始状态的root节点没有字符c，next数组存储的是与该节点对应的模式串。接下来，算法会从模式串Pi[0]开始建立起多叉树，并使用队列Q初始化，放入root节点。然后循环读取队列Q，对于队列中的每个节点u，将Pi[u.c+1]中的字符作为键，在多叉树中匹配Pi[u.c+1][0]，若存在该匹配节点v，则建立边（u，v）。若不存在，则在多叉树中创建新节点，并将新节点与u连接。若Pi[u.c+1]匹配结束，则置节点u.fail为空，否则将节点u.fail指向Pi[u.c+1][0]的匹配节点。
### （2）多模态字符串匹配
在多模态字符串匹配过程中，主串S会被分割成多个串Si，其中每个Si都可能匹配某个模式串Pi。为了快速匹配，Aho-Corasick算法构造了一个边集数组E，用于存储已匹配的字符串和相应的模式串。算法首先遍历主串S，逐个字符地扫描，并尝试在多叉树上匹配。假设节点u处于状态pi的位置，Pi是第一个匹配上的模式串，若存在模式串Pi'后面紧跟的Si'，并且该Si'的模式串是已匹配过的模式串的后缀，则将边（u，Pi）加入边集数组E，并继续扫描。
如果无法在多叉树上匹配Pi，则试图扩展模式串Pi。在算法中，我们把扩展一个已匹配上的模式串 Pi 为Pi’ 的过程称为边界停机（boundary stop）。边界停机就是指停止在某个节点的路径上，重新开始搜索另一条路径，也就是说，回溯到最初的匹配点之前的一个节点，再重新开始向右扫描。这个动作的目的是找到另一条可以匹配的路径，从而让算法能够处理那些匹配失败的情况。具体做法是在边界停机前后，都记住一个匹配到的最末端的节点 u ，并把它作为 root 开始新的搜索。具体算法如下：

1. 初始化边集数组 E 和 root ，root 指向多叉树的根节点，同时创建一个空栈 Q 。
2. 从 S 的首字母开始，在多叉树中搜索，每读入一个新的字符，就按照以下方式进行处理：
     a. 根据最新读入的字符 c ，在多叉树中匹配，若存在匹配节点 v ，则检查边（u，v）是否已经在边集数组 E 中，若不是，则把边（u，v）加入边集数组 E 并推入栈 Q ，并且 root 指向 v ，u 作为 u 之前的匹配点。
     b. 否则，如果栈非空，则边集数组 E 中的边（u，v_old）便是边界停机后的最后一条匹配路径。需要把 E 中边 (u,v_old) 删除，然后从栈中弹出一个节点 u_new 出来，并把 u_new 设置为栈顶节点，并重复第 2b 步。
     c. 如果栈为空，则说明该字符不能匹配任何已匹配上的模式串，算法结束。
3. 当所有字符都读入完毕，则算法结束。边集数组 E 中保存的是所有的已匹配的字符串及其相关模式串。

```python
from collections import defaultdict
 
class TrieNode:
    def __init__(self, char=''):
        self.char = char
        self.children = defaultdict()
        self.failure = None
        self.output = set()
        
    
def build_trie(patterns):
    root = TrieNode()
    for i, pattern in enumerate(patterns):
        current = root
        for j, char in enumerate(pattern):
            child = current.children.get(char)
            if not child:
                new_node = TrieNode(char)
                current.children[char] = new_node
                current = new_node
            else:
                current = child
                
            if j == len(pattern)-1:
                current.output.add(i)
                    
    queue = [(root, '')]
    while queue:
        node, path = queue.pop(0)
        
        if node.output:
            node.output.update([index+len(path) for index in patterns])
            
        failure = node.failure
        while failure is not None:
            try:
                edge = failure.children[node.char]
                break
            except KeyError:
                failure = failure.failure
        
        node.failure = failure if failure is not None else root
        
        children = sorted(node.children.items())
        for char, child in children[:-1]:
            queue.append((child, ''.join([path, char])))
            
        last_char, last_node = children[-1]
        node.last_char = last_char
        node.last_node = last_node
        
    return root


def ac_search(text, trie):
    output = []
    current = trie
    stack = []

    for i, char in enumerate(text):
        while current is not None and char not in current.children:
            current = current.failure

        if current is None:
            current = trie
        
        node = current.children.get(char)
        
        while node is not None and len(node.output) > 0:
            indexes = list(node.output)
            
            start = max(current.start, i - len(current.char))
            end = i+1
            match = text[start:end]
            
            for index in indexes:
                output.append((index, start, end, match))

            if node.last_char is not None:
                stack.append((current, match, i+1))
                current = node.last_node
            else:
                del stack[:]
                current = trie
        
        current = node
        
    return output
```