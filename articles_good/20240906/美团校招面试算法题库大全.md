                 

### 《2025美团校招面试算法题库大全》

#### 目录

1. [并查集问题](#并查集问题)
2. [数组问题](#数组问题)
3. [二叉树问题](#二叉树问题)
4. [图论问题](#图论问题)
5. [字符串问题](#字符串问题)
6. [动态规划问题](#动态规划问题)
7. [回溯算法问题](#回溯算法问题)
8. [贪心算法问题](#贪心算法问题)
9. [排序算法问题](#排序算法问题)

---

#### 1. 并查集问题

##### **题目**：给定一个无向图，求图中的连通分量个数。

**题目描述**：给定一个无向图，求图中的连通分量个数。

**解题思路**：使用并查集算法求解。

**代码示例**：

```go
package main

import "fmt"

type UnionFind struct {
    parent []int
    size   []int
}

func (uf *UnionFind) init(n int) {
    uf.parent = make([]int, n)
    uf.size = make([]int, n)
    for i := range uf.parent {
        uf.parent[i] = i
        uf.size[i] = 1
    }
}

func (uf *UnionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) union(x, y int) {
    rootX := uf.find(x)
    rootY := uf.find(y)
    if rootX != rootY {
        if uf.size[rootX] > uf.size[rootY] {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        } else {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        }
    }
}

func countComponents(n int, edges [][]int) int {
    uf := &UnionFind{}
    uf.init(n)
    for _, edge := range edges {
        uf.union(edge[0], edge[1])
    }
    return len(set uf.size)
}

func main() {
    n := 5
    edges := [][]int{{0, 1}, {1, 2}, {3, 4}}
    fmt.Println(countComponents(n, edges)) // 输出 2
}
```

---

#### 2. 数组问题

##### **题目**：给定一个整数数组，找出所有重复的数。

**题目描述**：给定一个整数数组，找出所有重复的数。

**解题思路**：使用哈希表记录每个数的出现次数，然后遍历哈希表找出重复的数。

**代码示例**：

```go
package main

import "fmt"

func findDuplicates(nums []int) []int {
    counts := make(map[int]int)
    duplicates := make([]int, 0)
    for _, num := range nums {
        counts[num]++
        if counts[num] > 1 {
            duplicates = append(duplicates, num)
        }
    }
    return duplicates
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 2, 4, 6}
    fmt.Println(findDuplicates(nums)) // 输出 [2 4]
}
```

---

#### 3. 二叉树问题

##### **题目**：给定一个二叉树，求其节点之和。

**题目描述**：给定一个二叉树，求其节点之和。

**解题思路**：使用递归遍历二叉树，计算节点之和。

**代码示例**：

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func sumRootToLeaf(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return root.Val + sumRootToLeaf(root.Left) + sumRootToLeaf(root.Right)
}

func main() {
    root := &TreeNode{
        Val:   1,
        Left:  &TreeNode{Val: 2},
        Right: &TreeNode{Val: 3},
    }
    fmt.Println(sumRootToLeaf(root)) // 输出 7
}
```

---

#### 4. 图论问题

##### **题目**：给定一个加权无向图，求最短路径。

**题目描述**：给定一个加权无向图，求图中所有顶点之间的最短路径。

**解题思路**：使用 Dijkstra 算法求解。

**代码示例**：

```go
package main

import (
    "fmt"
    "math"
)

func min(a, b float64) float64 {
    if a < b {
        return a
    }
    return b
}

func dijkstra(edges [][]int, n int) []float64 {
    dist := make([]float64, n)
    for i := range dist {
        dist[i] = math.MaxFloat64
    }
    dist[0] = 0

    visited := make([]bool, n)
    for i := 0; i < n; i++ {
        u := -1
        for j := 0; j < n; j++ {
            if !visited[j] && (u == -1 || dist[j] < dist[u]) {
                u = j
            }
        }
        visited[u] = true

        for _, edge := range edges[u] {
            v, w := edge[0], edge[1]
            dist[v] = min(dist[v], dist[u]+w)
        }
    }

    return dist
}

func main() {
    edges := [][]int{
        {0, 1, 2},
        {0, 2, 3},
        {1, 2, 1},
        {1, 3, 4},
        {2, 3, 2},
    }
    n := 4
    fmt.Println(dijkstra(edges, n)) // 输出 [0 2 3 6]
}
```

---

#### 5. 字符串问题

##### **题目**：给定一个字符串，求最长公共前缀。

**题目描述**：给定一个字符串数组，求其中最长公共前缀。

**解题思路**：从第一个字符串开始，依次与前一个字符串比较，找出最长公共前缀。

**代码示例**：

```go
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
        }
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs)) // 输出 "fl"
}
```

---

#### 6. 动态规划问题

##### **题目**：给定一个整数数组，求最长递增子序列的长度。

**题目描述**：给定一个整数数组，求最长递增子序列的长度。

**解题思路**：使用动态规划求解。

**代码示例**：

```go
package main

import "fmt"

func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = 1
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    fmt.Println(lengthOfLIS(nums)) // 输出 4
}
```

---

#### 7. 回溯算法问题

##### **题目**：给定一个字符串，求出所有有效的括号序列。

**题目描述**：给定一个字符串，求出所有有效的括号序列。

**解题思路**：使用回溯算法求解。

**代码示例**：

```go
package main

import "fmt"

var ans []string

func generateParenthesis(n int) []string {
    ans = []string{}
    dfs(n, 0, 0)
    return ans
}

func dfs(n, left, right int) {
    if left == n && right == n {
        ans = append(ans, "("+strings.Join(ans[:len(ans)-1], "")+")")
        return
    }
    if left < n {
        dfs(n, left+1, right)
    }
    if right < left {
        dfs(n, left, right+1)
    }
}

func main() {
    n := 3
    fmt.Println(generateParenthesis(n)) // 输出 ["((()))", "(()())", "(())()", "()(())", "()()()"]
}
```

---

#### 8. 贪心算法问题

##### **题目**：给定一个数组，求其中最小覆盖子数组的长度。

**题目描述**：给定一个数组，求其中最小覆盖子数组的长度。

**解题思路**：使用贪心算法求解。

**代码示例**：

```go
package main

import (
    "fmt"
    "sort"
)

func minWindow(s string, t string) string {
    m, n := len(s), len(t)
    if m < n {
        return ""
    }
    count := make([]int, 26)
    for _, ch := range t {
        count[ch-'A']++
    }
    left, right := 0, 0
    ans := -1
    for right < m {
        if count[s[right]-'A'] > 0 {
            count[s[right]-'A']--
        }
        for left <= right && isCovered(count) {
            if right-left+1 < n || ans == -1 {
                ans = right - left + 1
            }
            if count[s[left]-'A'] > 0 {
                count[s[left]-'A']++
            }
            left++
        }
        right++
    }
    if ans == -1 {
        return ""
    }
    return s[left : left+ans]
}

func isCovered(count []int) bool {
    for _, v := range count {
        if v > 0 {
            return false
        }
    }
    return true
}

func main() {
    s := "ADOBECODEBEEF"
    t := "ABC"
    fmt.Println(minWindow(s, t)) // 输出 "ABC"
}
```

---

以上便是《2025美团校招面试算法题库大全》中的典型问题及答案解析。希望对准备校招的你有所帮助！如需更多面试题及答案解析，请关注我们的公众号「算法小机灵」。祝你好运！


