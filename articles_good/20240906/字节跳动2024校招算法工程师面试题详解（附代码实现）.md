                 

### 字节跳动2024校招算法工程师面试题详解（附代码实现）

#### 目录

1. [排序算法](#排序算法)
   1.1 [快速排序](#快速排序)
   1.2 [归并排序](#归并排序)
   1.3 [冒泡排序](#冒泡排序)
   1.4 [选择排序](#选择排序)
   1.5 [插入排序](#插入排序)
2. [查找算法](#查找算法)
   2.1 [二分查找](#二分查找)
   2.2 [哈希查找](#哈希查找)
   2.3 [布隆过滤器](#布隆过滤器)
3. [动态规划](#动态规划)
   3.1 [斐波那契数列](#斐波那契数列)
   3.2 [最长公共子序列](#最长公共子序列)
   3.3 [最长公共子串](#最长公共子串)
4. [图算法](#图算法)
   4.1 [深度优先搜索](#深度优先搜索)
   4.2 [广度优先搜索](#广度优先搜索)
   4.3 [拓扑排序](#拓扑排序)
   4.4 [最小生成树](#最小生成树)
5. [字符串处理](#字符串处理)
   5.1 [最长公共前缀](#最长公共前缀)
   5.2 [最长回文子串](#最长回文子串)
   5.3 [字符串匹配](#字符串匹配)
6. [数据结构](#数据结构)
   6.1 [链表](#链表)
   6.2 [堆](#堆)
   6.3 [树](#树)

#### 1. 排序算法

##### 1.1 快速排序

**题目：** 实现快速排序算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func quickSort(arr []int) {
	if len(arr) <= 1 {
		return
	}
	pivot := arr[len(arr)-1]
	left, right := 0, 0

	for i := 0; i < len(arr)-1; i++ {
		if arr[i] < pivot {
			arr[left], arr[i] = arr[i], arr[left]
			left++
		} else {
			right++
		}
	}
	arr[left], arr[len(arr)-1] = arr[len(arr)-1], arr[left]

	quickSort(arr[:left])
	quickSort(arr[left+1:])
}

func main() {
	arr := []int{3, 6, 8, 10, 1, 2, 1}
	quickSort(arr)
	fmt.Println(arr)
}
```

**解析：** 快速排序采用分治法的一个典例。本质上采用了递归算法，将一个大数组分为两个小数组，然后分别对这两个小数组进行快速排序，最终将两个有序小数组合并成一个有序大数组。时间复杂度为 \(O(n\log n)\)。

##### 1.2 归并排序

**题目：** 实现归并排序算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func mergeSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}
	mid := len(arr) / 2
	left := mergeSort(arr[:mid])
	right := mergeSort(arr[mid:])
	return merge(left, right)
}

func merge(left, right []int) []int {
	res := []int{}
	for len(left) > 0 || len(right) > 0 {
		if len(left) == 0 {
			res = append(res, right...)
			break
		}
		if len(right) == 0 {
			res = append(res, left...)
			break
		}
		if left[0] < right[0] {
			res = append(res, left[0])
			left = left[1:]
		} else {
			res = append(res, right[0])
			right = right[1:]
		}
	}
	return res
}

func main() {
	arr := []int{3, 6, 8, 10, 1, 2, 1}
	sorted := mergeSort(arr)
	fmt.Println(sorted)
}
```

**解析：** 归并排序采用分治法的一个典例，将已有序的子序列合并，得到完全有序的序列。时间复杂度为 \(O(n\log n)\)。

##### 1.3 冒泡排序

**题目：** 实现冒泡排序算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func bubbleSort(arr []int) {
	n := len(arr)
	for i := 0; i < n; i++ {
		for j := 0; j < n-i-1; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}

func main() {
	arr := []int{3, 6, 8, 10, 1, 2, 1}
	bubbleSort(arr)
	fmt.Println(arr)
}
```

**解析：** 冒泡排序通过重复遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。时间复杂度为 \(O(n^2)\)。

##### 1.4 选择排序

**题目：** 实现选择排序算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func selectionSort(arr []int) {
	n := len(arr)
	for i := 0; i < n; i++ {
		minIndex := i
		for j := i + 1; j < n; j++ {
			if arr[j] < arr[minIndex] {
				minIndex = j
			}
		}
		arr[i], arr[minIndex] = arr[minIndex], arr[i]
	}
}

func main() {
	arr := []int{3, 6, 8, 10, 1, 2, 1}
	selectionSort(arr)
	fmt.Println(arr)
}
```

**解析：** 选择排序是一种简单直观的排序算法。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。时间复杂度为 \(O(n^2)\)。

##### 1.5 插入排序

**题目：** 实现插入排序算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func insertionSort(arr []int) {
	n := len(arr)
	for i := 1; i < n; i++ {
		key := arr[i]
		j := i - 1
		for j >= 0 && arr[j] > key {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = key
	}
}

func main() {
	arr := []int{3, 6, 8, 10, 1, 2, 1}
	insertionSort(arr)
	fmt.Println(arr)
}
```

**解析：** 插入排序是一种简单的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。时间复杂度为 \(O(n^2)\)。

#### 2. 查找算法

##### 2.1 二分查找

**题目：** 实现二分查找算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func binarySearch(arr []int, target int) int {
	left, right := 0, len(arr)-1
	for left <= right {
		mid := (left + right) / 2
		if arr[mid] == target {
			return mid
		} else if arr[mid] < target {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}

func main() {
	arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	target := 5
	index := binarySearch(arr, target)
	if index != -1 {
		fmt.Printf("元素%d在数组中的索引为：%d\n", target, index)
	} else {
		fmt.Printf("元素%d不在数组中\n", target)
	}
}
```

**解析：** 二分查找法只适用于顺序存储的有序表，其基本方法是：首先确定表的中间位置m，将待查找的K与a[m]比较，若相等则查找成功，否则需确定下一步的查找区间。若K<a[m]，则接下来要查找的子表为左子表a[1..m-1]，否则为右子表a[m+1..n]。通过这种方法，可以缩小查找范围，从而达到快速查找的目的。时间复杂度为 \(O(\log n)\)。

##### 2.2 哈希查找

**题目：** 实现哈希查找算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
	"hash/fnv"
)

var hashTable = make(map[int]int)

func insert(key int, value int) {
	hash := int(fnv.New32().Sum32())
	hashTable[hash] = value
}

func search(key int) int {
	hash := int(fnv.New32().Sum32())
	if val, ok := hashTable[hash]; ok {
		return val
	}
	return -1
}

func main() {
	insert(1, 100)
	insert(2, 200)
	insert(3, 300)

	fmt.Println(search(1))  // 输出：100
	fmt.Println(search(2))  // 输出：200
	fmt.Println(search(3))  // 输出：300
	fmt.Println(search(4))  // 输出：-1
}
```

**解析：** 哈希查找是一种利用哈希表实现的查找算法。通过哈希函数将关键字转换成哈希地址，直接访问哈希表获取对应的数据。时间复杂度为 \(O(1)\)。

##### 2.3 布隆过滤器

**题目：** 实现布隆过滤器，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
	"math"
)

const (
	m = 1000000
	k = 7
)

var arr [m]bool
var hash1, hash2 [k]int

func init() {
	for i := 0; i < m; i++ {
		arr[i] = false
	}

	hash1 = [...]int{211, 47, 73, 109, 167, 241}
	hash2 = [...]int{409, 543, 709, 739, 821, 937}
}

func add(word string) {
	hash := 0
	for _, v := range word {
		hash = (hash * 31 + int(v)) % m
	}

	for i := 0; i < k; i++ {
		arr[(hash + hash1[i])%m] = true
		arr[(hash + hash2[i])%m] = true
	}
}

func isExist(word string) bool {
	hash := 0
	for _, v := range word {
		hash = (hash * 31 + int(v)) % m
	}

	for i := 0; i < k; i++ {
		if !arr[(hash + hash1[i])%m] || !arr[(hash + hash2[i])%m] {
			return false
		}
	}

	return true
}

func main() {
	add("hello")
	add("world")
	fmt.Println(isExist("hello"))  // 输出：true
	fmt.Println(isExist("world"))  // 输出：true
	fmt.Println(isExist("google"))  // 输出：false
}
```

**解析：** 布隆过滤器是一种非常高效的查找算法，用于判断一个元素是否在一个集合中。它使用一系列哈希函数将关键字映射到哈希表中的不同位置，并通过这些哈希值标记关键字的存在。时间复杂度为 \(O(k)\)，其中 \(k\) 为哈希函数的个数。

#### 3. 动态规划

##### 3.1 斐波那契数列

**题目：** 实现斐波那契数列，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func fib(n int) int {
	if n <= 1 {
		return n
	}
	dp := make([]int, n+1)
	dp[0], dp[1] = 0, 1
	for i := 2; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}
	return dp[n]
}

func main() {
	fmt.Println(fib(10)) // 输出：55
}
```

**解析：** 斐波那契数列是著名的数学数列，每一项都是前两项的和。动态规划是一种常用的算法思想，通过将复杂问题拆分为更小的子问题，并保存子问题的解，避免重复计算。时间复杂度为 \(O(n)\)。

##### 3.2 最长公共子序列

**题目：** 实现最长公共子序列，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func lcs(X, Y string) string {
	m, n := len(X), len(Y)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if X[i-1] == Y[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
			}
		}
	}

	var result []rune
	i, j := m, n
	for i > 0 && j > 0 {
		if X[i-1] == Y[j-1] {
			result = append(result, X[i-1])
			i--
			j--
		} else if dp[i-1][j] > dp[i][j-1] {
			i--
		} else {
			j--
		}
	}

	for i := len(result) - 1; i >= 0; i-- {
		fmt.Printf("%c", result[i])
	}
	fmt.Println()
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	X := "AGGTAB"
	Y := "GXTXAYB"
	fmt.Println(lcs(X, Y)) // 输出：GTAB
}
```

**解析：** 最长公共子序列（LCS）是指两个序列中公共元素的子序列中最长的子序列。动态规划是一种有效的解决方法，通过构建一个二维数组 \(dp\) 保存子问题的解。时间复杂度为 \(O(mn)\)，其中 \(m\) 和 \(n\) 分别为两个序列的长度。

##### 3.3 最长公共子串

**题目：** 实现最长公共子串，并分析其时间复杂度。

**代码实现：**

```go
package main

import "fmt"

func lcs(X, Y string) string {
	m, n := len(X), len(Y)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)

		for j := range dp[i] {
			if i == 0 || j == 0 {
				dp[i][j] = 0
			} else if X[i-1] == Y[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
			}
		}
	}

	var result []rune
	i, j := m, n
	for i > 0 && j > 0 {
		if X[i-1] == Y[j-1] {
			result = append(result, X[i-1])
			i--
			j--
		} else if dp[i-1][j] > dp[i][j-1] {
			i--
		} else {
			j--
		}
	}

	for i := len(result) - 1; i >= 0; i-- {
		fmt.Printf("%c", result[i])
	}
	fmt.Println()
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	X := "AGGTAB"
	Y := "GXTXAYB"
	fmt.Println(lcs(X, Y)) // 输出：GTAB
}
```

**解析：** 最长公共子串（LCS）是指两个序列中公共元素的子序列中最长的子序列。动态规划是一种有效的解决方法，通过构建一个二维数组 \(dp\) 保存子问题的解。时间复杂度为 \(O(mn)\)，其中 \(m\) 和 \(n\) 分别为两个序列的长度。

#### 4. 图算法

##### 4.1 深度优先搜索

**题目：** 实现深度优先搜索（DFS）算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
)

type Graph struct {
	adjList map[int][]int
}

func (g *Graph) addEdge(u, v int) {
	g.adjList[u] = append(g.adjList[u], v)
	g.adjList[v] = append(g.adjList[v], u)
}

func (g *Graph) DFS(u int, visited *map[int]bool) {
	(*visited)[u] = true
	fmt.Print(u, " ")

	for v := range g.adjList[u] {
		if !(*visited)[v] {
			g.DFS(v, visited)
		}
	}
}

func main() {
	g := &Graph{
		adjList: make(map[int][]int),
	}
	g.addEdge(0, 1)
	g.addEdge(0, 2)
	g.addEdge(1, 2)
	g.addEdge(2, 0)
	g.addEdge(2, 3)
	g.addEdge(3, 3)

	visited := make(map[int]bool)
	fmt.Println("深度优先搜索：")
	g.DFS(2, &visited)
}
```

**解析：** 深度优先搜索（DFS）是一种用于遍历或搜索树或图的算法。它沿着一个分支走到底，然后回溯。时间复杂度为 \(O(V+E)\)，其中 \(V\) 为顶点数，\(E\) 为边数。

##### 4.2 广度优先搜索

**题目：** 实现广度优先搜索（BFS）算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
)

type Graph struct {
	adjList map[int][]int
}

func (g *Graph) addEdge(u, v int) {
	g.adjList[u] = append(g.adjList[u], v)
	g.adjList[v] = append(g.adjList[v], u)
}

func (g *Graph) BFS(u int) {
	visited := make(map[int]bool)
	queue := []int{u}
	visited[u] = true

	for len(queue) > 0 {
		u := queue[0]
		queue = queue[1:]
		fmt.Print(u, " ")

		for v := range g.adjList[u] {
			if !visited[v] {
				queue = append(queue, v)
				visited[v] = true
			}
		}
	}
}

func main() {
	g := &Graph{
		adjList: make(map[int][]int),
	}
	g.addEdge(0, 1)
	g.addEdge(0, 2)
	g.addEdge(1, 2)
	g.addEdge(2, 0)
	g.addEdge(2, 3)
	g.addEdge(3, 3)

	fmt.Println("广度优先搜索：")
	g.BFS(2)
}
```

**解析：** 广度优先搜索（BFS）是一种用于遍历或搜索树或图的算法。它首先访问起始顶点的邻接点，然后逐层访问下一层的顶点。时间复杂度为 \(O(V+E)\)，其中 \(V\) 为顶点数，\(E\) 为边数。

##### 4.3 拓扑排序

**题目：** 实现拓扑排序算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
)

type Graph struct {
	adjList   map[int][]int
	inDegree  map[int]int
}

func (g *Graph) addEdge(u, v int) {
	g.adjList[u] = append(g.adjList[u], v)
	g.inDegree[v]++
}

func (g *Graph)拓扑排序() []int {
	queue := make([]int, 0, len(g.inDegree))
	for u, v := range g.inDegree {
		if v == 0 {
			queue = append(queue, u)
		}
	}

	var result []int
	for len(queue) > 0 {
		u := queue[0]
		queue = queue[1:]
		result = append(result, u)

		for v := range g.adjList[u] {
			g.inDegree[v]--
			if g.inDegree[v] == 0 {
				queue = append(queue, v)
			}
		}
	}
	return result
}

func main() {
	g := &Graph{
		adjList: make(map[int][]int),
		inDegree: make(map[int]int),
	}
	g.addEdge(0, 1)
	g.addEdge(0, 2)
	g.addEdge(1, 2)
	g.addEdge(2, 3)
	g.addEdge(3, 4)

	fmt.Println("拓扑排序：")
	fmt.Println(g.拓扑排序())
}
```

**解析：** 拓扑排序是一种用于对有向无环图（DAG）进行排序的算法。它将顶点按照顶点入度进行排序，入度为0的顶点先排序。时间复杂度为 \(O(V+E)\)，其中 \(V\) 为顶点数，\(E\) 为边数。

##### 4.4 最小生成树

**题目：** 实现最小生成树算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
)

type Edge struct {
	u, v, w int
}

type PriorityQueue struct {
	edges []Edge
}

func (pq *PriorityQueue) Len() int {
	return len(pq.edges)
}

func (pq *PriorityQueue) Less(i, j int) bool {
	return pq.edges[i].w < pq.edges[j].w
}

func (pq *PriorityQueue) Swap(i, j int) {
	pq.edges[i], pq.edges[j] = pq.edges[j], pq.edges[i]
}

func (pq *PriorityQueue) Push(x interface{}) {
	pq.edges = append(pq.edges, x.(Edge))
}

func (pq *PriorityQueue) Pop() interface{} {
	old := pq.edges
	n := len(old)
	x := old[n-1]
	pq.edges = old[0 : n-1]
	return x
}

func kruskal(edges []Edge, n int) []Edge {
	uf := NewUnionFind(n)
	mst := []Edge{}
	for _, edge := range edges {
		if uf.isConnected(edge.u, edge.v) {
			continue
		}
		uf.union(edge.u, edge.v)
		mst = append(mst, edge)
		if len(mst) == n-1 {
			break
		}
	}
	return mst
}

func (uf *UnionFind) isConnected(u, v int) bool {
	return uf.find(u) == uf.find(v)
}

func (uf *UnionFind) union(u, v int) {
	p, q := uf.find(u), uf.find(v)
	if p != q {
		uf.parent[p] = q
		uf.size[q] += uf.size[p]
	}
}

func (uf *UnionFind) find(x int) int {
	if uf.parent[x] != x {
		uf.parent[x] = uf.find(uf.parent[x])
	}
	return uf.parent[x]
}

type UnionFind struct {
	parent []int
	size   []int
}

func NewUnionFind(n int) *UnionFind {
	uf := &UnionFind{
		parent: make([]int, n),
		size:   make([]int, n),
	}
	for i := range uf.parent {
		uf.parent[i] = i
		uf.size[i] = 1
	}
	return uf
}

func main() {
	edges := []Edge{
		{0, 1, 4}, {0, 7, 8}, {1, 2, 8}, {1, 7, 11},
		{2, 3, 7}, {2, 8, 2}, {3, 4, 9}, {3, 5, 14},
		{4, 5, 10}, {5, 6, 2}, {6, 7, 1}, {6, 8, 6},
	}

	n := 9
	mst := kruskal(edges, n)
	fmt.Println("最小生成树：")
	for _, edge := range mst {
		fmt.Printf("(%d, %d): %d\n", edge.u, edge.v, edge.w)
	}
}
```

**解析：** 最小生成树（MST）是一种加权无向连通图，包含图中所有的顶点，并且所含边的权值之和最小。Kruskal算法是一种常用的求解最小生成树的算法，通过贪心策略选择权值最小的边，并判断是否构成环。时间复杂度为 \(O(E\log V)\)，其中 \(E\) 为边数，\(V\) 为顶点数。

#### 5. 字符串处理

##### 5.1 最长公共前缀

**题目：** 实现最长公共前缀，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
)

func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return ""
	}

	for i, c := 0, strs[0][0]; i < len(strs[0]); i++ {
		for _, s := range strs {
			if i >= len(s) || s[i] != c {
				return strs[0][:i]
			}
		}
	}

	return strs[0]
}

func main() {
	strs := []string{"flower", "flow", "flight"}
	fmt.Println(longestCommonPrefix(strs)) // 输出："fl"
}
```

**解析：** 最长公共前缀（LCP）是指多个字符串中公共前缀的最长长度。通过逐个比较字符串的前缀，可以找到最长的公共前缀。时间复杂度为 \(O(n\cdot m)\)，其中 \(n\) 为字符串的个数，\(m\) 为最长公共前缀的长度。

##### 5.2 最长回文子串

**题目：** 实现最长回文子串，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
	"unicode"
)

func longestPalindrome(s string) string {
	if len(s) <= 1 {
		return s
	}

	maxLen, start := 1, 0
	for i := 0; i < len(s); i++ {
		for j := 0; i-j >= 0 && i+j < len(s) && unicode.IsLetter(s[i-j]) && unicode.IsLetter(s[i+j]); j++ {
			if 2*j+1 > maxLen {
				maxLen = 2*j + 1
				start = i - j
			}
		}

		for k := 0; i-k-1 >= 0 && i+k < len(s) && unicode.IsLetter(s[i-k-1]) && unicode.IsLetter(s[i+k]); k++ {
			if 2*k > maxLen {
				maxLen = 2*k
				start = i - k - 1
			}
		}
	}

	return s[start : start+maxLen]
}

func main() {
	s := "babad"
	fmt.Println(longestPalindrome(s)) // 输出："bab" 或 "aba"
}
```

**解析：** 最长回文子串是指一个字符串中长度最长的回文子串。通过遍历字符串，判断每个字符为中心，向两边扩展，找到最长的回文子串。时间复杂度为 \(O(n^2)\)。

##### 5.3 字符串匹配

**题目：** 实现字符串匹配算法，并分析其时间复杂度。

**代码实现：**

```go
package main

import (
	"fmt"
)

func KMP(s, p string) int {
	n, m := len(s), len(p)
	lps := make([]int, m)
	j := 0

	computeLPSArray(p, m, lps)

	i := 0
	for i < n {
		if p[j] == s[i] {
			i++
			j++
		}

		if j == m {
			return i - j
		} else if i < n && p[j] != s[i] {
			if j != 0 {
				j = lps[j-1]
			} else {
				i++
			}
		}
	}

	return -1
}

func computeLPSArray(p string, m int, lps []int) {
	len := 0
	lps[0] = 0

	i := 1
	for i < m {
		if p[i] == p[len] {
			len++
			lps[i] = len
			i++
		} else {
			if len != 0 {
				len = lps[len-1]
			} else {
				lps[i] = 0
				i++
			}
		}
	}
}

func main() {
	s := "abababcaba"
	p := "abca"
	fmt.Println(KMP(s, p)) // 输出：2
}
```

**解析：** KMP算法是一种高效的字符串匹配算法，通过预计算最长公共前后缀（LPS）数组，避免了重复匹配。时间复杂度为 \(O(n+m)\)，其中 \(n\) 为待匹配字符串的长度，\(m\) 为模式串的长度。

#### 6. 数据结构

##### 6.1 链表

**题目：** 实现链表，并实现常见操作。

**代码实现：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func (l *ListNode) append(val int) {
	for l.Next != nil {
		l = l.Next
	}
	l.Next = &ListNode{Val: val}
}

func (l *ListNode) reverse() {
	var prev *ListNode
	for l != nil {
		next := l.Next
		l.Next = prev
		prev = l
		l = next
	}
	l = prev
}

func (l *ListNode) print() {
	for l != nil {
		fmt.Printf("%d ", l.Val)
		l = l.Next
	}
	fmt.Println()
}

func main() {
	l := &ListNode{Val: 1}
	l.append(2)
	l.append(3)
	l.append(4)
	l.append(5)

	fmt.Println("原链表：")
	l.print()

	l.reverse()
	fmt.Println("逆序链表：")
	l.print()
}
```

**解析：** 链表是一种常见的基础数据结构，它由一系列节点组成，每个节点包含数据和一个指向下一个节点的指针。通过实现链表，可以完成链表的插入、删除、反转等常见操作。

##### 6.2 堆

**题目：** 实现堆，并实现常见操作。

**代码实现：**

```go
package main

import (
	"fmt"
)

type MaxHeap struct {
	data []int
}

func (h *MaxHeap) push(val int) {
	h.data = append(h.data, val)
	h.bubbleUp(len(h.data)-1)
}

func (h *MaxHeap) pop() int {
	if len(h.data) == 0 {
		return -1
	}
	top := h.data[0]
	h.data[0] = h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	h.bubbleDown(0)
	return top
}

func (h *MaxHeap) bubbleUp(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent] < h.data[index] {
			h.data[parent], h.data[index] = h.data[index], h.data[parent]
			index = parent
		} else {
			break
		}
	}
}

func (h *MaxHeap) bubbleDown(index int) {
	lastIndex := len(h.data) - 1
	for {
		left := index*2 + 1
		right := index*2 + 2
		largest := index

		if left <= lastIndex && h.data[left] > h.data[largest] {
			largest = left
		}

		if right <= lastIndex && h.data[right] > h.data[largest] {
			largest = right
		}

		if largest != index {
			h.data[largest], h.data[index] = h.data[index], h.data[largest]
			index = largest
		} else {
			break
		}
	}
}

func (h *MaxHeap) print() {
	for _, v := range h.data {
		fmt.Printf("%d ", v)
	}
	fmt.Println()
}

func main() {
	h := &MaxHeap{}
	h.push(3)
	h.push(1)
	h.push(4)
	h.push(2)

	fmt.Println("堆：")
	h.print()

	fmt.Println("弹出元素：")
	fmt.Printf("%d ", h.pop())
	h.print()
}
```

**解析：** 堆是一种常见的数据结构，用于实现优先队列。最大堆（MaxHeap）表示堆顶元素是当前堆中最大的元素。通过实现堆，可以完成插入、删除等常见操作。

##### 6.3 树

**题目：** 实现二叉树，并实现常见操作。

**代码实现：**

```go
package main

import (
	"fmt"
)

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func (t *TreeNode) insert(val int) {
	if val < t.Val {
		if t.Left == nil {
			t.Left = &TreeNode{Val: val}
		} else {
			t.Left.insert(val)
		}
	} else {
		if t.Right == nil {
			t.Right = &TreeNode{Val: val}
		} else {
			t.Right.insert(val)
		}
	}
}

func (t *TreeNode) inorderTraversal() []int {
	var result []int
	if t != nil {
		result = append(result, t.Left.inorderTraversal()...)
		result = append(result, t.Val)
		result = append(result, t.Right.inorderTraversal()...)
	}
	return result
}

func (t *TreeNode) print() {
	if t == nil {
		return
	}
	fmt.Printf("%d ", t.Val)
	t.Left.print()
	t.Right.print()
}

func main() {
	t := &TreeNode{Val: 10}
	t.insert(5)
	t.insert(15)
	t.insert(3)
	t.insert(7)

	fmt.Println("中序遍历：")
	fmt.Println(t.inorderTraversal())

	fmt.Println("树结构：")
	t.print()
}
```

**解析：** 二叉树是一种常见的数据结构，每个节点最多有两个子节点。通过实现二叉树，可以完成插入、中序遍历等常见操作。

