                 

### 1. 单词频率统计

#### 题目：

给定一个字符串 `s`，返回 `s` 中每个单词的频率。这里，“单词”是指连续不为字母的字符组成的字符串。

#### 示例：

```
输入：s = "this sentence has some words"
输出：{"this":1, "sentence":1, "has":1, "some":1, "words":1}
```

#### 解题思路：

1. **分割字符串**：首先使用正则表达式将字符串按单词分割成数组。
2. **统计单词频率**：遍历数组，使用哈希表（map）统计每个单词的频率。

#### 代码实现：

```python
import re

def word_frequency(s):
    # 分割字符串为单词数组
    words = re.findall(r'\b\w+\b', s)
    # 统计单词频率
    freq = {}
    for word in words:
        freq[word] = freq.get(word, 0) + 1
    return freq

# 示例
s = "this sentence has some words"
print(word_frequency(s))
```

#### 解析：

- `re.findall(r'\b\w+\b', s)` 用于匹配字符串中的单词。`\b` 表示单词边界，`\w+` 表示一个或多个字母数字字符。
- `freq[word] = freq.get(word, 0) + 1` 使用 `get` 方法获取单词的当前频率，如果单词不存在则返回默认值 0，然后加 1 更新频率。

### 2. 矩阵乘法优化

#### 题目：

给定两个矩阵 `A` 和 `B`，计算并返回它们的矩阵乘积 `C`。要求优化算法，尽可能减少时间复杂度。

#### 示例：

```
输入：
A = [[1, 2, 3],
     [4, 5, 6]]
B = [[7, 8],
     [9, 10],
     [11, 12]]

输出：
C = [[58, 64],
      [139, 154]]
```

#### 解题思路：

1. **常规矩阵乘法**：直接使用常规的矩阵乘法公式计算。
2. **优化算法**：使用 Strassen 矩阵乘法或分治算法。

#### 代码实现：

```python
def matrix_multiply(A, B):
    # 常规矩阵乘法实现
    rows_A, cols_A = len(A), len(A[0])
    rows_B, cols_B = len(B), len(B[0])
    if cols_A != rows_B:
        raise ValueError("矩阵维度不匹配，无法相乘")

    C = [[0] * cols_B for _ in range(rows_A)]
    for i in range(rows_A):
        for j in range(cols_B):
            for k in range(cols_A):
                C[i][j] += A[i][k] * B[k][j]
    return C

# 示例
A = [[1, 2, 3],
     [4, 5, 6]]
B = [[7, 8],
     [9, 10],
     [11, 12]]
print(matrix_multiply(A, B))
```

#### 解析：

- 矩阵乘法的时间复杂度为 \(O(n^3)\)，其中 \(n\) 为矩阵的阶数。
- 优化算法（如 Strassen 矩阵乘法）可以将时间复杂度降低到 \(O(n^{2.8074})\)。

### 3. 单链表转换成双链表

#### 题目：

给定一个单链表的头节点 `head`，将其转换为双链表。要求遍历链表一次即可。

#### 示例：

```
输入：
head = [1 -> 2 -> 3 -> 4 -> 5]

输出：
转换为双链表后：[1 <-> 2 <-> 3 <-> 4 <-> 5]
```

#### 解题思路：

1. **修改指针**：遍历链表，将每个节点的 `next` 指针改为 `prev`，最后将头节点的 `prev` 指针指向尾节点。

#### 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def convert_to_doubly_linked_list(head):
    if not head:
        return None

    # 遍历链表，修改指针
    current = head
    while current.next:
        current.next.prev = current
        current = current.next

    # 将头节点的 prev 指向尾节点
    head.prev = current

    return head

# 示例
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
new_head = convert_to_doubly_linked_list(head)
```

#### 解析：

- 本质上是修改节点的 `next` 和 `prev` 指针，遍历一次链表即可完成转换。
- 注意：修改链表时，要防止循环，确保链表结构正确。

### 4. 二进制数转十进制数

#### 题目：

给定一个二进制字符串 `s`，将其转换为十进制数。

#### 示例：

```
输入：s = "1010"

输出：10
```

#### 解题思路：

1. **计算权重**：二进制数的每一位都有一个权重，从右到左依次是 \(2^0, 2^1, 2^2, \ldots\)。
2. **累加权重**：将二进制字符串从右到左遍历，计算每一位的权重，累加得到十进制数。

#### 代码实现：

```python
def binary_to_decimal(s):
    decimal = 0
    for i, bit in enumerate(s[::-1]):
        decimal += int(bit) * (2 ** i)
    return decimal

# 示例
s = "1010"
print(binary_to_decimal(s))
```

#### 解析：

- `s[::-1]` 用于将字符串反向遍历。
- `int(bit) * (2 ** i)` 用于计算当前位的权重。

### 5. 字符串压缩

#### 题目：

给定一个字符串 `s`，使用 Run-Length Encoding（RLE）算法对其进行压缩。

#### 示例：

```
输入：s = "aaabbc"

输出："3a2ab"
```

#### 解题思路：

1. **遍历字符串**：遍历字符串，记录连续相同字符的个数。
2. **构造压缩字符串**：将连续字符的个数和字符本身拼接起来。

#### 代码实现：

```python
def compress_string(s):
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i - 1]:
            count += 1
        else:
            compressed.append(str(count) + s[i - 1])
            count = 1
    compressed.append(str(count) + s[-1])
    return ''.join(compressed)

# 示例
s = "aaabbc"
print(compress_string(s))
```

#### 解析：

- 使用列表 `compressed` 存储压缩后的字符串。
- `str(count) + s[i - 1]` 用于将字符个数和字符拼接起来。

### 6. 双色棋翻转矩阵

#### 题目：

给定一个二维矩阵 `board`，其中每个元素是 `'X'` 或 `'O'`。每次操作可以翻转任意一个 `'X'` 或 `'O'` 为其相反字符。求最少操作次数，使得矩阵中没有两个相邻的 `'X'` 或 `'O'`。

#### 示例：

```
输入：
board = [
    ['X', 'O', 'X'],
    ['X', 'X', 'O'],
    ['X', 'O', 'X']
]

输出：
最少操作次数：2
```

#### 解题思路：

1. **贪心算法**：每次操作选择最多的 `'X'` 或 `'O'` 进行翻转。
2. **动态规划**：定义状态 `dp[i][j]` 表示 `(i, j)` 位置的最优解。

#### 代码实现：

```python
def min_flips_to_win(board):
    m, n = len(board), len(board[0])
    dp = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            if board[i][j] == 'X':
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]

    min_flips = float('inf')
    for i in range(m):
        for j in range(n):
            min_flips = min(min_flips, dp[i][j])

    return min_flips

# 示例
board = [
    ['X', 'O', 'X'],
    ['X', 'X', 'O'],
    ['X', 'O', 'X']
]
print(min_flips_to_win(board))
```

#### 解析：

- 使用动态规划计算每个位置的最优解。
- `dp[i][j]` 表示 `(i, j)` 位置翻转的最少操作次数。

### 7. 零钱兑换

#### 题目：

给定一个金额 `amount` 和一个硬币数组 `coins`，求最少硬币数量凑出给定金额。

#### 示例：

```
输入：
amount = 11
coins = [1, 2, 5]

输出：
最少硬币数量：3
```

#### 解题思路：

1. **动态规划**：定义状态 `dp[i]` 表示凑出金额 `i` 的最少硬币数量。
2. **状态转移方程**：`dp[i] = min(dp[i - coin] + 1)`, 其中 `coin` 是硬币的值。

#### 代码实现：

```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0

    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)

    return dp[amount] if dp[amount] != float('inf') else -1

# 示例
coins = [1, 2, 5]
amount = 11
print(coin_change(coins, amount))
```

#### 解析：

- 使用动态规划计算最少硬币数量。
- 如果 `dp[amount]` 的值为 `float('inf')`，表示无法凑出金额，返回 `-1`。

### 8. 排序链表

#### 题目：

给定一个单链表的头节点 `head`，将其排序。

#### 示例：

```
输入：
head = [4 -> 2 -> 1 -> 3]

输出：
排序后的链表：[1 -> 2 -> 3 -> 4]
```

#### 解题思路：

1. **归并排序**：将链表分成两半，分别排序，然后合并。
2. **递归实现**：递归地将链表分成两半，直到链表只有一个元素或为空。

#### 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def sort_list(head):
    if not head or not head.next:
        return head

    # 寻找中点
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    mid = slow.next
    slow.next = None

    # 递归排序
    left = sort_list(head)
    right = sort_list(mid)

    # 合并排序后的链表
    return merge(left, right)

def merge(left, right):
    dummy = ListNode(0)
    curr = dummy
    while left and right:
        if left.val < right.val:
            curr.next = left
            left = left.next
        else:
            curr.next = right
            right = right.next
        curr = curr.next

    curr.next = left or right
    return dummy.next

# 示例
head = ListNode(4, ListNode(2, ListNode(1, ListNode(3))))
sorted_head = sort_list(head)
```

#### 解析：

- `sort_list` 函数实现归并排序。
- `merge` 函数用于合并两个有序链表。

### 9. 最长公共前缀

#### 题目：

给定一个字符串数组 `strs`，找出其中最长的公共前缀。

#### 示例：

```
输入：strs = ["flower","flow","flight"]

输出："fl"
```

#### 解题思路：

1. **横向比较**：从第一个字符串开始，逐个字符与其他字符串的前缀进行比较。
2. **剪枝**：一旦发现不匹配的字符，立即停止比较。

#### 代码实现：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
        
    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))
```

#### 解析：

- `prefix` 初始值为第一个字符串。
- 遍历每个字符串，使用两个指针 `i` 分别指向 `prefix` 和当前字符串的字符，比较它们是否相同。

### 10. 寻找旋转排序数组中的最小值

#### 题目：

给定一个旋转排序的数组 `nums` ，找出并返回数组中的最小元素。

#### 示例：

```
输入：nums = [3,4,5,1,2]

输出：1
```

#### 解题思路：

1. **二分查找**：使用二分查找的方法，找到最小元素。
2. **状态转移**：每次迭代，将当前数组的中间元素与第一个元素进行比较，确定最小元素所在区间。

#### 代码实现：

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

# 示例
nums = [3, 4, 5, 1, 2]
print(find_min(nums))
```

#### 解析：

- 使用二分查找，将问题转化为在有序数组中查找最小元素。

### 11. 最长公共子序列

#### 题目：

给定两个字符串 `text1` 和 `text2`，找出并返回它们的最长公共子序列。

#### 示例：

```
输入：text1 = "abcde", text2 = "ace"

输出："ace"
```

#### 解题思路：

1. **动态规划**：定义状态 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。
2. **状态转移方程**：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1)`。

#### 代码实现：

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

# 示例
text1 = "abcde"
text2 = "ace"
print(longest_common_subsequence(text1, text2))
```

#### 解析：

- 使用二维数组 `dp` 存储状态。
- 最后返回 `dp[m][n]`，即最长公共子序列的长度。

### 12. 合并区间

#### 题目：

给定一组区间，合并所有重叠的区间。

#### 示例：

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]

输出：[[1,6],[8,10],[15,18]]
```

#### 解题思路：

1. **排序**：将区间按照起始点排序。
2. **合并区间**：遍历排序后的区间，合并重叠的区间。

#### 代码实现：

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        last = merged[-1]
        if last[1] >= interval[0]:
            merged[-1][1] = max(last[1], interval[1])
        else:
            merged.append(interval)

    return merged

# 示例
intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))
```

#### 解析：

- 首先对区间进行排序。
- 然后遍历区间，合并重叠的部分。

### 13. 最长公共子串

#### 题目：

给定两个字符串 `text1` 和 `text2`，找出并返回它们的最长公共子串。

#### 示例：

```
输入：text1 = "abcde", text2 = "ace"

输出："ace"
```

#### 解题思路：

1. **动态规划**：定义状态 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子串长度。
2. **状态转移方程**：`dp[i][j] = max(dp[i - 1][j - 1] + 1, 0)`。

#### 代码实现：

```python
def longest_common_substring(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    max_len = 0
    end_pos = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i
            else:
                dp[i][j] = 0

    return text1[end_pos - max_len: end_pos]

# 示例
text1 = "abcde"
text2 = "ace"
print(longest_common_substring(text1, text2))
```

#### 解析：

- 使用二维数组 `dp` 存储状态。
- 最后返回从 `text1` 的 `end_pos - max_len` 到 `end_pos` 的子串。

### 14. 字符串匹配算法

#### 题目：

给定一个主字符串 `s` 和一个模式字符串 `p`，实现字符串匹配算法，找到 `s` 中第一个与 `p` 匹配的子字符串。

#### 示例：

```
输入：s = "hello", p = "ll"

输出：2
```

#### 解题思路：

1. **KMP 算法**：使用 KMP 算法预处理模式字符串 `p`，得到一个最长前后缀表 `lps`。
2. **匹配**：遍历主字符串 `s`，使用 `lps` 进行匹配。

#### 代码实现：

```python
def kmp_search(s, p):
    lps = [0] * len(p)
    compute_lps(p, len(p), lps)

    i = j = 0
    while i < len(s):
        if p[j] == s[i]:
            i += 1
            j += 1
        if j == len(p):
            return i - j
        elif i < len(s) and p[j] != s[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return -1

def compute_lps(p, m, lps):
    length = 0
    lps[0] = 0
    i = 1
    while i < m:
        if p[i] == p[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1

# 示例
s = "hello"
p = "ll"
print(kmp_search(s, p))
```

#### 解析：

- `compute_lps` 函数用于计算最长前后缀表。
- `kmp_search` 函数实现 KMP 算法。

### 15. 二叉树的直径

#### 题目：

给定一个二叉树，求出其直径的长度。二叉树的直径定义为通过任意节点，且不经过该节点的最长路径的长度。

#### 示例：

```
输入：
    1
   / \
  2   3
 / \   
4   5

输出：3
```

#### 解题思路：

1. **递归**：定义递归函数 `dfs(node)`，返回以 `node` 为根的二叉树的最大深度。
2. **更新直径**：在递归过程中，更新直径为左右子树深度的最大值之和。

#### 代码实现：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def diameter_of_binary_tree(root):
    def dfs(node):
        if not node:
            return 0
        left_depth, right_depth = dfs(node.left), dfs(node.right)
        nonlocal diameter
        diameter = max(diameter, left_depth + right_depth)
        return 1 + max(left_depth, right_depth)

    diameter = 0
    dfs(root)
    return diameter

# 示例
root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, None, TreeNode(6)))
print(diameter_of_binary_tree(root))
```

#### 解析：

- `dfs(node)` 函数计算以 `node` 为根的子树的最大深度。
- `diameter` 是一个全局变量，用于记录直径的长度。

### 16. 子集划分

#### 题目：

给定一个整数 `n`，求出所有可能的子集划分。

#### 示例：

```
输入：n = 4

输出：[
  [1,1,1,1],
  [1,1,1,2],
  [1,1,1,3],
  [1,1,2,2],
  [1,1,2,3],
  [1,1,3,3],
  [1,2,2,2],
  [1,2,2,3],
  [1,2,3,3],
  [1,3,3,3],
  [2,2,2,2],
  [2,2,2,3],
  [2,2,3,3],
  [2,3,3,3],
  [3,3,3,3]
]
```

#### 解题思路：

1. **递归**：使用递归遍历所有可能的子集。
2. **回溯**：在递归过程中，对于每个数字，可以选择加入或排除，然后继续递归。

#### 代码实现：

```python
def subsets_with_dup(nums):
    def dfs(nums, index, path):
        nonlocal result
        result.append(path)
        for i in range(index, len(nums)):
            if i > index and nums[i] == nums[i - 1]:
                continue
            dfs(nums, i + 1, path + [nums[i]])

    nums.sort()
    result = []
    dfs(nums, 0, [])
    return result

# 示例
nums = [1, 2, 2, 3]
print(subsets_with_dup(nums))
```

#### 解析：

- `dfs` 函数用于递归遍历所有可能的子集。
- `nums.sort()` 用于排序，避免重复子集。

### 17. 最短路径问题

#### 题目：

给定一个有向图和两个节点 `start` 和 `end`，求出从 `start` 到 `end` 的最短路径。

#### 示例：

```
输入：
graph = [
    [1, 2, 4],
    [1, 4, 5],
    [2, 3, 1],
    [2, 4, 3],
    [3, 4, 6],
    [4, 6, 6]
],
start = 0, end = 3

输出：7
```

#### 解题思路：

1. **迪杰斯特拉算法**：使用优先队列（最小堆）实现迪杰斯特拉算法。
2. **状态转移**：每次更新当前节点的邻居节点的距离。

#### 代码实现：

```python
import heapq

def dijkstra(graph, start, end):
    n = len(graph)
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        curr_dist, curr_node = heapq.heappop(pq)
        if curr_node == end:
            return curr_dist
        if curr_dist > dist[curr_node]:
            continue
        for neighbor, weight in graph[curr_node]:
            new_dist = curr_dist + weight
            if new_dist < dist[neighbor]:
                dist[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))

    return -1

# 示例
graph = [
    [1, 2, 4],
    [1, 4, 5],
    [2, 3, 1],
    [2, 4, 3],
    [3, 4, 6],
    [4, 6, 6]
]
start = 0
end = 3
print(dijkstra(graph, start, end))
```

#### 解析：

- 使用优先队列 `pq` 存储待处理的节点，按照距离排序。
- `heapq.heappop(pq)` 用于获取当前距离最短的节点。

### 18. 求最大子序列和

#### 题目：

给定一个整数数组 `nums`，返回数组中的最大子序列和。子序列是一个数组中的连续元素组成的序列。

#### 示例：

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

输出：6
```

#### 解题思路：

1. **动态规划**：使用变量 `max_ending_here` 和 `max_so_far` 分别表示以当前元素为结尾的最大子序列和和全局最大子序列和。
2. **状态转移方程**：`max_ending_here = max(nums[i], max_ending_here + nums[i])`，`max_so_far = max(max_so_far, max_ending_here)`。

#### 代码实现：

```python
def max_subarray_sum(nums):
    max_ending_here = max_so_far = nums[0]
    for num in nums[1:]:
        max_ending_here = max(num, max_ending_here + num)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

# 示例
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))
```

#### 解析：

- 遍历数组，更新 `max_ending_here` 和 `max_so_far`。

### 19. 快乐数

#### 题目：

编写一个算法来判断一个数 `n` 是否为「快乐数」。

一个「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐的。

#### 示例：

```
输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

#### 解题思路：

1. **快慢指针法**：使用快指针 `fast` 和慢指针 `slow`，快指针每次走两步，慢指针每次走一步。如果快指针和慢指针最终相遇，说明存在循环，该数不是快乐数。
2. **判断循环**：如果快指针到达 1，说明该数是快乐数。

#### 代码实现：

```python
def is_happy(n):
    def get_next(n):
        sum = 0
        while n:
            n, digit = divmod(n, 10)
            sum += digit ** 2
        return sum

    slow, fast = n, get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1

# 示例
n = 19
print(is_happy(n))
```

#### 解析：

- `get_next` 函数计算一个数的下一个数字。

### 20. 翻转链表

#### 题目：

定义一个函数，输入一个链表的头节点，反转该链表并返回新链表的头部。

#### 示例：

```
输入：head = [1,2,3,4,5]

输出：[5,4,3,2,1]
```

#### 解题思路：

1. **递归**：递归地反转当前节点的下一个节点，然后将当前节点的下一个节点指向其前一个节点。
2. **迭代**：使用栈或循环迭代反转链表。

#### 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    if not head or not head.next:
        return head

    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node

    return prev

# 示例
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
new_head = reverse_linked_list(head)
```

#### 解析：

- 使用三个指针 `prev`、`curr` 和 `next_node` 实现链表反转。

### 21. 有效括号

#### 颇题：

给定一个字符串 `s` ，其中包含左括号 `(`、右括号 `)`。判断字符串是否有效，即是否可以表示一个有效的括号嵌套结构。

#### 示例：

```
输入："()"
输出：true

输入："()[]{}"
输出：true

输入："{[()()]}"
输出：true

输入："{[()()]}("
输出：false
```

#### 解题思路：

1. **计数法**：使用栈记录左括号的数量，遇到右括号时，检查栈顶元素是否与之匹配。
2. **栈法**：使用栈存储遇到的左括号，遇到右括号时，弹出栈顶元素进行匹配。

#### 代码实现：

```python
def isValid(s):
    stack = []
    pairs = {')': '(', ']': '[', '}': '{'}
    for c in s:
        if c in pairs.values():
            stack.append(c)
        elif c in pairs and stack and stack[-1] == pairs[c]:
            stack.pop()
        else:
            return False
    return not stack

# 示例
s = "()[]{}"
print(isValid(s))
```

#### 解析：

- 遍历字符串，使用栈实现括号匹配。

### 22. 合并两个有序链表

#### 题目：

将两个升序链表合并为一个升序链表并返回结果。

#### 示例：

```
输入：l1 = [1,2,4], l2 = [1,3,4]

输出：[1,1,2,3,4,4]
```

#### 解题思路：

1. **递归**：递归地将两个链表合并。
2. **迭代**：使用两个指针遍历两个链表，每次选择较小的值。

#### 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = merge_two_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_two_lists(l1, l2.next)
        return l2

# 示例
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged_head = merge_two_lists(l1, l2)
```

#### 解析：

- 递归地将两个链表合并。

### 23. 合并区间

#### 题目：

以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。你需要合并所有重叠的区间，并返回一个不重叠的区间数组。

#### 示例：

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]

输出：[[1,6],[8,10],[15,18]]
```

#### 解题思路：

1. **排序**：首先对区间按照起始点排序。
2. **合并区间**：遍历排序后的区间，合并重叠的区间。

#### 代码实现：

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        last = merged[-1]
        if last[1] >= interval[0]:
            merged[-1][1] = max(last[1], interval[1])
        else:
            merged.append(interval)

    return merged

# 示例
intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))
```

#### 解析：

- 首先对区间进行排序。
- 然后遍历区间，合并重叠的部分。

### 24. 最长公共前缀

#### 题目：

编写一个函数来查找字符串数组中的最长公共前缀。

#### 示例：

```
输入：strs = ["flower","flow","flight"]

输出："fl"
```

#### 解题思路：

1. **横向比较**：从第一个字符串开始，逐个字符与其他字符串的前缀进行比较。
2. **剪枝**：一旦发现不匹配的字符，立即停止比较。

#### 代码实现：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
        
    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))
```

#### 解析：

- `prefix` 初始值为第一个字符串。
- 遍历每个字符串，使用两个指针 `i` 分别指向 `prefix` 和当前字符串的字符，比较它们是否相同。

### 25. 电话号码的字母组合

#### 题目：

给定一个仅包含数字 2-9 的字符串，返回所有可能的重排字母组合。

#### 示例：

```
输入："23"
输出：['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']

输入："123"
输出：['abc', 'abd', 'abe', 'acd', 'ace', 'acf', 'bcd', 'bce', 'bcf', 'bcd', 'bce', 'acf', 'abd', 'abe', 'ace', 'ace']
```

#### 解题思路：

1. **递归**：递归地将每个数字对应的字母添加到字符串中。
2. **剪枝**：如果当前字符串长度等于数字字符串的长度，说明已经找到了所有组合，停止递归。

#### 代码实现：

```python
def letter_combinations(digits):
    def dfs(index, curr):
        if index == len(digits):
            result.append(curr)
            return
        for c in phone_book[digits[index]]:
            dfs(index + 1, curr + c)

    phone_book = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    result = []
    dfs(0, "")
    return result

# 示例
digits = "23"
print(letter_combinations(digits))
```

#### 解析：

- `dfs` 函数用于递归生成所有组合。

### 26. 二进制数转十进制数

#### 题目：

给定一个二进制字符串，将其转换为十进制数。

#### 示例：

```
输入："1010"
输出：10
```

#### 解题思路：

1. **计算权重**：二进制数的每一位都有一个权重，从右到左依次是 \(2^0, 2^1, 2^2, \ldots\)。
2. **累加权重**：将二进制字符串从右到左遍历，计算每一位的权重，累加得到十进制数。

#### 代码实现：

```python
def binary_to_decimal(s):
    decimal = 0
    for i, bit in enumerate(s[::-1]):
        decimal += int(bit) * (2 ** i)
    return decimal

# 示例
s = "1010"
print(binary_to_decimal(s))
```

#### 解析：

- `s[::-1]` 用于将字符串反向遍历。

### 27. 最长连续序列

#### 题目：

给定一个未排序的整数数组，找出最长连续序列的长度。

#### 示例：

```
输入：nums = [100, 4, 200, 1, 3, 2]

输出：4
```

#### 解题思路：

1. **排序**：首先对数组进行排序。
2. **计数**：遍历排序后的数组，计算最长连续序列的长度。

#### 代码实现：

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums.sort()
    longest = 1
    current = 1

    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            current += 1
        else:
            longest = max(longest, current)
            current = 1

    return max(longest, current)

# 示例
nums = [100, 4, 200, 1, 3, 2]
print(longest_consecutive(nums))
```

#### 解析：

- 遍历排序后的数组，计算最长连续序列的长度。

### 28. 单词拆分

#### 题目：

给定一个字符串 `s` 和一个字符串列表 `wordDict`，返回该字符串的拆分方案。

#### 示例：

```
输入：s = "applepenapple", wordDict = ["apple", "pen"]

输出：["apple pen apple", "appler apple", "apple pen", "apple pene", "app ple apple"]

输入：s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]

输出：[]
```

#### 解题思路：

1. **动态规划**：定义状态 `dp[i]` 表示前 `i` 个字符是否可以拆分。
2. **状态转移方程**：`dp[i] = any(dp[j] and dp[i - j] for j in range(i))`。

#### 代码实现：

```python
def word_break(s, wordDict):
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordDict:
                dp[i] = True
                break
    return []

    def backtrack(s, wordDict, start):
        if start == len(s):
            return [[]]
        result = []
        for end in range(start + 1, len(s) + 1):
            if s[start:end] in wordDict:
                for prev in backtrack(s, wordDict, end):
                    result.append([s[start:end] 

