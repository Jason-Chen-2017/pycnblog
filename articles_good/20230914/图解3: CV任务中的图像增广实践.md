
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 1.1 文档背景及目标读者
随着近几年计算机视觉领域的发展，图像处理技术已经得到迅速的发展，其应用范围越来越广泛。由于数字图像具有很高的空间信息，图像处理算法往往依赖于图像的空间特性进行准确和精细化的识别。然而，每张图像都由固定的像素点组成，并且像素之间的相互关系并不能完整描述图像的空间结构，因此，如何提升基于图像的算法在对图像处理的准确性、效率和鲁棒性上的表现是当前图像处理领域的一大难题。
在CV任务中，图像增广（Image Augmentation）是一种广泛使用的图像预处理方法，它可以提升模型在数据集上泛化性能、减少过拟合和抗攻击等能力。但由于增强的方法种类繁多，参数配置复杂，如何选择最优的增强方法以及参数值也成为一大挑战。因此，如何系统atically理解图像增广方法的原理和操作，并将这些知识运用到实际项目中，成为一项重要的研究方向。
本文旨在通过对图像增广方法的系统性理解和分析，介绍它们的特点、原理及应用，以及如何有效地实现它们，帮助读者更好地掌握图像增广相关技术，以及在实际的CV任务中应用这些技术，从而达到提升模型在图像分类、检测、分割等任务上的性能。
文章作者：<NAME>，陈彦能，腾讯机器学习平台AI Lab高级工程师。
## 1.2 文章概述
图像增广（Image Augmentation）是指采用随机变换或特定规则对原始图像进行操作，生成新的图像样本，来增加训练数据规模，扩充数据集，加强模型泛化能力。它能够使模型对于噪声、光照、位置变化、尺度缩放、形态变化等因素不敏感，在一定程度上提升模型的泛化性能。但是，如何有效地使用图像增广方法对数据集进行扩充和加强，仍然是一个难点。为了解决这个问题，本文首先对图像增广方法的原理和分类进行系统的介绍，然后对目前常用的图像增广方法进行了详细的解析和比较，包括一些具体案例。最后，作者从多个视角阐释了图像增广方法的原理和作用，并结合实际案例，分享了他认为具有代表意义的图像增广方法。
文章将围绕以下几个方面展开讨论：
- 图像增广的原理和分类
- 常用图像增广方法的介绍
- 通过案例进行详尽剖析
- 涉及到的核心概念的深入分析
- 在实际场景中的应用和效果评估
# 2.基本概念术语说明
## 2.1 增广
增广(Augmentation)是指将一个数据集中的样本做一些处理，使得样本数量增加，既有利于模型的训练和测试，又没有增加实际的训练时间或者数据成本。一般来说，图像增广分为两种，一种是增广方法，一种是增广策略。
### 2.1.1 增广方法
增广方法(Augmentation Method) 是指对输入图像进行某种处理操作得到新图像。常见的图像增广方法如下所示：
- 插值插值法 (Interpolation Method): 对图像进行插值操作，根据插值方式不同，插值的结果可以是平滑的、锐化的、透视的、平行的等等。例如，将图像缩小，然后再放大。
- 混叠 (Mixing): 把两个或更多的图片混合在一起，产生新的图片。
- 对比度调整 (Contrast Adjustment): 对图像进行亮度、对比度等参数调整。
- 仿射变换 (Affine Transformation): 仿射变换可以实现平移、旋转、缩放等操作，可以改变图像的形状和大小。
- 噪声添加 (Noise Addition): 将模拟的噪声添加到图像中，比如椒盐噪声、高斯噪声、像素级别的噪声。
- 光学变换 (Photometric Transformation): 包括色彩增强和亮度变换等操作。
- 模糊操作 (Blurring Operation): 可以使图像的边缘、噪声、轮廓更加清晰。
- 遮挡操作 (Occlusion Operation): 先对原始图像随机擦除一部分区域，然后在该区域内绘制新物体。
- 浮雕 (Embossing): 先对原始图像进行灰度转换，然后向左右两侧投影线条，达到浮雕的效果。
- 反射 (Reflection): 对图片进行水平镜像、垂直镜像、斜向镜像，来模拟自然环境中的景物。
### 2.1.2 增广策略
增广策略(Augmentation Strategy) 是指对数据增强过程中要使用的各种方法及各自的参数设置组合。图像增广策略包含数据增强方法的选择，顺序的安排，以及各个方法的执行频率。一般包括三种策略：
- 整体策略 (Whole-image Strategy): 包含多个增广方法，并应用到整个图像上。
- 局部策略 (Local-regional Strategy): 包含多个增广方法，其中某些方法只应用到局部图像区域。
- 链式策略 (Chained Strategy): 包含多个增广方法，各个方法之间存在先后次序。

## 2.2 数据增强
数据增强（Data augmentation）是一种图像预处理方法，它通过对输入图像进行随机变换和操作，生成一系列图像，作为训练数据集的补充。这些图像通常与原始数据有所不同，例如，平移、旋转、裁剪、拼接、颜色变化等，有助于模型在测试时应对各种情况，提升模型的泛化性能。数据增强方法可以从多个视角看待，可以从数据集扩展、模型泛化两个方面去考虑。
## 2.3 深度学习框架
深度学习框架(Deep learning framework) 是构建、训练和部署深度学习模型的软件工具包，包括用于构建、训练、优化和部署神经网络的工具。常见的深度学习框架包括 TensorFlow、PyTorch、Caffe2 和 MXNet。
## 2.4 模型压缩
模型压缩(Model Compression) 是指通过压缩模型参数量和计算量，降低模型的内存占用和延迟，提升推理速度的方法。模型压缩有利于降低存储和传输模型所需的数据量，缩短推理时间，减轻计算设备的压力。常见的模型压缩方法包括剪枝、量化和蒸馏等。
# 3.核心算法原理和具体操作步骤以及数学公式讲解
## 3.1 插值插值法
插值插值法(Interpolation Method) 是指利用已知像素点的周围的像素点来计算缺失像素点的灰度值的方法。主要包括最近邻插值法、双线性插值法、三次样条插值法等。
### 3.1.1 最近邻插值法
最近邻插值法(Nearest Neighbor Interpolation) 是指用距目标像素最近的像素点的值来插值目标像素点的值。具体过程如下：
1. 根据目标像素的坐标计算出四舍五入后的整数坐标$(x_q,\ y_q)$。
2. 判断目标像素$(x_q,\ y_q)$是否在图像的边界内。如果在边界内，则赋值为对应的边界像素的值；否则，遍历源图像的所有像素，找到距离目标像素$(x_q,\ y_q)$最近的一个像素$(x_s,\ y_s)$，赋值给目标像素。

离散化插值公式：$f_{ij}=\left\{\begin{array}{ll} f(i+\frac{1}{2},j+\frac{1}{2}) & \text { if } x=i+\frac{1}{2} \\ f(i+1,j), \quad i<N-\frac{1}{2} \\ f(i-1,j), \quad i>\frac{1}{2} N \\ f(i, j+1), \quad j<M-\frac{1}{2} \\ f(i, j-1), \quad j>\frac{1}{2} M \end{array}\right.$

其中$f(x,y)$表示源图像的灰度值。

### 3.1.2 双线性插值法
双线性插值法(Bilinear Interpolation) 是指用与目标像素邻近的四个像素的权重比值进行双线性插值。具体过程如下：
1. 根据目标像素的坐标计算出四舍五入后的整数坐标$(x_q,\ y_q)$。
2. 判断目标像素$(x_q,\ y_q)$是否在图像的边界内。如果在边界内，则赋值为对应的边界像素的值；否则，对源图像中相邻的四个像素$(x_r,\ y_r)$的值进行计算，插值公式如下：
   $$
   f(x,y)=\frac{(1-\frac{x-x_r}{w})f(x_r,y)+\frac{x-x_r}{w}f(x_r+1,y)}
                 {(1-\frac{x-x_r}{w})+(1-\frac{x-x_r}{w})}
   $$

   $$
   g(x,y)=\frac{(1-\frac{y-y_r}{h})g(x,y_r)+\frac{y-y_r}{h}g(x,y_r+1)}
                 {(1-\frac{y-y_r}{h})+(1-\frac{y-y_r}{h})}
   $$

   $f(x,y)$和$g(x,y)$分别表示目标像素和其两个坐标相邻的像素。$w$和$h$表示两个坐标相邻的像素距离目标像素的距离，即$(x_q,\ y_q)$和$(x_r,\ y_r)$。
   
3. 计算两个插值函数的像素值乘积，即可求得目标像素的值。

双线性插值公式：$f_{ij}=f(x,y)\times(1-\frac{|x-x_i|}{w})\times(1-\frac{|y-y_i|}{h})+\\
            +f(x+\frac{1}{2},y)\times(\frac{|x-x_i|}{w})\times(1-\frac{|y-y_i|}{h})+\\
            +f(x,y+\frac{1}{2})\times(1-\frac{|x-x_i|}{w}) \times (\frac{|y-y_i|}{h})+\\
            +f(x+\frac{1}{2},y+\frac{1}{2})\times(\frac{|x-x_i|}{w})\times(\frac{|y-y_i|}{h})$
            
其中$f_{ij}$表示目标像素的灰度值，$(x_i,\ y_i)$表示源图像的$(i,\ j)$坐标，$w=\frac{x_{\max}-x_{\min}}{w_0}$, $h=\frac{y_{\max}-y_{\min}}{h_0}$, $x_{\min}, x_{\max}, y_{\min}, y_{\max}$分别表示源图像的最小值、最大值、宽度、高度。

### 3.1.3 三次样条插值法
三次样条插值法(Cubic Spline Interpolation) 是指用三次多项式拟合得到目标像素的值。具体过程如下：
1. 将源图像按照一维或二维的方式离散化，得到离散化图像。
2. 用三次多项式逼近离散化图像，得到逼近曲线。
3. 根据目标像素的坐标计算出离散化坐标$(x_k,\ y_k)$。
4. 从离散化坐标$(x_k,\ y_k)$处求取梯度值$(df/dx_k,\ df/dy_k)$。
5. 使用梯度值对逼近曲线进行插值，得到目标像素的值。

三次样条插值公式：$f_{ij}(x,y)=[A(x)-Bx^2+(cx)(2Dx)+(Ex)^3]_{n(x)}\Big|_{n(x)=u(x,y)}, n(x)=[floor(x), floor(y)]$

其中$n(x)=\{x_a, x_b,..., x_{k-1}, u(x,y)\}$表示离散化坐标，$u(x,y)$表示目标坐标。$A$, $B$, $C$, $D$, $E$是系数矩阵。

## 3.2 混叠
混叠(Mixing) 是指把两个或更多的图片混合在一起，生成新的图片。常见的混叠方法包括均匀混叠、加权混叠、光泽混叠等。
### 3.2.1 均匀混叠
均匀混叠(Uniform Mixing) 是指把两个或更多的图片平滑地混合在一起。具体过程如下：
1. 根据两个或更多的图片的尺寸大小，确定新的图像的尺寸。
2. 把两个或更多的图片的像素点按一定权重混合在一起。
3. 生成新的图像。

均匀混叠公式：$I'=\alpha I_1+\beta I_2+\gamma I_3+\cdots+\zeta I_n$

其中$\alpha,\ beta,\ gamma,\ \vdots,\ \zeta$是系数，$I'$是新的图像，$I_1,\ I_2,\ I_3,\ \vdots,\ I_n$是原来的图像。

### 3.2.2 加权混叠
加权混叠(Weighted Mixing) 是指依据图片的亮度、饱和度、颜色通道等参数，按相应权重混合在一起。具体过程如下：
1. 将两个或更多的图片划分为若干子区域。
2. 根据每个子区域的亮度、饱和度、颜色通道等参数计算权重。
3. 把两个或更多的图片按权重混合在一起。
4. 生成新的图像。

加权混叠公式：$I'_c=(R'_c G'_c B'_c)^T$

其中$I'_c$是新的图像，$R'_c, G'_c, B'_c$是混合后每个颜色通道的RGB值。

### 3.2.3 光泽混叠
光泽混叠(Lightness Saturation Mixing) 是指对两个或更多的图片进行亮度、饱和度、颜色通道等参数调整，得到新图片。具体过程如下：
1. 根据两个或更多的图片的属性差异，调整参数。
2. 生成新的图像。

光泽混叠公式：$L'=\gamma L+\kappa$

其中$\gamma$是对比度，$\kappa$是亮度偏移。

## 3.3 对比度调整
对比度调整(Contrast Adjustment) 是指对图像的亮度、对比度等参数调整。常见的对比度调整方法包括拉伸修正、线性拉伸、对数拉伸等。
### 3.3.1 拉伸修正
拉伸修正(Stretch Correction) 是指对图像进行线性拉伸，以适应特定显示器的输出特性。具体过程如下：
1. 对图像进行缩放，以使得其边界平滑，同时保持亮度不变。
2. 归一化图像，使其像素值位于0~1之间。
3. 为图像设置最大和最小值，并设置调节对比度的比例。
4. 生成新的图像。

拉伸修正公式：$I_{\lambda}(x,y)=\frac{\lambda}{\Delta \lambda}\cdot \left[I_{\min}+\frac{(I_{\max}-I_{\min})}{1-(exp(-\gamma x))}\right]$

其中$\gamma$是拉伸系数，$\lambda$是图像大小，$\Delta \lambda$是显示器的分辨率，$I_{\min}$和$I_{\max}$是图像的最小和最大值。

### 3.3.2 线性拉伸
线性拉伸(Linear Stretch) 是指对图像进行线性拉伸。具体过程如下：
1. 对图像进行缩放，以使得其边界平滑，同时保持亮度不变。
2. 设置图像的最大和最小值，并设置拉伸倍率。
3. 生成新的图像。

线性拉伸公式：$I_{\tau}(x,y)=\frac{\tau\cdot min(I_{\min},I_{\max})+I_{\delta}}{2}+\frac{\tau}{\Delta\tau}[(I_{\max}-I_{\min})(x,y)-I_{\delta}]$

其中$\tau$是拉伸比例，$\Delta\tau$是显示器的分辨率，$I_{\delta}$是图像亮度的平均值。

### 3.3.3 对数拉伸
对数拉伸(Logarithmic Stretch) 是指对图像进行对数拉伸。具体过程如下：
1. 对图像进行缩放，以使得其边界平滑，同时保持亮度不变。
2. 设置图像的最大和最小值，并设置对数拉伸的对数基底。
3. 生成新的图像。

对数拉伸公式：$I_{\sigma}(x,y)=\frac{\tau(log(\lambda(I_{\min}+\frac{(I_{\max}-I_{\min})}{1-\gamma x^{-\sigma}})))+\epsilon}{2\pi+\epsilon}$

其中$\tau$是对数拉伸系数，$\lambda$是图像大小，$\sigma$是对数基底，$\gamma$是保留角度，$\epsilon$是一个小常量。

## 3.4 仿射变换
仿射变换(Affine Transformation) 是指对图像进行平移、旋转、缩放等操作，来改变图像的形状和大小。仿射变换可以实现平移、旋转、缩放等操作，可以改变图像的形状和大小。常见的仿射变换方法包括平移、缩放、旋转、错切、仿射、透视图等。
### 3.4.1 平移
平移(Translation) 是指将图像沿着x轴和y轴移动。具体过程如下：
1. 指定移动的步长。
2. 根据指定移动的步长，将图像沿着x轴和y轴移动。
3. 生成新的图像。

平移公式：$x^{\prime}=x+tx, y^{\prime}=y+ty$

其中$(x^{\prime}, y^{\prime})$是图像在平移之后的坐标。

### 3.4.2 缩放
缩放(Scaling) 是指将图像按照一定的比例进行放大或缩小。具体过程如下：
1. 指定缩放的比例。
2. 根据指定的比例对图像进行缩放。
3. 生成新的图像。

缩放公式：$x^{\prime}=ax, y^{\prime}=ay$

其中$(x^{\prime}, y^{\prime})$是图像在缩放之后的坐标。

### 3.4.3 旋转
旋转(Rotation) 是指将图像顺时针或逆时针旋转一定角度。具体过程如下：
1. 指定旋转中心和旋转角度。
2. 根据指定的旋转中心和旋转角度对图像进行旋转。
3. 生成新的图像。

旋转公式：$x^{\prime}=cos\theta(x-x')-sin\theta(y-y'), y^{\prime}=sin\theta(x-x')+cos\theta(y-y')$

其中$(x', y')$是旋转中心，$\theta$是旋转角度，$(x^{\prime}, y^{\prime})$是图像在旋转之后的坐标。

### 3.4.4 错切
错切(Shear) 是指将图像进行错切，使图像发生扭曲。具体过程如下：
1. 指定错切的倾斜角度。
2. 根据指定的倾斜角度对图像进行错切。
3. 生成新的图像。

错切公式：$x^{\prime}=x+\tan(\theta)y, y^{\prime}=y$

其中$(x', y')$是图像在错切之后的坐标。

### 3.4.5 仿射
仿射(Affine) 是指将图像进行仿射变换，包括平移、旋转、缩放、错切。具体过程如下：
1. 指定仿射变换矩阵。
2. 根据指定的仿射变换矩阵对图像进行仿射变换。
3. 生成新的图像。

仿射公式：$x^{\prime}=Ax+By+Cx', y^{\prime}=Dx+Ey+Fz'$

其中$(x^{\prime}, y^{\prime})$是图像在仿射变换之后的坐标。

### 3.4.6 透视图
透视图(Perspective View) 是指将图像进行透视变换，从三维变换到二维。具体过程如下：
1. 指定透视变换参数。
2. 根据指定的透视变换参数，将三维图像转换到二维图像。
3. 生成新的图像。

透视图公式：$x^{\prime}=(1+\alpha xy+bz)X, y^{\prime}=(1+\gamma xy+dZ)Y$

其中$(x^{\prime}, y^{\prime})$是图像在透视变换之后的坐标。

## 3.5 噪声添加
噪声添加(Noise Addition) 是指将模拟的噪声添加到图像中，比如椒盐噪声、高斯噪声、像素级别的噪声。
### 3.5.1 椒盐噪声
椒盐噪声(Salt and Pepper Noise) 是指随机地替换像素值为黑色或白色。具体过程如下：
1. 指定噪声的比例。
2. 替换图像中的每一个像素点，以增加椒盐噪声。
3. 生成新的图像。

椒盐噪声公式：$I_{noise}(x,y)\in \{0,1\}, I_{noise}(x,y)=P(0.5), \ p=noise\_ratio$

其中$p$表示噪声的比例。

### 3.5.2 高斯噪声
高斯噪声(Gaussian Noise) 是指随机地生成正太分布的噪声。具体过程如下：
1. 指定噪声的标准差。
2. 随机地生成正太分布的噪声。
3. 添加噪声到图像中。

高斯噪声公式：$I_{noise}(x,y)=\mathcal{N}(mean, stddev^2), mean=0, stddev=$噪声的标准差

### 3.5.3 像素级别的噪声
像素级别的噪声(Pixel Level Noise) 是指对每个像素点赋予一个随机的高斯分布的噪声。具体过程如下：
1. 指定噪声的标准差。
2. 生成一个正太分布的噪声。
3. 将噪声添加到每个像素点。

像素级别的噪声公式：$I_{noise}(x,y)=I(x,y)+\mathcal{N}(0, noise\_stddev^2)$

其中$noise\_stddev$表示噪声的标准差。

## 3.6 光学变换
光学变换(Photometric Transformation) 是指对图像进行色彩增强和亮度变换。常见的光学变换方法包括亮度增强、对比度增强、颜色空间转换等。
### 3.6.1 亮度增强
亮度增强(Brightness Enhancement) 是指对图像进行亮度调节，提升图像的饱和度。具体过程如下：
1. 指定亮度调节的倍数。
2. 提升图像的亮度。
3. 生成新的图像。

亮度增强公式：$I'=a\cdot I$

其中$a$是亮度增强的倍数。

### 3.6.2 对比度增强
对比度增强(Contrast Enhancement) 是指对图像进行对比度调节，提升图像的对比度。具体过程如下：
1. 指定对比度调节的倍数。
2. 提升图像的对比度。
3. 生成新的图像。

对比度增强公式：$I'\leftarrow \frac{a}{1-K^\alpha (a-1)}I$

其中$a$是对比度调节的倍数，$K^\alpha (a-1)$表示对比度调整公式。

### 3.6.3 颜色空间转换
颜色空间转换(Color Space Conversion) 是指将图像从一种颜色空间转换到另一种颜色空间。常用的颜色空间包括RGB、HSV、CMYK、XYZ等。具体过程如下：
1. 选择目标颜色空间。
2. 将图像转换到目标颜色空间。
3. 生成新的图像。

颜色空间转换公式：$I_{target}=\mu+\frac{\sum_{i=1}^n \lambda_i F_i(I_{src})}{\sum_{j=1}^m w_j}$

其中$F_i(I_{src})$表示颜色空间$i$下的颜色模型，$\lambda_i$表示权重，$w_j$表示颜色空间之间的相似度。

## 3.7 模糊操作
模糊操作(Blurring Operation) 是指对图像进行模糊操作，如平滑滤波、高斯滤波等。常用的模糊操作方法包括均值滤波、方框滤波、椒盐滤波、中值滤波等。
### 3.7.1 均值滤波
均值滤波(Mean Filtering) 是指对图像进行均值滤波，将邻域的像素值平均化。具体过程如下：
1. 指定滤波窗口的大小。
2. 计算滤波窗口的均值。
3. 将图像中对应位置的像素值置为均值。
4. 生成新的图像。

均值滤波公式：$I'(x,y)=\frac{1}{W^2}\sum_{i=-\frac{W}{2}}^{\frac{W}{2}}\sum_{j=-\frac{W}{2}}^{\frac{W}{2}}I(x_i+i,y_j+j)$

其中$W$表示滤波窗口的大小。

### 3.7.2 方框滤波
方框滤波(Box Filtering) 是指对图像进行方框滤波，将邻域的像素值进行叠加。具体过程如下：
1. 指定滤波窗口的大小。
2. 计算滤波窗口中每个元素的权重。
3. 将图像中对应位置的像素值乘以对应的权重。
4. 生成新的图像。

方框滤波公式：$I'(x,y)=\frac{\sum_{i=-W/2}^{W/2}\sum_{j=-W/2}^{W/2}I(x_i+i,y_j+j)W(i,j)}{\sum_{i=-W/2}^{W/2}\sum_{j=-W/2}^{W/2}W(i,j)}$

其中$W(i,j)$表示滤波窗口的权重。

### 3.7.3 椒盐滤波
椒盐滤波(Salt And Pepper Filtering) 是指对图像进行椒盐滤波，将图像分为两个部分，椒（白色）部分和沙（黑色）部分。具体过程如下：
1. 分别计算图像的椒部分和沙部分。
2. 将椒部分用最大值替代，沙部分用最小值替代。
3. 生成新的图像。

椒盐滤波公式：$I'(x,y)=\text{min}_{b}(I(x,y)), I'(x,y)=\text{max}_{w}(I(x,y))$

其中$b$表示白色，$w$表示黑色。

### 3.7.4 中值滤波
中值滤波(Median Filtering) 是指对图像进行中值滤波，将邻域的像素值排序后取中间值。具体过程如下：
1. 指定滤波窗口的大小。
2. 对图像进行排序。
3. 将图像中对应位置的像素值置为排序后的中值。
4. 生成新的图像。

中值滤波公式：$I'(x,y)=\text{median}_{i,j}|I(x_i+i,y_j+j)|$

其中$\text{median}_{i,j}|I(x_i+i,y_j+j)|$表示滤波窗口$W\times W$的中值，$x_i+i,\ y_j+j$表示滤波窗口中点的坐标。

## 3.8 遮挡操作
遮挡操作(Occlusion Operation) 是指先对原始图像随机擦除一部分区域，然后在该区域内绘制新物体，来生成新的图像。常用的遮挡操作方法包括马赛克、撞色、徐帧、灰度化等。
### 3.8.1 马赛克
马赛克(Mosaic) 是指将原始图像中部分区域打乱，重新组合成新的图像。具体过程如下：
1. 指定马赛克块的大小。
2. 对原始图像随机采样，形成马赛克块。
3. 随机对各个马赛克块的颜色进行修改。
4. 将所有马赛克块重新组合起来。
5. 生成新的图像。

马赛克公式：$I_{mosaic}(x,y)=\text{min}_{w\in mosaic block}(I(w))$

其中$w\in mosaic block$表示马赛克块的中心坐标。

### 3.8.2 撞色
撞色(Pixelate) 是指将原始图像的某些区域缩小，以方便人眼观看。具体过程如下：
1. 指定撞色块的大小。
2. 对原始图像中的撞色块进行缩小。
3. 生成新的图像。

撞色公式：$I_{pixelated}(x,y)=\frac{1}{(W/s)^2}\sum_{i=\lfloor x/(W/s) \rfloor - s/2}^{\lceil x/(W/s) \rceil + s/2}~\sum_{j=\lfloor y/(H/s) \rfloor - s/2}^{\lceil y/(H/s) \rceil + s/2} I(\frac{i}{s}W,(j)/s H)$

其中$s$表示撞色块的大小。

### 3.8.3 徐帧
徐帧(Dodge And Frame) 是指对原始图像进行一定的虚化，让图像中暗部暗淡，明部浓淡，从而得到新的图像。具体过程如下：
1. 将图像的明暗区域分成两个部分。
2. 对原始图像的暗部进行上抹（增强），明部进行下抹（减弱）。
3. 融合两个部分，生成新的图像。

徐帧公式：$I_{dodge}(x,y)=\frac{I_{src}(x,y)+I_{mask}(x,y)}{I_{mask}(x,y)}$

其中$I_{mask}$为图像的虚化蒙版。

### 3.8.4 灰度化
灰度化(Grayscale) 是指将图像转换成黑白图像，便于查看。具体过程如下：
1. 以某个像素值作为阈值，将图像分为两个部分。
2. 将明亮部分设置为白色，暗部设置为黑色。
3. 生成新的图像。

灰度化公式：$I_{gray}(x,y)=\begin{cases} max, & I(x,y)>t \\
                            min, & I(x,y)<t
                        \end{cases}$
                        
其中$max, t$表示最大值和阈值。