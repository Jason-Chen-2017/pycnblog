                 

### 滴滴2025届校招面试高频算法题解析

#### 1. 超级快递员调度问题

**题目描述：** 滴滴要求你设计一个算法，用于优化超级快递员的调度问题。假设有 n 个快递点，每个快递点有一个快递员，快递员可以同时处理多个任务。给定一个任务列表，每个任务有一个起始位置、目的地以及截止时间。要求设计一个算法，使得快递员能够尽可能地按时完成任务。

**输入：**
- n：快递点的数量
- m：任务的数量
- tasks：一个二维数组，其中 tasks[i] = [start, end, deadline]，表示任务 i 的起始位置、目的地和截止时间。

**输出：**
- 一个数组，表示每个快递员需要完成的任务序列。

**示例：**
```
输入：
n = 4
m = 5
tasks = [
    [0, 2, 5],
    [0, 1, 3],
    [1, 3, 2],
    [2, 3, 1],
    [3, 0, 3],
]

输出：
[
    [0, 2],
    [1, 3],
    [2, 1],
    [3, 0],
    [0, 3],
]
```

**答案解析：** 这道题目可以看作是一个调度问题，需要我们设计一个贪心算法。核心思路是每次选择截止时间最紧迫的任务。具体步骤如下：

1. 对任务列表按截止时间进行排序。
2. 初始化结果数组，每个快递员都为空数组。
3. 遍历任务列表，对于每个任务，选择当前可用的快递员，并将任务添加到该快递员的任务序列中。
4. 如果没有可用的快递员，则将任务添加到最接近当前任务起始位置的快递员的任务序列中。

以下是一个可能的实现：

```go
type Task struct {
    Start, End, Deadline int
}

func schedule(tasks [][]int) [][]int {
    // 按截止时间排序任务
    sort.Slice(tasks, func(i, j int) bool {
        return tasks[i][2] < tasks[j][2]
    })

    // 初始化结果数组
    result := make([][]int, n)
    // 记录每个快递员当前可用的快递点
    available := make([]int, n)
    for i := 0; i < n; i++ {
        available[i] = i
    }

    // 遍历任务列表
    for _, task := range tasks {
        start, end, deadline := task[0], task[1], task[2]

        // 选择当前可用的快递员
        for _, v := range available {
            if result[v] == nil || result[v][0] == start {
                // 添加任务到快递员的任务序列中
                result[v] = append(result[v], task...)
                break
            }
        }

        // 如果没有可用的快递员，则选择最接近当前任务起始位置的快递员
        if len(result) == n {
            minDistance := math.MaxInt32
            for i, v := range available {
                distance := abs(end - v)
                if distance < minDistance {
                    minDistance = distance
                    result[i] = append(result[i], task...)
                }
            }
        }
    }

    return result
}
```

**时间复杂度：** O(mlogm)，其中 m 是任务的数量。主要的计算时间花费在排序上。

**空间复杂度：** O(n)，用于存储结果数组。

#### 2. 最小路径和问题

**题目描述：** 给定一个包含非负整数的 m x n 网格 grid，找出一条从左上角到右下角的最短路径，使得路径上的数字之和最小。

**输入：**
- m：网格的行数
- n：网格的列数
- grid：一个 m x n 的二维数组，其中 grid[i][j] 表示网格中 (i, j) 位置上的数字。

**输出：**
- 最短路径上的数字之和。

**示例：**
```
输入：
m = 3, n = 3
grid = [
    [2, 3, 5],
    [1, 2, 4],
    [5, 6, 2],
]

输出：
7
```

**答案解析：** 这道题目可以看作是一个动态规划问题。我们可以从左上角开始，逐步计算到每个位置的的最小路径和。具体步骤如下：

1. 初始化一个二维数组 dp，用于存储到每个位置的最小路径和。
2. 对于第一行和第一列，只能从左上角或右上角走到当前位置，因此 dp[i][j] = grid[0][i] + grid[j][0]。
3. 对于其他位置，dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]。
4. 最终的最短路径和为 dp[m-1][n-1]。

以下是一个可能的实现：

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := 0; i < m; i++ {
        dp[i] = make([]int, n)
    }

    // 初始化第一行和第一列
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    // 计算其他位置的最小路径和
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }

    return dp[m-1][n-1]
}
```

**时间复杂度：** O(mn)，其中 m 是网格的行数，n 是网格的列数。需要遍历每个位置一次。

**空间复杂度：** O(mn)，用于存储动态规划数组。

#### 3. 无重复字符的最长子串

**题目描述：** 给定一个字符串 s ，找出其中不含有重复字符的最长子串的长度。

**输入：**
- s：一个字符串

**输出：**
- 不含有重复字符的最长子串的长度。

**示例：**
```
输入：
s = "abcabcbb"

输出：
3
```

**答案解析：** 这道题目可以使用滑动窗口的方法解决。我们可以使用两个指针 left 和 right，分别表示窗口的左右边界。具体步骤如下：

1. 初始化 left 和 right 为 0，用于表示窗口的左右边界。
2. 初始化一个哈希表 d，用于记录窗口中字符的计数。
3. 遍历字符串 s，对于每个字符 s[right]：
    - 如果 s[right] 不在哈希表 d 中，或者 d[s[right]] == 0，则将 d[s[right]] 设为 1，并将 right 加 1。
    - 如果 d[s[right]] > 0，则说明 s[right] 在窗口中出现过，需要将 left 移动到 s[right] 的下一个位置，同时更新 d[s[left]]。
4. 在每次循环中，更新最长子串的长度 maxLen = max(maxLen, right - left)。
5. 返回最长子串的长度 maxLen。

以下是一个可能的实现：

```go
func lengthOfLongestSubstring(s string) int {
    n := len(s)
    left, right := 0, 0
    d := make(map[rune]int)
    maxLen := 0

    for right < n {
        if _, ok := d[s[right]]; ok {
            left = max(left, d[s[right]] + 1)
        }
        d[s[right]] = right
        maxLen = max(maxLen, right - left + 1)
        right++
    }

    return maxLen
}
```

**时间复杂度：** O(n)，其中 n 是字符串的长度。需要遍历每个字符一次。

**空间复杂度：** O(min(m, n))，其中 m 是字符集的大小，n 是字符串的长度。最多需要存储 min(m, n) 个字符的计数。

#### 4. 合并区间

**题目描述：** 给定一组区间，请你合并所有重叠的区间。

**输入：**
- intervals：一组区间，表示为 [[start1, end1], [start2, end2], ..., [startN, endN]]。其中 intervals[i] = [starti, endi]。

**输出：**
- 合并后的区间，表示为 [[start1, end1], [start2, end2], ..., [startM, endM]]。其中 M 是合并后的区间个数，并且区间已按区间起点进行升序排序。

**示例：**
```
输入：
intervals = [
    [1, 3],
    [2, 6],
    [8, 10],
    [15, 18],
]

输出：
[
    [1, 6],
    [8, 10],
    [15, 18],
]
```

**答案解析：** 这道题目可以使用排序和合并区间的方法解决。具体步骤如下：

1. 对区间数组 intervals 进行排序，按照区间的起点进行升序排序。
2. 初始化结果数组 res，用于存储合并后的区间。
3. 遍历排序后的区间数组 intervals：
    - 如果 res 为空，或者当前区间的起点大于 res 中最后一个区间的终点，则将当前区间添加到 res 中。
    - 如果当前区间的起点小于等于 res 中最后一个区间的终点，则将当前区间的终点更新为 res 中最后一个区间的终点。
4. 返回结果数组 res。

以下是一个可能的实现：

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    res := [][]int{}
    for _, interval := range intervals {
        if len(res) == 0 || interval[0] > res[len(res)-1][1] {
            res = append(res, interval)
        } else {
            res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
        }
    }

    return res
}
```

**时间复杂度：** O(nlogn)，其中 n 是区间数组的长度。主要的计算时间花费在排序上。

**空间复杂度：** O(n)，用于存储结果数组。

#### 5. 有效数字

**题目描述：** 给定一个字符串 s ，判断它是否是有效的数字。

**输入：**
- s：一个字符串

**输出：**
- 如果 s 是一个有效的数字，返回 true；否则返回 false。

**示例：**
```
输入：
s = "0"

输出：
true
```

**答案解析：** 这道题目可以使用状态机的方法解决。我们可以定义以下状态：

- State0：数字状态，表示当前数字是否有效。
- State1：小数点状态，表示当前是否有小数点。
- State2：正负状态，表示当前是否有正负号。
- State3：空状态，表示当前字符串是否为空。

初始状态为 State0。具体步骤如下：

1. 初始化状态机，将所有状态都设置为 false。
2. 遍历字符串 s，对于每个字符 c：
    - 如果 c 是数字字符，则将 State0 设置为 true。
    - 如果 c 是小数点，则将 State1 设置为 true。
    - 如果 c 是正负号，则将 State2 设置为 true。
3. 返回 State0、State1 和 State2 的或运算结果。

以下是一个可能的实现：

```go
func isValidNumber(s string) bool {
    state0, state1, state2 := false, false, false

    for _, c := range s {
        if c >= '0' && c <= '9' {
            state0 = true
        } else if c == '.' {
            state1 = true
        } else if c == '+' || c == '-' {
            state2 = true
        } else {
            return false
        }
    }

    return state0 || state1 || state2
}
```

**时间复杂度：** O(n)，其中 n 是字符串的长度。需要遍历每个字符一次。

**空间复杂度：** O(1)，不需要额外空间。

#### 6. 剑指 Offer 58 - I. 翻转单词顺序

**题目描述：** 输入一个字符串，翻转字符串中的单词。

**输入：**
- s：一个字符串

**输出：**
- 翻转后的字符串。

**示例：**
```
输入：
s = "the sky is blue"

输出：
"blue is sky the"
```

**答案解析：** 这道题目可以分解为两个步骤：

1. 首先去除字符串中的空格。
2. 然后将剩余的单词进行反转。

以下是一个可能的实现：

```go
func reverseWords(s string) string {
    s = strings.TrimSpace(s)
    n := len(s)
    left, right := 0, n-1
    for left < right {
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
    words := strings.Fields(s)
    n = len(words)
    left, right := 0, n-1
    for left < right {
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
    return strings.Join(words, " ")
}
```

**时间复杂度：** O(n)，其中 n 是字符串的长度。需要遍历每个字符一次。

**空间复杂度：** O(n)，用于存储去除空格后的字符串和单词数组。

#### 7. 剑指 Offer 45. 把数组排成最小的数

**题目描述：** 输入一个整数数组，把数组里所有数字排成一个最小的数。

**输入：**
- nums：一个整数数组

**输出：**
- 最小的数字。

**示例：**
```
输入：
nums = [3, 30, 34, 5, 9]

输出：
"30539"
```

**答案解析：** 这道题目可以使用排序和拼接字符串的方法解决。具体步骤如下：

1. 将整数数组 nums 转换为字符串数组 strings。
2. 对字符串数组 strings 进行自定义排序，比较两个字符串 a 和 b 的大小，可以通过拼接 ab 和 ba 的形式比较。
3. 将排序后的字符串数组 strings 拼接成一个字符串。

以下是一个可能的实现：

```go
func minNumber(nums []int) string {
    strings := make([]string, len(nums))
    for i, num := range nums {
        strings[i] = strconv.Itoa(num)
    }
    sort.Slice(strings, func(i, j int) bool {
        a, b := strings[i]+strings[j], strings[j]+strings[i]
        return a < b
    })
    return strings.Join(strings, "")
}
```

**时间复杂度：** O(nlogn)，其中 n 是整数数组的长度。主要的计算时间花费在排序上。

**空间复杂度：** O(n)，用于存储字符串数组。

#### 8. 剑指 Offer 18. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 head 和一个整数 val ，删除链表中所有值为 val 的节点，并返回修改后的链表。

**输入：**
- head：链表的头节点
- val：需要删除的值

**输出：**
- 修改后的链表的头节点。

**示例：**
```
输入：
head = [1, 2, 6, 3, 4, 5, 6], val = 6

输出：
[1, 2, 3, 4, 5]
```

**答案解析：** 这道题目可以使用快慢指针的方法解决。具体步骤如下：

1. 初始化快指针 fast 和慢指针 slow，都指向链表的头节点 head。
2. 如果 head 的值等于 val，则将 head 更新为 head 的下一个节点，继续下一轮循环。
3. 遍历链表，对于每个节点：
    - 如果当前节点的值等于 val，则将 slow 的下一个节点更新为当前节点的下一个节点。
    - 否则，将 slow 更新为当前节点。
4. 返回链表的头节点 head。

以下是一个可能的实现：

```go
func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil || head.Val == val {
        return head.Next
    }
    fast, slow := head, head
    for fast != nil {
        if fast.Val == val {
            slow.Next = fast.Next
        } else {
            slow = fast
        }
        fast = fast.Next
    }
    return head
}
```

**时间复杂度：** O(n)，其中 n 是链表的长度。需要遍历每个节点一次。

**空间复杂度：** O(1)，不需要额外空间。

#### 9. 剑指 Offer 43. 1 的个数

**题目描述：** 输入一个整数 n ，求 1～n 中 1 出现的次数。

**输入：**
- n：一个整数

**输出：**
- 1～n 中 1 出现的次数。

**示例：**
```
输入：
n = 13

输出：
6
```

**答案解析：** 这道题目可以使用动态规划的方法解决。我们可以定义一个数组 f，其中 f[i] 表示从 1 到 i 中 1 出现的次数。具体步骤如下：

1. 初始化 f[0] 为 0。
2. 对于每个 i 从 1 到 n：
    - 如果 i 的二进制表示中 1 的个数为 k，则 f[i] = f[i-k] + k。
3. 返回 f[n]。

以下是一个可能的实现：

```go
func countDigitOne(n int) int {
    f := make([]int, n+1)
    for i := 1; i <= n; i++ {
        k := 0
        for ; i > 0; i = i >> 1 {
            if i%2 == 1 {
                k++
            }
        }
        f[i] = f[i-k] + k
    }
    return f[n]
}
```

**时间复杂度：** O(nlogn)，其中 n 是整数 n 的二进制表示中 1 的个数。

**空间复杂度：** O(n)，用于存储动态规划数组。

#### 10. 剑指 Offer 64. 最小的k个数

**题目描述：** 给定一个整数数组 arr ，找出 arr 中最小的 k 个数。例如，输入 arr = [3, 2, 1]，k = 2，输出 [1, 2]。

**输入：**
- arr：一个整数数组
- k：一个整数

**输出：**
- 最小的 k 个数。

**示例：**
```
输入：
arr = [3, 2, 1]
k = 2

输出：
[1, 2]
```

**答案解析：** 这道题目可以使用快速选择算法解决。具体步骤如下：

1. 选择 arr[0] 作为基准值 pivot。
2. 将数组分为三部分：小于 pivot 的部分、等于 pivot 的部分和大于 pivot 的部分。
3. 如果等于 pivot 的部分的长度大于 k，则继续在小于 pivot 的部分中查找最小的 k 个数。
4. 如果等于 pivot 的部分的长度小于 k，则将小于 pivot 的部分和等于 pivot 的部分合并，返回合并后的结果。

以下是一个可能的实现：

```go
func findKthLargest(arr []int, k int) int {
    left, right := 0, len(arr)-1
    for {
        pivot := arr[left]
        i, j := left, right
        for {
            for i <= j && arr[i] <= pivot {
                i++
            }
            for i <= j && arr[j] > pivot {
                j--
            }
            if i <= j {
                arr[i], arr[j] = arr[j], arr[i]
            } else {
                break
            }
        }
        arr[left], arr[j] = arr[j], arr[left]
        if j-left >= k {
            right = j - 1
        } else {
            k -= j - left
            left = i
        }
        if k == 0 {
            return arr[left]
        }
    }
}
```

**时间复杂度：** O(n)，其中 n 是数组的长度。

**空间复杂度：** O(1)，不需要额外空间。

#### 11. 剑指 Offer 57 - II. 和为指定值的连续子数组

**题目描述：** 输入一个整数数组和一个整数 target，找到和为 target 的连续子数组的起始和结束位置。如果存在多个起始位置和结束位置，返回任意一个均可。

**输入：**
- nums：一个整数数组
- target：一个整数

**输出：**
- 一个长度为 2 的数组，表示起始和结束位置。

**示例：**
```
输入：
nums = [1, 1, 1, 1, 1], target = 3

输出：
[1, 4]
```

**答案解析：** 这道题目可以使用双指针的方法解决。具体步骤如下：

1. 初始化两个指针 left 和 right，都指向数组的起始位置。
2. 初始化一个变量 sum，用于记录当前子数组的和。
3. 遍历数组，对于每个位置 right：
    - 将 nums[right] 添加到 sum 中。
    - 如果 sum 等于 target，返回 [left, right]。
    - 如果 sum 大于 target，将 left 加 1，同时更新 sum。
    - 如果 sum 小于 target，将 right 加 1。
4. 如果遍历完整个数组都没有找到和为 target 的子数组，返回 [-1, -1]。

以下是一个可能的实现：

```go
func findContinuousSubarray(nums []int, target int) []int {
    left, right := 0, 0
    sum := 0
    for right < len(nums) {
        sum += nums[right]
        for sum > target {
            sum -= nums[left]
            left++
        }
        if sum == target {
            return []int{left, right}
        }
        right++
    }
    return []int{-1, -1}
}
```

**时间复杂度：** O(n)，其中 n 是数组的长度。

**空间复杂度：** O(1)，不需要额外空间。

#### 12. 剑指 Offer 55 - II. 平衡二叉树

**题目描述：** 输入一个二叉树的根节点 root，判断是否为平衡二叉树。

**输入：**
- root：二叉树的根节点

**输出：**
- 如果是平衡二叉树，返回 true；否则返回 false。

**示例：**
```
输入：
root = [3,9,20,null,null,15,7]

输出：
true
```

**答案解析：** 这道题目可以使用递归的方法解决。具体步骤如下：

1. 递归地计算每个节点的左子树和右子树的高度，并检查它们是否平衡。
2. 如果左子树和右子树都平衡，并且它们的高度差不超过 1，则当前节点平衡。
3. 如果当前节点不平衡，返回 false。

以下是一个可能的实现：

```go
func isBalanced(root *TreeNode) bool {
    var check func(*TreeNode) bool
    check = func(node *TreeNode) bool {
        if node == nil {
            return true
        }
        leftHeight := 0
        rightHeight := 0
        if !check(node.Left) {
            return false
        }
        leftHeight = max(getHeight(node.Left), leftHeight)
        if !check(node.Right) {
            return false
        }
        rightHeight = max(getHeight(node.Right), rightHeight)
        return abs(leftHeight-rightHeight) <= 1
    }
    return check(root)
}

func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    return 1 + max(getHeight(node.Left), getHeight(node.Right))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**时间复杂度：** O(n^2)，其中 n 是二叉树的节点数。因为每个节点都会被访问两次。

**空间复杂度：** O(n)，其中 n 是二叉树的节点数。需要递归栈的空间。

#### 13. 剑指 Offer 68 - I. 判断一个数字是否是另一个数字的倍数

**题目描述：** 给定两个整数 num 和 k，判断 num 是否是 k 的倍数。例如，num = 12，k = 3，判断 12 是否是 3 的倍数。

**输入：**
- num：一个整数
- k：一个整数

**输出：**
- 如果 num 是 k 的倍数，返回 true；否则返回 false。

**示例：**
```
输入：
num = 12, k = 3

输出：
true
```

**答案解析：** 这道题目可以使用取余数的方法解决。具体步骤如下：

1. 如果 k 为 0，则 num 不能是 k 的倍数，返回 false。
2. 如果 k 不为 0，则计算 num 除以 k 的余数。
3. 如果余数为 0，则 num 是 k 的倍数，返回 true；否则返回 false。

以下是一个可能的实现：

```go
func isMultiple(num int, k int) bool {
    if k == 0 {
        return false
    }
    return num%k == 0
}
```

**时间复杂度：** O(1)，不需要遍历。

**空间复杂度：** O(1)，不需要额外空间。

#### 14. 剑指 Offer 44. 通配符匹配

**题目描述：** 给定一个字符串 (s) 和一个字符模式 (p)，实现一个支持 '.' 和 '*' 的通配符匹配。

**输入：**
- s：一个字符串
- p：一个字符模式

**输出：**
- 如果 s 能被 p 匹配，返回 true；否则返回 false。

**示例：**
```
输入：
s = "abc*def", p = "a.c*ef"

输出：
true
```

**答案解析：** 这道题目可以使用动态规划的方法解决。具体步骤如下：

1. 定义一个二维数组 dp，其中 dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符能否匹配。
2. 初始化 dp[0][0] 为 true，因为空字符串可以和空字符串匹配。
3. 对于每个 i 从 1 到 m：
    - 如果 p 的第 j 个字符是 '*', 则 dp[i][j] 取决于 dp[i-1][j-1] 或 dp[i-1][j]。
    - 如果 p 的第 j 个字符是 '.'，则 dp[i][j] 取决于 dp[i-1][j-1]。
    - 如果 p 的第 j 个字符是字母，则 dp[i][j] 取决于 dp[i-1][j-1]。
4. 返回 dp[m][n]。

以下是一个可能的实现：

```go
func isMatch(s string, p string) bool {
    m, n := len(s), len(p)
    dp := make([][]bool, m+1)
    for i := range dp {
        dp[i] = make([]bool, n+1)
    }
    dp[0][0] = true
    for j := 1; j <= n; j++ {
        if p[j-1] == '*' {
            dp[0][j] = dp[0][j-1]
        }
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if p[j-1] == '*' {
                dp[i][j] = dp[i][j-1] || dp[i-1][j]
            } else if p[j-1] == '?' || s[i-1] == p[j-1] {
                dp[i][j] = dp[i-1][j-1]
            }
        }
    }
    return dp[m][n]
}
```

**时间复杂度：** O(mn)，其中 m 和 n 分别是字符串 s 和 p 的长度。

**空间复杂度：** O(mn)，用于存储动态规划数组。

#### 15. 剑指 Offer 59 - II. 队列的最大值

**题目描述：** 请实现一个队列，支持普通队列的基本功能（push、pop、peek）以及获取队列的最大值。

**输入：**
- queue：队列
- operations：操作序列

**输出：**
- 对应的操作结果

**示例：**
```
输入：
queue = Queue()
operations = [
    ["push", [1]],
    ["push", [2]],
    ["peekMax", []],
    ["pop", []],
    ["peekMax", []],
]

输出：
[
    [1],
    [2],
    2,
    1,
    2,
]
```

**答案解析：** 为了实现队列的最大值功能，我们可以使用两个队列：一个队列用于存储正常的元素，另一个队列用于存储当前的最大值。具体步骤如下：

1. 在插入元素时，将元素插入到正常的队列中，同时检查该元素是否大于当前最大值。如果大于，将该元素插入到最大值队列的末尾。否则，将当前最大值队列的最后一个元素插入到最大值队列的末尾。
2. 在删除元素时，如果删除的元素是当前最大值，则需要更新最大值队列。
3. 在获取最大值时，直接返回最大值队列的最后一个元素。

以下是一个可能的实现：

```go
type Queue struct {
    queue []int
    maxQueue []int
}

func Constructor() Queue {
    return Queue{
        queue: make([]int, 0),
        maxQueue: make([]int, 0),
    }
}

func (this *Queue) Push(value int) {
    this.queue = append(this.queue, value)
    if len(this.maxQueue) == 0 || value > this.maxQueue[len(this.maxQueue)-1] {
        this.maxQueue = append(this.maxQueue, value)
    } else {
        this.maxQueue = append(this.maxQueue, this.maxQueue[len(this.maxQueue)-1])
    }
}

func (this *Queue) Pop() int {
    if len(this.queue) == 0 {
        return -1
    }
    value := this.queue[0]
    this.queue = this.queue[1:]
    if value == this.maxQueue[0] {
        this.maxQueue = this.maxQueue[1:]
    }
    return value
}

func (this *Queue) PeekMax() int {
    if len(this.maxQueue) == 0 {
        return -1
    }
    return this.maxQueue[len(this.maxQueue)-1]
}
```

**时间复杂度：** O(1)，所有操作的时间复杂度都是 O(1)。

**空间复杂度：** O(n)，其中 n 是队列的长度。需要额外的空间存储最大值队列。

#### 16. 剑指 Offer 59 - I. 滑动窗口的最大值

**题目描述：** 给定一个整数数组 nums 和一个整数 k，请找出 nums 中的滑动窗口中的最大值。

**输入：**
- nums：一个整数数组
- k：一个整数

**输出：**
- 滑动窗口中的最大值。

**示例：**
```
输入：
nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3

输出：
[3, 3, 5, 5, 6]
```

**答案解析：** 为了实现滑动窗口的最大值功能，我们可以使用一个双端队列。具体步骤如下：

1. 遍历数组 nums，对于每个元素：
    - 如果双端队列不为空，并且当前元素大于双端队列的最后一个元素，则将双端队列的最后一个元素弹出。
    - 将当前元素入队。
    - 如果当前元素的位置大于滑动窗口的起始位置 k-1，则将当前元素出队。
2. 返回滑动窗口中的最大值。

以下是一个可能的实现：

```go
func maxSlidingWindow(nums []int, k int) []int {
    deque := []int{}
    result := []int{}
    for i, v := range nums {
        for len(deque) > 0 && v > deque[len(deque)-1] {
            deque = deque[:len(deque)-1]
        }
        deque = append(deque, v)
        if i >= k-1 {
            result = append(result, deque[0])
            if deque[0] == nums[i-k+1] {
                deque = deque[1:]
            }
        }
    }
    return result
}
```

**时间复杂度：** O(n)，其中 n 是数组 nums 的长度。需要遍历每个元素一次。

**空间复杂度：** O(k)，其中 k 是滑动窗口的大小。需要额外的空间存储双端队列。

#### 17. 剑指 Offer 50. 第一个只出现一次的字符

**题目描述：** 在字符串 s 中找出第一个只出现一次的字符，并返回它的 ASCII 码。如果不存在，返回 -1。

**输入：**
- s：一个字符串

**输出：**
- 第一个只出现一次的字符的 ASCII 码。

**示例：**
```
输入：
s = "abaccdeff"

输出：
97
```

**答案解析：** 为了找出第一个只出现一次的字符，我们可以使用一个哈希表记录每个字符的出现次数。具体步骤如下：

1. 初始化一个哈希表 d，用于记录字符的出现次数。
2. 遍历字符串 s，对于每个字符 c：
    - 将 d[c] 加 1。
3. 遍历字符串 s，对于每个字符 c：
    - 如果 d[c] 等于 1，则返回 c 的 ASCII 码。
4. 如果遍历完字符串 s 都没有找到只出现一次的字符，返回 -1。

以下是一个可能的实现：

```go
func firstUniqChar(s string) int {
    d := make(map[rune]int)
    for _, c := range s {
        d[c]++
    }
    for _, c := range s {
        if d[c] == 1 {
            return int(c)
        }
    }
    return -1
}
```

**时间复杂度：** O(n)，其中 n 是字符串的长度。需要遍历字符串 s 两次。

**空间复杂度：** O(n)，其中 n 是字符串的长度。需要额外的空间存储哈希表。

#### 18. 剑指 Offer 16. 数值的整数次方

**题目描述：** 实现函数 doublePower，用于计算给定数 x 的 n 次方。

**输入：**
- x：一个浮点数
- n：一个整数

**输出：**
- x 的 n 次方的结果。

**示例：**
```
输入：
x = 2.00000, n = 10

输出：
1024000000.00000
```

**答案解析：** 为了计算 x 的 n 次方，我们可以使用快速幂的方法。具体步骤如下：

1. 如果 n 等于 0，则返回 1。
2. 如果 n 等于 1，则返回 x。
3. 如果 n 为负数，则返回 1 / x 的 -n 次方。
4. 初始化 result 为 1。
5. 将 n 除以 2，循环直到 n 为 0：
    - 如果 n 是奇数，则 result 乘以 x。
    - 将 x 乘以自身。
    - 将 n 减 1。
6. 返回 result。

以下是一个可能的实现：

```go
func doublePower(x float64, n int) float64 {
    if n == 0 {
        return 1
    }
    if n == 1 {
        return x
    }
    if n < 0 {
        return 1 / doublePower(x, -n)
    }
    result := 1
    for n > 0 {
        if n%2 == 1 {
            result *= x
        }
        x *= x
        n /= 2
    }
    return result
}
```

**时间复杂度：** O(logn)，其中 n 是整数 n 的二进制表示中 1 的个数。

**空间复杂度：** O(1)，不需要额外空间。

#### 19. 剑指 Offer 17. 打印从 1 到最大的 n 位数

**题目描述：** 打印从 1 到最大的 n 位数。

**输入：**
- n：一个整数

**输出：**
- 从 1 到最大的 n 位数的序列。

**示例：**
```
输入：
n = 3

输出：
[
    "1", "2", "3", "4", "5", "6", "7", "8", "9", 
    "10", "11", "12", "13", "14", "15", "16", "17", 
    "18", "19", "20", ...
]
```

**答案解析：** 为了打印从 1 到最大的 n 位数，我们可以使用字符串的方法。具体步骤如下：

1. 初始化一个字符串数组 result，用于存储打印的结果。
2. 遍历从 1 到最大的 n 位数：
    - 将当前数转换为字符串，并添加到 result 中。
3. 返回 result。

以下是一个可能的实现：

```go
func printNumbers(n int) []string {
    result := make([]string, 0)
    for i := 1; i <= pow(10, n)-1; i++ {
        result = append(result, strconv.Itoa(i))
    }
    return result
}

func pow(a, b int) int {
    result := 1
    for b > 0 {
        if b%2 == 1 {
            result *= a
        }
        a *= a
        b /= 2
    }
    return result
}
```

**时间复杂度：** O(nlogn)，其中 n 是整数 n 的二进制表示中 1 的个数。

**空间复杂度：** O(n)，其中 n 是整数 n 的二进制表示中 1 的个数。需要额外的空间存储字符串数组。

#### 20. 剑指 Offer 27. 二叉树的镜像

**题目描述：** 请完成一个函数，输入一个二叉树，该函数输出它的镜像。

**输入：**
- root：二叉树的根节点

**输出：**
- 镜像后的二叉树。

**示例：**
```
输入：
root = [4,2,7,1,3,6,9]

输出：
[4,7,2,9,6,3,1]
```

**答案解析：** 为了实现二叉树的镜像，我们可以使用递归的方法。具体步骤如下：

1. 如果 root 为空，返回空。
2. 递归地交换 root 的左右子节点。
3. 返回 root。

以下是一个可能的实现：

```go
func mirrorTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left)
    return root
}
```

**时间复杂度：** O(n)，其中 n 是二叉树的节点数。需要遍历每个节点一次。

**空间复杂度：** O(n)，其中 n 是二叉树的节点数。需要递归栈的空间。

### 总结

本文对滴滴2025届校招面试中的高频算法题进行了详细解析，涵盖了从数据结构到算法的各个方面，包括字符串处理、动态规划、排序、递归等。通过这些题目，我们可以更好地理解和掌握各种算法和技巧，提高面试能力。在解答过程中，我们尽量使用简单易懂的方法，同时注重代码的可读性和性能。希望这篇文章对您的面试准备有所帮助！如果您有其他问题或者需要进一步的解析，请随时提问。祝您面试顺利，成功进入心仪的公司！

