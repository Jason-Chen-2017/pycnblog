                 

### 从经典开始：奠定基础认知

#### 1. 常见排序算法及时间复杂度

**题目：** 请简要描述几种常见的排序算法，并说明它们的时间复杂度。

**答案：**

* 冒泡排序（Bubble Sort）：O(n²)
* 选择排序（Selection Sort）：O(n²)
* 插入排序（Insertion Sort）：O(n²)
* 快速排序（Quick Sort）：O(nlogn)
* 归并排序（Merge Sort）：O(nlogn)
* 堆排序（Heap Sort）：O(nlogn)

**解析：** 这些排序算法都是基于不同的原理和策略进行排序的。冒泡排序、选择排序和插入排序是比较简单的排序算法，但时间复杂度较高。快速排序、归并排序和堆排序是更高效的排序算法，时间复杂度在 O(nlogn) 左右。快速排序通常被认为是平均性能最好的排序算法。

#### 2. 链表常见操作

**题目：** 请描述链表常见的基本操作，并给出对应的代码示例。

**答案：**

* 创建链表：`Node* createList(int n)`  
* 添加节点：`void addNode(Node* head, int val)`  
* 删除节点：`void deleteNode(Node* head, int val)`  
* 遍历链表：`void printList(Node* head)`

**示例代码：**

```c++
#include <iostream>
using namespace std;

struct Node {
    int val;
    Node* next;
};

Node* createList(int n) {
    Node* head = new Node();
    head->val = 0;
    head->next = nullptr;
    Node* current = head;
    for (int i = 1; i <= n; i++) {
        Node* newNode = new Node();
        newNode->val = i;
        newNode->next = nullptr;
        current->next = newNode;
        current = newNode;
    }
    return head;
}

void addNode(Node* head, int val) {
    Node* newNode = new Node();
    newNode->val = val;
    newNode->next = nullptr;
    Node* current = head;
    while (current->next != nullptr) {
        current = current->next;
    }
    current->next = newNode;
}

void deleteNode(Node* head, int val) {
    Node* current = head;
    while (current->next != nullptr) {
        if (current->next->val == val) {
            Node* temp = current->next;
            current->next = temp->next;
            delete temp;
            return;
        }
        current = current->next;
    }
}

void printList(Node* head) {
    Node* current = head->next;
    while (current != nullptr) {
        cout << current->val << " ";
        current = current->next;
    }
    cout << endl;
}

int main() {
    Node* head = createList(5);
    addNode(head, 10);
    deleteNode(head, 3);
    printList(head);
    return 0;
}
```

**解析：** 链表是一种常用的线性数据结构，它由一系列节点组成，每个节点包含一个数据元素和一个指向下一个节点的指针。在这个示例中，我们实现了链表的基本操作，包括创建链表、添加节点、删除节点和遍历链表。

#### 3. 红黑树的基本操作

**题目：** 请描述红黑树的基本操作，并给出对应的代码示例。

**答案：**

* 插入节点：`void insert(int val)`  
* 删除节点：`void delete(int val)`  
* 搜索节点：`Node* search(int val)`  
* 中序遍历：`void inorder(Node* node)`

**示例代码：**

```c++
#include <iostream>
using namespace std;

struct Node {
    int val;
    Node* left;
    Node* right;
    Node* parent;
    char color;
};

class RBTree {
public:
    RBTree() {
        root = nullptr;
    }

    void insert(int val) {
        Node* newNode = new Node();
        newNode->val = val;
        newNode->left = nullptr;
        newNode->right = nullptr;
        newNode->parent = nullptr;
        newNode->color = 'R';

        if (root == nullptr) {
            root = newNode;
        } else {
            Node* current = root;
            Node* parent = nullptr;
            while (current != nullptr) {
                parent = current;
                if (val < current->val) {
                    current = current->left;
                } else {
                    current = current->right;
                }
            }
            if (val < parent->val) {
                parent->left = newNode;
            } else {
                parent->right = newNode;
            }
            newNode->parent = parent;
        }

        fixInsert(newNode);
    }

    void delete(int val) {
        Node* node = search(val);
        if (node == nullptr) {
            return;
        }

        if (node->left == nullptr || node->right == nullptr) {
            Node* child = node->left != nullptr ? node->left : node->right;
            if (node->parent == nullptr) {
                root = child;
            } else if (node == node->parent->left) {
                node->parent->left = child;
            } else {
                node->parent->right = child;
            }
            child->parent = node->parent;
        } else {
            Node* successor = getSuccessor(node);
            node->val = successor->val;
            delete(successor);
        }

        fixDelete(node);
    }

    Node* search(int val) {
        Node* current = root;
        while (current != nullptr) {
            if (val == current->val) {
                return current;
            } else if (val < current->val) {
                current = current->left;
            } else {
                current = current->right;
            }
        }
        return nullptr;
    }

    void inorder(Node* node) {
        if (node != nullptr) {
            inorder(node->left);
            cout << node->val << " ";
            inorder(node->right);
        }
    }

private:
    Node* root;

    void fixInsert(Node* node) {
        while (node->parent != nullptr && node->parent->color == 'R') {
            Node* parent = node->parent;
            Node* grandParent = parent->parent;

            if (parent == grandParent->left) {
                Node* uncle = grandParent->right;

                if (uncle != nullptr && uncle->color == 'R') {
                    parent->color = 'B';
                    uncle->color = 'B';
                    grandParent->color = 'R';
                    node = grandParent;
                } else {
                    if (node == parent->right) {
                        rotateLeft(parent);
                        node = node->left;
                    }
                    rotateRight(grandParent);
                    swapColors(parent, grandParent);
                }
            } else {
                Node* uncle = grandParent->left;

                if (uncle != nullptr && uncle->color == 'R') {
                    parent->color = 'B';
                    uncle->color = 'B';
                    grandParent->color = 'R';
                    node = grandParent;
                } else {
                    if (node == parent->left) {
                        rotateRight(parent);
                        node = node->right;
                    }
                    rotateLeft(grandParent);
                    swapColors(parent, grandParent);
                }
            }
        }

        root->color = 'B';
    }

    void fixDelete(Node* node) {
        Node* x = nullptr;
        while (node != root && node->color == 'B') {
            if (node == node->parent->left) {
                Node* W = node->parent->right;

                if (W->color == 'R') {
                    W->color = 'B';
                    rotateLeft(node->parent);
                    W = node->parent->right;
                }

                if (W->left->color == 'R' && W->right->color == 'R') {
                    W->color = 'R';
                    node = node->parent;
                    continue;
                }

                if (W->left->color == 'R') {
                    W->right->color = 'B';
                    rotateLeft(W);
                    W = node->parent->right;
                }

                W->left->color = 'B';
                rotateRight(node->parent);
                x = root;
            } else {
                Node* W = node->parent->left;

                if (W->color == 'R') {
                    W->color = 'B';
                    rotateRight(node->parent);
                    W = node->parent->left;
                }

                if (W->right->color == 'R' && W->left->color == 'R') {
                    W->color = 'R';
                    node = node->parent;
                    continue;
                }

                if (W->right->color == 'R') {
                    W->left->color = 'B';
                    rotateRight(W);
                    W = node->parent->left;
                }

                W->right->color = 'B';
                rotateLeft(node->parent);
                x = root;
            }
        }

        node->color = 'B';
        if (x != nullptr) {
            if (x == root) {
                x->color = 'B';
            } else if (x == x->parent->left) {
                x->parent->left = nullptr;
            } else {
                x->parent->right = nullptr;
            }
            delete x;
        }
    }

    void rotateLeft(Node* node) {
        Node* temp = node->right;
        node->right = temp->left;

        if (temp->left != nullptr) {
            temp->left->parent = node;
        }

        temp->parent = node->parent;

        if (node->parent == nullptr) {
            root = temp;
        } else if (node == node->parent->left) {
            node->parent->left = temp;
        } else {
            node->parent->right = temp;
        }

        temp->left = node;
        node->parent = temp;
    }

    void rotateRight(Node* node) {
        Node* temp = node->left;
        node->left = temp->right;

        if (temp->right != nullptr) {
            temp->right->parent = node;
        }

        temp->parent = node->parent;

        if (node->parent == nullptr) {
            root = temp;
        } else if (node == node->parent->right) {
            node->parent->right = temp;
        } else {
            node->parent->left = temp;
        }

        temp->right = node;
        node->parent = temp;
    }

    void swapColors(Node* x, Node* y) {
        char temp = x->color;
        x->color = y->color;
        y->color = temp;
    }

    Node* getSuccessor(Node* node) {
        Node* successor = node->right;
        if (successor->color == 'R') {
            successor = successor->left;
        }
        return successor;
    }
};

int main() {
    RBTree tree;
    tree.insert(10);
    tree.insert(5);
    tree.insert(15);
    tree.insert(3);
    tree.insert(7);
    tree.insert(12);
    tree.insert(18);

    cout << "Inorder traversal of the given tree:" << endl;
    tree.inorder(tree.root);

    cout << endl << "Deleting node with value 3:" << endl;
    tree.delete(3);
    tree.inorder(tree.root);

    cout << endl << "Deleting node with value 18:" << endl;
    tree.delete(18);
    tree.inorder(tree.root);

    return 0;
}
```

**解析：** 红黑树是一种自平衡二叉查找树，它通过特定的规则保持树的平衡，以确保查找、插入和删除操作的时间复杂度都在 O(logn) 左右。在这个示例中，我们实现了红黑树的基本操作，包括插入、删除和搜索。

#### 4. 二分查找算法

**题目：** 请描述二分查找算法的基本思想和实现方式。

**答案：**

* 基本思想：将有序数组划分为左右两个子数组，取中间位置的元素与目标元素比较，如果中间位置的元素等于目标元素，则返回中间位置的下标；如果中间位置的元素大于目标元素，则在左子数组中继续查找；如果中间位置的元素小于目标元素，则在右子数组中继续查找，直到找到目标元素或子数组为空。
* 实现方式：

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1
```

**解析：** 二分查找算法是一种高效的查找算法，时间复杂度为 O(logn)。它通过不断将搜索范围缩小一半，从而快速找到目标元素。在实现二分查找时，需要注意处理好循环条件，以避免陷入死循环。

#### 5. 字符串匹配算法

**题目：** 请描述几种常见的字符串匹配算法，并说明它们的时间复杂度。

**答案：**

* 原始模式匹配算法（Brute-Force Algorithm）：O(n*m)
* KMP 算法：O(n+m)
* RK 算法：O(n+m)
* BM 算法：O(n+m)

**解析：** 这些字符串匹配算法都是用于在主字符串中查找子字符串的方法。原始模式匹配算法是最简单的一种，但时间复杂度较高。KMP 算法和 RK 算法都是基于部分匹配表（Partial Match Table）的优化算法，时间复杂度较低。BM 算法是一种高效的字符串匹配算法，但实现相对复杂。

#### 6. 动态规划算法

**题目：** 请描述动态规划算法的基本思想和实现方式。

**答案：**

* 基本思想：将复杂问题分解为更小的子问题，并利用子问题的解来构建原问题的解。动态规划通常使用一个数组来存储子问题的解，避免重复计算。
* 实现方式：

```python
def fibonacci(n):
    if n <= 1:
        return n

    dp = [0] * (n + 1)
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```

**解析：** 动态规划算法是一种用于求解最优子结构问题的算法。它通过将复杂问题分解为更小的子问题，并利用子问题的解来构建原问题的解，从而避免重复计算。在实现动态规划时，通常使用一个数组来存储子问题的解。

#### 7. 队列和栈的实现

**题目：** 请描述队列和栈的数据结构及其实现方式。

**答案：**

* 队列（Queue）：队列是一种先进先出（FIFO）的数据结构，元素按照插入顺序依次出队。

```python
class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)

    def is_empty(self):
        return len(self.items) == 0
```

* 栈（Stack）：栈是一种后进先出（LIFO）的数据结构，元素按照插入顺序的逆序依次出栈。

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0
```

**解析：** 队列和栈是两种基本的数据结构，它们在计算机科学和编程中广泛应用。队列通常用于模拟等待队列，而栈则常用于实现递归、计算表达式的值等场景。在实现队列和栈时，可以使用数组或链表作为底层数据结构。

#### 8. 单链表和双向链表的实现

**题目：** 请描述单链表和双向链表的数据结构及其实现方式。

**答案：**

* 单链表（Singly Linked List）：单链表是一种由节点组成的线性结构，每个节点包含一个数据和指向下一个节点的指针。

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()
```

* 双向链表（Doubly Linked List）：双向链表是一种由节点组成的线性结构，每个节点包含一个数据和指向前后节点的指针。

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def print_list(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()
```

**解析：** 单链表和双向链表是两种常用的链表结构，它们在计算机科学和编程中广泛应用。单链表只包含一个指向下一个节点的指针，而双向链表包含一个指向前后节点的指针。在实现单链表和双向链表时，可以使用节点类和数据结构类来表示和操作链表。

#### 9. 二叉树的遍历算法

**题目：** 请描述二叉树的遍历算法，并给出先序遍历、中序遍历和后序遍历的实现。

**答案：**

* 先序遍历（Pre-order Traversal）：先访问根节点，然后递归遍历左子树和右子树。

```python
def pre_order_traversal(root):
    if root:
        print(root.val, end=" ")
        pre_order_traversal(root.left)
        pre_order_traversal(root.right)
```

* 中序遍历（In-order Traversal）：先递归遍历左子树，然后访问根节点，最后递归遍历右子树。

```python
def in_order_traversal(root):
    if root:
        in_order_traversal(root.left)
        print(root.val, end=" ")
        in_order_traversal(root.right)
```

* 后序遍历（Post-order Traversal）：先递归遍历左子树，然后递归遍历右子树，最后访问根节点。

```python
def post_order_traversal(root):
    if root:
        post_order_traversal(root.left)
        post_order_traversal(root.right)
        print(root.val, end=" ")
```

**解析：** 二叉树的遍历算法是遍历二叉树的基本操作，包括先序遍历、中序遍历和后序遍历。先序遍历首先访问根节点，然后递归遍历左子树和右子树；中序遍历先递归遍历左子树，然后访问根节点，最后递归遍历右子树；后序遍历先递归遍历左子树，然后递归遍历右子树，最后访问根节点。

#### 10. 图的遍历算法

**题目：** 请描述图的遍历算法，并给出深度优先搜索（DFS）和广度优先搜索（BFS）的实现。

**答案：**

* 深度优先搜索（DFS）：从起始节点开始，沿着一条路径一直向下搜索，直到达到叶子节点，然后回溯到上一个节点，继续沿着另一条路径搜索。

```python
def dfs(graph, node, visited):
    visited.add(node)
    print(node, end=" ")
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

def dfs_iterative(graph, start):
    stack = [start]
    visited = set()
    while stack:
        node = stack.pop()
        if node not in visited:
            print(node, end=" ")
            visited.add(node)
            stack.extend(graph[node])
```

* 广度优先搜索（BFS）：从起始节点开始，先访问所有与起始节点相邻的节点，然后依次访问这些节点的相邻节点，直到达到目标节点。

```python
from collections import deque

def bfs(graph, start):
    queue = deque([start])
    visited = set()
    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node, end=" ")
            visited.add(node)
            queue.extend(graph[node])
```

**解析：** 图的遍历算法包括深度优先搜索和广度优先搜索。深度优先搜索从起始节点开始，沿着一条路径一直向下搜索，直到达到叶子节点，然后回溯到上一个节点，继续沿着另一条路径搜索；广度优先搜索从起始节点开始，先访问所有与起始节点相邻的节点，然后依次访问这些节点的相邻节点，直到达到目标节点。深度优先搜索通常使用递归或栈来实现，而广度优先搜索通常使用队列来实现。

#### 11. 堆排序算法

**题目：** 请描述堆排序算法的基本思想和实现方式。

**答案：**

* 基本思想：堆排序算法首先将无序数组构建成一个最大堆（Max Heap），然后逐步将堆顶元素（最大值）移除，最终得到一个有序数组。

* 实现方式：

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("Sorted array:", arr)
```

**解析：** 堆排序算法是一种基于堆数据结构的排序算法，时间复杂度为 O(nlogn)。它首先将无序数组构建成一个最大堆，然后逐步将堆顶元素（最大值）移除，最终得到一个有序数组。在实现堆排序时，需要先实现堆的插入和删除操作，然后使用这些操作来构建最大堆和排序数组。

#### 12. 快速排序算法

**题目：** 请描述快速排序算法的基本思想和实现方式。

**答案：**

* 基本思想：快速排序算法通过选取一个基准元素，将数组划分为两部分，使得左侧的所有元素都比基准元素小，右侧的所有元素都比基准元素大，然后递归地对左右两部分进行排序。

* 实现方式：

```python
def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

arr = [10, 7, 8, 9, 1, 5]
quick_sort(arr, 0, len(arr) - 1)
print("Sorted array:", arr)
```

**解析：** 快速排序算法是一种高效的排序算法，时间复杂度为 O(nlogn)。它通过选取一个基准元素，将数组划分为两部分，然后递归地对左右两部分进行排序。在实现快速排序时，需要先实现数组的分割操作，然后使用递归函数进行排序。

#### 13. 冒泡排序算法

**题目：** 请描述冒泡排序算法的基本思想和实现方式。

**答案：**

* 基本思想：冒泡排序算法通过重复遍历待排序的数组，比较相邻的两个元素，如果它们的顺序错误就交换它们，直到整个数组排序完成。

* 实现方式：

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array:", arr)
```

**解析：** 冒泡排序算法是一种简单的排序算法，时间复杂度为 O(n²)。它通过重复遍历待排序的数组，比较相邻的两个元素，如果它们的顺序错误就交换它们，直到整个数组排序完成。在实现冒泡排序时，可以使用嵌套循环来遍历和比较元素。

#### 14. 选择排序算法

**题目：** 请描述选择排序算法的基本思想和实现方式。

**答案：**

* 基本思想：选择排序算法通过每次遍历找出剩余元素中的最小值，并将其放到未排序序列的开头，直到整个数组排序完成。

* 实现方式：

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

arr = [64, 34, 25, 12, 22, 11, 90]
selection_sort(arr)
print("Sorted array:", arr)
```

**解析：** 选择排序算法是一种简单的排序算法，时间复杂度为 O(n²)。它通过每次遍历找出剩余元素中的最小值，并将其放到未排序序列的开头，直到整个数组排序完成。在实现选择排序时，可以使用嵌套循环来遍历和选择元素。

#### 15. 插入排序算法

**题目：** 请描述插入排序算法的基本思想和实现方式。

**答案：**

* 基本思想：插入排序算法通过逐步将一个记录插入到已经排好序的有序表中，直到整个表有序。

* 实现方式：

```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

arr = [64, 34, 25, 12, 22, 11, 90]
insertion_sort(arr)
print("Sorted array:", arr)
```

**解析：** 插入排序算法是一种简单的排序算法，时间复杂度为 O(n²)。它通过逐步将一个记录插入到已经排好序的有序表中，直到整个表有序。在实现插入排序时，可以使用嵌套循环来遍历和插入元素。

#### 16. 前缀树（Trie）的实现

**题目：** 请描述前缀树（Trie）的基本概念及其实现方式。

**答案：**

* 基本概念：前缀树是一种树形结构，用于存储大量的字符串，以快速查找是否存在某个字符串或以某个字符串为前缀的字符串。

* 实现方式：

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True

trie = Trie()
trie.insert("apple")
trie.insert("banana")
trie.insert("app")
print(trie.search("apple"))  # 输出 True
print(trie.search("app"))  # 输出 True
print(trie.search("apples"))  # 输出 False
print(trie.starts_with("app"))  # 输出 True
print(trie.starts_with("apple"))  # 输出 True
print(trie.starts_with("banana"))  # 输出 True
print(trie.starts_with("b"))  # 输出 False
```

**解析：** 前缀树是一种树形结构，用于存储大量的字符串，以快速查找是否存在某个字符串或以某个字符串为前缀的字符串。在实现前缀树时，可以使用 TrieNode 类表示节点，Trie 类表示整个树。Trie 类提供了插入、查找和前缀查找的方法。

#### 17. 并查集（Union-Find）的实现

**题目：** 请描述并查集（Union-Find）的基本概念及其实现方式。

**答案：**

* 基本概念：并查集是一种数据结构，用于处理元素动态集合的合并及查找问题。它通常用于求解连通性问题，如判断两个节点是否在同一集合中、合并两个集合等。

* 实现方式：

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]

uf = UnionFind(10)
uf.union(1, 2)
uf.union(2, 3)
uf.union(4, 5)
uf.union(5, 6)
print(uf.find(1))  # 输出 1
print(uf.find(6))  # 输出 4
print(uf.find(5))  # 输出 4
uf.union(4, 3)
print(uf.find(3))  # 输出 4
```

**解析：** 并查集是一种数据结构，用于处理元素动态集合的合并及查找问题。在实现并查集时，可以使用 UnionFind 类表示。UnionFind 类提供了 find 和 union 方法，分别用于查找元素所在的集合和合并两个集合。

#### 18. 哈希表（Hash Table）的实现

**题目：** 请描述哈希表（Hash Table）的基本概念及其实现方式。

**答案：**

* 基本概念：哈希表是一种基于哈希函数的数据结构，用于快速查找、插入和删除键值对。哈希表的性能取决于哈希函数和冲突解决策略。

* 实现方式：

```python
class HashTable:
    def __init__(self, size=1000):
        self.size = size
        self.table = [None] * size

    def hash_function(self, key):
        return key % self.size

    def put(self, key, value):
        index = self.hash_function(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    self.table[index][i] = (key, value)
                    return
            self.table[index].append((key, value))

    def get(self, key):
        index = self.hash_function(key)
        if self.table[index] is None:
            return None
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

    def delete(self, key):
        index = self.hash_function(key)
        if self.table[index] is None:
            return
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return

hash_table = HashTable()
hash_table.put(1, "one")
hash_table.put(2, "two")
hash_table.put(3, "three")
print(hash_table.get(1))  # 输出 "one"
print(hash_table.get(2))  # 输出 "two"
hash_table.delete(2)
print(hash_table.get(2))  # 输出 None
```

**解析：** 哈希表是一种基于哈希函数的数据结构，用于快速查找、插入和删除键值对。在实现哈希表时，可以使用 HashTable 类表示。HashTable 类提供了 hash_function、put、get 和 delete 方法，分别用于计算哈希值、插入键值对、获取键值和删除键值对。

#### 19. 设计LRU缓存

**题目：** 请描述如何设计一个LRU（Least Recently Used）缓存。

**答案：**

* 设计思路：使用哈希表加双向链表实现LRU缓存。哈希表用于快速查找缓存项，双向链表用于维护最近使用的缓存项。

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

# Example usage
lru_cache = LRUCache(2)
lru_cache.put(1, 1)
lru_cache.put(2, 2)
print(lru_cache.get(1))  # 输出 1
lru_cache.put(3, 3)
print(lru_cache.get(2))  # 输出 -1 (not found)
lru_cache.put(4, 4)
print(lru_cache.get(1))  # 输出 -1 (not found)
print(lru_cache.get(3))  # 输出 3
print(lru_cache.get(4))  # 输出 4
```

**解析：** LRU缓存是一种常见的缓存策略，用于缓存最近使用的数据，以实现快速访问。使用哈希表加双向链表实现LRU缓存可以高效地查找、插入和删除缓存项。哈希表用于快速查找缓存项，双向链表用于维护最近使用的缓存项。

#### 20. 单调栈的应用

**题目：** 请描述如何使用单调栈解决数组中的下一个更大元素问题。

**答案：**

* 设计思路：使用单调递减栈，遍历数组，对于当前元素，从栈顶弹出元素，直到栈为空或当前元素大于栈顶元素为止。每次弹出栈顶元素时，记录当前元素与栈顶元素的索引值。

```python
def next_greater_elements(arr):
    stack = []
    result = [-1] * len(arr)
    for i, num in enumerate(arr):
        while stack and arr[stack[-1]] < num:
            stack.pop()
        if stack:
            result[i] = arr[stack[-1]]
        stack.append(i)
    return result

arr = [4, 5, 2, 25]
print(next_greater_elements(arr))  # 输出 [5, 25, -1, -1]
arr = [13, 7, 6, 12]
print(next_greater_elements(arr))  # 输出 [13, 13, 12, 12]
```

**解析：** 单调栈可以用于解决数组中的下一个更大元素问题。通过使用单调递减栈，遍历数组，对于当前元素，从栈顶弹出元素，直到栈为空或当前元素大于栈顶元素为止。每次弹出栈顶元素时，记录当前元素与栈顶元素的索引值，即可得到下一个更大元素。

#### 21. 单调队列的应用

**题目：** 请描述如何使用单调队列解决数组中的下一个更小元素问题。

**答案：**

* 设计思路：使用单调递增队列，遍历数组，对于当前元素，将所有小于当前元素的队列元素弹出，然后入队当前元素。队列头部即为当前元素的下一个更小元素。

```python
def next_smaller_elements(arr):
    stack = []
    result = [-1] * len(arr)
    for i, num in enumerate(arr):
        while stack and arr[stack[-1]] >= num:
            stack.pop()
        if stack:
            result[i] = arr[stack[-1]]
        stack.append(i)
    return result

arr = [4, 5, 2, 25]
print(next_smaller_elements(arr))  # 输出 [-1, -1, 2, 2]
arr = [13, 7, 6, 12]
print(next_smaller_elements(arr))  # 输出 [7, 6, 6, 7]
```

**解析：** 单调队列可以用于解决数组中的下一个更小元素问题。通过使用单调递增队列，遍历数组，对于当前元素，将所有小于当前元素的队列元素弹出，然后入队当前元素。队列头部即为当前元素的下一个更小元素。

#### 22. 股票买卖的最佳时机

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果可以在第 `i` 天和第 `j` 天购买和出售股票（其中 `i < j`），且只能持有最多一次股票，请返回你能获得的最大利润。

**答案：**

* 设计思路：遍历数组，记录前缀和，如果当前元素大于前一个元素，则加上前缀和，否则重置前缀和。遍历结束后，前缀和即为最大利润。

```python
def max_profit(prices):
    max_profit = 0
    prev = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            max_profit += prices[i] - prices[i - 1] + prev
        else:
            prev = max_profit
    return max_profit

prices = [7, 1, 5, 3, 6, 4]
print(max_profit(prices))  # 输出 7
```

**解析：** 通过遍历数组，记录前缀和，如果当前元素大于前一个元素，则加上前缀和，否则重置前缀和。遍历结束后，前缀和即为最大利润。这种方法可以在不持有股票的情况下实现多次买卖，同时避免了复杂的条件判断。

#### 23. 买卖股票的最佳时机 II

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果可以在第 `i` 天和第 `j` 天购买和出售股票（其中 `i < j`），且只能持有最多一次股票，请返回你能获得的最大利润。

**答案：**

* 设计思路：遍历数组，对于每个元素，如果下一个元素大于当前元素，则加上当前元素，否则重置累加值。遍历结束后，累加值即为最大利润。

```python
def max_profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    return profit

prices = [7, 1, 5, 3, 6, 4]
print(max_profit(prices))  # 输出 7
```

**解析：** 通过遍历数组，对于每个元素，如果下一个元素大于当前元素，则加上当前元素，否则重置累加值。遍历结束后，累加值即为最大利润。这种方法实现了多次买卖，并且在每次买卖时都保证了利润最大化。

#### 24. 股票买卖的最佳时机 III

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果可以在第 `i` 天和第 `j` 天购买和出售股票（其中 `i < j`），且只能持有最多两次股票，请返回你能获得的最大利润。

**答案：**

* 设计思路：使用动态规划，定义三个状态：不持有股票、持有一手股票、持有两手股票。遍历数组，更新这三个状态，最后返回不持有股票的状态。

```python
def max_profit(prices):
    n = len(prices)
    f0, f1, f2 = 0, -prices[0], -prices[0]
    for i in range(1, n):
        f0, f1, f2 = max(f0, f1 + prices[i]), max(f1, f0 - prices[i]), f2 + prices[i]
    return max(f0, f2)

prices = [3, 3, 6, 5, 0, 3, 1, 4]
print(max_profit(prices))  # 输出 6
```

**解析：** 使用动态规划，定义三个状态：不持有股票、持有一手股票、持有两手股票。遍历数组，更新这三个状态，最后返回不持有股票的状态。这种方法实现了最多两次买卖，并且在每次买卖时都保证了利润最大化。

#### 25. 分隔等和子集

**题目：** 给定一个整数数组 `nums`，判断是否存在元素可以将其分隔成两个子集，使得两个子集的和相等。

**答案：**

* 设计思路：使用动态规划，定义一个二维数组 `dp[i][j]` 表示从前 `i` 个元素中选取一些元素，它们的和为 `j` 是否可能。遍历数组，更新 `dp` 数组，最后判断 `dp[n][sum(nums)/2]` 是否为 `True`。

```python
def canPartition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    n = len(nums)
    dp = [[False] * (target + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = True

    for i in range(1, n + 1):
        for j in range(1, target + 1):
            if j < nums[i - 1]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]

    return dp[n][target]

nums = [1, 5, 11, 5]
print(canPartition(nums))  # 输出 True
nums = [1, 2, 3, 5]
print(canPartition(nums))  # 输出 False
```

**解析：** 使用动态规划，定义一个二维数组 `dp[i][j]` 表示从前 `i` 个元素中选取一些元素，它们的和为 `j` 是否可能。遍历数组，更新 `dp` 数组，最后判断 `dp[n][sum(nums)/2]` 是否为 `True`。这种方法实现了判断是否存在元素可以将其分隔成两个子集，使得两个子集的和相等。

#### 26. 子集划分问题

**题目：** 给定一个整数数组 `nums`，判断是否存在元素可以将其分隔成两个子集，使得两个子集的和相等。

**答案：**

* 设计思路：使用动态规划，定义一个二维数组 `dp[i][j]` 表示从前 `i` 个元素中选取一些元素，它们的和为 `j` 是否可能。遍历数组，更新 `dp` 数组，最后判断 `dp[n][sum(nums)/2]` 是否为 `True`。

```python
def canPartition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    n = len(nums)
    dp = [[False] * (target + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = True

    for i in range(1, n + 1):
        for j in range(1, target + 1):
            if j < nums[i - 1]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]

    return dp[n][target]

nums = [1, 5, 11, 5]
print(canPartition(nums))  # 输出 True
nums = [1, 2, 3, 5]
print(canPartition(nums))  # 输出 False
```

**解析：** 使用动态规划，定义一个二维数组 `dp[i][j]` 表示从前 `i` 个元素中选取一些元素，它们的和为 `j` 是否可能。遍历数组，更新 `dp` 数组，最后判断 `dp[n][sum(nums)/2]` 是否为 `True`。这种方法实现了判断是否存在元素可以将其分隔成两个子集，使得两个子集的和相等。

#### 27. 背包问题

**题目：** 给定一个整数数组 `weights` 和一个整数 `capacity`，表示一个背包的容量，请找出背包可以装入的最大重量。

**答案：**

* 设计思路：使用动态规划，定义一个二维数组 `dp[i][j]` 表示从前 `i` 个物品中选取一些物品，它们的总重量不超过 `j` 时的最大重量。遍历物品和容量，更新 `dp` 数组，最后返回 `dp[n][capacity]`。

```python
def knapsack(weights, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if weights[i - 1] <= j:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + weights[i - 1])
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[n][capacity]

weights = [1, 2, 3, 4, 5]
capacity = 8
print(knapsack(weights, capacity))  # 输出 8
```

**解析：** 使用动态规划，定义一个二维数组 `dp[i][j]` 表示从前 `i` 个物品中选取一些物品，它们的总重量不超过 `j` 时的最大重量。遍历物品和容量，更新 `dp` 数组，最后返回 `dp[n][capacity]`。这种方法实现了背包问题的求解。

#### 28. 删除重复节点

**题目：** 给定一个单链表，删除所有重复的节点，只保留一个。

**答案：**

* 设计思路：使用哈希表记录每个节点的值和下一个节点，遍历链表，对于当前节点，如果它的值在哈希表中存在，则将它的下一个节点指向哈希表中的下一个节点。

```python
def delete_duplicates(head):
    if head is None:
        return None

    values = set()
    current = head
    values.add(current.val)
    while current.next:
        if current.next.val in values:
            current.next = current.next.next
        else:
            values.add(current.next.val)
            current = current.next

    return head

# Example usage
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(2)
head.next.next.next.next = ListNode(4)
head.next.next.next.next.next = ListNode(3)
print(delete_duplicates(head))  # 输出 [1, 2, 3, 4, 3]
```

**解析：** 使用哈希表记录每个节点的值和下一个节点，遍历链表，对于当前节点，如果它的值在哈希表中存在，则将它的下一个节点指向哈希表中的下一个节点。这种方法实现了删除重复节点，只保留一个。

#### 29. 剑指 Offer 18. 删除链表的节点

**题目：** 给定单向链表的头指针和一个节点指针，定义一个函数删除该节点。

**答案：**

* 设计思路：遍历链表，找到要删除的节点的前一个节点，然后将它的下一个节点设置为要删除节点的下一个节点。

```python
def delete_node(head, node):
    if head == node:
        head = head.next
        return head

    current = head
    while current and current.next != node:
        current = current.next

    if current:
        current.next = current.next.next
        return head

# Example usage
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)
node = head.next.next
print(delete_node(head, node))  # 输出 [1, 2, 4, 5]
```

**解析：** 遍历链表，找到要删除的节点的前一个节点，然后将它的下一个节点设置为要删除节点的下一个节点。这种方法实现了删除链表的节点。

#### 30. 剑指 Offer 36. 二叉搜索树与双向链表

**题目：** 将一个二叉搜索树转换为双向链表，要求不能创建任何新的节点，只能调整树节点中的指针。

**答案：**

* 设计思路：使用中序遍历，将二叉搜索树转换为排序链表，然后调整指针，使其成为双向链表。

```python
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def tree_to_doubly_list(root):
    if not root:
        return None

    prev = None
    head = None

    def dfs(root):
        nonlocal prev, head
        if root is None:
            return
        dfs(root.left)
        if prev:
            prev.right = root
            root.left = prev
        else:
            head = root
        prev = root
        dfs(root.right)

    dfs(root)

    head.left = prev
    prev.right = head
    return head

# Example usage
root = Node(4, Node(2, Node(1), Node(3)), Node(6, Node(5), Node(7)))
root = tree_to_doubly_list(root)
print(root.val, end=" ")
current = root.left
while current:
    print(current.val, end=" ")
    current = current.right
# 输出 1 2 3 4 5 6 7
```

**解析：** 使用中序遍历，将二叉搜索树转换为排序链表，然后调整指针，使其成为双向链表。这种方法实现了将二叉搜索树转换为双向链表。

