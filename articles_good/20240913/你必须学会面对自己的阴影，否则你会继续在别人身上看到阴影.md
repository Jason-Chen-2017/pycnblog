                 

### 必须学会面对自己的阴影，否则你会继续在别人身上看到阴影

#### 面试题与算法编程题库

**1. 股票买卖**

**题目：** 给定一个整数数组 prices ，其中 prices[i] 是第 i 天股票的价格。如果您今天买入股票，则第二天可以卖出。返回您能获得的 最大利润。

**答案解析：** 该问题可以转化为找到一个子数组，其和最大。可以使用动态规划的方法解决。

```go
func maxProfit(prices []int) int {
    n := len(prices)
    dp := make([]int, n)
    for i := 1; i < n; i++ {
        dp[i] = max(dp[i-1], prices[i]-prices[i-1])
    }
    return max(0, dp[n-1])
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**2. 单词梯**

**题目：** 给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的转换序列。转换需遵循以下规则：

- 每次转换只能改变一个字母。
- 转换过程中的中间单词必须是字典中的单词。

**答案解析：** 使用广度优先搜索（BFS）来找到最短路径。

```go
func findLadders(beginWord string, endWord string, wordList []string) [][]string {
    words := map[string]bool{}
    for _, w := range wordList {
        words[w] = true
    }
    q := [][]string{{beginWord}}
    for len(q) > 0 {
        level := len(q)
        for i := 0; i < level; i++ {
            word := q[0]
            q = q[1:]
            for _, s := range neighbors(word, words) {
                if s == endWord {
                    return append(word, s)
                }
                q = append(q, append(word, s))
            }
        }
    }
    return nil
}

func neighbors(word string) []string {
    var neighbors []string
    for i := 0; i < len(word); i++ {
        for c := 'a'; c <= 'z'; c++ {
            newWord := word[:i] + string(c) + word[i+1:]
            if _, ok := s.NewWords[newWord]; ok {
                neighbors = append(neighbors, newWord)
            }
        }
    }
    return neighbors
}
```

**3. 快乐数**

**题目：** 编写一个算法来判断一个数 n 是不是快乐数。

**答案解析：** 快乐数的定义：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但最终会变为 1。如果 n 是快乐数，返回 True ；不是，则返回 False 。

```go
func isHappy(n int) bool {
    def getSum(n):
        sum = 0
        while n > 0:
            sum += (n % 10) ** 2
            n //= 10
        return sum
    
    slow, fast = n, getSum(n)
    while fast != 1 and slow != fast:
        slow = getSum(slow)
        fast = getSum(getSum(fast))
    return fast == 1
}
```

**4. 两数之和**

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：** 使用哈希表来存储数组中每个元素以及它们的索引，然后遍历数组并检查目标值是否等于当前值与哈希表中元素的差值。

```go
def twoSum(nums, target):
    hashTable = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashTable:
            return [hashTable[complement], i]
        hashTable[num] = i
    return []
```

**5. 合并两个有序链表**

**题目：** 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案解析：** 使用递归或迭代的方式，比较两个链表当前节点的值，选择较小的值作为新链表的下一个节点，并递归或迭代地处理剩余部分。

```go
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**6. 设计一个支持基本数据结构的数据流**

**题目：** 设计一个支持以下两种操作的数据结构：

- void addNum(int val)：向数据流中添加一个整数。
- int move(int k)：从数据流中获取第  k  个迁移的整数。如果第  k  个整数不存在，则返回 -1 。

**答案解析：** 可以使用优先级队列（最小堆）来实现这个数据结构，使用一个哈希表来存储每个数字的索引。

```python
from heapq import heapify, heappop, heappush
from collections import defaultdict

class DataStream:
    def __init__(self):
        self.heap = []
        self.index = defaultdict(int)
        self.k = 0

    def addNum(self, val: int) -> None:
        if val > self.heap[0]:
            heappush(self.heap, -val)
            self.index[val] = self.index.get(val, 0) + 1
        self.k = min(self.k, self.index[val])

    def move(self, k: int) -> int:
        if k > self.k:
            return -1
        while -self.heap[0] != k:
            heappop(self.heap)
            self.k = min(self.k, self.index[-self.heap[0]])
        self.index[-self.heap[0]] -= 1
        return -self.heap[0]
```

**7. 寻找旋转排序数组中的最小值**

**题目：** 已知一个按顺序存储的旋转数组，在数组中，元素从0开始计数，到n-1结束。当数组被旋转后，最开始的几个元素将移动到数组末尾。例如，数组 `[0,1,2,4,5,6,7]` 变为 `[4,5,6,7,0,1,2]`。

请找出并返回数组中的最小元素。

**答案解析：** 使用二分查找法，如果中间元素小于其左右邻居，那么它就是最小元素。否则，根据中间元素与最左端元素的大小关系，将搜索范围缩小一半。

```python
def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[right]:
            right = mid
        else:
            left = mid + 1
    return nums[left]
```

**8. 盛水问题**

**题目：** 给定一个长度为 n 的整数数组 `height` 。有 n 条垂线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**答案解析：** 使用双指针法，分别从左右两端开始，计算当前容器的面积，然后移动较短边，尝试获取更大的面积。

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    area = 0
    while left < right:
        area = max(area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return area
```

**9. 颜色分类**

**题目：** 给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。

**答案解析：** 使用 Dutch National Flag 算法，通过三个指针将数组分为四个部分：红、白、蓝和无定义。

```python
def sortColors(nums):
    left, right = 0, len(nums) - 1
    p = 0
    while p <= right:
        if nums[p] == 0:
            nums[left], nums[p] = nums[p], nums[left]
            left += 1
            p += 1
        elif nums[p] == 1:
            p += 1
        else:
            nums[right], nums[p] = nums[p], nums[right]
            right -= 1
```

**10. 合并区间**

**题目：** 给出一个区间的列表，区间 `[a, b]` 表示第 `a` 个区间的起点和第 `b` 个区间的终点。请你合并所有重叠的区间，以一个列表的形式返回合并后的区间。

**答案解析：** 首先对区间进行排序，然后遍历排序后的区间，合并重叠的部分。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last = ans[-1]
        if last[1] >= interval[0]:
            ans[-1] = [last[0], max(last[1], interval[1])]
        else:
            ans.append(interval)
    return ans
```

**11. 验证二叉搜索树**

**题目：** 给定一个二叉树，判断它是是否是有效的二叉搜索树（BST）。假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树都是二叉搜索树。

**答案解析：** 使用中序遍历，如果遍历结果是一个递增的序列，则二叉树是有效的 BST。

```python
def isValidBST(root):
    def dfs(root):
        if root is None:
            return True
        if not dfs(root.left) or not dfs(root.right):
            return False
        return root.val > prev and root.val < succ

    prev, succ = float('-inf'), float('inf')
    return dfs(root)
```

**12. 最小路径和**

**题目：** 给定一个包含非负整数的 `m x n` 网格。请找出一条从左上角到右下角的最小路径和。每一步你可以只向下或只向右移动。

**答案解析：** 使用动态规划，将每个元素设置为到当前位置的最小路径和。

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i-1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j-1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
    return grid[-1][-1]
```

**13. 最大子序和**

**题目：** 给定一个整数数组 `nums` ，找出数组中连续子数组的最小和。返回所有这些最小和中的最大值。

**答案解析：** 使用前缀和 + 单调栈，计算每个元素左侧最小值和右侧最小值，然后用前缀和减去这两个值。

```python
from sortedcontainers import SortedList

def maximumSum(nums):
    n = len(nums)
    left_min, right_min = [0] * n, [0] * n
    sl = SortedList([nums[0]])
    for i in range(1, n):
        left_min[i] = sl.bisect_left(nums[i])
        sl.add(nums[i])
    sl = SortedList([nums[-1]])
    for i in range(n - 2, -1, -1):
        right_min[i] = n - 1 - sl.bisect_left(nums[i])
        sl.add(nums[i])
    ans = -inf
    for i in range(n):
        ans = max(ans, nums[i] - left_min[i] - right_min[i])
    return ans
```

**14. 最长公共子序列**

**题目：** 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在共同子序列，返回 0。

**答案解析：** 使用动态规划，定义 dp[i][j] 为 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列长度。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**15. 删除链表的节点**

**题目：** 给定一个单链表的头节点 head 和一个整数 val ，删除链表中所有值为 val 的节点，并返回新的头节点。

**答案解析：** 使用虚拟头节点，避免处理特殊情况。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNode(head, val):
    dummy = ListNode(0)
    dummy.next = head
    cur = dummy
    while cur.next:
        if cur.next.val == val:
            cur.next = cur.next.next
        else:
            cur = cur.next
    return dummy.next
```

**16. 设计循环双链表**

**题目：** 设计实现一个循环双链表。循环双链表是一个双向链表，既可以向前也可以向后遍历。在循环双链表中，给定节点的一个下一个节点和前一个节点都指向链表中的另一个节点，最后两个节点的前一个和后一个节点都指向链表中的第一个节点。

**答案解析：** 定义一个 Node 类表示节点，实现 Insert、Delete 等操作。

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

class MyCycleList:
    def __init__(self):
        self.head = Node(0)
        self.tail = Node(0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def insert(self, val):
        new_node = Node(val)
        new_node.next = self.tail
        new_node.prev = self.tail.prev
        self.tail.prev.next = new_node
        self.tail.prev = new_node

    def delete(self, node):
        if node == self.head or node == self.tail:
            return
        node.prev.next = node.next
        node.next.prev = node.prev
```

**17. 设计推特**

**题目：** 设计一个简化版的推特（Twitter），用户可以发推文（post tweets），所有发推文都会按照时间顺序被保存在一个列表中，列表示用户发布的所有推文。每个推文都可以进行点赞（like）。你的设计需要支持以下功能：

- postTweet(userId, tweetId)：用户发布一条推文。
- getNewsFeed(userId)：获取用户的新闻推送，即获取用户关注的人（包括他本身）发布的最近十条推文。
- follow(followerId, followeeId)：用户关注其他用户。
- unfollow(followerId, followeeId)：用户取消关注其他用户。

**答案解析：** 使用哈希表存储用户的推文和关注列表，有序哈希表存储新闻推送。

```python
from sortedcontainers import SortedList
from collections import defaultdict

class Twitter:
    def __init__(self):
        self.timeline = SortedList()
        self.tweets = defaultdict(list)
        self.followees = defaultdict(set)

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets[userId].append(tweetId)
        self.timeline.add((0, userId, tweetId))

    def getNewsFeed(self, userId: int) -> [int]:
        self.followees[userId].add(userId)
        feed = []
        i = 0
        while i < 10 and len(feed) < 10:
            _, u, t = self.timeline[i]
            if u in self.followees[userId]:
                feed.append(t)
                i += 1
        return feed

    def follow(self, followerId: int, followeeId: int) -> None:
        self.followees[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.followees[followerId].discard(followeeId)
```

**18. 最小栈**

**题目：** 设计一个支持 push ，pop ，top 操作的栈。

- push(x) —— 将元素 x 推到栈顶。
- pop() —— 删除栈顶元素。
- top() —— 获取栈顶元素。
- isEmpty() —— 检查栈是否为空。

**答案解析：** 使用两个栈，一个用来存储元素，另一个用来存储最小值。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def isEmpty(self) -> bool:
        return not self.stack
```

**19. 哈希表**

**题目：** 设计哈希表，实现 `put` 、`get` 和 `remove` 函数。

- `put(key, value)`：向哈希表中插入一个键值对（键值对由键和值组成）。如果键已存在，则更新其对应的值。
- `get(key)`：返回哈希表中对应键的值。如果键不存在，返回 -1 。
- `remove(key)`：删除哈希表中这个键的值。

**答案解析：** 使用哈希表实现，时间复杂度为 O(1)。

```python
class MyHashMap:
    def __init__(self):
        self.size = 10000
        self.table = [None] * self.size

    def hash(self, key):
        return key % self.size

    def put(self, key: int, value: int) -> None:
        idx = self.hash(key)
        if self.table[idx] is None:
            self.table[idx] = []
        for i, (k, v) in enumerate(self.table[idx]):
            if k == key:
                self.table[idx][i] = (key, value)
                return
        self.table[idx].append((key, value))

    def get(self, key: int) -> int:
        idx = self.hash(key)
        if self.table[idx] is None:
            return -1
        for k, v in self.table[idx]:
            if k == key:
                return v
        return -1

    def remove(self, key: int) -> None:
        idx = self.hash(key)
        if self.table[idx] is None:
            return
        for i, (k, v) in enumerate(self.table[idx]):
            if k == key:
                self.table[idx].pop(i)
                return
```

**20. 滑动窗口最大值**

**题目：** 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最顶部开始移动。你只可以看到在滑动窗口内的 `k` 个数值，滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。

**答案解析：** 使用双端队列维护滑动窗口中的最大值。

```python
from collections import deque

def maxSlidingWindow(nums, k):
    if not nums:
        return []
    q = deque()
    ans = []
    for i, v in enumerate(nums):
        while q and nums[q[-1]] < v:
            q.pop()
        q.append(i)
        if i >= k - 1:
            ans.append(nums[q[0]])
            if q[0] == i - k + 1:
                q.popleft()
    return ans
```

**21. 设计前缀树**

**题目：** 设计一个前缀树（字典树），实现 `Trie` 类：

- `Trie()` 初始化前缀树对象。
- `insert(word)` 插入字符串 word 到前缀树中。
- `search(word)` 检查前缀树中是否存在字符串 word 。
- `startsWith(prefix)` 检查前缀树中是否存在以字符串 prefix 开头的情况。

**答案解析：** 定义 TrieNode 类表示节点，实现 insert、search、startsWith 方法。

```python
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str) -> None:
        node = self.root
        for c in word:
            node = node.children[c]
        node.is_end_of_word = True

    def search(self, word: str) -> bool:
        node = self.root
        for c in word:
            if c not in node.children:
                return False
            node = node.children[c]
        return node.is_end_of_word

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for c in prefix:
            if c not in node.children:
                return False
            node = node.children[c]
        return True
```

**22. 合并区间**

**题目：** 给出一个区间的列表，区间 `[a, b]` 表示第 `a` 个区间的起点和第 `b` 个区间的终点。请你合并所有重叠的区间，以一个列表的形式返回合并后的区间。

**答案解析：** 首先对区间进行排序，然后遍历排序后的区间，合并重叠的部分。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for i in range(1, len(intervals)):
        last = ans[-1]
        if last[1] >= intervals[i][0]:
            ans[-1] = [last[0], max(last[1], intervals[i][1])]
        else:
            ans.append(intervals[i])
    return ans
```

**23. 电话号码的字母组合**

**题目：** 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。

**答案解析：** 使用深度优先搜索（DFS）遍历所有可能的组合。

```python
def letterCombinations(digits):
    def dfs(i):
        if i == len(digits):
            ans.append(''.join(t))
            return
        for c in strings[int(digits[i])]:
            t.append(c)
            dfs(i + 1)
            t.pop()

    strings = [['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l'], ['m', 'n', 'o'], ['p', 'q', 'r', 's'], ['t', 'u', 'v'], ['w', 'x', 'y', 'z']]
    ans = []
    t = []
    dfs(0)
    return ans
```

**24. 股票买卖**

**题目：** 给定一个整数数组 prices ，其中 prices[i] 是第 i 天的股票价格。如果您今天买入股票，则第二天可以卖出。返回您能获得的 最大利润。

**答案解析：** 使用动态规划，定义 dp[i] 表示第 i 天的最大利润。

```python
def maxProfit(prices):
    n = len(prices)
    dp = [[0] * 2 for _ in range(n)]
    for i in range(1, n):
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = max(dp[i - 1][1], -prices[i])
    return dp[-1][0]
```

**25. 分割等和子集**

**题目：** 给定一个非空整数数组 nums ，判断是否存在子集可以使这些元素的和等于一个给定整数 target 。

**答案解析：** 使用动态规划，定义 dp[i][j] 表示前 i 个元素和为 j 的子集是否存在。

```python
def canPartition(nums, target):
    n = len(nums)
    dp = [[False] * (target + 1) for _ in range(n + 1)]
    dp[0][0] = True
    for i in range(1, n + 1):
        for j in range(target + 1):
            if j < nums[i - 1]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
    return dp[n][target]
```

**26. 合并两个有序链表**

**题目：** 给出两个 非空 链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以零开头。

**答案解析：** 使用递归或迭代的方法合并两个有序链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**27. 爬楼梯**

**题目：** 假设你正在爬楼梯。需要 `n` 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**答案解析：** 使用动态规划，定义 dp[i] 表示到达第 i 阶台阶的方法数。

```python
def climbStairs(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

**28. 两数之和**

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：** 使用哈希表存储数组中每个元素以及它们的索引，然后遍历数组并检查目标值是否等于当前值与哈希表中元素的差值。

```python
def twoSum(nums, target):
    hashTable = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashTable:
            return [hashTable[complement], i]
        hashTable[num] = i
    return []
```

**29. 最长公共前缀**

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：** 从第一个字符串开始，依次取子串与下一个字符串比较，找到最长的公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        for i, c in enumerate(s):
            if i == len(prefix) or s[i] != prefix[i]:
                prefix = prefix[:i]
                break
    return prefix
```

**30. 字符串转换大写字母**

**题目：** 将一个给定字符串 s 输入到函数里面，输出一个字符串，并将其中（ ）替换为 “（ ）”，将 [ 在字符串左侧的 ] 替换为 [ ]。

**答案解析：** 使用字符串的 replace 方法替换字符。

```python
def toLowerCase(s: str) -> str:
    return s.lower().replace("(", "（ ").replace("[", "[ ").rstrip()

def toUpperCase(s: str) -> str:
    return s.upper().replace("(", "（ ").replace("[", "[ ").rstrip()

def toLowerCase(s: str) -> str:
    return s.replace("(", "（ ").replace("[", "[ ").replace("]", " ]").lower()

def toUpperCase(s: str) -> str:
    return s.replace("(", "（ ").replace("[", "[ ").replace("]", " ]").upper()
```

