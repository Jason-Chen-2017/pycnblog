                 

### 2025年腾讯社招算法面试题库及答案：数据结构与算法篇

#### 1. 简单选择排序（Selection Sort）

**题目：** 实现简单选择排序算法，并对一个给定的数组进行排序。

**答案：**

```python
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print(sorted_arr)  # 输出：[11, 12, 22, 25, 64]
```

**解析：** 选择排序算法每次从未排序的部分中找到最小（或最大）的元素，并将其放到已排序部分的末尾。时间复杂度为 \(O(n^2)\)。

#### 2. 冒泡排序（Bubble Sort）

**题目：** 实现冒泡排序算法，并对一个给定的数组进行排序。

**答案：**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

arr = [64, 34, 25, 12, 22, 11]
sorted_arr = bubble_sort(arr)
print(sorted_arr)  # 输出：[11, 12, 22, 25, 34, 64]
```

**解析：** 冒泡排序算法通过反复交换相邻元素来将最大（或最小）的元素“冒泡”到数组的末尾。时间复杂度为 \(O(n^2)\)。

#### 3. 快速排序（Quick Sort）

**题目：** 实现快速排序算法，并对一个给定的数组进行排序。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [64, 34, 25, 12, 22, 11]
sorted_arr = quick_sort(arr)
print(sorted_arr)  # 输出：[11, 12, 22, 25, 34, 64]
```

**解析：** 快速排序通过选择一个“基准”元素，将数组划分为两个子数组，一个包含小于基准的元素，另一个包含大于基准的元素，然后递归地对这两个子数组进行排序。时间复杂度为 \(O(n \log n)\)。

#### 4. 二分查找（Binary Search）

**题目：** 实现二分查找算法，在已排序的数组中查找一个给定元素。

**答案：**

```python
def binary_search(arr, x):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] < x:
            low = mid + 1
        elif arr[mid] > x:
            high = mid - 1
        else:
            return mid
    return -1

arr = [64, 34, 25, 12, 22, 11]
result = binary_search(arr, 25)
print(result)  # 输出：2
```

**解析：** 二分查找算法通过不断将搜索范围缩小一半，逐步逼近目标元素。时间复杂度为 \(O(\log n)\)。

#### 5. 合并两个有序数组

**题目：** 给定两个有序数组，实现一个函数，将它们合并为一个有序数组。

**答案：**

```python
def merge_sorted_arrays(arr1, arr2):
    i, j = 0, 0
    merged = []
    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            merged.append(arr1[i])
            i += 1
        else:
            merged.append(arr2[j])
            j += 1
    while i < len(arr1):
        merged.append(arr1[i])
        i += 1
    while j < len(arr2):
        merged.append(arr2[j])
        j += 1
    return merged

arr1 = [1, 3, 5]
arr2 = [2, 4, 6]
merged_arr = merge_sorted_arrays(arr1, arr2)
print(merged_arr)  # 输出：[1, 2, 3, 4, 5, 6]
```

**解析：** 通过逐个比较两个数组的元素，将较小的元素添加到合并后的数组中。时间复杂度为 \(O(m + n)\)，其中 \(m\) 和 \(n\) 分别是两个数组的长度。

#### 6. 判断回文串

**题目：** 实现一个函数，判断一个给定的字符串是否为回文串。

**答案：**

```python
def is_palindrome(s):
    return s == s[::-1]

s = "racecar"
result = is_palindrome(s)
print(result)  # 输出：True
```

**解析：** 通过字符串的逆序比较来判断是否为回文串。时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串的长度。

#### 7. 逆波兰表达式求值

**题目：** 给定一个逆波兰表达式，实现一个函数，计算表达式的值。

**答案：**

```python
def evaluate_postfix(expression):
    stack = []
    for token in expression.split():
        if token.isdigit():
            stack.append(int(token))
        else:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            elif token == "/":
                stack.append(a / b)
    return stack[0]

expression = "3 4 * 2 / 3 +"
result = evaluate_postfix(expression)
print(result)  # 输出：5
```

**解析：** 通过栈实现逆波兰表达式的求值。时间复杂度为 \(O(n)\)，其中 \(n\) 是表达式的长度。

#### 8. 爬楼梯问题

**题目：** 一个楼梯有 \(n\) 个台阶，每次可以爬 1 或 2 个台阶，求爬到楼顶的方法数。

**答案：**

```python
def climb_stairs(n):
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

n = 3
result = climb_stairs(n)
print(result)  # 输出：3
```

**解析：** 使用动态规划求解爬楼梯的方法数。时间复杂度为 \(O(n)\)。

#### 9. 打家劫舍

**题目：** 给定一个数组，每个元素表示一家的财富，一个盗贼计划要抢窃每一家的财富，但不能连续抢两家。求盗贼能获得的最大财富。

**答案：**

```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]

nums = [2, 7, 9, 3, 1]
result = rob(nums)
print(result)  # 输出：12
```

**解析：** 使用动态规划求解打家劫舍的最大财富。时间复杂度为 \(O(n)\)。

#### 10. 两数之和

**题目：** 给定一个整数数组和一个目标值，找出数组中两个数之和等于目标值的两个数的位置。

**答案：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []

nums = [2, 7, 11, 15]
target = 9
result = two_sum(nums, target)
print(result)  # 输出：[0, 1]
```

**解析：** 使用哈希表实现两数之和的查找。时间复杂度为 \(O(n)\)。

#### 11. 合并区间

**题目：** 给定一组区间，将重叠的区间合并，输出合并后的区间。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if interval[0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], interval[1])
        else:
            result.append(interval)
    return result

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
result = merge(intervals)
print(result)  # 输出：[[1, 6], [8, 10], [15, 18]]
```

**解析：** 对区间进行排序后，依次合并重叠的区间。时间复杂度为 \(O(n \log n)\)，其中 \(n\) 是区间的数量。

#### 12. 最小栈

**题目：** 设计一个最小栈，支持栈的基本操作（push、pop、top），并能够获取栈的最小元素。

**答案：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**解析：** 使用两个栈，一个存储所有元素，另一个存储最小元素。时间复杂度为 \(O(1)\)。

#### 13. 删除排序数组中的重复项

**题目：** 给定一个排序数组，移除重复项，并返回新的数组长度。

**答案：**

```python
def remove_duplicates(nums):
    if not nums:
        return 0
    slow, fast = 0, 0
    while fast < len(nums):
        if nums[slow] != nums[fast]:
            slow += 1
            nums[slow] = nums[fast]
        fast += 1
    return slow + 1

nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
result = remove_duplicates(nums)
print(result)  # 输出：5，nums 为 [0, 1, 2, 3, 4]
```

**解析：** 使用双指针法，一个指针遍历整个数组，另一个指针指向当前最后一个不重复元素的位置。时间复杂度为 \(O(n)\)。

#### 14. 三数之和

**题目：** 给定一个数组，找到所有三个元素的和等于目标值的组合。

**答案：**

```python
def three_sum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return result

nums = [-1, 0, 1, 2, -1, -4]
target = 0
result = three_sum(nums, target)
print(result)  # 输出：[[-1, -1, 2], [-1, 0, 1]]
```

**解析：** 使用排序和双指针法，依次固定第一个元素，并使用两个指针分别从左右两侧遍历。时间复杂度为 \(O(n^2)\)。

#### 15. 搜索二维矩阵

**题目：** 给定一个排序的二维矩阵，实现一个函数，查找一个目标值是否存在。

**答案：**

```python
def search_matrix(matrix, target):
    if not matrix or not matrix[0]:
        return False
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1
    while row < rows and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False

matrix = [
    [1, 3, 5, 7],
    [10, 11, 16, 20],
    [23, 30, 34, 50]
]
target = 3
result = search_matrix(matrix, target)
print(result)  # 输出：True
```

**解析：** 使用二分查找法，依次在行和列上查找。时间复杂度为 \(O(m + n)\)，其中 \(m\) 是行数，\(n\) 是列数。

#### 16. 汇总区间

**题目：** 给定一个无序数组，其中包含一些连续的数字区间，实现一个函数，将它们汇总成一组不重叠的区间。

**答案：**

```python
def merge_intervals(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if interval[0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], interval[1])
        else:
            result.append(interval)
    return result

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
result = merge_intervals(intervals)
print(result)  # 输出：[[1, 6], [8, 10], [15, 18]]
```

**解析：** 对区间进行排序后，依次合并重叠的区间。时间复杂度为 \(O(n \log n)\)，其中 \(n\) 是区间的数量。

#### 17. 单调栈

**题目：** 实现一个单调栈，支持栈的基本操作（push、pop、top），并能够获取栈中下一个更大元素。

**答案：**

```python
class MonotonicStack:

    def __init__(self):
        self.stack = []

    def push(self, val: int) -> None:
        while self.stack and self.stack[-1] < val:
            self.stack.pop()
        self.stack.append(val)

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def next_greater(self, nums) -> List[int]:
        result = [-1] * len(nums)
        stack = MonotonicStack()
        for i in range(len(nums)):
            stack.push(nums[i])
            result[i] = stack.top()
        return result
```

**解析：** 使用单调栈，依次弹出栈顶小于当前元素的情况。时间复杂度为 \(O(n)\)。

#### 18. 前K个高频元素

**题目：** 给定一个整数数组和一个整数 \(k\)，返回数组中频率最高的 \(k\) 个元素。

**答案：**

```python
from collections import Counter

def top_k_frequent(nums, k):
    counter = Counter(nums)
    return [x for x, count in counter.most_common(k)]

nums = [1, 1, 1, 2, 2, 3]
k = 2
result = top_k_frequent(nums, k)
print(result)  # 输出：[1, 2]
```

**解析：** 使用 Counter 对数组进行计数，并按频率排序。时间复杂度为 \(O(n \log n)\)，其中 \(n\) 是数组的长度。

#### 19. 滑动窗口最大值

**题目：** 给定一个整数数组和一个整数 \(k\)，找出滑动窗口中的最大值。

**答案：**

```python
from collections import deque

def max_sliding_window(nums, k):
    result = []
    queue = deque()
    for i, num in enumerate(nums):
        while queue and queue[0] < i - k + 1:
            queue.popleft()
        while queue and nums[queue[-1]] < num:
            queue.pop()
        queue.append(i)
        if i >= k - 1:
            result.append(nums[queue[0]])
    return result

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
result = max_sliding_window(nums, k)
print(result)  # 输出：[3, 3, 5, 5, 6, 7]
```

**解析：** 使用双端队列实现滑动窗口的最大值。时间复杂度为 \(O(n)\)。

#### 20. 快速幂

**题目：** 实现一个快速幂函数，计算 \(a^n\) 的值。

**答案：**

```python
def quick_power(a, n):
    result = 1
    while n:
        if n & 1:
            result *= a
        a *= a
        n >>= 1
    return result

a = 2
n = 10
result = quick_power(a, n)
print(result)  # 输出：1024
```

**解析：** 使用位运算实现快速幂。时间复杂度为 \(O(\log n)\)，其中 \(n\) 是指数的大小。

#### 21. 盛水问题

**题目：** 给定一个由若干个非负整数组成的数组，求出其中两个最大数和最小数之和的最大差值。

**答案：**

```python
def max_water_trapped(height):
    left, right = 0, len(height) - 1
    max_left, max_right = height[0], height[-1]
    result = 0
    while left < right:
        max_left = max(max_left, height[left])
        max_right = max(max_right, height[right])
        if max_left < max_right:
            result += max_left - height[left]
            left += 1
        else:
            result += max_right - height[right]
            right -= 1
    return result

height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
result = max_water_trapped(height)
print(result)  # 输出：49
```

**解析：** 使用双指针法，分别指向数组的左右两端，计算最大高度的差值。时间复杂度为 \(O(n)\)，其中 \(n\) 是数组的长度。

#### 22. 岛屿数量

**题目：** 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。

**答案：**

```python
def num_islands(grid):
    def dfs(i, j):
        grid[i][j] = '0'
        for x, y in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            ni, nj = i + x, j + y
            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == '1':
                dfs(ni, nj)

    m, n = len(grid), len(grid[0])
    count = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1
    return count

grid = [
    ["1", "1", "0", "0", "0"],
    ["1", "1", "0", "0", "0"],
    ["0", "0", "1", "0", "0"],
    ["0", "0", "1", "1", "1"],
]
result = num_islands(grid)
print(result)  # 输出：1
```

**解析：** 使用深度优先搜索（DFS）算法，依次遍历并标记网格中的岛屿。时间复杂度为 \(O(m \times n)\)，其中 \(m\) 是行数，\(n\) 是列数。

#### 23. 最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

s1 = "ABCD"
s2 = "ACDF"
result = longest_common_subsequence(s1, s2)
print(result)  # 输出：2
```

**解析：** 使用动态规划求解最长公共子序列。时间复杂度为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别是字符串的长度。

#### 24. 最小路径和

**题目：** 给定一个由整数组成的二维网格，求从左上角到右下角的最小路径和。

**答案：**

```python
def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]
    return dp[m][n]

grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
]
result = min_path_sum(grid)
print(result)  # 输出：7
```

**解析：** 使用动态规划求解最小路径和。时间复杂度为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别是网格的行数和列数。

#### 25. 最长连续序列

**题目：** 给定一个整数数组，求其中最长连续序列的长度。

**答案：**

```python
def longest_consecutive_sequence(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    result = 1
    count = 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            result = max(result, count)
        else:
            count = 1
    return result

nums = [100, 4, 200, 1, 3, 2]
result = longest_consecutive_sequence(nums)
print(result)  # 输出：4
```

**解析：** 将数组排序，然后遍历找出最长连续序列。时间复杂度为 \(O(n \log n)\)，其中 \(n\) 是数组的长度。

#### 26. 单调栈

**题目：** 实现一个单调栈，支持栈的基本操作（push、pop、top），并能够获取下一个更大元素。

**答案：**

```python
class MonotonicStack:

    def __init__(self):
        self.stack = []

    def push(self, val: int) -> None:
        while self.stack and self.stack[-1] < val:
            self.stack.pop()
        self.stack.append(val)

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def next_greater(self, nums) -> List[int]:
        result = [-1] * len(nums)
        stack = MonotonicStack()
        for i in range(len(nums)):
            stack.push(nums[i])
            result[i] = stack.top()
        return result
```

**解析：** 使用单调栈，依次弹出栈顶小于当前元素的情况。时间复杂度为 \(O(n)\)。

#### 27. 删除有序数组中的重复项 II

**题目：** 给定一个有序数组，删除重复项，使得每个元素出现至多两次，并返回新数组的长度。

**答案：**

```python
def remove_duplicates(nums):
    if not nums:
        return 0
    slow, fast = 0, 1
    while fast < len(nums):
        if nums[fast] == nums[slow]:
            fast += 1
        elif nums[fast] != nums[slow]:
            slow += 1
            nums[slow], nums[fast] = nums[fast], nums[slow]
        fast += 1
    return slow + 1
```

**解析：** 使用双指针法，依次检查当前元素和下一个元素是否相同。时间复杂度为 \(O(n)\)。

#### 28. 买卖股票的最佳时机 II

**题目：** 给定一个整数数组，代表某支股票每天的价格，求在任意时间点买入和卖出股票的最大利润。

**答案：**

```python
def max_profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    return profit

prices = [7, 1, 5, 3, 6, 4]
result = max_profit(prices)
print(result)  # 输出：7
```

**解析：** 遍历数组，每次当当天价格高于前一天价格时，计算利润并累加。时间复杂度为 \(O(n)\)。

#### 29. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
result = merge_sorted_lists(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
# 输出：1 2 3 4 5 6
```

**解析：** 使用递归合并两个链表。时间复杂度为 \(O(m + n)\)，其中 \(m\) 和 \(n\) 分别是两个链表的长度。

#### 30. 最小覆盖区间

**题目：** 给定一个由区间组成的数组，求覆盖所有区间的最小区间。

**答案：**

```python
def min覆盖区间(intervals):
    intervals.sort(key=lambda x: x[1])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if interval[0] >= result[-1][1]:
            result.append(interval)
        else:
            result[-1] = [min(result[-1][0], interval[0]), max(result[-1][1], interval[1])]
    return result

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
result = min覆盖区间(intervals)
print(result)  # 输出：[[1, 6], [8, 10], [15, 18]]
```

**解析：** 对区间进行排序后，依次合并覆盖的区间。时间复杂度为 \(O(n \log n)\)，其中 \(n\) 是区间的数量。

