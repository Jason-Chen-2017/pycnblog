                 

### 主题：信息差的商业创新管理：大数据如何推动创新管理

#### 一、典型问题/面试题库

### 1. 大数据如何定义？

**题目：** 请解释大数据的定义，并简要说明其与传统数据处理的主要区别。

**答案：** 

大数据是指无法使用传统数据处理工具（如单机数据库、简单的查询工具等）在合理时间内完成处理的数据集合。与传统数据处理相比，大数据通常具有以下特点：

1. **数据量（Volume）：** 海量，通常达到 TB、PB 甚至 ZB 级别。
2. **数据速度（Velocity）：** 数据生成、处理和传输的速度极快，要求实时或接近实时的处理能力。
3. **数据多样性（Variety）：** 数据类型丰富，包括结构化数据、半结构化数据和非结构化数据。
4. **数据真实性（Veracity）：** 数据的真实性难以保证，需要处理噪声、错误和不确定性。

### 2. 大数据的核心技术和工具有哪些？

**题目：** 请列举大数据领域中的核心技术和工具，并简要说明其作用。

**答案：**

大数据领域涉及众多核心技术和工具，以下是一些典型的：

1. **Hadoop：** 基于分布式计算框架，能够处理海量数据，包括 HDFS（分布式文件系统）、MapReduce（数据处理模型）等组件。
2. **Spark：** 高性能的分布式计算引擎，支持内存计算，适合实时数据处理和复杂算法。
3. **Hive：** 数据仓库工具，基于 Hadoop，提供 SQL 查询功能，方便对大数据进行结构化处理。
4. **HBase：** 分布式列式存储系统，支持海量数据的实时读写。
5. **Elasticsearch：** 分布式搜索引擎，用于处理大规模文本数据和日志数据。
6. **Kafka：** 分布式消息队列系统，用于处理高吞吐量的实时数据流。
7. **Flink：** 新一代分布式计算引擎，支持流处理和批处理。

### 3. 大数据在商业创新管理中的应用场景有哪些？

**题目：** 请列举大数据在商业创新管理中的应用场景，并简要说明其价值。

**答案：**

大数据在商业创新管理中的应用场景广泛，以下是一些典型应用：

1. **市场洞察：** 通过大数据分析，企业可以更准确地了解市场趋势、消费者行为，为产品创新和市场营销提供依据。
2. **风险控制：** 大数据可以帮助企业识别潜在风险，优化风险控制策略，降低运营风险。
3. **产品创新：** 通过对用户数据的分析，企业可以发现用户需求，推动产品创新和迭代。
4. **供应链优化：** 利用大数据技术，企业可以实现供应链的实时监控和优化，降低成本，提高效率。
5. **客户关系管理：** 通过大数据分析，企业可以更好地了解客户需求，提供个性化服务，提升客户满意度。
6. **人力资源优化：** 大数据可以帮助企业分析员工绩效、团队协作，优化人力资源配置。

#### 二、算法编程题库

### 1. 查找最近三个公共祖先节点

**题目：** 给定一个二叉树和两个节点 p 和 q，请找到它们的最近公共祖先节点。要求时间复杂度为 O(n)。

**答案：** 

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        parent = {root: None}
        stack = [root]
        while stack:
            node = stack.pop()
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            if node.right:
                parent[node.right] = node
                stack.append(node.right)
        ancestors_p = {self.getAncestor(p, parent)}
        while q:
            if q in ancestors_p:
                return q
            q = self.getAncestor(q, parent)
        return None

    def getAncestor(self, node, parent):
        while parent[node]:
            node = parent[node]
        return node
```

### 2. 求解最大子序列和

**题目：** 给定一个整数数组，求解其最大子序列和。

**答案：**

```python
def maxSubArray(nums):
    ans, curr_sum = nums[0], 0
    for num in nums[1:]:
        curr_sum = max(num, curr_sum + num)
        ans = max(ans, curr_sum)
    return ans
```

### 3. 求解第 k 小的元素

**题目：** 给定一个整数数组，求解第 k 小的元素。

**答案：**

```python
def findKthLargest(nums, k):
    n = len(nums)
    left, right = 0, n - 1
    while left <= right:
        pivot = partition(nums, left, right)
        if pivot == k - 1:
            return nums[pivot]
        elif pivot < k - 1:
            left = pivot + 1
        else:
            right = pivot - 1
    return -1

def partition(nums, left, right):
    pivot = nums[right]
    i = left
    for j in range(left, right):
        if nums[j] <= pivot:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
    nums[i], nums[right] = nums[right], nums[i]
    return i
```

### 4. 求解最长公共前缀

**题目：** 给定一个字符串数组，求解最长公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix
```

### 5. 求解最长连续序列

**题目：** 给定一个整数数组，求解最长连续序列的长度。

**答案：**

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans, count = 1, 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            ans = max(ans, count)
        else:
            count = 1
    return ans
```

### 6. 求解两个数组的交集

**题目：** 给定两个整数数组，求解它们的交集。

**答案：**

```python
def intersection(nums1, nums2):
    return sorted(set(nums1) & set(nums2))
```

### 7. 求解旋转矩阵后的最短路径

**题目：** 给定一个包含 0 和 1 的矩阵，求解从左上角到右下角的最短路径长度。

**答案：**

```python
def shortestPathBinaryMatrix(grid):
    n = len(grid)
    dist = [[float('inf')] * n for _ in range(n)]
    dist[0][0] = 1 if grid[0][0] == 1 else float('inf')
    q = [(1 if grid[0][0] else float('inf'), 0, 0)]
    while q:
        d, x, y = heappop(q)
        for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:
            nx, ny = x + a, y + b
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1:
                if dist[nx][ny] > d + 1:
                    dist[nx][ny] = d + 1
                    heappush(q, (d + 1, nx, ny))
    return dist[-1][-1]
```

### 8. 求解最长公共子序列

**题目：** 给定两个字符串，求解它们的最长公共子序列。

**答案：**

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

### 9. 求解最长递增子序列

**题目：** 给定一个整数数组，求解它的最长递增子序列。

**答案：**

```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

### 10. 求解两数之和

**题目：** 给定一个整数数组和一个目标值，求解数组中两个数的和等于目标值的下标。

**答案：**

```python
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

### 11. 求解打家劫舍

**题目：** 给定一个整数数组，求解最多能抢到的最大金额。

**答案：**

```python
def rob(nums):
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2, prev1 = 0, nums[0]
    for i in range(1, n):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    return prev1
```

### 12. 求解最长公共子串

**题目：** 给定两个字符串，求解它们的最长公共子串。

**答案：**

```python
def longestCommonSubstr(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    ans = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                ans = max(ans, dp[i][j])
            else:
                dp[i][j] = 0
    return ans
```

### 13. 求解最长公共子序列（LCS）

**题目：** 给定两个字符串，求解它们的最长公共子序列。

**答案：**

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

### 14. 求解最长连续序列

**题目：** 给定一个整数数组，求解最长连续序列的长度。

**答案：**

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans, count = 1, 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            ans = max(ans, count)
        else:
            count = 1
    return ans
```

### 15. 求解字符串的全排列

**题目：** 给定一个字符串，求解它的所有全排列。

**答案：**

```python
from itertools import permutations

def permutations(s):
    return [''.join(p) for p in permutations(s)]
```

### 16. 求解合并两个有序链表

**题目：** 给定两个有序链表，求解合并后的有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

### 17. 求解两数之和

**题目：** 给定一个整数数组和一个目标值，求解数组中两个数的和等于目标值的下标。

**答案：**

```python
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

### 18. 求解最长公共前缀

**题目：** 给定一个字符串数组，求解它们的公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix
```

### 19. 求解打家劫舍

**题目：** 给定一个整数数组，求解最多能抢到的最大金额。

**答案：**

```python
def rob(nums):
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2, prev1 = 0, nums[0]
    for i in range(1, n):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    return prev1
```

### 20. 求解两数之和

**题目：** 给定一个整数数组和一个目标值，求解数组中两个数的和等于目标值的下标。

**答案：**

```python
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

### 21. 求解合并两个有序链表

**题目：** 给定两个有序链表，求解合并后的有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

### 22. 求解最长公共子序列

**题目：** 给定两个字符串，求解它们的最长公共子序列。

**答案：**

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

### 23. 求解最长连续序列

**题目：** 给定一个整数数组，求解最长连续序列的长度。

**答案：**

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans, count = 1, 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            ans = max(ans, count)
        else:
            count = 1
    return ans
```

### 24. 求解字符串的全排列

**题目：** 给定一个字符串，求解它的所有全排列。

**答案：**

```python
from itertools import permutations

def permutations(s):
    return [''.join(p) for p in permutations(s)]
```

### 25. 求解合并两个有序链表

**题目：** 给定两个有序链表，求解合并后的有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

### 26. 求解两数之和

**题目：** 给定一个整数数组和一个目标值，求解数组中两个数的和等于目标值的下标。

**答案：**

```python
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

### 27. 求解最长公共前缀

**题目：** 给定一个字符串数组，求解它们的公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix
```

### 28. 求解打家劫舍

**题目：** 给定一个整数数组，求解最多能抢到的最大金额。

**答案：**

```python
def rob(nums):
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2, prev1 = 0, nums[0]
    for i in range(1, n):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    return prev1
```

### 29. 求解两数之和

**题目：** 给定一个整数数组和一个目标值，求解数组中两个数的和等于目标值的下标。

**答案：**

```python
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

### 30. 求解合并两个有序链表

**题目：** 给定两个有序链表，求解合并后的有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

### 完整代码示例

以下是一个完整的代码示例，包括所有题目及其答案：

```python
# 1. 查找最近三个公共祖先节点
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        parent = {root: None}
        stack = [root]
        while stack:
            node = stack.pop()
            if node.left:
                parent[node.left] = node
                stack.append(node.left)
            if node.right:
                parent[node.right] = node
                stack.append(node.right)
        ancestors_p = {self.getAncestor(p, parent)}
        while q:
            if q in ancestors_p:
                return q
            q = self.getAncestor(q, parent)
        return None

    def getAncestor(self, node, parent):
        while parent[node]:
            node = parent[node]
        return node

# 2. 求解最大子序列和
def maxSubArray(nums):
    ans, curr_sum = nums[0], 0
    for num in nums[1:]:
        curr_sum = max(num, curr_sum + num)
        ans = max(ans, curr_sum)
    return ans

# 3. 求解第 k 小的元素
def findKthLargest(nums, k):
    n = len(nums)
    left, right = 0, n - 1
    while left <= right:
        pivot = partition(nums, left, right)
        if pivot == k - 1:
            return nums[pivot]
        elif pivot < k - 1:
            left = pivot + 1
        else:
            right = pivot - 1
    return -1

def partition(nums, left, right):
    pivot = nums[right]
    i = left
    for j in range(left, right):
        if nums[j] <= pivot:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
    nums[i], nums[right] = nums[right], nums[i]
    return i

# 4. 求解最长公共前缀
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

# 5. 求解最长连续序列
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans, count = 1, 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            ans = max(ans, count)
        else:
            count = 1
    return ans

# 6. 求解两个数组的交集
def intersection(nums1, nums2):
    return sorted(set(nums1) & set(nums2))

# 7. 求解旋转矩阵后的最短路径
def shortestPathBinaryMatrix(grid):
    n = len(grid)
    dist = [[float('inf')] * n for _ in range(n)]
    dist[0][0] = 1 if grid[0][0] else float('inf')
    q = [(1 if grid[0][0] else float('inf'), 0, 0)]
    while q:
        d, x, y = heappop(q)
        for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:
            nx, ny = x + a, y + b
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1:
                if dist[nx][ny] > d + 1:
                    dist[nx][ny] = d + 1
                    heappush(q, (d + 1, nx, ny))
    return dist[-1][-1]

# 8. 求解最长公共子序列
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]

# 9. 求解最长递增子序列
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

# 10. 求解两数之和
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 11. 求解打家劫舍
def rob(nums):
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2, prev1 = 0, nums[0]
    for i in range(1, n):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    return prev1

# 12. 求解最长公共子串
def longestCommonSubstr(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    ans = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                ans = max(ans, dp[i][j])
            else:
                dp[i][j] = 0
    return ans

# 13. 求解最长公共子序列（LCS）
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]

# 14. 求解最长连续序列
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans, count = 1, 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            ans = max(ans, count)
        else:
            count = 1
    return ans

# 15. 求解字符串的全排列
from itertools import permutations

def permutations(s):
    return [''.join(p) for p in permutations(s)]

# 16. 求解合并两个有序链表
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 17. 求解两数之和
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 18. 求解最长公共前缀
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

# 19. 求解打家劫舍
def rob(nums):
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2, prev1 = 0, nums[0]
    for i in range(1, n):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    return prev1

# 20. 求解两数之和
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 21. 求解合并两个有序链表
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 22. 求解最长公共子序列
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]

# 23. 求解最长连续序列
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans, count = 1, 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            count += 1
            ans = max(ans, count)
        else:
            count = 1
    return ans

# 24. 求解字符串的全排列
from itertools import permutations

def permutations(s):
    return [''.join(p) for p in permutations(s)]

# 25. 求解合并两个有序链表
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 26. 求解两数之和
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 27. 求解最长公共前缀
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

# 28. 求解打家劫舍
def rob(nums):
    n = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2, prev1 = 0, nums[0]
    for i in range(1, n):
        curr = max(prev1, prev2 + nums[i])
        prev2 = prev1
        prev1 = curr
    return prev1

# 29. 求解两数之和
def twoSum(nums, target):
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 30. 求解合并两个有序链表
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

