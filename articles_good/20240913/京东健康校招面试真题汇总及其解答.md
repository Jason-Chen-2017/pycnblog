                 

### 2024京东健康校招面试真题汇总及其解答

#### 一、编程题

1. **实现一个带缓存的队列**

**题目描述：** 使用 Go 语言实现一个带缓存的队列，缓存大小为 `size`，如果队列满了，新加入的元素会覆盖最早加入的元素。

**答案：**

```go
package main

import "fmt"

type CacheQueue struct {
    items []int
    size  int
}

func NewCacheQueue(size int) *CacheQueue {
    return &CacheQueue{
        items: make([]int, size),
        size:  size,
    }
}

func (cq *CacheQueue) Enqueue(item int) {
    cq.items = append(cq.items, item)
    if len(cq.items) > cq.size {
        cq.items = cq.items[1:]
    }
}

func (cq *CacheQueue) Dequeue() int {
    if len(cq.items) == 0 {
        panic("Queue is empty")
    }
    item := cq.items[0]
    cq.items = cq.items[1:]
    return item
}

func main() {
    cq := NewCacheQueue(3)
    cq.Enqueue(1)
    cq.Enqueue(2)
    cq.Enqueue(3)
    cq.Enqueue(4)
    fmt.Println(cq.Dequeue()) // 输出 1
    fmt.Println(cq.Dequeue()) // 输出 2
}
```

2. **实现一个二叉树的层序遍历**

**题目描述：** 给定一个二叉树的根节点，实现二叉树的层序遍历。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        level := []int{}
        nextLevel := []*TreeNode{}

        for _, node := range queue {
            level = append(level, node.Val)

            if node.Left != nil {
                nextLevel = append(nextLevel, node.Left)
            }

            if node.Right != nil {
                nextLevel = append(nextLevel, node.Right)
            }
        }

        result = append(result, level)
        queue = nextLevel
    }

    return result
}

func main() {
    root := &TreeNode{
        Val:   1,
        Left:  &TreeNode{Val: 2},
        Right: &TreeNode{Val: 3},
    }

    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}
    root.Right.Left = &TreeNode{Val: 6}
    root.Right.Right = &TreeNode{Val: 7}

    fmt.Println(levelOrder(root)) // 输出：[[1] [2 3] [4 5 6 7]]
}
```

3. **实现一个单例模式**

**题目描述：** 使用 Go 语言实现一个单例模式。

**答案：**

```go
package main

import "sync"

type Singleton struct {
    // 成员变量
}

var (
    instance *Singleton
    once      sync.Once
)

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{}
    })

    return instance
}

func main() {
    s1 := GetInstance()
    s2 := GetInstance()

    fmt.Println(s1 == s2) // 输出：true
}
```

#### 二、算法题

1. **最长公共前缀**

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix); j++ {
            if j >= len(strs[i]) || strs[i][j] != prefix[j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    fmt.Println(longestCommonPrefix([]string{"flower", "flow", "flight"})) // 输出：fl
}
```

2. **两数相加**

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只存储单个数字。请将这两个数相加，并以相同形式返回一个表示和的链表。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10

        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{2, &ListNode{4, &ListNode{3}}}
    l2 := &ListNode{5, &ListNode{6, &ListNode{4}}}
    fmt.Println(addTwoNumbers(l1, l2)) // 输出：7 -> 0 -> 5
}
```

3. **反转链表**

**题目描述：** 反转一个单链表。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head

    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}

func main() {
    head := &ListNode{1, &ListNode{2, &ListNode{3, &ListNode{4, &ListNode{5}}}}}
    newHead := reverseList(head)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

#### 三、综合题

1. **设计一个队列**

**题目描述：** 请设计一个队列，支持基本的队列操作（入队、出队、获取队首元素）和统计队列中元素的数量。

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    Val  int
    Next *Node
}

type MyQueue struct {
    head *Node
    tail *Node
    size int
}

func NewQueue() *MyQueue {
    return &MyQueue{}
}

func (q *MyQueue) Enqueue(val int) {
    node := &Node{Val: val}
    if q.tail == nil {
        q.head = node
    } else {
        q.tail.Next = node
    }
    q.tail = node
    q.size++
}

func (q *MyQueue) Dequeue() int {
    if q.head == nil {
        panic("Queue is empty")
    }
    val := q.head.Val
    q.head = q.head.Next
    if q.head == nil {
        q.tail = nil
    }
    q.size--
    return val
}

func (q *MyQueue) Front() int {
    if q.head == nil {
        panic("Queue is empty")
    }
    return q.head.Val
}

func (q *MyQueue) Size() int {
    return q.size
}

func main() {
    queue := NewQueue()
    queue.Enqueue(1)
    queue.Enqueue(2)
    queue.Enqueue(3)
    fmt.Println(queue.Dequeue()) // 输出 1
    fmt.Println(queue.Front())    // 输出 2
    fmt.Println(queue.Size())     // 输出 2
}
```

2. **设计一个缓存**

**题目描述：** 请设计一个缓存系统，支持基本的缓存操作（设置、获取、删除）和缓存容量限制。

**答案：**

```go
package main

import (
    "fmt"
)

type Cache struct {
    capacity int
    cacheMap map[int]int
    used      int
}

func NewCache(capacity int) *Cache {
    return &Cache{
        capacity: capacity,
        cacheMap: make(map[int]int),
    }
}

func (c *Cache) Set(key int, value int) {
    if c.used >= c.capacity {
        oldestKey := -1
        oldestValue := -1
        for k, v := range c.cacheMap {
            if oldestKey == -1 || c.cacheMap[oldestKey] > v {
                oldestKey = k
                oldestValue = v
            }
        }
        delete(c.cacheMap, oldestKey)
        c.used--
    }
    c.cacheMap[key] = value
    c.used++
}

func (c *Cache) Get(key int) int {
    if val, ok := c.cacheMap[key]; ok {
        return val
    }
    return -1
}

func (c *Cache) Delete(key int) {
    if _, ok := c.cacheMap[key]; ok {
        delete(c.cacheMap, key)
        c.used--
    }
}

func main() {
    cache := NewCache(2)
    cache.Set(1, 10)
    cache.Set(2, 20)
    fmt.Println(cache.Get(1)) // 输出 10
    cache.Set(3, 30)
    fmt.Println(cache.Get(2)) // 输出 -1
}
```

3. **设计一个日志系统**

**题目描述：** 请设计一个日志系统，支持日志的写入、查询和删除操作，并支持日志文件滚动。

**答案：**

```go
package main

import (
    "fmt"
    "os"
    "path/filepath"
    "time"
)

type LogEntry struct {
    Time   time.Time
    Level  string
    Message string
}

type Logger struct {
    filename   string
    maxFileSize int64
    logEntries []LogEntry
}

func NewLogger(filename string, maxFileSize int64) *Logger {
    return &Logger{
        filename:   filename,
        maxFileSize: maxFileSize,
        logEntries: []LogEntry{},
    }
}

func (l *Logger) Write(entry LogEntry) {
    l.logEntries = append(l.logEntries, entry)
    if err := l.rotateFile(); err != nil {
        fmt.Println("Error rotating file:", err)
    }
}

func (l *Logger) rotateFile() error {
    fi, err := os.Stat(l.filename)
    if err != nil {
        return err
    }

    if fi.Size() >= l.maxFileSize {
        newFilename := l.filename + "." + time.Now().Format("20060102-150405")
        err := os.Rename(l.filename, newFilename)
        if err != nil {
            return err
        }
        l.filename = newFilename
        l.logEntries = []LogEntry{}
    }
    return nil
}

func (l *Logger) GetEntries() []LogEntry {
    return l.logEntries
}

func (l *Logger) DeleteEntry(entry LogEntry) {
    index := -1
    for i, e := range l.logEntries {
        if e == entry {
            index = i
            break
        }
    }
    if index != -1 {
        l.logEntries = append(l.logEntries[:index], l.logEntries[index+1:]...)
    }
}

func main() {
    logger := NewLogger("log.txt", 1024)
    logger.Write(LogEntry{Time: time.Now(), Level: "INFO", Message: "This is an info message"})
    logger.Write(LogEntry{Time: time.Now(), Level: "ERROR", Message: "This is an error message"})
    fmt.Println(logger.GetEntries())
    logger.DeleteEntry(logger.GetEntries()[0])
    fmt.Println(logger.GetEntries())
}
```

4. **设计一个负载均衡器**

**题目描述：** 请设计一个简单的负载均衡器，支持请求的分发和节点的添加/移除。

**答案：**

```go
package main

import (
    "fmt"
    "sync"
)

type LoadBalancer struct {
    nodes      map[string]int
    nodeCount  int
    sync.Mutex
}

func NewLoadBalancer() *LoadBalancer {
    return &LoadBalancer{
        nodes: make(map[string]int),
        nodeCount: 0,
    }
}

func (l *LoadBalancer) AddNode(nodeName string) {
    l.Lock()
    defer l.Unlock()

    l.nodes[nodeName] = 0
    l.nodeCount++
}

func (l *LoadBalancer) RemoveNode(nodeName string) {
    l.Lock()
    defer l.Unlock()

    if _, exists := l.nodes[nodeName]; exists {
        delete(l.nodes, nodeName)
        l.nodeCount--
    }
}

func (l *LoadBalancer) GetNode() string {
    l.Lock()
    defer l.Unlock()

    randNode := rand.Intn(l.nodeCount)
    nodeIndex := 0
    for nodeName, count := range l.nodes {
        if nodeIndex == randNode {
            return nodeName
        }
        nodeIndex++
    }
    return ""
}

func main() {
    lb := NewLoadBalancer()
    lb.AddNode("node1")
    lb.AddNode("node2")
    lb.AddNode("node3")

    for i := 0; i < 10; i++ {
        node := lb.GetNode()
        fmt.Println("Request", i, "sent to node", node)
    }
}
```

### 总结

以上是2024京东健康校招面试真题汇总及其解答的详细内容。希望这些题目和答案能够帮助准备京东健康面试的同学更好地应对面试挑战。同时，也欢迎在评论区提出任何问题和建议，我们会尽力为大家解答。祝大家面试顺利，成功拿到心仪的offer！

