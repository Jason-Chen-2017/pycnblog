                 

### 1. 如何判断一个数是否是回文数？

**题目：** 编写一个函数，用于判断一个整数是否是回文数。回文数是指正读和反读都一样的整数。

**答案：** 

```python
def isPalindrome(x: int) -> bool:
    if x < 0 or (x % 10 == 0 and x != 0):  # 回文数的最高位和最低位都不为 0
        return False
    reversed_num = 0
    while x > reversed_num:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
    return x == reversed_num or x == reversed_num // 10

# 示例
print(isPalindrome(121))  # True
print(isPalindrome(-121))  # False
print(isPalindrome(10))  # False
```

**解析：** 

该函数首先检查输入的整数是否符合回文数的条件，即最高位和最低位都不为 0。然后，通过不断将 x 的个位数添加到 reversed_num 变量，并将 x 除以 10 来反转 x 的数字。当 x 变为小于或等于 reversed_num 时，可以通过比较 x 和 reversed_num 或 reversed_num 除以 10 来判断 x 是否为回文数。

### 2. 无重复字符的最长子串

**题目：** 给定一个字符串 s ，找出其中不含有重复字符的最长子串的长度。

**答案：**

```python
def lengthOfLongestSubstring(s: str) -> int:
    n = len(s)
    ans = 0
    # 将字符串转换为字符数组
    char_array = list(s)
    # 使用双指针和哈希表
    visited = {}
    i = 0
    for j in range(n):
        if char_array[j] in visited:
            i = max(i, visited[char_array[j]] + 1)
        visited[char_array[j]] = j
        ans = max(ans, j - i + 1)
    return ans

# 示例
print(lengthOfLongestSubstring("abcabcbb"))  # 3
print(lengthOfLongestSubstring("bbbbb"))  # 1
print(lengthOfLongestSubstring("pwwkew"))  # 3
```

**解析：**

该函数使用双指针和哈希表来找到不含有重复字符的最长子串。`i` 指针指向子串的起始位置，`j` 指针指向子串的结束位置。`visited` 哈希表用于存储字符到最后一次出现的位置。在遍历字符串时，如果当前字符已存在于哈希表中，则更新 `i` 指针的位置，以便跳过重复字符。最后，更新最长子串的长度。

### 3. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next
        curr.next = list1 or list2
        return dummy.next

# 示例
list1 = ListNode(1, ListNode(2, ListNode(4)))
list2 = ListNode(1, ListNode(3, ListNode(4)))
merged = Solution().mergeTwoLists(list1, list2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**解析：**

该函数使用一个哑节点 `dummy` 作为新链表的头节点，`curr` 指针用于遍历新链表。当两个链表都有节点时，比较当前节点值，将较小的节点链接到新链表中，并移动对应的链表指针。最后，将剩余的链表直接链接到新链表的末尾。

### 4. 有效的括号

**题目：** 给定一个字符串 `s` ，判断 `s` 是否为有效的括号字符串，即：

- 字符串是一个空字符串，或者
- 字符串可以表示一个装满水的或不装满水的无空隙括号组合。
- 可以根据需要多次使用 `(` 和 `)` 。

**答案：**

```python
def isValid(s: str) -> bool:
    stack = []
    for char in s:
        if char == '(' or char == '{' or char == '[':
            stack.append(char)
        elif char == ')' and len(stack) > 0 and stack[-1] == '(':
            stack.pop()
        elif char == '}' and len(stack) > 0 and stack[-1] == '{':
            stack.pop()
        elif char == ']' and len(stack) > 0 and stack[-1] == '[':
            stack.pop()
        else:
            return False
    return len(stack) == 0

# 示例
print(isValid("()"))  # True
print(isValid("()[]{}"))  # True
print(isValid("(]"))  # False
```

**解析：**

该函数使用栈来跟踪未匹配的括号。对于每个字符，如果它是左括号，则将其压入栈中；如果它是右括号，则检查栈顶元素是否与之匹配。如果不匹配或栈为空，则返回 False。最后，如果栈为空，则返回 True。

### 5. 合并两个有序数组

**题目：** 给定两个已经排序好的整数数组 `nums1` 和 `nums2` ，请你将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**答案：**

```python
def merge(nums1, m, nums2, n):
    i = m - 1
    j = n - 1
    k = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1

# 示例
nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
merge(nums1, 3, nums2, 3)
print(nums1)  # 输出 [1, 2, 2, 3, 5, 6]

nums1 = [1]
nums2 = []
merge(nums1, 1, nums2, 0)
print(nums1)  # 输出 [1]
```

**解析：**

该函数从后向前比较两个数组中的元素，将较大的元素填充到 `nums1` 的末尾。首先，从两个数组的末尾开始比较，较大的元素填充到 `nums1` 的末尾。如果 `nums1` 的数组空间不足，则将 `nums2` 的剩余元素填充到 `nums1` 中。

### 6. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix

# 示例
print(longestCommonPrefix(["flower","flow","flight"]))  # "fl"
print(longestCommonPrefix(["dog","racecar","car"]))  # ""
```

**解析：**

该函数首先将第一个字符串作为公共前缀 `prefix`。然后，遍历其余字符串，每次将 `prefix` 与当前字符串比较，如果当前字符串不以 `prefix` 作为前缀，则缩短 `prefix` 的长度，直到找到最长公共前缀。如果找不到公共前缀，则返回空字符串。

### 7. 字符串转换大写字母

**题目：** 实现一个函数，将小写字母和大写字母转换为对应的数字。例如，'a' 转换为 '1'，'b' 转换为 '2'，...，'z' 转换为 '26'。'A' 转换为 '27'，'B' 转换为 '28'，...，'Z' 转换为 '52'。

**答案：**

```python
def toLowerCase(char):
    return chr(ord(char) - 32) if 'A' <= char <= 'Z' else char

def toUpperCase(char):
    return chr(ord(char) + 32) if 'a' <= char <= 'z' else char

def toDigital(char):
    return ord(toLowerCase(char)) - ord('a') + 1 if 'a' <= char <= 'z' else ord(toLowerCase(char)) - ord('A') + 27

# 示例
print(toDigital('a'))  # 1
print(toDigital('z'))  # 26
print(toDigital('A'))  # 27
print(toDigital('Z'))  # 52
```

**解析：**

该函数首先使用 `toLowerCase` 和 `toUpperCase` 函数将字符转换为对应的小写或大写字母。然后，根据字符的 ASCII 码值，将其转换为对应的数字。小写字母 'a' 到 'z' 转换为 1 到 26，大写字母 'A' 到 'Z' 转换为 27 到 52。

### 8. 螺旋矩阵

**题目：** 给定一个 `m x n` 的二维矩阵，按照顺时针螺旋顺序，返回矩阵中的所有元素。

**答案：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    ans = []
    left, right = 0, len(matrix[0])
    top, bottom = 0, len(matrix)
    while True:
        for i in range(left, right):
            ans.append(matrix[top][i])
        top += 1
        if top == bottom:
            break
        for i in range(top, bottom):
            ans.append(matrix[i][right - 1])
        right -= 1
        if left == right:
            break
        for i in range(right - 1, left - 1, -1):
            ans.append(matrix[bottom - 1][i])
        bottom -= 1
        if top == bottom:
            break
        for i in range(bottom - 1, top - 1, -1):
            ans.append(matrix[i][left])
        left += 1
    return ans

# 示例
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(spiralOrder(matrix))  # [1, 2, 3, 6, 9, 8, 7, 4, 5]
```

**解析：**

该函数通过四个边界值 `left`，`right`，`top` 和 `bottom` 来遍历矩阵。首先，遍历顶部行的所有元素，然后将 `top` 增加 1。然后，遍历右侧列的所有元素，将 `right` 减少 1。接着，遍历底部行的所有元素，将 `bottom` 减少 1。最后，遍历左侧列的所有元素，将 `left` 增加 1。每次遍历后，检查四个边界值是否重合，如果重合，则退出循环。

### 9. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 示例
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**解析：**

该函数创建一个哑节点 `dummy` 作为新链表的头节点，`curr` 指针用于遍历新链表。当两个链表都有节点时，比较当前节点值，将较小的节点链接到新链表中，并移动对应的链表指针。最后，将剩余的链表直接链接到新链表的末尾。

### 10. 找到字符串中第一个匹配到的子串位置

**题目：** 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出第一个匹配的 needle 子串的位置（下标从 0 开始）。如果不存在，返回 -1。

**答案：**

```python
def strStr(haystack: str, needle: str) -> int:
    return haystack.find(needle)

# 示例
print(strStr("sunday", "sun"))  # 0
print(strStr("sunday", "nday"))  # 3
print(strStr("sunday", "mon"))  # -1
```

**解析：**

该函数使用 Python 的内置方法 `find()` 来找到子字符串 `needle` 在 `haystack` 中的第一个匹配位置。如果找到匹配，返回位置索引；否则，返回 -1。

### 11. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last_end = ans[-1][1]
        if interval[0] <= last_end:
            ans[-1][1] = max(last_end, interval[1])
        else:
            ans.append(interval)
    return ans

# 示例
intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # [[1,6],[8,10],[15,18]]
```

**解析：**

该函数首先对区间列表进行排序，然后遍历排序后的列表，将重叠的区间合并。如果当前区间的开始位置小于或等于前一个区间的结束位置，则将两个区间的结束位置合并。否则，将当前区间添加到结果列表中。

### 12. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))  # [0, 1]
```

**解析：**

该函数使用一个哈希表 `hashmap` 来存储已经遍历过的数字及其索引。对于每个数字，计算其补数，然后检查补数是否已经在哈希表中。如果存在，返回两个数字的索引；否则，将当前数字及其索引添加到哈希表中，继续遍历。

### 13. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。最长公共子序列（LCS）是指两个序列中具有最长相同顺序的子序列。

**答案：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

# 示例
text1 = "abcde"
text2 = "ace"
print(longestCommonSubsequence(text1, text2))  # "ace"
```

**解析：**

该函数使用动态规划来求解最长公共子序列。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。遍历两个字符串，如果当前字符相同，则 `dp[i][j] = dp[i - 1][j - 1] + 1`；否则，取最大值 `dp[i - 1][j]` 或 `dp[i][j - 1]`。最后，返回 `dp[m][n]`。

### 14. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix

# 示例
print(longestCommonPrefix(["flower","flow","flight"]))  # "fl"
print(longestCommonPrefix(["dog","racecar","car"]))  # ""
```

**解析：**

该函数首先将第一个字符串作为公共前缀 `prefix`。然后，遍历其余字符串，每次将 `prefix` 与当前字符串比较，如果当前字符串不以 `prefix` 作为前缀，则缩短 `prefix` 的长度，直到找到最长公共前缀。如果找不到公共前缀，则返回空字符串。

### 15. 快乐数

**题目：** 编写一个算法来判断一个数是不是“快乐数”。

**答案：**

```python
def isHappy(n):
    def get_next(num):
        sum = 0
        while num:
            sum += (num % 10) ** 2
            num //= 10
        return sum

    slow, fast = n, get_next(n)
    while fast != 1:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
        if slow == fast:
            return False
    return True

# 示例
print(isHappy(19))  # True
print(isHappy(1))  # True
print(isHappy(2))  # False
```

**解析：**

该函数使用快慢指针法来判断一个数是否为快乐数。定义一个辅助函数 `get_next` 来计算下一个数。快指针 `fast` 每次移动两次，慢指针 `slow` 每次移动一次。如果快指针遇到 1，则说明是快乐数，返回 True。如果快慢指针相遇，说明进入循环，返回 False。

### 16. 单调栈

**题目：** 实现一个单调栈，用于找出每个元素对应前一个元素中离它最近的、比它大的元素。

**答案：**

```python
def nextGreaterElement(nums1, nums2):
    stack = []
    result = [-1] * len(nums1)
    for num in nums2:
        while stack and stack[-1] < num:
            result[stack.pop()] = num
        stack.append(num)
    for num in nums1:
        while stack and stack[-1] < num:
            result[stack.pop()] = num
        stack.append(num)
    return result

# 示例
nums1 = [4,1,2]
nums2 = [1,3,4,2]
print(nextGreaterElement(nums1, nums2))  # [3,2,-1,4]
```

**解析：**

该函数使用单调栈来找出每个元素对应前一个元素中离它最近的、比它大的元素。遍历 `nums2` 时，如果栈顶元素小于当前元素，则将栈顶元素从结果数组中弹出，并将其下一个元素设置为当前元素。遍历 `nums1` 时，重复上述过程，直到栈为空或栈顶元素大于当前元素。

### 17. 二进制表示中的数字范围

**题目：** 给定一个整数 n，返回一个字符串数组 answers，其中 answers[i] 是字符串形式的二进制表示 `i` 中包含的 `1` 的个数（`i` 从 1 到 `n`）。

**答案：**

```python
def binarylorems(n):
    answers = []
    for i in range(1, n + 1):
        answers.append(bin(i).count('1'))
    return answers

# 示例
print(binarylorems(5))  # [1, 1, 2, 1, 2]
```

**解析：**

该函数遍历从 1 到 n 的每个整数，使用 `bin()` 函数将其转换为二进制字符串，并使用 `count()` 函数计算二进制字符串中 '1' 的个数。将结果添加到答案列表中。

### 18. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶楼梯才能到达楼顶。每次可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**答案：**

```python
def climbStairs(n):
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

# 示例
print(climbStairs(2))  # 2
print(climbStairs(3))  # 3
```

**解析：**

该函数使用动态规划来计算爬楼梯的方法数。定义一个一维数组 `dp`，其中 `dp[i]` 表示到达第 i 阶楼梯的方法数。根据状态转移方程 `dp[i] = dp[i - 1] + dp[i - 2]`，计算每个阶梯的方法数。

### 19. 暴力求解法

**题目：** 设计一个函数，用于计算一个给定字符串的字典序前一个字符串。如果不存在字典序前的字符串，则返回空字符串。

**答案：**

```python
def prevString(s):
    if not s:
        return ""
    for i in range(len(s) - 1, -1, -1):
        if s[i] > s[i - 1]:
            t = s[i - 1]
            while i < len(s) and s[i] == s[i - 1]:
                i += 1
            return s[:i] + chr(ord(s[i - 1]) - 1) + s[i:]
    return ""

# 示例
print(prevString("abcd"))  # "acd"
print(prevString("abc"))  # "ab"
print(prevString("ab"))  # ""
```

**解析：**

该函数通过逆向遍历字符串，寻找第一个比前一个字符小的字符。找到后，将该字符的 ASCII 码值减 1，并将该字符后的所有字符顺序不变地连接在前面。如果不存在比前一个字符小的字符，则返回空字符串。

### 20. 合并两个有序链表

**题目：** 给定两个有序链表 `l1` 和 `l2`，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next

# 示例
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = Solution().mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**解析：**

该函数使用哑节点 `dummy` 作为新链表的头节点，`curr` 指针用于遍历新链表。当两个链表都有节点时，比较当前节点值，将较小的节点链接到新链表中，并移动对应的链表指针。最后，将剩余的链表直接链接到新链表的末尾。

### 21. 最小栈

**题目：** 设计一个支持 push ，pop ，top 操作的栈，同时可以实现获取最小元素的操作。

**答案：**

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**解析：**

该函数实现了一个最小栈。使用两个栈：`stack` 用于存储元素，`min_stack` 用于存储最小元素。每次插入元素时，如果元素小于等于 `min_stack` 的栈顶元素，则将元素同时压入 `min_stack`。每次弹出元素时，如果弹出的元素等于 `min_stack` 的栈顶元素，则同时弹出 `min_stack` 的栈顶元素。

### 22. 图的深度优先搜索

**题目：** 使用深度优先搜索算法实现一个图遍历。

**答案：**

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)
        self.graph[v].append(u)

    def dfs(self, v, visited, ans):
        visited[v] = True
        ans.append(v)
        for neighbor in self.graph[v]:
            if not visited[neighbor]:
                self.dfs(neighbor, visited, ans)

    def traverse(self, start):
        visited = [False] * (max(self.graph) + 1)
        ans = []
        self.dfs(start, visited, ans)
        return ans

# 示例
g = Graph()
g.add_edge(0, 1)
g.add_edge(1, 2)
g.add_edge(2, 0)
g.add_edge(1, 3)
print(g.traverse(0))  # [0, 1, 3, 2]
```

**解析：**

该函数使用深度优先搜索（DFS）算法遍历图。首先创建一个图类 `Graph`，其中包含一个邻接表 `graph`。添加边时，将节点添加到相邻节点的列表中。遍历函数 `dfs` 用于递归遍历图。首先标记当前节点为已访问，将其添加到答案列表中，然后递归遍历相邻节点。主函数 `traverse` 初始化一个访问数组 `visited` 和答案列表 `ans`，然后调用 `dfs` 函数，并返回答案列表。

### 23. 快速排序

**题目：** 实现快速排序算法。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 示例
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # [1, 1, 2, 3, 6, 8, 10]
```

**解析：**

该函数使用快速排序（QuickSort）算法对列表进行排序。首先选择一个基准值 `pivot`，然后将列表划分为三个部分：小于 `pivot` 的元素、等于 `pivot` 的元素和大于 `pivot` 的元素。递归地对小于和大于 `pivot` 的元素列表进行排序，并将它们合并。

### 24. 二分查找

**题目：** 实现二分查找算法。

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 示例
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(binary_search(arr, 5))  # 4
print(binary_search(arr, 11))  # -1
```

**解析：**

该函数使用二分查找算法在一个有序数组中查找目标值。初始化两个指针 `left` 和 `right`，然后通过不断缩小区间来查找目标值。如果找到目标值，返回其索引；否则，返回 -1。

### 25. 逆波兰表达式求值

**题目：** 计算逆波兰表达式（Postfix Notation）的值。

**答案：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            op2 = stack.pop()
            op1 = stack.pop()
            if token == "+":
                stack.append(op1 + op2)
            elif token == "-":
                stack.append(op1 - op2)
            elif token == "*":
                stack.append(op1 * op2)
            elif token == "/":
                stack.append(int(op1 / op2))
        else:
            stack.append(int(token))
    return stack.pop()

# 示例
tokens = ["2", "1", "+", "3", "*"]
print(evalRPN(tokens))  # 9
```

**解析：**

该函数使用栈实现逆波兰表达式的求值。遍历每个字符，如果字符为操作符，则弹出栈顶的两个元素进行运算，并将结果压入栈中；如果字符为数字，则直接压入栈中。最后，栈顶元素即为表达式的值。

### 26. 字符串相加

**题目：** 实现一个函数，用于计算两个字符串表示的非负整数之和。

**答案：**

```python
def addStrings(num1, num2):
    i, j = len(num1) - 1, len(num2) - 1
    carry = 0
    result = []
    while i >= 0 or j >= 0 or carry:
        x = int(num1[i]) if i >= 0 else 0
        y = int(num2[j]) if j >= 0 else 0
        sum = x + y + carry
        carry = sum // 10
        result.append(str(sum % 10))
        i, j = i - 1, j - 1
    return ''.join(result[::-1])

# 示例
num1 = "11"
num2 = "123"
print(addStrings(num1, num2))  # "234"
```

**解析：**

该函数从字符串的末尾开始，依次计算两个字符串表示的数字之和。如果当前位相加的结果大于等于 10，则进位。最后，将结果字符串反转返回。

### 27. 电话号码的字母组合

**题目：** 给定一个仅包含数字 2-9 的字符串，返回所有可能用数字所表示的字母组合。

**答案：**

```python
def letterCombinations(digits):
    mapping = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    if not digits:
        return []
    if len(digits) == 1:
        return [c for c in mapping[digits]]
    ans = []
    for c in mapping[digits[0]]:
        for x in letterCombinations(digits[1:]):
            ans.append(c + x)
    return ans

# 示例
digits = "23"
print(letterCombinations(digits))  # ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']
```

**解析：**

该函数使用递归和回溯来生成所有可能的字母组合。首先创建一个映射字典，将每个数字映射到对应的字母组合。然后，递归地处理剩余的数字，并将当前数字对应的字母组合与递归调用返回的结果连接起来。

### 28. 合并两个有序链表

**题目：** 给定两个单链表，分别代表两个非递减有序序列，合并这两个有序链表并返回一个新链表。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2

# 示例
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged = Solution().mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**解析：**

该函数递归地合并两个有序链表。如果 `l1` 的值小于 `l2` 的值，则将 `l1` 的下一个节点与 `l2` 递归合并；否则，将 `l2` 的下一个节点与 `l1` 递归合并。最终返回较小的节点作为新的链表头。

### 29. 盗贼的得手

**题目：** 给定一个数组，其中包含非负整数，每个数表示从位置到宝藏的距离。小偷有一分钟的时间到达宝藏。请你计算小偷一分钟内最多可以盗取多少宝藏。

**答案：**

```python
def max_loot(nums):
    max_lose = -nums[0]
    max_profit = 0
    for num in nums[1:]:
        temp = max_profit
        max_profit = max(max_lose + num, max_profit)
        max_lose = temp
    return max_profit

# 示例
nums = [1, 2, 3, 1]
print(max_loot(nums))  # 4
```

**解析：**

该函数使用动态规划来计算小偷一分钟内最多可以盗取多少宝藏。定义两个变量 `max_profit` 和 `max_lose`，分别表示最大利润和最大亏损。遍历数组时，更新 `max_profit` 和 `max_lose` 的值。最终，`max_profit` 的值即为小偷一分钟内最多可以盗取的宝藏数量。

### 30. 合并区间

**题目：** 给定一组区间，请你合并所有重叠的区间。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort()
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last = ans[-1]
        if last[1] >= interval[0]:
            ans[-1] = (last[0], max(last[1], interval[1]))
        else:
            ans.append(interval)
    return ans

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # [[1, 6], [8, 10], [15, 18]]
```

**解析：**

该函数首先对区间列表进行排序。然后，遍历区间列表，合并重叠的区间。如果当前区间的开始位置大于前一个区间的结束位置，则将当前区间添加到结果列表中。否则，将两个区间的结束位置合并。最后，返回合并后的区间列表。

