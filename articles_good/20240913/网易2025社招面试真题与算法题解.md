                 

## 网易2025社招面试真题与算法题解

### 1. 判断二进制中1的个数

**题目描述：** 编写一个函数，输入一个整数（以二进制字符串形式），返回这个数二进制表示中1的个数。例如，若输入"11"，则返回2。

**答案解析：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 该函数通过位运算来统计二进制中1的个数。使用`&`运算符检查当前位是否为1，如果是，则将计数器加1。然后，使用`>>`运算符将数字右移一位，继续检查下一位。

### 2. 二维数组和矩阵的查找

**题目描述：** 给定一个二维数组（数组中每个元素都是整数），编写一个函数，在该数组中查找一个特定的值。数组中的数按照每一行从左到右递增，每一列从上到下递增。

**答案解析：**

```go
func searchMatrix(matrix [][]int, target int) bool {
    rows := len(matrix)
    cols := len(matrix[0])
    row := 0
    col := cols - 1

    for row < rows && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] < target {
            row++
        } else {
            col--
        }
    }
    return false
}
```

**解析：** 使用“搜索二维数组”的方法。从左下角开始，如果当前元素小于目标值，向上移动；如果当前元素大于目标值，向右移动；如果当前元素等于目标值，返回true。这个方法可以确保每次移动都尽可能接近目标值。

### 3. 快速排序

**题目描述：** 实现快速排序算法，对数组进行升序排序。

**答案解析：**

```go
func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }

    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)

    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }

    quickSort(left)
    quickSort(right)

    arr = append(append(left, middle...), right...)
}
```

**解析：** 快速排序的核心思想是通过选取一个基准值（pivot），将数组分成两部分：小于基准值的部分和大于基准值的部分。然后递归地对这两部分进行快速排序。

### 4. 合并两个有序链表

**题目描述：** 合并两个有序链表并返回新的链表。新链表中不应有重复元素。

**答案解析：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

type ListNode struct {
    Val  int
    Next *ListNode
}
```

**解析：** 使用递归方法合并两个有序链表。每次递归都选择两个链表中值较小的节点作为新链表的一个节点，然后递归地对剩余的链表进行合并。

### 5. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if j, ok := m[target-num]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

**解析：** 使用哈希表存储已遍历的数字及其索引。遍历数组时，对于每个数字，都检查哈希表中是否存在与该数字相加等于目标值的另一个数字。如果存在，返回两个数字的索引。

### 6. 罗马数字转换

**题目描述：** 罗马数字包含以下七种字符: I，V，X，L，C，D 和 M。

**答案解析：**

```go
func romanToInt(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    ans := 0
    prev := 0
    for _, c := range s {
        cur := m[c]
        if cur > prev {
            ans -= 2 * prev
        }
        ans += cur
        prev = cur
    }
    return ans
}
```

**解析：** 遍历字符串，将罗马数字转换为整数。对于连续的相同字符，只计算最后一个字符的值；如果当前字符的值大于前一个字符的值，则从前一个字符的值中减去两个前一个字符的值。

### 7. 反转字符串

**题目描述：** 编写一个函数，其功能是反转字符串中的内容。

**答案解析：**

```go
func reverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i := 0; i < n/2; i++ {
        runes[i], runes[n-1-i] = runes[n-1-i], runes[i]
    }
    return string(runes)
}
```

**解析：** 将字符串转换为 rune 切片，然后交换前半部分和后半部分的字符。

### 8. 字符串转换整数 (atoi)

**题目描述：** 实现一个 atoi 函数，它可以将字符串转换为整数。

**答案解析：**

```go
func myAtoi(s string) int {
    if s == "" {
        return 0
    }
    sign := 1
    if s[0] == '-' {
        sign = -1
    }
    start := 0
    if s[0] == '+' || s[0] == '-' {
        start = 1
    }
    num := 0
    for i := start; i < len(s); i++ {
        if s[i] < '0' || s[i] > '9' {
            break
        }
        num = num*10 + int(s[i]-'0')
        if num < 0 {
            return int((1 << 31) - 1)
        }
        if num > 0 && num > int((1 << 31)-1)/10 {
            return int((1 << 31)-1)
        }
    }
    return sign * num
}
```

**解析：** 遍历字符串，跳过前导空格和符号位，然后逐位将字符转换为数字。在转换过程中，检查数字是否超出整数范围。

### 9. 链表反转

**题目描述：** 反转单链表。

**答案解析：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head
    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}

type ListNode struct {
    Val  int
    Next *ListNode
}
```

**解析：** 使用三个指针变量 `prev`、`cur` 和 `nextTemp`。`prev` 指向当前节点的上一个节点，`cur` 指向当前节点，`nextTemp` 指向当前节点的下一个节点。循环中，将当前节点的 `next` 指针指向 `prev`，然后移动三个指针。

### 10. 最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）。返回其最大和。

**答案解析：**

```go
func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    currMax := nums[0]
    for i := 1; i < len(nums); i++ {
        currMax = max(nums[i], currMax+nums[i])
        maxSoFar = max(maxSoFar, currMax)
    }
    return maxSoFar
}
```

**解析：** 使用“动态规划”的方法。`maxSoFar` 是迄今为止的最大子序和，`currMax` 是当前子序和。每次迭代，计算当前元素加入子序列时的最大子序和，并更新最大子序和。

### 11. 二分查找

**题目描述：** 实现一个二分查找函数，在排序数组中查找一个特定的值。

**答案解析：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**解析：** 使用“二分查找”算法。每次迭代，计算中间值，如果中间值等于目标值，返回索引；如果中间值小于目标值，向右移动；如果中间值大于目标值，向左移动。

### 12. 找到字符串中第一个匹配项的下标

**题目描述：** 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出第一个匹配的 needle 子串的下标（0-based）。如果不存在，返回 -1。

**答案解析：**

```go
func strStr(haystack string, needle string) int {
    n := len(needle)
    if n == 0 {
        return 0
    }
    nHaystack := len(haystack)
    for i := 0; i < nHaystack-n+1; i++ {
        if haystack[i:i+n] == needle {
            return i
        }
    }
    return -1
}
```

**解析：** 遍历 haystack，检查每个长度为 n 的子串是否与 needle 匹配。如果找到匹配，返回子串的起始索引；否则，返回 -1。

### 13. 有效的括号

**题目描述：** 给定一个字符串，验证它是否是有效的括号字符串。

**答案解析：**

```go
func isValid(s string) bool {
    stack := make([]byte, 0)
    for _, v := range s {
        if v == '(' || v == '{' || v == '[' {
            stack = append(stack, v)
        } else {
            if len(stack) == 0 {
                return false
            }
            top := stack[len(stack)-1]
            if (v == ')' && top != '(') || (v == '}' && top != '{') || (v == ']' && top != '[') {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

**解析：** 使用栈来检查括号是否匹配。如果遇到开括号，将其推入栈中；如果遇到闭括号，检查栈顶元素是否匹配，如果匹配则弹出栈顶元素，否则返回 false。最后检查栈是否为空。

### 14. 有效的字母异位词

**题目描述：** 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

**答案解析：**

```go
func isAnagram(s string, t string) bool {
    m := make(map[rune]int)
    for _, v := range s {
        m[v]++
    }
    for _, v := range t {
        m[v]--
        if m[v] < 0 {
            return false
        }
    }
    for _, v := range m {
        if v != 0 {
            return false
        }
    }
    return true
}
```

**解析：** 使用哈希表统计 s 中每个字符的频次，然后遍历 t，对每个字符进行计数减一，如果减到负数或者 m 中有任何字符的频次不为零，则返回 false。

### 15. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案解析：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

type ListNode struct {
    Val  int
    Next *ListNode
}
```

**解析：** 类似于数组合并，选择两个链表中值较小的节点作为新链表的一个节点，然后递归地对剩余的链表进行合并。

### 16. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && strings.Index(strs[i], prefix) != 0 {
            prefix = prefix[:len(prefix)-1]
        }
        if prefix == "" {
            break
        }
    }
    return prefix
}
```

**解析：** 遍历字符串数组，对于每个字符串，检查其是否以当前的前缀开头。如果不是，则缩短前缀，直到找到所有字符串都匹配的前缀。

### 17. 两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的，并且每个链表中的节点已经按 逆序 排列。

**答案解析：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        curr.Next = &ListNode{sum % 10, nil}
        carry = sum / 10
        curr = curr.Next
    }
    if carry > 0 {
        curr.Next = &ListNode{carry, nil}
    }
    return dummy.Next
}

type ListNode struct {
    Val  int
    Next *ListNode
}
```

**解析：** 按位相加，并处理进位。使用一个哑节点 `dummy` 作为结果链表的头节点，以及一个当前节点 `curr` 指向链表的当前节点。最后，处理可能出现的最高位的进位。

### 18. 有效的数字

**题目描述：** 给定一个字符串，判断它是否是有效的数字。

**答案解析：**

```go
func isNumber(s string) bool {
    if s == "" {
        return false
    }
    dotCount, eCount := 0, 0
    signCount := 0
    i := 0
    n := len(s)
    for i < n {
        if s[i] == '+' || s[i] == '-' {
            if i > 0 && (s[i-1] != 'e' && s[i-1] != 'E') {
                return false
            }
            if signCount > 1 {
                return false
            }
            signCount++
            i++
        } else if s[i] == '0' && (i == 0 || s[i-1] == '.') {
            i++
        } else if s[i] >= '1' && s[i] <= '9' {
            break
        } else if s[i] == '.' {
            if dotCount > 0 || (i == 0 && (i+1) == n) {
                return false
            }
            dotCount++
            i++
        } else if s[i] == 'e' || s[i] == 'E' {
            if eCount > 0 || i == 0 || (i+1) == n {
                return false
            }
            eCount++
            i++
            if i < n && (s[i] == '+' || s[i] == '-') {
                i++
            }
        } else {
            return false
        }
    }
    isDecimal := false
    for i < n {
        if s[i] == '+' || s[i] == '-' {
            return false
        } else if s[i] == '0' {
            if isDecimal {
                break
            }
            i++
        } else if s[i] >= '1' && s[i] <= '9' {
            isDecimal = true
            i++
        } else {
            return false
        }
    }
    return true
}
```

**解析：** 分析字符串中的每个字符，检查是否满足数字的规则。注意处理科学计数法。

### 19. 最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**答案解析：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划解决最长公共子序列问题。构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。

### 20. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案解析：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

type ListNode struct {
    Val  int
    Next *ListNode
}
```

**解析：** 类似于合并两个有序数组。递归地选择两个链表中值较小的节点作为新链表的一个节点，然后递归地对剩余的链表进行合并。

### 21. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 head 和一个整数 val，删除链表中所有值为 val 的节点。

**答案解析：**

```go
func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    dummy := &ListNode{0, head}
    cur := dummy
    for cur.Next != nil {
        if cur.Next.Val == val {
            cur.Next = cur.Next.Next
        } else {
            cur = cur.Next
        }
    }
    return dummy.Next
}
```

**解析：** 使用哑节点 `dummy`，跳过所有值为 val 的节点。最后返回哑节点的下一个节点。

### 22. 寻找旋转排序数组中的最小值

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**答案解析：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 使用二分查找。如果中值大于右边界值，说明最小值在右侧；否则在左侧。

### 23. 字符串匹配

**题目描述：** 实现一种支持以下函数的字符串匹配的实现：

1. `void addWord(word)`
2. `bool search(word)`

**答案解析：**

```go
var words []string

func addWord(word string) {
    words = append(words, word)
}

func search(word string) bool {
    n := len(words)
    left, right := 0, n-1
    for left <= right {
        mid := left + (right-left)/2
        i := 0
        j := 0
        for i < len(word) && j < len(words[mid]) {
            if word[i] < words[mid][j] {
                left = mid + 1
                break
            } else if word[i] > words[mid][j] {
                right = mid - 1
                break
            } else {
                i++
                j++
            }
        }
        if i == len(word) {
            return true
        }
    }
    return false
}
```

**解析：** 使用二分查找，并在匹配时检查字符串是否完全相等。

### 24. 数据流中的中位数

**题目描述：** 设计一个算法来查找中位数。输入类型有一个数据流，每当有一个新的值加入时，计算出当前的累计中位数。

**答案解析：**

```go
var small, large []int
var n int

func addNum(val int) {
    if n&1 == 0 {
        small = append(small, val)
        sort.Ints(small)
        large = append(large, small[len(small)-1])
        large = append(large, small[:(n/2)-1]...)
        sort.Ints(large)
    } else {
        large = append(large, val)
        sort.Ints(large)
        small = append(small, large[len(large)-1])
        small = append(small, large[:(n/2)-1]...)
        sort.Ints(small)
    }
    n++
}

func findMedian() float64 {
    if n&1 == 0 {
        return float64(small[n/2-1]+large[n/2]) / 2.0
    } else {
        return float64(large[n/2])
    }
}
```

**解析：** 使用两个堆来存储数组的前半部分和后半部分。每次插入新值时，根据当前数组的奇偶性调整两个堆。计算中位数时，根据数组的奇偶性返回相应的值。

### 25. 重建二叉树

**题目描述：** 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树并返回。

**答案解析：**

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 || len(inorder) == 0 {
        return nil
    }
    rootVal := preorder[0]
    root := &TreeNode{Val: rootVal}
    idx := 0
    for i := 0; i < len(inorder); i++ {
        if inorder[i] == rootVal {
            idx = i
            break
        }
    }
    root.Left = buildTree(preorder[1:idx+1], inorder[:idx])
    root.Right = buildTree(preorder[idx+1:], inorder[idx+1:])
    return root
}

func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 || len(inorder) == 0 {
        return nil
    }
    rootVal := preorder[0]
    root := &TreeNode{Val: rootVal}
    idx := 0
    for i := 0; i < len(inorder); i++ {
        if inorder[i] == rootVal {
            idx = i
            break
        }
    }
    root.Left = buildTree(preorder[1:idx+1], inorder[:idx])
    root.Right = buildTree(preorder[idx+1:], inorder[idx+1:])
    return root
}

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```

**解析：** 利用前序遍历的根节点和中序遍历的根节点位置来分割左右子树，递归地重建二叉树。

### 26. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序的数组。

**答案解析：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > nums[left] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[right] || target < nums[mid] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 搜索旋转后的有序数组。如果中间值大于左边界值，则说明最小值在右侧；否则在左侧。更新左右边界。

### 27. 合并两个有序数组

**题目描述：** 给定两个已排序的整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 从 beginning 起开始保留原始的顺序。

**答案解析：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j := m-1, n-1
    k := m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**解析：** 从数组的末尾开始比较两个数组的元素，将较大的元素移动到合并数组的末尾。

### 28. 股票的最大利润

**题目描述：** 给定一个整数数组 `prices`，其中每个元素代表了该时间点的股票价格。计算你所能获取的最大利润。

**答案解析：**

```go
func maxProfit(prices []int) int {
    maxProfit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            maxProfit += prices[i] - prices[i-1]
        }
    }
    return maxProfit
}
```

**解析：** 遍历数组，如果当前元素大于前一个元素，则计算差值并累加到最大利润中。

### 29. 剪绳子

**题目描述：** 给定一个正整数 n，把绳子剪成若干段最大长度为 3 的线段，计算最大长度。

**答案解析：**

```go
func cuttingRope(n int) int {
    if n < 4 {
        return n - 1
    }
    maxProduct := 1
    for n > 4 {
        maxProduct *= 3
        n -= 3
    }
    maxProduct *= n
    return maxProduct
}
```

**解析：** 尽可能多地剪出长度为3的段，最后剩下的部分如果小于4，则直接乘以剩余的长度。

### 30. 零钱兑换

**题目描述：** 给定不同面额的硬币和一个总金额，计算需要多少种硬币组合来凑出总金额。

**答案解析：**

```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
        for _, coin := range coins {
            if i-coin >= 0 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划，`dp[i]` 表示凑出金额 `i` 需要的最少硬币数量。遍历每个硬币，更新 `dp[i]` 的值。最后返回 `dp[amount]` 的值，如果等于 `math.MaxInt32`，则返回 -1。

---

以上是网易2025社招面试真题与算法题解的相关面试题和算法编程题，以及相应的答案解析和源代码实例。这些题目覆盖了数据结构、算法、数学等领域，是面试中常见的高频题目。在准备面试时，理解题目的本质和解决问题的方法是非常重要的。希望这些解答能够帮助到您。如果您有其他问题或者需要进一步的解析，欢迎提问。

