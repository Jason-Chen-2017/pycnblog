                 

### 网易2025届社招面试高频算法题解析：排序算法

#### 1. 快速排序（Quick Sort）

**题目描述：** 实现一个快速排序函数，对数组进行排序。

**答案：** 

```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }

    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)

    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }

    return append(quickSort(left...), append(middle, quickSort(right...)...)...)
}
```

**解析：** 快速排序采用分治的思想，通过一趟排序将数组分为两个子数组，其中一个子数组的所有元素都比另一个子数组的所有元素小，然后递归地对这两个子数组进行快速排序。

#### 2. 归并排序（Merge Sort）

**题目描述：** 实现一个归并排序函数，对数组进行排序。

**答案：**

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }

    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])

    return merge(left, right)
}

func merge(left, right []int) []int {
    result := []int{}
    for len(left) > 0 && len(right) > 0 {
        if left[0] <= right[0] {
            result = append(result, left[0])
            left = left[1:]
        } else {
            result = append(result, right[0])
            right = right[1:]
        }
    }

    result = append(result, left...)
    result = append(result, right...)
    return result
}
```

**解析：** 归并排序采用分治的思想，将数组不断分割成更小的子数组，然后对子数组进行排序，最后将排好序的子数组进行合并。

#### 3. 希尔排序（Shell Sort）

**题目描述：** 实现一个希尔排序函数，对数组进行排序。

**答案：**

```go
func shellSort(arr []int) []int {
    gap := len(arr) / 2
    for gap > 0 {
        for i := gap; i < len(arr); i++ {
            temp := arr[i]
            j := i
            for j >= gap && arr[j-gap] > temp {
                arr[j] = arr[j-gap]
                j -= gap
            }
            arr[j] = temp
        }
        gap /= 2
    }
    return arr
}
```

**解析：** 希尔排序也是一种插入排序，它通过比较不同索引间隔的元素来减少排序次数，在待排序列基本有序时非常有效。

#### 4. 冒泡排序（Bubble Sort）

**题目描述：** 实现一个冒泡排序函数，对数组进行排序。

**答案：**

```go
func bubbleSort(arr []int) []int {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
    return arr
}
```

**解析：** 冒泡排序通过比较相邻的元素并交换它们的位置来对数组进行排序，每次遍历都会将最大的元素“冒泡”到数组的末尾。

#### 5. 选择排序（Selection Sort）

**题目描述：** 实现一个选择排序函数，对数组进行排序。

**答案：**

```go
func selectionSort(arr []int) []int {
    n := len(arr)
    for i := 0; i < n; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
    return arr
}
```

**解析：** 选择排序通过每次遍历找到未排序部分的最小元素，并将其放到已排序部分的末尾。

#### 6. 插入排序（Insertion Sort）

**题目描述：** 实现一个插入排序函数，对数组进行排序。

**答案：**

```go
func insertionSort(arr []int) []int {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
    return arr
}
```

**解析：** 插入排序通过将未排序部分的一个元素插入到已排序部分的正确位置来对数组进行排序。

#### 7. 计数排序（Counting Sort）

**题目描述：** 实现一个计数排序函数，对数组进行排序。

**答案：**

```go
func countingSort(arr []int) []int {
    maxVal := max(arr)
    count := make([]int, maxVal+1)
    output := make([]int, 0, len(arr))

    for _, v := range arr {
        count[v]++
    }

    for i, v := range count {
        for j := 0; j < v; j++ {
            output = append(output, i)
        }
    }

    return output
}

func max(arr []int) int {
    maxVal := arr[0]
    for _, v := range arr {
        if v > maxVal {
            maxVal = v
        }
    }
    return maxVal
}
```

**解析：** 计数排序利用数组统计原始数组中每个数字的出现次数，然后将原始数组中的数字按照出现次数依次放入输出数组中。

#### 8. 堆排序（Heap Sort）

**题目描述：** 实现一个堆排序函数，对数组进行排序。

**答案：**

```go
func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func heapSort(arr []int) []int {
    n := len(arr)

    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }

    return arr
}
```

**解析：** 堆排序利用堆这种数据结构进行排序。首先构建一个最大堆，然后将堆顶元素与最后一个元素交换，再将剩余元素重新构建成最大堆，重复此过程直到堆中只剩下一个元素。

### 总结

排序算法是计算机科学中非常重要的一部分，掌握各种排序算法的原理和实现对于解决实际问题非常有帮助。在本篇博客中，我们介绍了七种常见的排序算法，包括快速排序、归并排序、希尔排序、冒泡排序、选择排序、插入排序和计数排序。每种排序算法都有其特点和适用场景，读者可以根据实际情况选择合适的算法。同时，我们也通过代码示例展示了每种算法的实现方法。希望这篇文章能够帮助读者更好地理解和掌握排序算法。在后续的文章中，我们将继续探讨其他数据结构和算法，敬请期待。

