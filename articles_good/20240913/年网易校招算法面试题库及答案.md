                 

### 2025年网易校招算法面试题库及答案

#### 1. 单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断该单词是否可以在网格中按照字典中的单词的排列顺序遍历找到。每个单元格只能通过上下左右四个方向移动。

**示例：**

```
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
```

**答案：**

```go
func exist(board [][]byte, word string) bool {
    rows, cols := len(board), len(board[0])
    path := [][]bool{}

    for i := 0; i < rows; i++ {
        path = append(path, make([]bool, cols))
    }

    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if search(board, word, 0, i, j, &path) {
                return true
            }
        }
    }

    return false
}

func search(board [][]byte, word string, index int, i int, j int, path **[][]bool) bool {
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || (*path)[i][j] || board[i][j] != word[index] {
        return false
    }

    (*path)[i][j] = true
    index++

    if index == len(word) {
        return true
    }

    if search(board, word, index, i+1, j, path) {
        return true
    }
    if search(board, word, index, i-1, j, path) {
        return true
    }
    if search(board, word, index, i, j+1, path) {
        return true
    }
    if search(board, word, index, i, j-1, path) {
        return true
    }

    (*path)[i][j] = false
    return false
}
```

**解析：** 使用回溯算法，通过递归遍历所有可能的路径，并使用一个布尔数组 `path` 记录每个单元格是否被访问过。

#### 2. 股票买卖 II

**题目描述：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**示例：**

```
[7,1,5,3,6,4]
```

**答案：**

```go
func maxProfit(prices []int) int {
    profit := 0

    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }

    return profit
}
```

**解析：** 遍历数组，如果后一天的股票价格高于前一天，则将其差值累加到利润中。

#### 3. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```
[2, 7, 11, 15], target = 9
```

**答案：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)

    for i, v := range nums {
        if j, ok := m[target-v]; ok {
            return []int{j, i}
        }
        m[v] = i
    }

    return nil
}
```

**解析：** 使用哈希表存储数组中的每个元素及其索引，遍历数组的同时检查哈希表中是否存在当前元素的补数。

#### 4. 有效的括号字符串

**题目描述：** 给定一个只包含 '('、')'、'*'的字符串，检验是否为有效字符串。有效字符串需满足：

* 左右括号必须匹配；
* '*'可以被视为单个括号或消除两个相邻括号。

**示例：**

```
"(*)"
```

**答案：**

```go
func checkValidString(g string) bool {
    count := 0

    for i := range g {
        switch g[i] {
        case '(':
            count++
        case ')':
            count--
        case '*':
            if count > 0 {
                count--
            } else {
                count++
            }
        }

        if count < 0 {
            return false
        }
    }

    return count == 0
}
```

**解析：** 遍历字符串，使用一个计数器记录 '(' 和 '*' 的数量。当遇到 ')' 时，计数器递减；当遇到 '*' 时，根据当前计数器值决定是否递减。如果计数器小于 0，说明括号不匹配，返回 false。遍历完成后，如果计数器为 0，说明字符串有效。

#### 5. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**

```
[3, 2, 0, -4]
```

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true
        }
    }

    return false
}
```

**解析：** 使用快慢指针法，快指针每次移动两个节点，慢指针每次移动一个节点。如果快指针追上慢指针，说明链表中存在环。

#### 6. 合并区间

**题目描述：** 给定一组区间，合并所有重叠的区间。

**示例：**

```
[[1,3],[2,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }

    return ans
}
```

**解析：** 首先对区间数组按照起点排序，然后遍历区间数组，将当前区间与结果数组中的最后一个区间合并，如果当前区间与结果数组中的最后一个区间的终点重叠，则将当前区间的终点更新为两个区间的较大值。

#### 7. 合并K个排序链表

**题目描述：** 给定K个已排序的链表，合并链表并返回结果链表。

**示例：**

```
[
    [1,4,5],
    [1,3,4],
    [2,6]
]
```

**答案：**

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    for len(lists) > 1 {
        lists = append(lists[:len(lists)/2], lists[len(lists)/2+1:]...)
        t := &ListNode{}
        head, p := t, nil

        for _, l := range lists {
            for l != nil {
                if p == nil || l.Val < p.Val {
                    p.Next = l
                    l = l.Next
                } else {
                    q := p.Next
                    p.Next = l
                    l = q
                }
                p = p.Next
            }
        }

        lists = []*ListNode{head.Next}
    }

    return lists[0]
}
```

**解析：** 使用分治算法，每次合并两个链表，然后将结果与下一个链表合并，直到所有链表合并为一个。

#### 8. 最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**示例：**

```
[1,-2,3,10,-4,7,2,-5]
```

**答案：**

```go
func maxSubArray(nums []int) int {
    ans := nums[0]
    sum := nums[0]

    for i := 1; i < len(nums); i++ {
        sum = max(nums[i], sum+nums[i])
        ans = max(ans, sum)
    }

    return ans
}
```

**解析：** 动态规划，维护一个当前子序列和的最大值，遍历数组时更新最大值。

#### 9. 最长回文子串

**题目描述：** 给定一个字符串 `s` ，找到其最长的回文子串。

**示例：**

```
"babad"
```

**答案：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }

    start, mx := 0, 1

    for i := 0; i < n; i++ {
        len1, len2 := expand(s, i, i), expand(s, i, i+1)

        if len1 > mx {
            mx = len1
            start = i - (len1 - 1) / 2
        }
        if len2 > mx {
            mx = len2
            start = i - mx/2
        }
    }

    return s[start : start+mx]
}

func expand(s string, l, r int) int {
    for l >= 0 && r < len(s) && s[l] == s[r] {
        l--
        r++
    }

    return r - l - 1
}
```

**解析：** 使用中心扩展算法，遍历字符串，以每个字符为中心扩展，找到最长回文子串。

#### 10. 三数之和

**题目描述：** 给定一个包含 `n` 个整数的数组 `nums` ，判断 `nums` 中是否存在三个元素 `a`，`b`，`c` ，使得 `a + b + c = 0`？找出所有满足条件且不重复的三元组。

**示例：**

```
[-1, 0, 1, 2, -1, -4]
```

**答案：**

```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)

    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        left, right := i+1, len(nums)-1

        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum < 0 {
                left++
            } else if sum > 0 {
                right--
            } else {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            }
        }
    }

    return ans
}
```

**解析：** 对数组进行排序，然后遍历数组，使用双指针法找到与当前元素相加等于0的另外两个元素。为了避免重复，跳过相邻的相同元素。

#### 11. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
["flower", "flow", "flight"]
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    ans := strs[0]
    for _, v := range strs {
        for ans != "" && !strings.HasPrefix(v, ans) {
            ans = ans[:len(ans)-1]
        }
    }

    return ans
}
```

**解析：** 遍历字符串数组，每次从结果中移除最后一个字符，直到找到公共前缀。

#### 12. 爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 `n` 阶才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**

```
3
```

**答案：**

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }

    a, b := 1, 2
    for i := 2; i < n; i++ {
        c := a + b
        a = b
        b = c
    }

    return b
}
```

**解析：** 使用动态规划，维护前两个状态的值，每次更新状态。

#### 13. 盛水最多的容器

**题目描述：** 给定一个数组 `height` 表示容器的高度，按从上到下排列。找出可以容纳的最大水量。

**示例：**

```
[1,8,6,2,5,4,8,3,7]
```

**答案：**

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    ans := 0

    for left < right {
        if height[left] < height[right] {
            ans = max(ans, height[left]*(right-left))
            left++
        } else {
            ans = max(ans, height[right]*(right-left))
            right--
        }
    }

    return ans
}
```

**解析：** 使用双指针法，遍历数组，每次移动高度较小的指针，计算当前容器的面积，更新最大面积。

#### 14. 有效的数字

**题目描述：** 判断一个字符串是否是有效的数字。

**示例：**

```
"0"
" 0.1 "
".+--."
```

**答案：**

```go
func isNumber(s string) bool {
    state := 0
    dot, exp := false, false

    for i := 0; i < len(s); i++ {
        c := s[i]

        switch state {
        case 0:
            if c == ' ' {
                continue
            }
            if c == '+' || c == '-' {
                state = 1
            } else if c >= '0' && c <= '9' {
                state = 2
            } else {
                return false
            }
        case 1:
            if c >= '0' && c <= '9' {
                state = 2
            } else {
                return false
            }
        case 2:
            if c == '.' {
                if dot || exp {
                    return false
                }
                state = 3
                dot = true
            } else if c == 'e' {
                if exp {
                    return false
                }
                state = 4
                exp = true
            } else if c >= '0' && c <= '9' {
                continue
            } else {
                return false
            }
        case 3:
            if c == 'e' {
                if exp {
                    return false
                }
                state = 4
                exp = true
            } else if c >= '0' && c <= '9' {
                continue
            } else {
                return false
            }
        case 4:
            if c == '+' || c == '-' {
                state = 5
            } else if c >= '0' && c <= '9' {
                state = 6
            } else {
                return false
            }
        case 5:
            if c >= '0' && c <= '9' {
                state = 6
            } else {
                return false
            }
        case 6:
            if c >= '0' && c <= '9' {
                continue
            } else {
                return false
            }
        }

    }

    return state == 2 || state == 3 || state == 6 || state == 7
}
```

**解析：** 使用状态机，定义不同的状态来处理数字、符号和字母。遍历字符串，根据当前状态和字符更新状态。

#### 15. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**示例：**

```
"s = 'anagram', t = 'nagaram'"
```

**答案：**

```go
func isAnagram(s string, t string) bool {
    m := map[rune]int{}

    for _, v := range s {
        m[v]++
    }
    for _, v := range t {
        if m[v] == 0 {
            return false
        }
        m[v]--
    }

    for _, v := range m {
        if v != 0 {
            return false
        }
    }

    return true
}
```

**解析：** 使用哈希表存储 `s` 中每个字符的频率，然后遍历 `t` 并减少相应字符的频率。如果哈希表中任何字符的频率不为零，则 `t` 不是 `s` 的字母异位词。

#### 16. 有效的括号

**题目描述：** 给定一个字符串 `s` ，检查是否通过一系列的有效的括号组合形成了 `s` 。

**示例：**

```
"()"
```

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}

    for _, c := range s {
        switch c {
        case '(':
            stack = append(stack, ')')
        case '[':
            stack = append(stack, ']')
        case '{':
            stack = append(stack, '}')
        default:
            if len(stack) == 0 || c != stack[len(stack)-1] {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}
```

**解析：** 使用栈存储括号，遍历字符串，根据当前字符更新栈。如果当前字符是左括号，将其压入栈；如果当前字符是右括号，检查是否与栈顶元素匹配，然后弹出栈顶元素。遍历完成后，如果栈为空，则字符串有效。

#### 17. 字符串转换大写字母

**题目描述：** 使用 `toUpper` 函数将字符串 `str` 中的每个字符转换为大写字母。

**示例：**

```
"hello"
```

**答案：**

```go
func toUpper(s string) string {
    b := []byte(s)
    for i := 0; i < len(b); i++ {
        if b[i] >= 'a' && b[i] <= 'z' {
            b[i] -= 32
        }
    }
    return string(b)
}
```

**解析：** 将字符串转换为字节切片，遍历每个字节，如果字节是大写字母，则将其转换为小写字母。

#### 18. 字符串转换小写字母

**题目描述：** 使用 `toLower` 函数将字符串 `str` 中的每个字符转换为小写字母。

**示例：**

```
"HELLO"
```

**答案：**

```go
func toLower(s string) string {
    b := []byte(s)
    for i := 0; i < len(b); i++ {
        if b[i] >= 'A' && b[i] <= 'Z' {
            b[i] += 32
        }
    }
    return string(b)
}
```

**解析：** 将字符串转换为字节切片，遍历每个字节，如果字节是大写字母，则将其转换为小写字母。

#### 19. 字符串相乘

**题目描述：** 给定两个字符串 `num1` 和 `num2` ，以字符串形式返回它们乘积的结果。

**示例：**

```
"123","456"
```

**答案：**

```go
func multiply(num1 string, num2 string) string {
    ans := []byte{}

    for i := len(num1) - 1; i >= 0; i-- {
        carry := 0
        for j := len(num2) - 1; j >= 0; j-- {
            mul := int(num1[i]-'0')*int(num2[j]-'0') + carry
            ans = append(ans, byte(mul%10+'0'))
            carry = mul / 10
        }
        if carry > 0 {
            ans = append(ans, byte(carry+'0'))
        }
    }

    n := len(ans)
    for i := 0; i < n/2; i++ {
        ans[i], ans[n-i-1] = ans[n-i-1], ans[i]
    }

    if ans[0] == '0' && len(ans) > 1 {
        return string(ans[1:])
    }
    return string(ans)
}
```

**解析：** 使用模拟乘法，逐位相乘，将结果存储在数组中。然后对数组进行翻转，最后转换回字符串。

#### 20. 精简文本

**题目描述：** 给定一个字符串 `s` ，删除字符串中的所有空格、标点符号和非数字字符，保留数字和字母。

**示例：**

```
"Hello, World! 123"
```

**答案：**

```go
func simplifyText(s string) string {
    ans := []byte{}
    for _, c := range s {
        if (c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {
            ans = append(ans, byte(c))
        }
    }
    return string(ans)
}
```

**解析：** 遍历字符串，如果当前字符是数字、小写字母或大写字母，则将其添加到结果中。

#### 21. 数组中重复的数字

**题目描述：** 给定一个整数数组，判断数组中是否存在重复的数字。

**示例：**

```
[2,3,5,2,3]
```

**答案：**

```go
func containsDuplicate(nums []int) bool {
    m := make(map[int]bool)

    for _, v := range nums {
        if _, ok := m[v]; ok {
            return true
        }
        m[v] = true
    }

    return false
}
```

**解析：** 使用哈希表存储数组中的每个元素，如果发现重复元素，则返回 true。

#### 22. 搜索插入位置

**题目描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**示例：**

```
[1,3,5,6], 5
```

**答案：**

```go
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)-1

    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return left
}
```

**解析：** 使用二分查找法，在排序数组中找到目标值的位置。如果找到，返回索引；如果未找到，返回插入位置。

#### 23. 二进制求和

**题目描述：** 给你两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**

```
"a = "11","b = "1"
```

**答案：**

```go
func addBinary(a string, b string) string {
    ans := []byte{}
    i, j := len(a)-1, len(b)-1
    carry := 0

    for i >= 0 || j >= 0 || carry > 0 {
        sum := carry
        if i >= 0 {
            sum += int(a[i]-'0')
            i--
        }
        if j >= 0 {
            sum += int(b[j]-'0')
            j--
        }
        ans = append(ans, byte(sum%2+'0'))
        carry = sum / 2
    }

    for i := len(ans) - 1; i > 0; i-- {
        ans[i], ans[i-1] = ans[i-1], ans[i]
    }

    return string(ans)
}
```

**解析：** 使用模拟加法，从低位开始相加，记录进位。遍历完成后，翻转结果，得到最终二进制和。

#### 24. 缩写字符串

**题目描述：** 给定一个字符串 `s` 和一个整数 `n`，将字符串 `s` 缩写为 `n` 个字符的字符串。缩写的规则如下：

- 如果从第 `i` 个字符开始，有 `k` 个连续相同的字符，则将其缩写为 `[i, k]`；
- 如果缩写后的字符串长度小于 `n`，则在末尾添加一个或多个 `0`。

**示例：**

```
s = "aaa12bbcc", n = 6
```

**答案：**

```go
func compress(s string, n int) string {
    ans := []byte{}
    i := 0
    for i < len(s) {
        j := i
        for j < len(s) && s[i] == s[j] {
            j++
        }
        if j-i+1 <= n {
            ans = append(ans, []byte{byte(s[i] - '0'), byte(j-i+1 - '0'), byte(']')}...)
            n -= j - i + 1
        } else {
            ans = append(ans, s[i])
            n--
        }
        i = j
    }
    for n > 0 {
        ans = append(ans, byte('0'))
        n--
    }

    return string(ans)
}
```

**解析：** 遍历字符串，找到连续相同字符的长度。如果长度加上方括号和数字的总长度小于 `n`，则将其缩写为 `[i, k]`，否则将其直接添加到结果中。遍历完成后，如果 `n` 大于 0，则在结果末尾添加 `0`。

#### 25. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
["flower","flow","flight"]
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    ans := strs[0]
    for i := 1; i < len(strs); i++ {
        for ans != "" && !strings.HasPrefix(strs[i], ans) {
            ans = ans[:len(ans)-1]
        }
    }

    return ans
}
```

**解析：** 遍历字符串数组，依次与前一个字符串比较公共前缀。如果当前字符串不以公共前缀开头，则缩短公共前缀。

#### 26. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
l1 = [1,2,4], l2 = [1,3,4]
```

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 使用递归合并两个有序链表。每次比较当前节点值，选择较小的节点值作为新链表的当前节点，然后递归合并下一个节点。

#### 27. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回两个字符串的最长公共子序列的长度。

**示例：**

```
text1 = "abcde", text2 = "ace"
```

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}
```

**解析：** 使用动态规划，创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 和 `text2` 的前 `i` 个字符和前 `j` 个字符的最长公共子序列的长度。遍历字符串，更新 `dp` 数组。

#### 28. 字符串转换整数 (atoi)

**题目描述：** 实现一个 myAtoi(string s) 函数，使其能将字符串转换为整数。

**示例：**

```
"42"
```

**答案：**

```go
func myAtoi(s string) int {
    ans := 0
    sign := 1
    i := 0
    n := len(s)

    for i < n && s[i] == ' ' {
        i++
    }

    if i < n && (s[i] == '+' || s[i] == '-') {
        if s[i] == '-' {
            sign = -1
        }
        i++
    }

    for i < n && s[i] >= '0' && s[i] <= '9' {
        digit := int(s[i]-'0')
        if ans > (int(1<<31)-1-digit)/10 {
            return int(1<<31)*sign
        }
        ans = ans*10 + digit
        i++
    }

    return ans*sign
}
```

**解析：** 遍历字符串，处理前导空格、符号和数字。在处理数字时，检查是否超出整数范围。如果超出范围，则返回 `int(1<<31)*sign`。

#### 29. 合并两个有序数组

**题目描述：** 给定两个有序整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**示例：**

```
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3
```

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j := m-1, n-1
    t := len(nums1) - 1

    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[t] = nums1[i]
            i--
        } else {
            nums1[t] = nums2[j]
            j--
        }
        t--
    }

    for j >= 0 {
        nums1[t] = nums2[j]
        j--
        t--
    }
}
```

**解析：** 从两个数组的末尾开始比较，将较大的值放入结果数组的末尾，然后移动指针。如果某个数组遍历完毕，则将另一个数组的剩余元素放入结果数组。

#### 30. 颠倒整数

**题目描述：** 编写一个函数，实现整数数字的位数颠倒。

**示例：**

```
123
```

**答案：**

```go
func reverse(x int) int {
    ans := 0
    for x > 0 {
        ans = ans*10 + x%10
        x /= 10
    }
    if ans > int(1<<31)-1 || ans < int(1<<31)*(-1) {
        return 0
    }
    return ans
}
```

**解析：** 使用循环将整数的每一位从低位开始添加到结果中。在循环结束后，检查结果是否超出整数范围，如果超出则返回 0。

### 总结

本文共介绍了 30 道网易校招算法面试题及答案，涵盖了排序、查找、字符串、数组、链表等常见题型，通过详尽的解析和代码示例，帮助读者更好地理解和掌握这些算法题。这些题目涵盖了算法面试的常见知识点，对于准备校招或社招的算法工程师来说，具有很高的参考价值。在解题过程中，不仅要关注算法的正确性，还要注意代码的效率和可读性。通过不断的练习和总结，相信大家能够在算法面试中取得更好的成绩。希望本文对大家有所帮助！

