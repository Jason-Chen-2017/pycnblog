
作者：禅与计算机程序设计艺术                    
                
                
《设计模式：代码模式与结构(第2版)》（中文译名：《设计模式：可复用面向对象软件设计元素》）是一本全面、系统地介绍设计模式的著作，作者是维纳·特莱姆（Vernon Trent）。该书作为最权威的设计模式介绍教材，已经成为学习面向对象编程中不可缺少的一课。

《设计模式：代码模式与结构(第2版)》中覆盖了23种设计模式，并对每一种模式进行了详细的阐述，通过实例和图示将模式的应用方法论化、形象化地呈现出来，读者可以从中获得“设计模式”的关键概念和方法，并且能够更好地理解和掌握这些概念和方法的实际运用。

# 2.基本概念术语说明
## 2.1 模式分类及其介绍
设计模式是一套被反复使用的、多变的、经过分类编排的方法论。模式通常分为三类：<strong>创建型模式</strong>(Creational Patterns)，<strong>结构型模式</strong>(Structural Patterns)，<strong>行为型模式</strong>(Behavioral Patterns)。

- <strong>创建型模式：</strong>用于解耦对象的构造过程，提升性能和可维护性。主要包括单例模式、工厂模式、建造者模式、原型模式。
- <strong>结构型模式：</strong>用于处理类或对象的组合关系，封装变化点，关注类的继承和组合。主要包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式。
- <strong>行为型模式：</strong>用于类和对象之间的交互，描述类间职责分配方式。主要包括策略模式、模板方法模式、观察者模式、迭代子模式、状态模式、职责链模式、命令模式、备忘录模式。

## 2.2 设计模式六大原则
- <strong>开闭原则（Open Close Principle）：</strong>一个软件实体应该对扩展开放，对修改关闭。即增加需求时不必修改原有的代码。
- <strong>里氏替换原则（Liskov Substitution Principle）：</strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象。它还有助于实现“多态”。
- <strong>依赖倒置原则（Dependence Inversion Principle）：</strong>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。换言之，要针对接口而不是实现编程。
- <strong>接口隔离原则（Interface Segregation Principle）：</strong>客户不应该依赖那些它不需要的接口。
- <strong>迪米特法则（Law of Demeter）：</strong>一个对象应当尽可能少地与其他对象通信。
- <strong>单一职责原则（Single Responsibility Principle）：</strong>应该有且仅有一个原因引起一个类变化。

# 3.核心算法原理和具体操作步骤以及数学公式讲解
## 3.1 创建型模式
### 3.1.1 单例模式
单例模式（Singleton Pattern）是创建型模式，其特点在于一个类只能拥有一个实例，而且自行实例化并向整个系统提供这个实例，使其成为系统中的唯一实例。如下所示是一个单例类的Java实现：

```java
public class Singleton {
  private static Singleton instance = null;

  // 构造函数私有化，防止外部直接new
  private Singleton() {}
  
  public static synchronized Singleton getInstance() {
    if (instance == null) {
      instance = new Singleton();
    }
    
    return instance;
  }
  
  // 方法用于实际业务逻辑处理
  public void doSomething() {
    System.out.println("This is a singleton.");
  }
}
```

如上所示，创建一个Singleton类，它有一个私有化的构造函数，使得无法由外部创建实例，同时使用static关键字修饰getInstance方法，使得可以确保只有一个实例存在。如果instance变量为空，则调用私有构造函数生成新的实例，否则返回之前生成的实例。

### 3.1.2 工厂模式
工厂模式（Factory Pattern）是创建型模式，其特点在于定义一个创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到子类。如下所示是一个工厂模式类的Java实现：

```java
// 抽象产品类
interface Animal {
  void speak();
}

// 具体产品类
class Cat implements Animal {
  @Override
  public void speak() {
    System.out.println("喵喵叫~");
  }
}

class Dog implements Animal {
  @Override
  public void speak() {
    System.out.println("汪汪叫~");
  }
}

// 抽象工厂类
abstract class AnimalFactory {
  abstract Animal createAnimal();
}

// 具体工厂类
class CatFactory extends AnimalFactory {
  @Override
  Animal createAnimal() {
    return new Cat();
  }
}

class DogFactory extends AnimalFactory {
  @Override
  Animal createAnimal() {
    return new Dog();
  }
}

// 测试
public class FactoryPatternDemo {
  public static void main(String[] args) {
    Animal cat = new CatFactory().createAnimal();
    cat.speak();

    Animal dog = new DogFactory().createAnimal();
    dog.speak();
  }
}
```

如上所示，创建一个Animal接口，用于表示动物，包含speak方法。Cat类和Dog类分别实现了Animal接口，其分别代表猫和狗。然后创建两个具体工厂类，分别为CatFactory和DogFactory，它们实现了AnimalFactory接口，重写了createAnimal方法，根据参数返回不同类型的动物实例。最后测试时通过具体工厂类创建不同类型的动物，调用其speak方法。

### 3.1.3 建造者模式
建造者模式（Builder Pattern）是创建型模式，其特点在于一步步构建复杂对象的各个部件，可以通过多个步骤来构造一个完整的对象。如下所示是一个建造者模式类的Java实现：

```java
// 产品类
class Car {
  private String brand;
  private int year;
  private List<String> parts;

  public Car(CarBuilder builder) {
    this.brand = builder.getBrand();
    this.year = builder.getYear();
    this.parts = builder.getParts();
  }

  public String getBrand() {
    return brand;
  }

  public int getYear() {
    return year;
  }

  public List<String> getParts() {
    return parts;
  }
}

// 抽象建造者类
abstract class CarBuilder {
  protected final String brand;
  protected int year;
  protected List<String> parts;

  public CarBuilder(String brand) {
    this.brand = brand;
    this.parts = new ArrayList<>();
  }

  public CarBuilder addPart(String part) {
    this.parts.add(part);
    return this;
  }

  public abstract Car build();

  public String getBrand() {
    return brand;
  }

  public int getYear() {
    return year;
  }

  public List<String> getParts() {
    return Collections.unmodifiableList(parts);
  }
}

// 具体建造者类
class BenzBuilder extends CarBuilder {
  public BenzBuilder() {
    super("奔驰");
  }

  @Override
  public Car build() {
    this.year = 2020;
    return new Car(this);
  }
}

// 测试
public class BuilderPatternDemo {
  public static void main(String[] args) {
    Car benz = new BenzBuilder()
       .addPart("轮胎")
       .build();
    System.out.println(benz.getBrand());
    System.out.println(benz.getYear());
    for (String part : benz.getParts()) {
      System.out.println(part);
    }
  }
}
```

如上所示，创建一个Car类，它包含品牌、年份、部件列表等属性。然后创建一个抽象建造者类CarBuilder，它包含一个构造函数，brand属性以及addPart方法，用于添加部件。再创建一个具体建造者类BenzBuilder，它继承了CarBuilder，重写了build方法，用于创建奔驰车实例。最后测试时通过具体建造者类创建奔驰车实例，打印出其属性值。

### 3.1.4 原型模式
原型模式（Prototype Pattern）是创建型模式，其特点在于用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新对象。如下所示是一个原型模式类的Java实现：

```java
// 原型类
class Prototype implements Cloneable {
  private String name;

  public Prototype(String name) {
    this.name = name;
  }

  public Object clone() throws CloneNotSupportedException {
    Prototype prototype = (Prototype) super.clone();
    return prototype;
  }
}

// 测试
public class PrototypePatternDemo {
  public static void main(String[] args) {
    try {
      Prototype prototype1 = new Prototype("小甲鱼");

      Prototype prototype2 = (Prototype)prototype1.clone();

      prototype2.setName("金枪鱼");

      System.out.println("prototype1的名称：" + prototype1.getName());
      System.out.println("prototype2的名称：" + prototype2.getName());
    } catch (CloneNotSupportedException e) {
      e.printStackTrace();
    }
  }
}
```

如上所示，创建一个Prototype类，它包含一个名称属性。其clone方法是一个protected方法，因此需要重写一下。另外，由于clone方法抛出CloneNotSupportedException异常，因此需要捕获该异常。最后测试时创建原型对象，复制一个原型对象，修改该对象的名称后打印出两者的名称。

## 3.2 结构型模式
### 3.2.1 适配器模式
适配器模式（Adapter Pattern）是结构型模式，其特点在于使已有类满足新的接口要求，主要解决类接口不兼容的问题。如下所示是一个适配器模式类的Java实现：

```java
// 源对象接口
interface Shape {
  double area();
}

// 源对象类
class Rectangle implements Shape {
  private double width;
  private double height;

  public Rectangle(double width, double height) {
    this.width = width;
    this.height = height;
  }

  @Override
  public double area() {
    return width * height;
  }
}

// 目标对象接口
interface DrawAPI {
  void drawRectangle(double x, double y, double width, double height);
}

// 目标对象类
class GraphicsAdapter implements DrawAPI {
  private Rectangle rectangle;

  public GraphicsAdapter(Rectangle rectangle) {
    this.rectangle = rectangle;
  }

  @Override
  public void drawRectangle(double x, double y, double width, double height) {
    System.out.println("使用Graphics API绘制矩形...");
    System.out.printf("左上角坐标(%f,%f),宽%f,高%f
",x,y,width,height);
    System.out.println("矩形面积:" + rectangle.area());
  }
}

// 测试
public class AdapterPatternDemo {
  public static void main(String[] args) {
    Shape shape = new Rectangle(10, 20);
    DrawAPI adapter = new GraphicsAdapter((Rectangle)shape);
    adapter.drawRectangle(0, 0, 10, 20);
  }
}
```

如上所示，创建一个Shape接口，包含一个area方法，用于计算矩形面积。再创建一个Rectangle类，实现了Shape接口，用于表示矩形。然后创建一个DrawAPI接口，包含一个drawRectangle方法，用于绘制矩形。再创建一个GraphicsAdapter类，它实现了DrawAPI接口，用于适配Rectangle。最后测试时实例化一个Rectangle对象，创建一个GraphicsAdapter对象，调用它的drawRectangle方法，传入不同的坐标值和大小，打印出绘制矩形的坐标值和面积。

### 3.2.2 桥接模式
桥接模式（Bridge Pattern）是结构型模式，其特点在于将抽象和实现分离，使得两者可以独立变化。如下所示是一个桥接模式类的Java实现：

```java
// 抽象化类
abstract class Abstraction {
  protected Implementor implementor;

  public Abstraction(Implementor implementor) {
    this.implementor = implementor;
  }

  public void operation() {
    implementor.operationImpl();
  }
}

// 实现化类
interface Implementor {
  void operationImpl();
}

// 实现化1类
class ConcreteImplementor1 implements Implementor {
  @Override
  public void operationImpl() {
    System.out.println("执行ConcreteImplementor1的操作...");
  }
}

// 实现化2类
class ConcreteImplementor2 implements Implementor {
  @Override
  public void operationImpl() {
    System.out.println("执行ConcreteImplementor2的操作...");
  }
}

// 测试
public class BridgePatternDemo {
  public static void main(String[] args) {
    Implementor impl1 = new ConcreteImplementor1();
    Implementor impl2 = new ConcreteImplementor2();

    Abstraction abstraction1 = new RefinedAbstraction(impl1);
    Abstraction abstraction2 = new RefinedAbstraction(impl2);

    abstraction1.operation();
    abstraction2.operation();
  }
}

// 扩充抽象化类
class RefinedAbstraction extends Abstraction {
  public RefinedAbstraction(Implementor implementor) {
    super(implementor);
  }
}
```

如上所示，首先创建一个抽象化类Abstraction，它包含一个Implementor属性，用于存放实现类对象。其次创建一个Implementor接口，用于声明操作方法operationImpl。之后创建两个实现化类，分别为ConcreteImplementor1和ConcreteImplementor2，它们实现了Implementor接口。接着创建一个桥接模式类的Test类，通过InstantiateAbstraction创建两个Abstraction对象，设置不同的实现类对象，调用它们的operation方法，打印出对应的输出结果。

### 3.2.3 组合模式
组合模式（Composite Pattern）是结构型模式，其特点在于将对象组合成树形结构，用来表示“整体-部分”的层次结构。如下所示是一个组合模式类的Java实现：

```java
// 抽象构件类
abstract class Component {
  protected String name;

  public Component(String name) {
    this.name = name;
  }

  public abstract void addChild(Component component);

  public abstract void removeChild(Component component);

  public abstract Component getChild(int index);

  public abstract void display(int depth);
}

// 叶子构件类
class Leaf extends Component {
  public Leaf(String name) {
    super(name);
  }

  @Override
  public void addChild(Component component) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void removeChild(Component component) {
    throw new UnsupportedOperationException();
  }

  @Override
  public Component getChild(int index) {
    throw new UnsupportedOperationException();
  }

  @Override
  public void display(int depth) {
    for (int i = 0; i < depth; i++) {
      System.out.print("--");
    }
    System.out.println(name);
  }
}

// 复合构件类
class Composite extends Component {
  private List<Component> childComponents;

  public Composite(String name) {
    super(name);
    childComponents = new ArrayList<>();
  }

  @Override
  public void addChild(Component component) {
    childComponents.add(component);
  }

  @Override
  public void removeChild(Component component) {
    childComponents.remove(component);
  }

  @Override
  public Component getChild(int index) {
    return childComponents.get(index);
  }

  @Override
  public void display(int depth) {
    for (int i = 0; i < depth; i++) {
      System.out.print("--");
    }
    System.out.println(name);

    Iterator<Component> iterator = childComponents.iterator();
    while (iterator.hasNext()) {
      Component component = iterator.next();
      component.display(depth+1);
    }
  }
}

// 测试
public class CompositePatternDemo {
  public static void main(String[] args) {
    Component root = new Composite("整体");

    Component branch1 = new Composite("部门1");
    root.addChild(branch1);

    Component leaf1 = new Leaf("小明");
    branch1.addChild(leaf1);

    Component leaf2 = new Leaf("小红");
    branch1.addChild(leaf2);

    Component branch2 = new Composite("部门2");
    root.addChild(branch2);

    Component leaf3 = new Leaf("小张");
    branch2.addChild(leaf3);

    Component leaf4 = new Leaf("小李");
    branch2.addChild(leaf4);

    root.display(1);
  }
}
```

如上所示，首先创建一个抽象构件类Component，它包含名字、添加孩子、删除孩子、获取孩子和显示信息的方法。然后创建一个叶子构件类Leaf，它实现了抽象构件类的所有方法，抛出UnsupportedOperationException异常。再创建一个复合构件类Composite，它也实现了抽象构件类的所有方法，包括添加孩子、删除孩子、获取孩子，但不支持这些操作，而是在内部维护了一个Component集合用于存储子节点。最后创建一个Test类，实例化一个根节点对象，添加一些子节点，并调用display方法打印出整体结构。

### 3.2.4 装饰器模式
装饰器模式（Decorator Pattern）是结构型模式，其特点在于动态地给一个对象增加一些额外的功能。如下所示是一个装饰器模式类的Java实现：

```java
// 抽象构件类
abstract class Component {
  protected String name;

  public Component(String name) {
    this.name = name;
  }

  public abstract void display(int depth);
}

// 具体构件类
class ConcreateComponent extends Component {
  public ConcreateComponent(String name) {
    super(name);
  }

  @Override
  public void display(int depth) {
    for (int i = 0; i < depth; i++) {
      System.out.print("-");
    }
    System.out.println(name);
  }
}

// 抽象装饰类
abstract class Decorator extends Component {
  protected Component component;

  public Decorator(String name, Component component) {
    super(name);
    this.component = component;
  }

  public void setComponent(Component component) {
    this.component = component;
  }

  @Override
  public void display(int depth) {
    component.display(depth);
  }
}

// 具体装饰类
class RedBorderDecorator extends Decorator {
  public RedBorderDecorator(Component component) {
    super("红色边框", component);
  }

  @Override
  public void display(int depth) {
    super.display(depth);
    for (int i = 0; i <= depth; i++) {
      System.out.print("* ");
    }
    System.out.println("红色边框");
  }
}

// 另一个具体装饰类
class BlackBorderDecorator extends Decorator {
  public BlackBorderDecorator(Component component) {
    super("黑色边框", component);
  }

  @Override
  public void display(int depth) {
    super.display(depth);
    for (int i = 0; i <= depth; i++) {
      System.out.print("* ");
    }
    System.out.println("黑色边框");
  }
}

// 测试
public class DecoratorPatternDemo {
  public static void main(String[] args) {
    Component concreate = new ConcreateComponent("叶子组件");

    Component redBorderConcreate = new RedBorderDecorator(concreate);
    redBorderConcreate.display(1);

    Component blackBorderConcreate = new BlackBorderDecorator(redBorderConcreate);
    blackBorderConcreate.setComponent(concreate);
    blackBorderConcreate.display(1);
  }
}
```

如上所示，首先创建一个抽象构件类Component，它包含显示信息的方法。然后创建一个具体构件类ConcreateComponent，它继承了Component，并实现了它的display方法。接着创建一个抽象装饰类Decorator，它包含一个Component属性，并且实现了自己的display方法，它会调用它的component对象的display方法，这样就保证了装饰器和被装饰对象可以正确显示。再创建一个具体装饰类RedBorderDecorator，它继承Decorator，重写了display方法，在原有输出前加上了红色边框。再创建一个另一个具体装饰类BlackBorderDecorator，它继承Decorator，重写了display方法，在原有输出前加上了黑色边框。最后创建一个Test类，实例化一个叶子节点对象，加上红色边框装饰器和黑色边框装饰器，并调用display方法打印出边框装饰后的叶子节点。

### 3.2.5 享元模式
享元模式（Flyweight Pattern）是结构型模式，其特点在于减少内存占用，相同或者相似对象只保存一份，当需要创建很多对象的时候，可以将其共享，节省内存空间。如下所示是一个享元模式类的Java实现：

```java
// 抽象享元类
abstract class Flyweight {
  protected String intrinsic;

  public Flyweight(String intrinsic) {
    this.intrinsic = intrinsic;
  }

  public abstract void operation(UnsharedConcreteFlyweight unsharedConcreteFlyweight);
}

// 非共享享元类
class UnsharedConcreteFlyweight extends Flyweight {
  public UnsharedConcreteFlyweight(String intrinsic) {
    super(intrinsic);
  }

  @Override
  public void operation(UnsharedConcreteFlyweight unsharedConcreteFlyweight) {
    System.out.println("非共享享元对象的操作..." + unsharedConcreteFlyweight.intrinsic);
  }
}

// 共享享元类
class SharedConcreteFlyweight extends Flyweight {
  public SharedConcreteFlyweight(String intrinsic) {
    super(intrinsic);
  }

  @Override
  public void operation(UnsharedConcreteFlyweight unsharedConcreteFlyweight) {
    System.out.println("共享享元对象的操作..." + unsharedConcreteFlyweight.intrinsic);
  }
}

// 测试
public class FlyweightPatternDemo {
  public static void main(String[] args) {
    SharedConcreteFlyweight shared1 = new SharedConcreteFlyweight("共享对象1");
    SharedConcreteFlyweight shared2 = new SharedConcreteFlyweight("共享对象2");

    UnsharedConcreteFlyweight unshared1 = new UnsharedConcreteFlyweight("非共享对象1");
    UnsharedConcreteFlyweight unshared2 = new UnsharedConcreteFlyweight("非共享对象2");

    shared1.operation(unshared1);
    shared2.operation(unshared2);
  }
}
```

如上所示，首先创建一个抽象享元类Flyweight，它包含内蕴状态和行为，其中行为是一个抽象方法。然后创建一个非共享享元类UnsharedConcreteFlyweight，它继承Flyweight，并且重写了behavior方法，打印出传入的非共享对象。再创建一个共享享元类SharedConcreteFlyweight，它继承Flyweight，它可以被共享，所以不会被打印出来。最后创建一个Test类，实例化两个共享享元对象，和两个非共享享元对象，调用共享享元对象的operation方法，打印出操作结果。

