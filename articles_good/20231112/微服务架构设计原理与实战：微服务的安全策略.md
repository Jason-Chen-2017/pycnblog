                 

# 1.背景介绍


## 一、什么是微服务架构？
微服务（Microservices）是一种架构模式，它通过将单个应用程序作为小型服务进行开发，每个服务都运行在自己的进程中，彼此之间互相隔离，允许独立部署，可以按需伸缩，易于理解和维护。微服务架构是由一些轻量级的、松耦合的服务模块组成，这些服务模块按照业务功能进行划分，能够实现各自独立的持续交付能力。

传统的单体应用架构模式是一个庞大的应用程序，所有的功能都堆积在一个系统里，随着功能的增加和迭代，这个应用程序会越来越臃肿，难以维护、扩展和升级。而微服务架构则试图将单体应用拆分为多个小型、可独立开发的服务，每个服务负责不同的业务功能，独立部署、独立扩展，更适合云计算时代的应用架构。

## 二、为什么要使用微服务架构？
### （1）组件化开发
组件化开发的一个优点是其可以提高开发效率，比如不同的团队可以工作在不同的部分，并独立开发其中的某些模块，并且只部署需要的服务。另一方面，微服务架构也是一种灵活的架构风格，因为它鼓励将一个大型应用程序拆分为多个小型、松耦合的服务，使得单个服务的改动不会影响整个系统的运作。

### （2）弹性伸缩
微服务架构带来的另一个好处就是可以利用云计算平台提供的弹性伸缩能力，即根据需求动态调整资源分配和分配比例，以便应对不断变化的业务场景。通过微服务架构，可以让应用具备弹性，在硬件、软件、网络、数据库等各项资源上都能弹性应对变化，从而实现业务快速响应和创新。

### （3）容错
微服务架构的另一个好处是其容错能力强，一个服务出现故障时只影响该服务的一部分功能，不会造成整体故障。另外，当某个服务的依赖服务出现故障时，也不会影响整个应用的正常运行，因此微服务架构具有很好的容错能力。

### （4）服务自治
微服务架构还可以让服务各自独立开发、部署、扩展，从而可以减少整体应用的开发和维护成本，让开发者聚焦于最重要的业务功能。

### （5）数据分层
微服务架构可以把不同类型的数据存储到不同的服务中，这样就能保证数据的隔离性和可用性。对于那些频繁访问的数据，可以存放在内存缓存中，对于不经常访问的数据，可以存放在磁盘或数据库中，达到最佳的数据分布。

## 三、微服务架构设计原理简介
### （1）分布式服务治理
分布式服务治理（Distributed Service Governance），即服务之间如何通讯、发现、路由请求、熔断和限流等。传统的服务治理模式，如SOA（Service-Oriented Architecture）和RPC（Remote Procedure Call），是基于中心化的方式管理微服务间的通信和调用关系，而分布式服务治理则采用去中心化的方式进行服务治理，即每个服务节点自己负责管理自己的服务，并且采用分布式协调机制，通过向注册中心发送心跳信息和服务元数据，帮助其他服务节点发现和路由请求。

### （2）消息队列和事件总线
消息队列和事件总线（Message Queue and Event Bus）是微服务架构下最基础的技术，用于解耦服务之间内部的调用关系，从而实现异步通信。当服务间需要相互通信时，首先通过消息队列进行异步通信；如果服务间存在非常紧密的调用关系，可以通过事件总线来实现同步通信。

### （3）服务网关
服务网关（Gateway）是微服务架构的“大脑”，它接收外部用户的请求，并根据路由规则把请求转发给对应的服务，并且支持负载均衡、认证授权、日志记录等功能。由于服务网关可以看成是一个独立的服务节点，所以它的设计与开发也应该按照服务的特性进行设计和开发。

### （4）服务注册与发现
服务注册与发现（Service Registry and Discovery）是微服务架构的“耳朵”，它用来管理服务集群的信息，包括服务的地址、端口、服务名等。服务注册中心和客户端都可以使用服务注册与发现功能，从而知道其它服务的位置。

### （5）配置中心和共享存储
配置中心和共享存储（Configuration Center and Shared Storage）是微服务架构下最复杂的技术之一，它们用于管理微服务的配置参数、日志级别、数据库连接串、SSL证书等，并且保证微服务集群中的所有微服务获取同样的配置数据。

### （6）认证授权和权限控制
认证授权和权限控制（Authentication, Authorization and Permission Control）是微服务架构中比较重要的技术，它通过访问控制列表（ACL）来控制微服务之间的访问权限，确保服务的安全性。认证服务器和资源服务器是两个主要的组件，用于实现认证授权和权限控制。

### （7）日志聚合和查询
日志聚合和查询（Logging Aggregation and Querying）用于收集、整理、分析和查询微服务集群中的日志数据。ELK（Elasticsearch、Logstash、Kibana）是一个开源的日志聚合工具栈，它通常被用在微服务架构中。

### （8）健康检查
健康检查（Health Checking）是微服务架构的重要特征之一，它用于检测微服务是否正常运行，并采取相应措施进行恢复。在 Kubernetes 和 Docker Swarm 中，可以使用诸如 Prometheus 和 Consul 之类的工具来实现健康检查。

### （9）自动化部署
自动化部署（Continuous Deployment/Delivery）是微服务架构下的一个热门话题，目的是实现应用的持续集成、持续交付和部署流程。Jenkins、Ansible、Gitlab CI/CD、Kubernetes 等开源工具可以实现微服务的自动化部署。

# 2.核心概念与联系
## 服务网关 Gateway
服务网关，是微服务架构中的一个重要角色，通常用来实现请求的转发、负载均衡、流量控制、权限校验等，类似于传统的边缘设备，将用户的请求转发到对应的后端服务节点。每个服务都有自己独立的域名，但最终都会通过统一的服务网关才能访问到服务的实际节点。
服务网关与API Gateway的区别：API Gateway属于服务网关范畴，而微服务架构中的服务网关指整个微服务架构的入口，如上图所示。

微服务架构的服务网关包含以下几个基本功能：

1. 代理请求：一般来说，服务网关都会充当一个代理角色，它接受外部请求，并把请求转发到服务集群中对应的服务节点上。

2. 负载均衡：服务集群中的节点数量多了之后，服务网关就会遇到性能瓶颈，因此需要引入负载均衡算法进行优化。

3. 流量控制：服务网关通过设置阀值控制服务的流量，避免过大的流量压垮服务节点。

4. 权限校验：服务网关通过鉴权模块校验客户端的身份，判断是否有访问当前服务的权限。

5. 协议转换：服务网关需要兼容多种服务协议，如HTTP、HTTPS、TCP、WebSocket等。

6. API定义及版本管理：服务网关通过RESTful API或者GraphQL API接口规范，定义了访问当前服务的接口，并通过版本号进行管理。

7. 提供监控、报警、限流、降级、熔断等功能：服务网关除了提供上述功能外，还可以提供各种监控、报警、限流、降级、熔断等功能。

## 配置中心 Configuration Management
配置中心，是微服务架构中管理微服务配置的组件，通常使用键值对方式存储配置信息，包括静态配置和动态配置。静态配置如数据库连接串、SSL证书路径等，不需要动态变更；动态配置如微服务的日志级别、线程池大小等，可以在线更新。配置中心提供了统一的配置管理界面，让开发人员可以通过web页面、RESTful API或SDK来修改配置。配置中心对外提供API接口，让客户端可以通过API来获取、更新配置信息。

## 认证授权 Authentication, Authorization and Permission Control
认证授权，是微服务架构中用于实现用户认证和鉴权的关键技术，主要目的是验证用户是否拥有访问当前服务的权限。常用的认证授权方式有两种：

1. OAuth2.0：OAuth2.0是行业标准协议，目前已成为微服务架构中的一种认证授权协议，它支持第三方应用安全地获取资源访问令牌，可用于替代传统的API密钥。

2. JWT：JSON Web Token，这是一种针对WebAPI的基于Token的认证授权协议，它可以将用户信息编码进Token中，并且签名，防止Token被篡改。

权限控制，是微服务架构中用于管理用户访问权限的技术，包括三个方面的内容：

1. ACL：访问控制列表，是一种基于角色的访问控制技术，用于限制用户对特定资源的访问权限。

2. RBAC：基于角色的访问控制，是一种更细粒度的访问控制，通过将用户的角色划分为不同的组，并为每个组分配相应的权限，实现不同角色的访问控制。

3. ABAC：属性-值-规则访问控制，是一种更严格的访问控制方法，通过对用户的属性进行匹配，来确定用户是否具有访问权限。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 数据加密和传输安全加密算法
加密算法又称加密技术、加密工艺、加密手段、加密过程。加密算法是为了解决信息在传输过程中可能遭受窃听、抗攻击和信息泄露的问题而产生的一种算法。

常见的加密算法包括：

1. 对称加密算法：对称加密算法指加密和解密使用相同密钥的算法。常见的对称加密算法有DES、AES、RSA、ECC等。

2. 非对称加密算法：非对称加密算法指加密和解密使用的密钥是不同的算法。常见的非对称加密算法有RSA、Diffie-Hellman、ECDH、ElGamal等。

3. Hash函数：Hash函数又称散列函数、摘要函数，它把任意长度的信息变换为固定长度的结果。常见的Hash算法有MD5、SHA1、SHA256、SHA384、SHA512等。

4. 摘要算法：摘要算法是一种将输入数据重新计算摘要值的算法，常用于数据完整性校验。常见的摘要算法有MD5、SHA1、SHA256等。

## 安全相关算法
常见的安全相关算法如下：

1. 对称加密算法：对称加密算法指加密和解密使用相同密钥的算法，常见的算法有DES、AES等。

2. 不可逆加密算法：不可逆加密算法指加密的信息无法通过解密获得原始信息的算法，常见的算法有RSA、ECC等。

3. 数字签名算法：数字签名算法是一种建立文档真实性的方法，采用公私钥对的方法，公钥用于加密签名，私钥用于解密验证。

4. 密码学套件：密码学套件是一种规范的集合，包括各种加密算法、哈希算法、签名算法等，实现安全的消息传递。

5. 随机数生成器：随机数生成器是计算机中用于产生随机数的算法。随机数生成器可以用于密码学、网络安全领域。

6. 加解密算法：加解密算法又称加密算法、解密算法，是实现加密、解密功能的算法，常见的算法有DES、AES、RSA等。

7. 密钥交换算法：密钥交换算法用于双方共享密钥，是公钥加密算法的关键技术，常见的算法有Diffie-Hellman、ECDH等。

## OAuth2.0协议的四种模式
OAuth2.0是一种开放授权协议，它用于第三方网站或app向第三方网站提供用户授权，以获取特定的资源权限。四种授权模式分别为：

1. 授权码模式（Authorization Code）：这种模式的特点是在浏览器中完成认证，即先向授权服务器申请授权码，然后再用授权码获取访问令牌。

2. 隐藏式（Implicit）模式：这种模式的特点是直接向授权服务器申请访问令牌，无需向浏览器展示认证页面。

3. 密码模式（Resource Owner Password Credentials）：这种模式的特点是通过用户名和密码向授权服务器申请访问令牌，属于最简单的授权模式。

4. 客户端模式（Client credentials）：这种模式的特点是向授权服务器申请客户端的身份（ID与SECRET），然后用该身份向其他服务器申请访问令牌，属于机器到机器的认证模式。

## JWT(Json Web Token)的构成
JWT（Json Web Token）是一种新的基于JSON的轻量级Web Token规范。它使用了URLsafe的Base64url编码方式对JSON对象编码，并通过“.”(点)符号分割来进行信息封包。

JWT由三部分组成：头部、载荷与签名。
1. 头部：头部包括两部分：算法标识、声明。
2. 载荷：载荷由三部分组成：有效时间、主题、授权信息。
3. 签名：签名是对头部、载荷、秘钥进行加密后的字符串，用来校验数据的完整性。

## Spring Security OAuth2的配置
Spring Security OAuth2是Spring Framework提供的用于处理OAuth2的工具包，其配置流程如下：

1. 添加pom依赖：

```xml
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-autoconfigure</artifactId>
            <version>${spring.version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <!-- 添加Jackson依赖 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
```

2. 在启动类上添加注解@EnableOAuth2Sso，用来启用OAuth2的sso功能：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.KeyStoreKeyFactory;

@SpringBootApplication
@EnableGlobalMethodSecurity(prePostEnabled = true) // 方法级安全注解开启
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Bean
    public JwtAccessTokenConverter jwtAccessTokenConverter() throws Exception{
        KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(
                new ClassPathResource("keystore.jks"), "password".toCharArray());
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setKeyPair(keyStoreKeyFactory.getKeyPair("mytest"));
        return converter;
    }
    
    @Bean
    public InMemoryTokenStore tokenStore(){
        return new InMemoryTokenStore();
    }
    
    
    /**
     * 设置spring security的默认登录页
     */
    @EnableWebSecurity
    protected static class WebSecurityConfig extends WebSecurityConfigurerAdapter {
        private final String FORM_LOGIN_PAGE = "/login";

        @Override
        protected void configure(HttpSecurity http) throws Exception {

            // 需要身份认证时，表单登录
            http.authorizeRequests().anyRequest().authenticated().and()
                   .formLogin().loginPage(FORM_LOGIN_PAGE).permitAll().and()
                   .logout().permitAll();
        }
    }

}
```

3. 创建一个客户端配置文件：

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          testclient: # 配置客户端id
            provider: server # 客户端提供商
            client-id: testclient # 配置客户端id
            client-secret: secret # 配置客户端密码，需要注意不要泄露
            authorization-grant-type: password # 配置授权模式
        provider:
          server:
            token-uri: http://localhost:8080/uaa/oauth/token
            user-info-uri: http://localhost:8080/uaa/api/user
```

4. 使用postman或者自定义工具测试访问权限

# 4.具体代码实例和详细解释说明
## Spring Cloud Config的配置
Spring Cloud Config是微服务架构中的一个重要组件，用于集中管理应用程序的配置。其主要作用包括：

1. 分布式配置：配置中心可以存储微服务的配置信息，不同的环境可以读取同样的配置，不需要对源代码进行任何更改。

2. 配置文件管理：配置中心可以管理不同环境下微服务的配置信息，只需通过网页或接口形式添加、修改、删除配置即可。

3. 动态刷新：当配置中心的配置发生变更时，微服务可以动态刷新配置，实时生效。

Spring Cloud Config的配置流程如下：

1. 添加pom依赖：

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
```

2. 在bootstrap.yml配置文件中配置spring cloud config相关的属性：

```yaml
server:
  port: ${port:8888}
    
spring:
  application:
    name: demo
    
eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
  
management:
  endpoints:
    web:
      exposure:
        include: refresh,health,info
        
---
spring:
  profiles: dev
  cloud:
    config:
      uri: http://localhost:${config.port}
      
config:
  port: 8888
  label: master
  profile: dev
  
logging:
  file: logs/${spring.application.name}-${timestamp}.log
  level:
    root: INFO
    org.springframework.cloud.config: DEBUG
    
server:
  servlet:
    context-path: /config
    
---
spring:
  profiles: prod
  cloud:
    config:
      uri: http://localhost:${config.port}
      
config:
  port: 8888
  label: master
  profile: prod
```

3. 在微服务的application.yml文件中指定配置文件的位置：

```yaml
spring:
  profiles:
    active: dev
  
  datasource:
    url: jdbc:mysql://localhost:3306/demo?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai

  jpa:
    hibernate:
      ddl-auto: update
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
        
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL5Dialect
        format_sql: true

  redis:
    host: localhost
    port: 6379
    database: 0

  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
    virtual-host: "/"

  swagger:
    title: "${spring.application.name}"
    description: "Spring Boot Project"
    version: "v1.0"
    base-package: com.example.demo.${spring.profiles.active}  
    license: "Apache 2.0"
    licenseUrl: "http://www.apache.org/licenses/LICENSE-2.0.html"
    termsOfServiceUrl: ""
    contactName: "author"
    contactUrl: "https://github.com/heyuxuan"
    contactEmail: "<EMAIL>"
```

4. 通过actuator暴露配置相关接口：

```java
import org.springframework.boot.actuate.autoconfigure.endpoint.web.servlet.WebMvcEndpointHandlerMapping;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

@Configuration
public class EndpointConfig {
    @Bean
    public RequestMappingHandlerMapping requestMappingHandlerMapping() {
        return new WebMvcEndpointHandlerMapping();
    }
}
```

5. 在客户端项目中使用FeignClient访问配置中心：

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(value="config-service", fallback = ConfigClientFallback.class)
public interface ConfigClient {

    @GetMapping("/master/{profile}/{label}/{path}")
    String getValue(@PathVariable("profile") String profile,
                     @PathVariable("label") String label,
                     @PathVariable("path") String path);

}


@Component
public class ConfigClientFallback implements ConfigClient {
    @Override
    public String getValue(String profile, String label, String path) {
        log.warn("【ConfigClient】Get value error, use local cache");
        try {
            return FileUtils.readFileToString(new File("config/" + profile + "-" + label + ".properties"), StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("Get value from local cache failed.");
        }
    }
}
```

6. 在项目的main方法中启动主程序：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean;
import org.springframework.cloud.netflix.eureka.config.EurekaClientConfigBean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@Import({ EurekaClientConfigBean.class, EurekaInstanceConfigBean.class })
@PropertySource({"classpath:/common.properties"})
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

## Spring Cloud Zuul的配置
Spring Cloud Zuul是微服务架构中的一个网关组件，用来提供API Gateway。Zuul通过过滤器来过滤请求、转发请求、验证请求头等功能。

Zuul的配置流程如下：

1. 添加pom依赖：

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zuul</artifactId>
        </dependency>
```

2. 在bootstrap.yml配置文件中配置zuul相关的属性：

```yaml
server:
  port: ${port:8769}
    
spring:
  application:
    name: zuul
    
eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
    
management:
  endpoints:
    web:
      exposure:
        include: health,info
    
logging:
  file: logs/${spring.application.name}-${timestamp}.log
  level:
    root: INFO
    org.springframework.cloud.netflix.zuul: DEBUG
    
zuul:
  ignored-services: '*'
  routes:
    auth-service:
      path: /auth/**
      url: http://${AUTH_SERVICE_HOST}:${AUTH_SERVICE_PORT}
      sensitiveHeaders: Cookie,Set-Cookie,Authorization
    product-service:
      path: /product/**
      url: http://${PRODUCT_SERVICE_HOST}:${PRODUCT_SERVICE_PORT}
    order-service:
      path: /order/**
      url: http://${ORDER_SERVICE_HOST}:${ORDER_SERVICE_PORT}
    customer-service:
      path: /customer/**
      url: http://${CUSTOMER_SERVICE_HOST}:${CUSTOMER_SERVICE_PORT}
```

3. 在项目的application.yml文件中指定配置文件的位置：

```yaml
spring:
  profiles:
    active: dev
  
zuul:
  ratelimit:
    enabled: true
    repository: MEMORY
    policy-list:
      - limit: 10
        quota: 10
        refreshInterval: 60s
        type:
          
      - limit: 100
        quota: 100
        refreshInterval: 60s
        type:
        
      - limit: 200
        quota: 200
        refreshInterval: 60s
        type:
        
      - limit: 300
        quota: 300
        refreshInterval: 60s
        type:
          
      - limit: 500
        quota: 500
        refreshInterval: 60s
        type:
          
      - limit: 1000
        quota: 1000
        refreshInterval: 60s
        type:
        
      - limit: 2000
        quota: 2000
        refreshInterval: 60s
        type:
        
      - limit: 3000
        quota: 3000
        refreshInterval: 60s
        type:
            
      - limit: 5000
        quota: 5000
        refreshInterval: 60s
        type:  
```

4. 通过actuator暴露配置相关接口：

```java
import org.springframework.boot.actuate.autoconfigure.endpoint.web.servlet.WebMvcEndpointHandlerMapping;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

@Configuration
public class EndpointConfig {
    @Bean
    public RequestMappingHandlerMapping requestMappingHandlerMapping() {
        return new WebMvcEndpointHandlerMapping();
    }
}
```

5. 在客户端项目中使用FeignClient访问配置中心：

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(value="config-service", fallback = ConfigClientFallback.class)
public interface ConfigClient {

    @GetMapping("/master/{profile}/{label}/{path}")
    String getValue(@PathVariable("profile") String profile,
                     @PathVariable("label") String label,
                     @PathVariable("path") String path);

}


@Component
public class ConfigClientFallback implements ConfigClient {
    @Override
    public String getValue(String profile, String label, String path) {
        log.warn("【ConfigClient】Get value error, use local cache");
        try {
            return FileUtils.readFileToString(new File("config/" + profile + "-" + label + ".properties"), StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new RuntimeException("Get value from local cache failed.");
        }
    }
}
```

6. 在项目的main方法中启动主程序：

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean;
import org.springframework.cloud.netflix.eureka.config.EurekaClientConfigBean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.PropertySource;

@SpringBootApplication
@Import({ EurekaClientConfigBean.class, EurekaInstanceConfigBean.class })
@PropertySource({"classpath:/common.properties"})
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```