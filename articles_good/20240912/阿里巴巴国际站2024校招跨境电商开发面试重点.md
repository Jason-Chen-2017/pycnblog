                 

阿里巴巴国际站2024校招跨境电商开发面试重点：面试题库与算法编程题库

一、面试题库

### 1. 讲解跨境电商业务流程

**题目：** 请简要描述跨境电商的业务流程，并说明各个步骤的作用。

**答案：** 跨境电商的业务流程包括以下步骤：

1. **市场调研**：了解目标市场的需求、竞争对手、市场规模等信息，为产品定位和市场推广提供依据。
2. **产品定位**：根据市场调研结果，确定适合目标市场的产品，并进行差异化营销。
3. **平台选择**：选择适合跨境电商业务的电商平台，如阿里巴巴国际站、亚马逊、eBay等。
4. **产品上架**：在选定的平台上进行产品上架，包括产品描述、图片、价格等信息。
5. **订单管理**：处理客户订单，包括订单确认、发货、售后服务等。
6. **物流配送**：选择合适的物流公司，确保货物安全、快速地送达客户。
7. **支付结算**：支持多种支付方式，如信用卡、支付宝、PayPal等，确保交易安全、便捷。
8. **数据分析**：分析销售数据、客户反馈等，优化产品、营销策略和业务流程。

**解析：** 通过以上步骤，跨境电商业务可以实现产品从生产、销售到客户的全过程管理，提高业务效率、降低成本、提升客户满意度。

### 2. 跨境电商中的支付流程

**题目：** 请详细描述跨境电商中的支付流程。

**答案：** 跨境电商中的支付流程通常包括以下步骤：

1. **买家下单**：买家在跨境电商平台上选择商品并下单，填写收货信息。
2. **卖家确认**：卖家收到订单后，确认订单信息，准备发货。
3. **支付环节**：卖家向买家发送支付链接，买家通过支付平台（如支付宝、PayPal）进行支付。
4. **支付确认**：支付平台将支付结果通知卖家和平台，卖家开始准备发货。
5. **发货**：卖家根据订单信息，通过物流公司将货物寄送至买家。
6. **物流跟踪**：买家在平台上查看物流信息，跟踪货物状态。
7. **收货确认**：买家收到货物后，在平台上确认收货。
8. **结算**：平台根据交易结果，将货款支付给卖家。

**解析：** 跨境电商支付流程涉及多个环节，包括订单、支付、发货、收货等，确保交易安全、可靠。

### 3. 跨境电商中的物流配送策略

**题目：** 请简要介绍跨境电商中的物流配送策略。

**答案：** 跨境电商中的物流配送策略包括以下几个方面：

1. **国内物流**：选择合适的国内物流公司，确保货物安全、快速地送达仓库。
2. **国际物流**：选择合适国际物流公司，根据目标国家和地区的特点，制定合适的物流方案，如海空联运、国际快递等。
3. **仓储管理**：在目标市场建立仓储中心，降低物流成本、提高配送效率。
4. **跨境清关**：了解目标市场的海关政策，确保货物顺利清关。
5. **运输保险**：为货物购买运输保险，降低运输过程中可能出现的损失风险。

**解析：** 跨境电商物流配送策略需要综合考虑国内物流、国际物流、仓储管理、跨境清关和运输保险等因素，提高物流效率和客户满意度。

### 4. 跨境电商中的营销策略

**题目：** 请简要介绍跨境电商中的营销策略。

**答案：** 跨境电商中的营销策略包括以下几个方面：

1. **搜索引擎优化（SEO）**：优化产品标题、描述、关键词等，提高产品在搜索引擎中的排名。
2. **搜索引擎营销（SEM）**：通过竞价广告、展示广告等方式，吸引目标客户访问平台和产品。
3. **社交媒体营销**：利用社交媒体平台（如Facebook、Instagram、Twitter等）宣传产品，提高品牌知名度。
4. **内容营销**：发布有价值的内容（如博客、视频、教程等），吸引潜在客户，提高产品转化率。
5. **网红营销**：与网红、KOL合作，通过他们的影响力推广产品。
6. **会员营销**：为会员提供优惠、积分、专属服务等方式，提高会员忠诚度。

**解析：** 跨境电商营销策略需要结合目标市场特点，综合运用多种营销手段，提高产品曝光度和销售转化率。

### 5. 跨境电商中的风险控制

**题目：** 请简要介绍跨境电商中的风险控制。

**答案：** 跨境电商中的风险控制包括以下几个方面：

1. **信用评估**：对供应商、客户进行信用评估，降低交易风险。
2. **支付安全**：确保支付环节的安全，如使用SSL加密、多因素验证等。
3. **物流安全**：确保物流环节的安全，如与物流公司签订安全协议、货物保险等。
4. **数据安全**：保护客户数据、交易数据等敏感信息，防止数据泄露。
5. **法律法规**：了解目标市场的法律法规，遵守相关法律法规，降低法律风险。

**解析：** 跨境电商风险控制需要从交易、支付、物流、数据等多个方面进行综合考虑，确保交易安全、可靠。

### 6. 跨境电商中的客户服务

**题目：** 请简要介绍跨境电商中的客户服务。

**答案：** 跨境电商中的客户服务包括以下几个方面：

1. **售前咨询**：为客户提供产品咨询、市场咨询等，帮助客户做出购买决策。
2. **售中服务**：为客户提供订单跟踪、物流查询等服务，确保客户了解订单状态。
3. **售后服务**：为客户提供退换货、维修等服务，提高客户满意度。
4. **客户反馈**：收集客户反馈，优化产品和服务，提高客户体验。

**解析：** 跨境电商中的客户服务是提升客户满意度、促进复购的重要环节，需要从售前、售中、售后服务等多个方面进行完善。

### 7. 跨境电商中的数据分析

**题目：** 请简要介绍跨境电商中的数据分析。

**答案：** 跨境电商中的数据分析包括以下几个方面：

1. **销售数据分析**：分析销售数据，了解产品销售情况，优化产品策略。
2. **客户数据分析**：分析客户数据，了解客户需求、偏好，提高客户满意度。
3. **市场数据分析**：分析市场数据，了解市场趋势、竞争对手情况，优化市场策略。
4. **库存数据分析**：分析库存数据，优化库存管理，降低库存成本。

**解析：** 跨境电商中的数据分析可以帮助企业了解市场、客户和产品的状况，优化业务流程，提高竞争力。

### 8. 跨境电商中的供应链管理

**题目：** 请简要介绍跨境电商中的供应链管理。

**答案：** 跨境电商中的供应链管理包括以下几个方面：

1. **供应商管理**：选择合适的供应商，建立长期合作关系，确保供应链稳定。
2. **采购管理**：根据销售预测，制定采购计划，确保库存充足。
3. **仓储管理**：优化仓储布局，提高仓储效率，降低物流成本。
4. **物流管理**：选择合适的物流公司，确保货物安全、快速地送达客户。
5. **供应链协同**：与供应商、物流公司等合作伙伴建立协同机制，提高供应链效率。

**解析：** 跨境电商中的供应链管理是确保产品从供应商到客户的全过程高效运作的重要环节。

### 9. 跨境电商中的跨境支付

**题目：** 请简要介绍跨境电商中的跨境支付。

**答案：** 跨境电商中的跨境支付包括以下几个方面：

1. **支付方式**：支持多种支付方式，如信用卡、支付宝、PayPal等，满足客户需求。
2. **支付渠道**：建立跨境支付渠道，确保支付过程安全、快捷。
3. **汇率管理**：根据汇率波动，合理调整产品价格，降低汇率风险。
4. **支付结算**：确保支付结算过程准确、及时，提高资金周转效率。

**解析：** 跨境电商中的跨境支付是确保交易顺利完成的关键环节，需要考虑支付方式、支付渠道、汇率管理和支付结算等因素。

### 10. 跨境电商中的跨境物流

**题目：** 请简要介绍跨境电商中的跨境物流。

**答案：** 跨境电商中的跨境物流包括以下几个方面：

1. **物流渠道**：选择合适的物流渠道，如空运、海运、快递等，确保货物安全、快速地送达客户。
2. **物流服务**：提供多种物流服务，如标准物流、加急物流等，满足客户需求。
3. **跨境清关**：了解目标市场的海关政策，确保货物顺利清关。
4. **物流跟踪**：提供物流跟踪服务，让客户随时了解货物状态。

**解析：** 跨境电商中的跨境物流是确保货物从卖家到客户的全过程高效运作的重要环节，需要考虑物流渠道、物流服务、跨境清关和物流跟踪等因素。

二、算法编程题库

### 1. 简化路径问题

**题目：** 给定一个由大小写英文字母组成的字符串 s，你需要将字符串进行若干替换，用相同长度的字母规则替换原字符串中的每个字母。所有替换都应该是 上行下效 的，意思是 a 用新字母替换后，所有 a 出现的地方都应该替换成同一个新字母。定义一个新的长度等于 s 长度的 02D 数组 paths，其中 paths[i] 是将 s 中第 i 个字符的所有可能替换。请按照下列步骤返回 paths：

1. 初始化一个长度为 26 的 02D 数组 letters，其中 letters[i] 是一个长度为 26 的 02D 数组，表示字母 i 可以替换成任意一个字母（包括自身）。
2. 对于每个字母 i，在 letters[i] 中，如果第 j 个字母在 s 中至少出现了两次，则将其置为 1，否则置为 0。
3. 如果第 i 个字母在 s 中只出现了一次，则将其在 letters[i] 中所有的位置都置为 1。
4. 遍历 letters，对于每个字母 i，如果 letters[i] 中的所有位置都被置为 1，则 paths[i] 应该是一个长度为 26 的 02D 数组，其中第 j 个位置为 1；否则，paths[i] 应该为空数组。
5. 返回 paths。

**示例 1：**

```plaintext
输入：s = "abcccde"
输出：[[0,0,1,0,0,0,1],[0,1,1,0,1,0,1],[1,0,1,1,0,0,1],[0,1,1,0,1,1,1],[1,1,1,1,1,1,0],[1,1,1,1,1,0,1]]
解释：
- 字母 'a' 只出现一次，所以 letters['a'][i] = 1 对于所有 0 <= i <= 25。
- 字母 'b' 出现两次，所以 letters['b'][i] = 1 对于所有 0 <= i <= 1 且 2 <= i <= 25。
- 字母 'c' 出现三次，所以 letters['c'][i] = 1 对于所有 0 <= i <= 2 且 3 <= i <= 25。
- 字母 'd' 和 'e' 各出现一次，所以 letters['d'][i] = 1 和 letters['e'][i] = 1 对于所有 0 <= i <= 25。
- paths['a'] = [[1,1,1,1,1,1,1]]，paths['b'] = [[1,1,0,0,0,0,0]]，paths['c'] = [[1,1,1,0,0,0,0]]，paths['d'] = [[1,1,1,1,1,1,1]]，paths['e'] = [[1,1,1,1,1,1,1]]。
```

**示例 2：**

```plaintext
输入：s = "abcd"
输出：[[0,0,0,0],[1,1,1,1],[1,1,1,1],[1,1,1,1]]
解释：
- 字母 'a' 只出现一次，所以 letters['a'][i] = 1 对于所有 0 <= i <= 25。
- 字母 'b'、'c' 和 'd' 各出现一次，所以 letters['b'][i] = 1、letters['c'][i] = 1 和 letters['d'][i] = 1 对于所有 0 <= i <= 25。
- paths['a'] = [[1,1,1,1,1,1,1]]，paths['b'] = [[1,1,1,1,1,1,1]]，paths['c'] = [[1,1,1,1,1,1,1]]，paths['d'] = [[1,1,1,1,1,1,1]]。
```

**示例 3：**

```plaintext
输入：s = "aabbcc"
输出：[[0,0,0,0],[1,1,1,1],[1,1,1,1],[0,0,0,0]]
解释：
- 字母 'a' 和 'b' 各出现两次，所以 letters['a'][i] = 1 对于所有 0 <= i <= 1，letters['b'][i] = 1 对于所有 2 <= i <= 3。
- 字母 'c' 只出现一次，所以 letters['c'][i] = 1 对于所有 4 <= i <= 25。
- paths['a'] = [[1,1,0,0,0,0,0]]，paths['b'] = [[1,1,1,1,0,0,0]]，paths['c'] = [[1,1,1,1,1,1,1]]。
```

**示例 4：**

```plaintext
输入：s = "aa"
输出：[[0,0,0,0],[1,1,0,0,0,0,0]]
解释：
- 字母 'a' 只出现一次，所以 letters['a'][i] = 1 对于所有 0 <= i <= 25。
- paths['a'] = [[1,1,0,0,0,0,0]]。
```

**提示：**

* 1 <= s.length <= 26
* s 只包含小写英文字母。

**答案：**

```python
class Solution:
    def possibleTransitions(self, s: str) -> List[List[int]]:
        letters = [[0] * 26 for _ in range(26)]
        cnt = [0] * 26
        for c in s:
            cnt[ord(c) - ord('a')] += 1
        for i in range(26):
            if cnt[i] > 1:
                for j in range(26):
                    letters[i][j] = 1
        for i in range(26):
            if cnt[i] == 1:
                for j in range(26):
                    letters[i][j] = 1
        paths = []
        for i in range(26):
            if sum(letters[i]) == 26:
                paths.append([1] * 26)
            elif sum(letters[i]) > 0:
                paths.append([])
        return paths
```



### 2. 单词替换问题

**题目：** 给你一个由小写字母组成的字符串 word 和一个字母表的列表 dictionary 。我们希望按下述规则将 word 替换为一个字母表的词或者其中的部分词：

1. 首先，将 word 的第一个字母替换为字母表中第一个合适字母。
2. 对于后续的字母，如果其前一个字母已经被替换，用字母表中该字母之后的字母替换它。
3. 如果字母表中没有字母可以被替换给某个字母，用同样的字母替换它。

替换过程中需要保证替换后的字符串仍然是合法的表词。

（注：字母表中单词是以小写字母顺序排列的。如果字母表中没有该字母后面的字母，则用相同的字母替换。）

请你找出并返回 word 替换后的结果。如果无法将其替换为单词表中的单词，则返回空字符串。

**示例 1：**

```plaintext
输入：word = "affe", dictionary = ["plane","hook","map"]
输出："//plane//"
解释：
- "affe" 不能替换成 "hook"，因为 'f' 只出现一次，所以 "hook" 不能形成字符串。
- "affe" 可以替换成 "plane"，因为 'a' 和 'e' 被替换成了 'p' 和 'l'。
- "affe" 不能替换成 "map"，因为两个 'e' 都需要不同字母替换，但是 "map" 中只有 'p' 可用，所以无法形成字符串。
- 注意 "plane" 中两个 '//' 表示字符串中的两个 'e' 分别被替换成了 'p' 和 'l'。
```

**示例 2：**

```plaintext
输入：word = "ILoveYou", dictionary = ["ILoveYou"]
输出："ILoveYou"
解释：
- 字母表 = ["ILoveYou"]。
- "ILoveYou" 替换为 "ILoveYou"。
```

**提示：**

* 1 <= word.length <= 100
* word 只包含小写英文字母
* 1 <= dictionary.length <= 10
* 1 <= dictionary[i].length <= 100
* dictionary[i] 只包含小写英文字母
* dictionary 中的所有字符串都 互不相同

**答案：**

```python
class Solution:
    def replaceTheWord(self, word: str, dictionary: List[str]) -> str:
        def replace(word):
            n = len(word)
            arr = list(word)
            ans = arr[:]
            if n == 1:
                return ans
            for i in range(1, n):
                if ans[i - 1] == ans[i]:
                    continue
                found = False
                for w in dictionary:
                    if w[0] == ans[i] and w[-1] == ans[i - 1]:
                        ans[i - 1] = w[0]
                        ans[i] = w[-1]
                        found = True
                        break
                if not found:
                    return []
            return ans

        i = 0
        while i < len(word):
            t = replace(word[i:])
            if not t:
                return ""
            word = ''.join(t)
            i += 1
        return ''.join(ans)
```

### 3. 汇总活动总数

**题目：** 有一个活动的起点和终点时间表 activities，其中 activities[i] = [starti, endi] 表示从 starti 开始、endi 结束的活动。每个活动都独立进行，活动之间的顺序可能会被打乱，但你仍然需要确保所有活动的参与者都能按照他们的活动顺序进行。

你需要从给定的活动中选择若干个，并安排参与者顺序进行这些活动。参与者必须按照以下规则进行活动：

1. 如果活动 A 在活动 B 开始之前结束，那么参与者必须先完成活动 A，然后再进行活动 B。
2. 如果两个活动的结束时间相同，那么它们的顺序任意。
3. 活动必须以顺序进行，不能跳过。

请你实现一个函数 `scheduleActivities`，返回参与者可以完成的最多的活动数量。

**示例 1：**

```plaintext
输入：activities = [[1,3], [2,4], [3,5]]
输出：3
解释：
参与者可以完成以下活动：
- 活动序列：1 → 2 → 3
- 活动序列：1 → 3 → 4
- 活动序列：1 → 3 → 5
```

**示例 2：**

```plaintext
输入：activities = [[1,3], [2,4], [3,5], [4,6]]
输出：5
解释：
参与者可以完成以下活动：
- 活动序列：1 → 2 → 3 → 4 → 6
- 活动序列：1 → 2 → 3 → 5 → 6
- 活动序列：1 → 3 → 4 → 5 → 6
- 活动序列：1 → 3 → 5 → 4 → 6
- 活动序列：1 → 3 → 5 → 6 → 4
```

**提示：**

* 1 <= activities.length <= 10^5
* activities[i].length == 2
* 1 <= starti < endi <= 10^9

**答案：**

```python
class Solution:
    def scheduleActivities(self, activities: List[List[int]]) -> int:
        activities.sort(key=lambda x: x[1])
        ans = 1
        j = 0
        for i in range(1, len(activities)):
            while j < len(activities) and activities[j][0] < activities[i][1]:
                j += 1
            ans = max(ans, i - j + 1)
        return ans
```

### 4. 贪心算法：合并区间

**题目：** 给定一个区间列表，请合并所有重叠的区间。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，合并为 [1,6]。
```

```plaintext
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可合并为 [1,5]。
```

**提示：**

* 1 <= intervals.length <= 10^4
* intervals[i].length == 2
* 0 <= intervals[i][0] <= intervals[i][1] <= 10^4

**答案：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        ans = []
        for interval in intervals:
            if not ans or ans[-1][1] < interval[0]:
                ans.append(interval)
            else:
                ans[-1][1] = max(ans[-1][1], interval[1])
        return ans
```

### 5. 动态规划：最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，找出它们的 最长公共子序列。如果不存在共同的子序列，返回空字符串。

**示例：**

```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"
解释："ace" 是最长公共子序列。
```

```plaintext
输入：text1 = "abc", text2 = "abc"
输出："abc"
解释："abc" 是最长公共子序列。
```

**提示：**

* 1 <= text1.length, text2.length <= 1000
* text1 和 text2 仅由小写英文字母组成

**答案：**

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> str:
        m, n = len(text1), len(text2)
        dp = [[""] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + text1[i - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[-1][-1]
```

### 6. 二分查找：寻找旋转排序数组中的最小值

**题目：** 给你一个旋转排序的数组 nums ，请你找出并返回数组的最小元素。

**示例：**

```plaintext
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5]，旋转后变为 [3,4,5,1,2]。
```

```plaintext
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7]，旋转后变为 [4,5,6,7,0,1,2]。
```

```plaintext
输入：nums = [1]
输出：1
解释：原数组为 [1]，旋转 0 次后数组不变。
```

**提示：**

* 1 <= nums.length <= 10^4
* -10^4 <= nums[i] <= 10^4
* nums 中的每个值都 独一无二
* nums 原来是一个升序排序的数组

**答案：**

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < nums[right]:
                right = mid
            else:
                left = mid + 1
        return nums[left]
```

### 7. 回溯算法：全排列

**题目：** 给定一个没有重复元素的整数数组 nums，返回该数组所有可能的排列。

**示例：**

```plaintext
输入：nums = [1,2,3]
输出：
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**提示：**

* 1 <= nums.length <= 6
* -10 <= nums[i] <= 10
* nums 中的所有整数均无重复

**答案：**

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, path, ans):
            if not nums:
                ans.append(path)
                return
            for i in range(len(nums)):
                dfs(nums[:i] + nums[i+1:], path + [nums[i]], ans)

        ans = []
        dfs(nums, [], ans)
        return ans
```

### 8. 二叉树遍历：前序遍历

**题目：** 给定一个二叉树的根节点 root，返回它的 前序遍历。

**示例：**

```plaintext
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**提示：**

* 节点数在 [0, 100] 范围内

**答案：**

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(root):
            if root is None:
                return
            ans.append(root.val)
            dfs(root.left)
            dfs(root.right)

        ans = []
        dfs(root)
        return ans
```

### 9. 单调栈：有效的括号字符串

**题目：** 给定一个只包含 '('、')' 和 '*' 的字符串 expression，验证是否有效。有效表达式的定义：任意连续的 '*' 都必须满足以下条件之一：

1. 它两边都是空字符串或者只包含 '(' 和 ')'，例如 '*()'。
2. 它周围的一部分括号内的字符串是一个有效的表达式，例如 '*()(*())'。

同时，'(' 必须在 '*' 的左边，')' 必须在 '*' 的右边。

**示例：**

```plaintext
输入：expression = "(*(()))()"
输出：true
解释：可以验证字符串是有效的，例如：可以分组为 *(()(()()))。
```

```plaintext
输入：expression = "(*(()*()))"
输出：true
解释：可以验证字符串是有效的，例如：可以分组为 *((*()))()。
```

```plaintext
输入：expression = "(****"
输出：false
解释：未找到有效的分组。
```

```plaintext
输入：expression = "(*)))"
输出：false
解释：没找到有效的括号分组。
```

```plaintext
输入：expression = "(()*"
输出：false
解释：未找到有效的分组。
```

**提示：**

* 1 <= expression.length <= 10^6
* expression 仅包含 '*'、'(' 和 ')' 字符

**答案：**

```python
class Solution:
    def isValid(self, expression: str) -> bool:
        stk = []
        for c in expression:
            if c == '(':
                stk.append(c)
            elif c == '*' or stk:
                if stk and stk[-1] == '(':
                    stk.append(c)
                else:
                    if stk[-1] == '(':
                        stk.pop()
                    stk.append(c)
            else:
                if stk[-1] == '(':
                    stk.pop()
                else:
                    stk.pop()
                    if stk and stk[-1] == '(':
                        stk.pop()
                    stk.append(')')
        return not stk
```

### 10. 双指针：两数之和

**题目：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```plaintext
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。
```

```plaintext
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

```plaintext
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

* 2 <= nums.length <= 10^3
* -10^9 <= nums[i] <= 10^9
* -10^9 <= target <= 10^9

**答案：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while left < right:
            if nums[left] + nums[right] == target:
                return [left, right]
            elif nums[left] + nums[right] < target:
                left += 1
            else:
                right -= 1
        return []
```

### 11. 排序算法：快速排序

**题目：** 给你一个整数数组 nums，请你找出并返回数组中的所有重复元素。

**示例：**

```plaintext
输入：nums = [1,2,3,1]
输出：[1]
```

```plaintext
输入：nums = [1,2,3,4,1]
输出：[1,3,4]
```

**提示：**

* 1 <= nums.length <= 10^5
* -10^9 <= nums[i] <= 10^9

**答案：**

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        def quicksort(arr, l, r):
            if l >= r:
                return
            pivot = arr[r]
            i = l
            for j in range(l, r):
                if arr[j] < pivot:
                    arr[i], arr[j] = arr[j], arr[i]
                    i += 1
            arr[i], arr[r] = arr[r], arr[i]
            quicksort(arr, l, i - 1)
            quicksort(arr, i + 1, r)

        quicksort(nums, 0, len(nums) - 1)
        ans = []
        for i in range(1, len(nums)):
            if nums[i] == nums[i - 1]:
                ans.append(nums[i])
        return ans
```

### 12. 链表：反转链表

**题目：** 反转一个单链表。

**示例：**

```plaintext
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

```plaintext
输入：head = [1,2]
输出：[2,1]
```

```plaintext
输入：head = []
输出：[]
```

**提示：**

* 链表中节点数目范围是 [0, 5000]
* -5000 <= Node.val <= 5000

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head is None:
            return None
        prev, curr = None, head
        while curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp
        return prev
```

### 13. 优先队列：合并 K 个排序链表

**题目：** 合并 k 个排序链表。请你们用 堆 或者优先队列实现。

**示例：**

```plaintext
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
```

**提示：**

* k 为整数且满足 k >= 1
* lists.length == k
* 1 <= k <= 10^4
* 0 <= lists[i].length <= 10^4
* -10^4 <= lists[i][j] <= 10^4
* lists[i] 已按升序排列
* lists[i] 中的所有值都独一无二

**答案：**

```python
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        dummy = ListNode()
        curr = dummy
        q = []
        for head in lists:
            if head:
                heapq.heappush(q, (head.val, head))
        while q:
            curr.next = heapq.heappop(q)[1]
            curr = curr.next
            if curr.next:
                heapq.heappush(q, (curr.next.val, curr.next))
        return dummy.next
```

### 14. 动态规划：零钱兑换

**题目：** 给定一个数组 coins 表示不同面额的硬币，和一个总金额 amount。请计算最少需要多少枚硬币组合出给定的金额。

**示例：**

```plaintext
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```

```plaintext
输入：coins = [2], amount = 3
输出：1
```

```plaintext
输入：coins = [1], amount = 0
输出：0
```

```plaintext
输入：coins = [1], amount = 1
输出：1
```

**提示：**

* 1 <= coins.length <= 12
* 1 <= coins[i] <= 2^31 - 1
* 0 <= amount <= 10^9

**答案：**

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
        return -1 if dp[amount] == float('inf') else dp[amount]
```

### 15. 并查集：岛屿数量

**题目：** 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

**示例：**

```plaintext
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

```plaintext
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

* m == grid.length
* n == grid[i].length
* 1 <= m, n <= 300
* grid[i][j] 为 '0' 或 '1'

**答案：**

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        m, n = len(grid), len(grid[0])
        p = list(range(m * n))
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    if i > 0 and grid[i - 1][j] == '1':
                        p[find(i * n + j)] = find((i - 1) * n + j)
                    if j > 0 and grid[i][j - 1] == '1':
                        p[find(i * n + j)] = find(i * n + j - 1)
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1' and find(i * n + j) == i * n + j:
                    ans += 1
        return ans
```

### 16. 图遍历：拓扑排序

**题目：** 给定一个无向图，返回一个按照拓扑排序排序的节点数组。如果有循环，则返回空数组。

**示例：**

```plaintext
输入：nodes = [2,2,3,-1], relations = [[0,1],[1,2]]
输出：[0,2,3]
解释：
节点 0 和 2 可以形成拓扑排序：0 -> 1 -> 2。
```

```plaintext
输入：nodes = [4,2,1,3], relations = [[3,2],[3,0],[2,0],[2,1]]
输出：[4,2,1,3]
解释：
拓扑排序的结果可能是 [4,2,1,3]，也可能是 [4,1,3,2] 或 [4,3,2,1]。
```

```plaintext
输入：nodes = [1,4,3,2], relations = [[1,4],[1,3],[1,2]]
输出：[]
解释：
不能形成拓扑排序。
```

```plaintext
输入：nodes = [7,1,1,4,4,4,9,9], relations = [[1,4],[1,4],[9,7],[9,4],[9,4],[7,9],[6,7]]
输出：[7,9,6,1,4,4,8,3,2]
解释：
可能的拓扑排序是 [7,9,6,1,4,4,8,3,2] 或者 [7,9,6,1,4,8,4,3,2]，都是有效的。

```

**提示：**

* nodes.length == relations.length
* 1 <= nodes.length <= 10^4
* relations.length == 2 * nodes.length
* 0 <= nodes[i] <= 10^6
* relations[i][0] != relations[i][1]
* relations[i][0] 和 relations[i][1] 都存在于 nodes
* nodes 中不存在重复元素

**答案：**

```python
class Solution:
    def拓扑排序(self, nodes: List[int], relations: List[List[int]]) -> List[int]:
        def dfs(u):
            vis[u] = True
            for v in g[u]:
                if not vis[v]:
                    dfs(v)
            ans.append(u)

        n = len(nodes)
        g = defaultdict(list)
        for a, b in relations:
            g[a].append(b)
            g[b].append(a)
        vis = [False] * n
        ans = []
        for i in range(n):
            if not vis[i]:
                dfs(i)
        return ans[::-1]
```

### 17. 动态规划：最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，找出它们的 最长公共子序列。如果不存在共同的子序列，返回空字符串。

**示例：**

```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"
解释："ace" 是最长公共子序列。
```

```plaintext
输入：text1 = "abc", text2 = "abc"
输出："abc"
解释："abc" 是最长公共子序列。
```

**提示：**

* 1 <= text1.length, text2.length <= 1000
* text1 和 text2 仅由小写英文字母组成

**答案：**

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> str:
        m, n = len(text1), len(text2)
        dp = [[""] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + text1[i - 1]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[-1][-1]
```

### 18. 二分查找：查找旋转排序数组中的元素

**题目：** 给定一个旋转后可能重复的排序数组，请找出数组中的目标元素。

**示例：**

```plaintext
输入：nums = [1,3,5,6,7,0,1], target = 0
输出：4
解释：nums 为 [1,0,1,3,5,6,7] 的旋转，答案为 4。
```

```plaintext
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
解释：数组中不存在 3。
```

```plaintext
输入：nums = [1], target = 0
输出：-1
解释：数组中不存在 0。
```

**提示：**

* 1 <= nums.length <= 5000
* -10^4 <= nums[i] <= 10^4
* nums 是一个旋转过的升序数组
* -10^4 <= target <= 10^4

**答案：**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[left]:
                if target >= nums[left] and target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

### 19. 贪心算法：最小花费爬楼梯

**题目：** 数组 cost 是一条位于 (0, 0) 的楼梯，楼梯的总长度为 10。你需要从楼梯底部开始往上爬楼梯，每次可以爬 1 或 2 个台阶。你可以选择按任意顺序爬到楼梯顶部。

请你计算并返回爬楼梯的最小总花费。

每次移动都要支付 cost[i] 的费用，其中 cost[i] 和楼梯长度 n 都由数组 cost 和 n 给出。

**示例：**

```plaintext
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最优方法是爬 1 个台阶（支付 1）然后爬 3 个台阶（支付 1）接着爬 1 个台阶（支付 1）。
总花费 = 1 + 1 + 1 = 3 + 3 = 6 。无法以少于 6 的总花费爬上楼梯。
```

```plaintext
输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：4
解释：最优方法是爬 1 个台阶（支付 1）然后爬 2 个台阶（支付 1）接着爬 2 个台阶（支付 1）。
总花费 = 1 + 1 + 1 = 3 + 2 = 5 。无法以少于 5 的总花费爬上楼梯。
```

```plaintext
输入：cost = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
输出：0
解释：因为楼梯都是免费的，所以不需要支付任何费用。
```

**提示：**

* cost.length == 10
* 1 <= cost[i] <= 1000

**答案：**

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        a, b = 0, 0
        for v in cost:
            a, b = b, a + v
        return min(a, b)
```

### 20. 贪心算法：合并区间

**题目：** 给你一个区间列表，请合并所有重叠的区间。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，合并为 [1,6]。
```

```plaintext
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可合并为 [1,5]。
```

**提示：**

* 1 <= intervals.length <= 10^4
* intervals[i].length == 2
* 0 <= intervals[i][0] <= intervals[i][1] <= 10^4

**答案：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[0])
        ans = []
        for interval in intervals:
            if not ans or ans[-1][1] < interval[0]:
                ans.append(interval)
            else:
                ans[-1][1] = max(ans[-1][1], interval[1])
        return ans
```

### 21. 回溯算法：组合总和

**题目：** 给定一个无重复元素的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

**示例：**

```plaintext
输入：candidates = [10,1,2,7,6,1,5], target = 8
输出：
[
  [1, 1, 6],
  [1, 2, 5],
  [1, 7],
  [2, 6]
]
```

```plaintext
输入：candidates = [2,3,6,7], target = 7
输出：
[
  [7],
  [2,2,3]
]
```

```plaintext
输入：candidates = [2,3,5], target = 8
输出：[]
```

```plaintext
输入：candidates = [2], target = 1
输出：[]
```

**提示：**

* 1 <= candidates.length <= 30
* 1 <= candidates[i] <= 200
* candidate 中的每个元素是独一无二的。
* 1 <= target <= 500

**答案：**

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def dfs(path, rest, start):
            if rest == 0:
                ans.append(path)
                return
            for i in range(start, len(candidates)):
                if candidates[i] > rest:
                    break
                dfs(path + [candidates[i]], rest - candidates[i], i + 1)

        ans = []
        candidates.sort()
        dfs([], target, 0)
        return ans
```

### 22. 树形动态规划：二叉树的直径

**题目：** 给定一棵二叉树，返回所有节点之间的最长路径长度。这个最长路径可能穿过或者不穿过根节点。

**示例：**

```plaintext
输入：root = [1,2,3,4,5]
输出：3
解释：最长路径是 [4,5,3,1,2] 或者 [5,4,3,1,2]
```

```plaintext
输入：root = [1,2]
输出：2
```

```plaintext
输入：root = []
输出：0
```

**提示：**

* 二叉树的节点数在范围 [0, 10^4] 内
* -10^9 <= Node.val <= 10^9

**答案：**

```python
class Solution:
    def treeDiameter(self, root: Optional[TreeNode]) -> int:
        def dfs(root):
            if root is None:
                return 0
            left, right = dfs(root.left), dfs(root.right)
            nonlocal ans
            ans = max(ans, left + right)
            return max(left, right) + 1

        ans = 0
        dfs(root)
        return ans
```

### 23. 搜索算法：最小生成树

**题目：** 给定一个无向图，找到图的最小生成树，并返回其中边的权重之和。

**示例：**

```plaintext
输入：edges = [[0,1,10],[0,2,1],[1,2,2]], n = 3
输出：6
解释：最小生成树包含边 0-1，权重 10；边 0-2，权重 1；边 1-2，权重 2。总权重为 10 + 1 + 2 = 6。
```

```plaintext
输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1],[2,3,8]], n = 4
输出：14
```

```plaintext
输入：edges = [[0,1,1],[1,2,1],[2,0,1]], n = 3
输出：6
```

```plaintext
输入：edges = [[0,3,6],[1,3,1],[1,2,1],[2,3,4]], n = 4
输出：7
```

**提示：**

* edges.length == n * (n - 1) / 2
* 0 <= i < j <= edges.length
* edges[i][0] != edges[i][1]
* 1 <= n <= 3 * 10^4
* 1 <= edges[i][2] <= 10^6

**答案：**

```python
class Solution:
    def minimumTotalPrice(self, edges: List[List[int]], n: int) -> int:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        def union(x, y):
            root_x, root_y = find(x), find(y)
            if root_x == root_y:
                return
            p[root_x] = root_y
            w[root_y] += w[root_x]

        p = list(range(n))
        w = [0] * n
        edges.sort(key=lambda x: x[2])
        ans = 0
        for u, v, w in edges:
            if find(u) != find(v):
                union(u, v)
                ans += w
        return ans
```

### 24. 并查集：判断图中是否存在环

**题目：** 判断一个无向图是否存在环。

**示例：**

```plaintext
输入：nodes = [2,2,3,-1], relations = [[0,1],[1,2]]
输出：true
解释：节点 0 和节点 1 形成环，因此返回 true。
```

```plaintext
输入：nodes = [1,1,2], relations = [[0,1],[0,2]]
输出：false
解释：节点 0 形成了自环，但是只有节点 0 一个节点，因此不构成环。
```

```plaintext
输入：nodes = [1,2,3], relations = [[0,1],[1,2]]
输出：false
解释：节点 0、节点 1 和节点 2 形成一个三角形，不构成环。
```

```plaintext
输入：nodes = [1,2,3], relations = [[0,1],[1,2],[0,2]]
输出：true
解释：节点 0、节点 1 和节点 2 形成一个三角形，构成环。
```

**提示：**

* nodes.length == relations.length
* 2 <= nodes.length <= 10^5
* relations[i].length == 2
* 1 <= nodes[i] <= 10^9
* relations[i][0] != relations[i][1]
* relations[i][0] 和 relations[i][1] 都存在于 nodes

**答案：**

```python
class Solution:
    def cycleInGraph(self, nodes: List[int], relations: List[List[int]]) -> bool:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        p = list(range(max(nodes) + 1))
        for u, v in relations:
            root_u, root_v = find(u), find(v)
            if root_u == root_v:
                return True
            p[root_u] = root_v
        return False
```

### 25. 搜索算法：拓扑排序

**题目：** 给定一个有向图，请返回其中所有可能的拓扑排序。

**示例：**

```plaintext
输入：nodes = [2,2,3,-1], relations = [[0,1],[1,2]]
输出：[['0', '2', '1'], ['0', '2', '3'], ['0', '3', '2'], ['2', '0', '1'], ['2', '0', '3'], ['3', '0', '2']]
解释：所有可能的拓扑排序如下：
- ['0', '2', '1']
- ['0', '2', '3']
- ['0', '3', '2']
- ['2', '0', '1']
- ['2', '0', '3']
- ['3', '0', '2']
```

```plaintext
输入：nodes = [1,1,2], relations = [[0,1],[0,2]]
输出：[['0', '1', '2'], ['0', '2', '1'], ['1', '0', '2'], ['2', '0', '1']]
解释：所有可能的拓扑排序如下：
- ['0', '1', '2']
- ['0', '2', '1']
- ['1', '0', '2']
- ['2', '0', '1']
```

```plaintext
输入：nodes = [1], relations = []
输出：[['1']]
解释：只有一个节点，因此只有一种拓扑排序：['1']。
```

```plaintext
输入：nodes = [1,2,3], relations = [[0,1],[0,2]]
输出：[['0', '1', '2'], ['0', '2', '1'], ['1', '0', '2'], ['2', '0', '1']]
解释：所有可能的拓扑排序如下：
- ['0', '1', '2']
- ['0', '2', '1']
- ['1', '0', '2']
- ['2', '0', '1']
```

**提示：**

* nodes.length == relations.length
* 1 <= nodes.length <= 10^5
* relations[i].length == 2
* 1 <= nodes[i] <= 10^9
* relations[i][0] != relations[i][1]
* relations[i][0] 和 relations[i][1] 都存在于 nodes

**答案：**

```python
class Solution:
    def拓扑排序(self, nodes: List[int], relations: List[List[int]]) -> List[List[str]]:
        def dfs(u):
            for v in g[u]:
                vis[v] = True
                dfs(v)
            path.append(u)

        def swap(i, j):
            path[i], path[j] = path[j], path[i]
            vis[i], vis[j] = vis[j], vis[i]

        n = len(nodes)
        g = defaultdict(list)
        vis = [False] * n
        for a, b in relations:
            g[a].append(b)
            g[b].append(a)
        ans = []
        for i in range(n):
            if not vis[i]:
                path = []
                dfs(i)
                vis[i] = True
                for j in range(len(path) - 1, -1, -1):
                    ans.append(path[:j + 1])
                for i in range(len(ans) - 1, 0, -1):
                    for j in range(i - 1, -1, -1):
                        if ans[i][0] == ans[j][0]:
                            ans[i], ans[j] = ans[j], ans[i]
                            break
                        elif ans[i][0] == ans[j][1]:
                            swap(i, j)
        return ans
```

### 26. 树形动态规划：二叉树的直径

**题目：** 给定一棵二叉树，返回所有节点之间的最长路径长度。这个最长路径可能穿过或者不穿过根节点。

**示例：**

```plaintext
输入：root = [1,2,3,4,5]
输出：3
解释：最长路径是 [4,5,3,1,2] 或者 [5,4,3,1,2]。
```

```plaintext
输入：root = [1,2]
输出：2
```

```plaintext
输入：root = []
输出：0
```

**提示：**

* 二叉树的节点数在范围 [0, 10^4] 内
* -10^9 <= Node.val <= 10^9

**答案：**

```python
class Solution:
    def treeDiameter(self, root: Optional[TreeNode]) -> int:
        def dfs(root):
            if root is None:
                return 0
            left, right = dfs(root.left), dfs(root.right)
            nonlocal ans
            ans = max(ans, left + right)
            return max(left, right) + 1

        ans = 0
        dfs(root)
        return ans
```

### 27. 线段树：合并区间

**题目：** 给定一个无重复元素的整数数组 intervals ，其中 intervals[i] = [starti, endi] 表示第 i 个区间。你需要合并所有有重叠的区间，并返回一个结果数组，结果数组中的区间必须按它们的起始点按升序排列。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，合并为 [1,6]。
```

```plaintext
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可以合并为 [1,5]。
```

```plaintext
输入：intervals = [[1,4],[2,3]]
输出：[[1,4],[2,3]]
```

```plaintext
输入：intervals = [[1,4],[2,2]]
输出：[[1,4],[2,2]]
```

```plaintext
输入：intervals = [[1,3],[7,9]]
输出：[[1,3],[7,9]]
```

```plaintext
输入：intervals = [[1,1],[1,1],[1,1]]
输出：[[1,1]]
```

```plaintext
输入：intervals = [[1,1]]
输出：[[1,1]]
```

**提示：**

* 1 <= intervals.length <= 10^4
* intervals[i].length == 2
* 0 <= starti <= endi <= 10^4
* intervals 中的所有区间都是唯一的。

**答案：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        s = sorted(intervals, key=lambda x: x[0])
        ans = []
        for x in s:
            if not ans or ans[-1][1] < x[0]:
                ans.append(x)
            else:
                ans[-1][1] = max(ans[-1][1], x[1])
        return ans
```

### 28. 数学算法：最大子序列和

**题目：** 给定一个整数数组 nums ，找出其中最长连续递增序列的长度。

**示例：**

```plaintext
输入：nums = [1,2,3,2,5]
输出：3
解释：最长连续递增序列是 [2,3,5],它的长度为 3。
```

```plaintext
输入：nums = [2,-1,2]
输出：3
解释：最长连续递增序列是 [-1,2,2],它的长度为 3。
```

```plaintext
输入：nums = [1]
输出：1
解释：最长连续递增序列是 [1]，它的长度为 1。
```

```plaintext
输入：nums = [1,2,2,3,4,3]
输出：4
解释：最长连续递增序列是 [1,2,3,4]，它的长度为 4。
```

**提示：**

* 1 <= nums.length <= 10^5
* -10^9 <= nums[i] <= 10^9

**答案：**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        d = []
        for x in nums:
            l = bisect_left(d, x)
            if l == len(d):
                d.append(x)
            else:
                d[l] = x
        return len(d)
```

### 29. 排序算法：快速排序

**题目：** 给定一个整数数组 nums，找出其中最长连续递增序列的长度。

**示例：**

```plaintext
输入：nums = [1,2,3,2,5]
输出：3
解释：最长连续递增序列是 [2,3,5],它的长度为 3。
```

```plaintext
输入：nums = [2,-1,2]
输出：3
解释：最长连续递增序列是 [-1,2,2],它的长度为 3。
```

```plaintext
输入：nums = [1]
输出：1
解释：最长连续递增序列是 [1]，它的长度为 1。
```

```plaintext
输入：nums = [1,2,2,3,4,3]
输出：4
解释：最长连续递增序列是 [1,2,3,4]，它的长度为 4。
```

**提示：**

* 1 <= nums.length <= 10^5
* -10^9 <= nums[i] <= 10^9

**答案：**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def quicksort(arr, l, r):
            if l >= r:
                return
            pivot = arr[r]
            i = l
            for j in range(l, r):
                if arr[j] < pivot:
                    arr[i], arr[j] = arr[j], arr[i]
                    i += 1
            arr[i], arr[r] = arr[r], arr[i]
            quicksort(arr, l, i - 1)
            quicksort(arr, i + 1, r)

        quicksort(nums, 0, len(nums) - 1)
        ans = 1
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                ans += 1
        return ans
```

### 30. 双指针：有效的字母异位词

**题目：** 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

**示例：**

```plaintext
输入：s = "anagram", t = "nagaram"
输出：true
解释：s 的字母异位词是 "nagaram"，返回 true。
```

```plaintext
输入：s = "rat", t = "car"
输出：false
解释：s 的字母异位词不包含 "car"，返回 false。
```

**提示：**

* 1 <= s.length, t.length <= 5 * 10^4
* s 和 t 仅包含小写字母

**答案：**

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
```

