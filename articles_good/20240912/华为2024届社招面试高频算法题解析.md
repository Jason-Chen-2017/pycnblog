                 

### 华为2024届社招面试高频算法题解析

#### 1. 单词拆分

**题目描述：**  
给定一个非空字符串 `s` 和一个包含 `s` 中部分单词的单词列表 `wordDict`，返回 `s` 能被 `wordDict` 拆分的所有可能性的数量。返回值需要是一个整数，表示所有可能性的总数。

**示例：**  
输入：  
`s = "applepenapple"`  
`wordDict = ["apple", "pen"]`  
输出：  
`3`  
解释：`s` 可以按照以下三种方式拆分：  
- `applepenapple`  
- `applerapplepenapple`  
- `applesplitapplepenapple`  

**解题思路：**  
使用动态规划，定义 `dp[i]` 表示 `s[0..i-1]` 拆分的方法数量。遍历字符串 `s`，对于每个位置 `i`，遍历 `wordDict`，如果 `s[j+1..i]` 在 `wordDict` 中，则 `dp[i]` 可以加上 `dp[j]`。

**代码实现：**

```go
func wordBreak(s string, wordDict []string) int {
    dp := make([]int, len(s)+1)
    dp[0] = 1
    wordSet := make(map[string]bool)
    for _, w := range wordDict {
        wordSet[w] = true
    }

    for i := 1; i <= len(s); i++ {
        for j := 0; j < i; j++ {
            if wordSet[s[j:i]] {
                dp[i] += dp[j]
            }
        }
    }
    return dp[len(s)]
}
```

**解析：**  
在这个例子中，我们首先创建一个动态规划数组 `dp`，初始化 `dp[0]` 为 1，因为空字符串有一种拆分方法。然后，我们遍历字符串 `s`，对于每个位置 `i`，我们再遍历 `s[0..i-1]` 的每个位置 `j`，如果 `s[j+1..i]` 在 `wordDict` 中，则将 `dp[j]` 加到 `dp[i]` 上。最终，`dp[len(s)]` 即为所有拆分方法的总数。

#### 2. 电话号码的字母组合

**题目描述：**  
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。返回的答案需要按字典顺序排列。

**示例：**  
输入：  
`digits = "23"`  
输出：  
`["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]`  

**解题思路：**  
使用深度优先搜索（DFS）和回溯算法，递归构建所有可能的字母组合。每次递归调用时，根据当前数字对应的字母，将字母添加到结果中，并继续递归调用下一个数字。

**代码实现：**

```go
func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }
    var letters = []string{
        "",   // 0
        "",   // 1
        "abc",// 2
        "def",// 3
        "ghi",// 4
        "jkl",// 5
        "mno",// 6
        "pqrs",// 7
        "tuv",// 8
        "wxyz",// 9
    }
    var ans []string
    dfs(digits, 0, "", &ans, &letters)
    return ans
}

func dfs(digits string, index int, curr string, ans *[]string, letters *[]string) {
    if index == len(digits) {
        *ans = append(*ans, curr)
        return
    }
    for _, l := range (*letters)[digits[index]-'0'] {
        dfs(digits, index+1, curr+l, ans, letters)
    }
}
```

**解析：**  
在这个例子中，我们首先创建一个字符串数组 `letters`，用于表示每个数字对应的字母。然后，我们定义一个递归函数 `dfs`，递归地构建所有可能的字母组合。每次递归调用时，我们将当前数字对应的字母添加到结果中，并继续递归调用下一个数字。最终，我们将所有结果添加到 `ans` 数组中并返回。

#### 3. 最长公共前缀

**题目描述：**  
编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**  
输入：  
`["flower","flow","flight"]`  
输出：  
`"fl"`  

**解题思路：**  
可以使用垂直扫描的方法，比较字符串数组中每个字符的位置，找到所有字符串中相同位置上的字符，组成最长公共前缀。

**代码实现：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, c := 0, strs[0][0]; i < len(strs[0]); i, c = i+1, c>>1 {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

**解析：**  
在这个例子中，我们首先检查输入字符串数组是否为空，如果为空，则返回空字符串。然后，我们使用一个循环遍历字符串数组中每个字符的位置，对于每个位置，我们再使用一个循环比较所有字符串中相同位置上的字符。如果找到一个位置上的字符不相等，则返回当前相同字符组成的字符串。如果所有位置上的字符都相等，则返回整个字符串。

#### 4. 两数相加

**题目描述：**  
给你两个 非空 的链表来表示两个非负的整数。数字最高位位于链表的开始位置。它们可以含有多个 0 前导位。请你将这两个数相加，可以用链表形式返回结果。

**示例：**  
输入：  
`l1 = [7,2,4,3]`  
`l2 = [5,6,4]`  
输出：  
`[7,8,0,7]`  

**解题思路：**  
使用链表模拟加法运算，从最低位开始逐位相加，如果相加结果大于等于10，则进位。遍历两个链表的所有位，直到至少一个链表到达链尾。

**代码实现：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{Val: 0}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        val2 := 0

        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        curr.Next = &ListNode{Val: (val1 + val2 + carry) % 10}
        carry = (val1 + val2 + carry) / 10
        curr = curr.Next
    }

    return dummy.Next
}
```

**解析：**  
在这个例子中，我们首先创建一个哑节点 `dummy`，用于简化边界条件处理。然后，我们使用一个循环遍历两个链表的所有位，对于每个位，我们计算两个链表当前位上的值之和，加上上一位的进位 `carry`，得到当前位的值和新的进位 `carry`。我们使用一个指针 `curr` 指向当前位的链表节点，将其添加到结果链表中。最终，我们返回哑节点的下一个节点，即结果链表的头节点。

#### 5. 字符串转换整数 (atoi)

**题目描述：**  
实现一个函数，将一个字符串转换成一个整数。该整数应小于或等于 `INT_MAX` 且大于或等于 `INT_MIN`。

**示例：**  
输入：  
`"42"`  
输出：  
`42`  

**解题思路：**  
使用状态机模拟字符串到整数的转换过程。定义状态机有以下几个状态：

1. 初始化（Init）：读取字符串的第一个字符。
2. 跳过前导空格（Space）。
3. 标记符号（Sign）：读取正负号。
4. 读取数字（Num）：读取数字字符，并将数字累加到结果中。
5. 遇到非数字字符，结束转换（Done）。

在每个状态中，根据输入的字符进行状态转移，并更新结果。

**代码实现：**

```go
func myAtoi(s string) int {
    const (
        Init     = iota
        Space
        Sign
        Num
        Done
    )

    state := map[string]int{
        "Init":      Init,
        "Space":     Space,
        "Sign":      Sign,
        "Num":       Num,
        "Done":      Done,
    }

    sign, num, i := 1, 0, 0
    state := Init

    for _, c := range s {
        switch state {
        case Init:
            if c == ' ' {
                state = Space
            } else if c == '+' {
                state = Sign
                sign = 1
            } else if c == '-' {
                state = Sign
                sign = -1
            } else if c >= '0' && c <= '9' {
                state = Num
                num = int(c - '0')
            } else {
                state = Done
            }
        case Space:
            if c == ' ' {
                // Keep space state
            } else if c == '+' {
                state = Sign
                sign = 1
            } else if c == '-' {
                state = Sign
                sign = -1
            } else if c >= '0' && c <= '9' {
                state = Num
                num = int(c - '0')
            } else {
                state = Done
            }
        case Sign:
            if c >= '0' && c <= '9' {
                state = Num
                num = int(c - '0') * sign
            } else {
                state = Done
            }
        case Num:
            if c >= '0' && c <= '9' {
                num = num*10 + int(c-'0')
                if num < 0 {
                    return int^uint((uint)^(-1) << 31)
                }
            } else {
                state = Done
            }
        case Done:
            return num * sign
        }
    }

    return num * sign
}
```

**解析：**  
在这个例子中，我们首先定义了一个状态机，用于模拟字符串到整数的转换过程。状态机有初始化（Init）、跳过前导空格（Space）、标记符号（Sign）、读取数字（Num）和结束（Done）五个状态。在每个状态中，根据输入的字符进行状态转移，并更新结果。如果遇到非数字字符，则结束转换，返回当前结果。

#### 6. 设计推特

**题目描述：**  
设计一个简化版的推特(Twitter)接口，其中一个用户可以关注其他用户、发布微博、将自己发布微博推给他们的关注者以及好友关注者的微博。

**示例：**  
用户 `jane` 关注 `john`，`john` 发布一条微博。现在，`jane` 的推文中应包含 `john` 的微博。

**解题思路：**  
可以使用哈希表存储用户的关注列表和微博列表。对于每个用户，使用一个哈希表存储其关注的用户和发布的微博。同时，使用一个哈希表存储所有用户的微博列表。

**代码实现：**

```go
type Twitter struct {
    tweets  map[int][]int
    users   map[int]map[int]bool
    time    int
}

func Constructor() Twitter {
    return Twitter{
        tweets:  make(map[int][]int),
        users:   make(map[int]map[int]bool),
        time:    0,
    }
}

func (this *Twitter) postTweet(userId int, tweetId int)  {
    this.tweets[userId] = append(this.tweets[userId], this.time)
    this.time++
}

func (this *Twitter) getNewsFeed(userId int) []int {
    followees := make([]int, 0)
    if this.users[userId] != nil {
        for id := range this.users[userId] {
            followees = append(followees, id)
        }
    }

    followees = append(followees, userId)

    maxHeap := &priorityQueue{}
    for _, id := range followees {
        for i := len(this.tweets[id]) - 1; i >= 0; i-- {
            tweetId := this.tweets[id][i]
            maxHeap.offer(-tweetId)
            if maxHeap.Len() > 10 {
                maxHeap.poll()
            }
        }
    }

    res := make([]int, maxHeap.Len())
    for i := maxHeap.Len() - 1; i >= 0; i-- {
        res[i] = -maxHeap.poll()
    }

    return res
}

func (this *Twitter) follow(followerId int, followeeId int)  {
    if this.users[followerId] == nil {
        this.users[followerId] = make(map[int]bool)
    }
    this.users[followerId][followeeId] = true
}

func (this *Twitter) unfollow(followerId int, followeeId int)  {
    if this.users[followerId] != nil {
        delete(this.users[followerId], followeeId)
    }
}
```

**解析：**  
在这个例子中，我们定义了一个 `Twitter` 结构，包含三个字段：`tweets` 用于存储每个用户的微博列表，`users` 用于存储每个用户的关注列表，`time` 用于记录微博的发布时间。`Constructor` 函数用于初始化 `Twitter` 结构。`postTweet` 函数用于发布微博，`getNewsFeed` 函数用于获取用户的推送微博，`follow` 函数用于关注其他用户，`unfollow` 函数用于取消关注其他用户。

#### 7. 最小栈

**题目描述：**  
设计一个支持 push 、pop 、top 操作的栈，同时能获取该栈的最小元素。

**示例：**  
最小栈 `[]` 推入 `1`，栈顶元素为 `1`，最小元素为 `1`。  
推入 `2`，栈顶元素为 `2`，最小元素为 `1`。  
弹出栈顶元素，栈顶元素为 `1`，最小元素为 `1`。  

**解题思路：**  
使用两个栈，一个栈 `st` 用于存储栈元素，另一个栈 `min` 用于存储栈的最小元素。

**代码实现：**

```go
type MinStack struct {
    st  []int
    min []int
}

func Constructor() MinStack {
    return MinStack{
        st:  make([]int, 0),
        min: make([]int, 0),
    }
}

func (this *MinStack) Push(x int)  {
    this.st = append(this.st, x)
    if len(this.min) == 0 || x <= this.min[len(this.min)-1] {
        this.min = append(this.min, x)
    }
}

func (this *MinStack) Pop()  {
    if this.st[len(this.st)-1] == this.min[len(this.min)-1] {
        this.min = this.min[:len(this.min)-1]
    }
    this.st = this.st[:len(this.st)-1]
}

func (this *MinStack) Top() int {
    return this.st[len(this.st)-1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min)-1]
}
```

**解析：**  
在这个例子中，我们定义了一个 `MinStack` 结构，包含两个字段：`st` 用于存储栈元素，`min` 用于存储栈的最小元素。`Constructor` 函数用于初始化 `MinStack` 结构。`Push` 函数用于将元素推入栈，如果新元素的值小于或等于当前最小元素，则将新元素推入 `min` 栈。`Pop` 函数用于弹出栈顶元素，如果弹出的元素是当前最小元素，则同时弹出 `min` 栈的元素。`Top` 函数用于获取栈顶元素。`GetMin` 函数用于获取当前最小元素。

#### 8. 有效的括号

**题目描述：**  
给定一个只包括 `'('` ，`')'` ，`'{'` ，`'}'` ，`'['` 和 `']'` 的字符串，判断是否有效。

**示例：**  
输入：`"()"`  
输出：`true`

输入：`"()[]{}"`  
输出：`true`

输入：`"(]"`  
输出：`false`

**解题思路：**  
使用栈模拟括号匹配过程。遍历字符串，对于每个括号：

- 如果是左括号，将其入栈。
- 如果是右括号，检查栈顶元素是否与其匹配，如果不匹配，返回 `false`。
- 如果匹配，将栈顶元素弹出。

遍历完成后，如果栈为空，则字符串有效，否则无效。

**代码实现：**

```go
func isValid(s string) bool {
    stack := make([]rune, 0)
    pairs := map[rune]rune{'(': ')', '{': '}', '[': ']'}

    for _, c := range s {
        if _, ok := pairs[c]; ok {
            stack = append(stack, c)
        } else if len(stack) == 0 || pairs[stack[len(stack)-1]] != c {
            return false
        } else {
            stack = stack[:len(stack)-1]
        }
    }

    return len(stack) == 0
}
```

**解析：**  
在这个例子中，我们首先定义了一个栈 `stack` 和一个映射 `pairs`，用于存储括号的配对关系。然后，遍历字符串 `s`，对于每个字符：

- 如果是左括号，将其入栈。
- 如果是右括号，检查栈顶元素是否与其匹配，如果不匹配，返回 `false`。
- 如果匹配，将栈顶元素弹出。

遍历完成后，如果栈为空，则字符串有效，否则无效。

#### 9. 最长公共子序列

**题目描述：**  
给定两个字符串 `text1` 和 `text2`，找到并返回它们的 **最长公共子序列**。如果不存在共同的子序列，返回空字符串。

**示例：**  
输入：  
`text1 = "abcde"`  
`text2 = "ace"`  
输出：  
`"ace"`

**解题思路：**  
使用动态规划求解最长公共子序列。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。

状态转移方程：

- 如果 `text1[i-1] == text2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
- 如果 `text1[i-1] != text2[j-1]`，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

最后，`dp[m][n]` 即为最长公共子序列的长度。

**代码实现：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    result := make([]byte, 0, dp[m][n])
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            result = append(result, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }

    reverse(result)
    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func reverse(s []byte) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

**解析：**  
在这个例子中，我们首先定义一个二维数组 `dp`，初始化为 0。然后，遍历 `text1` 和 `text2` 的每个字符，更新 `dp` 数组。最后，根据 `dp` 数组构建最长公共子序列。

#### 10. 合并两个有序链表

**题目描述：**  
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
输入：  
`l1 = [1,2,4]`  
`l2 = [1,3,4]`  
输出：  
`[1,1,2,3,4,4]`

**解题思路：**  
使用递归或迭代方法，比较两个链表的头节点，选择较小的节点作为新链表的当前节点，然后递归或迭代处理剩余的链表。

**代码实现（递归）：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**代码实现（迭代）：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p, q := l1, l2

    for p != nil && q != nil {
        if p.Val < q.Val {
            curr.Next = p
            p = p.Next
        } else {
            curr.Next = q
            q = q.Next
        }
        curr = curr.Next
    }

    if p != nil {
        curr.Next = p
    } else if q != nil {
        curr.Next = q
    }

    return dummy.Next
}
```

**解析：**  
在这两个例子中，我们首先定义了一个 `ListNode` 结构，表示链表节点。递归方法通过比较两个链表的头节点，选择较小的节点作为新链表的当前节点，然后递归处理剩余的链表。迭代方法使用两个指针 `p` 和 `q` 分别遍历两个链表，选择较小的节点作为新链表的当前节点，直到处理完一个链表。最后，将未处理完的链表连接到新链表的尾部。

#### 11. 有效的山脉数组

**题目描述：**  
给定一个整数数组 `arr` ，如果它是有效的山脉数组就返回 `true`，否则返回 `false`。

山脉数组是指一个整数数组，除了恰好一个元素之外，其余元素都位于这个元素两侧，这个元素比周围的所有其他元素都要高。

**示例：**  
输入：`arr = [2,1]`  
输出：`false`

输入：`arr = [3,5,5]`  
输出：`true`

**解题思路：**  
可以使用线性扫描的方法。首先找到山脉数组的最高点，然后确保最高点两侧都是递增的。

**代码实现：**

```go
func validMountainArray(arr []int) bool {
    n := len(arr)
    if n < 3 {
        return false
    }
    i := 0
    // 搜索山脉的最高点
    for i < n-1 && arr[i] < arr[i+1] {
        i++
    }
    // 最高点的两边都要下降
    if i == 0 || i == n-1 {
        return false
    }
    // 下降段
    for i < n-1 && arr[i] > arr[i+1] {
        i++
    }
    return i == n-1
}
```

**解析：**  
在这个例子中，我们首先检查数组的长度，如果小于 3，则不可能形成山脉数组。然后，我们使用一个指针 `i` 搜索山脉的最高点。找到最高点后，我们需要确保最高点两侧都是下降的。如果最高点在数组的开头或结尾，则不可能形成山脉数组。最后，如果指针到达数组的最后一个元素，则说明山脉数组有效。

#### 12. 链表中的中间结点

**题目描述：**  
给定一个单链表，找出链表中间的结点。如果有两个中间结点，则返回第二个中间结点。

**示例：**  
输入：`[1,2,3,4,5]`  
输出：`3`

**解题思路：**  
可以使用快慢指针的方法。慢指针每次走一步，快指针每次走两步。当快指针到达链表末尾时，慢指针恰好到达中间结点。

**代码实现：**

```go
func middleNode(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```

**解析：**  
在这个例子中，我们定义了两个指针 `slow` 和 `fast`，它们都初始化为链表的头节点 `head`。然后，我们使用一个循环，每次快指针走两步，慢指针走一步。当快指针到达链表末尾时，慢指针恰好到达中间结点。

#### 13. 二进制求和

**题目描述：**  
给你两个二进制字符串 `a` 和 `b` ，返回它们的和（用二进制表示）。

**示例：**  
输入：`a = "11"`，`b = "1"`  
输出：`"100"`  

**解题思路：**  
可以使用字符串反转和模拟加法的方法。首先，将两个二进制字符串反转，然后从最低位开始逐位相加，如果相加结果大于等于 2，则进位。

**代码实现：**

```go
func addBinary(a string, b string) string {
    la, lb := len(a), len(b)
    if la > lb {
        b = strings.Repeat("0", la-lb) + b
    } else if lb > la {
        a = strings.Repeat("0", lb-la) + a
    }
    reva, revb := reverse(a), reverse(b)
    carry, ans := 0, ""
    for i := 0; i < len(reva) || carry != 0; i++ {
        sum := int(reva[i]-'0') + int(revb[i]-'0') + carry
        ans += strconv.Itoa(sum % 2)
        carry = sum / 2
    }
    return reverse(ans)
}

func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}
```

**解析：**  
在这个例子中，我们首先将两个二进制字符串反转，然后从最低位开始逐位相加。如果相加结果大于等于 2，则进位。最后，将结果反转并返回。

#### 14. 搜索旋转排序数组

**题目描述：**  
整数数组 `nums` 按升序排列，要找到数组中的某个 `target` ，在数组中搜索 `target` ，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1`。

数组中可能包含重复的元素。

当数组被搜索多次时，这个解决方案需要尽可能快地搜索到目标值。

**示例：**  
输入：`nums = [4,5,6,7,0,1,2]`，`target = 0`  
输出：`4`

**解题思路：**  
可以使用二分查找的方法。对于旋转排序数组，我们首先找到中间元素，然后根据中间元素和目标值的关系，确定下一次搜索的范围。如果中间元素大于数组的第一个元素，说明左半部分是升序排列的，我们可以搜索左半部分。否则，我们搜索右半部分。

**代码实现：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] >= nums[left] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：**  
在这个例子中，我们定义了两个指针 `left` 和 `right`，初始化为数组的第一个和最后一个元素。然后，我们使用一个循环，根据中间元素和目标值的关系，更新 `left` 和 `right` 的值。当 `left` 等于 `right` 时，如果中间元素不等于目标值，说明数组中不存在目标值，返回 `-1`。

#### 15. 设计一个支持最近最少使用（LRU）缓存的数据结构

**题目描述：**  
设计并实现一个数据结构，支持最近最少使用（LRU）缓存，它应该支持以下操作：`get(key)` 和 `put(key, value)`。

- `get(key)` - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 `-1`。
- `put(key, value)` - 如果关键字已经存在，则更改其值；否则，添加该值。

当缓存达到容量时，它应该用最新插入的键值对替换最旧的键值对。

**示例：**  
输入：  
操作  操作值  
["LRUCache", "put", "get", "put", "get", "put", "get", "get"]  
[[2], [1, 1], [1], [2, 2], [2], [3, 3], [2], [4, 4]]  
输出：  
[null, null, 1, null, -1, null, -1, 4]

**解题思路：**  
可以使用哈希表和双向链表来实现 LRU 缓存。哈希表用于快速查找缓存中的键值对，双向链表用于维护键值对的插入顺序。

**代码实现：**

```go
type Node struct {
    key   int
    value int
    prev  *Node
    next  *Node
}

type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head     *Node
    tail     *Node
}

func Constructor(capacity int) LRUCache {
    cache := make(map[int]*Node)
    head := &Node{}
    tail := &Node{}
    head.next = tail
    tail.prev = head
    return LRUCache{
        capacity: capacity,
        cache:    cache,
        head:     head,
        tail:     tail,
    }
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
    } else {
        newNode := &Node{key: key, value: value}
        this.cache[key] = newNode
        this.insertToHead(newNode)
        if len(this.cache) > this.capacity {
            this.removeFromTail()
        }
    }
}

func (this *LRUCache) moveToHead(node *Node) {
    this.removeFromNode(node)
    this.insertToHead(node)
}

func (this *LRUCache) removeFromNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) insertToHead(node *Node) {
    node.next = this.head.next
    node.prev = this.head
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeFromTail() {
    node := this.tail.prev
    this.cache[node.key] = nil
    node.prev.next = this.tail
    this.tail.prev = node
}
```

**解析：**  
在这个例子中，我们定义了一个 `Node` 结构，表示缓存中的键值对。`LRUCache` 结构包含容量 `capacity`、哈希表 `cache`、头节点 `head` 和尾节点 `tail`。`Constructor` 函数用于初始化 `LRUCache` 结构。`Get` 函数用于获取键的值，如果键存在，将其移动到头部。`Put` 函数用于添加或更新键值对，如果缓存已满，删除最旧的键值对。

#### 16. 最小路径和

**题目描述：**  
给定一个包含非负整数的二维数组 `grid` ，找出这个数组中的最小路径和。

说明：你可以只使用 `R`（向右）和 `U`（向上）来修改输入数组。

**示例：**  
输入：  
grid = [[1,3,1],[1,5,1],[4,2,1]]  
输出：  
7  
解释：因为路径 `1→3→1→1→1` 的总和最小。

**解题思路：**  
可以使用动态规划的方法。从右下角开始，反向更新每个节点的最小路径和，直到左上角。每个节点的最小路径和等于当前位置的值加上右边或下面的最小路径和中的较小值。

**代码实现：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            if i == m-1 && j == n-1 {
                continue
            }
            if i < m-1 {
                grid[i][j] += min(grid[i+1][j], grid[i][j])
            }
            if j < n-1 {
                grid[i][j] += min(grid[i][j], grid[i][j+1])
            }
        }
    }
    return grid[0][0]
}
```

**解析：**  
在这个例子中，我们定义了一个二维数组 `grid`，表示给定的网格。然后，我们使用两个嵌套的循环，从右下角开始，反向更新每个节点的最小路径和。每个节点的最小路径和等于当前位置的值加上右边或下面的最小路径和中的较小值。最终，返回左上角节点的值，即最小路径和。

#### 17. 合并两个有序链表

**题目描述：**  
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
输入：  
`l1 = [1,2,4]`  
`l2 = [1,3,4]`  
输出：  
`[1,1,2,3,4,4]`

**解题思路：**  
可以使用递归或迭代方法。递归方法通过比较两个链表的头节点，选择较小的节点作为新链表的当前节点，然后递归处理剩余的链表。迭代方法使用两个指针分别遍历两个链表，选择较小的节点作为新链表的当前节点。

**代码实现（递归）：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**代码实现（迭代）：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p, q := l1, l2

    for p != nil && q != nil {
        if p.Val < q.Val {
            curr.Next = p
            p = p.Next
        } else {
            curr.Next = q
            q = q.Next
        }
        curr = curr.Next
    }

    if p != nil {
        curr.Next = p
    } else if q != nil {
        curr.Next = q
    }

    return dummy.Next
}
```

**解析：**  
在这两个例子中，我们首先定义了一个 `ListNode` 结构，表示链表节点。递归方法通过比较两个链表的头节点，选择较小的节点作为新链表的当前节点，然后递归处理剩余的链表。迭代方法使用两个指针 `p` 和 `q` 分别遍历两个链表，选择较小的节点作为新链表的当前节点，直到处理完一个链表。最后，将未处理完的链表连接到新链表的尾部。

#### 18. 搜索旋转排序数组 II

**题目描述：**  
给定一个可能包含重复元素的整数数组 `nums`，请编写一个函数来判断给定的目标值 `target` 是否在数组中。如果 `nums` 的元素可以重复，可以将 `target` 视为在数组中的第一个位置或者最后一个位置。

**示例：**  
输入：  
`nums = [2,5,6,0,0,1,2]`，`target = 0`  
输出：  
`true`

**解题思路：**  
可以使用二分查找的方法。对于旋转排序数组，我们首先找到中间元素，然后根据中间元素和目标值的关系，确定下一次搜索的范围。如果中间元素大于数组的第一个元素，说明左半部分是升序排列的，我们可以搜索左半部分。否则，我们搜索右半部分。

**代码实现：**

```go
func search(nums []int, target int) bool {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return true
        }
        if nums[mid] > nums[left] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else if nums[mid] < nums[right] {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        } else {
            right--
        }
    }
    return false
}
```

**解析：**  
在这个例子中，我们定义了两个指针 `left` 和 `right`，初始化为数组的第一个和最后一个元素。然后，我们使用一个循环，根据中间元素和目标值的关系，更新 `left` 和 `right` 的值。当 `left` 等于 `right` 时，如果中间元素不等于目标值，说明数组中不存在目标值，返回 `false`。

#### 19. 设计哈希映射

**题目描述：**  
不使用任何内建哈希表库设计一个哈希映射（HashMap）。实现 `MyHashMap` 类：

- `MyHashMap()` 使用一个空映射初始化对象
- `int put(int key, int value)`：向映射中插入一个键值对 (key, value)。如果键已存在，则更新其对应的值
- `int get(int key)`：返回特定的键 key 的值。如果键不存在，返回 -1
- `void remove(key)`：如果映射中存在这个键 key，然后删除它

**示例：**  
输入：  
操作  操作值  
["MyHashMap", "put", "put", "put", "get", "get", "put", "get", "remove", "get"]  
[[], [1, 1], [2, 2], [2, 3], [1], [3], [2, 2], [2], [2], [2]]  
输出：  
[null, null, null, null, 1, -1, null, 2, true, -1]

**解题思路：**  
可以使用拉链法解决哈希冲突。定义一个数组 `buckets` 存储链表的头节点，每个链表节点包含键值对。对于每个键值对，使用哈希函数计算其索引，将节点插入到对应的链表中。

**代码实现：**

```go
type Node struct {
    key   int
    value int
    next  *Node
}

type MyHashMap struct {
    buckets []*Node
    size    int
}

func Constructor() MyHashMap {
    return MyHashMap{
        buckets: make([]*Node, 1000),
        size:    0,
    }
}

func (this *MyHashMap) hash(key int) int {
    return key % 1000
}

func (this *MyHashMap) put(key int, value int) {
    idx := this.hash(key)
    node := this.buckets[idx]
    for node != nil {
        if node.key == key {
            node.value = value
            return
        }
        node = node.next
    }
    newNode := &Node{key: key, value: value}
    newNode.next = this.buckets[idx]
    this.buckets[idx] = newNode
    this.size++
}

func (this *MyHashMap) get(key int) int {
    idx := this.hash(key)
    node := this.buckets[idx]
    for node != nil {
        if node.key == key {
            return node.value
        }
        node = node.next
    }
    return -1
}

func (this *MyHashMap) remove(key int) {
    idx := this.hash(key)
    node := this.buckets[idx]
    prev := nil
    for node != nil {
        if node.key == key {
            if prev != nil {
                prev.next = node.next
            } else {
                this.buckets[idx] = node.next
            }
            this.size--
            return
        }
        prev = node
        node = node.next
    }
}
```

**解析：**  
在这个例子中，我们定义了一个 `Node` 结构，表示链表节点。`MyHashMap` 结构包含数组 `buckets` 存储链表的头节点，`size` 表示当前哈希表中键值对的数量。`Constructor` 函数用于初始化 `MyHashMap` 结构。`put` 函数用于插入键值对，如果键已存在，则更新其对应的值。`get` 函数用于获取键的值。`remove` 函数用于删除键值对。

#### 20. 三数之和

**题目描述：**  
给定一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**示例：**  
输入：  
`nums = [-1, 0, 1, 2, -1, -4]`  
输出：  
`[[-1, 0, 1], [-1, -1, 2]]`

**解题思路：**  
可以使用排序和双指针的方法。首先，对数组进行排序。然后，遍历数组中的每个元素，对于每个元素，使用双指针方法找到另外两个元素，使得这三个元素之和为 0。

**代码实现：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var triples [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}
```

**解析：**  
在这个例子中，我们首先对数组 `nums` 进行排序。然后，使用两个指针 `left` 和 `right` 分别指向 `nums[i]` 的下一个元素和最后一个元素。遍历数组中的每个元素，对于每个元素，使用双指针方法找到另外两个元素，使得这三个元素之和为 0。为了避免重复的三元组，我们在循环中跳过相同的元素。

#### 21. 盛最多水的容器

**题目描述：**  
给定一个二维矩阵 `matrix`，包含 `m x n` 的整数，每行和每列按升序对齐。设计一个算法，使其能够找到矩阵中的最大元素和最小元素，时间复杂度为 O(1)。

**示例：**  
输入：  
`matrix = [[1,2,3],[4,5,6],[7,8,9]]`  
输出：  
最大元素：9  
最小元素：1

**解题思路：**  
由于矩阵按行和列排序，我们可以使用边界值来快速找到最大和最小元素。最大元素位于最后一行或最后一列的最后一个元素，最小元素位于第一行或第一列的第一个元素。

**代码实现：**

```go
func findMinMax(matrix [][]int) (int, int) {
    maxVal, minVal := math.MinInt64, math.MaxInt64
    m, n := len(matrix), len(matrix[0])

    // Find max and min in last row
    for j := 0; j < n; j++ {
        maxVal = max(maxVal, matrix[m-1][j])
        minVal = min(minVal, matrix[m-1][j])
    }

    // Find max and min in last column
    for i := 0; i < m; i++ {
        maxVal = max(maxVal, matrix[i][n-1])
        minVal = min(minVal, matrix[i][n-1])
    }

    // Find max and min in first row
    for j := 0; j < n; j++ {
        maxVal = max(maxVal, matrix[0][j])
        minVal = min(minVal, matrix[0][j])
    }

    // Find max and min in first column
    for i := 0; i < m; i++ {
        maxVal = max(maxVal, matrix[i][0])
        minVal = min(minVal, matrix[i][0])
    }

    return maxVal, minVal
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：**  
在这个例子中，我们定义了两个辅助函数 `max` 和 `min`，用于计算最大和最小值。然后，我们遍历矩阵的最后一行、最后一列、第一行和第一列，更新 `maxVal` 和 `minVal`。最终，返回 `maxVal` 和 `minVal`。

#### 22. 三数之和的多种方法

**题目描述：**  
给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中三个数之和等于 `target` 的所有三整数组合。不考虑重复组合。

**示例：**  
输入：  
`nums = [-1, 0, 1, 2, -1, -4]`，`target = 0`  
输出：  
`[[-1, 0, 1], [-1, -1, 2]]`

**解题思路：**  
有多种方法可以解决三数之和问题，包括排序 + 双指针、哈希表、排序 + 哈希表等。

- **排序 + 双指针：** 首先对数组进行排序，然后遍历每个元素，对于每个元素，使用双指针法找到另外两个元素，使得这三个元素之和等于目标值。
- **哈希表：** 使用哈希表存储每个元素和其索引，对于每个元素，使用双指针法找到另外两个元素，使得这三个元素之和等于目标值。
- **排序 + 哈希表：** 首先对数组进行排序，然后使用哈希表存储每个元素和其索引，对于每个元素，使用双指针法找到另外两个元素，使得这三个元素之和等于目标值。

**代码实现（排序 + 双指针）：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var triples [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}
```

**代码实现（哈希表）：**

```go
func threeSum(nums []int) [][]int {
    var triples [][]int
    numsMap := make(map[int]int)
    for _, num := range nums {
        numsMap[num]++
    }
    for i := range nums {
        for j := i + 1; j < len(nums); j++ {
            complement := -nums[i] - nums[j]
            if val, exists := numsMap[complement]; exists {
                if complement == nums[j] {
                    if val > 1 {
                        triples = append(triples, []int{nums[i], nums[j], complement})
                    }
                } else {
                    triples = append(triples, []int{nums[i], nums[j], complement})
                }
            }
        }
    }
    return triples
}
```

**代码实现（排序 + 哈希表）：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var triples [][]int
    numsMap := make(map[int]int)
    for _, num := range nums {
        numsMap[num]++
    }
    for i := 0; i < len(nums); i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}
```

**解析：**  
在这三个例子中，我们使用了不同的方法来解决三数之和问题。第一个例子使用了排序和双指针，第二个例子使用了哈希表，第三个例子使用了排序和哈希表。这些方法都有其优缺点，排序 + 双指针的时间复杂度为 O(n^2)，哈希表的时间复杂度为 O(n^2)，排序 + 哈希表的时间复杂度为 O(n^2)。

#### 23. 设计时间轮

**题目描述：**  
设计一个时间轮，它由多个时间槽组成，每个时间槽可以存储一个事件。时间轮可以按照时间顺序处理事件，并且能够添加和删除事件。

**示例：**  
输入：  
- `add(1, 2)`: 添加事件，时间为 1，持续时间为 2。  
- `add(2, 3)`: 添加事件，时间为 2，持续时间为 3。  
- `add(3, 4)`: 添加事件，时间为 3，持续时间为 4。  
- `next()`: 返回下一个要处理的事件。  
输出：  
- `1`：返回下一个要处理的事件的时间。  
- `2`：返回下一个要处理的事件的时间。  
- `3`：返回下一个要处理的事件的时间。  
- `4`：返回下一个要处理的事件的时间。

**解题思路：**  
可以使用环形双向链表来实现时间轮。每个节点包含事件的时间、持续时间和指向前后节点的指针。添加事件时，根据事件的时间将事件插入到链表中的合适位置。处理事件时，从链表头部依次处理事件。

**代码实现：**

```go
type Event struct {
    time     int
    duration int
    prev     *Event
    next     *Event
}

type TimeWheel struct {
    slots     []*Event
    currentTime int
}

func Constructor() TimeWheel {
    return TimeWheel{
        slots:     make([]*Event, 100),
        currentTime: 0,
    }
}

func (this *TimeWheel) add(time int, duration int) {
    event := &Event{time: time, duration: duration}
    slot := this.slots[time%100]
    if slot == nil {
        this.slots[time%100] = event
    } else {
        for slot.next != nil {
            slot = slot.next
        }
        slot.next = event
        event.prev = slot
    }
}

func (this *TimeWheel) next() int {
    if this.slots[this.currentTime%100] == nil {
        this.currentTime++
        return -1
    }
    event := this.slots[this.currentTime%100]
    this.currentTime += event.duration
    if event.next != nil {
        event = event.next
    } else {
        this.slots[this.currentTime%100] = nil
        this.currentTime++
    }
    return event.time
}
```

**解析：**  
在这个例子中，我们定义了一个 `Event` 结构，表示事件。`TimeWheel` 结构包含数组 `slots` 存储每个时间槽的事件，`currentTime` 表示当前时间。`Constructor` 函数用于初始化 `TimeWheel` 结构。`add` 函数用于添加事件，根据事件的时间将事件插入到链表中。`next` 函数用于返回下一个要处理的事件的时间。

#### 24. 快乐数

**题目描述：**  
编写一个函数，判断一个正整数是否为「快乐数」。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环但始终变不了 1。如果可以变为 1，那么这个数就是快乐数。

**示例：**  
输入：`19`  
输出：`true`  

**解题思路：**  
可以使用快慢指针的方法。定义两个指针，一个快指针 `fast` 和一个慢指针 `slow`，它们都初始化为头节点。每次快指针走两步，慢指针走一步。如果快指针指向 1，则说明是快乐数，否则，如果快指针和慢指针相遇，则说明进入了循环，不是快乐数。

**代码实现：**

```go
func isHappy(n int) bool {
    fast, slow := n, n
    for {
        fast = squareSum(fast)
        fast = squareSum(fast)
        slow = squareSum(slow)
        if fast == slow {
            return false
        }
        slow = squareSum(slow)
        if fast == 1 {
            return true
        }
    }
}

func squareSum(n int) int {
    sum := 0
    for n > 0 {
        digit := n % 10
        sum += digit * digit
        n /= 10
    }
    return sum
}
```

**解析：**  
在这个例子中，我们定义了一个辅助函数 `squareSum`，用于计算一个数的每个位置上的数字的平方和。然后，我们使用两个指针 `fast` 和 `slow`，分别初始化为 `n`。我们进入一个循环，每次快指针走两步，慢指针走一步。如果快指针指向 1，则返回 `true`，否则，如果快指针和慢指针相遇，则返回 `false`。

#### 25. 颜色分类

**题目描述：**  
给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，原地对数组进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。

我们可以假设数组 `nums` 之前已经被 `n` 个元素正确地初始化（`n > 0`），忽略任意元素出现的可能性。

**示例：**  
输入：`nums = [2,0,2,1,1,0]`  
输出：`[0,0,1,1,2,2]`

**解题思路：**  
可以使用荷兰国旗问题的解法。定义三个指针 `red`、`white` 和 `blue`，分别表示当前已排序的区域的边界。遍历数组，根据当前元素的值，将元素移动到相应的位置，并更新边界。

**代码实现：**

```go
func sortColors(nums []int) {
    red, white, blue := 0, 0, len(nums)
    for i := 0; i < blue; {
        if nums[i] < 1 {
            nums[i], nums[white] = nums[white], nums[i]
            white++
            i++
        } else if nums[i] == 1 {
            i++
        } else {
            nums[i], nums[blue-1] = nums[blue-1], nums[i]
            blue--
        }
    }
}
```

**解析：**  
在这个例子中，我们定义了三个指针 `red`、`white` 和 `blue`，分别初始化为 0、0 和数组的长度。我们遍历数组，如果当前元素的值小于 1，则将其移动到已排序区域的边界 `red`，并将 `white` 和 `i` 都加 1。如果当前元素的值等于 1，则直接将 `i` 加 1。如果当前元素的值大于 1，则将其移动到已排序区域的边界 `blue`，并将 `blue` 减 1。

#### 26. 链表中的中间结点

**题目描述：**  
给定一个单链表，找出链表中的中间结点。

**示例：**  
输入：`[1,2,3,4,5]`  
输出：`3`

**解题思路：**  
可以使用快慢指针的方法。定义两个指针 `slow` 和 `fast`，分别初始化为链表的头节点。慢指针每次走一步，快指针每次走两步。当快指针到达链表末尾时，慢指针恰好到达中间结点。

**代码实现：**

```go
func middleNode(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```

**解析：**  
在这个例子中，我们定义了两个指针 `slow` 和 `fast`，分别初始化为链表的头节点。我们使用一个循环，每次快指针走两步，慢指针走一步。当快指针到达链表末尾时，慢指针恰好到达中间结点。最后，我们返回慢指针。

#### 27. 合并两个排序的链表

**题目描述：**  
将两个排序的链表合并为一个新的排序的链表并返回。新的链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
输入：`l1 = [1,2,4]`，`l2 = [1,3,4]`  
输出：`[1,1,2,3,4,4]`

**解题思路：**  
可以使用递归或迭代方法。递归方法通过比较两个链表的头节点，选择较小的节点作为新链表的当前节点，然后递归处理剩余的链表。迭代方法使用两个指针分别遍历两个链表，选择较小的节点作为新链表的当前节点。

**代码实现（递归）：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**代码实现（迭代）：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p, q := l1, l2

    for p != nil && q != nil {
        if p.Val < q.Val {
            curr.Next = p
            p = p.Next
        } else {
            curr.Next = q
            q = q.Next
        }
        curr = curr.Next
    }

    if p != nil {
        curr.Next = p
    } else if q != nil {
        curr.Next = q
    }

    return dummy.Next
}
```

**解析：**  
在这两个例子中，我们首先定义了一个 `ListNode` 结构，表示链表节点。递归方法通过比较两个链表的头节点，选择较小的节点作为新链表的当前节点，然后递归处理剩余的链表。迭代方法使用两个指针 `p` 和 `q` 分别遍历两个链表，选择较小的节点作为新链表的当前节点，直到处理完一个链表。最后，将未处理完的链表连接到新链表的尾部。

#### 28. 盒子堆叠

**题目描述：**  
给定一个由若干个盒子堆叠而成的金字塔，每个盒子都是一个正方形，具有不同的边长。编写一个函数，以数组 `boxes` 的形式返回金字塔的层次结构。数组中的每个元素都是一个盒子，表示该层中的盒子列表。最顶层是第一个元素，最底层是最后一个元素。

**示例：**  
输入：`boxes = [[2, 1], [3, 2], [5, 3], [6, 3], [7, 4]]`  
输出：`[[2, 1], [3, 2], [5, 3], [6, 3], [7, 4]]`

**解题思路：**  
可以使用广度优先搜索（BFS）的方法。首先，将所有盒子放入一个队列中。然后，使用一个循环逐层构建金字塔，每次从队列中取出当前层的所有盒子，并将下一层的盒子放入队列中。

**代码实现：**

```go
func arrangeBoxes(boxes [][]int) [][][]int {
    q := make([]*Box, 0)
    for _, b := range boxes {
        q = append(q, &Box{b[0], b[1]})
    }
    ans := [][][]int{}
    for len(q) > 0 {
        layer := [][]int{}
        for i := 0; i < len(q); i++ {
            b := q[0]
            q = q[1:]
            layer = append(layer, b.sizes)
            for _, p := range b.parts {
                n := &Box{p[0], p[1]}
                q = append(q, n)
            }
        }
        ans = append(ans, layer)
    }
    return ans
}

type Box struct {
    sizes [][]int
    parts []*Box
}
```

**解析：**  
在这个例子中，我们定义了一个 `Box` 结构，表示一个盒子，包含尺寸和部分。`arrangeBoxes` 函数使用 BFS 方法构建金字塔的层次结构。首先，将所有盒子放入队列中。然后，使用一个循环逐层构建金字塔，每次从队列中取出当前层的所有盒子，并将下一层的盒子放入队列中。最终，返回金字塔的层次结构。

#### 29. 单调栈

**题目描述：**  
实现一个单调栈，用于处理一些数学问题，如下一个更大元素、下一个更小元素等。

**示例：**  
输入：`[2, 1, 2, 4, 3]`  
输出：`[4, -1, 4, -1, 2]`  

**解题思路：**  
可以使用栈来维护一个单调递增或递减的序列。对于每个元素，将其与栈顶元素进行比较：

- 如果元素大于栈顶元素，将其入栈。
- 如果元素小于栈顶元素，弹出栈顶元素，并记录当前元素为下一个更大或更小的元素。

**代码实现：**

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := make([]int, 0)
    ans := make([]int, len(nums1))
    for _, num := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] < num {
            top := stack[len(stack)-1]
            ans = append(ans, num)
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            ans = append(ans, -1)
        }
        stack = append(stack, num)
    }
    return ans
}
```

**解析：**  
在这个例子中，我们定义了一个单调递增栈 `stack`，用于处理 `nums2` 中的每个元素。对于每个元素，我们将其与栈顶元素进行比较。如果元素大于栈顶元素，将其入栈。如果元素小于栈顶元素，弹出栈顶元素，并记录当前元素为下一个更大元素。如果栈为空，则记录下一个更大元素为 `-1`。最后，返回结果数组 `ans`。

#### 30. 设计前缀树

**题目描述：**  
设计一个前缀树（字典树）的数据结构，实现以下功能：

- `void insert(String word)`：向树中插入字符串 word。
- `boolean search(String word)`：如果字符串 word 在树中，则返回 true；否则返回 false。
- `boolean startsWith(String prefix)`：如果字符串 word 的前缀在树中，则返回 true；否则返回 false。

**示例：**  
输入：  
`[" Trie", "insert", "search", "search", "startsWith", "insert", "search"]`  
`[[], ["apple"], ["apple"], ["apple"], ["app"], ["app"], ["app"]]`  
输出：  
`[null, null, true, false, true, null, true]`

**解题思路：**  
前缀树由节点组成，每个节点包含一个字符和指向子节点的指针数组。对于每个字符，使用一个指针指向该字符的下一个字符。在根节点，添加一个标记，用于判断字符串是否结束。

**代码实现：**

```go
class Trie {
    private Trie[] children;
    private boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }

    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); i++) {
            int index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); i++) {
            int index = word.charAt(i) - 'a';
            if (node.children[index] == null) {
                return false;
            }
            node = node.children[index];
        }
        return node.isEnd;
    }

    public boolean startsWith(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++) {
            int index = prefix.charAt(i) - 'a';
            if (node.children[index] == null) {
                return false;
            }
            node = node.children[index];
        }
        return true;
    }
}
```

**解析：**  
在这个例子中，我们定义了一个 `Trie` 类，包含一个指针数组 `children` 存储子节点，以及一个布尔值 `isEnd` 标记字符串是否结束。`insert` 方法用于插入字符串，`search` 方法用于查找字符串，`startsWith` 方法用于查找字符串的前缀。通过递归遍历节点，实现前缀树的插入和查找功能。

