                 

# 2024京东物流科技校招面试真题汇总及其解答

## 一、算法题库

### 1. 合并区间

**题目描述：** 给一个区间列表，请合并所有重叠的区间。

**示例：**  
输入：[[1,3],[2,6],[8,10],[15,18]]  
输出：[[1,6],[8,10],[15,18]]

**答案解析：**  
首先，我们将区间按起始点排序。然后，我们遍历排序后的区间列表，对于每个区间，如果它与下一个区间的起始点大于等于结束点，则合并这两个区间。以下是 Python 代码实现：

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort()
    merged = [intervals[0]]
    for interval in intervals[1:]:
        if merged[-1][1] >= interval[0]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)
    return merged

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))
```

### 2. 二进制数中 1 的个数

**题目描述：** 给一个无符号整数，返回其二进制表示中 1 的个数。

**示例：**  
输入：9  
输出：2

**答案解析：**  
我们可以通过不断将数字右移一位，然后判断移出的位是否为 1 来计算 1 的个数。以下是 Python 代码实现：

```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

n = 9
print(hammingWeight(n))
```

### 3. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**  
输入：["flower","flow","flight"]  
输出："fl"

**答案解析：**  
我们可以使用分治算法来解决这个问题。首先，找到所有字符串的最长公共前缀，然后将其与每个字符串比较，如果匹配则继续，否则返回当前公共前缀。以下是 Python 代码实现：

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if len(s) < len(prefix) or s[:len(prefix)] != prefix:
                return prefix
        prefix += c
    return prefix

strs = ["flower","flow","flight"]
print(longestCommonPrefix(strs))
```

## 二、编程题库

### 1. 爬楼梯

**题目描述：** 一个楼梯有 n 阶台阶，每次可以上一阶或两阶，请计算有多少种上楼梯的方法。

**示例：**  
输入：3  
输出：3

**答案解析：**  
我们可以使用动态规划来解决这个问题。设 f(n) 为上 n 阶楼梯的方法数，则 f(n) = f(n-1) + f(n-2)。以下是 Python 代码实现：

```python
def climbStairs(n):
    if n < 2:
        return n
    a, b = 1, 1
    for i in range(2, n+1):
        a, b = b, a+b
    return b

n = 3
print(climbStairs(n))
```

### 2. 打家劫舍

**题目描述：** 你是一个小偷，面对一个按从大到小排列的房屋列表，每个房屋都装有不同数额的现金。你打算从其中选择一些房屋进行盗窃，但是不能连续选择相邻的房屋。请问，你最多可以偷窃多少现金？

**示例：**  
输入：[1,2,3,1]  
输出：4

**答案解析：**  
我们可以使用动态规划来解决这个问题。设 f(n) 为前 n 个房屋的最大盗窃金额，则 f(n) = max(f(n-1), f(n-2) + nums[n-1])。以下是 Python 代码实现：

```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    a, b = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        c = max(b, a+nums[i])
        a, b = b, c
    return b

nums = [1,2,3,1]
print(rob(nums))
```

### 3. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
输入：l1 = [1,2,4], l2 = [1,3,4]  
输出：[1,1,2,3,4,4]

**答案解析：**  
我们可以使用递归或迭代的方法来合并两个有序链表。以下是 Python 代码实现：

**递归方法：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

**迭代方法：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next
        curr.next = list1 or list2
        return dummy.next
```

