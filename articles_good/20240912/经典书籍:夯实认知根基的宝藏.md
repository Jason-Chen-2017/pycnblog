                 

### 《夯实认知根基的宝藏》 - 算法面试题与编程题解析

#### 一、算法面试题解析

##### 1. 如何判断一个链表是否有环？

**题目：** 如何判断一个链表是否含有环？

**答案：** 可以使用快慢指针法。定义两个指针，一个快指针每次走两步，一个慢指针每次走一步。如果链表中存在环，那么快指针最终会追上慢指针。

**代码示例：**

```python
def hasCycle(head):
    if not head:
        return False
    
    slow = head
    fast = head.next
    
    while fast and fast.next:
        if slow == fast:
            return True
        slow = slow.next
        fast = fast.next.next
    
    return False
```

##### 2. 如何找到链表中的中间节点？

**题目：** 如何找到单向链表的中间节点？

**答案：** 使用快慢指针法。定义两个指针，一个快指针每次走两步，一个慢指针每次走一步。当快指针到达链表末尾时，慢指针所指的节点即为中间节点。

**代码示例：**

```python
def middleNode(head):
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

##### 3. 如何实现一个堆？

**题目：** 如何在 Python 中实现一个小顶堆？

**答案：** 使用列表来实现一个小顶堆。堆的根节点总是最小的元素。实现时，可以通过父节点和子节点之间的关系来维护堆的性质。

**代码示例：**

```python
import heapq

def heappush(heap, item):
    heapq.heappush(heap, item)

def heappop(heap):
    return heapq.heappop(heap)

# 创建一个空堆
heap = []
heappush(heap, (1, 'a'))
heappush(heap, (2, 'b'))
heappush(heap, (3, 'c'))

print(heappop(heap))  # 输出 (1, 'a')
print(heappop(heap))  # 输出 (2, 'b')
```

##### 4. 如何实现一个二叉搜索树？

**题目：** 如何在 Python 中实现一个二叉搜索树（BST）？

**答案：** 创建一个节点类，每个节点包含值、左子节点和右子节点。实现插入、删除、搜索等基本操作。

**代码示例：**

```python
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert(self.root, value)

    def _insert(self, node, value):
        if value < node.value:
            if node.left:
                self._insert(node.left, value)
            else:
                node.left = TreeNode(value)
        else:
            if node.right:
                self._insert(node.right, value)
            else:
                node.right = TreeNode(value)

    def search(self, value):
        return self._search(self.root, value)

    def _search(self, node, value):
        if not node:
            return False
        if node.value == value:
            return True
        elif value < node.value:
            return self._search(node.left, value)
        else:
            return self._search(node.right, value)
```

##### 5. 如何实现一个排序算法？

**题目：** 如何在 Python 中实现快速排序算法？

**答案：** 快速排序是一种分治算法，其基本思想是通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据都比另一部分的所有数据要小。然后递归地对这两部分数据继续进行排序。

**代码示例：**

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quicksort(arr))  # 输出 [1, 1, 2, 3, 6, 8, 10]
```

#### 二、算法编程题解析

##### 1. 颠倒整数

**题目：** 编写一个函数，实现整数反转。

**示例：**

```python
def reverse(x):
    rev = 0
    while x:
        rev = rev * 10 + x % 10
        x //= 10
    return rev

# 输入: 123
# 输出: -321
```

##### 2. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。

**示例：**

```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(2, n):
        a, b = b, a + b
    return b

# 输入: 3
# 输出: 3
```

##### 3. 字符串转换整数 (atoi)

**题目：** 实现一个 myAtoi(string s) 函数，使其能将字符串转换为整数。

**示例：**

```python
def myAtoi(s):
    s = s.lstrip(' -+')
    if not s:
        return 0
    sign = 1 if s[0] != '-' else -1
    num = 0
    for c in s[:10]:
        if '0' <= c <= '9':
            num = num * 10 + ord(c) - ord('0')
        else:
            break
    return max(min(num * sign, 2**31 - 1), -2**31)

# 输入: "42"
# 输出: 42
```

##### 4. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
    return prefix

# 输入: ["flower","flow","flight"]
# 输出: "fl"
```

##### 5. 两数之和

**题目：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []

# 输入: [2, 7, 11, 15], target = 9
# 输出: [0, 1]
```

##### 6. 两数相加

**题目：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的。

**示例：**

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

# 输入：[2, 4, 3], [5, 6, 4]
# 输出：[7, 0, 7]
```

##### 7. 字符串匹配 - 暴力解法

**题目：** 给定一个字符串 (s) 和一个字符 (t)，实现一个支持 '.' 和 '*' 的通配符匹配。

**示例：**

```python
def isMatch(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n+1) for _ in range(m+1)]
    dp[0][0] = True
    for j in range(1, n+1):
        dp[0][j] = p[j-1] == '*'
    for i in range(1, m+1):
        for j in range(1, n+1):
            if p[j-1] == '*':
                dp[i][j] = dp[i-1][j] or dp[i][j-1]
            elif p[j-1] == '?' or p[j-1] == s[i-1]:
                dp[i][j] = dp[i-1][j-1]
    return dp[-1][-1]

# 输入: "adceb", "*.**d**"
# 输出: True
```

##### 8. 字符串匹配 - KMP 算法

**题目：** 给定一个字符串 (s) 和一个字符 (t)，实现一个支持 '.' 和 '*' 的通配符匹配。

**示例：**

```python
def kmp(s, p):
    def build_next(p):
        next = [0] * len(p)
        j = 0
        for i in range(1, len(p)):
            while j > 0 and p[i] != p[j]:
                j = next[j - 1]
            if p[i] == p[j]:
                j += 1
            next[i] = j
        return next

    next = build_next(p)
    i = j = 0
    while i < len(s):
        while j > 0 and (s[i] != p[j] or p[j] == '*'):
            j = next[j - 1]
        if s[i] == p[j] or p[j] == '.':
            i, j = i + 1, j + 1
        if j == len(p):
            return True
    return False

# 输入: "adceb", "*.**d**"
# 输出: True
```

### 总结

本文详细解析了《夯实认知根基的宝藏》主题下的典型面试题和算法编程题，包括链表、排序、搜索、整数操作等领域的经典问题。通过深入理解和掌握这些题目，可以夯实自己的算法基础，提升面试和实际项目开发的能力。同时，本文还提供了丰富的代码示例和解析，帮助读者更好地理解题目的解法和思路。

无论是准备技术面试，还是提升自己的编程技能，这些题目都是宝贵的财富。希望本文能够对你有所帮助，助你在算法的道路上不断前行。记住，坚持不懈地学习和实践是夯实认知根基的关键。加油！

