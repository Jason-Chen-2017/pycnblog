                 

### 华为社招面试算法题库大全

#### 1. 单调栈问题

**题目：** 求一个数组中的每个元素对应的下一个更大元素。如果没有更大的元素，则用 `-1` 表示。

**示例：**
```
输入：[2,1,5,6,2,3]
输出：[5,6,-1,-1,-1,3]
```

**答案：** 使用单调栈。

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    // 使用单调递减栈
    stack := []int{}
    for i := 2*n - 1; i >= 0; i-- {
        for len(stack) > 0 && nums[stack[len(stack)-1]] <= nums[i%n] {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            ans[i%n] = -1
        } else {
            ans[i%n] = nums[stack[len(stack)-1]]
        }
        stack = append(stack, i%n)
    }
    return ans
}
```

**解析：** 通过单调栈实现，遍历数组两次，时间复杂度为 \(O(n)\)。

#### 2. 最小栈

**题目：** 设计一个支持 push，pop，top 操作的栈，同时还需支持获取栈的最小元素。

**示例：**
```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[(-2)],\[(-3)\],\[(-4)\],[],[],[],[]]

输出：
[null,null,null,null,-3,null,-2,-3]
```

**答案：**

```go
type MinStack struct {
    st, minSt []int
}

func Constructor() MinStack {
    return MinStack{[]int{}, []int{}}
}

func (this *MinStack) Push(x int) {
    this.st = append(this.st, x)
    if len(this.minSt) == 0 || x <= this.minSt[len(this.minSt)-1] {
        this.minSt = append(this.minSt, x)
    }
}

func (this *MinStack) Pop() {
    if this.st[len(this.st)-1] == this.minSt[len(this.minSt)-1] {
        this.minSt = this.minSt[:len(this.minSt)-1]
    }
    this.st = this.st[:len(this.st)-1]
}

func (this *MinStack) Top() int {
    return this.st[len(this.st)-1]
}

func (this *MinStack) GetMin() int {
    return this.minSt[len(this.minSt)-1]
}
```

**解析：** 使用两个栈，一个存储所有元素，一个存储当前栈中的最小值。

#### 3. 逆波兰表达式求值

**题目：** 计算逆波兰表达式。

**示例：**
```
输入：["2", "1", "+", "3", "*"]
输出：9
解释：(2 + 1) * 3 = 9
```

**答案：**

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/int64(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

**解析：** 利用栈实现，遍历字符串数组，根据符号进行相应操作。

#### 4. 股票买卖

**题目：** 设计一个算法，用来查找最大的利润。

**示例：**
```
输入：prices = [7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润为 6-1 = 5 。
```

**答案：**

```go
func maxProfit(prices []int) int {
    minPrice := prices[0]
    maxProfit := 0
    for _, price := range prices {
        if price < minPrice {
            minPrice = price
        } else {
            profit := price - minPrice
            if profit > maxProfit {
                maxProfit = profit
            }
        }
    }
    return maxProfit
}
```

**解析：** 维护当前最低价格和最大利润。

#### 5. 合并两个有序链表

**题目：** 合并两个有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归合并。

#### 6. 二叉树的遍历

**题目：** 实现二叉树的遍历（前序、中序、后序）。

**示例：**
```
输入：root = [3,9,20,null,null,15,7]
输出：前序遍历：[3,9,20,15,7]
中序遍历：[9,3,15,20,7]
后序遍历：[9,15,7,20,3]
```

**答案：**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// 前序遍历
func preorderTraversal(root *TreeNode) (result []int) {
    dfs(root, &result)
    return
}
func dfs(node *TreeNode, result *[]int) {
    if node == nil {
        return
    }
    *result = append(*result, node.Val)
    dfs(node.Left, result)
    dfs(node.Right, result)
}

// 中序遍历
func inorderTraversal(root *TreeNode) (result []int) {
    dfs(root, &result)
    return
}

// 后序遍历
func postorderTraversal(root *TreeNode) (result []int) {
    dfs(root, &result)
    reverse(result)
    return
}
func reverse(nums []int) {
    for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
        nums[i], nums[j] = nums[j], nums[i]
    }
}
```

**解析：** 使用递归或迭代实现。

#### 7. 合并区间

**题目：** 合并区间。

**示例：**
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：间隔 [1,3] 和 [2,6] 可以合并为 [1,6]。
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 先排序，然后合并重叠区间。

#### 8. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**示例：**
```
输入：nums = [1,3,5,6], target = 5
输出：2
输入：nums = [1,3,5,6], target = 2
输出：1
```

**答案：**

```go
func searchInsert(nums []int, target int) int {
    low, high := 0, len(nums)
    for low < high {
        mid := low + (high-low)/2
        if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return low
}
```

**解析：** 二分查找。

#### 9. 字符串匹配

**题目：** 实现「暴力匹配」和「KMP 算法」。

**示例：**
```
输入：s = "ababc", p = "abc"
输出：暴力匹配：2，KMP算法：2
```

**答案：**

暴力匹配：

```go
func violentMatch(s string, p string) int {
    ls, lp := len(s), len(p)
    for i := 0; i <= ls-lp; i++ {
        j := 0
        for j < lp && s[i+j] == p[j] {
            j++
        }
        if j == lp {
            return i
        }
    }
    return -1
}
```

KMP算法：

```go
func kmpMatch(s string, p string) int {
    lps := computeLPSArray(p)
    i := 0
    j := 0
    for i < len(s) {
        if s[i] == p[j] {
            i++
            j++
        }
        if j == len(p) {
            return i - j
        } else if i < len(s) && s[i] != p[j] {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    return -1
}

func computeLPSArray(p string) []int {
    lps := make([]int, len(p))
    length := 0
    i := 1
    for i < len(p) {
        if p[i] == p[length] {
            length++
            lps[i] = length
            i++
        } else {
            if length != 0 {
                length = lps[length-1]
            } else {
                lps[i] = 0
                i++
            }
        }
    }
    return lps
}
```

**解析：** 暴力匹配通过遍历字符串`s`和模式字符串`p`，KMP算法通过最长公共前后缀（LPS）数组优化匹配过程。

#### 10. 二分查找最小值

**题目：** 在一个递增数组中找到最小值。

**示例：**
```
输入：nums = [3,4,5,1,2]
输出：1
```

**答案：**

```go
func findMin(nums []int) int {
    low, high := 0, len(nums)-1
    for low < high {
        mid := low + (high-low)/2
        if nums[mid] > nums[high] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}
```

**解析：** 使用二分查找。

#### 11. 最长公共子序列

**题目：** 给定两个字符串，找到它们的最长公共子序列。

**示例：**
```
输入：text1 = "ABCD", text2 = "ACDF"
输出："ACD"
```

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    i, j := m, n
    var res string
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            res = string(text1[i-1]) + res
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划求解。

#### 12. 设计循环队列

**题目：** 设计一个循环队列。

**示例：**
```
输入：["MyCircularQueue", "enque

