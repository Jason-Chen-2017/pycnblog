                 

### 2025华为校招面试算法题库大全

#### 一、排序算法

##### 1. 快速排序

**题目：** 实现快速排序算法，并解释其工作原理。

**答案：** 快速排序（Quick Sort）是一种高效的排序算法，其基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

```go
func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

**解析：** 代码中，`quickSort` 函数是快速排序的核心部分，通过递归调用 `partition` 函数来实现排序。`partition` 函数负责将数组分为两部分，小于 pivot 的放在 pivot 的左边，大于 pivot 的放在 pivot 的右边，然后返回 pivot 的索引。

##### 2. 归并排序

**题目：** 实现归并排序算法，并解释其工作原理。

**答案：** 归并排序（Merge Sort）是一种分治算法，其基本思想是将待排序的序列不断拆分为子序列，直到每个子序列只有一个元素，然后将这些子序列两两合并，直到得到有序的序列。

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

**解析：** `mergeSort` 函数递归地将数组拆分为两个子数组，然后调用 `merge` 函数将这两个有序子数组合并为一个有序数组。`merge` 函数负责比较两个子数组中的元素，并将较小的元素添加到结果数组中。

#### 二、查找算法

##### 3. 二分查找

**题目：** 实现二分查找算法，并解释其工作原理。

**答案：** 二分查找（Binary Search）算法是对有序数组进行查找的一种高效算法，其基本思想是每次将待查找的区间分为一半，根据中间元素与目标元素的大小关系，确定下一轮查找的区间。

```go
func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}
```

**解析：** 在二分查找过程中，`low` 和 `high` 指针始终指向当前查找区间的左右边界，每次循环通过计算中间值 `mid`，与目标值 `target` 进行比较，更新 `low` 或 `high` 的值，直到找到目标值或确定目标值不存在。

##### 4. 哈希表查找

**题目：** 实现哈希表查找算法，并解释其工作原理。

**答案：** 哈希表查找算法是一种基于哈希函数的查找方法，其基本思想是将关键字通过哈希函数映射到哈希表中，然后在哈希表中直接查找关键字对应的值。

```go
var hashTable = map[int]int{
    1: 10,
    2: 20,
    3: 30,
}

func hashSearch(key int) int {
    return hashTable[key]
}
```

**解析：** 在哈希表中，`hashTable` 是一个键值对映射表，通过 `key` 对应的哈希值在哈希表中直接查找，即可获取对应的值。哈希查找的时间复杂度为 O(1)。

#### 三、动态规划

##### 5. 最长公共子序列

**题目：** 实现最长公共子序列（LCS）算法，并解释其工作原理。

**答案：** 最长公共子序列（Longest Common Subsequence，LCS）是指两个序列中同时出现的最长的子序列。动态规划（Dynamic Programming，DP）是一种有效的求解方法。

```go
func longestCommonSubsequence(str1, str2 string) string {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    result := ""
    i, j := m, n
    for dp[i][j] != 0 {
        if str1[i-1] == str2[j-1] {
            result = string(str1[i-1]) + result
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return result
}
```

**解析：** `dp` 数组用于存储两个序列中各个位置上的最长公共子序列长度。通过遍历两个序列，更新 `dp` 数组。最后根据 `dp` 数组回溯，构建出最长公共子序列。

##### 6. 最长公共子串

**题目：** 实现最长公共子串（LCP）算法，并解释其工作原理。

**答案：** 最长公共子串（Longest Common Substring，LCP）是指两个序列中同时出现的最长的连续子串。可以使用动态规划（Dynamic Programming，DP）来求解。

```go
func longestCommonSubstring(str1, str2 string) string {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen, endIndex := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - 1
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return str1[endIndex-maxLen+1 : endIndex+1]
}
```

**解析：** `dp` 数组用于存储两个序列中各个位置上的最长公共子串长度。通过遍历两个序列，更新 `dp` 数组。最后根据 `dp` 数组，找到最长公共子串。

#### 四、图算法

##### 7. 拓扑排序

**题目：** 实现拓扑排序算法，并解释其工作原理。

**答案：** 拓扑排序（Topological Sort）是一种用于对有向无环图（DAG）进行排序的算法。拓扑排序的顺序满足：对于每一条边 `AB`，都有 `A` 在 `B` 之前。

```go
func topologicalSort(graph [][]int) []int {
    n := len(graph)
    inDegree := make([]int, n)
    for _, edges := range graph {
        for _, edge := range edges {
            inDegree[edge]++
        }
    }
    result := []int{}
    queue := []int{}
    for i, degree := range inDegree {
        if degree == 0 {
            queue = append(queue, i)
        }
    }
    for len(queue) > 0 {
        vertex := queue[0]
        queue = queue[1:]
        result = append(result, vertex)
        for _, edge := range graph[vertex] {
            inDegree[edge]--
            if inDegree[edge] == 0 {
                queue = append(queue, edge)
            }
        }
    }
    if len(result) != n {
        return nil // 图中有环
    }
    return result
}
```

**解析：** 拓扑排序算法首先统计各个节点的入度，将入度为 0 的节点加入队列。然后依次从队列中取出节点，将其加入结果数组，并更新其他节点的入度。如果某个节点的入度为 0，则将其加入队列。最后，如果结果数组的长度等于图中的节点数，说明图是无环的。

##### 8. 最短路径

**题目：** 实现迪杰斯特拉算法（Dijkstra's Algorithm），并解释其工作原理。

**答案：** 迪杰斯特拉算法（Dijkstra's Algorithm）是一种用于计算图中两点之间的最短路径的算法。它基于贪心策略，每次选择一个距离最短的未访问节点，更新其邻居节点的最短路径。

```go
func dijkstra(graph [][]int, start int) []int {
    n := len(graph)
    distances := make([]int, n)
    for i := range distances {
        distances[i] = math.MaxInt32
    }
    distances[start] = 0
    visited := make([]bool, n)
    for i := 0; i < n; i++ {
        minDistance := math.MaxInt32
        minIndex := -1
        for j := 0; j < n; j++ {
            if !visited[j] && distances[j] < minDistance {
                minDistance = distances[j]
                minIndex = j
            }
        }
        if minIndex == -1 {
            break
        }
        visited[minIndex] = true
        for j := 0; j < n; j++ {
            if !visited[j] && graph[minIndex][j] != 0 && distances[minIndex]+graph[minIndex][j] < distances[j] {
                distances[j] = distances[minIndex] + graph[minIndex][j]
            }
        }
    }
    return distances
}
```

**解析：** 迪杰斯特拉算法首先初始化所有节点的距离为无穷大，然后将起点的距离设置为 0。然后依次选择距离最短的未访问节点，更新其邻居节点的距离。最后返回所有节点的最短路径距离。

#### 五、位运算

##### 9. 位运算中的加法和减法

**题目：** 使用位运算实现加法和减法。

**答案：** 位运算中的加法和减法可以通过位与、位或和位异或操作来实现。

```go
func add(a, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}

func subtract(a, b int) int {
    for b != 0 {
        borrow := (~a) & b
        a = a ^ b
        b = borrow << 1
    }
    return a
}
```

**解析：** `add` 函数使用位与和位异或操作来计算和，使用位左移来计算进位。`subtract` 函数使用位与和位异或操作来计算差，使用位取反和位左移来计算借位。

##### 10. 位运算中的最大公约数

**题目：** 使用位运算实现最大公约数（GCD）。

**答案：** 使用位运算可以高效地计算最大公约数，方法是基于欧几里得算法。

```go
func gcd(a, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}
```

**解析：** 位运算版本的 GCD 算法同样使用递归，但使用位运算来计算模运算，即 `a % b` 可以表示为 `a - (a >> b)`。

#### 六、链表

##### 11. 反转链表

**题目：** 实现链表反转。

**答案：** 链表反转可以通过迭代和递归两种方法实现。

**迭代法：**

```go
func reverseList(head *ListNode) *ListNode {
    prev := nil
    current := head
    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}
```

**递归法：**

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

**解析：** 两种方法都通过改变链表的指向来实现反转。迭代法使用一个 `prev` 指针，每次将当前节点的 `Next` 指向 `prev`，然后更新 `prev` 和 `current` 的值。递归法通过递归调用 `reverseList` 函数，将当前节点的下一个节点反转，然后更新指向。

##### 12. 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：** 合并两个有序链表可以通过迭代和递归两种方法实现。

**迭代法：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    tail := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            tail.Next = l1
            l1 = l1.Next
        } else {
            tail.Next = l2
            l2 = l2.Next
        }
        tail = tail.Next
    }
    if l1 != nil {
        tail.Next = l1
    }
    if l2 != nil {
        tail.Next = l2
    }
    return dummy.Next
}
```

**递归法：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

**解析：** 两种方法都通过比较两个链表的当前节点值，选择较小的节点加入到合并后的链表中。迭代法使用一个 `tail` 指针来维护当前尾节点。递归法通过递归调用 `mergeTwoLists` 函数，将当前节点的下一个节点和另一个链表合并。

#### 七、树

##### 13. 二叉树的遍历

**题目：** 实现二叉树的前序遍历、中序遍历和后序遍历。

**答案：** 二叉树的遍历可以通过递归和迭代两种方法实现。

**递归法：**

```go
// 前序遍历
func preorderTraversal(root *TreeNode) []int {
    var result []int
    traverse(root, &result)
    return result
}

func traverse(node *TreeNode, result *[]int) {
    if node != nil {
        *result = append(*result, node.Val)
        traverse(node.Left, result)
        traverse(node.Right, result)
    }
}

// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    var result []int
    traverse(root, &result)
    return result
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    var result []int
    traverse(root, &result)
    return result
}
```

**迭代法：**

```go
// 前序遍历
func preorderTraversal(root *TreeNode) []int {
    var stack []*TreeNode
    var result []int
    if root != nil {
        stack = append(stack, root)
    }
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, node.Val)
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
    }
    return result
}

// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    var stack []*TreeNode
    var result []int
    node := root
    for node != nil || len(stack) > 0 {
        for node != nil {
            stack = append(stack, node)
            node = node.Left
        }
        node = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, node.Val)
        node = node.Right
    }
    return result
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    var stack []*TreeNode
    var result []int
    if root != nil {
        stack = append(stack, root)
    }
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        if node.Left == nil && node.Right == nil {
            stack = stack[:len(stack)-1]
            result = append(result, node.Val)
        } else {
            if node.Right != nil {
                stack = append(stack, node.Right)
            }
            if node.Left != nil {
                stack = append(stack, node.Left)
            }
            node.Right = nil
            node.Left = nil
        }
    }
    return result
}
```

**解析：** 递归法通过直接调用函数来实现遍历，而迭代法使用栈来模拟递归过程。前序遍历首先访问根节点，然后递归遍历左子树和右子树。中序遍历先递归遍历左子树，访问根节点，然后递归遍历右子树。后序遍历先递归遍历左子树，递归遍历右子树，然后访问根节点。

##### 14. 二叉搜索树

**题目：** 实现二叉搜索树（BST）的插入、删除和查找。

**答案：** 二叉搜索树（BST）是一种特殊的二叉树，左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// 插入
func insert(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return &TreeNode{Val: val}
    }
    if val < root.Val {
        root.Left = insert(root.Left, val)
    } else if val > root.Val {
        root.Right = insert(root.Right, val)
    }
    return root
}

// 删除
func delete(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return root
    }
    if val < root.Val {
        root.Left = delete(root.Left, val)
    } else if val > root.Val {
        root.Right = delete(root.Right, val)
    } else {
        if root.Left == nil && root.Right == nil {
            return nil
        } else if root.Left == nil {
            return root.Right
        } else if root.Right == nil {
            return root.Left
        }
        minNode := findMin(root.Right)
        root.Val = minNode.Val
        root.Right = delete(root.Right, minNode.Val)
    }
    return root
}

func findMin(node *TreeNode) *TreeNode {
    for node.Left != nil {
        node = node.Left
    }
    return node
}

// 查找
func search(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return nil
    }
    if val == root.Val {
        return root
    } else if val < root.Val {
        return search(root.Left, val)
    } else {
        return search(root.Right, val)
    }
}
```

**解析：** `insert` 函数将新节点插入到二叉搜索树中。`delete` 函数删除具有特定值的节点。在删除节点时，需要考虑三种情况：节点没有子节点、只有一个子节点、有两个子节点。对于有两个子节点的情况，通常使用中序遍历顺序中的最小节点替换待删除节点。`search` 函数在二叉搜索树中查找具有特定值的节点。

#### 八、数据结构

##### 15. 单调栈

**题目：** 使用单调栈实现下一个更大元素。

**答案：** 单调栈可以用来求解数组中的下一个更大元素。

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    result := make([]int, len(nums1), len(nums1))
    for i, v := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] <= v {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            result[i] = -1
        } else {
            result[i] = stack[len(stack)-1]
        }
        stack = append(stack, v)
    }
    return result
}
```

**解析：** 遍历 `nums2` 数组，对于每个元素，使用单调栈来维护一个递减的栈。如果栈为空，说明当前元素没有更大的元素，结果为 `-1`。否则，栈顶元素即为当前元素在 `nums1` 中的下一个更大元素。

##### 16. 双向链表

**题目：** 实现双向链表。

**答案：** 双向链表是一种支持双向遍历的链表。

```go
type Node struct {
    Val  int
    Prev *Node
    Next *Node
}

func (n *Node) InsertAfter(val int) {
    newNode := &Node{Val: val}
    newNode.Next = n.Next
    n.Next.Prev = newNode
    n.Next = newNode
    newNode.Prev = n
}

func (n *Node) InsertBefore(val int) {
    newNode := &Node{Val: val}
    newNode.Prev = n.Prev
    n.Prev.Next = newNode
    n.Prev = newNode
    newNode.Next = n
}

func (n *Node) Remove() {
    if n.Prev != nil {
        n.Prev.Next = n.Next
    }
    if n.Next != nil {
        n.Next.Prev = n.Prev
    }
}
```

**解析：** `Node` 结构体定义了双向链表的节点，包括值、前驱节点和后继节点。`InsertAfter` 和 `InsertBefore` 函数分别用于在当前节点的后面和前面插入新节点。`Remove` 函数用于删除当前节点。

##### 17. 有序集合

**题目：** 实现有序集合。

**答案：** 有序集合是一种支持插入、删除和查找的集合，可以使用二叉搜索树实现。

```go
type BST struct {
    Root *TreeNode
}

func (b *BST) Insert(val int) {
    b.Root = insert(b.Root, val)
}

func (b *BST) Delete(val int) {
    b.Root = delete(b.Root, val)
}

func (b *BST) Search(val int) bool {
    return search(b.Root, val) != nil
}

func insert(node *TreeNode, val int) *TreeNode {
    if node == nil {
        return &TreeNode{Val: val}
    }
    if val < node.Val {
        node.Left = insert(node.Left, val)
    } else if val > node.Val {
        node.Right = insert(node.Right, val)
    }
    return node
}

func delete(node *TreeNode, val int) *TreeNode {
    if node == nil {
        return node
    }
    if val < node.Val {
        node.Left = delete(node.Left, val)
    } else if val > node.Val {
        node.Right = delete(node.Right, val)
    } else {
        if node.Left == nil && node.Right == nil {
            return nil
        } else if node.Left == nil {
            return node.Right
        } else if node.Right == nil {
            return node.Left
        }
        minNode := findMin(node.Right)
        node.Val = minNode.Val
        node.Right = delete(node.Right, minNode.Val)
    }
    return node
}

func search(node *TreeNode, val int) *TreeNode {
    if node == nil {
        return nil
    }
    if val == node.Val {
        return node
    } else if val < node.Val {
        return search(node.Left, val)
    } else {
        return search(node.Right, val)
    }
}

func findMin(node *TreeNode) *TreeNode {
    for node.Left != nil {
        node = node.Left
    }
    return node
}
```

**解析：** `BST` 结构体定义了二叉搜索树，包括根节点。`Insert` 和 `Delete` 函数用于插入和删除节点。`Search` 函数用于查找节点。二叉搜索树保证了集合中的元素有序，方便进行插入、删除和查找操作。

#### 九、其他

##### 18. 逆波兰表达式求值

**题目：** 实现逆波兰表达式求值。

**答案：** 逆波兰表达式（Reverse Polish Notation，RPN）是一种后缀表示法，运算符位于操作数的后面。

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/b)
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(s string) int {
    sign := 1
    if s[0] == '-' {
        sign = -1
        s = s[1:]
    }
    result := 0
    for _, c := range s {
        result = result*10 + int(c-'0')
    }
    return result * sign
}
```

**解析：** 逆波兰表达式求值通过一个栈来存储中间结果。遍历表达式中的每个字符，如果是数字，直接入栈；如果是运算符，从栈中弹出两个操作数进行计算，将结果重新入栈。最后栈顶元素即为表达式的值。

##### 19. 有效的括号

**题目：** 判断一个字符串是否是有效的括号。

**答案：** 可以使用栈来判断字符串是否是有效的括号。

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{'(': ')', '[': ']', '{': '}'}
    for _, char := range s {
        if _, ok := pairs[char]; ok {
            stack = append(stack, char)
        } else if len(stack) == 0 || pairs[stack[len(stack)-1]] != char {
            return false
        } else {
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

**解析：** 遍历字符串中的每个字符，如果是左括号，将其入栈；如果是右括号，则与栈顶元素进行匹配，如果匹配成功，则出栈，否则返回 false。遍历结束后，如果栈为空，说明字符串是有效的括号。

##### 20. 有效的数字

**题目：** 判断一个字符串是否是有效的数字。

**答案：** 可以使用状态机来判断字符串是否是有效的数字。

```go
func isNumber(s string) bool {
    states := []struct {
        sign, digit, dot, exp int
        result                bool
    }{
        {0, 0, 0, 0, false},
        {1, 0, 0, 0, false},  // sign
        {1, 1, 0, 0, false},
        {1, 1, 1, 0, false},  // integer
        {2, 2, 0, 0, false},  // .
        {2, 2, 1, 0, false},
        {3, 2, 1, 0, false},  // .
        {3, 2, 1, 1, false},  // e
        {4, 0, 0, 0, false},  // e sign
        {4, 1, 0, 0, false},
        {5, 2, 0, 0, false},  // e integer
        {5, 2, 1, 0, false},
        {6, 2, 1, 1, false},  // e e
    }

    var state int = 0
    for _, char := range s {
        switch char {
        case '+', '-':
            state = 1
        case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
            state = 2
        case '.':
            state = 3
        case 'e':
            state = 4
        default:
            return false
        }
        states[state].result = states[state].result || states[state].digit > 0 || states[state].dot > 0 || states[state].exp > 0
        states[state].sign = states[state].sign || char == '+' || char == '-'
        states[state].digit = states[state].digit || char == '0' || char == '1' || char == '2' || char == '3' || char == '4' || char == '5' || char == '6' || char == '7' || char == '8' || char == '9'
        states[state].dot = states[state].dot || char == '.'
        states[state].exp = states[state].exp || char == 'e'
    }
    return states[state].result
}
```

**解析：** 状态机维护了数字的各种状态，包括整数、小数点、指数等。遍历字符串中的每个字符，根据字符的类型和当前状态，更新状态机的状态。最终判断状态机的结果是否为真。

##### 21. 验证二叉搜索树

**题目：** 判断一棵二叉树是否是有效的二叉搜索树。

**答案：** 可以使用中序遍历来判断一棵二叉树是否是有效的二叉搜索树。

```go
func isValidBST(root *TreeNode) bool {
    var prev *TreeNode
    return traverse(root)
}

func traverse(node *TreeNode) bool {
    if node == nil {
        return true
    }
    if !traverse(node.Left) {
        return false
    }
    if prev != nil && node.Val <= prev.Val {
        return false
    }
    prev = node
    return traverse(node.Right)
}
```

**解析：** 中序遍历二叉树，如果遍历的节点值小于前一个节点值，说明二叉树不是有效的二叉搜索树。遍历结束后，如果所有节点值都满足升序关系，则二叉树是有效的二叉搜索树。

##### 22. 字符串匹配

**题目：** 实现字符串匹配算法，例如 KMP 算法。

**答案：** KMP 算法（Knuth-Morris-Pratt Algorithm）是一种高效的字符串匹配算法。

```go
func KMP(s, p string) int {
    lps := computeLPS(p)
    i := 0
    j := 0
    for i < len(s) && j < len(p) {
        if s[i] == p[j] {
            i++
            j++
        } else {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    if j == len(p) {
        return i - j
    }
    return -1
}

func computeLPS(p string) []int {
    lps := make([]int, len(p))
    length := 0
    i := 1
    for i < len(p) {
        if p[i] == p[length] {
            length++
            lps[i] = length
            i++
        } else {
            if length != 0 {
                length = lps[length-1]
            } else {
                lps[i] = 0
                i++
            }
        }
    }
    return lps
}
```

**解析：** KMP 算法使用前缀函数 `lps` 来优化匹配过程。当匹配失败时，使用 `lps` 数组来决定下一次匹配的起始位置。`computeLPS` 函数计算前缀函数，`KMP` 函数实现匹配过程。如果匹配成功，返回匹配的起始位置；否则，返回 -1。

##### 23. 颜色分类

**题目：** 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序。

**答案：** 可以使用 Dutch National Flag 算法来解决这个问题。

```go
func sortColors(nums []int) {
    low, mid, high := 0, 0, len(nums)-1
    for mid <= high {
        if nums[mid] == 0 {
            nums[low], nums[mid] = nums[mid], nums[low]
            low++
            mid++
        } else if nums[mid] == 1 {
            mid++
        } else {
            nums[mid], nums[high] = nums[high], nums[mid]
            high--
        }
    }
}
```

**解析：** 算法使用三个指针来维护三个区域的边界。遍历数组，将 0 放在 low 和 mid 之间，将 1 放在 mid 和 high 之间。通过交换元素，实现原地排序。

##### 24. 快乐数

**题目：** 编写一个函数，判断一个数是否是快乐数。

**答案：** 快乐数是指一个正数，通过一系列的步骤后，最终会变为 1。步骤如下：

1. 将这个数的每一位上的数字进行平方运算。
2. 将平方后的结果相加。
3. 重复步骤 1 和 2，直到这个数变为 1（这时这个数就是快乐数），或者进入一个循环（这时这个数就不是快乐数）。

```go
func isHappy(n int) bool {
    seen := map[int]bool{}
    for n != 1 && !seen[n] {
        seen[n] = true
        sum := 0
        for n > 0 {
            n, remainder := n/10, n%10
            sum += remainder * remainder
        }
        n = sum
    }
    return n == 1
}
```

**解析：** 使用哈希表 `seen` 来记录已经出现的数字。如果数字变为 1，说明是快乐数。如果进入循环，说明不是快乐数。

##### 25. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。拼接链表应该将 `list1` 和 `list2` 中的节点依次进行交替排列。

**答案：** 可以使用递归或者迭代的方法来实现。

**递归方法：**

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    }
    list2.Next = mergeTwoLists(list1, list2.Next)
    return list2
}
```

**迭代方法：**

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            current.Next = list1
            list1 = list1.Next
        } else {
            current.Next = list2
            list2 = list2.Next
        }
        current = current.Next
    }
    if list1 != nil {
        current.Next = list1
    }
    if list2 != nil {
        current.Next = list2
    }
    return dummy.Next
}
```

**解析：** 两种方法都可以实现合并两个有序链表。递归方法通过递归调用 `mergeTwoLists` 函数，将当前节点与下一个节点合并。迭代方法使用一个指针 `current` 来维护当前节点，遍历两个链表，将较小的节点添加到结果链表中。

##### 26. 合并区间

**题目：** 给定一个无重叠的区间列表，合并所有重叠的区间。

**答案：** 可以使用排序和合并的方法来实现。

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    result := [][]int{intervals[0]}
    for _, interval := range intervals[1:] {
        last := result[len(result)-1]
        if interval[0] <= last[1] {
            last[1] = max(interval[1], last[1])
        } else {
            result = append(result, interval)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 首先将区间列表按照起点排序。然后遍历区间列表，如果当前区间的起点小于前一个区间的终点，则合并两个区间；否则，将当前区间添加到结果列表中。最终返回结果列表。

##### 27. 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组。

**答案：** 可以使用二分搜索的方法来实现。

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 遍历数组，使用二分搜索的方法来查找目标元素。当找到目标元素时，返回索引。否则，返回 -1。

##### 28. 买卖股票的最佳时机 III

**题目：** 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你最大利润。你最多只能完成两笔交易。

**答案：**

```go
func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    buy1, sell1 := -prices[0], 0
    buy2, sell2 := -prices[0], 0
    for i := 1; i < len(prices); i++ {
        sell1 = max(sell1, buy1+prices[i])
        buy2 = max(buy2, sell1-prices[i])
    }
    return sell2
}
```

**解析：** 使用动态规划的方法来计算最大利润。`buy1` 和 `sell1` 分别表示第一次买入和卖出的价格。`buy2` 和 `sell2` 分别表示第二次买入和卖出的价格。遍历数组，更新 `buy1`、`sell1`、`buy2` 和 `sell2` 的值，最终返回 `sell2`。

##### 29. 最大矩形

**题目：** 给定一个二维字符网格，找出其中最大的矩形。

**答案：**

```go
func maximalRectangle(matrix [][]byte) int {
    m, n := len(matrix), len(matrix[0])
    maxArea := 0
    heights := make([]int, n)
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == '0' {
                heights[j] = 0
            } else {
                heights[j]++
                if i > 0 {
                    heights[j] += heights[j-1]
                }
            }
        }
        for j := range heights {
            left, right := 0, n-1
            for left < right {
                mid := (left + right + 1) / 2
                if check(heights, j, mid) {
                    right = mid - 1
                } else {
                    left = mid
                }
            }
            maxArea = max(maxArea, (right-left+1)*heights[j])
        }
    }
    return maxArea
}

func check(heights []int, j, mid int) bool {
    for i := 0; i < mid; i++ {
        if i > 0 && heights[i] < heights[j] {
            return false
        }
    }
    for i := mid; i < len(heights); i++ {
        if i < len(heights)-1 && heights[i] < heights[j] {
            return false
        }
    }
    return true
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划的方法来计算最大矩形。首先遍历每一行，计算每列的高度。然后对于每一列，使用二分搜索来找到当前列高度可以扩展的最大宽度。遍历所有列，更新最大矩形面积。

##### 30. 最多能完成排序的块

**题目：** 给定一个整数数组 arr，你可以从中选出一个非空子数组并将该子数组翻转。请找出最大的非空子数组长度，使得对原始数组执行该操作后，得到的数组仍然按非递减顺序排列。

**答案：**

```go
func maximumBlocks(arr []int) int {
    cnt := 0
    sum := 0
    prev := -1
    for _, v := range arr {
        if v >= prev {
            sum++
            if sum > cnt {
                cnt = sum
            }
        } else {
            sum = 1
        }
        prev = v
    }
    return cnt
}
```

**解析：** 遍历数组，统计满足非递减条件的连续元素个数。每次遇到不满足条件的元素时，重置计数器。最大计数器即为最多能完成的排序块数量。

### 结束

以上是2025华为校招面试算法题库大全的典型问题/面试题库和算法编程题库，以及对应的详尽答案解析说明和源代码实例。希望对准备华为校招面试的同学们有所帮助。如果还有其他问题或需要更多解析，欢迎留言讨论。祝大家面试顺利！
<|endoftext|>

