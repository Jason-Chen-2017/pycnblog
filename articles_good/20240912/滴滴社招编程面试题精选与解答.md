                 

### 2025滴滴社招编程面试题精选与解答

#### 一、常见面试题

**1. 快排的时间复杂度是多少？如何证明？**

**答案：** 快速排序（Quick Sort）的平均时间复杂度为 \(O(n\log n)\)，最坏情况下的时间复杂度为 \(O(n^2)\)。证明如下：

快速排序的基本思想是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

- 平均情况：设 `n` 为待排序列的长度，则每次分割可以使得两部分记录的长度分别为 `n/2` 和 `n/2`，因此，快速排序递归调用次数为 \(\log_2 n\)。对于每次递归调用，需要遍历序列进行分割，平均分割长度为 `n/2`，因此，平均时间复杂度为 \(O(n\log n)\)。
- 最坏情况：最坏情况发生在每次分割时，分割点总是选择到序列的最小或最大元素，导致每次分割后一个子序列的长度为 `n-1`，另一个子序列的长度为 `0`。此时，递归调用次数为 \(n\)，每次递归调用需要遍历序列，因此，最坏情况下的时间复杂度为 \(O(n^2)\)。

**2. 红黑树是什么？它的主要特性是什么？**

**答案：** 红黑树是一种自平衡二叉查找树，其中每个节点包含一个颜色（红色或黑色），它的主要特性如下：

- 每个节点要么是红色的，要么是黑色的；
- 根节点是黑色的；
- 每个叶节点（NIL节点，空节点）是黑色的；
- 如果一个节点是红色的，则它的两个子节点都是黑色的（即不存在两个红色节点连续的情况）；
- 从任一节点到其每个叶节点的所有路径都包含相同数目的黑色节点。

红黑树的主要特性保证了树的高度平衡，因此，它的搜索、插入、删除操作的时间复杂度都接近于 \(O(\log n)\)。

**3. 如何实现一个非阻塞队列？**

**答案：** 可以使用两个条件变量来实现一个非阻塞队列：

- 一个条件变量用于队列不为空时的等待；
- 另一个条件变量用于队列非满时的等待。

具体实现如下：

```go
package main

import (
    "fmt"
    "sync/atomic"
)

type Condition struct {
    sync.Cond
    count int32
}

func NewCondition() *Condition {
    c := &Condition{}
    c.L = new(sync.Mutex)
    c.Cond = *sync.NewCond(c.L)
    return c
}

func (c *Condition) Wait() {
    c.L.Lock()
    for c.count == 0 {
        c.Cond.Wait()
    }
    c.L.Unlock()
}

func (c *Condition) Signal() {
    c.L.Lock()
    c.count++
    c.L.Unlock()
    c.Cond.Signal()
}

func (c *Condition) Notify(n int) {
    c.L.Lock()
    c.count += int32(n)
    c.L.Unlock()
    c.Cond.Signal()
}

func main() {
    cond := NewCondition()
    var wg sync.WaitGroup

    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            cond.Wait()
            fmt.Println("Waiting for signal:", atomic.AddInt32(&cond.count, -1))
            wg.Done()
        }()
    }

    for i := 0; i < 5; i++ {
        time.Sleep(time.Millisecond * 100)
        cond.Notify(2)
    }

    wg.Wait()
}
```

#### 二、算法编程题库

**1. 反转链表**

**题目：** 实现一个函数，反转单链表。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev, curr *ListNode
    curr = head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}

func main() {
    n1 := &ListNode{Val: 1}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 3}
    n1.Next = n2
    n2.Next = n3

    reversed := reverseList(n1)
    for reversed != nil {
        fmt.Println(reversed.Val)
        reversed = reversed.Next
    }
}
```

**2. 二分查找**

**题目：** 实现一个函数，在有序数组中查找目标值。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 3, 5, 7, 9}
    sort.Ints(arr)
    target := 5
    result := binarySearch(arr, target)
    if result == -1 {
        fmt.Println("Target not found.")
    } else {
        fmt.Printf("Target found at index: %d\n", result)
    }
}
```

**3. 合并两个有序链表**

**题目：** 实现一个函数，合并两个有序链表。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: nil}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: nil}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**4. 判断字符串是否为回文**

**题目：** 实现一个函数，判断字符串是否为回文。

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

func isPalindrome(s string) bool {
    runes := []rune(s)
    left, right := 0, len(runes)-1
    for left < right {
        if runes[left] != runes[right] {
            return false
        }
        left++
        right--
    }
    return true
}

func main() {
    s := "level"
    if isPalindrome(strings.ToLower(s)) {
        fmt.Println(s, "is a palindrome.")
    } else {
        fmt.Println(s, "is not a palindrome.")
    }
}
```

**5. 找出数组中的重复元素**

**题目：** 给定一个整数数组 `nums` ，其中可能包含重复元素，请找出任意一个重复的元素。如果有多个答案，只需返回其中一个。如果不存在重复元素，则返回 `-1`。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func findDuplicate(nums []int) int {
    sort.Ints(nums)
    for i := 1; i < len(nums); i++ {
        if nums[i] == nums[i-1] {
            return nums[i]
        }
    }
    return -1
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 5}
    result := findDuplicate(nums)
    if result != -1 {
        fmt.Println("Duplicate element:", result)
    } else {
        fmt.Println("No duplicate element found.")
    }
}
```

**6. 找出数组中的缺失元素**

**题目：** 给定一个整数数组 `nums`，其中可能存在缺失的元素，请找出缺失的元素。如果存在多个答案，只需返回其中一个。如果不存在缺失元素，则返回 `-1`。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func missingNumber(nums []int) int {
    n := len(nums)
    xor := 0
    for i := 0; i < n; i++ {
        xor ^= i ^ nums[i]
    }
    xor ^= n
    if xor == 0 {
        return -1
    }
    return xor
}

func main() {
    nums := []int{3, 0, 1}
    result := missingNumber(nums)
    if result != -1 {
        fmt.Println("Missing element:", result)
    } else {
        fmt.Println("No missing element found.")
    }
}
```

**7. 最长公共前缀**

**题目：** 给定一个字符串数组 `strs`，找出其中最长的公共前缀。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix); j++ {
            if j >= len(strs[i]) || strs[i][j] != prefix[j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("Longest common prefix:", result)
}
```

**8. 计数质数**

**题目：** 计算小于或等于 `n` 的质数个数。

**答案：**

```go
package main

import (
    "fmt"
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func countPrimes(n int) int {
    count := 0
    for i := 2; i <= n; i++ {
        if isPrime(i) {
            count++
        }
    }
    return count
}

func main() {
    n := 10
    result := countPrimes(n)
    fmt.Println("Number of primes less than or equal to", n, ":", result)
}
```

**9. 最长公共子序列**

**题目：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    var sb strings.Builder
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            sb.WriteByte(text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return sb.String()
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("Longest common subsequence:", result)
}
```

**10. 最长公共子串**

**题目：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子串。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubstring(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    maxLen, endIndex := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - 1
                }
            } else {
                dp[i][j] = 0
            }
        }
    }

    return text1[endIndex-maxLen+1 : endIndex+1]
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    result := longestCommonSubstring(text1, text2)
    fmt.Println("Longest common substring:", result)
}
```

**11. 股票买卖的最佳时机**

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果我们在第 `i` 天买入股票并在第 `j` 天（`j > i`）卖出，则可以获取 `prices[j] - prices[i]` 的利润。返回我们能够获取的最大利润。可以在任何时候买入和卖出股票，但每次交易完成后，我们不可以再继续交易。

**答案：**

```go
package main

import (
    "fmt"
)

func maxProfit(prices []int) int {
    maxProfit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            maxProfit += prices[i] - prices[i-1]
        }
    }
    return maxProfit
}

func main() {
    prices := []int{7, 1, 5, 3, 6, 4}
    result := maxProfit(prices)
    fmt.Println("Maximum profit:", result)
}
```

**12. 最小路径和**

**题目：** 给定一个包含非负整数的 `m x n` 网格，找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**答案：**

```go
package main

import (
    "fmt"
)

func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]

    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }

    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    grid := [][]int{
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1},
    }
    result := minPathSum(grid)
    fmt.Println("Minimum path sum:", result)
}
```

**13. 旋转图像**

**题目：** 给定一个 `n x n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 `90 度`。

**答案：**

```go
package main

import (
    "fmt"
)

func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := i; j < n-i-1; j++ {
            temp := matrix[i][j]
            matrix[i][j] = matrix[n-1-j][i]
            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]
            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]
            matrix[j][n-1-i] = temp
        }
    }
}

func printMatrix(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            fmt.Printf("%d ", matrix[i][j])
        }
        fmt.Println()
    }
}

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    rotate(matrix)
    printMatrix(matrix)
}
```

**14. 搜索旋转排序数组**

**题目：** 整数数组 `nums` 按升序排列，数组中的元素 `nums[i]` 可能有一个缺失。如果你只能访问数组中 24 小时数据，而且数组只被操作一次，请编写一个函数来查找 `nums` 的第一个缺失的整数。

**答案：**

```go
package main

import (
    "fmt"
)

func search(nums []int, target int) int {
    low, high := 0, len(nums)-1
    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return target
        } else if nums[mid] > target {
            if nums[low] == target {
                return target
            }
            high = mid - 1
        } else {
            if nums[high] == target {
                return target
            }
            low = mid + 1
        }
    }
    return nums[low]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 3
    result := search(nums, target)
    fmt.Println("First missing integer:", result)
}
```

**15. 有效的括号字符串**

**题目：** 给定一个只包含 `'('`、')'` 和 `'{'`、'}'` 的字符串，判断字符串是否有效。

**答案：**

```go
package main

import (
    "fmt"
)

func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || stack[len(stack)-1] != char {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}

func main() {
    s := "{}()"
    result := isValid(s)
    fmt.Println("Is valid:", result)
}
```

**16. 最小覆盖子串**

**题目：** 给定一个字符串 `s` 和一个字符集合 `t`，在 `s` 中找到最短的子串，使得子串中包含 `t` 集合中的所有字符。如果这样的子串不存在，返回空字符串。

**答案：**

```go
package main

import (
    "fmt"
)

func minWindow(s string, t string) string {
    counter := [128]int{}
    for _, char := range t {
        counter[char]++
    }
    left, right := 0, 0
    formed := 0
    ans := ""
    var charCount [128]int
    whileRight := right

    for right < len(s) {
        rightChar := s[right]
        charCount[rightChar]++
        if charCount[rightChar] == counter[rightChar] {
            formed++
        }
        whileRight = right

        while left <= whileRight && formed == len(t) {
            leftChar := s[left]
            charCount[leftChar]--
            if charCount[leftChar] == counter[leftChar]-1 {
                formed--
            }
            left++
            if len(ans) == 0 || right-left+1 < len(ans) {
                ans = s[left-1 : right+1]
            }
        }
        right++
    }
    return ans
}

func main() {
    s := "ADOBECODEBANC"
    t := "ABC"
    result := minWindow(s, t)
    fmt.Println("Minimum window substring:", result)
}
```

**17. 搜索二维矩阵**

**题目：** 编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target`。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**答案：**

```go
package main

import (
    "fmt"
)

func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    row, col := 0, n-1
    for row < m && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] < target {
            row++
        } else {
            col--
        }
    }
    return false
}

func main() {
    matrix := [][]int{
        {1, 3, 5, 7},
        {10, 11, 16, 20},
        {23, 30, 34, 50},
    }
    target := 3
    result := searchMatrix(matrix, target)
    fmt.Println("Target found:", result)
}
```

**18. 检查旋转排序数组是否有重复元素**

**题目：** 给定一个升序排列的数组 `nums` ，你需要在数组中找出并打印所有重复的数字。

**答案：**

```go
package main

import (
    "fmt"
)

func findDuplicates(nums []int) []int {
    duplicates := []int{}
    n := len(nums)
    for i := 0; i < n; i++ {
        val := abs(nums[i])
        if nums[val-1] < 0 {
            duplicates = append(duplicates, val)
        } else {
            nums[val-1] = -nums[val-1]
        }
    }
    for i := 0; i < n; i++ {
        nums[i] = abs(nums[i])
    }
    return duplicates
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 5, 5, 6, 6, 7, 8, 8, 9}
    duplicates := findDuplicates(nums)
    fmt.Println("Duplicates:", duplicates)
}
```

**19. 合并区间**

**题目：** 给定一组区间，合并所有重叠的区间。

**答案：**

```go
package main

import (
    "fmt"
)

type Interval struct {
    Start, End int
}

func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i].Start == intervals[j].Start {
            return intervals[i].End < intervals[j].End
        }
        return intervals[i].Start < intervals[j].Start
    })
    var result []Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := []Interval{
        {1, 3},
        {2, 6},
        {8, 10},
        {15, 18},
    }
    result := merge(intervals)
    fmt.Println("Merged intervals:", result)
}
```

**20. 零钱兑换 II**

**题目：** 给定一个整数数组 `coins` 和一个目标金额 `amount`，计算可以组合出多少种不同的硬币组合来达到目标金额。

**答案：**

```go
package main

import (
    "fmt"
)

func change(coins []int, amount int) int {
    dp := make([]int, amount+1)
    dp[0] = 1
    for _, coin := range coins {
        for i := coin; i <= amount; i++ {
            dp[i] += dp[i-coin]
        }
    }
    return dp[amount]
}

func main() {
    coins := []int{1, 2, 5}
    amount := 5
    result := change(coins, amount)
    fmt.Println("Number of combinations:", result)
}
```

#### 三、总结

本文整理了 2025 滴滴社招编程面试题精选与解答，涵盖了常见面试题和算法编程题。这些题目都是滴滴社招中较为典型的高频题目，对求职者来说具有很高的参考价值。通过本文的解答，读者可以更好地理解和掌握这些面试题的解题思路和算法实现。

#### 四、拓展阅读

为了帮助读者进一步深入学习，我们推荐以下拓展阅读：

1. 《算法导论》：一本经典的算法教材，涵盖了各种算法的设计和分析方法。
2. 《大话数据结构》：一本生动有趣的数据库和数据结构入门书。
3. 《编程之美》：微软的面试题集合，适合求职者进行面试准备。

希望本文能对您的面试准备有所帮助，祝您在求职过程中取得好成绩！


