                 

### 阿里巴巴2025校招编程面试题精选与解答

#### 1. 简单的链表操作

**题目：** 实现一个链表，支持添加节点、删除节点、查找节点等功能。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, val):
        if not self.head:
            self.head = ListNode(val)
        else:
            curr = self.head
            while curr.next:
                curr = curr.next
            curr.next = ListNode(val)

    def delete(self, val):
        if self.head and self.head.val == val:
            self.head = self.head.next
            return
        curr = self.head
        prev = None
        while curr and curr.val != val:
            prev = curr
            curr = curr.next
        if curr:
            prev.next = curr.next

    def search(self, val):
        curr = self.head
        while curr:
            if curr.val == val:
                return True
            curr = curr.next
        return False
```

**解析：** 该代码定义了一个简单的链表类`LinkedList`，支持添加节点`append`、删除节点`delete`和查找节点`search`。

#### 2. 二叉树的遍历

**题目：** 实现二叉树的先序、中序、后序遍历。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorderTraversal(root):
    if root is None:
        return []
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)

def inorderTraversal(root):
    if root is None:
        return []
    return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)

def postorderTraversal(root):
    if root is None:
        return []
    return postorderTraversal(root.left) + postorderTraversal(root.right) + [root.val]
```

**解析：** 该代码定义了一个二叉树节点类`TreeNode`，并实现了先序、中序、后序遍历函数。

#### 3. 双指针算法

**题目：** 给定一个数组，找出其中重复的元素。

**答案：**

```python
def findDuplicate(nums):
    slow, fast = 0, 0
    while True:
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast:
            break
    slow = 0
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow
```

**解析：** 该代码使用双指针算法找到数组中的重复元素。快指针每次走两步，慢指针每次走一步，当它们相遇时，说明找到了一个循环。

#### 4. 堆排序

**题目：** 实现堆排序。

**答案：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
```

**解析：** 该代码首先通过`heapify`函数将数组转化为大顶堆，然后通过交换和调整堆顶元素，实现堆排序。

#### 5. 二分查找

**题目：** 在有序数组中查找一个元素。

**答案：**

```python
def binarySearch(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 该代码使用二分查找算法在有序数组中查找目标元素。

#### 6. 排序算法

**题目：** 实现冒泡排序、选择排序、插入排序。

**答案：**

```python
def bubbleSort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def selectionSort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

def insertionSort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i-1
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
```

**解析：** 该代码分别实现了冒泡排序、选择排序和插入排序。

#### 7. 动态规划

**题目：** 最长递增子序列。

**答案：**

```python
def longestIncreasingSubsequence(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**解析：** 该代码使用动态规划求解最长递增子序列。

#### 8. 位操作

**题目：** 位操作实现加法。

**答案：**

```python
def add(a, b):
    while b != 0:
        carry = a & b
        a = a ^ b
        b = carry << 1
    return a
```

**解析：** 该代码使用位操作实现加法，避免了溢出问题。

#### 9. 双指针

**题目：** 两数相加。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**解析：** 该代码使用双指针实现两个链表的相加。

#### 10. 快排

**题目：** 快速排序。

**答案：**

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

**解析：** 该代码实现了快速排序算法。

#### 11. 并查集

**题目：** 合并区间。

**答案：**

```python
def merge(intervals):
    intervals.sort(key=lambda x: x[0])
    result = []
    for interval in intervals:
        if not result or result[-1][1] < interval[0]:
            result.append(interval)
        else:
            result[-1][1] = max(result[-1][1], interval[1])
    return result
```

**解析：** 该代码使用并查集算法合并区间。

#### 12. 设计模式

**题目：** 实现单例模式。

**答案：**

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance
```

**解析：** 该代码实现了单例模式。

#### 13. 红黑树

**题目：** 实现红黑树。

**答案：**

```python
class Node:
    def __init__(self, value, color='red'):
        self.value = value
        self.color = color
        self.parent = None
        self.left = None
        self.right = None

class RedBlackTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        node = Node(value)
        if not self.root:
            self.root = node
            self.root.color = 'black'
        else:
            curr = self.root
            parent = None
            while curr:
                parent = curr
                if node.value < curr.value:
                    curr = curr.left
                else:
                    curr = curr.right
            node.parent = parent
            if node.value < parent.value:
                parent.left = node
            else:
                parent.right = node
            self.fixInsert(node)

    def fixInsert(self, node):
        while node != self.root and node.parent.color == 'red':
            if node.parent == node.parent.parent.left:
                uncle = node.parent.parent.right
                if uncle.color == 'red':
                    node.parent.color = 'black'
                    uncle.color = 'black'
                    node.parent.parent.color = 'red'
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        node = node.parent
                        self.leftRotate(node)
                    node.parent.color = 'black'
                    node.parent.parent.color = 'red'
                    self.rightRotate(node.parent.parent)
            else:
                uncle = node.parent.parent.left
                if uncle.color == 'red':
                    node.parent.color = 'black'
                    uncle.color = 'black'
                    node.parent.parent.color = 'red'
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        node = node.parent
                        self.rightRotate(node)
                    node.parent.color = 'black'
                    node.parent.parent.color = 'red'
                    self.leftRotate(node.parent.parent)
        self.root.color = 'black'

    def leftRotate(self, x):
        y = x.right
        x.right = y.left
        if y.left:
            y.left.parent = x
        y.parent = x.parent
        if not x.parent:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    def rightRotate(self, x):
        y = x.left
        x.left = y.right
        if y.right:
            y.right.parent = x
        y.parent = x.parent
        if not x.parent:
            self.root = y
        elif x == x.parent.right:
            x.parent.right = y
        else:
            x.parent.left = y
        y.right = x
        x.parent = y
```

**解析：** 该代码实现了红黑树。

#### 14. 设计模式

**题目：** 实现工厂模式。

**答案：**

```python
class Factory:
    def create_product(self, type):
        if type == 'A':
            return ProductA()
        elif type == 'B':
            return ProductB()
        else:
            raise ValueError('Invalid product type')

class ProductA:
    def use_product(self):
        print('Using Product A')

class ProductB:
    def use_product(self):
        print('Using Product B')
```

**解析：** 该代码实现了工厂模式，可以根据类型创建不同的产品。

#### 15. 设计模式

**题目：** 实现装饰器模式。

**答案：**

```python
class Component:
    def operation(self):
        pass

class ConcreteComponent(Component):
    def operation(self):
        print('ConcreteComponent operation')

class Decorator(Component):
    def __init__(self, component):
        self._component = component

    def operation(self):
        self._component.operation()

class ConcreteDecoratorA(Decorator):
    def operation(self):
        self._component.operation()
        print('ConcreteDecoratorA additional operation')

class ConcreteDecoratorB(Decorator):
    def operation(self):
        self._component.operation()
        print('ConcreteDecoratorB additional operation')
```

**解析：** 该代码实现了装饰器模式，可以在不修改原有组件代码的情况下，动态地扩展组件的功能。

#### 16. 常见排序算法

**题目：** 实现冒泡排序。

**答案：**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
```

**解析：** 该代码实现了冒泡排序算法。

#### 17. 常见排序算法

**题目：** 实现选择排序。

**答案：**

```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```

**解析：** 该代码实现了选择排序算法。

#### 18. 常见排序算法

**题目：** 实现插入排序。

**答案：**

```python
def insertion_sort(arr):
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

**解析：** 该代码实现了插入排序算法。

#### 19. 常见排序算法

**题目：** 实现快速排序。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

**解析：** 该代码实现了快速排序算法。

#### 20. 常见排序算法

**题目：** 实现归并排序。

**答案：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

**解析：** 该代码实现了归并排序算法。

#### 21. 设计模式

**题目：** 实现单例模式。

**答案：**

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance
```

**解析：** 该代码实现了单例模式。

#### 22. 设计模式

**题目：** 实现工厂模式。

**答案：**

```python
class Factory:
    def create_product(self, type):
        if type == 'A':
            return ProductA()
        elif type == 'B':
            return ProductB()
        else:
            raise ValueError('Invalid product type')

class ProductA:
    def use_product(self):
        print('Using Product A')

class ProductB:
    def use_product(self):
        print('Using Product B')
```

**解析：** 该代码实现了工厂模式。

#### 23. 设计模式

**题目：** 实现装饰器模式。

**答案：**

```python
class Component:
    def operation(self):
        pass

class ConcreteComponent(Component):
    def operation(self):
        print('ConcreteComponent operation')

class Decorator(Component):
    def __init__(self, component):
        self._component = component

    def operation(self):
        self._component.operation()

class ConcreteDecoratorA(Decorator):
    def operation(self):
        self._component.operation()
        print('ConcreteDecoratorA additional operation')

class ConcreteDecoratorB(Decorator):
    def operation(self):
        self._component.operation()
        print('ConcreteDecoratorB additional operation')
```

**解析：** 该代码实现了装饰器模式。

#### 24. 链表操作

**题目：** 实现链表反转。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

**解析：** 该代码实现了链表反转。

#### 25. 栈与队列

**题目：** 使用栈实现队列。

**答案：**

```python
class StackQueue:
    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def enqueue(self, val):
        self.stack_in.append(val)

    def dequeue(self):
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())
        return self.stack_out.pop() if self.stack_out else None
```

**解析：** 该代码使用栈实现队列。

#### 26. 树结构

**题目：** 实现二叉搜索树。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val < node.val:
            if not node.left:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        else:
            if not node.right:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)
```

**解析：** 该代码实现了二叉搜索树。

#### 27. 图结构

**题目：** 实现深度优先搜索。

**答案：**

```python
from collections import defaultdict

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def dfs(self, start):
        visited = set()
        self._dfs(start, visited)

    def _dfs(self, node, visited):
        print(node.val)
        visited.add(node.val)
        for neighbor in self.graph[node.val]:
            if neighbor.val not in visited:
                self._dfs(neighbor, visited)
```

**解析：** 该代码实现了深度优先搜索。

#### 28. 图结构

**题目：** 实现广度优先搜索。

**答案：**

```python
from collections import deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def add_edge(self, u, v):
        self.graph[u].append(v)

    def bfs(self, start):
        visited = set()
        queue = deque([start])
        visited.add(start)
        while queue:
            node = queue.popleft()
            print(node.val)
            for neighbor in self.graph[node.val]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)
```

**解析：** 该代码实现了广度优先搜索。

#### 29. 设计模式

**题目：** 实现观察者模式。

**答案：**

```python
class Observer:
    def update(self, subject):
        print("Observer: Subject state has changed.")

class Subject:
    def __init__(self):
        self._observers = []
        self._state = None

    def attach(self, observer):
        self._observers.append(observer)

    def detach(self, observer):
        self._observers.remove(observer)

    def notify(self):
        for observer in self._observers:
            observer.update(self)

    @property
    def state(self):
        return self._state

    @state.setter
    def state(self, value):
        self._state = value
        self.notify()
```

**解析：** 该代码实现了观察者模式。

#### 30. 设计模式

**题目：** 实现策略模式。

**答案：**

```python
class Strategy:
    def do_algorithm(self):
        pass

class ConcreteStrategyA(Strategy):
    def do_algorithm(self):
        print("Executing algorithm A")

class ConcreteStrategyB(Strategy):
    def do_algorithm(self):
        print("Executing algorithm B")

class Context:
    def __init__(self, strategy):
        self._strategy = strategy

    def set_strategy(self, strategy):
        self._strategy = strategy

    def execute_algorithm(self):
        self._strategy.do_algorithm()
```

**解析：** 该代码实现了策略模式。

