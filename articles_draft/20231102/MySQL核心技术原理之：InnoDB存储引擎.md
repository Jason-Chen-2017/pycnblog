
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


　　InnoDB（另译名：永久表）是MySQL 5.5版本引入的一款存储引擎，它主要用于存储事务性及其处理速度要求较高的数据。在MySQL中，InnoDB存储引擎由聚集索引和辅助索引组成。InnoDB支持崩溃恢复能力、并发控制、事务支持等功能。InnoDB支持主从复制，其中，作为主库的服务器可以使用基于语句级复制；而作为从库的服务器只能进行基于行级别的复制。  
　　InnoDB的设计目标是提供给用户最好的性能，包括事务处理的完整ACID compliance、外部键约束、通过锁保证数据一致性、异步IO以及支持索引和统计信息收集。MySQL 5.5版本后默认使用InnoDB作为其默认的存储引擎。
# 2.核心概念与联系
## 2.1 InnoDB存储引擎
　　InnoDB存储引擎由聚集索引和辅助索引组成。如下图所示，InnoDB中的数据是按照聚集索引的顺序存放的，同时，InnoDB也维护一个隐藏的辅助索引来加速数据的检索。每张表只能有一个聚集索引，但可以创建多个辅助索引。当需要执行查询时，InnoDB会首先根据索引查找主键所在的位置，然后按主键值顺序访问记录。如果没有找到，则再依次检查非聚集索引是否满足条件。如果所有的索引都无法找到对应的数据记录，则返回空结果集。如此，InnoDB使得查询效率大幅提升。


　　２．事务与隔离级别
InnoDB支持两种类型的事务：
* 1.行级锁（Row-level locking）：最基本的锁策略。通过锁住需要修改或读取的数据，避免其他事务对同一份数据的并发访问。当对某个记录做UPDATE或DELETE操作的时候，整个表都会被锁住，直到当前事务结束。为了防止死锁，InnoDB采用两阶段锁定协议，确保事务不会因持有锁资源长时间产生死锁。但是由于锁住了大量的资源，在冲突比较多时效率可能出现问题。
* 2.事务锁（Transaction Locking）：InnoDB支持对事务的精准加锁，不仅可以锁住整个表或者单个行，还可以对某些范围内的数据项上锁。因此，即便发生了其他事务对该范围内数据项的更新，也将不会影响当前事务对该数据的读写。
事务隔离级别定义了数据库对并发事务处理的策略，不同级别下数据库处理事务的方式不同，进而影响事务一致性和性能。目前InnoDB支持4种事务隔离级别，分别为Read Uncommitted(读已提交),Read Committed(读已提交)，Repeatable Read(可重复读)，Serializable(串行化)。  
　　下面对各个隔离级别进行详细介绍。
### 2.1.1 Read Uncommitted(读未提交)  
最低的隔离级别，任何事务都可以看到其他未提交事务的变动，可能会导致不可重复读、幻影读或不可用情况。READ UNCOMMITTED隔离级别可以解决脏读的问题，但是不能解决其他问题，如幻象读、不可重复读、虚读。

#### 脏读 (Dirty Read): 一个事务读到了另一个未提交事务的脏数据。  
例如，一个事务A开始读取一条记录，这条记录的值为100。这时候另一个事务B开始执行update语句，更改了这个记录的值为200，但是因为还没提交，所以这条记录实际上是仍然为100。那么事务A再继续执行查询操作就会发现自己读到的记录不是最新值，也就是读到了脏数据。

#### 例子：假设某学生管理系统中存在一个students表，列如id, name, age，其中age字段为自增主键。某个事务先插入一条数据(id = 1, name = 'Alice', age = 18)，然后开启新的事务B，并执行如下sql语句：

    BEGIN;
    SELECT * FROM students WHERE id = 1 FOR UPDATE; -- select语句加FOR UPDATE锁住这条记录
    INSERT INTO students(name, age) VALUES('Bob', 19);-- 插入新纪录，准备提交事务B
    COMMIT;
    END;
    
由于SELECT语句加了FOR UPDATE锁，所以事务B只能等待事务A提交事务才能执行INSERT操作。另外，InnoDB的REPEATABLE READ隔离级别也可以避免幻象读的问题。 

### 2.1.2 Read Committed(读已提交)  
只能读到已经提交事务的数据，InnoDB只能保证这个级别事务隔离能满足简单查询的要求。这就意味着一个事务要么完全看见已经提交的事务，要么根本无法看到。

#### 示例：A事务读取一条记录，这条记录的值为100，并且提交事务。B事务开始执行insert语句，插入一条新纪录(id = 1, name = 'Bob', age = 19)，准备提交事务B。这时A事务重新启动，再次读取相同的记录，发现还是原来的那条记录。因为读到的都是已经提交的记录。 

#### 注意事项：对于有较强一致性要求的业务场景，比如银行转账等，建议选择此隔离级别。

### 2.1.3 Repeatable Read(可重复读)  
这个级别允许一个事务多次读取同一数据集合，但是每次只能看到事务开始前一刻的状态，这可以避免前面说的幻象读问题，但是可能导致不可重复读问题。

#### 可重复读的实现方式：InnoDB在每个事务开始之前都会生成一个数据快照（undo log），记录该事务对数据做过哪些更新。同时，InnoDB会保存当前数据快照的编号，之后再重启时，InnoDB会对比这些快照编号，判断是否应该回滚之前的更新操作。这样的话，如果两个事务操作了同一条记录，可能产生幻象读的问题。

#### 示例：事务A和B同时读取一条记录，这条记录的值为100。那么事务A开始提交事务，然后事务B开始执行update语句，把该记录的值改为200，准备提交事务B。这时事务A又开始提交事务，那么这时A和B读取的记录值是不同的。 

#### 注意事项：InnoDB的默认事务隔离级别就是Repeatable Read。 

### 2.1.4 Serializable(串行化)  
最严格的隔离级别，确保每次读写都完全按请求顺序执行，即串行化执行。该隔离级别可以防止脏读、不可重复读、幻读等并发问题。InnoDB在实现SERIALIZABLE隔离级别时采用的是两阶段锁机制，具体过程如下：  

1. 预备语句生成（transaction prepare phase）。事务开始时，InnoDB会记录下该事务涉及的所有数据页，以及在每个页面上待更新的记录，然后在数据字典里记下这些页面的锁信息。

2. 提交（commit phase）。事务结束后，InnoDB会释放所有相关锁，并提交事务日志。其他事务在获取相同数据页面上的排他锁之前，需等待这个事务提交。

3. 校验（validation phase）。在提交事务日志前，InnoDB会检查数据是否正确。如果检测出任何异常，InnoDB将利用回滚段（rollback segment）撤销已经提交的事务。

## 2.2 存储结构与组织
### 2.2.1 索引组织结构
InnoDB存储引擎是基于聚集索引和辅助索引的。其中，聚集索引是一个逻辑概念，表示表中一组唯一的行，叶子节点存放表中的真正数据。InnoDB在物理上将数据按每张表的聚集索引排序，这种结构称为索引组织表。


InnoDB支持动态添加、删除、修改索引。一般情况下，InnoDB对索引文件做缓存，以提升读性能。但由于InnoDB表有聚集索引和辅助索引之分，所以索引数据也分为聚集索引数据和辅助索引数据两部分。聚集索引数据位于表空间的数据区，辅助索引数据存放在一个独立的索引区。

### 2.2.2 数据页
InnoDB以页（page）为单位磁盘存储和分配表空间，每个页的大小为16KB，即65536字节。InnoDB页分为三种类型：
* 数据页：用于存储表中实际的数据，每个数据页分成三部分：头部（page header）、数据（row data）、尾部（page trailer）。其中，头部和尾部占用固定大小的存储空间，数据大小可变。
* 索引页：用于存储索引信息。
* 字典页：用于存储数据字典信息。

InnoDB页的内部是通过堆积的方式实现的。若一个页中没有足够的空间容纳新数据，InnoDB会申请一个新的页，并将原页的数据全部写入到新的页中。对于一个插入操作来说，只有在写完数据后才会向磁盘申请空间。因此，在表中大量插入数据时，系统性能可能会受到影响。

## 2.3 日志模块
InnoDB的日志模块负责将数据变更记录在 redo log 和 undo log 中。redo log 用于保证事务的持久性，当事务提交成功后，InnoDB 将更新数据写入到 redo log 文件中，以保证数据durability。 undo log 用于事务回滚，当事务回滚时，InnoDB 会通过 undo log 中的数据恢复到相应的版本。

### 2.3.1 Redo Log 详解
Redo log 是 InnoDB 为保证事务的持久性而提出的一种技术。其工作原理是将对数据的修改操作先写入 redo log 中，随后再 flush 到磁盘，以此确保事务的持久性。当系统发生异常宕机等故障时，可以根据 redo log 对数据进行恢复。

redo log 有三个主要作用:

1. 数据安全性：当发生系统崩溃时，InnoDB 从 redo log 取出未完成的操作，重新构造数据。这样就保证了数据的安全性。

2. 效率：磁盘 I/O 操作是十分耗时的，redo log 可以缓冲这些操作，批量执行。

3. 复制：当使用主从复制时，如果主服务器发生异常，需要依赖 redo log 来恢复数据，保证数据的一致性。

InnoDB 的 redo log 是一个固定大小的循环日志文件，文件名默认为 ib_log{number}. redo log 文件以固定大小扩展。当 redo log 文件写满时，另起一个新的 redo log 文件。当多个事务操作同一张表时，这些事务的 redo log 会追加到同一个文件中。

Redo log 分为两类：

1. 物理 redo log （重做日志）：记录的是记录更新的数据改动。通过调用 os_file_write() 接口写入 redo log ，一次性写入内存 buffer，先写 redo log 文件，最后再刷新到磁盘。

2. 逻辑 redo log （重做日志缓冲区）：记录的只是操作的逻辑信息，比如数据页号、offset、长度、类型等，一次性写入 redo log 文件中。

Redo log 打开后，每当有事务提交时，首先会记录操作信息（如事务 ID、数据页号、回滚指针等）到 redo log 搭配的逻辑 redo log 缓冲区中。随后，会通知 InnoDB “提交”线程将 redo log 的数据写入到物理 redo log 中。Redo log 写入到物理 redo log 中后，事务就算提交完成。当出现 crash 时，可以通过 redo log 对数据进行恢复。

### 2.3.2 Undo Log 详解
Undo log 也是 InnoDB 为保证事务的一致性而提出的一种技术。其工作原理是在事务开始之前，将旧数据备份到 undo log 中，当事务提交失败或回滚时，利用 undo log 中的备份数据快速地进行回滚。

Undo log 有以下几个作用：

1. 事务回滚：当事务回滚时，利用 undo log 中的备份数据快速地进行回滚。

2. MVCC（多版本并发控制）：MVCC 通过版本链和 undo log 来支持并发读取。当读取某一行数据时，并不需要去读取最新版本的数据，而是根据历史版本的数据记录来定位并读取指定版本的数据。

3. 恢复丢失的数据：当备份数据被清理或损坏时，利用 undo log 中的备份数据可以帮助 DBA 快速恢复丢失的数据。

4. 数据可压缩性：通过将数据删除记录到 undo log 中，使得数据文件整体空间占用减少，有效的节省磁盘空间。

InnoDB 使用插入 undo 和更新 undo 来实现 undo log 。

插入 undo ：当插入一条记录时，InnoDB 会为这条记录生成一个 undo 记录，用来记录这条记录之前的旧值。

更新 undo ：当更新一条记录时，InnoDB 会为这条记录生成一个 undo 记录，用来记录这条记录的旧值。同时，InnoDB 会为这条记录生成对应的 redo 记录，用来记录这条记录的新值。当这条记录被回滚时，可以通过 redo 记录恢复更新前的旧值，并再次应用到记录上。