
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、栈（Stack）简介
栈(stack)又称为堆栈，是一种线性存储结构。它的特点是先进后出（Last-In First-Out），即最后进入的元素最先被释放掉。栈顶端提供一个插入（push）操作，另一端提供一个删除（pop）操作，所以它也叫做 Last-in-First-out （LIFO）。它可以用于各种场景下的数据处理，如函数调用的历史记录、表达式求值、文件管理、回文判断等。

## 二、队列（Queue）简介
队列（queue）是一种特殊的线性表，元素按照顺序排列，插入时在队尾加入元素，删除时在队头删除元素。队列的操作方式与栈类似，都是先进先出。但是，不同的是队列具有先进先出的特征，而栈具有后进先出的特征。队列主要应用于多道批次处理、任务调度、消息传递、并发环境中线程之间的通信等方面。

## 三、优先队列（Priority Queue）简介
优先队列（priority queue）也称作高速缓存（cache），是一种特殊的队列，它是一种经过排序的集合。一般来说，优先队列中的元素从最小到最大或从大到小进行排序。优先队列的插入和删除操作的时间复杂度都为 O (log n)。因此，优先队列非常适合用在基于比较关系的排序算法中，如快速排序。

## 四、集合（Set）简介
集合（set）是一个不允许重复元素的无序且无索引的数据结构。它提供了一个对某些数据进行快速查询、删除和计算的方法。集合中的元素是唯一的，没有重复的元素，并且每个元素都是独一无二的，因此可以轻易地判断两个集合是否相等。集合通常用于进行快速的查找和检查，比如判断某个字符串是否已经出现过，或者确定某张图片里的颜色种类。集合是一种抽象数据类型（Abstract Data Type，ADT），是由一个个元素组成的集合，集合中的元素是无序的，不能通过索引访问。

## 五、散列表（Hash Table）简介
散列表（hash table）是一种存储键值对的数据结构。它利用了哈希函数将键映射到数组的索引上，使得查找、插入和删除效率都很高。哈希函数是一种从键（key）计算出整数索引值的函数。当需要定位数据时，只需对键求哈希值，然后根据哈希值直接得到存放数据的数组位置，再从该位置取出数据即可。这种方法使得查询、插入和删除的平均时间复杂度都为 O (1)。散列表的另一个重要特性是支持动态扩容，方便在数据量增长时自动增加内存空间，从而提升性能。

## 六、树形结构（Tree Structures）简介
树形结构包括二叉树、搜索二叉树、平衡二叉树、红黑树、B-树、B+树、AVL树、伸展树、B/B+树等。这些数据结构都属于非线性数据结构，利用树形结构可实现对元素的动态查询、插入、删除。例如，搜索二叉树可以在 O (log n) 的时间内找到某个元素，红黑树能保持平衡性，保证插入和删除操作的 O (log n) 时间复杂度。

# 2.核心概念与联系
## 一、栈与队列的区别
栈是先进后出，队列是先进先出。两者的结构差异导致它们各自擅长解决不同的问题，但也存在一些共同点。

1. 操作方式：栈只能在一端插入和删除元素，只能从另一端弹出；而队列则是两端都可以进行插入和删除操作。
2. 是否阻塞：栈为空时，peek() 和 pop() 操作会报错；而队列为空时，dequeue() 操作会报错。
3. 元素个数限制：栈可以设置大小，超出大小后就不能再添加新的元素，否则报错；而队列的大小是没有限制的。
4. 优先级：栈的操作都是 FILO（先入后出），因此先进的元素优先被弹出；而队列操作前面的元素都是先进先出，因此先进的元素优先被取出。
5. 应用领域：栈主要用于函数调用、递归，主程序最后一次执行完成；队列主要用于多生产者 - 消费者模型，数据可在多个任务间共享。

## 二、优先队列、散列表、树形结构的对应关系
|  优先队列 |  散列表   |  树形结构  |
| ------------ | ---------- | ------------- |
| 插入元素      |  添加元素   |  添加节点       |
| 删除元素      |  删除元素   |  删除节点        |
| 查找最小/大值 | 通过索引取值  | 从根节点开始遍历   |

优先队列与散列表分别负责按顺序维护元素顺序，而树形结构则侧重于快速查找。集合也可以看作一种特殊的树形结构，其中所有节点的值均相同。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 一、栈（Stack）
栈是一种线性数据结构，其特点是后进先出。栈中的元素只能在一端添加，移除；栈顶元素之后的所有元素都会被推出。栈常用的操作有：

- push()：向栈顶插入一个元素；
- pop()：删除栈顶元素；
- peek()：返回栈顶元素；
- isEmpty()：判断栈是否为空；
- size()：返回栈的大小；

对于栈，一般来说，不需要在栈中分配内存，因为是在运行过程中自动分配内存。当申请的栈空间耗尽时，操作系统会抛出异常表示“栈溢出”，提示程序员进行扩容。

### 模型：

栈的模型主要分为两种：顺序栈（Array Stack）和链式栈（Linked Stack）。

#### 顺序栈（Array Stack）

顺序栈是栈的一种实现，采用数组的方式来存储数据。具体实现过程如下图所示：


从图中可以看到，顺序栈底部有一个指针 `top`，指向栈顶元素。当向栈中插入一个新元素时，首先判断栈是否已满，若满，则提示栈溢出，否则将元素放入栈顶，并更新 `top` 指针。当需要删除栈顶元素时，需要先判断栈是否为空，若空，则提示栈空，否则先得到栈顶元素，然后将栈顶元素的值置零，并移动 `top` 指针。其他操作基本一致，故不再赘述。

#### 链式栈（Linked Stack）

链式栈是栈的另一种实现，采用链表的方式来存储数据。具体实现过程如下图所示：


从图中可以看到，链式栈底部依然有一个指针 `top`，但这个指针并不是指向具体的元素，而是指向当前栈顶节点的指针。当向栈中插入一个新元素时，首先创建一个新节点，然后将这个新节点链接到栈顶节点的下一个节点，最后将栈顶节点的下一个节点指向新建的节点。当需要删除栈顶元素时，只需要将栈顶节点的下一个节点作为栈顶节点，并将之前栈顶节点的引用指向新的栈顶节点，栈就删除了第一个元素。其他操作基本一致，故不再赘述。

### 示例：括号匹配

栈的典型应用就是括号匹配的问题。给定一个表达式，判断它是否满足所有的括号匹配规则。

#### 方法一：栈模拟

为了能够检测出所有括号匹配错误，这里选择栈这一数据结构。具体实现步骤如下：

1. 创建一个空栈 stack；
2. 使用输入表达式中的字符逐个扫描；
3. 当遇到左括号 '{' 或 '[' 或 '(' 时，压入栈中；
4. 当遇到右括号 '}' 或 ']' 或 ')' 时，从栈中弹出一个元素，如果此右括号与栈顶元素相匹配，则继续扫描，否则打印括号匹配错误信息并结束扫描；
5. 如果表达式扫描完成且栈中还有余下的元素，则说明表达式中还有未匹配的括号，打印括号匹配错误信息。

```python
def isMatch(self, s: str) -> bool:
    # 创建空栈
    stack = []

    # 使用输入表达式中的字符逐个扫描
    for c in s:
        if c == '{':
            stack.append('}')
        elif c == '[':
            stack.append(']')
        elif c == '(':
            stack.append(')')
        else:
            if not stack or c!= stack.pop():
                return False

    # 如果栈中还有余下的元素，则说明表达式中还有未匹配的括号
    return len(stack) == 0
```

#### 方法二：栈的特性

我们可以分析一下栈的特性。

- 在入栈操作时，栈顶指针 `top` 向下移动一个单位，而栈顶单元保存着新的元素。
- 在出栈操作时，栈顶指针 `top` 向上移动一个单位，同时栈顶元素的值也随之消失。
- 当栈顶指针 `top` 指向空单元时，栈为空。

因此，当遇到左括号 `{`、`[`、`(` 时，栈顶指针 `top` 可以向下移动一个单位，并将此括号保存到栈顶单元中。当遇到右括号 `}`、`]`、`)` 时，栈顶指针 `top` 可以向上移动一个单位，并将此括号从栈顶单元中弹出。

这样，当扫描到对应的括号时，可以判断是否匹配，如果栈顶元素和当前字符相等，则匹配成功，此时栈顶指针 `top` 向上移动一个单位，如果不匹配，则输出括号匹配错误信息，终止扫描。

```python
def match(char):
    if char == '}':
        return '{'
    elif char == ']':
        return '['
    elif char == ')':
        return '('
    else:
        return None

def isValid(s: str) -> bool:
    # 创建空栈
    stack = []
    
    # 使用输入表达式中的字符逐个扫描
    for char in s:
        top_char = match(char)
        if top_char and stack[-1] == top_char:
            stack.pop()
        else:
            print("Invalid expression")
            return False
            
    # 如果栈中还有余下的元素，则说明表达式中还有未匹配的括号
    if stack:
        print("Invalid expression")
        return False
        
    return True
```