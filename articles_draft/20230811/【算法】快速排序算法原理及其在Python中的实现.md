
作者：禅与计算机程序设计艺术                    

# 1.简介
         

快速排序（Quicksort）是对冒泡排序、插入排序和选择排序三种简单排序算法的一种改进。快速排序的平均时间复杂度为 O(nlogn)，空间复杂度也为 O(1)。

本文将以 Python 的语言进行快速排序的实现和分析。并且通过分析与实践，能够帮助读者了解快速排序的工作原理及其应用场景。

作者：邓紫棋
编辑：雷樱 
# 2.基础概念和术语
## 2.1 数组
首先，我们先理解一下什么是数组。数组是一个线性表数据结构，它用一组连续的内存空间存储元素。在计算机中，数组通常是由若干个相同类型的数据元素按照顺序排列在一起，方便计算和访问。

举一个简单的例子，假设我们要记录 5 个班级的学生姓名、成绩等信息，就可以将这些信息用数组表示如下：

```python
classmates = ['Tom', 'Alice', 'John', 'Mike', 'Bob']
scores = [95, 78, 90, 87, 68]
```

可以看到，数组 classmates 和 scores 中分别存放了 5 个班级的学生姓名和成绩。数组的第一个元素称为索引 0，第二个元素索引为 1，依此类推。

## 2.2 分治策略
分治策略是指将待解决的问题划分成多个子问题，然后各自递归地求解，最后再合并得到完整的结果。

对于快速排序，分治策略是利用“分而治之”的方式来实现的。它的基本思路是选定一个基准值或关键码，然后将数组按该值划分成两个子数组，左边都小于等于该值，右边都大于等于该值。接着递归地对这两个子数组进行快速排序，直到子数组只有一个元素为止。最后再把两部分数组合并起来，得到整个数组有序的结果。

```python
def quick_sort(arr):
if len(arr) <= 1:
return arr

pivot = arr[len(arr)//2]
left = [x for x in arr if x < pivot]
middle = [x for x in arr if x == pivot]
right = [x for x in arr if x > pivot]

return quick_sort(left) + middle + quick_sort(right)
```

以上是快速排序的递归算法模板。该函数接收一个数组 arr，判断长度是否小于或等于 1；如果小于或等于 1，则直接返回该数组，因为它已经有序了；否则，取数组中间位置的值作为枢轴 pivot，然后用列表推导式从 arr 中筛出三个新的子数组，左边的都小于等于 pivot，中间的都等于 pivot，右边的都大于 pivot。然后递归地调用 quick_sort() 函数处理左右两个子数组，并将三部分连接起来，就得到了整个数组有序的结果。

## 2.3 时间复杂度分析
快速排序的时间复杂度分析依赖于两个重要的数学定理。第一个定理是三次概率比的渐近证明，它给出了一个对任意输入随机分布均匀的情况下，三个不同大小的输入序列的平均比较次数之间的关系。第二个定理是期望不等式，它给出了多项式时间的界。

### 2.3.1 三次概率比定理
为了能够证明快速排序的时间复杂度，需要先对算法的运行过程做一些分析。快速排序的主要操作是在数组上分割成两个子数组，并保证左边的元素都小于等于基准值，右边的元素都大于等于基准值。

我们可以通过统计排序过程中交换和赋值的次数，来估计快速排序的时间复杂度。对于某个大小为 n 的数组，一次分割操作之后，平均交换和赋值次数分别为 k1 和 k2。假设每次交换或赋值的概率相等，且满足 0 ≤ p ≤ q ≤ 1，那么快速排序的平均时间复杂度为 T(n)=Θ(n^2)。

```python
P(k1>k2|n,p,q) ~ pq+qp-p^2   # 三次概率比定理
T(n) ≈ c*n^d                  # 根据期望不等式

=> d=2,c≥pq/((1-p)*(1-q)^2), c 是系数。
```

上面这个等式表明，当输入的随机分布相对均匀时，快排的时间复杂度是 O(n^2)。

### 2.3.2 期望不等式
期望不等式（Little's theorem of averages）又被称为“随机变量的期望值的几何级数逼近定理”，描述的是两个随机变量关于某些条件独立时的期望值之间的关系。

假设 X 和 Y 是两个随机变量，其期望值分别为 μ(X) 和 μ(Y)，它们的方差分别为 σ^2(X) 和 σ^2(Y)。假设 Z=g(X,Y) 是一个关于 (X,Y) 的函数，且满足 Φ(Z)=μ(Z) 且 P(Z>=z)=P(X>=ux)+P(X<ux)P(Y>=uy)+P(Y<uy) 。其中 u=(ux,uy) 为 Φ^{-1}(z) 的某个函数值，Φ 为积分函数，φ(z)=E(e^{t(z)}) 。由于 Z 与 X 和 Y 有关，所以有 E(Z | X,Y) = E(Z | X)*E(Z | Y)，且根据期望不等式，可得：

```python
Var(f(X)) ≤ Var([f(X)+g(Y)]) + Var(g(Y))        # 期望不等式1
Var(X) ≤ μ(σ^2(X))+√[Var(X)+Var(Y)]             # 期望不等式2
```

第一条等式表明，方差的下界是由方差相加和方差的下界所决定的；第二条等式表明，方差的下界取决于随机变量的平均值和方差之和的平方根。

考虑这样的情形：假设有两个随机变量 A 和 B，它们的期望值分别为 a 和 b，方差分别为 α^2 和 β^2。另外假设有一个函数 C(A,B) ，满足以下三个条件：

1. 满足条件 Φ(C(A,B))=a·b
2. 对所有 (u₁,v₁),(u₂,v₂) 均有 P(C(u₁,v₁)>a·b-α^(1/2)(u₁-u₂)-β^(1/2)(v₁-v₂))≤ϕ
3. 对所有 (u₁,v₁),(u₂,v₂) 均有 P(C(u₁,v₁)<a·b+α^(1/2)(u₁-u₂)+β^(1/2)(v₁-v₂))≤ϕ

其中 ϕ 为某个正数，ϕ(1-ϕ) 为任意的概率质量函数。假设 Y=C(X,X) 是关于 X 的函数，且满足 Φ(Y)=ab 。利用期望不等式，有：

Var(Y) ≤ ab·[(Var(X)+a+b)/2]^2     # 期望不等式3

上面这一步只是为了证明后面的条件，并没有计算出 γ=Var(X)/(2ab)，因为这个值需要用到期望不等式 2 中的方差下界。事实上，γ 可以从条件 (2) 中推导出，但用到了乘法和除法，因此会使计算变得复杂。

假设 X 和 Y 都是服从某一分布 D 的随机变量，且满足 Σij=i·j/(i+j-1)Σij。记 ξi=D(1/n…(i+1)/n) 为第 i 个平均数，那么有：

Var(X) ≤ ∏1≤i≤n∑1≤j≤n∑ij/[(i+j-1)/2]^2 Σijξi^2

这里 δij 为 Delta function，δij=1 如果 ij 不相关，0 反之。由 Markov–Lemma 知 Σij=i·j/(i+j-1) 就是相关系数矩阵。

由于 Σij=i·j/(i+j-1) 且 δij 只依赖于 i 或 j，因此有：

Var(X) ≤ ∑ijδij[(1/i+1/j+(i+j-2)/(i+j-1))/2]^2 [(Σ1iξi)^2+(Σ1jξj)^2-(1/i+1/j+(i+j-2)/(i+j-1))]

现在假设存在另一随机变量 U 和 V 与 X,Y 相关，且满足：

Σuv=sum_{i=1}^n{sum_{j=1}^n{(i+j-1)*D(ij)}}Σuv≥∑ijδij

且 ΣuiΔj(i,j)>0，ΣujΔi(i,j)>0。因此，有：

Var(U+V) ≤ ∑ijδij[(1/i+1/j+(i+j-2)/(i+j-1))/2]^2 [(Σ1iξi)^2+(Σ1jξj)^2-(1/i+1/j+(i+j-2)/(i+j-1))]
+∑ijδij(i+j-1)[δij+δji]/[(i+j-1)^2]+∑ijδij[(i+j-1)^(-1)*(i+j-2)+(i+j-1)]/[(i+j-1)^2]*[δij*(1-δij)+δji*(1-δji)]

这里 δij*(1-δij) 表示 δij^2 次方减 1 的商。由 ΣuiΔj(i,j)>0，ΣujΔi(i,j)>0 可知上式第三项及第四项分别为 0 或 δij*(i+j-1-δij-δji) 。因此有：

Var(U+V) ≤ ∑ijδij[(1/i+1/j+(i+j-2)/(i+j-1))/2]^2 [(Σ1iξi)^2+(Σ1jξj)^2-(1/i+1/j+(i+j-2)/(i+j-1))]
+∑ijδij*(i+j-1)*δij*(1-δij)*(1-δji)/[(i+j-1)^2]*[(i+j-1)^(-1)*(i+j-2)+(i+j-1)]

上式是关于 X,Y,U,V 的方差的无偏估计，也就是说，它仅依赖于 X,Y 和 δij 而不是 U,V，而且仍然是常数。因此，方差的下界 Var(Y) 的表达式也可以改写为 Var(Y|δij)+Var(U+V)-∑ijδij[(1/i+1/j+(i+j-2)/(i+j-1))/2]^2 [(Σ1iξi)^2+(Σ1jξj)^2-(1/i+1/j+(i+j-2)/(i+j-1))]

代入条件 (3) 中可知：

Var(Y|δij)≤[(1-δij)^2σ^2(X)]/[2n(n-1)]           # 上式的等号成立当且仅当 δij=0
Var(U+V)-∑ijδij[(1/i+1/j+(i+j-2)/(i+j-1))/2]^2 [(Σ1iξi)^2+(Σ1jξj)^2-(1/i+1/j+(i+j-2)/(i+j-1))]
≤ [(1/n+...+1/2n-1)^2-(1/n+...+1/(2n-1))*[(2n-1)/2^((2n-1)/2)]]^2σ^2(X) 

于是，Var(Y|δij)≤Var(U+V)-∑ijδij(1/i+1/j+...)-[(2n-1)/2^((2n-1)/2)]σ^2(X)         
Var(Y)≤2Var(U+V)-∑ijδij(1/i+1/j+)-(n-1)σ^2(X)                         
Var(Y)≤2Var(U+V)-∑ijδij(1/i+1/j)-(n-1)Var(X)                         (对任意 δij=0)

设 Var(U+V) 为 cu^2+d，则 Var(Y) ≤ c(n-1)σ^2(X)+(dn^2+dvar(X))/n      （n>=3，于是 σ^2(X)>0）

由期望不等式 3，Var(Y) ≤ [ab·[(Var(X)+a+b)/2]^2+(ab^2σ^2(X)+(n-1)σ^2(X))/n]  (对任意 δij=0)

于是，Var(Y) ≤ [(ab+nσ^2(X))/n]^2 Var(X)+(ab^2σ^2(X)+(n-1)σ^2(X))/n     (对于任意 δij=0)

记 G=ab+nσ^2(X)/n，即快速排序的期望比较次数。由于 n 大于等于 10，所以上述算式右端第二项的上界为 O(1) 。设 u=(ux,uy) 为 Φ^{-1}(z) 的某个函数值，则：

G≤λu^2=[λ²·(var(X)+2u·sqrt(var(X)))/(nσ^2(X)/n)]

于是，G≤λu^2·(nσ^2(X)/n)       # 归纳假设，即 λ=sqrt(2/3)

于是，当 n 大于 10 时，G≤2/3·nσ^2(X)                     (n>=10)

又由于 var(X)≤Var(X)≤∏1≤i≤n∑1≤j≤n∑ij/[(i+j-1)/2]^2 Σijξi^2，即 var(X) 的下界至多是 Var(X) 的 1/3，所以 G≤2/3·nVar(X)         (n>=10)

因此，快速排序的时间复杂度为 O(nlogn) 当且仅当 n>=10。