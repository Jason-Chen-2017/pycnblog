                 

# 1.背景介绍


拓扑排序(Topological Sorting)是用来对有向图中的顶点进行排序，使得图中任意两个顶点间都存在路径，或者在排序后的序列中不存在任何回路（Cycle）。拓扑排序方法是在图论中的一种排序算法，常用于数学、工程等领域。
# 2.核心概念与联系
## 2.1 拓扑排序的定义及其应用场景
> **拓扑排序** 是对一个有向无回路图(DAG, Directed Acyclic Graph)中的所有顶点的线性序列。该序列满足如下性质：
> 1. 每个顶点出现且只出现一次。
> 2. 如果存在一条从顶点 $u$ 到顶点 $v$ 的边，那么 $u$ 在序列中出现在 $v$ 的前面。

拓扑排序可以应用于多种实际的问题中：

1. 编译器的依赖分析。依赖关系图可能是DAG，因此可以使用拓扑排序进行排序，输出每个顶点的编译顺序。
2. 课程表的安排。课程之间可能存在先修关系，因此可以使用拓扑排序进行课程的安排，输出每个学生应该上哪些课。
3. 任务调度。有向无环图代表了任务之间的依赖关系，因此可以使用拓顶排序进行任务调度，将任务按序执行。

## 2.2 拓扑排序的两种实现方式
拓扑排序既可以用深度优先搜索(DFS)，也可以用广度优先搜索(BFS)。

### DFS实现法
这种实现方式比较简单，也经常被采用。其基本思路是：从所有入度为0的节点出发，进行深度优先遍历。遇到的第一个入度为0的节点即为输出的第一个元素，然后将该节点的所有邻居的入度减1，如果某个邻居的入度变成了0，则将它加入队列中，重复上面操作直至队列为空或当前输出序列的长度达到总结点个数。这种方式的时间复杂度是O(n+m)，其中n是节点数，m是边数。

### BFS实现法
这种实现方式时间复杂度比DFS稍好，因为需要多次访问相同的节点。其基本思路是：将所有顶点放入队列，然后逐层对队列中的顶点进行遍历，每当处理完某个顶点后，将它的所有出边指向的结点的入度减1。当队列中的结点入度变为0时，将它们加到输出序列的尾部。这样做的原因是：相比于DFS，BFS能够更快地跳过一些结点。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 3.1 拓扑排序算法的基本步骤
首先，建立一个有向无回路图。然后，按照以下步骤进行排序：

1. 从图中选择一个没有前驱的顶点并输出。（此时图中至少有 n 个顶点，并且只有 n-1 条边）
2. 删除该顶点及其相关联的边。（由于所选出的顶点不再存在前驱，因此其所有邻接点的入度均减1；因此图中最多有 n-1 条边）
3. 对剩下的图重复步骤 1 和 2 ，直到所有顶点都输出或者图中不存在可输出的顶点。

步骤 1 和 2 构成了拓扑排序算法的主要过程。为了证明这一结果正确，需要引入两个重要概念：**等待边** 和 **加入边**。

### 概念：等待边
在拓扑排序算法过程中，若顶点 $v$ 的入度为 $d$，则称 $\delta (v)$ 为该顶点的等待边数目，即 $\delta (v)=d$ 。等待边是指指向该顶点的边的数量等于其入度。

### 概念：加入边
在拓ор置算法过程中，若顶点 $u$ 指向顶点 $v$ ，而边 $(u, v)$ 不属于图中已输出的边，则称 $(u, v)$ 为加入边。

## 3.2 拓扑排序的两种实现方式的区别及优缺点
### DFS实现法
DFS实现法中，对于某个顶点 $v$ ，其邻居节点的入度永远等于零或一个，所以可以将它输出并删除。因此，整个算法的时间复杂度为 $O(n+m)$ ，其中 $n$ 表示节点个数，$m$ 表示边数。

DFS实现法的优点是易于理解和实现。缺点是存在着许多反复处理相同节点的情况，因此效率较低。

### BFS实现法
BFS实现法中，对于某个顶点 $v$ ，其邻居节点的入度一定等于零或一个，所以可以将它输出并删除。因此，整个算法的时间复杂度为 $O(n+m)$ ，其中 $n$ 表示节点个数，$m$ 表示边数。

BFS实现法的优点是可以在 $O(\lceil\frac{n}{k}\rceil+\sum_{i=1}^{k}a_ik^ia_ik^{k-1}$ ) 时间内解决，其中 $k$ 为插入序列的平均长度。

# 4.具体代码实例和详细解释说明
## 4.1 DFS实现算法的代码示例
```python
def topological_sort_dfs(graph):
    visited = set() # keep track of visited nodes in a set
    stack = [] # use a stack to implement the depth first search
    
    def dfs(node):
        if node not in visited:
            visited.add(node)
            
            for neighbor in graph[node]:
                dfs(neighbor)
                
            stack.append(node)
            
    for vertex in graph:
        if vertex not in visited:
            dfs(vertex)
        
    return stack[::-1] # reverse the order to get the correct output sequence
```
## 4.2 BFS实现算法的代码示例
```python
from collections import deque 

def topological_sort_bfs(graph): 
    indegree = {key: 0 for key in graph}

    for u in graph: 
        for v in graph[u]: 
            indegree[v] += 1 

    queue = deque([u for u in graph if indegree[u] == 0]) 

    result = [] 

    while queue: 
        u = queue.popleft() 

        result.append(u)

        for v in graph[u]:
            indegree[v] -= 1

            if indegree[v] == 0: 
                queue.append(v) 

    if len(result)!= len(graph): 
        raise Exception("The input is not a DAG!") 

    return result[::-1] # reverse the order to get the correct output sequence
```