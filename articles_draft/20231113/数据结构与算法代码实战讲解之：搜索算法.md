                 

# 1.背景介绍


## 概述
搜索算法又称为检索算法或定位算法，它是信息检索中最基本的算法之一。其基本功能是在一个集合或列表中查找符合特定条件的数据元素，并返回其位置（索引）或者具体的值。

在信息检索领域，各种各样的搜索算法被广泛应用，如：模糊匹配、字符串搜索、排序搜索等。其中，最著名的、应用最为广泛的搜索算法有：哈希表搜索法、顺序查找法、二分查找法、二叉树搜索法、插值搜索法、斐波那契搜索法、Ternary Search算法、KMP算法、AC自动机算法、线性搜素算法等。

本文将主要介绍的是几种常用搜索算法，包括顺序查找、二分查找、KMP算法、AC自动机算法、Ternary Search算法、线性搜索算法等。这些算法的特点、优缺点及应用场景都会一一进行分析，并给出相应的代码实现。希望通过对搜索算法的了解和理解，读者能够更好地运用搜索算法提高编程能力。

# 2.核心概念与联系
## 二分查找
### 定义
二分查找(Binary search)是一种在有序数组中查找指定元素的有效方法。它首先确定数组中间值的下标，然后判断该下标对应的值是否等于指定元素，若相等则查找成功；否则，若指定元素小于中间值的下标对应的值，则只需重复前两步，反之，则需要重复后半部分。这种方法能在最坏情况下减少比较次数从而达到线性时间复杂度。

### 插入排序 vs 二分查找
当要搜索的元素已排好序时，可以采用插入排序算法，效率更高。但如果不排好序的话，也可以使用二分查找算法，但二分查找算法更适合大规模数据的搜索。

### 算法过程
二分查找算法的基本思路如下:

1. 查找区间的左端点low=0，右端点high=n-1；
2. 如果数组为空，或查找值大于数组所有元素的值，则返回"无此元素"；
3. 将mid=(low+high)/2计算出中间的下标；
4. 如果查找值等于中间元素的值arr[mid]，则返回mid；
5. 如果查找值小于中间元素的值arr[mid]，则更新high=mid-1；
6. 如果查找值大于中间元素的值arr[mid]，则更新low=mid+1；
7. 重复第3~6步，直至找到查找值或 low>high 为止；
8. 返回low或high的值，即为查找元素的下标；
9. 当找到查找值时，low=high，否则循环结束；

### 时间复杂度
二分查找算法的时间复杂度是 O(log n)，其中 n 是待查序列的长度。因为每次都可以排除掉一半的记录，所以总体花费的时间比顺序查找略短一些。

## KMP算法
### 定义
KMP算法（Knuth-Morris-Pratt algorithm）是用于主串和模式串匹配的Substring searching算法，由D.E.Knuth、J.H.Morris 和 R.P.Pratt在1977年共同发现。这个算法是基于前缀函数的概念。

前缀函数f(i)=j表示，以s[0],s[1],...,s[i-1]结尾的子串的最大的前缀和后缀是相同的，并且长度为j。例如，对于字符串ababaca，它的前缀函数为：

```
prefix = [0,0,1,2,0,1,2]
```

我们先看一下例子，再讨论KMP算法。

### 示例
假设有两个字符串："hello world" 和 "hola mundo", 我们想找到第一个出现在第二个字符串中的单词。下面通过KMP算法解决这个问题。

1. 创建两个列表`p=[]`和`t=[1]` ，分别用来保存模式串`pat`和目标串`txt`。
2. 通过循环遍历整个目标串`txt`，遇到模式串`pat`中的字符，则把当前指针`i`放入列表`t`。比如`txt='hello'`，`pat='hel'`, `t=[1,2]`；`txt='hell'`, `pat='ello'`, `t=[1,2,3]`；`txt='hello'`，`pat='l'`, `t=[1,2,3,4]`。
3. 判断模式串`pat`的长度是否大于当前指针`i`，如果是的话，则删除`t`最后一个元素，使得其长度恢复为模式串的长度。比如`txt='hello w'`, `pat='llo wo'`, `t=[1,2,3,4]`。
4. 用循环遍历模式串`pat`，根据前缀函数创建索引列表`p`。比如`pat='ello'`, `prefix = [0,0,1,2]`，那么`p=[0,2,0,3]`。
5. 用索引列表`p`和模式串`pat`执行对比，最终结果为`[1,2,3]`。
6. 根据索引列表`p`和目标串`txt`执行对比，最终结果为`['he', 'l']`。
7. 从上面的过程可以知道，模式串`pat`对应的索引列表`p`可以通过前缀函数求得。另外，如果输入的目标串`txt`没有找到匹配的模式串`pat`，则输出空列表`[]`。

### 算法过程
KMP算法的基本思路如下:

1. 初始化一个空列表`p`，用来存储模式串`pat`的前缀函数`prefix`。
2. 设置`j`为0，用来表示模式串`pat`的起始位置。
3. 循环遍历模式串`pat`，直到`j`大于等于`len(pat)`，跳出循环。
   - 如果当前模式串`pat`中有字符不在字符集`A={a,b}`中，则跳过该字符。
   - 设置`q=prefix[j]`，表示当前模式串`pat[:q+1]`的最大前缀和后缀是相同的。
   - 把`q+1`存入`p`，表示前缀函数的第一个值。
   - 更新`j`为`j+1`。
4. 返回`p`，表示前缀函数。
5. 使用前缀函数和模式串`pat`执行对比。
    - 如果`pat`的长度大于当前指针`i`，则跳过`t[-q-1]`。
    - 如果`pat`的长度等于当前指针`i`，则进行对比。
        - 如果`pat`和`txt`的相应位置上的字符相等，则更新指针`i`，否则跳转回`p[q+1]`。
6. 在对比过程中，如果模式串`pat`的所有字符都被完全匹配到了，则匹配成功，否则失败。

### 时间复杂度
KMP算法的时间复杂度是 O(m + n)，其中 m 和 n 分别是模式串和目标串的长度。主要原因是循环遍历了一次模式串，寻址了 n 个字符，所以时间复杂度为 O(n)。另外，也不需要像其他算法一样预处理所有的模式串前缀函数，这样内存消耗也很小。

## AC自动机
### 定义
AC自动机（Aho-Corasick automation）是为了解决在一组字符串集合中快速检测某一个字符串是否存在于这个集合的问题。所谓“快速”就是指可以在多次搜索时期望具有线性时间复杂度。AC自动机算法根据AC自动机字符串集合的特点构建出一棵树，每一个节点代表一个状态，边代表状态转换。通过树结构的层次遍历，可以判断任意一个字符是否属于某个字符串集合。AC自动机算法的主要作用在于加速子串的匹配速度。

### 基本思路
AC自动机算法利用了 trie 树的结构。trie 树是一种典型的多叉树结构，每个节点表示一个字符或者空格，树中的每一条路径都表示了一个字符串。因此，我们可以利用 trie 树的结构建立一个字典树。

构建完字典树之后，我们遍历目标串，从根结点开始，按照字典树的层次遍历方式依次匹配。如果能够匹配到终止状态，则判断是否命中。否则，继续向下遍历。通过这种方式，我们可以快速判断一个串是否出现在某个字符串集合中。

### 操作流程
1. 构造字典树。
    - 构造字典树的过程类似于上节中介绍的 KMP 算法，主要做三件事情：
      - 记录状态转移的情况。
      - 把每个节点加入相应的状态中。
      - 标记状态是否为叶节点。

    每个节点的结构如下：

        struct Node {
            bool isEnd; // 是否是叶子节点
            unordered_map<char, int> next; // 下一个节点
            vector<int> status; // 状态集
        };
    
2. 遍历目标串。
    - 对目标串的每一个位置 i，根据字典树的层次遍历方式，依次遍历字典树，直到找到叶子节点。
      - 当前位置匹配状态：根据字典树的结构，当前位置 i 的状态是它的父节点的某条边对应的状态。
      - 下一个状态：从当前状态开始，尝试按字典树的结构，转移到下一个状态。如果无法转移，则返回 root 节点。
      - 添加到状态集：将当前位置 i 所在的状态添加到状态集中。
      
    - 如果字典树的匹配到了目标串的所有字符，则认为命中。

3. 输出结果。
    - 如果命中，则输出命中的字符串。
    - 如果未命中，则输出空列表。