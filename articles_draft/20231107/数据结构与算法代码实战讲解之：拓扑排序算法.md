
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 拓扑排序
拓扑排序（英语：Topological sorting），是指对一个有向无环图（DAG, Directed Acyclic Graph）进行排序的过程。它要求找出这个有向图中所有顶点的一个线性序列，使得每一条边第一个顶点都在它的后面。这条线性序列被称为拓扑序列或顺序序列。

例如，假设有一个项目管理系统，该系统由多个任务组成，每个任务又依赖于其他任务，则可以用有向无环图表示这些关系。每个顶点代表一个任务，若两个任务之间存在依赖关系，则从前者指向后者；否则，这两个任务之间没有约束关系。如果将所有的任务视为顶点，并且找出任意一个顶点的入度为零，那么该顶点可以加入到序列当中，直到所有顶点都属于某一序列后，才能结束排序。

实际上，拓扑排序不仅适用于有向图，而且还可以用来处理树型图、二叉树等各种数据结构。因此，可以把它们看作是特殊形式的DAG。

## 相关术语
- 有向图：由有向边连接的一组节点构成的图形结构。
- DAG(Directed Acyclic Graph)：有向无环图，即不含回路的有向图。
- 次数：在一组元素中，出现相同元素的次数。
- 拓扑序：一组顶点的线性序列。
- 路径长度：从源顶点到终止顶点经过的边数。
- 无后效性：只要输入的DAG没有自环，则输出的顶点序列一定是唯一的。换句话说，拓扑排序不会改变原图的任何子集，也不会影响其他图的排序结果。
- 稳定性：保持图中顶点的相对顺序。

# 2.核心概念与联系
本节主要介绍一些重要的概念和算法术语。
## 有向图
有向图G=(V,E),其中V是顶点集合，E是边的集合。边e=(u,v)，其中u和v都是V中的顶点，e表示从顶点u到顶点v的一条有向边。
## DAG
DAG(Directed Acyclic Graph)是指没有回路的有向图。简而言之，就是有向图，其中不存在通向回头的边，换句话说，每个顶点都可以从其他顶点到达，但是不能回头。DAG定义了一种先后发生的关系，这种关系可以用于表示有向事件的执行顺序。比如，某个项目，从开始到完成过程中所需的所有任务之间的依赖关系。
## 有向无环图
有向无环图(DAG)是一个有向图，其中不存在回路（循环）。换句话说，从任意一个节点出发，都无法再回到它之前的状态。对于DAG而言，可能有多种拓扑序列，但只有一种正确的拓扑序列。拓扑排序是一种对DAG的排序算法，其目标是在给定的DAG中，找出一个线性序列，满足条件：如果存在一条边uv，那么顶点u应该在顶点v的前面。一般情况下，DAG具有以下几个特点：

- 有向图；
- 包含多个顶点，且每个顶点都可以有0个或者多个后继节点；
- 不含回路（即不存在回路的环）。

## 路径（Path）
路径是图论中研究带权最短路径及其链路是否存在唯一顶点的问题。简单地说，路径就是通过图中的顶点和边，走过的特定顺序的边序列，其长度等于各边上的权值之和。一条路径上的每两个顶点之间至多只有一条边相连，所以路径总是由单方向边所组成。

## 路径长度（Path Length）
路径长度是指一条路径中边的个数。对于无向图来说，每条路径的长度都是相同的。对于有向图而言，路径长度可能不同，因为有向图允许某个顶点回溯到它之前的状态。例如，一条有向环可以拥有任意长的路径长度。

## 根节点（Root Node）
图论中，节点的度定义为其邻接节点的个数，除非节点只有一个邻接节点，才会被认为是一个度为1的节点。如果节点中度最大的那个节点不是该图的根节点，就称此节点为根节点。

## 森林（Forest）
森林(Forest)是指一组互不相交的树的集合，森林也被称为“有根树”。如果不考虑多重边的情况，图论中的无向连通图可以看做是带有唯一源点和汇点的森林。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 基本思想
拓扑排序是对有向无环图(DAG)的排序算法。首先选取G的任意一个顶点作为起始点，然后标记该顶点为已访问并输出，随后从该顶点出发，按字典序扫描它的后继顶点，对每个后继顶点，进行以下操作:

1. 如果该顶点已经被访问过，则跳过它；
2. 对该顶点标记为已访问，并输出；
3. 对于该顶点的每个后继顶点，重复步骤1~2。

按照以上操作，直到图G中所有顶点均已输出为止，得到一个拓扑序列。

## 操作步骤
1. 从G中选择一个没有前驱结点（入度为0）的顶点输出。如果G中没有这样的顶点，说明它是一个DAG，则返回空序列，否则继续执行。
2. 将第1步选择出的顶点加入输出序列中。
3. 删除第2步选择出的顶点及所有以它为尾的边。
4. 从G中选取一个新的顶点，重复第1~3步。
5. 最后，输出序列就是所有顶点的拓扑排序。

注意：为了保证拓扑排序的准确性，必须保证输入的DAG没有自环。若有自环，则不一定能得到唯一的拓扑排序，或许会陷入无限循环中。另外，由于删除的边可能导致孤立的顶点，即度为0的顶点，因此需要一直删除孤立的顶点，直到所有顶点都被标记为已访问，输出序列才算完整。

## 数学模型公式
设G=(V,E), V为顶点集，E为边集，定义集合Y={y|y∈V且degree(y)=0}为G的源点集，我们希望找出由Y生成的线性序列{v0,v1,...,vk},其中v0∈Y，vk∉Y, 且对所有i≠j有vi=vj 或 vi的直接后继不包含vj时，序列中位置j>k的元素都可以被确定下来。如果存在这样的序列，则称它为G的拓扑排序，记为T。当G不是DAG时，则不存在这样的序列。

### 属性与定理
#### (属性1) 在DAG上，无后效性。
假设存在两个不同的拓扑排序，且它们的逆序也是同一个拓扑排序。那么，我们必须找到其中一个拓顶排序，使得它在删除任意一条边后，仍然是DAG。否则，就像之前所说的，拓扑排序并不改变原图的任何子集，也不会影响其他图的排序结果。

证明：反证法。设有两个不同的拓扑排序P和Q，其中pi与pj为序列中的任意两个元素，且他们的逆序{pj, pi}为另一个拓扑排序R。设di与dj是图G中任意两条边，且di与di+1为pj与pi，即{d1,d2,...} = {p_j, p_{j-1}} = {q_i, q_{i-1}}，而P和Q中的元素pi、pj与pi、pj之间的位置均不变，那么说明存在顶点vi、vj在所有序列中仍然处于固定位置，即存在边vi->vj。根据拓扑排序的定义，vi应该在vj的前面，因而说明存在P'和Q'，满足:

1. P': P的删边{d1, d2,..., dj-1}和删除的子图H的拓扑排序与P的删边{d1',d2',...}和删除的子图H的拓扑排序相同；
2. Q': Q的删边{d1, d2,..., di-1}和删除的子图H的拓扑排序与Q的删边{d1',d2',...}和删除的子图H的拓扑排序相同。

由于vi、vj为序列中的两个元素，所以d1、d2、...至少有两种选择，且删边操作不改变一个元素的相对次序，矛盾！因此，不存在这样的两个拓扑排序。故无后效性成立。

#### (属性2) 稳定性。
设T为图G的一个拓扑排序，若存在顶点u和v，使得u在T中排在v之前，则称T是稳定的，否则称为不稳定的。

证明：反证法。设G=(V,E)为DAG，且T为G的拓扑排序。假设存在i, j，1 ≤ i < k ≤ |T|, 1 ≤ j < l ≤ |T|，且T[i]与T[j]为序列中的两个不同元素，且T[i]在T[j]的前面。也就是说，对于1 ≤ t < l-i，T[t+i] <= T[t], t+i >= j，即对于任意t+i，t+j<l，有T[t]<T[t+i]。那么，假设存在s∈(i,j)，且对所有t+i > s, 有T[t]<=T[t+i]. 这意味着，在删除边{d1,...,dk}后，T[t]<=T[t+i]，矛盾! 因此，不存在这样的i, j，T[i]与T[j]为序列中的两个不同元素，且T[i]在T[j]的前面。故可推知，T为稳定的。

### 方法
#### 1. Kahn法（Bron–Kerbosch算法）
Kahn法是一个基于DFS的拓扑排序算法，时间复杂度为O(|V|+|E|)，空间复杂度为O(|V|^2)。它使用一种迭代的方法，每次选取入度为0的节点，把它放入结果序列中，并删除它和所有出边。然后再遍历剩余节点，对每个节点，找出它的所有入边，若其所有的前驱结点均已被访问过，则将它加入队列，并继续寻找入边。如此反复，直至队列为空，且结果序列为空，则说明输入是一个DAG。

```python
def topologicalSort(self):
    # Step 1 : Initialization 
    S = set() # Set of all the vertices with zero in-degree
    L = []   # To store result
 
    # Step 2 : Extract vertices with no incoming edges and add to list L
    for u in self.graph:
        if len(self.graph[u]) == 0:
            S.add(u)
    
    while len(S)!= 0:
        v = S.pop()
        L.append(v)
 
        for w in self.graph[v]:
            self.graph[w].discard(v)
 
            if not self.graph[w]:
                S.add(w)
 
    return L
```

#### 2. DFS算法
DFS算法是一种基于栈的拓扑排序算法，时间复杂度为O(|V|+|E|)，空间复杂度为O(|V|^2)。它的原理是，在图G上调用DFS遍历，首先找到入度为0的节点，然后递归地将它们添加到栈中。当遍历完图G时，栈中就存有各个顶点的拓扑排序。

```python
def dfsTopologicalSort(self):
    visited = [False]*len(self.graph) # keep track of visited nodes
    stack = []    # to maintain order of visiting nodes

    def recursiveHelper(node):
        visited[node] = True

        for neighbor in graph[node]:
            if not visited[neighbor]:
                recursiveHelper(neighbor)
        
        stack.append(node)

    # Traverse all nodes and perform dfs traversal starting from vertex with no incoming edge
    for node in range(len(visited)):
        if not visited[node] and all(not visited[neighbour] for neighbour in graph[node]):
            recursiveHelper(node)
            
    return stack[::-1] # Return reverse of stack as output since it contains toplogical sort
```