
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在Java中，父类引用指向子类的实例对象是允许的，但反过来则不可以。也就是说，如果有一个父类类型变量a指向了一个子类类型变量b的实例，那么a将不能访问b所独有的属性或方法。比如：
```java
public class Animal {
    public void eat() {}
    //...其他方法和属性
}

public class Dog extends Animal {
    private String breed;

    public void play() {}
    
    //...其他方法和属性
}

Animal a = new Dog();   // OK: a引用指向Dog实例
a.play();              // OK: a可以调用Dog实例独有的play方法
String breedName = ((Dog)a).breed;    // OK: a可以访问Dog实例独有的breed属性

// 下面两行代码将会报错：
Animal animalArray[] = new Animal[2];      // 定义了一个Animal数组
animalArray[0] = new Dog();                 // 将Dog实例赋值给数组的第一个位置
((Dog)animalArray[0]).eat();               // 此处将会报错：Cannot invoke "Dog.eat()" because "animalArray[0]" is an instance of type "Animal" rather than a subclass of "Dog"
```

在上面的代码中，我们通过Dog实例向Animal数组的第一个位置写入了一条记录。之后尝试调用`animalArray[0]`的独有方法`eat()`，由于类型不匹配，编译器将无法通过检查。而对于私有的属性`breed`，也一样，由于Dog实例是Animal类的子类，所以可以直接通过强制类型转换获取到该属性值，但并没有意义。

为了能够实现类似的方法级泛型功能，使得父类引用指向子类的实例对象时不允许，可以采取以下两种方式：

1. 方法重载（overload）：可以使用多个重载方法，每个方法接受的参数都是父类类型，然后进行条件判断，若是传入的是子类对象，则转换成父类对象；否则，直接调用父类版本的同名方法。
```java
public class Animal {
    public void eat() {}
    //...其他方法和属性
}

public class Dog extends Animal {
    private String breed;

    public void play() {}
    
    //...其他方法和属性
}

class ParentClassExample {
    static void printAnimal(Animal animal) {
        System.out.println("This is the parent version.");
    }
    static void printAnimal(Dog dog) {
        System.out.println("Eating ability of this dog is: " + dog.getEatAbility());
    }
    static void printBreed(Object obj) {
        if (obj instanceof Dog)
            System.out.println(((Dog)obj).getBreed());
        else
            throw new IllegalArgumentException("Object is not a Dog!");
    }
}

ParentClassExample example = new ParentClassExample();
example.printAnimal(new Dog());     // This is the parent version.
example.printAnimal(new Cat());     // Eating ability of this cat is: 4
example.printBreed(new Dog());       // Sheepishly dishonest carnivore...
```
这种方式虽然简单易懂，但是缺点也是很明显的：
- 因为要使用多种不同的方法签名，导致方法名称相同，难以区分用途；
- 每增加一种类型需要增加一个新的方法，在维护和修改的时候麻烦很多；
- 对返回值的类型校验不全面，容易误判；
- 在运行时动态类型转换将带来额外的性能损耗。

2. 方法级泛型（method generics）：使用Java8引入的范型（generics）机制，可以在方法声明中添加泛型参数，用来限定传入的参数和返回值只能是某个指定类型或其子类。这样，在实际使用时，如果传入的是子类对象，就不需要做任何转换，就可以调用父类版本的同名方法。
```java
import java.util.*;

interface Eatable<T> {
    boolean canEat(T t);
}

abstract class Animal<T> implements Eatable<T>{
    abstract T getSelf();
}

class Dog extends Animal<Dog> {
    private int age;
    private String breed;

    @Override
    public Dog getSelf() { return this; }

    @Override
    public boolean canEat(Dog other) { 
        return true; 
    } 

    public String getBreed() { return breed; }

    public int getAge() { return age; }

    public void setAge(int age) { this.age = age; }
}

class Cat extends Animal<Cat> {
    private double weight;
    private String name;

    @Override
    public Cat getSelf() { return this; }

    @Override
    public boolean canEat(Cat other) { 
        return false; 
    } 

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public double getWeight() { return weight; }

    public void setWeight(double weight) { this.weight = weight; }
}

class MethodGenericsExample {
    static <T extends Animal<? super T>, U extends T & Eatable<U>> void testAnimals(List<U> animalList) {
        for (U u : animalList) {
            boolean canEatOther = false;
            ListIterator<U> it = animalList.listIterator(animalList.indexOf(u));
            while (it.hasNext()) {
                U next = it.next();
                if (!Objects.equals(next, u)) {
                    canEatOther |= u.canEat(next);
                }
            }
            if (canEatOther) {
                u.setAge(999);
            }
        }

        Collections.sort(animalList, Comparator.<T>comparingInt(Animal::getAge));
    }
}

MethodGenericsExample example = new MethodGenericsExample();
List<Animal<? super Animal<Dog>>> animalList = Arrays.asList(new Dog(), new Cat());
example.testAnimals(animalList);
for (Animal<? super Animal<Dog>> animal : animalList) {
    System.out.println(animal.getClass().getSimpleName() + ": " + animal.getAge());
}
```
这里我们先定义了一个`Eatable`接口，里面有一个`canEat`方法，用来检测传入的参数是否可以被吃。同时还定义了一个抽象的父类`Animal`，它定义了两个泛型参数：`T`表示自身类型，`Eatable<T>`表示能够被自己类型参数的实例所吃。

然后我们定义了两个具体的子类`Dog`和`Cat`，它们分别继承于父类`Animal`，分别实现自己的`Eatable`接口和`getSelf`方法。

接下来我们创建了一个测试类`MethodGenericsExample`，里面有一个`testAnimals`方法，接收一个由`Animal`及其子类的实例组成的列表，并对其中的实例执行某些操作。

在这个方法内部，我们遍历列表，对于每一个实例，我们求出它和其他所有实例之间的关系，通过调用`canEat`方法判断，并将符合条件的实例设置一个更年期。最后，我们利用Java8引入的`Comparator`工具类对实例进行排序。

这里注意一下方法的参数类型，我们使用了方法级泛型。首先是列表中的元素类型，由通配符`? super Animal`表示，即列表中可以存放任意父类`Animal`实例或者它的子类实例。其次是调用了`canEat`方法的类型，由`? extends T & Eatable<U>`表示，即传入的参数可以是某个类型（此例中为`Dog`、`Cat`），并且该类型能够被自己类型的实例所吃。

如此一来，编译器就知道哪些版本的`getAge`方法应该被调用，哪些版本的`setAge`方法应该被调用，这就是方法级泛型的好处。

这种方式虽然解决了父类引用指向子类的实例对象的问题，而且避免了多种不同方法签名和增加新方法的困扰，但仍然存在一些隐患：
- 如果某个类同时继承了父类A和子类B，且又需要使用方法级泛型，如何处理？
- 没有考虑到方法的重载情况，即不同参数个数、类型、顺序的重载方法。
- 没有考虑到方法的返回值类型，即对于泛型类型来说，方法的返回值只能是Object或其子类，即使方法逻辑可以正确运行，但编译器还是会警告。
因此，这种方式只是一种尝试，需要进一步完善才能得到广泛应用。