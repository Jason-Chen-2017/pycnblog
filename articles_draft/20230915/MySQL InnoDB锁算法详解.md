
作者：禅与计算机程序设计艺术                    

# 1.简介
  

InnoDB存储引擎是MySQL的默认事务性存储引擎之一。它是一个高性能、高并发的事务型数据库引擎。因此对于InnoDB的锁的实现非常重要。InnoDB的行级锁设计得很精巧，通过数据字典元数据等手段获得了非常好的性能。但是同时，理解其锁的机制也成为一个关键点。
MySQL对InnoDB的锁设计相对复杂一些。对于不同类型的锁存在不同的实现方式。主要有三种锁，共享锁（S）、排他锁（X）和意向锁（IS）。它们是如何共同作用的呢？这一节我们将首先介绍一下InnoDB锁的基本机制。
# 2.InnoDB锁机制概述
InnoDB中处理并发控制的方式叫做Next-Key Locks。InnoDB采用两阶段锁协议，在所有的索引记录上加锁时都需要添加间隙锁。每一个会话或者事务在申请锁之前都会计算一系列相关的键值范围，然后按照顺序加锁。这么做的目的是为了防止死锁发生。如下图所示：
当要获取某个索引上的排他锁时，会先检查该索引是否已经被加过排他锁。如果加过排他锁，那么就直接返回失败；否则，则遍历整个索引的所有条目，如果发现有不满足条件的记录，则给予排他锁；否则，给予插入意向锁。意向锁实际上并不是真正的锁，而只是一种请求，之后才会真正持有这个锁。如果插入意向锁失败，就会阻塞其他的插入事务。
显然，这么做可以有效地防止幻读和不可重复读，保证数据的一致性。但是它的代价是开销比较大的，尤其是在对大量的数据进行修改时。因此InnoDB又提供了各种优化措施，比如插入缓冲区、预读、多版本并发控制等，减少锁的时间和提升并发性。这些优化措施在一定程度上缓解了锁的影响，但还是不能完全消除。另外，InnoDB还有一些限制，比如事务大小限制、死锁检测器超时时间等。这里暂不讨论这些内容。
# 3.InnoDB锁算法分类及特点
InnoDB的锁算法有两种，表级别锁（table-level locking）和行级别锁（row-level locking）。
## 3.1 表级别锁
表级别锁是MySQL最基本的锁管理策略，每个InnoDB的表对应一个SHARE ROW EXCLUSIVE锁，并且所有事务只能对这个表加锁，直到提交或回滚完成。通常情况下，共享锁(S)、排他锁(X)都是表级别锁。由于只允许一个事务访问一个表，因此避免了死锁，也能够充分利用CPU资源，提升系统性能。但是，由于锁粒度太大，当需要对多个表进行操作时，可能会造成资源竞争，从而降低效率。因此，一般情况下，我们应该尽可能的减少表之间的锁竞争。
## 3.2 行级别锁
InnoDB的行级别锁有三种形式：共享锁（S）、排他锁（X）和意向锁（IS）。在行级别锁的机制下，事务在更新或删除某一行记录时，对这一行加共享锁或排他锁。其他事务只能对已加锁的行进行查询，不能对其进行加锁，直到当前事务释放了锁。因此，多个事务可以同时读取同一行数据，但是只能串行执行，提升了并发度。但是行级锁使并发度比表级别锁低，因此一般情况下我们应该选择表级锁。
# 4.InnoDB行锁实现原理
InnoDB的行锁是在索引记录上进行加锁，不同类型的索引类型对锁的实现又各不相同。
## 4.1 意向锁
InnoDB支持在GAP（间隙）页中的记录上设置一个唯一的索引“聚集索引”，称为聚集索引。聚集索引的设计意义在于，让每一个聚簇页都有一个唯一的主键，同时还避免了非聚簇索引维护的空间消耗。每当创建新索引的时候，都会根据主键排序顺序创建一个新聚簇索引。因此，如果聚集索引可以覆盖查询，那么就会给相应的记录加上索引的S锁。也就是说，对于一条记录，其唯一索引键值等于相应的聚集索引键值才能给这个记录加S锁。例如：
```sql
mysql> create table t (c int not null primary key);
Query OK, 0 rows affected (0.02 sec)

mysql> insert into t values (1),(2),(3),(NULL);
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql> select * from t where c = 1 for update;
+----+
| c |
+----+
|  1 |
+----+
1 row in set (0.00 sec)

```
上面例子中，`select * from t where c = 1 for update;`语句实际上锁定了记录`(1)`，并且给记录的唯一索引加了一个S锁。由于记录`(1)`的聚集索引键值为1，所以就可以给它加S锁。其他事务无法再对这个记录加任何锁。
注意：在InnoDB中，只有聚集索引可以加S锁，非聚集索引不会锁住任何行。
## 4.2 共享锁（S）
在并发环境下，两个或多个事务可能需要对同一张表中的同一行数据进行并发操作。为了保证数据的正确性和一致性，InnoDB提供两种互斥锁：排它锁（X）和共享锁（S）。在任何时候，只能由获得锁的事务进行锁定的操作。
### 4.2.1 读已提交（RC）隔离级别下的读共享锁（S）
在一个事务开启后，其他事务可以继续对其读取数据的操作，而不用等待。该隔离级别下，数据库系统只会对外公布其他事务所做的修改，而不会自己做任何数据检查。因此，在这种情况下，两个或多个事务可能对同一张表中的同一行数据加读共享锁（S），而不用排他锁。如下所示：
```sql
mysql> begin; // 开启事务
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t where id = 1 lock in share mode;
+----+
| c |
+----+
|  1 |
+----+
1 row in set (0.00 sec)

mysql> commit; // 提交事务
Query OK, 0 rows affected (0.00 sec)

```
第一次查询语句开启了一个事务，在事务中用SELECT... FOR SHARE命令查询了记录`id=1`，并给记录加上了读共享锁。其他事务可以继续查询此记录，并不会因为已经加锁而被阻塞。当第一个事务提交后，其他事务就可以继续查询这个记录，并且不会因已经被锁住而出现死锁或其它错误。
### 4.2.2 读未提交（RU）隔离级别下的读共享锁（S）
在一个事务开启后，其他事务可以继续对其读取数据的操作，即使另一个事务已经对该数据进行了修改，但是数据还没有提交。该隔离级别下，数据库系统不会对外公布其他事务所做的修改，也不会自己做任何数据检查。因此，在这种情况下，两个或多个事务可能对同一张表中的同一行数据加读共享锁（S），而不用排他锁。如下所示：
```sql
mysql> begin; // 开启事务
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t where id = 1 lock in share mode;
+----+
| c |
+----+
|  1 |
+----+
1 row in set (0.00 sec)

// 另一个事务开始，并对记录id=1进行修改
mysql> begin; // 开启事务
Query OK, 0 rows affected (0.00 sec)

mysql> update t set c = 10 where id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from t where id = 1;
+----+
| c |
+----+
| 10 |
+----+
1 row in set (0.00 sec)

mysql> rollback; // 回滚事务
Query OK, 0 rows affected (0.00 sec)

// 查询id=1的记录，仍然是10，说明另一个事务修改了这个记录的值，而第一个事务仍然可以正常访问
mysql> select * from t where id = 1;
+----+
| c |
+----+
| 10 |
+----+
1 row in set (0.00 sec)
```
第一组查询语句在事务中用SELECT... FOR SHARE命令查询了记录`id=1`，并给记录加上了读共享锁。第二组查询语句开启了一个新的事务，并对记录`id=1`进行了修改。第三组查询语句再次查询了记录`id=1`，可以看到其值已经变成了10，但是还没提交事务。最后的回滚语句取消了修改，并且释放了锁。这样就保证了在读未提交隔离级别下，读取数据的正确性。
## 4.3 排他锁（X）
排他锁（X）是一种独占锁，用于实现对数据完整性的约束。当事务对某一行数据进行写入操作时，数据库系统对其加上排他锁。其他事务不能对已加锁的行进行任何操作，直到当前事务释放了锁。因此，排他锁是一种独占锁，只有被锁住的事务才能做任何数据修改。
### 4.3.1 写已提交（WUC）隔离级别下的排他锁（X）
在一个事务开启后，其他事务不能再对其读取数据的操作，直到该事务结束。该隔离级别下，数据库系统只会对外公布其他事务所做的修改，而不会自己做任何数据检查。因此，在这种情况下，两个或多个事务可能对同一张表中的同一行数据加排他锁（X），而不用共享锁。如下所示：
```sql
mysql> begin; // 开启事务
Query OK, 0 rows affected (0.00 sec)

mysql> delete from t where id = 1;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

```
在事务中尝试删除`id=1`的记录，但由于已经被别的事务加上了排他锁，因此抛出了一个异常。其他事务需要等待当前事务结束才能对记录`id=1`进行删除。
### 4.3.2 写未提交（WU）隔离级别下的排他锁（X）
在一个事务开启后，其他事务不能再对其读取数据的操作，即使另一个事务已经对该数据进行了修改，但是数据还没有提交。该隔离级别下，数据库系统不会对外公布其他事务所做的修改，也不会自己做任何数据检查。因此，在这种情况下，两个或多个事务可能对同一张表中的同一行数据加排他锁（X），而不用共享锁。如下所示：
```sql
mysql> begin; // 开启事务
Query OK, 0 rows affected (0.00 sec)

mysql> delete from t where id = 1;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction

// 另一个事务开始，并对记录id=1进行修改
mysql> begin; // 开启事务
Query OK, 0 rows affected (0.00 sec)

mysql> update t set c = 10 where id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> commit; // 提交事务
Query OK, 0 rows affected (0.00 sec)

// 删除id=1的记录
mysql> delete from t where id = 1;
Query OK, 1 row affected (0.00 sec)

```
第一组查询语句在事务中尝试删除`id=1`的记录，但由于已经被别的事务加上了排他锁，因此抛出了一个异常。第二组查询语句开启了一个新的事务，并对记录`id=1`进行了修改。第三组提交事务，并删除了`id=1`的记录。这样就保证了在写未提交隔离级别下，写入数据的正确性。
# 5.总结与建议
本文介绍了InnoDB锁的实现机制。首先，InnoDB支持两种锁类型——共享锁（S）和排他锁（X）——用于处理并发场景。其次，InnoDB通过锁的算法和限制解决了死锁的问题。最后，InnoDB在不同的隔离级别下支持不同的锁算法。最后，我们提出了InnoDB锁的应用场景。希望能够帮助大家更好的了解InnoDB锁的实现机制。