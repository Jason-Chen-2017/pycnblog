
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 什么是并查集
在计算机科学中，并查集（Disjoint-Set Union）是一个数据结构，它能高效地处理一些动态集合合并及查询问题。其核心思想是用树形结构表示一个集合族，并定义两个集合是否属于同一个集合的方法——祖先。

所谓祖先，就是某一节点到根节点路径上的最后一个节点。如果两个集合所在树的根节点相同，则它们一定是同一集合；否则，就不是同一集合。通过这种方式，可以高效地判断任意两点之间是否存在路径、计算任意两个集合的大小等问题。

应用场景如图所示，多个矩形区域要在图像上画出覆盖范围，将这些矩形按包含关系排列成一颗树状结构，那么相同颜色区域就属于同一集合。并查集的原理也是类似的，可以用来解决各种动态集合合并及查询问题。


## 为何要用并查集？
### 复杂性分析
并查集算法的时间复杂度是 $O(n\alpha(n))$ ，其中 n 是集合的元素个数，$\alpha(n)$ 是连接性函数，即树的高度。而树的高度随着集合元素个数的增长而急剧增加，因此其效率非常低下。

传统的动态集合合并及查询问题包括连接两个子集、查询两个子集的交集、判断两个子集是否相互独立、计算子集的并集等。而并查集提供了一种高效的实现方法。

### 其他优势
#### 利用树结构简化了动态集合操作
并查集的树结构简单易懂，可以很直观地看出集合之间的内部关系。同时，通过查询祖先节点，还可以推断出任意两个集合是否处于同一连通分量中。另外，并查集的大小操作也可以直接在树的结构上完成，不需要对所有集合元素进行遍历。

#### 使用路径压缩优化并查集树结构
在并查集的合并过程中，当两个集合的根节点不同时，会导致树的深度增长，进而影响并查集算法的效率。为了减少树的深度，可以在每一次合并的时候更新所有元素的父节点信息，使得整个树保持高度较小的平衡状态。

#### 支持按秩合并集合
由于并查集中每个元素对应了一个树中的节点，因此可以通过记录各元素的秩来支持按秩合并操作。也就是说，某个元素的所有祖先都指向它的唯一祖先。这样就可以快速确定两个元素是否属于同一集合，且不必像并查集一样遍历树中的每一个元素。

总结来说，并查集具有以下几方面的优势：
1. 时间复杂度低：树的高度随着集合元素个数的增长而急剧增加，因此其效率非常低下。并查集算法的时间复杂度是 O(nα(n)), 其中 n 是集合的元素个数，α(n) 是连接性函数。
2. 利用树结构简化了动态集合操作：并查集的树结构简单易懂，可以很直观地看出集合之间的内部关系。同时，通过查询祖先节点，还可以推断出任意两个集合是否处于同一连通分量中。
3. 使用路径压缩优化并查集树结构：在并查集的合并过程中，当两个集合的根节点不同时，会导致树的深度增长，进而影响并查集算法的效率。为了减少树的深度，可以在每一次合并的时候更新所有元素的父节点信息，使得整个树保持高度较小的平衡状态。
4. 支持按秩合并集合：由于并查集中每个元素对应了一个树中的节点，因此可以通过记录各元素的秩来支持按秩合并操作。也就是说，某个元素的所有祖先都指向它的唯一祖先。这样就可以快速确定两个元素是否属于同一集合，且不必像并查集一样遍历树中的每一个元素。

# 2.核心概念与联系
## 概念介绍
### 元素和其对应的子集
并查集中主要包含的元素包括若干个集合的元素，元素是并查集的最小单位。每个元素都对应了一个集合，不同元素对应的集合可能不同。例如，并查集中元素 {1, 2, 3} 对应三个集合：{1}, {2}, {3}.

集合由元素构成，并查集中的元素可以是任何类型的数据，包括整数、字符串、自定义类型等。元素可以是不相交的，也可能是相互重叠的。

### 集合的合并
对于两个或以上元素组成的集合，并查集中的合并操作用于将这些集合统一到一起。集合的合并，通常被称为连接操作，其含义是将两个集合合并为一个集合。并查集提供两种类型的合并操作：

1. 链接(Union): 将两个集合所在树的根节点设置为同一节点。
2. 按秩合并(Ranked Union): 如果两个集合的秩不同，将秩较小的集合的根节点指向秩较大的集合的根节点。

#### 连接操作
连接操作的过程如下:

1. 在两个集合的任意一个元素上，找到该元素的祖先节点。
2. 将另一个集合所在的树的根节点作为该元素的新祖先。

举例：假设并查集中元素 {1, 2, 3} 分别对应集合 {A}, {B}, {C}; 再假设我们需要将集合 A 和 B 合并为一个集合，则按照连接操作步骤如下：

1. 在集合 A 中元素 1 上找到其祖先节点，假定为集合 C (假定集合 C 的根节点为 x)。
2. 然后在集合 B 中元素 1 上找到其祖先节点，假定为集合 D (假定集合 D 的根节点为 y)。
3. 把集合 D 的根节点 (y) 设置为集合 C 的根节点 (x)，即令 x = y 。

新的并查集中元素 {1, 2, 3} 分别对应集合 {A', B'}, {B'}, {C'}。集合 A' 中的元素 {1} 仍然对应集合 C', 集合 B' 中的元素 {2} 仍然对应集合 D'.

#### 按秩合并操作
按秩合并操作的过程如下:

1. 判断两个集合的秩，取秩较小者作为当前集合，秩较大的作为对照集合。
2. 当前集合和对照集合的元素逐一比较，如果对照集合的元素的秩比当前集合的元素的秩小，则把当前集合的元素的秩设置成最大值，即令 rank[i] = max(rank[i], rank[j]), i ∈ current_set.
3. 将两个集合所在树的根节点作为两个集合的并集。

举例：假设并查集中元素 {1, 2, 3} 分别对应集合 {A}, {B}, {C}; 此时，秩分别为 2, 1, 1. 假设又有一个元素 4 需要加入集合 {A}, 根据按秩合并操作步骤如下：

1. 对集合 A 中的元素 4 而言，其秩为 0 (初始情况下，所有元素的秩都是 0), 对照集合是元素 3 ，秩为 1; 故，对照集合 A' 的元素 3 取代了 A' 的元素 4。
2. 对照集合 A' 中的元素 2 则没有可替代的元素，故无需操作。
3. 对照集合 A' 中的元素 1 则没有可替代的元素，故无需操作。
4. 最后，对照集合 A' 和当前集合 A 的元素 {3} 合并为一个集合 A''，该集合的根节点设置为 null 。此时的并查集中元素 {1, 2, 3, 4} 分别对应集合 {A'', B}, {B}, {C}, {}。集合 A'' 中的元素 {3, 4} 仍然对应集合 A''.

新的并查集中元素 {1, 2, 3, 4} 分别对应集合 {A''}, {B}, {C}, {null}. 集合 A'' 中的元素 {3, 4} 仍然对应集合 A''.

综上所述，连接操作可以将两个集合合并为一个集合，但每次只能合并两个集合，而按秩合并操作可以把任意多个集合合并为一个集合，且可以保证合并后的元素数量不变。

## 重要关联操作
### 查询操作
查询操作的目标是判断两个元素是否属于同一个集合。并查集提供了两种类型的查询操作：

1. 查询元素的祖先节点: 返回元素所在集合的根节点。
2. 查询两个元素是否属于同一集合: 判断两个元素是否有共同的祖先节点。

#### 查询元素的祖先节点
查询元素的祖先节点的过程如下:

1. 在元素所在集合的任意一个元素上，找到该元素的祖先节点。
2. 重复第 1 步，直到找到根节点。

举例：假设并查集中元素 {1, 2, 3} 分别对应集合 {A}, {B}, {C}; 然后我们需要知道元素 3 的祖先节点，则按照查询操作步骤如下：

1. 从元素 3 开始，找到元素 3 所在集合的根节点。
2. 根节点为 null, 说明元素 3 对应的集合只包含一个元素，根节点为空，返回空节点。

所以，元素 3 的祖先节点为 null.

#### 查询两个元素是否属于同一集合
查询两个元素是否属于同一集合的过程如下:

1. 在第一个元素所在集合的任意一个元素上，找到第一个元素的祖先节点。
2. 在第二个元素所在集合的任意一个元素上，找到第二个元素的祖先节点。
3. 比较两个元素的祖先节点，如果相同，则返回 true ; 否则返回 false.

举例：假设并查集中元素 {1, 2, 3} 分别对应集合 {A}, {B}, {C}; 我们需要判断元素 1 和 3 是否属于同一集合，则按照查询操作步骤如下：

1. 从元素 1 开始，找到元素 1 所在集合的根节点，假定为集合 A (假定集合 A 的根节点为 z)。
2. 从元素 3 开始，找到元素 3 所在集合的根节点，假定为集合 A （根节点与集合 A 的根节点相同）。
3. 比较两个集合的根节点 z，因为相同，返回 true. 

所以，元素 1 和 3 属于同一集合。

## 性能分析
并查集算法的时间复杂度是 $O(n\alpha(n))$ ，其中 n 是集合的元素个数，$\alpha(n)$ 是连接性函数，即树的高度。而树的高度随着集合元素个数的增长而急剧增加，因此其效率非常低下。

实际上，并查集算法是一种树形结构数据存储方案，其平均时间复杂度为 $O(\log^* n)$ ，其中 $\log^*(n)$ 是 $n$ 的任意次幂，换句话说，就是任意多层树的高度之和。但由于哈希表的优越性能，实际应用中并未采用这种结构。

因此，并查集算法虽然能很好地处理动态集合合并及查询问题，但是不能满足实时的要求。当集合规模较大时，并查集算法的效率远不及线性数据结构算法，如散列表。