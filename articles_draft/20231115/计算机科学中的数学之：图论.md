                 

# 1.背景介绍


图（Graph）是由节点（node）和边（edge）组成的无序的、连通的集合。在图论中有着广泛的应用，例如网络结构、生物信息学、电路设计等方面。图的表示形式有多种，包括邻接矩阵、邻接表、十字链表、松弛矩阵等等。在实际应用中，我们通常将图用二维数组或者邻接矩阵表示。本文关注的是邻接表表示法，邻接表是图的一种主要表示方法，利用数组实现，用来存储一个图的顶点及其相邻顶点之间的关系。

# 2.核心概念与联系
## 2.1 定义与术语
### (1)定义：在数学中，图是由结点（vertex 或 node）和边（edge）组成的非空集合。其中，结点可以看作是图中的顶点（v），边可以看作是连接两个结点的一条线段。图中的每一条边都有一个方向性，即它只能沿着它的两个端点进行扩展。当且仅当两个顶点之间存在一条边，则称它们是邻居。如果一个图的所有顶点都互相连接，并且每个顶点至少与一个其他顶点相邻，则该图是完全图（complete graph）。

### (2)术语：
1. 路径（path）: 序列上的一条从第一个顶点到最后一个顶点的边，不包含重复的边或回头的边；
2. 简单路径（simple path）： 路径中没有重复的边；
3. 回路（circuit）：简单路径上的起始顶点和结束顶点相同。
4. 强连通分量（strongly connected component）： 没有任何回路的无向图的一个子图；
5. 稳定集（stable set）： 使得所有结点在某一次迭代中保持不变的子集；
6. 生成树（spanning tree）： 是所有结点形成的有根树，它包含图中全部的边且没有环；
7. 完全图： 任意两个顶点间都存在边。

## 2.2 图的表示方式
图的表示方式有很多，包括邻接矩阵、邻接表、十字链表、邻接多重列表等等。下面以邻接表为例来介绍一下相关的知识。

### 2.2.1 邻接表表示法
邻接表表示法是一个图的稀疏表示方法。一般情况下，图的邻接矩阵是比较大的，而邻接表表示法可以有效地节省空间，特别是在稠密图上。邻接表是一个数组，数组的每一项是一个链表，保存与当前顶点相关联的所有顶点。为了便于理解，下面的示例图使用邻接表表示法：


1. 每个顶点对应一个数字索引，例如，索引0代表顶点A，索引1代表顶点B，索引2代表顶点C，索引3代表顶点D，索引4代表顶点E。
2. 对于顶点A来说，它与顶点B和顶点E之间存在一条边，所以邻接表中第0号位置存储了一个指向1和4的指针；同样，顶点B也与顶点A和顶点C之间存在边，因此邻接表中第1号位置存储了一个指向0和2的指针；顶点C与顶点B、D之间存在边，因此邻接表中第2号位置存储了指向1和3的指针；顶点D与顶点C、E之间存在边，因此邻接表中第3号位置存储了指向2和4的指针；顶点E与顶点D之间存在边，因此邻接表中第4号位置存储了指向3的指针。
3. 通过这种方式，我们可以快速访问某个顶点与哪些顶点相邻。例如，假设要确定顶点A与哪些顶点相邻？只需访问其邻接表中第0号位置即可，得到的值就是存有顶点B和顶点E的指针。同样，我们也可以通过顶点之间的边找出路径。
4. 如果图是稀疏图，比如只有四个顶点和五条边，那么邻接表中会有许多指针为空。这样浪费了很多空间。因此，邻接表还有一个压缩技巧，可以把一些空指针删掉，节省空间。这个技巧称为“边压缩”。边压缩的方法并不是总能成功压缩空间，但是对于稠密图来说，压缩率还是很高的。

### 2.2.2 遍历图
根据图的表示方式不同，我们可以使用不同的遍历算法。下面介绍几种常用的遍历算法：

#### 深度优先搜索DFS(Depth First Search)
深度优先搜索是一种简单的遍历算法，它沿着图的深度方向搜索图的边。它先访问初始顶点，然后依次从其相邻的顶点开始递归地搜索。具体步骤如下：

1. 从一个顶点v开始，标记v为已访问，并将v入栈。
2. 若栈为空，搜索结束，否则，弹出一个顶点u，然后访问u。
   - 对于u的每一个相邻顶点w，若未被访问过，则进行如下处理：
      - 将w压栈；
      - 标记w为已访问；
      - w所在的边成为“链路”上的一个新顶点。
3. 重复步骤2直至栈为空，或找到已经被访问过的顶点。

#### 宽度优先搜索BFS(Breadth First Search)
宽度优先搜索是另一种简单遍历算法，它沿着图的宽度方向搜索图的边。它首先访问所有与初始顶点直接相连的顶点，然后再访问距离初始顶点更近的顶点。具体步骤如下：

1. 创建一个队列Q，并将初始顶点v加入队列。
2. 遍历队列Q，对每个顶点u：
   - 访问u。
   - 对u的每一个相邻顶点v，若v尚未访问过，则将v加入队列。
3. 当队列Q为空时，搜索结束。

#### 最小生成树
图的最小生成树（Minimum Spanning Tree，MST）是指图中权值的和最小的生成树。常用的算法有 Prim 和 Kruskal 算法。

##### Prim 算法
Prim 算法基于贪心算法，它的基本思想是每次选择最小权值边，并添加到 MST 中。具体步骤如下：

1. 从图中任选一个顶点作为源点，其余顶点作为初始顶点。
2. 对初始顶点选取其相邻的所有顶点，记录下各自的权值，并记录下这些顶点。
3. 随后再选取权值最小的边，添加到 MST 中。
4. 重复第三步，直至选取完所有的边。

##### Kruskal 算法
Kruskal 算法也是一种贪心算法，它的基本思想是每次选择代价最小的边，并判断是否形成回路。具体步骤如下：

1. 将图中的所有边按代价从小到大排序。
2. 依次扫描排序后的边，若不存在形成回路的边，则将该边添加到 MST 中，并记录它所连接的顶点。
3. 重复第二步，直至 MST 的边数等于图中的最小生成树的边数。

#### 拓扑排序
拓扑排序是一个非常重要的图论算法，它用于对DAG（有向无环图）进行排序。具体步骤如下：

1. 从 DAG 中的所有顶点中选择一个，将其输出。
2. 删除所有与该顶点相关联的箭头。
3. 重复第一步和第二步，直至所有顶点都输出。
4. 如果图中还有顶点没有删除，则说明该图中有回路，无法进行拓扑排序。

### 2.2.3 最短路径
最短路径问题可以分为单源最短路径问题和多源最短路径问题。在单源最短路径问题中，给定一个源顶点s，求从s到所有其他顶点的最短路径长度。在多源最短路径问题中，给定n个源顶点，分别是s1、s2、…、sn，求从任意一个源顶点s到所有其他顶点的最短路径长度。

一般情况下，图的最短路径算法都是使用 Bellman-Ford 算法或者 Dijkstra 算法。下面就介绍这两种算法。

#### Bellman-Ford 算法
Bellman-Ford 算法是一种动态规划算法，它用于计算单源最短路径问题。具体步骤如下：

1. 初始化一个数组dist[]，其中dist[i]表示从源点s到i的最短路径长度。初始化dist[s]=0。
2. 使用|V|-1次松弛操作，在所有顶点对之间进行松弛操作，松弛函数为`relax(u, v)`，当且仅当`dist[u]+w<dist[v]`时才进行松弛。
3. 当第i次松弛操作后仍然存在负权回路时，说明图中存在负权回路，不存在最短路径。返回false。
4. 最后，当i=|V|-1时，算法结束，dist[i]即为源点s到所有其他顶点的最短路径长度。

#### Dijkstra 算法
Dijkstra 算法是一种贪心算法，它用于计算单源最短路径问题。它的基本思想是每次选择当前路径长度最短的顶点进行扩展，直至所有顶点都访问完成。具体步骤如下：

1. 初始化一个数组dist[]，其中dist[i]表示从源点s到i的最短路径长度，其初始值均为正无穷大。dist[s]=0。
2. 在集合S中，选择dist[]数组中最小的元素作为u。
3. 对u的所有相邻顶点v，若v尚未访问过，则更新dist[v]为min(dist[v], dist[u]+w)，其中w为顶点u到v的权值。
4. 将u移出集合S。
5. 重复步骤2～4，直至S为空。

### 2.2.4 关键路径
关键路径（Critical Path）是一个比较特殊的路径，它决定了一个进程完成的时间。在有向无环图（DAG）中，一个顶点可以作为唯一的开始点，其他所有顶点作为结束点，且整个过程都具有确定的次序。因此，关键路径一定是最长路径。一个有向无环图的关键路径就是其具有最大流的路径。

### 2.2.5 割点、桥和堤防
图中的割点、桥、堤防是指图中连接两个子图的顶点。下面介绍三种类型的边：

1. 割边：两条边连通了两个不同的连通子图。
2. 桥边：两条边的顶点都属于不同的连通子图，但只有一条边连接这两个子图。
3. 堤防：两条边的顶点都属于不同的连通子图，且这两条边都连接着这两个子图。

### 2.2.6 判别式
判别式是图论的一个重要概念。它衡量的是一个图中存在多少种不同的连接方式。判别式有着重要的应用，如费尔曼圈定理、完全匹配、支配子图、联通分量等。判别式的计算公式如下：

$d_1=\frac{n*(n-1)}{2}$

$d_2=\sum_{i}\sum_{j\neq i}C_{ij}^{\prime}, C_{ij}^{\prime}:=|E\{i,j\}|+\sum_{k\in V\{i\}}deg(k)$

$d_3=\left(\sum_{\substack{i \leq j \\ i\neq j}}deg(i)\right)^2-\sum_{\substack{i\leq j\\i\neq j}}\sum_{k\notin N(i)}e^{\delta}_{ik}(d_{kj})+d^{2}_{\max}$

其中，$N(i)$ 表示顶点 $i$ 的邻居（neighbors），$\delta$: $V\times E$ 是一个边加权的邻接矩阵。