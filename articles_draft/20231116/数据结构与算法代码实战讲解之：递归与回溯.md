                 

# 1.背景介绍


## 什么是递归
在计算机科学中，递归(Recursion)是指一个函数调用自身的一种编程技巧或方法。递归可以使程序更简洁、更易于理解，而且经过优化后运行速度也很快。它主要应用于解决一些复杂的问题。许多编程语言都支持递归，比如C语言、Java、Python等。
## 为什么要用递归
在日常生活中，我们经常会遇到很多需要重复做同一件事情的场景。比如说，爬楼梯、打印机、汉诺塔等。这些都是可以使用递归解决的问题。另外，递归还有一个特性，就是函数自己调用自己，最终可能导致栈空间溢出。因此，要想在实际项目中充分利用递归，就需要对递归有深刻的理解。
## 递归算法优缺点
### 优点
1. 简单性：递归算法往往比迭代算法更容易理解和实现。递归算法通常只需要少量的代码就可以实现，而且逻辑清晰；迭代算法则需要大量的循环和判断语句才能实现同样的功能。
2. 适应性：递归算法往往具有适应性强，因为它的思路非常类似于自上而下阅读程序执行过程的思路。因此，无论什么时候，只要涉及树形结构或者数据集合的处理，都可以考虑采用递归方式。
3. 模块化程度高：使用递归算法可以将一个大型任务分解成多个小任务，每个小任务只需要做好当前的工作即可，不需要等待其他小任务的完成。这样，程序的结构也更加清晰。
4. 减少堆栈消耗：由于递归算法在执行过程中创建了新的栈帧，每一次递归调用都会占用一定的内存，当递归调用层次太多时，可能会导致栈溢出。但是，如果使用迭代算法，那么就不会存在这个问题。
### 缺点
1. 使用过深的递归会导致栈溢出：由于递归调用的次数不断增加，所以其所需的空间也会逐渐增长。当递归的深度过深时，就会出现栈溢出的错误。为了防止这种情况发生，必须确保递归调用的深度不要太深。
2. 可读性差：递归算法的可读性较差，因为它隐含着多层嵌套。另外，调试递归算法也比较困难。
3. 效率低下：递归算法的效率一般比迭代算法低。这是因为每次递归调用都需要保存现场并返回，这会带来额外的时间开销。
4. 非 tail recursion optimization（尾递归优化）: 在某些平台上，递归算法可能无法满足尾递归优化要求，导致编译器报错或者产生错误结果。为了避免这种情况，可以在递归算法的最后一步调用 return 之前修改一些值，而不是直接返回。
## 如何使用递归？
### 求斐波那契数列
斐波那契数列（Fibonacci sequence），又称黄金分割数列，是一个数列，其中第 i 个数字是前两个数字的总和，即 F(i)=F(i-1)+F(i-2)，其中 F(1)=1 和 F(2)=1 。例如，0、1、1、2、3、5、8、13、21、34……是斐波那契数列。
```python
def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```
这段代码实现了一个普通的递归版本的斐波那契数列求解算法。时间复杂度为 O(2^n)，会超时。为什么呢？原因是，对于 n 大于等于 3 的情况，递归的调用次数太多，导致栈溢出。
```python
fibonacci(7) # Output: 8
```
### 用递归求解最大公约数（GCD）
欧几里得算法（Euclidean algorithm）是计算两个正整数 a 和 b 的最大公约数的方法，该算法由费马-拉格朗日创立。
```python
def gcd(a,b):
    if b==0:
        return a
    else:
        return gcd(b,a%b)
```
这段代码实现了一个普通的递归版本的欧几里得算法。该算法的时间复杂度为 O(logmin(a,b))，相比于迭代算法，速度更快。
```python
gcd(96,64) # Output: 16
```
### 用递归生成排列（Permutation）
排列是从给定元素的一个序列中，按照一定的顺序选出来的不同元素的全集。根据元素个数的不同，排列共有 n! 种。
```python
def permutation(nums):
    def backtrack(first):
        if first == len(nums)-1:
            result.append(nums[:])
        for i in range(first,len(nums)):
            nums[first],nums[i] = nums[i],nums[first]
            backtrack(first+1)
            nums[first],nums[i] = nums[i],nums[first]

    result=[]
    backtrack(0)
    return result
```
这段代码实现了一个普通的递归版本的排列生成算法。该算法的时间复杂度为 O(N*N!)，远超过题目中给出的 O(N!)。
```python
permutation([1,2,3]) # Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
### 用递归实现二叉树遍历
二叉树的遍历（Traversal）是指对二叉树进行一个访问，得到其节点值的序列。二叉树的遍历有四种基本形式，包括先序遍历、中序遍历、后序遍历、以及层序遍历。
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def preorderTraversal(root):
    """
    :type root: TreeNode
    :rtype: List[int]
    """
    res = []
    def traverse(node):
        if not node:
            return 
        res.append(node.val)
        traverse(node.left)
        traverse(node.right)
        
    traverse(root)
    return res 

def inorderTraversal(root):
    """
    :type root: TreeNode
    :rtype: List[int]
    """
    res = []
    stack = []
    
    while True:
        while root:
            stack.append(root)
            root = root.left
        
        if not stack:
            break
            
        curr_node = stack.pop()
        res.append(curr_node.val)
        root = curr_node.right
        
    return res 
        
def postorderTraversal(root):
    """
    :type root: TreeNode
    :rtype: List[int]
    """
    res = []
    stack = [root]
    
    while stack:
        node = stack[-1]
        if (not node.left and not node.right):
            res.append(stack.pop().val)
        elif node.right:
            prev = None
            
            while node.right!= prev:
                prev = node
                stack.append(node)
                node = node.right
                
            res.append(stack.pop().val)
            node = node.left
        else:
            res.append(stack.pop().val)
            
    return res
    
def levelOrder(root):
    """
    :type root: TreeNode
    :rtype: List[List[int]]
    """
    if not root:
        return []
        
    queue = deque()
    queue.append(root)
    res = []
    
    while queue:
        size = len(queue)
        level = []
        
        for _ in range(size):
            curr = queue.popleft()
            level.append(curr.val)
            
            if curr.left:
                queue.append(curr.left)
                
            if curr.right:
                queue.append(curr.right)
                
        res.append(level)
        
    return res
```
这段代码分别实现了四种基本形式的递归遍历。其中，先序遍历和中序遍历有着不同的递归入口，它们会先处理左子树还是右子树。后序遍历没有改变根结点位置。层序遍历使用队列实现。
```python
preorderTraversal(buildTree([1,None,2,3])) #[1,2,3]
inorderTraversal(buildTree([1,None,2,3])) #[2,1,3]
postorderTraversal(buildTree([1,None,2,3])) #[2,3,1]
levelOrder(buildTree([3,9,20,None,None,15,7])) #[[3],[9,20],[15,7]]
```