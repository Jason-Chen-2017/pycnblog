
作者：禅与计算机程序设计艺术                    

# 1.简介
         
 函数式编程（Functional Programming）是一个编程范式，它提供了很多优点，如数据不可变、纯函数、引用透明性等，可以帮助我们更好地组织代码和管理复杂的业务逻辑。本文会以一个例子介绍函数式编程的优势，并以此引出一些概念和术语。希望能够帮助读者快速了解函数式编程在实际项目中的应用。
          为什么要用函数式编程？
          这里先提一下为什么要用函数式编程。如果你经历过企业级应用开发，或是一个大型互联网公司的高层，你肯定听说过“企业级应用都是用函数式编程”。那么，到底什么是函数式编程呢？和其他编程范式相比，函数式编程有哪些优势？
          1. 数据不可变
          在函数式编程中，数据的状态不可改变。比如，整数a=2；a=3是不可能的。函数式编程中的数据不可变，意味着每次调用函数时，输入参数都是相同的，而且没有副作用，保证了函数的纯度。只有纯函数才能在程序中引入副作用，导致函数不能像普通函数一样被测试。
          2. 纯函数
          纯函数指的是对于相同的输入，总会有相同的输出。换句话说，就是该函数不会产生任何影响外部世界的状态变化。也就是说，不依赖于任何外部变量或者参数，也不会产生任何可观察到的副作用，只返回结果值。也就是说，函数没有隐藏的状态或者变量，每次调用都得到确定的结果。
          3. 引用透明性
          引用透明性，又叫作纯度，是函数式编程的重要属性之一。它表现为，所有引用到函数内部的数据类型的值都是不可变的，对数据的任何修改都会立即反映到引用的数据结构上。换句话说，引用透明性保证了数据的一致性。
          所以，函数式编程将程序编写方式抽象成计算，使得程序更容易理解和维护。同时，通过纯函数和引用透明性，函数式编程可以帮助我们更好地控制程序的行为和数据的流动，从而提升程序的稳定性和健壮性。
          然而，函数式编程还是有一些缺点。比如，由于在程序运行期间修改数据的方式限制了函数的表现力，可能会造成难以预测的结果。另外，函数式编程语言通常比较复杂，学习曲线陡峭。本文以一个例子介绍函数式编程的优势。
          
          # 2.示例: 用Python实现判断两条线是否相交
          
          我们假设有一个二维坐标系上的空间，空间里有一条线段ab(x1,y1)——(x2,y2)，另一条线段cd(x3,y3)——(x4,y4)。如何判断这两条线段是否相交，即两个线段有没有交点？
          
          ## 方法一：暴力求解法
          
          暴力求解法就是遍历所有的点，判断两条线段有无共同的端点，这样的时间复杂度是O(n^2)。举个例子：
          
          ```python
          def check_crossing(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
              for x in range(max(ax1,bx1), min(ax2,bx2)+1):
                  for y in range(max(ay1,by1), min(ay2,by2)+1):
                      if (x-ax1)*(bx2-ax1)-(bx1-ax1)*(y-ay1)==0 and \
                          (x-bx1)*(ax2-bx1)-(ax1-bx1)*(y-by1)==0:
                          return True
              return False
          ```
          
          判断两条线段相交时，需要考虑很多条件，比如端点重合、斜率不等、线段交于单点等。
          
          ## 方法二：数学证明法
          
          数学证明法则认为，任意两条线段如果相交，那么他们必定存在重点，而且共同的端点必定在两条线段延长线的交点处。因此，我们可以找出一条直线l，并且让它穿过ab和cd。l的方程为：y - k*x = b。其中b表示直线的截距。显然，l在ab上方，且在cd左侧，否则它就不相交。
          
          为了确定是否共同的端点，我们再找出另一条直线r，让它垂直于ab，并穿过bc和da。其方程为：k'*(x+dx) + dy = c'*(x+dx) + e。其中dx,dy分别为da与ab之间的向量，c',e为r与bc之间的向量。对于任意的d∈{bc,da}，我们有：
          
          | dx |   | d   |   | c'|    |  ab   | 
          | --- |---| ----|---|---|------|
          | dy | * | 1/k | = |-c'| -1/k'*|  bc   |
          
          根据矢量叉乘的定义，可以得到：

          | (c'×b)+(e×a)|     |ac|      | ac × bc|
          | -------------|-----|---|--------|---------|
          | |r'| |(b-a)/2|     |ca| ≠ 0      |
          
          可以看到，当且仅当r'与bc和da有相同的方向时，两条线段才有共同的端点。所以，如果以上条件成立，则线段ab与线段cd相交。如果以上条件不成立，则两条线段不相交。
          
          通过数学证明法，我们得到如下Python代码：
          
          ```python
          import math
          
          def point_distance(px, py, qx, qy):
              return math.sqrt((qx - px)**2 + (qy - py)**2)
      
          def line_equation(p1, p2):
              a = p2[1] - p1[1]
              b = -(p2[0] - p1[0])
              c = -(a*p1[0]+b*p1[1])
              return [a, b, c]
      
          def intersected(line1, line2):
              a1, b1, _ = line1
              a2, b2, _ = line2
              determinant = a1*b2 - a2*b1
              if abs(determinant)<1e-9:
                  return False, None, None
              dx = b2*(-b1*c1+b2*c2)/(determinant**2)
              dy = (-a2)*(-b1*c1+b2*c2)/(determinant**2)
              inter_point = (c1+dx*a1, c2+dy*a2)
              dist1 = point_distance(*inter_point, *(line1[:2]))
              dist2 = point_distance(*inter_point, *(line2[:2]))
              cross1 = ((line1[0]-inter_point[0])*dist2-(line1[1]-inter_point[1])*dist1)\
                   /math.sqrt(((line1[0]-inter_point[0])**2+(line1[1]-inter_point[1])**2))
              cross2 = ((line2[0]-inter_point[0])*dist1-(line2[1]-inter_point[1])*dist2)\
                   /math.sqrt(((line2[0]-inter_point[0])**2+(line2[1]-inter_point[1])**2))
              return bool(abs(cross1)>1e-9 and abs(cross2)>1e-9), inter_point, (dist1, dist2)
          
          
          def check_crossing(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):
              line1 = line_equation([ax1,ay1],[ax2,ay2])
              line2 = line_equation([bx1,by1],[bx2,by2])
              _, intersection, distances = intersected(line1, line2)
              if not intersection or max(distances)<1e-9:
                  return False
              else:
                  x, y = intersection
                  return (min(ax1,ax2)<x<max(ax1,ax2) and min(ay1,ay2)<y<max(ay1,ay2) and \
                        min(bx1,bx2)<x<max(bx1,bx2) and min(by1,by2)<y<max(by1,by2))
                      
          print(check_crossing(0,0,1,1,0,2,1,3))  # output:True
          print(check_crossing(0,0,1,1,0,2,-1,3)) # output:False
          ```
          
          此外，还有基于矩阵运算的方法，但由于矩阵运算的复杂性，目前还不是主流方法。