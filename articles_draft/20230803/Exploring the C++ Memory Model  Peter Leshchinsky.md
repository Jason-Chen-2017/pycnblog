
作者：禅与计算机程序设计艺术                    

# 1.简介
         

         C++ memory model (内存模型) 定义了各个变量访问在内存中的位置的方法和顺序。每种编译器都提供了不同的内存模型实现方法，因此在编写并行多线程或分布式程序时需要了解其工作机制及适用场景。本文通过剖析C++内存模型中重要概念和相关机制，介绍编译器不同内存模型的差异及适用场景，为读者提供参考。
         
         作者：Peter Leshchinsky，博士，美国爱荷华大学信息科学系博士生导师，现任首席科学顾问、美国C++标准化委员会( Committee on C++ Standardization )主席。著有《Effective C++》一书、《C++ Concurrency in Action》一书、《The Art of Multiprocessor Programming》一书等经典作品。
         
         ## 一、引言
        
         C++语言是一个多面性很强的语言，既支持过程式编程，又支持面向对象编程和泛型编程。但是，由于历史原因导致C++往往存在数据竞争和死锁的问题，所以，为了提高程序的正确性和并发性，需要更好的控制内存访问。C++11引入了新的内存模型，提出了概念上“内存顺序”和“同步原语”的概念，通过这些概念能够有效地解决多线程间的数据共享和同步问题。这个新的内存模型非常重要，是理解C++多线程编程的基础。
         
         在对新内存模型进行深入讨论之前，先简要回顾一下“程序的执行顺序”和“顺序一致性”两个概念。程序的执行顺序指的是一个程序从头到尾的指令序列执行的顺序，顺序一致性则指在多个处理器上运行同一个程序时，各处理器执行同一条指令的结果相同。然而，在多处理器系统上，每个处理器都可以按照任意的顺序执行自己的指令，这就带来了一个麻烦——如何保证各处理器上执行的指令顺序一致？如果不一致，就可能造成程序出现错误。因此，保证顺序一致性，主要靠硬件提供的原子指令和缓存一致性协议。
         
         在以前的CPU架构中，指令的执行可以分为以下几种类型：
         
         + 数据流指令：它们将数据从源地址传输到目的地址，包括加载指令（mov）、存储指令（stor）等；
         + 控制转移指令：它们修改程序计数器，使得程序的执行跳转到其他地方，包括条件跳转指令（branch）、调用指令（call）、返回指令（return）等；
         + 浮点运算指令：用于浮点运算；
         + 其他类型的指令，如向量、SIMD、加密等。
         
        现代计算机系统通常会同时兼容多个数据流指令和控制转移指令，这些指令可能会影响执行顺序，比如，可以把常数值作为源操作数送至目的操作数所在的寄存器内，这样就可以把它移动到程序执行的某个特定位置。为了保障指令的顺序一致性，系统通常会给出一些原子指令和同步原语，其中原子指令是不可中断的一个整体，同步原语是由一组原子指令构成的序列，用于确保指令的执行顺序，而不会被其他指令打乱。
        
        ### 二、内存模型的定义
        
        “内存模型”一词有两种含义：
        
        + 一种是计算机科学里所谓的内存模型，是指计算机系统在进行程序计算时，一个内存位置上的值可能取自于何处、以何种方式更新，以及如何刷新到主存中。它一般是抽象的，并不涉及具体的CPU架构，也不一定真实反映了实际的硬件设计。例如，最简单的CPU cache一致性模型，就是通过读取缓存来模拟整个系统内存的行为。
        + 另一种是高级编程语言里的内存模型，它描述了变量的访问顺序以及更新规则。也就是说，C++内存模型描述了程序执行期间对变量的访问和更新，以保证合法地并发地访问内存。
        
        ### 三、内存模型中重要的概念
        首先，“内存模型”由两部分组成：一个是内存序（memory order），另一个是同步原语（synchronization primitives）。
        
        #### 1. 内存序
        
         内存序是指程序在不同线程之间的访问、重排、冲突关系，以及发生缺页等事件时的处理方式。内存序分为以下四类：
         
         + acquire-release：该内存序要求所有线程以串行的方式访问内存资源，直到释放锁才可继续执行。该类内存序适用于临界区，例如互斥锁。
         + relaxed：该内存序允许单线程和同时发生的线程以任何顺序访问内存资源。该类内存序适用于无需线程同步的代码块，例如仅包含简单的赋值语句。
         + seq_cst：该内存序要求所有线程以串行的方式访问内存资源，且禁止重排序。该类内存序适用于需要线程安全的关键代码段。
         + compiler：该内存序由编译器指定，但不是绝对的，因为还有编译器优化的空间。该类内存序适用于需要编译器优化的程序。
         
        在下面示例代码中，thread1和thread2之间传递了参数，按照默认的seq_cst内存序，应该按顺序输出参数，否则可能造成参数输出混乱。
        
        ```c++
        int main() {
            std::vector<int> v;
            std::mutex mtx;
            
            auto worker = [&]() {
                for (int i=0; i<100000; ++i) {
                    mtx.lock();   // acquire lock
                    v.push_back(i);    // release lock
                    mtx.unlock();
                }
            };
            
            std::thread t1(worker), t2(worker);
            t1.join();
            t2.join();
            
            for (auto x : v) {
                std::cout << x << " ";
            }
            return 0;
        }
        ```
        
        如果程序不声明内存模型，则根据编译器默认设置的内存模型来决定执行顺序。对于某些编译器来说，顺序一致性也属于relaxed内存序，所以可能造成输出随机。
        
        #### 2. 同步原语
         
        同步原语是用于实现线程间通信的工具。C++11定义了六种同步原语：条件变量cond_var、互斥锁mutex、读写锁shared_mutex、通知信号notify_all和通知信号notify_one。
         
        **条件变量**：condition variable是用于线程间通信的原语，它的作用是等待一个特定的条件（条件变量）成立后再唤醒线程。条件变量需要配合互斥锁使用。
        
        **互斥锁**：互斥锁（mutex）用于避免多个线程同时访问临界资源。当一个线程获得互斥锁时，其他线程只能等待，直到互斥锁被释放。通常，互斥锁可以用来保护临界区的代码。例如：
        
        ```c++
        mutex mtx;
        
        void critical_section() {
            // code that must be executed atomically
           // access to shared data protected by the mutex
        }
        ```
         
        **读写锁**：读写锁（shared_mutex）可以让多个线程同时对同一资源进行读操作，但只允许单个线程对资源进行写操作。当读写锁在一个线程上被上锁，则所有其他线程均不能在此上锁。当读写锁被上锁，则必须解锁才能被其他线程重新上锁。读写锁可以帮助提升性能，因为它允许并发读操作的并发度降低。例如：
        
        ```c++
        shared_mutex rw_mtx;
        
        void read_operation() {
            unique_lock<shared_mutex> lk(rw_mtx);
             // read access to shared data
            // only one thread can hold a write lock at any given time 
        }

        void write_operation() {
            unique_lock<shared_mutex> lk(rw_mtx, defer_lock);
             // wait until no threads have a read or write lock
            while (!lk.try_lock()) {} 
             // lock exclusively for writing
            // other threads will block here until we unlock
            // update shared data
            // then unlock
            lk.unlock();
        }
        ```
         
        **通知信号**：通知信号（notify_*）可以用来唤醒正在等待某个事件（条件）的线程。通知信号需要配合条件变量一起使用。例如：
        
        ```c++
        condition_variable cv;
        bool ready = false;
        
        void signaler() {
           ...
            notify_all();     // wake up all waiting threads 
           ...
        }

        void waiter() {
           ...
            cv.wait(lk,[&ready]{ return ready == true; });    // wait until flag is set
           ...
        }
        ```
         
        上述六种同步原语都可以使用在多线程编程中，它们对数据的访问控制、同步与协调十分重要。例如，如果一个线程在访问共享数据的时候，其他线程必须等待它完成访问，则互斥锁就会起作用；如果一个线程需要通知其他线程某个事件已经发生，则通知信号就会起作用。
         
        通过这些概念的了解，读者可以更好地理解C++内存模型，并应用到自己的项目中，提高并发程序的正确性、效率和稳定性。