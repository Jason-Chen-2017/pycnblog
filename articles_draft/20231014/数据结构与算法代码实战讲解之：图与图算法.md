
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、什么是图？
在图论中，图（Graph）由顶点和边组成，由无向边或者有向边相连组成。有时也用邻接表表示法对图进行存储。其特点是顶点可以直接通过边连接到其他顶点，因此不存在孤立点。在计算领域，图通常用来描述复杂系统或网络结构，如交通网络、互联网路由、股票市场等。
## 二、为什么要学习图算法？
如果说数组是一种线性的数据结构，那么图就是一种非线性的数据结构。因为图不仅存在着节点之间的关系，还可能存在着边之间的关系。比如，在航空交通中的航线图就是一个带权重的图，其权重反映了航线上的风险程度，而图的最短路径算法就是为了找出最小风险路线。再比如，在计算机网络中，如何找出距离最近的路由器就是一个经典的问题，而图的广度优先搜索和深度优先搜索就是寻找这个问题的有效算法。因此，了解图算法对于处理复杂的数据和建立智能系统都至关重要。

本篇教程重点讨论图的基本概念和应用场景，并介绍图算法的一些经典问题及其解决方案。希望通过这些内容，读者能够掌握图的一些基础知识，能够理解图的各类算法实现方式，并且掌握一些常用的算法。由于时间仓促，这篇文章难免有疏漏和错误之处，敬请指正！
# 2.核心概念与联系
## 一、图的定义和抽象数据类型
### （1）图的定义
在图论中，图由顶点集合V和边集E组成，顶点和边分别称为结点和弧。图G=(V,E)是一个邻接矩阵的形式表示，其中$|V|=n,\ |E|=m$。图G由一组无序的顶点V和边集E构成，每条边(u,v)∈E表示结点u和v之间存在一条连接。若两个结点间没有连接，则称它们没有边相连。
### （2）图的抽象数据类型
图的抽象数据类型主要由两部分组成：顶点集合V和边集E。顶点用V来表示，它是一个动态集合，它的元素可以有两种情况，第一种情况是元素直接对应着图中某一顶点；第二种情况是元素是某个值，即它可以作为图的顶点，但是不能直接对应任何顶点，因为它没有名字。图的边用E来表示，它是一个二元组集合，它的元素的第一项是边的起始点，第二项是边的终止点。如果第三个元素存在的话，则它代表着该边的权重。例如，假设边的权重是一个整数，那边可以用(u,v,w)表示，其中u和v分别代表起始点和终止点，w代表边的权重。

对于图来说，其抽象数据类型可以用如下C++代码表示：

```c++
class Graph{
    private:
        vector<vector<int>> adj; // 邻接矩阵
        int V;   // 顶点数
        int E;   // 边数

    public:
        Graph(int v){
            V = v;
            E = 0;
            for (int i=0;i<=V;i++){
                vector<int> temp(V+1,0);
                adj.push_back(temp);
            }
        }

        void addEdge(int u, int v){
            adj[u][v] = 1;
            E++;
        }

        void delEdge(int u, int v){
            if (!adj[u][v]) return ;    // 如果该边不存在，则退出
            adj[u][v] = 0;
            E--;
        }

        bool hasEdge(int u, int v){
            return adj[u][v];
        }
        
        friend ostream& operator << (ostream &out, const Graph &g){
            for (int i=0;i<g.V;i++){
                out<<"Vertex "<<i<<": ";
                for (int j=0;j<g.V;j++)
                    if (g.hasEdge(i,j)) cout<<j<<" ";
                cout<<endl;
            }
            return out;
        }
};
```

图的初始化函数`Graph()`接受一个参数V，表示图的顶点数。它首先创建了一个大小为V+1的二维向量，其每个元素均为空向量。然后初始化一个变量E为0，表示当前图的边数。同时还有一个类友元函数operator<<用于输出图的信息。


## 二、图的相关术语
### （1）顶点的度
对于图G=(V,E), 定义$deg(v)$为顶点v的度，即所有与v相关联的边的数目。记为$|N(v)|$，其中N(v)是与v邻接的顶点的集合。

### （2）顶点的入度
对于图G=(V,E), 定义$in-degree(v)$为顶点v的入度，为从外部指向内部的边的数量。记为$d^-(v)$ 或 $id(v)$，其中d^-(v)表示从外部指向内部的边的数目。

### （3）顶点的出度
对于图G=(V,E), 定义$out-degree(v)$为顶点v的出度，为从内部指向外部的边的数量。记为$d^+(v)$ 或 $od(v)$，其中d^+(v)表示从内部指向外部的边的数目。

### （4）子图
对于图G=(V,E)，子图H=(H,F)是由图G的一个子集V'和另一个子集E'组成的图。其中$V' \subseteq V$，$E' \subseteq E$。如果顶点v∈V',则边(u,v)∈E'意味着从u到v的一条路径包含v。换句话说，顶点v被包括在子图H中，但除了那些它所邻接的顶点外，其他的所有顶点都不会被包括进来。类似地，边e∈E'被包括在子图H中，但除了与它相关联的顶点e'外，其他的所有边都不会被包括进来。

### （5）简单图
对于图G=(V,E)，称G为简单图当且仅当G中不存在自环和平行边。如果不存在自环，则称G为不含回路的图。简单图被广泛应用于图论中，主要原因是很多算法的运行时间复杂度都是对数级别的，因此在实际应用中需要保证所有的输入图都是简单图。

### （6）连通图
对于图G=(V,E)，如果对任意两个顶点v和w，存在一条路径连接v和w，则称G为连通图。在计算机科学和通信工程中，很多问题都可以转换为图问题，解决这些问题通常依赖于图的连通性质。例如，在有向图中，计算出是否存在回路是一个NP-难问题，所以几乎不可能解决。然而，对于连通图，可以利用分治策略求解，其时间复杂度达到多项式级别。

### （7）强连通图
对于图G=(V,E)，称G为强连通图当且仅当G中所有顶点都具有相同度，或者不存在正则树的完全图，即不可能将图的顶点分割为两个子集，使得这两个子集具有相同的度序列，且不存在连通子图，其内部包含任何一个连通子图。换言之，G的所有顶点都属于同一强连通分支。强连通图在生物信息学和网络流传输方面有广泛应用。

## 三、图的生成树
### （1）生成树
对于图G=(V,E)，生成树T=(T,A)，其中A是T的边集。生成树的目标是使T覆盖整个图G，并且通过它的所有顶点到所有的其它顶点都有路径。它可以看作是最短的连通子图，但这不是唯一的。有时只需要T中的边即可，这时称T为最小生成树。

一个图的最小生成树有时无法直接找到。常见的算法有Kruskal算法和Prim算法。

### （2）Kruskal算法
Kruskal算法是由Moore和Russel于1956年提出的算法。Kruskal算法用于构造生成树，适用于稠密图，且不考虑边的权重。它首先按权重递增顺序排列边，然后选择权重最小的边加入生成树，直至形成一棵树为止。选择边的方法是，如果它的端点都不在生成树中，则加入；否则，丢弃。

Kruskal算法的时间复杂度是$O(ElogE)$。

### （3）Prim算法
Prim算法也是由Moore和Russel于1956年提出的算法。Prim算法用于构造生成树，适用于稠密图，且不考虑边的权重。它首先选取源点s，然后依次选取到生成树中的顶点，不断扩展生成树，直至把图中的所有顶点都加入为止。选择边的方法是，每次添加一条从源点s到新的顶点v的最短路径的边，然后从v扩展生成树。

Prim算法的时间复杂度是$O(ElogV)$。