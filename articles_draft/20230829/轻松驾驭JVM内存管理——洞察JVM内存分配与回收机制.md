
作者：禅与计算机程序设计艺术                    

# 1.简介
  

Java虚拟机（JVM）是一种跨平台、可执行字节码的仿真器，它负责把编译后的Java代码转化成底层系统能够直接运行的机器指令。在JVM中运行的程序一般称为虚拟机中的“实体”，而运行在JVM之上的应用则称为虚拟机环境中的“虚拟机进程”。由于JVM的高性能和动态特性，使得它成为当前被普遍使用的脚本语言、Web服务器、企业应用服务器、中间件等诸多领域的必备组件。通过对JVM进行深入的剖析和分析，读者可以对JVM内存分配与回收的过程有更全面的认识，从而更好地掌握JVM的运作机制和优化方法。因此，《轻松驾驭JVM内存管理》——《洞察JVM内存分配与回收机制》旨在通过提供经验丰富的程序员、架构师、CTO等各行各业的深度技术学习指南，帮助读者快速学习并掌握JVM内存管理原理和技巧，达到全面掌握JVM的目的。本文的主要受众为程序员、架构师、CTO等IT相关人员。
# 2.基本概念术语说明
## （一）JVM运行时数据区
JVM内存由若干不同的数据结构组成，如堆（Heap）、方法区（Method Area）、虚拟机栈（VM Stack）、程序计数器（PC Register），此外，还有一块直接内存（Direct Memory）。这五大数据区总共占据了JVM虚拟机的内存空间，分别用于存放类信息、常量、静态变量、运行时数据、JIT即时编译的代码缓存及内存分页等数据。其中堆是所有线程共享的一片内存区域，用来存储对象实例、数组等；方法区与永久代是JVM规范中的内存模型，其作用是存储类信息、常量、静态变量、即时编译代码缓存等；虚拟机栈和程序计数器都是线程私有的，存放着当前线程正在执行的方法的信息和状态；直接内存是基于本地函数库的堆外内存，可以提升JVM运行效率。
## （二）JVM堆内存分配原理
### 1.JVM堆内存划分
JVM堆内存由新生代、老年代、永久代三个部分组成。
- 年轻代（Young Generation）:主要用来存储短生命周期对象的内存。年轻代又分为Eden和两个Survivor区。
  - Eden区：在这个区中刚创建的对象都放在这里，当进行垃圾回收的时候，只清楚Eden区，如果对象经历过第一次GC后依然存活，那么它将被移动到survivor区中。
  - Survivor区：当eden区满的时候，所有的对象都会被复制到其中一个survivor区，当有一个survivor区已满，就会将另外一个空闲的survivor区中相同年龄的所有对象放入另一个survivor区中，直到所有对象都在survivor区中消亡，才会把这些对象送入另一块大的内存空间中（即老年代），再触发另一次完整的GC过程。
- 年老代（Old Generation）：主要用来存储长生命周期对象，一般占据整个堆内存的60%以上。
- 永久代（Permanent Generation）：主要用来存储Class的元数据，包括类、方法、字段等描述信息。


### 2.堆内存分配策略
#### 2.1 对象优先在Eden分配
除非出现老年代溢出，否则所有新创建的对象都将首先放入Eden区。因此，JVM的堆内存分配策略主要考虑的是如何减少在堆上创建对象的内存压力。

#### 2.2 大对象直接进入老年代
为了避免因单个大对象导致的内存占用过多，JVM提供了-XX:MaxTenuringThreshold参数设置对象从新生代晋升到老年代的最大年龄阈值。对象在Eden区内的平均存活时间较长，所以大对象也被迫提前进入老年代。可以通过-Xmx参数指定最大堆内存，超过该值就会触发Full GC。

#### 2.3 长期存活的对象进入老年代
为了减少老年代的内存压力，JVM提供了一种动态年龄判断策略。如果一个对象在Survivor区中熬过了n次GC仍然存活，并且这个对象的大小不超过Survivor区的一半，那么就将它移到老年代中。因为Survivor区的空间大小固定，只有老年代才有额外的空间容纳长期存活的对象。这样做的原因是一般长期存活的对象不会一直存在，而仅仅存在于内存中，所以它们不会对GC产生太大影响。通过设置-XX:TargetSurvivorRatio可以调整Survivor区中对象年龄的比例。

#### 2.4 空间担保
如果在Young GC之后仍然没有足够的内存满足新生代的需求，JVM会启动一次Full GC，但是这种情况下通常会耗费相对较长的时间。为了确保始终有足够的内存可用，JVM提供了-XX:+AlwaysPreTouch参数。JVM会预先扫描整个堆内存，并尽可能多地访问每个页表条目。这可以增加Full GC发生的几率，同时还可以降低后续Full GC的发生。

### 3.堆内存垃圾收集算法
#### 3.1 标记-清除算法
最基础的垃圾收集算法，分两步，第一步是标记出所有需要回收的对象，第二步是回收被标记的对象所占用的内存空间。缺点是效率不高，空间利用率低。
#### 3.2 复制算法
将内存按容量分为两个等大的相同的堆，每次只使用其中一个，在垃圾收集时将存活的对象复制到另一个堆。优点是简单易实现，缺点是浪费了一半的内存空间。
#### 3.3 标记-整理算法
与标记-清除算法类似，但在回收时不是直接将死亡对象清理掉，而是让其内存向一端移动，然后再清理另一端的内存。
#### 3.4 分代收集算法
根据对象的生死不同，采用不同的算法来回收内存。一般把java堆分为新生代、老年代、持久代三块，根据各自的特点选取不同的回收算法。在jdk1.8中新生代使用的是Parallel Scavenge和Parallel Old算法。老年代默认选择Serial Old。

## （三）JVM垃圾回收器
### 1.串行回收器（Serial Garbage Collector）
串行回收器是一个单线程的垃圾回收器。它只能用于小型内存数据集，且应用程序对吞吐量要求较高的场景。串行回收器的工作流程是“Stop the world”模式，即暂停其他所有活动线程的执行，然后进行垃圾收集，最后恢复所有线程的执行。串行回收器主要用于客户端模式下的虚拟机。
### 2.并行回收器（Parallel Garbage Collector）
并行回收器是一个多线程的垃圾回收器。它可以在多个处理器上并行收集垃圾，适合于那些具有多核处理器的服务器端虚拟机。并行回收器的工作流程是“Stop the world”模式，与串行回收器类似。但它将任务分布到多个线程上执行，缩短垃圾收集的时间。
### 3.并发标记清除(CMS)回收器
CMS回收器（Concurrent Mark Sweep）是一款优秀的垃圾回收器。它是以牺牲吞吐量和暂停时间换取获得 low pause 的高吞吐量。CMS的垃圾回收过程分为四个步骤。第一阶段是初始标记，只标记GC Roots能直接关联到的对象，速度很快；第二阶段是并发标记，遍历堆中所有对象，找出存活的对象，并记录与GC Roots直接关联的对象，标记过程需要耗费较长的时间；第三阶段是重新标记，修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录；第四阶段是并发清除，删除未标记的对象，释放内存空间。它主要用于后台服务模式下的虚拟机。
### 4.Garbage-First(G1)回收器
G1回收器（Garbage First）是OpenJDK 9默认的垃圾回收器。它将堆内存分割成多个大小不一的独立区域，并跟踪每个区域的垃圾分配，同时维护一个最小的堆内数据集。每次运行时，它只对包含垃圾的区域进行回收。它不像之前的回收器一样，需要在整个堆空间范围内遍历所有对象，因此在处理大内存应用时，它能显著提高垃圾回收的效率。除了在后台服务模式下运行外，它还能在混合环境（例如部分后台线程和部分交互式线程）中运行，因此能降低停顿时间。
### 5.ZGC回收器
ZGC（Low-Latency GC）是一种低延迟的垃圾回收器，主要针对极端内存敏感的工作负载设计。它把堆划分为固定大小的“page”集合，称为“segments”。当启用ZGC时，应用程序可以使用连续内存地址，但是物理上仍然可能分散在多个segments中。对堆的碎片和碎片合并非常敏感，因此ZGC可以实现非常低的延迟，在秒级甚至毫秒级的程度。它目前处于实验性质，尚未完全投入使用。

## （四）JVM性能调优
### 1.内存调优
#### 设置堆大小
-XX:InitialHeapSize设置初始堆大小，默认为物理内存的1/64。
-XX:MaxHeapSize设置最大堆大小，默认为物理内存的1/4。
-Xms设置最小堆大小，默认为-XX:InitialHeapSize的值。
-Xmx设置最大堆大小，默认为-XX:MaxHeapSize的值。
可以通过jinfo或jmap命令查看初始、最大、最小、当前堆大小。
#### 设置堆占用
-XX:ReservedCodeCacheSize设置存放JIT编译代码的内存大小。
可以通过设置-XX:MetaspaceSize或者-XX:CompressedClassSpaceSize来设置元数据区和压缩类空间的大小。
#### 设置并行垃圾回收器的参数
-XX:ConcGCThreads设置并发垃圾回收线程数。
-XX:ParallelGCThreads设置并行垃圾回收线程数。
#### 设置老年代的调优
-XX:NewSize设置新生代初始大小。
-XX:MaxNewSize设置新生代最大大小。
-XX:PermSize设置永久代初始大小。
-XX:MaxPermSize设置永久代最大大小。
可以通过设置-XX:SurvivorRatio来设置eden与survivor的比例，默认eden与survivor的比例为8:1。
#### 设置gc日志输出级别
-XX:+PrintGCDetails打印每次GC的详细信息。
-XX:+PrintGCDateStamps打印每次GC的时间戳。
-XX:+PrintGCTimeStamps打印每次GC的时间戳。
-XX:+PrintGCApplicationStoppedTime打印应用程序运行时间。
-XX:+PrintSafepointStatistics打印线程阻塞情况。
### 2.gc调优
#### 查看垃圾回收统计信息
jstat命令显示JAVA进程的各种运行期间收集器的统计信息。可以通过-gc参数选择要监视的垃圾回收器。例如：jstat -gc pid 每隔1s打印一次进程pid的垃圾回收信息。

#### 使用-XX:+UseConcMarkSweepGC或-XX:+UseParNewGC切换垃圾回收器
-XX:+UseConcMarkSweepGC选项启用CMS回收器，默认开启。
-XX:+UseParNewGC选项启用并行回收器，默认关闭。
#### 指定gc算法
-XX:+UseG1GC启用G1回收器。
#### 调整gc参数
修改GC的参数对系统性能的影响非常大，应谨慎选择参数。以下是一些重要的参数：
-Xmn<size>设置年轻代大小，如果堆内存较大，可以适当增大年轻代大小以获得较好的性能。
-Xms<size>设置初始堆大小。
-Xmx<size>设置最大堆大小。
-XX:SurvivorRatio=<ratio>设置eden与survivor的比例。
-XX:PretenureSizeThreshold=<size>设置大对象阈值，超过该阈值的对象将直接在老年代分配。
### 3.方法区调优
-XX:MaxMetaspaceSize设置元数据区大小。
-XX:MetaspaceSizePerClass设置每种类的元数据的大小。
-XX:MinMetaspaceFreeRatio设置空闲空间低于该比例时，触发Full GC。
-XX:MaxMetaspaceFreeRatio设置空闲空间高于该比例时，触发Full GC。