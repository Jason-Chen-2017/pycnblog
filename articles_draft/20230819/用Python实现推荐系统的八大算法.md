
ä½œè€…ï¼šç¦…ä¸è®¡ç®—æœºç¨‹åºè®¾è®¡è‰ºæœ¯                    

# 1.ç®€ä»‹
  

æ¨èç³»ç»Ÿæ˜¯äº’è”ç½‘é¢†åŸŸçš„ä¸€é¡¹é‡è¦åº”ç”¨ï¼Œå®ƒé€šè¿‡åˆ†æç”¨æˆ·çš„è¡Œä¸ºä¹ æƒ¯ã€å–œå¥½åå¥½ã€å†å²è´­ä¹°è®°å½•ç­‰æ–¹é¢ä¿¡æ¯ï¼Œå‘ç”¨æˆ·æ¨èå•†å“æˆ–æœåŠ¡ï¼Œå¸®åŠ©ç”¨æˆ·å‘ç°ã€æ¯”è¾ƒå¹¶é€‰æ‹©æ„Ÿå…´è¶£çš„å†…å®¹ï¼Œæå‡ç”¨æˆ·ä½“éªŒåŠå•†ä¸šåˆ©ç›Šã€‚ç›®å‰å¸‚åœºä¸Šæ¨èç³»ç»Ÿçš„ç®—æ³•ç§ç±»ç¹å¤šï¼Œä½†å„ç±»ç®—æ³•åˆå­˜åœ¨ç€åƒä¸ä¸‡ç¼•çš„è”ç³»ï¼Œä¸åŒçš„ç®—æ³•ä¹‹é—´ä¹Ÿä¼šäº§ç”Ÿäº¤å‰ä½œç”¨ï¼Œè¿™äº›å…±æ€§å’Œç‰¹æ€§å¯¼è‡´æ¨èæ•ˆæœå‚å·®ä¸é½ã€‚å› æ­¤ï¼ŒæŒæ¡å¤šä¸ªä¸åŒç±»å‹ç®—æ³•åŠå…¶åœ¨æ¨èç³»ç»Ÿä¸­çš„åº”ç”¨æ–¹æ³•å¯¹äºè®¾è®¡å‡ºé«˜æ•ˆä¸”å®ç”¨çš„æ¨èç³»ç»Ÿååˆ†é‡è¦ã€‚æœ¬æ–‡å°†ä»æœ€ç®€å•çš„åŸºäºç‰©å“ç›¸ä¼¼åº¦çš„ååŒè¿‡æ»¤ç®—æ³•ã€åŸºäºç”¨æˆ·çš„ååŒè¿‡æ»¤ç®—æ³•ã€åŸºäºä¸Šä¸‹æ–‡çš„ååŒè¿‡æ»¤ç®—æ³•ã€åŸºäºå› å­åˆ†è§£æœºï¼ˆFunk-SVDï¼‰çš„æ¨èç³»ç»Ÿç®—æ³•ã€åŸºäºæ·±åº¦å­¦ä¹ çš„æ¨èç³»ç»Ÿç®—æ³•ã€æ‹“å±•æ¨èç³»ç»Ÿç®—æ³•ã€æ··åˆæ¨èç³»ç»Ÿç®—æ³•ç­‰8ä¸ªæ–¹é¢å¯¹æ¨èç³»ç»Ÿç®—æ³•è¿›è¡Œä»‹ç»ã€‚å¹¶é€šè¿‡ä¸€äº›ä»£ç å®ä¾‹å±•ç¤ºä¸åŒç®—æ³•ä¹‹é—´çš„å·®å¼‚ä»¥åŠä¼˜ç¼ºç‚¹ã€‚
# 2.1 åŸºäºç‰©å“ç›¸ä¼¼åº¦çš„ååŒè¿‡æ»¤ç®—æ³•
## 2.1.1 ç®—æ³•æè¿°
åŸºäºç‰©å“ç›¸ä¼¼åº¦çš„ååŒè¿‡æ»¤ç®—æ³•æ˜¯æ¨èç³»ç»Ÿä¸­æœ€åŸºç¡€ã€æœ€ç»å…¸çš„ä¸€ç§æ¨èç®—æ³•ã€‚å®ƒå‡è®¾ç”¨æˆ·æ²¡æœ‰ä»€ä¹ˆç‹¬ç‰¹çš„åå¥½ï¼Œä»–åªæ ¹æ®è‡ªå·±è¿‡å»çš„è¡Œä¸ºä¹ æƒ¯ã€å–œå¥½åå¥½ç­‰ä¿¡æ¯è¿›è¡Œæ¨èã€‚è¯¥ç®—æ³•åŸºäºç”¨æˆ·æ‰€è´­ä¹°çš„ç‰©å“ä¹‹é—´çš„å…±åŒå–œå¥½ç¨‹åº¦ï¼Œå¯¹æ¯ä¸€ä¸ªç”¨æˆ·æ¨èå¯èƒ½æ„Ÿå…´è¶£çš„ç‰©å“ã€‚ä»¥ä¸‹å…¬å¼ä¸ºåŸºäºç‰©å“ç›¸ä¼¼åº¦çš„ååŒè¿‡æ»¤ç®—æ³•çš„è®¡ç®—å…¬å¼ï¼š



å…¶ä¸­ï¼šğ‘¥(i,j): ç”¨æˆ·ğ‘– çš„ç‰©å“ğ‘— çš„å±æ€§å€¼ã€‚æ¯”å¦‚ï¼Œç”¨æˆ·ğ‘– çš„ç‰©å“ğ‘— çš„è¯„åˆ†å€¼ã€‚

ğœ‡(i,k): ç”¨æˆ·ğ‘– çš„ç¬¬ğ‘˜ä¸ªæ¨èç‰©å“çš„å±æ€§å€¼ã€‚

ğœ(i,k): ç”¨æˆ·ğ‘– å¯¹æ¨èç‰©å“ğ‘˜ çš„å…´è¶£åº¦ã€‚

ğ‘ (i,j): ç”¨æˆ·ğ‘– å’Œğ‘— éƒ½å·²ç»è´­ä¹°çš„ç‰©å“é›†åˆã€‚

è¯¥ç®—æ³•é‡‡ç”¨åŸºäºç”¨æˆ·çš„ååŒè¿‡æ»¤ç®—æ³•ä½œä¸ºåº•å±‚çš„æ¨èæ¨¡å‹ï¼Œåªæ˜¯åœ¨æœ€åä¸€æ­¥æŠŠç”¨æˆ·çš„è¯„åˆ†è½¬åŒ–ä¸ºç‰©å“çš„ç›¸ä¼¼åº¦åˆ†æ•°ã€‚æ¨èç»™æ¯ä¸ªç”¨æˆ·çš„ç‰©å“åˆ—è¡¨å¯è§†ä½œæ˜¯ç”¨æˆ·çš„ç‰¹å¾çŸ©é˜µã€‚
## 2.1.2 ä»£ç å®ç°
```python
import numpy as np
from scipy.spatial import distance

def cosine_similarity(x, y):
    """
    Compute the cosine similarity between two vectors x and y using scipy.spatial.distance library.
    :param x: a vector of float values (n,)
    :param y: another vector of float values with same shape as x
    :return: a scalar value indicating the cosine similarity between x and y
    """
    return distance.cosine(x,y)

class ItemBasedCF():
    def __init__(self, ratings):
        self.ratings = ratings

    def train(self):
        item_similarities = {}
        n_users, n_items = self.ratings.shape

        for i in range(n_items):
            items = list(range(n_items))
            del items[i]

            similarities = []
            for j in items:
                rating_matrix = self.ratings[:, [i, j]]
                # filter out users who have not rated both i and j
                common_users = set(rating_matrix[:, 0]).intersection(set(rating_matrix[:, 1]))

                if len(common_users) > 1:
                    user_rating = rating_matrix[(rating_matrix[:, 0].isin(list(common_users))) &
                                                 (rating_matrix[:, 1].isin([i])), :]

                    A = user_rating[:, 0].values - np.mean(user_rating[:, 0])
                    B = user_rating[:, 1].values - np.mean(user_rating[:, 1])

                    sim = cosine_similarity(A,B)[0][1]

                    similarities.append((sim, j))

            sorted_similarities = sorted(similarities, reverse=True)[:3]
            
            # add top 3 most similar items to dictionary
            item_similarities[str(i)] = [(index, score) for (score, index) in sorted_similarities]
        
        self.item_similarities = item_similarities
        
    def predict(self, user_id, k=3):
        n_users, n_items = self.ratings.shape
        
        known_items = self.ratings[user_id, :].nonzero()[1]

        predictions = []
        for item in range(n_items):
            if item in known_items or str(item) not in self.item_similarities: continue

            scores = []
            weights = []
            for neighbor, weight in self.item_similarities[str(item)]:
                if neighbor in known_items: continue
                
                weighted_score = self.ratings[user_id,neighbor]*weight
                scores.append(weighted_score)
                weights.append(weight)
                
            if len(scores) == 0: continue

            predicted_score = sum(np.array(scores)*np.array(weights))/sum(weights)

            predictions.append((predicted_score, item))
            
        sorted_predictions = sorted(predictions, reverse=True)[:k]
                
        return [(index, score) for (score, index) in sorted_predictions]
``` 

# 3. åŸºäºç”¨æˆ·çš„ååŒè¿‡æ»¤ç®—æ³•