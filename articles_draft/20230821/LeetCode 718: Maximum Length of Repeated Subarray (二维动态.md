
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在本次题目中，给定两个整数数组 `nums1` 和 `nums2`，返回两个数组中最长公共子序列的长度。

**Example:**
```
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The longest common subsequence is "321", which its length is 3. 
```

# 2. 基本概念术语说明
## 2.1. 最长公共子序列
### 定义
最长公共子序列（LCS）问题是在两个序列中找出一个最长的子序列，使得该序列元素按照顺序同时出现在两个序列里。例如，对于两个序列 `[A,B,C]` 和 `[D,B,E,F,G]`，其最长公共子序列为 `[B,C]` ，因为它包含了序列中的所有元素，并且元素都出现在相同的位置。如果不存在这样的子序列，则称为空集。

### 性质
- LCS问题是一个二维空间中的最优搜索问题。
- 求解最长公共子序列时，要求找到两个序列的最长公共子序列。因此，如果存在多个最长公共子序列，则只能输出其中一个。
- 如果只有一个元素，那么它的最长公共子序列就是自身。
- 任意两个序列的最长公共子序列都可以拆分成两个子序列，其中左边的子序列是第一个序列，右边的子序列是第二个序列的最长公共子序列。
- 两个序列的最长公共子序列的长度等于它们各自最长公共子序列的最小值减去1，即：
  - $|LCS(X, Y)|=min(|LCS(X_1,Y), |LCS(X,Y_1)|)$
  
## 2.2. 动归推导法
动归推导法是一种分析最优解的通用方法，由英国计算机科学家罗宾·马尔可夫于1977年提出。由于它已经成为许多领域的基础算法，故此，我们将先介绍这种方法。

### 定义
**动归（dynamic programming）**：指的是在不增加额外内存或占用过多时间资源的情况下解决复杂问题的方法。动态规划基于递归的方式，通过一系列迭代来求解问题。相比于朴素递归方法，动归的特点是每一步只需计算一次状态，避免重复计算。

**推导法（deduction method）**：也称作计算法、决策树法、矩阵乘法等。它提供了一种更直接的方法来验证复杂问题的最优子结构和边界情况。

### 思想
从定义和例子出发，动归推导法的过程如下：

1. 确定问题的状态空间。即设$f[i][j]$表示输入字符串$s_i...s_m$与$t_n...t_j$的最长公共子序列的长度，其中$1\leq i\leq m, 1\leq j\leq n$。
2. 给定初始条件$f[i][i]=len_{i}(s_i)$，表示最短的单字符子序列，并且这一条路径肯定是一条有效的序列。
3. 从小到大的填入状态方程。
   + **考虑状态$(i,j)$的情况**。当$s_i$与$t_j$匹配的时候，那么就可以将$f[i+1][j+1]$看做一个独立的状态，即$f[i+1][j+1]\rightarrow f[i][j]+1$。这是由于，当$s_i$与$t_j$匹配的时候，最长公共子序列要么就包含$s_i$，要么就包含$t_j$，但是不能同时包含两者。因此，需要分别计算$s_i$与$t_j$是否作为最长公共子序列的一部分，取其中较长的一个，然后加上1得到$f[i][j]$。如果$s_i$或者$t_j$没有在另一个字符串中出现，那么就可以把当前的空格看做一个独特的状态，即$f[i+1][j], f[i][j+1]\rightarrow f[i][j]+1$。这是由于，若两个字符串都不包含某个元素，那么最长公共子序列仅包含空格，因此总长度要么就等于空格个数，要么就等于空格个数减1。
   + **考虑状态$(i,j)$的转移方向**。根据上面的分析，当$s_i$与$t_j$匹配的时候，$f[i][j]$的计算依赖于$f[i+1][j+1]$，而$f[i+1][j+1]$的计算又依赖于$f[i][j]$，所以$f[i][j]$应该在$f[i+1][j+1]$之前进行计算。反之，若$s_i$或者$t_j$没有在另一个字符串中出现，$f[i][j]$的计算也可以交给$f[i+1][j], f[i][j+1]$，无所谓。
   + **考虑状态$(i,j)$是否合法**。显然，当$s_i$或者$t_j$不存在的时候，我们就不需要更新$f[i][j]$的值了，因为它并不参与最长公共子序列的计算。

# 3. 核心算法原理和具体操作步骤以及数学公式讲解
## 3.1. 一维动态规划
假设现在有两个一维数组`num1`和`num2`, 数组元素均为非负整数。我们要求找到这两个数组的最长公共子序列。

最简单的方法就是逐一遍历两个数组，找到两个数组中相同的元素，加入到一个新数组中，最后这个新数组即为最长公共子序列。时间复杂度为$O((N_1+N_2)^2)$, N1和N2分别为数组num1和num2的长度。

## 3.2. 二维动态规划
为了解决这个问题，我们可以使用动归的方法来求解。

还是以上面给出的两个数组`num1=[1,2,3,2,1]`和`num2=[3,2,1,4,7]`为例。首先我们初始化一个二维数组`dp`大小为`(len(num1)+1)*(len(num2)+1)`, 其中`dp[i][j]`表示第`i`行，第`j`列对应的元素值。这里我们还需要另外创建一维数组`prev`大小为`len(num1)*len(num2)`用于记录最优路劲。

### 初始化
令`dp[i][0]`=`dp[0][j]`=`0`, `i=1 to len(num1)`, `j=1 to len(num2)`。

### 更新
在更新阶段，我们使用递归来实现。当`dp[i][j]>max(dp[i-1][j], dp[i][j-1])`时，我们认为`num1[i-1]`和`num2[j-1]`构成了一个新的最长公共子序列。因此，我们可以记住`dp[i-1][j-1]`的位置坐标`coord=(i-1, j-1)`。我们再回溯，更新`prev[k]`的值，直至`prev[coord[0]*len(num2)+coord[1]]=None`。也就是说，最优路劲向前追溯到第一个元素`num1[i-1]`和`num2[j-1]`的位置，记住它的下标`k`。

因此，更新公式为：
$$
if num1[i-1]==num2[j-1]:
    dp[i][j]=dp[i-1][j-1]+1
    prev[(i-1)*len(num2)+(j-1)]=k
else:
    if max(dp[i-1][j], dp[i][j-1]):
        coord=argmax{(dp[i-1][j]-1),(dp[i][j-1]-1)}
        k=int(coord/(len(num2)))
        dp[i][j]=dp[k//len(num2)][k%len(num2)]+1
        for p in range(coord*len(num2)+k):
            prev[p]=prev[p+1]
        prev[-1]=k
    else:
        dp[i][j]=0
$$


### 返回结果
最终，我们需要获取`dp`数组的最后一个元素即可获得整个最长公共子序列的长度。也就是说，`res=dp[-1][-1]`。

# 4. 具体代码实例和解释说明
## 4.1. Python代码实现
```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        # initialize dp array and backtrack matrix
        dp = [[0] * (n+1) for _ in range(m+1)]
        prev = [(i*n+j) // abs(j-i) if i > 0 and j > 0 else None for i in range(m+1) for j in range(n+1)]
        
        # fill up the dynamic programming table
        for i in range(1, m+1):
            for j in range(1, n+1):
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                    prev[(i-1)*n+(j-1)] = ((i-1)*n+(j-1)-abs(j-i)) % ((i-1)*(j-1))
                elif dp[i-1][j] >= dp[i][j-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i][j-1]
                    
        return dp[m][n]
    
    def backtrack(self, prev, start):
        res = []
        while True:
            pos = prev[start]
            if pos is None or pos <= 0: break
            res.append((pos // self.n + 1, pos % self.n + 1))
            start = pos
            
        return list(reversed(res))
    
```