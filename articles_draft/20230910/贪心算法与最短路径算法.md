
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 什么是贪心算法？
“贪心”指的是在对问题求解时，总是做出当前看起来最好的选择，也就是说，不从整体最优上加以考虑，他所做出的仅是局部最优解。贪心算法（Greedy Algorithm）是一种简单有效的算法，适用于很多应用场景。比如说，用来解决约束满足问题、图形识别、负载平衡、调度问题等等。
## 为什么要学习贪心算法？
贪心算法具有以下几个重要特征：

1.简单性：通过一步步地进行，得到全局最优解。即，贪心算法往往能够在较小的时间内获得可行解。

2.效率高：在很多实际问题中，贪心算法都可以达到很好的效果。如求图中的最小生成树，求最优进度计划等等。

3.无后悔性：贪心算法在每一步选择的基础上都没有回头的机会。

4.自然性：贪心算法往往能够产生最优或次优解，而不会陷入局部最优解陷阱。

## 贪心算法主要运用领域
贪心算法主要运用于图论、组合优化、动态规划、机器学习、经济、生物信息、算法设计、资源分配等领域。它有着良好的理论基础和实践价值。
# 2.基本概念术语说明
## 概念
- ### 图
  - 在图论中，图是由点和边组成的一个数据结构。点表示对象，边代表关系。一个图由一个带权重的边集V(v)和顶点集E(e)表示。其示意图如下：
  
  
  - ### 无向图
    - 无向图中任意两个顶点之间都存在一条边，称作无向图。比如：
    
    
    - ### 有向图
      - 有向图中，每条边都有一个方向，表示一个从源顶点到目标顶点的有向边。比如：
      
      
    - ### 稀疏图
      - 如果一个图中边的数量远小于它的顶点数量的平方，则称该图为稀疏图。比如：
    
        
    - ### 完全图
      - 完全图是指对于任意两点间都存在边相连，并且每个顶点都与其他所有顶点都相连的图。比如：
      
       
  ## 术语
  - ### 顶点
    - 图中的一个顶点，或者说是节点，是由顶点名称标识的实体。在不同领域的定义也不一样，比如在网络中，顶点通常是一个网址；在交通领域，顶点可以是城市、地铁站等；在生物信息领域，顶点可能是一个基因。
    
  - ### 度量
    - 描述顶点之间的连接程度。度的定义取决于图的类型，有不同的度量标准。比如在无向图中，顶点u的度D(u)是指与顶点u直接相连的边的个数，顶点v的度D(v)是指与顶点v直接相连的边的个数，则称为度分布函数。
  # 3.核心算法原理和具体操作步骤以及数学公式讲解
  ## Prim算法
  ### 概念
  Prim算法是一种用于计算最小生成树的算法，它的基本想法是每次选取一条连接起始点到某一顶点的边，使新增一条边后的子图成为一个独立连通子图，然后重复这个过程，直至所有顶点都已被切分。

  ### 操作步骤
  1. 选择一个顶点作为初始顶点s
  2. 创建一个包含s的集合S，并将其余所有顶点加入集合T
  3. 初始化一个空集合C，并令树中最短距离为无穷
  4. 当集合T为空的时候，结束算法，返回最小生成树。否则执行下面的步骤：

     a. 选择集合T中所有距离s最近的顶点k，并记为vk

     b. 将vk加入集合C

     c. 删除集合T中与vk相邻的所有顶点。即删除集合T中那些不再与C中的某个顶点相邻的顶点。如果一个顶点被删去之后，其邻接边中最小的边权对应的顶点也会被删除。

     d. 更新集合S中所有顶点的最短距离。因为删除了与vk相邻的顶点，所有与vk直接相连的顶点的最短距离需要重新计算。

     5. 执行第四步，直至集合T为空。

      6. 返回最小生成树。

      ### 复杂度分析
      - ### 时间复杂度
        - 每个顶点只需遍历一次邻接表，故Prim算法的运行时间为$O(|V|+|E|)$,其中|V|是顶点数，|E|是边数。

      - ### 空间复杂度
        - 存储每个顶点的最短距离，故空间复杂度为$O(|V|)$.

  ### 代码实现
    ```python
    def prim(graph):

        n = len(graph)
        vis = [False] * n      # 判断顶点是否被访问过
        dist = [float('inf')] * n    # 初始化顶点的最短距离
        parent = [-1] * n     # 初始化前驱顶点

        start = 0             # 设置起始点为0

        vis[start] = True       # 标记起始点为已访问
        dist[start] = 0         # 设置起始点的最短距离为0

        for i in range(n-1):
            min_dist = float('inf')   # 记录最小距离
            u = None                   # 记录下标

            for j in range(n):        # 寻找未访问过的顶点及其距离起始点最近的
                if not vis[j] and dist[j]<min_dist:
                    min_dist = dist[j]
                    u = j

            vis[u] = True              # 标记选定的点为已访问
            for v, w in graph[u]:
                if not vis[v] and w<dist[v]:
                    dist[v] = w          # 更新距离
                    parent[v] = u        # 更新前驱顶点

        result = []                  # 保存最小生成树
        last = n-1                   # 从最后一个顶点开始
        while last!= -1:            # 不断寻找父节点，直到找到起始点
            result.append((last, parent[last]))   # 添加边
            last = parent[last]

        return [(parent[i], i) for i in range(len(parent))] + list(reversed(result))
    ```
  ### PPT例题
  1. 最大团问题（Maximum Clique Problem）
  - ### 最大团问题
  最大团问题（Maximal Cliques Problem）是指给定一个图G=(V,E)，寻找一个团C=∩{v∈V: deg(v)>1}，使得|C|最大。团是由至少三个顶点组成的子图，任何两个顶点之间都有且只有一条边。最大团问题就是在一个无向图中，找出包含尽可能多的顶点的团。

  2. 旅行推销员问题（Traveling Salesman Problem, TSP）
  - ### 旅行推销员问题
  旅行推销员问题（Traveling Salesman Problem, TSP）是指给定一系列城市和对应坐标，求解通过这些城市所有的城市只通过一次，并且回到原点的最短路径长度。

  给定一个带权重的连通无向图G，其中顶点集为V={v1,v2,...,vn}，边集为E={(vi,vj),wij},其中wi>=0为边的权重，求解图中存在的一条最短路径p，使得p中经过的各个顶点除了最后一个顶点外，都恰好出现一次，且最后一个顶点恰好回到原点。