
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、什么是范式？
范式(normal form)是对关系型数据库的一种逻辑结构化方法，是为了解决数据冗余、数据不一致和查询效率等问题而提出的。
在范式理论的描述中，通常将关系模式分成不同的级别，分别为第一范式、第二范式、第三范式和BCNF范式等。最初的三范式理论是1971年由罗伯特·科尔茨、迈克尔·杜恩和詹姆斯·戴利首次提出。后续在经历了大量实践、对性能分析和工程实现上都进行了改进，逐渐形成了四个范式理论。

范式的概念，可以让我们更加清晰地理解关系型数据库中的数据。对于关系型数据库而言，每一个关系模式（表）都是由若干属性或字段组成。如果按照某个范式来组织关系模式，那么关系模式中就只包含以下形式的属性或字段：

1. 每个元组（tuple）必须是不可拆分的原子值；
2. 属性之间没有传递依赖（非主属性不能被任何其他属性所决定），也不会存在多重依赖；
3. 每个关系模式至少要有一个主键（primary key）用来唯一标识元组。

比如一个学生成绩表关系模式如下：

| 学号 | 年级 | 班级 | 姓名 | 语文 | 数学 | 英语 |
|:----:|:---:|:----:|:----:|:---:|:---:|:---:|
|   1 |  2017|     A| 小明|  80|  90|  85|
|   2 |  2017|     A| 小红|  70|  80|  85|
|   3 |  2017|     B| 小王|  90|  85|  90|

从上面的例子看出，这个关系模式满足第三范式，即每个关系模式至少有一个主键，且所有的属性均无传递依赖。由于语文、数学、英语各自独立于其他属性，因此不存在多重依赖。而年级、班级、姓名三个属性则存在传递依赖，但是也符合非主属性不能被任何其他属性所决定，所以仍然满足第三范式的要求。因此，学生成绩表这个关系模式可以视作是一个第三范式的关系模式。

## 二、为什么要设计范式？
随着互联网网站的兴起，越来越多的网站应用需要处理海量的数据，当数据越来越复杂时，关系型数据库的表结构不得不考虑到一些设计上的取舍。设计范式就是为了解决这些问题而提出的一种方案。它保证数据的完整性，减少数据冗余，提高查询效率。同时，范式还可以简化查询语句，使得数据库系统更容易优化和管理。

例如，如果某一天，你发现了一个性能问题，需要分析数据库访问日志，却发现数据库系统的性能非常差。分析完日志之后，你发现数据库的访问模式存在大量数据冗余，导致查询效率非常低下。通过设计范式，你可以把数据按照合理的设计模式来组织，甚至可以采用反范式设计，比如引入视图或者用存储过程代替复杂的SQL查询。这样做可以有效降低数据库的开销并提升数据库的整体性能。

范式并不是一劳永逸的，其本质还是为了提高数据查询效率和完整性，只有正确认识并运用范式，才能充分发挥数据库的优势。下面，我们一起学习一下如何更好地设计范式。

# 2.核心概念与联系
## 1.第一范式
第一范式(1NF)是指一个关系模式的所有属性都是单值依赖的。换句话说，就是确保每一个元组（tuple）都只能拥有一个值，并且该值必须是不可分解的原子值。

例如，学生信息表：

| 学号 | 姓名 | 年龄 | 性别 |
|:----:|:----:|:----:|:----:|
|   1 | 张三 |   20|     M|
|   2 | 李四 |   19|     F|

由于年龄、性别两个属性的值可能是组合的，因此不能保证它们都是单值依赖的。例如，张三的性别可能是男生，但年龄不一定是20岁，因此年龄与性别两者是多值依赖的。所以，年龄和性别都属于非第一范式的范畴。

## 2.第二范式
第二范式(2NF)是指一个关系模式中不包含部分函数依赖。换句话说，就是所有非主属性都完全函数依赖于键码（primary key）。也就是说，要想确定一个元组的某个属性的值，必须要先知道它的键码，再根据这个键码获取其他的属性。

例如，学生信息表：

| 学号 | 姓名 | 年龄 | 性别 |
|:----:|:----:|:----:|:----:|
|   1 | 张三 |   20|     M|
|   2 | 李四 |   19|     F|

如果没有完全函数依赖关系，比如有以下两个元组：

| 学号 | 姓名 | 年龄 | 性别 |
|:----:|:----:|:----:|:----:|
|   3 | 王五 |   22|     M|
|   4 | 赵六 |   18|     F|

其中，李四的性别是女孩，他的年龄不是19岁，因此出现了不一致的数据。所以，学生信息表不能满足第二范式。

如果将学生信息表修改如下：

| 学号 | 姓名 | 年龄 | 性别 |
|:----:|:----:|:----:|:----:|
|   1 | 张三 |   20|     M|
|   2 | 李四 |   19|     F|
|   3 | 王五 |   22|     M|
|   4 | 赵六 |   18|     F|

增加一个主键`id`，作为学生信息表的索引。那么，李四的年龄就必须依赖于`id`属性。所以，可以满足第二范式。

## 3.第三范式
第三范式(3NF)是指一个关系模式必须是第二范式，且所有多值依赖都必须放在主键前面。换句话说，就是主键不能包含部分依赖关系。

例如，学生信息表：

| 学号 | 姓名 | 年龄 | 性别 |
|:----:|:----:|:----:|:----:|
|   1 | 张三 |   20|     M|
|   2 | 李四 |   19|     F|
|   3 | 王五 |   22|     M|
|   4 | 赵六 |   18|     F|

由于主键包含了性别和年龄两个属性，虽然性别和年龄都与姓名相关，但是他们不属于键码。因此，这种关系模式不满足第三范式。

但是，如果修改主键为`(学号, 姓名)`：

| 学号 | 姓名 | 年龄 | 性别 |
|:----:|:----:|:----:|:----:|
|   1 | 张三 |   20|     M|
|   2 | 李四 |   19|     F|
|   3 | 王五 |   22|     M|
|   4 | 赵六 |   18|     F|

可以看到，主键`（学号，姓名）`可以唯一确定一条记录。所以，第三范式就得到满足。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解

## （一）第一范式与第二范式转换算法
### 第一范式的定义
> 1NF: 满足列不可拆分原则，即每个列（attribute）具有原子性，不可再分。即数据单元不可再分解，不能由多个单元组成。

### 第一范式转换算法
> 在已知某一关系R的情况下，将关系R中的每一行中的值属性值确定下来，而不能将其分割，即每一行只能包含单个值。

**步骤:** 

1. 查找非主属性和主属性。 
2. 对每一非主属性A，检查其是否直接依赖于其他非主属性。 
3. 如果依赖，则将该依赖关系移动到主属性上，直到不再依赖于其他非主属性为止。 
4. 将原来的非主属性删除，替换为新的主属性。 
5. 检查新建立的主属性能否满足1NF。 
6. 重复步骤2-5，直到所有属性都在满足1NF为止。

## （二）第三范式转换算法
### 第三范式的定义
> 3NF: 满足第三范式的关系模式中，如果不存在非主属性指向候选键，则称之为第三范式。在进行数据库设计时应尽可能满足3NF标准。

### 第三范式转换算法
> 如果一个关系模式R的关键字发生变化，则需要通过删除或添加属性的方式来达到第三范式。

**步骤:** 

1. 检查是否存在多个键，若存在则选择其中一个作为主关键字。 
2. 删除其他键，保留主关键字。 
3. 检查非主关键字的函数依赖关系。 
4. 从右往左依次判断，如果出现函数依赖关系A->B，则删除属性A，否则继续判断。 
5. 判断完成后，剩下的属性可以认为都是主属性。 
6. 验证当前的关系模式是否满足3NF。 
7. 重复步骤2-6，直到满足3NF为止。