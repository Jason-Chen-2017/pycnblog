                 

### 2024年京东校招技术面试题集锦：算法编程题库及解析

#### 1. 逆序对的数量

**题目：** 给定一个数组 `nums`，返回数组中的逆序对的数量。逆序对指的是，对于数组中的两个下标 `i` 和 `j`，如果 `i < j` 且 `nums[i] > nums[j]`，则 `(i, j)` 是一个逆序对。

**示例：**  
输入：`nums = [2, 4, 1, 3, 5]`  
输出：`3`  
解释：存在三个逆序对：(2, 1)、(4, 1) 和 (4, 3)。

**答案：** 使用归并排序求解。

```go
func reversePairs(nums []int) int {
    return mergeSort(nums)
}

func mergeSort(nums []int) int {
    if len(nums) < 2 {
        return 0
    }
    mid := len(nums) / 2
    leftCount := mergeSort(nums[:mid])
    rightCount := mergeSort(nums[mid:])
    mergeCount := merge(nums[:mid], nums[mid:])
    return leftCount + rightCount + mergeCount
}

func merge(nums1, nums2 []int) int {
    i, j := 0, 0
    count := 0
    for i < len(nums1) && j < len(nums2) {
        if nums1[i] > nums2[j] {
            count += len(nums1) - i
            j++
        } else {
            i++
        }
    }
    return count
}
```

**解析：** 归并排序过程中，每次比较两个数组的元素，若右数组元素小于左数组元素，则计算出左数组剩余元素与右数组当前元素的逆序对数量，累加到结果中。

#### 2. 二进制数位操作

**题目：** 给定一个整数 `n`，返回其二进制表示中，连续 1 的最大个数。

**示例：**  
输入：`n = 1993`  
输出：`3`  
解释：二进制表示为 `11000100111`，有三个连续 1。

**答案：** 使用位操作。

```go
func maxConsecutive Ones(n int) int {
    maxCount, count := 0, 0
    for n > 0 {
        if n&1 == 1 {
            count++
            maxCount = max(maxCount, count)
        } else {
            count = 0
        }
        n >>= 1
    }
    return maxCount
}
```

**解析：** 逐位判断整数 `n` 是否为 1，若是则计数器加 1，若是 0 则重置计数器。每次更新最大连续 1 的个数。

#### 3. 快速幂

**题目：** 实现快速幂算法，给定一个整数 `base` 和一个正整数 `exponent`，返回 `base` 的 `exponent` 次方。

**示例：**  
输入：`base = 2, exponent = 10`  
输出：`1024`

**答案：** 使用递归。

```go
func myPow(x float64, n int) float64 {
    if n == 0 {
        return 1
    }
    if n < 0 {
        return 1 / myPow(x, -n)
    }
    half := myPow(x, n/2)
    if n%2 == 0 {
        return half * half
    }
    return x * half * half
}
```

**解析：** 快速幂算法通过递归，将指数减半，减小计算次数。若指数为负，则计算倒数。

#### 4. 找出重复的数

**题目：** 给定一个包含 `[1, n]` 中数字的数组，找出重复出现的数字。

**示例：**  
输入：`nums = [2, 3, 1, 0, 2, 5, 3]`  
输出：`2` 或 `3`

**答案：** 利用数组的原地交换。

```go
func findRepeatNumber(nums []int) int {
    n := len(nums)
    for i := 0; i < n; {
        if nums[i] != i + 1 {
            j := nums[i]
            nums[i], nums[j] = nums[j], nums[i]
            if nums[i] == i+1 {
                return i + 1
            }
        } else {
            i++
        }
    }
    return -1
}
```

**解析：** 通过原地交换，将数字移动到正确的位置。若某位置已为正确数字，则继续下一步。

#### 5. 二维数组中的查找

**题目：** 在一个二维数组中（每个一维数组的长度相同），给定一个整数，判断是否存在该整数。

**示例：**  
输入：`matrix = [[1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]`，`target = 5`  
输出：`true`

**答案：** 使用剪枝搜索。

```go
func findNumberIn2DArray(matrix [][]int, target int) bool {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }
    for i := 0; i < len(matrix); i++ {
        for j := 0; j < len(matrix[0]); j++ {
            if matrix[i][j] == target {
                return true
            }
            if matrix[i][j] > target {
                break
            }
        }
    }
    return false
}
```

**解析：** 从右上角开始搜索，若当前元素大于目标值，则向下移动；若当前元素小于目标值，则向左移动。

#### 6. 数组中重复的数

**题目：** 给定一个整数数组 `nums`，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数应返回 `true`。否则返回 `false`。

**示例：**  
输入：`nums = [1, 2, 3, 1]`  
输出：`true`

**答案：** 使用哈希表。

```go
func containsDuplicate(nums []int) bool {
    m := make(map[int]bool)
    for _, num := range nums {
        if _, ok := m[num]; ok {
            return true
        }
        m[num] = true
    }
    return false
}
```

**解析：** 将数组中的每个元素作为键存储在哈希表中，若发现重复键，则返回 `true`。

#### 7. 寻找旋转排序数组中的最小值

**题目：** 已知一个升序排列的数组在预先未知的某个点上进行了旋转。请找出并返回数组的最小元素。

**示例：**  
输入：`nums = [3, 4, 5, 1, 2]`  
输出：`1`

**答案：** 使用二分查找。

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 利用二分查找，若中间元素大于最右边的元素，则最小值在右侧，否则在左侧。

#### 8. 存在重复元素

**题目：** 给定一个整数数组，判断是否存在重复元素。

**示例：**  
输入：`nums = [1, 2, 3, 1]`  
输出：`true`

**答案：** 使用排序。

```go
func containsDuplicate(nums []int) bool {
    sort.Ints(nums)
    for i := 1; i < len(nums); i++ {
        if nums[i] == nums[i-1] {
            return true
        }
    }
    return false
}
```

**解析：** 将数组排序后，逐个比较相邻元素，若发现相同元素，则存在重复。

#### 9. 最大子序和

**题目：** 给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（至少包含一个数）。

**示例：**  
输入：`nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`  
输出：`6` （`[4, -1, 2, 1]` 的和为 `6`）

**答案：** 使用动态规划。

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    maxSum := nums[0]
    currSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }
    return maxSum
}
```

**解析：** 动态规划，保存当前子序列的最大和，以及当前的最大子序列和。

#### 10. 只出现一次的数字

**题目：** 给定一个整数数组，找到其中只出现一次的数字。

**示例：**  
输入：`nums = [2, 2, 1, 1, 5, 3, 3]`  
输出：`5`

**答案：** 使用哈希表。

```go
func singleNumber(nums []int) int {
    m := make(map[int]int)
    for _, num := range nums {
        m[num]++
    }
    for num, count := range m {
        if count == 1 {
            return num
        }
    }
    return 0
}
```

**解析：** 将数组中的每个数字及其出现次数存储在哈希表中，然后找到出现次数为 1 的数字。

#### 11. 合并两个有序数组

**题目：** 将两个已排序的数组合并为一个有序数组。

**示例：**  
输入：`nums1 = [1, 2, 3, 0, 0, 0]，nums2 = [2, 5, 6]`  
输出：`[1, 2, 2, 3, 5, 6]`

**答案：** 使用双指针。

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    t := len(nums1) - 1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[t] = nums1[p1]
            p1--
        } else {
            nums1[t] = nums2[p2]
            p2--
        }
        t--
    }
    for p2 >= 0 {
        nums1[t] = nums2[p2]
        p2--
        t--
    }
}
```

**解析：** 从两个数组的尾部开始比较，将较大的数放到合并后的数组尾部，直到一个数组结束，然后将剩余的元素填充到合并后的数组中。

#### 12. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**  
输入：`intervals = [[1,3],[2,6],[8,10],[15,18]]`  
输出：`[[1,6],[8,10],[15,18]]`

**答案：** 使用排序。

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return intervals
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := intervals
    for i := 1; i < len(ans); i++ {
        if ans[i][0] <= ans[i-1][1] {
            ans[i] = [2]int{ans[i-1][0], max(ans[i-1][1], ans[i][1])}
        } else {
            ans = append(ans[:i], ans[i+1:]...)
            i--
        }
    }
    return ans
}
```

**解析：** 对区间进行排序，然后合并重叠区间。若当前区间与前一区间重叠，则合并为一个区间。

#### 13. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找到它们最长的公共子序列。

**示例：**  
输入：`text1 = "abcde"，text2 = "ace"`  
输出：`"ace"`

**答案：** 使用动态规划。

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    i, j := m, n
    ans := ""
    for dp[i][j] > 0 {
        if text1[i-1] == text2[j-1] {
            ans = string(text1[i-1]) + ans
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return ans
}
```

**解析：** 动态规划，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。

#### 14. 最小覆盖区间

**题目：** 给定一个数组 `nums`，其中包含一些连续的数字（可能是重复的），找到覆盖这些数字的最小连续区间。

**示例：**  
输入：`nums = [1, 3, 3, 3, 2, 4, 3, 5]`  
输出：`[2, 4]`

**答案：** 使用哈希表。

```go
func minCoveringInterval(nums []int) []int {
    m := make(map[int]bool)
    for _, num := range nums {
        m[num] = true
    }
    start, end := math.MaxInt32, math.MinInt32
    for num := range m {
        if num < start {
            start = num
        }
        if num > end {
            end = num
        }
    }
    return []int{start, end}
}
```

**解析：** 将数组中的数字存储在哈希表中，然后找到最小的起始和结束数字，以覆盖所有出现的数字。

#### 15. 翻转字符串中的单词

**题目：** 给定一个字符串，将字符串中的单词进行翻转。

**示例：**  
输入："the sky is blue"  
输出："blue is sky the"

**答案：** 使用字符串切片。

```go
func reverseWords(s string) string {
    words := strings.Fields(s)
    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
        words[i], words[j] = words[j], words[i]
    }
    return strings.Join(words, " ")
}
```

**解析：** 将字符串分割成单词切片，然后对单词进行反转，最后拼接成字符串。

#### 16. 有效的括号

**题目：** 给定一个字符串，判断其是否为有效的括号。

**示例：**  
输入："()"  
输出：`true`

**答案：** 使用栈。

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        if char == '(' || char == '{' || char == '[' {
            stack = append(stack, char)
        } else if len(stack) == 0 || (char != ')' && stack[len(stack)-1] != '(') || (char != '}' && stack[len(stack)-1] != '{') || (char != ']' && stack[len(stack)-1] != '[') {
            return false
        }
        stack = stack[:len(stack)-1]
    }
    return len(stack) == 0
}
```

**解析：** 使用栈存储左括号，遇到右括号时，判断栈顶元素是否匹配，若匹配则弹出栈顶元素。

#### 17. 合并两个有序链表

**题目：** 给定两个已排序的链表，将它们合并为一个有序链表。

**示例：**  
输入：`l1 = [1, 2, 4]，l2 = [1, 3, 4]`  
输出：`[1, 1, 2, 3, 4, 4]`

**答案：** 使用递归。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归地比较两个链表的当前节点，将较小的节点连接到前一个节点，并递归地处理下一个节点。

#### 18. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**  
输入：`intervals = [[1,3]，[2,6]，[8,10]，[15,18]]`  
输出：`[[1,6]，[8,10]，[15,18]]`

**答案：** 使用排序。

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return intervals
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := intervals
    for i := 1; i < len(ans); i++ {
        if ans[i][0] <= ans[i-1][1] {
            ans[i] = [2]int{ans[i-1][0], max(ans[i-1][1], ans[i][1])}
        } else {
            ans = append(ans[:i], ans[i+1:]...)
            i--
        }
    }
    return ans
}
```

**解析：** 对区间进行排序，然后合并重叠区间。若当前区间与前一区间重叠，则合并为一个区间。

#### 19. 寻找两个正序数组的中位数

**题目：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，找出这两个数组的中位数。

**示例：**  
输入：`nums1 = [1，3]，nums2 = [2]`  
输出：`2`

**答案：** 使用二分查找。

```go
func findMedianSortedArrays(nums1 []int，nums2 []int) float64 {
    if len(nums1) > len(nums2) {
        nums1，nums2 = nums2，nums1
    }
    m，n = len(nums1)，len(nums2)
    imin，imid，imax = 0，(m + n + 1) / 2，m
    for imin <= imax {
        i = (imin + imax) / 2
        j = (m + n + 1) / 2 - i
        if i < m && nums2[j - 1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i - 1] > nums2[j] {
            imax = i - 1
        } else {
            maxLeft = 0
            if i == 0 {
                maxLeft = nums2[j - 1]
            } else if j == 0 {
                maxLeft = nums1[i - 1]
            } else {
                maxLeft = max(nums1[i - 1]，nums2[j - 1])
            }
            if (m + n) % 2 == 1 {
                return float64(maxLeft)
            }
            minRight = 0
            if i == m {
                minRight = nums2[j]
            } else if j == n {
                minRight = nums1[i]
            } else {
                minRight = min(nums2[j]，nums1[i])
            }
            return (float64(maxLeft) + float64(minRight)) / 2
        }
    }
    return 0
}
```

**解析：** 使用二分查找，将数组分成两部分，找到中位数。

#### 20. 最小路径和

**题目：** 给定一个包含非负整数的 `m x n` 网格，找出从左上角到右下角的最小路径和。

**示例：**  
输入：`grid = [[1，3]，[1，5]，[4，2]，[4，6]]`  
输出：`11` （路径：`1 → 4 → 6`）

**答案：** 使用动态规划。

```go
func minPathSum(grid [][]int) int {
    m，n = len(grid)，len(grid[0])
    dp := make([][]int，m+1)
    for i := range dp {
        dp[i] = make([]int，n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            dp[i][j] = grid[i-1][j-1] + min(dp[i-1][j]，dp[i][j-1])
        }
    }
    return dp[m][n]
}
```

**解析：** 动态规划，保存从左上角到每个点的最小路径和。

#### 21. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个搜索函数，搜索一个给定目标值是否存在于数组中。数组可能包含重复元素。

**示例：**  
输入：`nums = [4，5，6，7，0，1，2]，target = 0`  
输出：`true`

**答案：** 使用二分查找。

```go
func search(nums []int，target int) bool {
    left，right = 0，len(nums) - 1
    for left <= right {
        mid = (left + right) / 2
        if nums[mid] == target {
            return true
        }
        if nums[left] < nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else if nums[left] > nums[mid] {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        } else {
            left++
        }
    }
    return false
}
```

**解析：** 对旋转排序的数组进行二分查找，同时处理重复元素。

#### 22. 合并有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的链表节点而形成的。

**示例：**  
输入：`l1 = [1，2，4]，l2 = [1，3，4]`  
输出：`[1，1，2，3，4，4]`

**答案：** 使用递归。

```go
func mergeTwoLists(l1 *ListNode，l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next，l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1，l2.Next)
    return l2
}
```

**解析：** 递归地比较两个链表的当前节点，将较小的节点连接到前一个节点。

#### 23. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 `n` 阶楼梯才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**  
输入：`n = 3`  
输出：`3`  
解释：3 种方法可以爬到楼顶。  
1. 1 阶 + 1 阶 + 1 阶  
2. 1 阶 + 2 阶  
3. 2 阶 + 1 阶

**答案：** 使用动态规划。

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    a，b := 1，2
    for i := 3; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }
    return b
}
```

**解析：** 动态规划，保存前两个数，依次计算出下一个数。

#### 24. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的链表节点而形成的。

**示例：**  
输入：`l1 = [1，2，4]，l2 = [1，3，4]`  
输出：`[1，1，2，3，4，4]`

**答案：** 使用递归。

```go
func mergeTwoLists(l1 *ListNode，l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next，l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1，l2.Next)
    return l2
}
```

**解析：** 递归地比较两个链表的当前节点，将较小的节点连接到前一个节点。

#### 25. 二进制中1的个数

**题目：** 给定一个非负整数，请计算它二进制表示中 1 的个数。

**示例：**  
输入：`n = 00000000000000000000000000001011`  
输出：`3`

**答案：** 使用位操作。

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 逐位判断整数是否为 1，若是则计数器加 1。

#### 26. 字符串转换整数 (atoi)

**题目：** 实现一个函数，将字符串转换成整数。如果数字无

