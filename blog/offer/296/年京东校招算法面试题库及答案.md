                 

### 2025年京东校招算法面试题库及答案

#### 1. 最长公共子序列

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子序列。

**示例：**  
`str1 = "ABCDGH"`  
`str2 = "AEDFHR"`  
最长公共子序列为 "ADH"，长度为 3。

**答案：**

```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

str1 = "ABCDGH"
str2 = "AEDFHR"
print(longest_common_subsequence(str1, str2))  # 输出 3
```

#### 2. 二分查找

**题目描述：** 给定一个有序数组 `arr` 和一个目标值 `target`，在数组中查找 `target` 的位置。

**示例：**  
`arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]`  
`target = 5`  
返回索引 4。

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
print(binary_search(arr, target))  # 输出 4
```

#### 3. 快速排序

**题目描述：** 实现快速排序算法。

**示例：**  
输入：`arr = [3, 2, 1, 4, 5, 6]`  
输出：`arr = [1, 2, 3, 4, 5, 6]`

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 2, 1, 4, 5, 6]
print(quick_sort(arr))  # 输出 [1, 2, 3, 4, 5, 6]
```

#### 4. 合并两个有序链表

**题目描述：** 给定两个已经排序的单链表 `l1` 和 `l2`，将它们合并成一个有序单链表。

**示例：**  
`l1 = [1, 3, 5]`  
`l2 = [2, 4, 6]`  
合并后：`[1, 2, 3, 4, 5, 6]`

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    if l1:
        current.next = l1
    if l2:
        current.next = l2

    return dummy.next

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
result = merge_sorted_lists(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
# 输出：1 2 3 4 5 6
```

#### 5. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**  
`nums = [2, 7, 11, 15]`  
`target = 9`  
返回 `[0, 1]`。

**答案：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []

nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # 输出 [0, 1]
```

#### 6. 最长递增子序列

**题目描述：** 给定一个无序的整数数组，找出其中最长递增子序列的长度。

**示例：**  
`nums = [10, 9, 2, 5, 3, 7, 101, 18]`  
返回 4，最长递增子序列为 `[2, 3, 7, 101]`。

**答案：**

```python
def length_of_lis(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_lis(nums))  # 输出 4
```

#### 7. 逆序对

**题目描述：** 给定一个数组 `nums`，返回数组中的逆序对的数量。

**示例：**  
`nums = [7, 5, 6, 4]`  
返回 5，存在五个逆序对：`(<7, 5>，<7, 6>，<7, 4>，<5, 6>，<5, 4>)`。

**答案：**

```python
def reverse_pairs(nums):
    def merge_sort(nums):
        if len(nums) <= 1:
            return nums
        mid = len(nums) // 2
        left = merge_sort(nums[:mid])
        right = merge_sort(nums[mid:])
        i = j = k = 0
        result = []
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                result.append(left[i])
                i += 1
            else:
                result.append(right[j])
                j += 1
                nonlocal count
                count += len(left) - i
        result.extend(left[i:])
        result.extend(right[j:])
        return result

    count = 0
    merge_sort(nums)
    return count

nums = [7, 5, 6, 4]
print(reverse_pairs(nums))  # 输出 5
```

#### 8. 最大子序和

**题目描述：** 给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（至少长度为 1）。

**示例：**  
`nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`  
返回 6，子数组 `[4, -1, 2, 1]` 的和最大，为 6。

**答案：**

```python
def max_subarray(nums):
    max_so_far = float("-inf")
    max_ending_here = 0
    for i in range(len(nums)):
        max_ending_here = max_ending_here + nums[i]
        if max_so_far < max_ending_here:
            max_so_far = max_ending_here
        if max_ending_here < 0:
            max_ending_here = 0
    return max_so_far

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray(nums))  # 输出 6
```

#### 9. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的数组 `nums` ，和你想要搜索的 `target` ，你在数组中搜索 `target` ，如果数组中存在这个目标值，那么返回它的索引。如果数组中不存在这个值，返回 `-1`。

**示例：**  
`nums = [4,5,6,7,0,1,2]`  
`target = 0`  
返回 `4`，因为 `nums[4] = 0`。

**答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[left] <= nums[mid]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[right] and target <= nums[left]:
                right = mid - 1
            else:
                left = mid + 1
    return -1

nums = [4,5,6,7,0,1,2]
target = 0
print(search(nums, target))  # 输出 4
```

#### 10. 合并两个有序链表

**题目描述：** 给定两个已经排序的单链表 `l1` 和 `l2`，将它们合并成一个有序单链表。

**示例：**  
`l1 = [1, 3, 5]`  
`l2 = [2, 4, 6]`  
合并后：`[1, 2, 3, 4, 5, 6]`

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    if l1:
        current.next = l1
    if l2:
        current.next = l2

    return dummy.next

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
result = merge_sorted_lists(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
# 输出：1 2 3 4 5 6
```

#### 11. 二进制中1的个数

**题目描述：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**示例：**  
输入：`n = 00000000000000000000000000001011`  
输出：`3`

**答案：**

```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

n = 0b1011
print(hammingWeight(n))  # 输出 3
```

#### 12. 旋转图像

**题目描述：** 给定一个 `n` × `n` 的二维矩阵 `matrix` 表示一个图像，请你将图像顺时针旋转 90 度。

**示例：**  
给定 `matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]`  
原地旋转输入矩阵，使其变为：
```
[
    [7,4,1],
    [8,5,2],
    [9,6,3]
]
```

**答案：**

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - 1 - j][i]
            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]
            matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]
            matrix[j][n - 1 - i] = temp

matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]
rotate(matrix)
for row in matrix:
    print(row)
# 输出：
# [7, 4, 1]
# [8, 5, 2]
# [9, 6, 3]
```

#### 13. 两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只存储单个数字。请将这两个数相加，并以相同形式返回一个表示和的链表。

**示例：**  
`l1 = [2, 4, 3]`  
`l2 = [5, 6, 4]`  
返回 `7 -> 0 -> 8`。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = add_two_numbers(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
# 输出：7 0 8
```

#### 14. 合并区间

**题目描述：** 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`。请你合并所有重叠的区间，并返回 `一个不重叠的区间集合`，该集合应按区间端点顺序排列。

**示例：**  
`intervals = [[1,3],[2,6],[8,10],[15,18]]`  
返回 `[[1,6],[8,10],[15,18]]`。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for current in intervals:
        last = merged[-1]
        if current[0] <= last[1]:
            merged[-1] = [last[0], max(last[1], current[1])]
        else:
            merged.append(current)

    return merged

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

#### 15. 两数相加（LeetCode 2）

**题目描述：** 给你两个 **非空** 链表来表示两个非负整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。请你将这两个数相加，并以相同形式返回一个表示和的链表。

**示例：**  
`l1 = [2,4,3]`  
`l2 = [5,6,4]`  
返回 `7 -> 0 -> 8`。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = add_two_numbers(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
# 输出：7 0 8
```

#### 16. 最小栈

**题目描述：** 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

**示例：**  
`minStack = MinStack()`  
`minStack.push(-2)`  
`minStack.push(0)`  
`minStack.push(-3)`  
`minStack.min()`  # 返回 -3  
`minStack.pop()`  
`minStack.top()`  # 返回 0  
`minStack.min()`  # 返回 -2

**答案：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def min(self) -> int:
        return self.min_stack[-1]
```

#### 17. 翻转链表

**题目描述：** 反转一个单链表。

**示例：**  
`head = [1,2,3,4,5]`  
返回 `[5,4,3,2,1]`。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        curr = head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev
```

#### 18. 螺旋矩阵

**题目描述：** 给定一个 `m x n` 的矩阵，按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例：**  
`matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]`  
返回 `[1,2,3,6,9,8,7,4,5]`。

**答案：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    rows, cols = len(matrix), len(matrix[0])
    seen = [[False] * cols for _ in range(rows)]
    order = []
    t, b, l, r = 0, rows - 1, 0, cols - 1
    while len(order) < rows * cols:
        for c in range(l, r + 1):
            if not seen[t][c]:
                order.append(matrix[t][c])
                seen[t][c] = True
        t += 1
        for r in range(t, b + 1):
            if not seen[r][r]:
                order.append(matrix[r][r])
                seen[r][r] = True
        r -= 1
        for c in range(r, l - 1, -1):
            if not seen[b][c]:
                order.append(matrix[b][c])
                seen[b][c] = True
        b -= 1
        for r in range(b, t - 1, -1):
            if not seen[r][l]:
                order.append(matrix[r][l])
                seen[r][l] = True
        l += 1
    return order
matrix = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]
print(spiralOrder(matrix))  # 输出 [1,2,3,6,9,8,7,4,5]
```

#### 19. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
`l1 = [1,2,4]`  
`l2 = [1,3,4]`  
返回 `[1,1,2,3,4,4]`。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

#### 20. 有效的括号

**题目描述：** 给定一个只包括 `'('` ，`')'` ，`'{'` ，`'}'` ，`'['` ，`']'` 的字符串 `s` ，判断字符串是否有效。

**示例：**  
`s = "()[]"`  
返回 `true`。

**答案：**

```python
def isValid(s):
    stack = []
    mappings = {"(": ")", "[": "]", "{": "}"}
    for char in s:
        if char in mappings:
            stack.append(char)
        elif len(stack) == 0 or mappings[stack.pop()] != char:
            return False
    return not stack

s = "()[]"
print(isValid(s))  # 输出 True
```

#### 21. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
`l1 = [1,2,4]`  
`l2 = [1,3,4]`  
返回 `[1,1,2,3,4,4]`。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

#### 22. 有效的括号

**题目描述：** 给定一个只包括 `'('` ，`')'` ，`'{'` ，`'}'` ，`'['` ，`']'` 的字符串 `s` ，判断字符串是否有效。

**示例：**  
`s = "()[]"`  
返回 `true`。

**答案：**

```python
def isValid(s):
    stack = []
    mappings = {"(": ")", "[": "]", "{": "}"}
    for char in s:
        if char in mappings:
            stack.append(char)
        elif len(stack) == 0 or mappings[stack.pop()] != char:
            return False
    return not stack

s = "()[]"
print(isValid(s))  # 输出 True
```

#### 23. 搜索旋转排序数组

**题目描述：** 给你一个数组 `nums` ，该数组有一个递增的子序列，且只包含 **独一无二** 的元素。在给定的情况下，找到关于原数组中 **任意一个** 恰好好的旋转索引 `k` ，使得数组的每一轮旋转都返回 `nums[k]` ，其中 `k == nums[k]` 。

**示例：**  
`nums = [2,3,1,4,5]`  
返回 `4` ，因为该数组以 `[3,1,4,5,2]` 为中间旋转，其中 `4 == nums[4]` 。

**答案：**

```python
def search(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == nums[right]:
            right -= 1
        elif nums[mid] < nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
nums = [2, 3, 1, 4, 5]
print(search(nums))  # 输出 4
```

#### 24. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**示例：**  
`s = "anagram"`  
`t = "nagaram"`  
返回 `true` 。

**答案：**

```python
def isAnagram(s, t):
    return sorted(s) == sorted(t)

s = "anagram"
t = "nagaram"
print(isAnagram(s, t))  # 输出 True
```

#### 25. 螺旋矩阵

**题目描述：** 给你一个 `m x n` 的矩阵 `matrix` ，请你返回矩阵的 螺旋顺序 。

**示例：**  
`matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]`  
返回 `[1,2,3,6,9,8,7,4,5]` 。

**答案：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    rows, cols = len(matrix), len(matrix[0])
    seen = [[False] * cols for _ in range(rows)]
    order = []
    t, b, l, r = 0, rows - 1, 0, cols - 1
    while len(order) < rows * cols:
        for c in range(l, r + 1):
            if not seen[t][c]:
                order.append(matrix[t][c])
                seen[t][c] = True
        t += 1
        for r in range(t, b + 1):
            if not seen[r][r]:
                order.append(matrix[r][r])
                seen[r][r] = True
        r -= 1
        for c in range(r, l - 1, -1):
            if not seen[b][c]:
                order.append(matrix[b][c])
                seen[b][c] = True
        b -= 1
        for r in range(b, t - 1, -1):
            if not seen[r][l]:
                order.append(matrix[r][l])
                seen[r][l] = True
        l += 1
    return order
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(spiralOrder(matrix))  # 输出 [1, 2, 3, 6, 9, 8, 7, 4, 5]
```

#### 26. 删除有序数组中的重复项

**题目描述：** 给你一个有序数组 `nums` ，请你去掉重复的元素，使每个元素只出现一次，返回删除后数组的新长度。

**示例：**  
`nums = [0,0,1,1,1,2,2,3,3,4]`  
返回 `5` ，`nums` 的新长度为 `5` ，并且 `nums = [0,1,2,3,4]`。

**答案：**

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[slow] != nums[fast]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
print(removeDuplicates(nums))  # 输出 5
```

#### 27. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**  
`l1 = [1,2,4]`  
`l2 = [1,3,4]`  
返回 `[1,1,2,3,4,4]`。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

#### 28. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**  
`strs = ["flower","flow","flight"]`  
返回 `"fl"`。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for j in range(1, len(strs)):
            if i >= len(strs[j]) or strs[j][i] != char:
                return prefix
        prefix += char
    return prefix
strs = ["flower","flow","flight"]
print(longestCommonPrefix(strs))  # 输出 "fl"
```

#### 29. 买卖股票的最佳时机

**题目描述：** 给定一个整数数组 `prices` ，其中 `prices[i]` 是第 `i` 天股票的价格。如果你只能在游荡期间买卖一次股票，设计一个算法来找到你能够获取的最大利润。

**示例：**  
`prices = [7,1,5,3,6,4]`  
返回 5。

**答案：**

```python
def maxProfit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        profit = prices[i] - prices[i - 1]
        if profit > 0:
            max_profit += profit
    return max_profit
prices = [7, 1, 5, 3, 6, 4]
print(maxProfit(prices))  # 输出 5
```

#### 30. 逆波兰表达式求值

**题目描述：** 根据 逆波兰表示法，求表达式的值。

有效的运算符包括 `+` ，`-` ，`*` 和 `/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**示例：**  
`tokens = ["2", "1", "+", "3", "*"]`  
返回 9。

**答案：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            num2 = stack.pop()
            num1 = stack.pop()
            if token == "+":
                stack.append(num1 + num2)
            elif token == "-":
                stack.append(num1 - num2)
            elif token == "*":
                stack.append(num1 * num2)
            else:
                stack.append(int(num1 / num2))
        else:
            stack.append(int(token))
    return stack[-1]

tokens = ["2", "1", "+", "3", "*"]
print(evalRPN(tokens))  # 输出 9
```

### 2025年京东校招算法面试题库及答案（总结）

本篇博客详细介绍了 2025年京东校招算法面试题库及答案，共涵盖了 30 个面试题及解答。这些面试题涵盖了一线互联网公司常见的算法和数据结构问题，包括数组、链表、栈、队列、字符串、排序、搜索、动态规划等多个方面。

通过对这些面试题的深入解析和代码实现，读者可以更好地理解算法的原理和应用，提高自己在面试中的应对能力。同时，这些面试题也具有一定的代表性，有助于读者应对其他互联网公司的面试。

希望本篇博客能够帮助到准备京东校招或对算法面试有兴趣的读者，祝大家面试顺利，取得理想的成绩！如有任何问题或建议，欢迎在评论区留言交流。💪💪💪

