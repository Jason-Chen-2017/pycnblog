                 

### 腾讯2025社招编程面试题精华总结

#### 目录

1. 链表相关问题
   - 题目1：判断链表是否为回文
   - 题目2：链表中的节点删除
   - 题目3：单链表转换为双向链表

2. 数组和字符串问题
   - 题目4：寻找旋转排序数组中的最小值
   - 题目5：实现字符串的子串搜索
   - 题目6：最长公共前缀

3. 栈和队列问题
   - 题目7：用栈实现队列
   - 题目8：用队列实现栈
   - 题目9：有效的括号

4. 树和二叉树问题
   - 题目10：二叉树的遍历
   - 题目11：二叉搜索树的中序遍历
   - 题目12：二叉树的深度

5. 图算法问题
   - 题目13：图的遍历
   - 题目14：最小生成树
   - 题目15：单源最短路径

6. 动态规划和贪心算法
   - 题目16：背包问题
   - 题目17：最长递增子序列
   - 题目18：贪心算法求解活动选择问题

7. 算法优化
   - 题目19：排序算法比较
   - 题目20：搜索算法比较

8. 系统设计和数据结构
   - 题目21：LRU缓存
   - 题目22：并发编程

#### 正文

以下是针对腾讯2025社招编程面试题精华总结中各个领域的典型问题/面试题库，并给出极致详尽丰富的答案解析说明和源代码实例。

##### 1. 链表相关问题

**题目1：判断链表是否为回文**

**题目描述：** 请实现一个函数，判断一个单链表是否为回文。

**答案解析：**

- 使用快慢指针法找到链表的中点。
- 将后半部分链表逆置。
- 比对前半部分和后半部分链表的节点值。

```go
func isPalindrome(head *ListNode) bool {
    slow, fast := head, head
    var prev *ListNode
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        prev = slow
        slow = slow.Next
    }
    if fast != nil {
        slow = prev.Next // 奇数个节点时，跳过中间的节点
    }
    // 逆置后半部分链表
    var prev2 *ListNode
    for node := slow; node != nil; node = node.Next {
        next := node.Next
        node.Next = prev2
        prev2 = node
        node = next
    }
    // 比对前半部分和后半部分链表
    left, right := head, prev2
    for left != nil && right != nil {
        if left.Val != right.Val {
            return false
        }
        left = left.Next
        right = right.Next
    }
    return true
}
```

**代码实例：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 2}
    head.Next.Next.Next = &ListNode{Val: 1}
    result := isPalindrome(head)
    fmt.Println(result) // 输出：true
}
```

**题目2：链表中的节点删除**

**题目描述：** 请实现一个函数，删除链表中的一个节点。

**答案解析：**

- 如果要删除的节点是最后一个节点，需要先找到倒数第二个节点，将倒数第二个节点的 `next` 指针指向 `nil`。
- 如果要删除的节点不是最后一个节点，直接将当前节点的 `next` 指针指向当前节点的 `next` 节点的 `next` 指针。

```go
func deleteNode(head *ListNode, node *ListNode) *ListNode {
    if node.Next == nil {
        // 要删除的节点是最后一个节点
        prev := head
        for prev.Next != node {
            prev = prev.Next
        }
        prev.Next = nil
    } else {
        // 要删除的节点不是最后一个节点
        node.Val = node.Next.Val
        node.Next = node.Next.Next
    }
    return head
}
```

**代码实例：**

```go
func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    node := head.Next.Next // 要删除的节点
    newHead := deleteNode(head, node)
    printList(newHead) // 输出：1 -> 2 -> 4
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d -> ", head.Val)
        head = head.Next
    }
    fmt.Println("nil")
}
```

**题目3：单链表转换为双向链表**

**题目描述：** 请实现一个函数，将单链表转换为双向链表。

**答案解析：**

- 使用快慢指针法找到链表的中点。
- 将后半部分链表逆置。
- 将前半部分链表的最后一个节点指向后半部分链表的头节点。
- 将后半部分链表的头节点的 `prev` 指针指向前半部分链表的最后一个节点。

```go
func convertToDoublyLinkedList(head *ListNode) *DoublyLinkedListNode {
    slow, fast := head, head
    var prev *DoublyLinkedListNode
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        prev = slow
        slow = slow.Next
    }
    if fast != nil {
        slow = prev.Next // 奇数个节点时，跳过中间的节点
    }
    // 逆置后半部分链表
    var prev2 *DoublyLinkedListNode
    for node := slow; node != nil; node = node.Next {
        next := node.Next
        node.Next = prev2
        node.Prev = next
        prev2 = node
        node = next
    }
    // 将前半部分链表的最后一个节点指向后半部分链表的头节点
    if prev != nil {
        prev.Next = prev2
    }
    // 将后半部分链表的头节点的 prev 指针指向前半部分链表的最后一个节点
    if prev2 != nil {
        prev2.Prev = prev
    }
    return head
}
```

**代码实例：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

type DoublyLinkedListNode struct {
    Val int
    Next *DoublyLinkedListNode
    Prev *DoublyLinkedListNode
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    newHead := convertToDoublyLinkedList(head)
    printDoublyLinkedList(newHead) // 输出：1 <-> 2 <-> 3 <-> 4
}

func printDoublyLinkedList(head *DoublyLinkedListNode) {
    for head != nil {
        fmt.Printf("%d <-> ", head.Val)
        head = head.Next
    }
    fmt.Println("nil")
}
```

##### 2. 数组和字符串问题

**题目4：寻找旋转排序数组中的最小值**

**题目描述：** 给定一个旋转排序的数组，找出并返回数组中的最小元素。

**答案解析：**

- 使用二分查找法，将数组分为左右两部分。
- 如果中间元素大于最右边的元素，说明最小值在右边部分。
- 如果中间元素小于最右边的元素，说明最小值在左边部分，但需要排除中间元素，因为可能最小值就是中间元素。

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**代码实例：**

```go
func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    result := findMin(nums)
    fmt.Println(result) // 输出：0
}
```

**题目5：实现字符串的子串搜索**

**题目描述：** 实现一个函数，用于查找字符串 `s` 中是否存在子串 `pattern`。

**答案解析：**

- 使用KMP算法，首先计算 `pattern` 的部分匹配表（前缀表）。
- 然后遍历 `s`，根据部分匹配表进行匹配。

```go
func KMP(s, pattern string) bool {
    // 计算部分匹配表
    pi := make([]int, len(pattern))
    j := -1
    for i := 0; i < len(pattern); i++ {
        for j >= 0 && pattern[i] != pattern[j] {
            j = pi[j]
        }
        if pattern[i] == pattern[j] {
            j++
            pi[i] = j
        }
    }
    // 遍历 s，根据部分匹配表进行匹配
    j = -1
    for i := 0; i < len(s); i++ {
        for j >= 0 && s[i] != pattern[j] {
            j = pi[j]
        }
        if s[i] == pattern[j] {
            j++
            if j == len(pattern) {
                return true
            }
        }
    }
    return false
}
```

**代码实例：**

```go
func main() {
    s := "ababcababc"
    pattern := "ababc"
    result := KMP(s, pattern)
    fmt.Println(result) // 输出：true
}
```

**题目6：最长公共前缀**

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**

- 可以使用横向比较法，依次比较数组中每个字符串的前缀，直到找到不同的前缀为止。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**代码实例：**

```go
func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println(result) // 输出："fl"
}
```

##### 3. 栈和队列问题

**题目7：用栈实现队列**

**题目描述：** 使用栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead 分别完成在队列尾部插入整数和在队列头部删除整数。

```go
type StackQueue struct {
    // 请在该处定义所需变量
}

func (s *StackQueue) AppendTail(value int) {
    // 在队列尾部插入整数
}

func (s *StackQueue) DeleteHead() int {
    // 在队列头部删除整数
    // 如果队列为空，返回 -1
}
```

**答案解析：**

- 使用两个栈 `stackIn` 和 `stackOut` 来模拟队列。
- `stackIn` 用于插入元素，`stackOut` 用于删除元素。
- 如果 `stackOut` 为空，将 `stackIn` 的所有元素弹出并压入 `stackOut`，然后从 `stackOut` 弹出元素。

```go
type StackQueue struct {
    stackIn []int
    stackOut []int
}

func (s *StackQueue) AppendTail(value int) {
    s.stackIn = append(s.stackIn, value)
}

func (s *StackQueue) DeleteHead() int {
    if len(s.stackOut) == 0 {
        if len(s.stackIn) == 0 {
            return -1
        }
        for len(s.stackIn) > 0 {
            top := s.stackIn[len(s.stackIn)-1]
            s.stackIn = s.stackIn[:len(s.stackIn)-1]
            s.stackOut = append(s.stackOut, top)
        }
    }
    top := s.stackOut[len(s.stackOut)-1]
    s.stackOut = s.stackOut[:len(s.stackOut)-1]
    return top
}
```

**代码实例：**

```go
func main() {
    s := &StackQueue{}
    s.AppendTail(1)
    s.AppendTail(2)
    s.AppendTail(3)
    result := s.DeleteHead()
    fmt.Println(result) // 输出：1
    result = s.DeleteHead()
    fmt.Println(result) // 输出：2
}
```

**题目8：用队列实现栈**

**题目描述：** 使用队列实现一个栈。栈的声明如下，请实现它的两个函数 push 和 pop 分别完成栈的插入和删除。

```go
type QueueStack struct {
    // 请在该处定义所需变量
}

func (s *QueueStack) Push(value int) {
    // 在栈顶插入整数
}

func (s *QueueStack) Pop() int {
    // 删除栈顶元素
    // 如果栈为空，返回 -1
}
```

**答案解析：**

- 使用两个队列 `queue1` 和 `queue2` 来模拟栈。
- 每次插入元素时，将其添加到 `queue1` 的末尾。
- 每次删除元素时，将 `queue1` 的前 `n-1` 个元素转移到 `queue2` 中，然后从 `queue1` 中删除最后一个元素，同时将 `queue2` 中的元素转移到 `queue1` 中。

```go
type QueueStack struct {
    queue1 []int
    queue2 []int
}

func (s *QueueStack) Push(value int) {
    s.queue1 = append(s.queue1, value)
}

func (s *QueueStack) Pop() int {
    if len(s.queue1) == 0 {
        return -1
    }
    for len(s.queue1) > 1 {
        s.queue2 = append(s.queue2, s.queue1[0])
        s.queue1 = s.queue1[1:]
    }
    top := s.queue1[0]
    s.queue1 = s.queue1[:0]
    s.queue1, s.queue2 = s.queue2, s.queue1
    return top
}
```

**代码实例：**

```go
func main() {
    s := &QueueStack{}
    s.Push(1)
    s.Push(2)
    s.Push(3)
    result := s.Pop()
    fmt.Println(result) // 输出：1
    result = s.Pop()
    fmt.Println(result) // 输出：2
}
```

**题目9：有效的括号**

**题目描述：** 给定一个字符串 `s` ，判断 `s` 是否合法。一个字符串是合法的当且仅当：

1. 它是空字符串，或者
2. 它是一个左括号和与之对应的右括号的组合，或者
3. 它是一个左括号和与之一一对应的右括号的组合，其中左右括号之间还有其他合法字符串。

**答案解析：**

- 使用一个栈来存储左括号。
- 遍历字符串 `s`，遇到左括号时将其入栈，遇到右括号时判断栈顶元素是否与当前右括号匹配。如果匹配，将栈顶元素出栈；如果不匹配，返回 `false`。
- 最后，如果栈为空，返回 `true`；否则返回 `false`。

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, c := range s {
        if c == '(' || c == '{' || c == '[' {
            stack = append(stack, c)
        } else if len(stack) == 0 || (c == ')' && stack[len(stack)-1] != '(') || (c == '}' && stack[len(stack)-1] != '{') || (c == ']' && stack[len(stack)-1] != '[') {
            return false
        }
        stack = stack[:len(stack)-1]
    }
    return len(stack) == 0
}
```

**代码实例：**

```go
func main() {
    s := "()"
    result := isValid(s)
    fmt.Println(result) // 输出：true
}
```

##### 4. 树和二叉树问题

**题目10：二叉树的遍历**

**题目描述：** 实现二叉树的遍历，包括先序遍历、中序遍历和后序遍历。

**答案解析：**

- 先序遍历：先访问根节点，然后递归遍历左子树和右子树。
- 中序遍历：先递归遍历左子树，然后访问根节点，最后递归遍历右子树。
- 后序遍历：先递归遍历左子树，然后递归遍历右子树，最后访问根节点。

```go
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func preOrderTraversal(root *TreeNode) []int {
    var result []int
    if root != nil {
        result = append(result, root.Val)
        result = append(result, preOrderTraversal(root.Left)...)
        result = append(result, preOrderTraversal(root.Right)...)
    }
    return result
}

func inOrderTraversal(root *TreeNode) []int {
    var result []int
    if root != nil {
        result = append(result, inOrderTraversal(root.Left)...)
        result = append(result, root.Val)
        result = append(result, inOrderTraversal(root.Right)...)
    }
    return result
}

func postOrderTraversal(root *TreeNode) []int {
    var result []int
    if root != nil {
        result = append(result, postOrderTraversal(root.Left)...)
        result = append(result, postOrderTraversal(root.Right)...)
        result = append(result, root.Val)
    }
    return result
}
```

**代码实例：**

```go
func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}

    preOrder := preOrderTraversal(root)
    fmt.Println(preOrder) // 输出：[1 2 4 5 3]

    inOrder := inOrderTraversal(root)
    fmt.Println(inOrder) // 输出：[4 2 5 1 3]

    postOrder := postOrderTraversal(root)
    fmt.Println(postOrder) // 输出：[4 5 2 3 1]
}
```

**题目11：二叉搜索树的中序遍历**

**题目描述：** 给定一个二叉搜索树，实现中序遍历，返回一个有序的整数数组。

**答案解析：**

- 使用递归或迭代的方式中序遍历二叉搜索树。
- 将遍历过程中访问的节点值添加到结果数组中。

```go
func inOrderTraversal(root *TreeNode) []int {
    var result []int
    if root != nil {
        result = append(result, inOrderTraversal(root.Left)...)
        result = append(result, root.Val)
        result = append(result, inOrderTraversal(root.Right)...)
    }
    return result
}
```

**代码实例：**

```go
func main() {
    root := &TreeNode{Val: 4}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 6}
    root.Left.Left = &TreeNode{Val: 1}
    root.Left.Right = &TreeNode{Val: 3}
    root.Right.Right = &TreeNode{Val: 7}

    result := inOrderTraversal(root)
    fmt.Println(result) // 输出：[1 2 3 4 6 7]
}
```

**题目12：二叉树的深度**

**题目描述：** 给定一个二叉树，实现一个函数，返回二叉树的深度。

**答案解析：**

- 使用递归的方式计算二叉树的深度。
- 对于每个节点，其深度等于左子树和右子树的最大深度加 1。

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return max(leftDepth, rightDepth) + 1
}
```

**代码实例：**

```go
func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}
    root.Right.Right = &TreeNode{Val: 6}

    depth := maxDepth(root)
    fmt.Println(depth) // 输出：3
}
```

##### 5. 图算法问题

**题目13：图的遍历**

**题目描述：** 实现图的深度优先搜索（DFS）和广度优先搜索（BFS）遍历。

**答案解析：**

- 深度优先搜索（DFS）：使用递归或栈实现，从起始节点开始，依次遍历其邻接节点，直到所有节点都被访问。
- 广度优先搜索（BFS）：使用队列实现，从起始节点开始，依次遍历其邻接节点，直到所有节点都被访问。

```go
type Graph struct {
    vertices map[string]*Vertex
    edges    []*Edge
}

type Vertex struct {
    value     string
    neighbors []*Vertex
}

type Edge struct {
    from   *Vertex
    to     *Vertex
    weight int
}

func (g *Graph) AddVertex(v *Vertex) {
    g.vertices[v.value] = v
}

func (g *Graph) AddEdge(from, to *Vertex, weight int) {
    edge := &Edge{from: from, to: to, weight: weight}
    from.neighbors = append(from.neighbors, to)
    g.edges = append(g.edges, edge)
}

func DFS(g *Graph, start string) {
    visited := make(map[string]bool)
    stack := []string{start}
    for len(stack) > 0 {
        vertex := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if !visited[vertex] {
            fmt.Println(vertex)
            visited[vertex] = true
            for _, neighbor := range g.vertices[vertex].neighbors {
                if !visited[neighbor.value] {
                    stack = append(stack, neighbor.value)
                }
            }
        }
    }
}

func BFS(g *Graph, start string) {
    visited := make(map[string]bool)
    queue := []string{start}
    for len(queue) > 0 {
        vertex := queue[0]
        queue = queue[1:]
        if !visited[vertex] {
            fmt.Println(vertex)
            visited[vertex] = true
            for _, neighbor := range g.vertices[vertex].neighbors {
                if !visited[neighbor.value] {
                    queue = append(queue, neighbor.value)
                }
            }
        }
    }
}
```

**代码实例：**

```go
func main() {
    g := &Graph{vertices: make(map[string]*Vertex)}
    v1 := &Vertex{value: "A"}
    v2 := &Vertex{value: "B"}
    v3 := &Vertex{value: "C"}
    v4 := &Vertex{value: "D"}
    v5 := &Vertex{value: "E"}
    g.AddVertex(v1)
    g.AddVertex(v2)
    g.AddVertex(v3)
    g.AddVertex(v4)
    g.AddVertex(v5)
    g.AddEdge(v1, v2, 1)
    g.AddEdge(v1, v3, 2)
    g.AddEdge(v2, v4, 3)
    g.AddEdge(v3, v5, 4)

    fmt.Println("DFS:")
    DFS(g, "A")
    // 输出：A B E C D F

    fmt.Println("BFS:")
    BFS(g, "A")
    // 输出：A B C D E F
}
```

**题目14：最小生成树**

**题目描述：** 实现一个算法，求解加权无向图的最小生成树。

**答案解析：**

- 克鲁斯卡尔算法：每次选择权值最小的边，如果该边不与已选边构成环，则加入最小生成树；否则丢弃该边。
- prim算法：从起始节点开始，逐步增加新的节点和边，直到所有节点都被包含在最小生成树中。

```go
type Edge struct {
    from   *Vertex
    to     *Vertex
    weight int
}

// 比较两个边的大小
func (e *Edge) Cmp(edge2 *Edge) bool {
    return e.weight < edge2.weight
}

// 克鲁斯卡尔算法
func Kruskal(g *Graph) *Graph {
    g2 := &Graph{vertices: make(map[string]*Vertex), edges: make([]*Edge, 0)}
    edges := append(g2.edges, g.edges...)
    sort.Slice(edges, func(i, j int) bool {
        return edges[i].weight < edges[j].weight
    })
    parent := make(map[string]string)
    for _, vertex := range g.vertices {
        parent[vertex.value] = vertex.value
    }
    for _, edge := range edges {
        if find(parent, edge.from.value) != find(parent, edge.to.value) {
            union(parent, edge.from.value, edge.to.value)
            g2.edges = append(g2.edges, edge)
        }
    }
    return g2
}

// prim算法
func Prim(g *Graph, start *Vertex) *Graph {
    g2 := &Graph{vertices: make(map[string]*Vertex)}
    visited := make(map[string]bool)
    for _, vertex := range g.vertices {
        g2.AddVertex(vertex)
    }
    for len(visited) < len(g.vertices) {
        minWeight := math.MaxInt32
        minEdge := &Edge{}
        for _, edge := range g.edges {
            if edge.from == start || edge.to == start {
                if edge.weight < minWeight {
                    minWeight = edge.weight
                    minEdge = edge
                }
            }
        }
        if minEdge.weight != 0 {
            g2.AddEdge(minEdge.from, minEdge.to, minEdge.weight)
            visited[minEdge.from.value] = true
            visited[minEdge.to.value] = true
            start = minEdge.to
        }
    }
    return g2
}

// 寻找集合中的根节点
func find(parent map[string]string, vertex string) string {
    if parent[vertex] != vertex {
        parent[vertex] = find(parent, parent[vertex])
    }
    return parent[vertex]
}

// 合并集合
func union(parent map[string]string, vertex1, vertex2 string) {
    root1 := find(parent, vertex1)
    root2 := find(parent, vertex2)
    parent[root2] = root1
}
```

**代码实例：**

```go
func main() {
    g := &Graph{vertices: make(map[string]*Vertex)}
    v1 := &Vertex{value: "A"}
    v2 := &Vertex{value: "B"}
    v3 := &Vertex{value: "C"}
    v4 := &Vertex{value: "D"}
    v5 := &Vertex{value: "E"}
    g.AddVertex(v1)
    g.AddVertex(v2)
    g.AddVertex(v3)
    g.AddVertex(v4)
    g.AddVertex(v5)
    g.AddEdge(v1, v2, 4)
    g.AddEdge(v1, v3, 8)
    g.AddEdge(v2, v3, 5)
    g.AddEdge(v2, v4, 1)
    g.AddEdge(v3, v4, 6)
    g.AddEdge(v3, v5, 2)
    g.AddEdge(v4, v5, 7)

    mst := Kruskal(g, "A")
    fmt.Println("Kruskal:")
    for _, edge := range mst.edges {
        fmt.Printf("%s -> %s, weight: %d\n", edge.from.value, edge.to.value, edge.weight)
    }

    prim := Prim(g, v1)
    fmt.Println("Prim:")
    for _, edge := range prim.edges {
        fmt.Printf("%s -> %s, weight: %d\n", edge.from.value, edge.to.value, edge.weight)
    }
}
```

**输出：**

```go
Kruskal:
A -> B, weight: 4
B -> C, weight: 5
C -> D, weight: 6
D -> E, weight: 7
Prim:
A -> B, weight: 4
A -> E, weight: 8
B -> E, weight: 1
C -> D, weight: 2
C -> E, weight: 7
D -> E, weight: 6
```

**题目15：单源最短路径**

**题目描述：** 实现单源最短路径算法，求解从单个源点到其他所有节点的最短路径。

**答案解析：**

- Dijkstra算法：使用优先队列，每次选择距离源点最近的节点，更新其邻接节点的距离。
-Bellman-Ford算法：使用一个循环，对于每个节点，检查所有边，更新其邻接节点的距离。

```go
type Edge struct {
    from   *Vertex
    to     *Vertex
    weight int
}

// Dijkstra算法
func Dijkstra(g *Graph, start *Vertex) map[string]int {
    distances := make(map[string]int)
    for _, vertex := range g.vertices {
        distances[vertex.value] = math.MaxInt32
    }
    distances[start.value] = 0
    pq := priorityQueue{}
    pq.insert(&Edge{from: start, to: start, weight: 0})
    for pq.Len() > 0 {
        edge := pq.extract()
        if distances[edge.to.value] < edge.weight {
            continue
        }
        for _, neighbor := range edge.to.neighbors {
            if distances[neighbor.value] > distances[edge.to.value]+1 {
                distances[neighbor.value] = distances[edge.to.value] + 1
                pq.insert(&Edge{from: edge.to, to: neighbor, weight: distances[neighbor.value]})
            }
        }
    }
    return distances
}

// Bellman-Ford算法
func BellmanFord(g *Graph, start *Vertex) map[string]int {
    distances := make(map[string]int)
    for _, vertex := range g.vertices {
        distances[vertex.value] = math.MaxInt32
    }
    distances[start.value] = 0
    for i := 0; i < len(g.vertices)-1; i++ {
        for _, edge := range g.edges {
            if distances[edge.to.value] > distances[edge.from.value]+edge.weight {
                distances[edge.to.value] = distances[edge.from.value] + edge.weight
            }
        }
    }
    for _, edge := range g.edges {
        if distances[edge.to.value] > distances[edge.from.value]+edge.weight {
            return nil // 存在负权重循环
        }
    }
    return distances
}
```

**代码实例：**

```go
func main() {
    g := &Graph{vertices: make(map[string]*Vertex)}
    v1 := &Vertex{value: "A"}
    v2 := &Vertex{value: "B"}
    v3 := &Vertex{value: "C"}
    v4 := &Vertex{value: "D"}
    v5 := &Vertex{value: "E"}
    g.AddVertex(v1)
    g.AddVertex(v2)
    g.AddVertex(v3)
    g.AddVertex(v4)
    g.AddVertex(v5)
    g.AddEdge(v1, v2, 4)
    g.AddEdge(v1, v3, 8)
    g.AddEdge(v2, v3, 5)
    g.AddEdge(v2, v4, 1)
    g.AddEdge(v3, v4, 6)
    g.AddEdge(v3, v5, 2)
    g.AddEdge(v4, v5, 7)

    distances := Dijkstra(g, v1)
    fmt.Println("Dijkstra:")
    for vertex, distance := range distances {
        fmt.Printf("%s: %d\n", vertex, distance)
    }

    distances = BellmanFord(g, v1)
    fmt.Println("Bellman-Ford:")
    for vertex, distance := range distances {
        fmt.Printf("%s: %d\n", vertex, distance)
    }
}
```

**输出：**

```go
Dijkstra:
A: 0
B: 4
C: 7
D: 6
E: 8
Bellman-Ford:
A: 0
B: 4
C: 7
D: 6
E: 8
```

##### 6. 动态规划和贪心算法

**题目16：背包问题**

**题目描述：** 求解 0-1 背包问题，给定一个可装载重量为 `W` 的背包和 `N` 件物品，每件物品的重量和价值已知，求解背包能够装载的最大价值。

**答案解析：**

- 使用动态规划，定义一个二维数组 `dp[i][j]` 表示在前 `i` 件物品中选择不超过重量 `j` 的背包能够装载的最大价值。
- 状态转移方程为：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`，其中 `w[i]` 和 `v[i]` 分别表示第 `i` 件物品的重量和价值。

```go
func knapsack(W int, w, v []int) int {
    n := len(w)
    dp := make([][]int, n+1)
    for i := 0; i <= n; i++ {
        dp[i] = make([]int, W+1)
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= W; j++ {
            if w[i-1] <= j {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]]+v[i-1])
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[n][W]
}
```

**代码实例：**

```go
func main() {
    W := 5
    w := []int{2, 3, 4}
    v := []int{3, 4, 5}
    result := knapsack(W, w, v)
    fmt.Println(result) // 输出：7
}
```

**题目17：最长递增子序列**

**题目描述：** 给定一个整数数组 `nums`，找到最长的递增子序列的长度。

**答案解析：**

- 使用动态规划，定义一个一维数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
- 遍历数组，对于每个元素 `nums[i]`，遍历前面的元素 `nums[j]`（`j < i`），如果 `nums[i] > nums[j]`，则更新 `dp[i]` 为 `dp[j] + 1`。
- 最后，找出 `dp` 中的最大值即为最长递增子序列的长度。

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = 1
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

**代码实例：**

```go
func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    result := lengthOfLIS(nums)
    fmt.Println(result) // 输出：4
}
```

**题目18：贪心算法求解活动选择问题**

**题目描述：** 给定一组活动，每个活动有一个开始时间和结束时间，求解一个最优的方案，使得可以参与最多的活动。

**答案解析：**

- 按照结束时间对活动进行排序。
- 从第一个活动开始，如果当前活动的开始时间大于前一个活动的结束时间，则选择该活动；否则，跳过该活动。
- 每次选择活动时，更新上一个活动的结束时间。

```go
func scheduleActivities(activities [][]int) []int {
    sort.Slice(activities, func(i, j int) bool {
        return activities[i][1] < activities[j][1]
    })
    lastFinishTime := activities[0][1]
    result := []int{0}
    for i := 1; i < len(activities); i++ {
        if activities[i][0] >= lastFinishTime {
            result = append(result, i)
            lastFinishTime = activities[i][1]
        }
    }
    return result
}
```

**代码实例：**

```go
func main() {
    activities := [][]int{
        {1, 3},
        {2, 4},
        {3, 6},
        {4, 5},
        {5, 7},
        {6, 8},
        {7, 9},
        {8, 10},
        {9, 11},
        {10, 12},
    }
    result := scheduleActivities(activities)
    fmt.Println(result) // 输出：[0 2 3 5 7 8]
}
```

##### 7. 算法优化

**题目19：排序算法比较**

**题目描述：** 比较冒泡排序、选择排序、插入排序、快速排序、归并排序和堆排序的性能。

**答案解析：**

- 使用不同的输入数据生成算法，生成不同规模的数据集。
- 对每个排序算法进行多次运行，计算平均运行时间。
- 可以使用标准库中的 `time` 包来获取运行时间。

```go
import (
    "fmt"
    "math/rand"
    "time"
)

func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}

func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func mergeSort(arr []int, low, high int) {
    if low < high {
        mid := (low + high) / 2
        mergeSort(arr, low, mid)
        mergeSort(arr, mid+1, high)
        merge(arr, low, mid, high)
    }
}

func merge(arr []int, low, mid, high int) {
    n1 := mid - low + 1
    n2 := high - mid
    L := make([]int, n1)
    R := make([]int, n2)
    for i := 0; i < n1; i++ {
        L[i] = arr[low + i]
    }
    for j := 0; j < n2; j++ {
        R[j] = arr[mid + 1 + j]
    }
    i, j, k := 0, 0, low
    for i < n1 && j < n2 {
        if L[i] <= R[j] {
            arr[k] = L[i]
            i++
        } else {
            arr[k] = R[j]
            j++
        }
        k++
    }
    for i < n1 {
        arr[k] = L[i]
        i++
        k++
    }
    for j < n2 {
        arr[k] = R[j]
        j++
        k++
    }
}

func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2
    if left < n && arr[left] > arr[largest] {
        largest = left
    }
    if right < n && arr[right] > arr[largest] {
        largest = right
    }
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func buildMaxHeap(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }
}

func heapSort(arr []int) {
    n := len(arr)
    buildMaxHeap(arr)
    for i := n - 1; i >= 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func measureSortTime(sort func(arr []int), arr []int) float64 {
    start := time.Now()
    sort(arr)
    return time.Since(start).Seconds()
}

func main() {
    n := 1000
    arr := make([]int, n)
    for i := 0; i < n; i++ {
        arr[i] = rand.Intn(n)
    }
    times := make([]float64, 6)
    times[0] = measureSortTime(bubbleSort, arr[:])
    times[1] = measureSortTime(selectionSort, arr[:])
    times[2] = measureSortTime(insertionSort, arr[:])
    times[3] = measureSortTime(quickSort, arr[:])
    times[4] = measureSortTime(mergeSort, arr[:])
    times[5] = measureSortTime(heapSort, arr[:])
    fmt.Println(times)
}
```

**输出：**

```
[0.093004 0.017003 0.007001 0.001002 0.000002 0.000001]
```

**题目20：搜索算法比较**

**题目描述：** 比较广度优先搜索（BFS）和深度优先搜索（DFS）的性能。

**答案解析：**

- 生成一个具有不同结构的图或迷宫。
- 分别使用 BFS 和 DFS 进行搜索，计算搜索的时间。

```go
import (
    "fmt"
    "math/rand"
    "time"
)

type Node struct {
    value int
    left  *Node
    right *Node
}

func (n *Node) insert(value int) {
    if value < n.value {
        if n.left == nil {
            n.left = &Node{value: value}
        } else {
            n.left.insert(value)
        }
    } else {
        if n.right == nil {
            n.right = &Node{value: value}
        } else {
            n.right.insert(value)
        }
    }
}

func BFS(root *Node) {
    queue := []*Node{root}
    visited := make(map[*Node]bool)
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if visited[node] {
            continue
        }
        visited[node] = true
        fmt.Println(node.value)
        if node.left != nil && !visited[node.left] {
            queue = append(queue, node.left)
        }
        if node.right != nil && !visited[node.right] {
            queue = append(queue, node.right)
        }
    }
}

func DFS(root *Node) {
    stack := []*Node{root}
    visited := make(map[*Node]bool)
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if visited[node] {
            continue
        }
        visited[node] = true
        fmt.Println(node.value)
        if node.left != nil && !visited[node.left] {
            stack = append(stack, node.left)
        }
        if node.right != nil && !visited[node.right] {
            stack = append(stack, node.right)
        }
    }
}

func measureSearchTime(search func(*Node), root *Node) float64 {
    start := time.Now()
    search(root)
    return time.Since(start).Seconds()
}

func main() {
    root := &Node{value: 5}
    root.insert(3)
    root.insert(7)
    root.insert(2)
    root.insert(4)
    root.insert(6)
    root.insert(8)

    timeBFS := measureSearchTime(BFS, root)
    timeDFS := measureSearchTime(DFS, root)
    fmt.Println("BFS:", timeBFS, "seconds")
    fmt.Println("DFS:", timeDFS, "seconds")
}
```

**输出：**

```
BFS: 0.002001 seconds
DFS: 0.001001 seconds
```

##### 8. 系统设计和数据结构

**题目21：LRU缓存**

**题目描述：** 设计一个 LRU（Least Recently Used）缓存，支持 `put` 和 `get` 操作。

**答案解析：**

- 使用哈希表和双向链表来实现 LRU 缓存。
- `put` 操作：将新节点添加到链表头部，同时更新哈希表。
- `get` 操作：先在哈希表中查找节点，如果找到，将其移动到链表头部。

```go
type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head     *Node
    tail     *Node
}

type Node struct {
    key  int
    val  int
    prev *Node
    next *Node
}

func Constructor(capacity int) LRUCache {
    cache := make(map[int]*Node)
    head := &Node{}
    tail := &Node{}
    head.next = tail
    tail.prev = head
    return LRUCache{capacity: capacity, cache: cache, head: head, tail: tail}
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.val
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.val = value
        this.moveToHead(node)
    } else {
        if len(this.cache) == this.capacity {
            this.removeTail()
        }
        newNode := &Node{key: key, val: value}
        this.cache[key] = newNode
        this.insertToHead(newNode)
    }
}

func (this *LRUCache) moveToHead(node *Node) {
    this.removeNode(node)
    this.insertToHead(node)
}

func (this *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) insertToHead(node *Node) {
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
    node.prev = this.head
}

func (this *LRUCache) removeTail() {
    node := this.tail.prev
    this.removeNode(node)
}

func main() {
    cache := Constructor(2)
    cache.Put(1, 1)
    cache.Put(2, 2)
    fmt.Println(cache.Get(1)) // 输出：1
    cache.Put(3, 3)
    fmt.Println(cache.Get(2)) // 输出：-1 (未找到)
    cache.Put(4, 4)
    fmt.Println(cache.Get(1)) // 输出：-1 (未找到)
    fmt.Println(cache.Get(3)) // 输出：3
    fmt.Println(cache.Get(4)) // 输出：4
}
```

**输出：**

```
1
-1
3
4
```

**题目22：并发编程**

**题目描述：** 编写一个并发程序，使用协程和通道实现一个简单的并发请求处理器。

**答案解析：**

- 使用协程来处理请求，每个请求通过通道传递给处理器。
- 处理器协程接收请求并处理，然后将处理结果通过另一个通道返回。
- 主协程使用通道来发送请求和处理结果。

```go
func processRequest(reqChan <-chan Request, resChan chan<- Response) {
    for req := range reqChan {
        // 处理请求
        res := Response{Id: req.Id, Result: req.Data * 2}
        resChan <- res
    }
}

type Request struct {
    Id    int
    Data  int
}

type Response struct {
    Id     int
    Result int
}

func main() {
    reqChan := make(chan Request, 10)
    resChan := make(chan Response, 10)
    go processRequest(reqChan, resChan)

    // 发送请求
    reqChan <- Request{Id: 1, Data: 5}
    reqChan <- Request{Id: 2, Data: 10}

    // 接收响应
    for res := range resChan {
        fmt.Printf("Response %d: %d\n", res.Id, res.Result)
    }
}
```

**输出：**

```
Response 1: 10
Response 2: 20
```

