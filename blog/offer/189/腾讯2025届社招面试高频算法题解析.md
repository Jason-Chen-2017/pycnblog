                 

### 腾讯2025届社招面试高频算法题解析

#### 一、排序算法

**题目1：快速排序（Quick Sort）**
快速排序是一种常用的排序算法，其基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

**解答：**
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 示例
arr = [10, 7, 8, 9, 1, 5]
print(quick_sort(arr))
```

**解析：**
快速排序通过选择一个基准元素（pivot），将数组划分为小于和大于基准元素的两部分，然后递归地对这两部分进行排序。此过程不断重复，直到所有子数组有序。

#### 二、链表

**题目2：合并两个有序链表**
将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**解答：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

# 示例
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
```

**解析：**
此算法通过迭代两个链表，比较当前节点的值，选择较小的节点添加到新链表中，并移动相应的链表指针。当其中一个链表到达末尾时，直接将另一个链表的剩余部分连接到新链表的末尾。

#### 三、栈和队列

**题目3：用栈实现队列**
用两个栈实现一个队列。队列的修改操作（addRemoveTop）和获取操作（getMin）需要能在常数时间内完成。

**解答：**
```python
from collections import deque

class MinQueue:
    def __init__(self):
        self.stack1 = deque()
        self.stack2 = deque()

    def add(self, value):
        self.stack1.append(value)

    def remove(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def get_min(self):
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]
```

**解析：**
此算法利用两个栈，`stack1` 用于添加元素，`stack2` 用于获取最小值。在删除操作中，如果 `stack2` 为空，将 `stack1` 的元素依次弹出并压入 `stack2`，这样 `stack2` 的栈顶元素即为最小值。获取最小值时，直接返回 `stack2` 的栈顶元素。

#### 四、动态规划

**题目4：最长递增子序列**
给定一个无序数组，找到最长递增子序列的长度。

**解答：**
```python
def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

# 示例
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_LIS(nums))
```

**解析：**
此算法使用动态规划，定义 `dp[i]` 为以 `nums[i]` 为结尾的最长递增子序列的长度。对于每个 `i`，遍历前面的所有 `j`（`j < i`），如果 `nums[i] > nums[j]`，则更新 `dp[i]`。

#### 五、二叉树

**题目5：二叉搜索树中的搜索**
给定一个二叉搜索树的根节点 `root` 和一个值 `val`，判断 `val` 是否存在于二叉搜索树中。

**解答：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root, val):
    while root:
        if root.val == val:
            return True
        elif root.val > val:
            root = root.left
        else:
            root = root.right
    return False

# 示例
root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(6, TreeNode(5), TreeNode(7)))
print(searchBST(root, 5))
```

**解析：**
此算法通过递归或迭代遍历二叉搜索树，根据当前节点的值与目标值的大小关系，决定是否继续遍历左子树或右子树。

#### 六、图

**题目6：最小生成树**
给定一个无向图及其边权，求出该图的最小生成树。

**解答：**
```python
from collections import defaultdict

def prim(graph):
    n = len(graph)
    min_cost = [float('inf')] * n
    min_cost[0] = 0
    in_mst = [False] * n
    mst = []

    for _ in range(n):
        min_index = -1
        for i in range(n):
            if not in_mst[i] and (min_index == -1 or min_cost[i] < min_cost[min_index]):
                min_index = i
        mst.append(min_index)
        in_mst[min_index] = True
        for i in range(n):
            if not in_mst[i] and graph[min_index][i] < min_cost[i]:
                min_cost[i] = graph[min_index][i]

    return sum(min_cost)

# 示例
graph = [[0, 2, 4, 6], [2, 0, 1, 3], [4, 1, 0, 5], [6, 3, 5, 0]]
print(prim(graph))
```

**解析：**
此算法使用 Prim 算法构建最小生成树。算法从任意节点开始，每次选择代价最小的边加入生成树，直到所有节点都被包含在生成树中。

#### 七、字符串

**题目7：最长公共前缀**
编写一个函数来查找字符串数组中的最长公共前缀。

**解答：**
```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if not s.startswith(prefix):
                return prefix
        prefix += c
    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))
```

**解析：**
此算法通过逐个字符比较字符串数组中的第一个字符串与后续每个字符串的前缀，直到找到公共前缀。

#### 八、数学

**题目8：两数之和**
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**解答：**
```python
def two_sum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))
```

**解析：**
此算法使用哈希表存储数组中的每个元素及其索引，遍历数组时，计算当前元素的补数，并检查补数是否已存在于哈希表中。

#### 九、其他

**题目9：验证回文字符串**
编写一个函数，验证一个字符串是否是回文。

**解答：**
```python
def is_palindrome(s):
    return s == s[::-1]

# 示例
s = "level"
print(is_palindrome(s))
```

**解析：**
此算法通过将字符串反转并与原字符串比较，判断是否为回文。

### 总结
以上列出了腾讯2025届社招面试中的高频算法题及其解析，涵盖了排序、链表、栈和队列、动态规划、二叉树、图、字符串和数学等领域的算法题。希望这些解析能够帮助你更好地应对面试中的算法挑战。在备考过程中，建议多做练习，熟练掌握各种算法的实现和应用。祝你面试成功！

