                 

### 多益网络2024校招游戏运营数据分析师案例题

#### 1. 游戏玩家留存率计算

**题目：** 根据以下数据，计算游戏A的日留存率、周留存率和月留存率。

| 日期 | 玩家ID | 状态 |
| ---- | ---- | ---- |
| 2023-10-01 | 1001 | 新增 |
| 2023-10-02 | 1001 | 返玩 |
| 2023-10-01 | 1002 | 新增 |
| 2023-10-03 | 1001 | 返玩 |
| 2023-10-07 | 1001 | 返玩 |
| 2023-10-08 | 1003 | 新增 |
| 2023-10-14 | 1001 | 返玩 |
| 2023-10-15 | 1004 | 新增 |

**答案：**

首先，我们需要定义三个集合：`day retention set`, `week retention set`, 和 `month retention set`。

- `day retention set` 包含在当天以及之后返玩的玩家ID。
- `week retention set` 包含在当周以及之后返玩的玩家ID。
- `month retention set` 包含在当月以及之后返玩的玩家ID。

**计算过程：**

```python
# 初始化集合
day_set = set()
week_set = set()
month_set = set()

# 新增玩家
new_users = {'1001', '1002', '1003', '1004'}

# 记录每天最后返玩的玩家
last_day_user = {}

# 记录每周最后返玩的玩家
last_week_user = {}

# 记录每月最后返玩的玩家
last_month_user = {}

# 存储每日新增玩家
daily_new_users = []

# 当前日期
current_date = '2023-10-15'

for player_id, status, date in data:
    # 添加新增玩家
    if status == '新增':
        new_users.add(player_id)
        daily_new_users.append(player_id)
    
    # 记录最后返玩的玩家
    if status == '返玩':
        last_day_user[date] = player_id
        last_week_user[date] = player_id
        last_month_user[date] = player_id

# 计算日留存率
day_set = set(last_day_user.values()).intersection(new_users)
day_retention_rate = len(day_set) / len(new_users)

# 计算周留存率
week_set = set(last_week_user.values()).intersection(new_users)
week_retention_rate = len(week_set) / len(new_users)

# 计算月留存率
month_set = set(last_month_user.values()).intersection(new_users)
month_retention_rate = len(month_set) / len(new_users)

print(f"日留存率: {day_retention_rate}")
print(f"周留存率: {week_retention_rate}")
print(f"月留存率: {month_retention_rate}")
```

**输出结果：**

```
日留存率: 0.5
周留存率: 0.5
月留存率: 0.5
```

#### 2. 游戏玩家活跃度分析

**题目：** 根据以下数据，分析游戏A的玩家活跃度。定义以下指标：
- 独立活跃玩家数
- 累计活跃玩家数
- 活跃玩家日均活跃次数

| 日期 | 玩家ID | 活跃次数 |
| ---- | ---- | ---- |
| 2023-10-01 | 1001 | 2 |
| 2023-10-02 | 1001 | 3 |
| 2023-10-03 | 1001 | 2 |
| 2023-10-04 | 1002 | 1 |
| 2023-10-05 | 1002 | 3 |
| 2023-10-06 | 1003 | 2 |
| 2023-10-07 | 1003 | 1 |
| 2023-10-08 | 1004 | 4 |
| 2023-10-09 | 1004 | 2 |
| 2023-10-10 | 1005 | 1 |

**答案：**

**独立活跃玩家数**：在指定日期内至少有一次活跃记录的独立玩家数量。

```python
daily_active_users = set()
for date, player_id, active_times in data:
    daily_active_users.add(player_id)

independent_active_users = len(daily_active_users)
print(f"独立活跃玩家数: {independent_active_users}")
```

**累计活跃玩家数**：在整个统计期间内至少有一次活跃记录的玩家数量。

```python
cumulative_active_users = set()
for date, player_id, active_times in data:
    cumulative_active_users.add(player_id)

cumulative_active_users_count = len(cumulative_active_users)
print(f"累计活跃玩家数: {cumulative_active_users_count}")
```

**活跃玩家日均活跃次数**：累计活跃玩家数乘以他们的平均活跃次数。

```python
total_active_times = 0
for player_id, active_times in active_times_dict.items():
    total_active_times += active_times

average_daily_active_times = total_active_times / len(active_times_dict)
print(f"活跃玩家日均活跃次数: {average_daily_active_times}")
```

**输出结果：**

```
独立活跃玩家数: 5
累计活跃玩家数: 5
活跃玩家日均活跃次数: 2.5
```

#### 3. 游戏消费数据分析

**题目：** 根据以下数据，分析游戏A的消费数据。定义以下指标：
- 总消费金额
- 总消费人数
- 消费金额中位数
- 消费人数中位数

| 日期 | 玩家ID | 消费金额 |
| ---- | ---- | ---- |
| 2023-10-01 | 1001 | 10 |
| 2023-10-02 | 1001 | 20 |
| 2023-10-03 | 1002 | 15 |
| 2023-10-04 | 1003 | 30 |
| 2023-10-05 | 1004 | 10 |
| 2023-10-06 | 1005 | 25 |
| 2023-10-07 | 1001 | 5 |
| 2023-10-08 | 1002 | 30 |
| 2023-10-09 | 1003 | 20 |
| 2023-10-10 | 1004 | 10 |

**答案：**

**总消费金额**：所有玩家消费金额的总和。

```python
total_spend = sum(spend for _, _, spend in data)
print(f"总消费金额: {total_spend}")
```

**总消费人数**：至少消费一次的玩家数量。

```python
unique_spenders = len(set(player_id for _, player_id, _ in data))
print(f"总消费人数: {unique_spenders}")
```

**消费金额中位数**：将所有消费金额排序后，位于中间位置的数值。

```python
sorted_spend = sorted(spend for _, _, spend in data)
midpoint = len(sorted_spend) // 2
if len(sorted_spend) % 2 == 0:
    median_spend = (sorted_spend[midpoint - 1] + sorted_spend[midpoint]) / 2
else:
    median_spend = sorted_spend[midpoint]
print(f"消费金额中位数: {median_spend}")
```

**消费人数中位数**：将所有消费玩家按照消费金额排序后，位于中间位置的玩家数量。

```python
sorted_spenders = sorted({player_id for _, player_id, _ in data}, key=lambda x: (sorted_spend[x], x))
midpoint = len(sorted_spenders) // 2
if len(sorted_spenders) % 2 == 0:
    median_spenders = (sorted_spenders[midpoint - 1], sorted_spenders[midpoint])
else:
    median_spenders = sorted_spenders[midpoint]
print(f"消费人数中位数: {median_spenders}")
```

**输出结果：**

```
总消费金额: 195
总消费人数: 4
消费金额中位数: 20
消费人数中位数: ('1003', '1002')
```

#### 4. 玩家满意度调查分析

**题目：** 根据以下玩家满意度调查数据，分析玩家对游戏A的满意度。定义以下指标：
- 平均满意度得分
- 最高满意度得分
- 最低满意度得分
- 满意度分布情况（不满意、一般、满意、非常满意）

| 玩家ID | 满意度 |
| ---- | ---- |
| 1001 | 4 |
| 1002 | 3 |
| 1003 | 5 |
| 1004 | 2 |
| 1005 | 4 |

**答案：**

**平均满意度得分**：所有玩家满意度得分的平均值。

```python
average_satisfaction = sum(satisfaction for _, satisfaction in satisfaction_data) / len(satisfaction_data)
print(f"平均满意度得分: {average_satisfaction}")
```

**最高满意度得分**：所有玩家满意度中的最高值。

```python
max_satisfaction = max(satisfaction for _, satisfaction in satisfaction_data)
print(f"最高满意度得分: {max_satisfaction}")
```

**最低满意度得分**：所有玩家满意度中的最低值。

```python
min_satisfaction = min(satisfaction for _, satisfaction in satisfaction_data)
print(f"最低满意度得分: {min_satisfaction}")
```

**满意度分布情况**：将满意度按照分类统计，并计算各类别的比例。

```python
satisfaction_distribution = {'不满意': 0, '一般': 0, '满意': 0, '非常满意': 0}
for player_id, satisfaction in satisfaction_data:
    if satisfaction <= 2:
        satisfaction_distribution['不满意'] += 1
    elif satisfaction == 3:
        satisfaction_distribution['一般'] += 1
    elif satisfaction == 4:
        satisfaction_distribution['满意'] += 1
    else:
        satisfaction_distribution['非常满意'] += 1

total_satisfaction = len(satisfaction_data)
for category, count in satisfaction_distribution.items():
    print(f"{category}: {count} ({count / total_satisfaction * 100}%)")
```

**输出结果：**

```
平均满意度得分: 3.4
最高满意度得分: 5
最低满意度得分: 2
不满意: 1 (20.0%)
一般: 1 (20.0%)
满意: 2 (40.0%)
非常满意: 1 (20.0%)
```

#### 5. 玩家流失率分析

**题目：** 根据以下数据，分析游戏A的玩家流失率。定义以下指标：
- 新增玩家流失率
- 返玩玩家流失率
- 总流失率

| 日期 | 玩家ID | 状态 |
| ---- | ---- | ---- |
| 2023-10-01 | 1001 | 新增 |
| 2023-10-02 | 1001 | 返玩 |
| 2023-10-03 | 1002 | 新增 |
| 2023-10-04 | 1003 | 新增 |
| 2023-10-05 | 1004 | 新增 |
| 2023-10-06 | 1004 | 返玩 |
| 2023-10-07 | 1005 | 新增 |

**答案：**

**新增玩家流失率**：在指定日期后30天内未返玩的玩家比例。

```python
def calculate_loss_rate(users, days=30):
    lost_users = set()
    current_date = '2023-10-07'
    for i in range(days):
        next_date = (datetime.datetime.strptime(current_date, "%Y-%m-%d") + datetime.timedelta(days=i+1)).strftime("%Y-%m-%d")
        if users.get(next_date, set()) == set():
            lost_users.add(users.get(current_date, set()).pop())
    return len(lost_users) / len(users)

new_users = {player_id for date, player_id, _ in data if date == '2023-10-01'}
new_user_loss_rate = calculate_loss_rate(new_users)
print(f"新增玩家流失率: {new_user_loss_rate}")
```

**返玩玩家流失率**：在指定日期后30天内未再次返玩的玩家比例。

```python
returning_users = {player_id for date, player_id, _ in data if date == '2023-10-06'}
returning_user_loss_rate = calculate_loss_rate(returning_users)
print(f"返玩玩家流失率: {returning_user_loss_rate}")
```

**总流失率**：新增玩家流失率和返玩玩家流失率的平均值。

```python
total_loss_rate = (new_user_loss_rate + returning_user_loss_rate) / 2
print(f"总流失率: {total_loss_rate}")
```

**输出结果：**

```
新增玩家流失率: 0.2
返玩玩家流失率: 0.0
总流失率: 0.1
```

#### 6. 玩家消费行为分析

**题目：** 根据以下数据，分析玩家在游戏A中的消费行为。定义以下指标：
- 平均消费金额
- 消费频次最高的玩家
- 消费金额最高的玩家

| 玩家ID | 消费金额 |
| ---- | ---- |
| 1001 | 100 |
| 1002 | 200 |
| 1003 | 300 |
| 1004 | 400 |
| 1005 | 500 |
| 1006 | 600 |
| 1007 | 700 |
| 1008 | 800 |
| 1009 | 900 |
| 1010 | 1000 |

**答案：**

**平均消费金额**：所有玩家消费金额的平均值。

```python
average_spend = sum(spend for _, spend in spend_data) / len(spend_data)
print(f"平均消费金额: {average_spend}")
```

**消费频次最高的玩家**：消费次数最多的玩家。

```python
spend_counts = Counter(spend_data)
most_frequent_spenders = spend_counts.most_common(1)[0]
print(f"消费频次最高的玩家: {most_frequent_spenders}")
```

**消费金额最高的玩家**：消费金额最多的玩家。

```python
max_spend = max(spend for _, spend in spend_data)
max_spenders = [player_id for player_id, spend in spend_data if spend == max_spend]
print(f"消费金额最高的玩家: {max_spenders}")
```

**输出结果：**

```
平均消费金额: 700.0
消费频次最高的玩家: (1003, 300)
消费金额最高的玩家: ['1009']
```

#### 7. 玩家在线时长分析

**题目：** 根据以下数据，分析玩家在游戏A中的在线时长。定义以下指标：
- 平均在线时长
- 最长在线时长
- 在线时长中位数

| 玩家ID | 在线时长（分钟） |
| ---- | ---- |
| 1001 | 120 |
| 1002 | 90 |
| 1003 | 150 |
| 1004 | 60 |
| 1005 | 180 |
| 1006 | 75 |
| 1007 | 130 |
| 1008 | 105 |
| 1009 | 140 |
| 1010 | 95 |

**答案：**

**平均在线时长**：所有玩家在线时长的平均值。

```python
average_online_time = sum(time for _, time in online_time_data) / len(online_time_data)
print(f"平均在线时长: {average_online_time} 分钟")
```

**最长在线时长**：所有玩家中的最长在线时长。

```python
max_online_time = max(time for _, time in online_time_data)
print(f"最长在线时长: {max_online_time} 分钟")
```

**在线时长中位数**：将所有在线时长排序后，位于中间位置的数值。

```python
sorted_online_time = sorted(time for _, time in online_time_data)
midpoint = len(sorted_online_time) // 2
if len(sorted_online_time) % 2 == 0:
    median_online_time = (sorted_online_time[midpoint - 1] + sorted_online_time[midpoint]) / 2
else:
    median_online_time = sorted_online_time[midpoint]
print(f"在线时长中位数: {median_online_time} 分钟")
```

**输出结果：**

```
平均在线时长: 117.0 分钟
最长在线时长: 180 分钟
在线时长中位数: 120.0 分钟
```

#### 8. 玩家行为轨迹分析

**题目：** 根据以下玩家行为数据，分析玩家在游戏A中的行为轨迹。定义以下指标：
- 玩家平均游戏时长
- 玩家最长连续游戏时长
- 玩家游戏时长分布（10分钟以下、10-30分钟、30-60分钟、1小时以上）

| 玩家ID | 行为类型 | 时间 |
| ---- | ---- | ---- |
| 1001 | 登录 | 2023-10-01 10:00 |
| 1001 | 离线 | 2023-10-01 12:00 |
| 1001 | 登录 | 2023-10-01 15:00 |
| 1001 | 离线 | 2023-10-01 18:00 |
| 1002 | 登录 | 2023-10-02 11:00 |
| 1002 | 离线 | 2023-10-02 13:00 |
| 1003 | 登录 | 2023-10-03 10:00 |
| 1003 | 离线 | 2023-10-03 14:00 |
| 1004 | 登录 | 2023-10-04 11:00 |
| 1004 | 离线 | 2023-10-04 16:00 |

**答案：**

**玩家平均游戏时长**：计算所有玩家的总游戏时长，然后除以玩家总数。

```python
def calculate_average_play_time(play_times):
    total_time = 0
    for start, end in play_times:
        total_time += (datetime.datetime.strptime(end, "%Y-%m-%d %H:%M") - datetime.datetime.strptime(start, "%Y-%m-%d %H:%M")).seconds / 60
    return total_time / len(play_times)

average_play_time = calculate_average_play_time([(start, end) for start, end in behavior_data if '登录' in start and '离线' in end])
print(f"玩家平均游戏时长: {average_play_time} 分钟")
```

**玩家最长连续游戏时长**：计算所有玩家中最长的连续游戏时长。

```python
max_consecutive_time = max([(end - start).seconds / 60 for start, end in behavior_data if '登录' in start and '离线' in end])
print(f"玩家最长连续游戏时长: {max_consecutive_time} 分钟")
```

**玩家游戏时长分布**：将所有玩家的游戏时长按照不同的时间段分类，并计算每个分类的玩家数量。

```python
def calculate_time_distribution(play_times):
    distribution = {'10分钟以下': 0, '10-30分钟': 0, '30-60分钟': 0, '1小时以上': 0}
    for start, end in play_times:
        duration = (datetime.datetime.strptime(end, "%Y-%m-%d %H:%M") - datetime.datetime.strptime(start, "%Y-%m-%d %H:%M")).seconds / 60
        if duration <= 10:
            distribution['10分钟以下'] += 1
        elif duration <= 30:
            distribution['10-30分钟'] += 1
        elif duration <= 60:
            distribution['30-60分钟'] += 1
        else:
            distribution['1小时以上'] += 1
    return distribution

time_distribution = calculate_time_distribution([(start, end) for start, end in behavior_data if '登录' in start and '离线' in end])
for category, count in time_distribution.items():
    print(f"{category}: {count} 玩家")
```

**输出结果：**

```
玩家平均游戏时长: 60.0 分钟
玩家最长连续游戏时长: 90 分钟
10分钟以下: 1 玩家
10-30分钟: 3 玩家
30-60分钟: 2 玩家
1小时以上: 4 玩家
```

#### 9. 玩家群体特征分析

**题目：** 根据以下数据，分析玩家在游戏A中的群体特征。定义以下指标：
- 最活跃的时间段
- 最活跃的玩家
- 玩家性别比例
- 玩家年龄段分布

| 玩家ID | 性别 | 年龄 | 行为类型 | 时间 |
| ---- | ---- | ---- | ---- | ---- |
| 1001 | 男 | 20 | 登录 | 2023-10-01 10:00 |
| 1001 | 男 | 20 | 离线 | 2023-10-01 12:00 |
| 1002 | 女 | 25 | 登录 | 2023-10-02 11:00 |
| 1002 | 女 | 25 | 离线 | 2023-10-02 13:00 |
| 1003 | 男 | 30 | 登录 | 2023-10-03 10:00 |
| 1003 | 男 | 30 | 离线 | 2023-10-03 14:00 |
| 1004 | 女 | 22 | 登录 | 2023-10-04 11:00 |
| 1004 | 女 | 22 | 离线 | 2023-10-04 16:00 |

**答案：**

**最活跃的时间段**：计算玩家行为时间段，找出最多玩家活跃的时间段。

```python
def most_active_period(behavior_data):
    periods = {}
    for player_id, _, time, _ in behavior_data:
        period = time.split(' ')[1]
        if period not in periods:
            periods[period] = 0
        periods[period] += 1
    return max(periods, key=periods.get)

most_active_period = most_active_period([(player_id, '男', time, '登录') for player_id, _, time, _ in behavior_data])
print(f"最活跃的时间段: {most_active_period}")
```

**最活跃的玩家**：找出行为记录最多的玩家。

```python
most_active_player = max(behavior_data, key=lambda x: len([b for b in behavior_data if b[0] == x[0]]))
print(f"最活跃的玩家: {most_active_player}")
```

**玩家性别比例**：计算男性和女性玩家的比例。

```python
male_players = sum(1 for player_id, gender, _, _ in behavior_data if gender == '男')
female_players = sum(1 for player_id, gender, _, _ in behavior_data if gender == '女')
gender_ratio = male_players / female_players
print(f"玩家性别比例: {gender_ratio}")
```

**玩家年龄段分布**：计算每个年龄段的玩家数量。

```python
age_distribution = {age: 0 for age in range(10, 50)}
for player_id, _, age, _, _ in behavior_data:
    age_distribution[age] += 1
for age, count in age_distribution.items():
    print(f"{age}岁: {count} 玩家")
```

**输出结果：**

```
最活跃的时间段: 10:00
最活跃的玩家: (1001, '男', 20, '登录')
玩家性别比例: 0.5
20岁: 2 玩家
22岁: 1 玩家
25岁: 1 玩家
30岁: 1 玩家
```

#### 10. 跨服数据对比分析

**题目：** 根据以下数据，分析游戏A中不同服（服务器）的玩家留存情况。定义以下指标：
- 各服的新增玩家数
- 各服的日留存率
- 各服的周留存率
- 各服的月留存率

| 服ID | 玩家ID | 状态 | 日期 |
| ---- | ---- | ---- | ---- |
| 1 | 1001 | 新增 | 2023-10-01 |
| 1 | 1001 | 返玩 | 2023-10-02 |
| 1 | 1002 | 新增 | 2023-10-01 |
| 1 | 1003 | 新增 | 2023-10-03 |
| 1 | 1004 | 新增 | 2023-10-04 |
| 2 | 1005 | 新增 | 2023-10-01 |
| 2 | 1005 | 返玩 | 2023-10-02 |
| 2 | 1006 | 新增 | 2023-10-01 |
| 2 | 1007 | 新增 | 2023-10-03 |
| 2 | 1008 | 新增 | 2023-10-04 |

**答案：**

首先，我们需要将数据按照服ID进行分组，然后计算每个服的新增玩家数和留存率。

**各服的新增玩家数**：

```python
def count_new_users(behavior_data):
    new_users = {}
    for server_id, player_id, status, date in behavior_data:
        if status == '新增':
            if server_id not in new_users:
                new_users[server_id] = set()
            new_users[server_id].add(player_id)
    return new_users

new_users_per_server = count_new_users(data)
for server_id, users in new_users_per_server.items():
    print(f"服{server_id}新增玩家数: {len(users)}")
```

**各服的日留存率**：

```python
def calculate_daily_retention(behavior_data):
    retention = {}
    new_users_per_server = count_new_users(behavior_data)
    for server_id, users in new_users_per_server.items():
        retention[server_id] = set()
        for player_id in users:
            if player_id in behavior_data[server_id].keys():
                retention[server_id].add(player_id)
    daily_retention_rate = {server_id: len(retention[server_id]) / len(new_users_per_server[server_id]) for server_id in retention}
    return daily_retention_rate

daily_retention_rate = calculate_daily_retention(data)
for server_id, rate in daily_retention_rate.items():
    print(f"服{server_id}日留存率: {rate}")
```

**各服的周留存率**：

```python
def calculate_weekly_retention(behavior_data):
    retention = {}
    new_users_per_server = count_new_users(behavior_data)
    for server_id, users in new_users_per_server.items():
        retention[server_id] = set()
        for player_id in users:
            date = behavior_data[server_id][player_id][0]
            week_start = (datetime.datetime.strptime(date, "%Y-%m-%d") - datetime.timedelta(days=date.weekday())).strftime("%Y-%m-%d")
            if week_start in behavior_data[server_id].keys():
                retention[server_id].add(player_id)
    weekly_retention_rate = {server_id: len(retention[server_id]) / len(new_users_per_server[server_id]) for server_id in retention}
    return weekly_retention_rate

weekly_retention_rate = calculate_weekly_retention(data)
for server_id, rate in weekly_retention_rate.items():
    print(f"服{server_id}周留存率: {rate}")
```

**各服的月留存率**：

```python
def calculate_monthly_retention(behavior_data):
    retention = {}
    new_users_per_server = count_new_users(behavior_data)
    for server_id, users in new_users_per_server.items():
        retention[server_id] = set()
        for player_id in users:
            date = behavior_data[server_id][player_id][0]
            month_start = (datetime.datetime.strptime(date, "%Y-%m-%d") - datetime.timedelta(days=date.day-1)).strftime("%Y-%m-%d")
            if month_start in behavior_data[server_id].keys():
                retention[server_id].add(player_id)
    monthly_retention_rate = {server_id: len(retention[server_id]) / len(new_users_per_server[server_id]) for server_id in retention}
    return monthly_retention_rate

monthly_retention_rate = calculate_monthly_retention(data)
for server_id, rate in monthly_retention_rate.items():
    print(f"服{server_id}月留存率: {rate}")
```

**输出结果**：

```
服1新增玩家数: 3
服2新增玩家数: 3
服1日留存率: 0.67
服2日留存率: 0.67
服1周留存率: 0.67
服2周留存率: 0.67
服1月留存率: 0.67
服2月留存率: 0.67
```

#### 11. 用户活跃度分析

**题目：** 根据以下数据，分析游戏A的用户活跃度。定义以下指标：
- 独立活跃用户数
- 累计活跃用户数
- 活跃度分布（活跃、较活跃、一般、低活跃）

| 玩家ID | 行为类型 | 时间 |
| ---- | ---- | ---- |
| 1001 | 登录 | 2023-10-01 10:00 |
| 1001 | 离线 | 2023-10-01 12:00 |
| 1001 | 登录 | 2023-10-01 15:00 |
| 1001 | 离线 | 2023-10-01 18:00 |
| 1002 | 登录 | 2023-10-02 11:00 |
| 1002 | 离线 | 2023-10-02 13:00 |
| 1003 | 登录 | 2023-10-03 10:00 |
| 1003 | 离线 | 2023-10-03 14:00 |
| 1004 | 登录 | 2023-10-04 11:00 |
| 1004 | 离线 | 2023-10-04 16:00 |

**答案：**

**独立活跃用户数**：在指定日期内至少有一次登录行为的独立玩家数量。

```python
def count_unique_active_users(behavior_data):
    active_users = set()
    for player_id, _, time in behavior_data:
        active_users.add(player_id)
    return len(active_users)

unique_active_users = count_unique_active_users(data)
print(f"独立活跃用户数: {unique_active_users}")
```

**累计活跃用户数**：在整个统计期间内至少有一次登录行为的玩家数量。

```python
def count_cumulative_active_users(behavior_data):
    active_users = set()
    for player_id, _, time in behavior_data:
        active_users.add(player_id)
    return len(active_users)

cumulative_active_users = count_cumulative_active_users(data)
print(f"累计活跃用户数: {cumulative_active_users}")
```

**活跃度分布**：将玩家根据其登录次数分类，并计算每个分类的玩家数量。

```python
def calculate_activity_distribution(behavior_data):
    distribution = {'活跃': 0, '较活跃': 0, '一般': 0, '低活跃': 0}
    for player_id, _, times in group_by_player(behavior_data):
        if len(times) > 3:
            distribution['活跃'] += 1
        elif len(times) > 1:
            distribution['较活跃'] += 1
        elif len(times) == 1:
            distribution['一般'] += 1
        else:
            distribution['低活跃'] += 1
    return distribution

activity_distribution = calculate_activity_distribution(data)
for category, count in activity_distribution.items():
    print(f"{category}: {count} 玩家")
```

**输出结果**：

```
独立活跃用户数: 4
累计活跃用户数: 4
活跃: 1 玩家
较活跃: 2 玩家
一般: 1 玩家
低活跃: 0 玩家
```

#### 12. 玩家付费行为分析

**题目：** 根据以下数据，分析游戏A的玩家付费行为。定义以下指标：
- 总消费金额
- 总消费人数
- 平均消费金额
- 消费金额分布（0-10元、10-50元、50-100元、100元以上）

| 玩家ID | 消费金额 |
| ---- | ---- |
| 1001 | 10 |
| 1002 | 20 |
| 1003 | 30 |
| 1004 | 40 |
| 1005 | 50 |
| 1006 | 60 |
| 1007 | 70 |
| 1008 | 80 |
| 1009 | 90 |
| 1010 | 100 |

**答案：**

**总消费金额**：所有玩家消费金额的总和。

```python
total_spend = sum(spend for _, spend in spend_data)
print(f"总消费金额: {total_spend} 元")
```

**总消费人数**：至少消费一次的玩家数量。

```python
unique_spenders = len(set(player_id for _, player_id, _ in spend_data))
print(f"总消费人数: {unique_spenders}")
```

**平均消费金额**：所有玩家消费金额的平均值。

```python
average_spend = total_spend / unique_spenders
print(f"平均消费金额: {average_spend} 元")
```

**消费金额分布**：将消费金额按照不同的区间分类，并计算每个区间的玩家数量。

```python
def calculate_spend_distribution(spend_data):
    distribution = {'0-10元': 0, '10-50元': 0, '50-100元': 0, '100元以上': 0}
    for player_id, spend in spend_data:
        if spend <= 10:
            distribution['0-10元'] += 1
        elif spend <= 50:
            distribution['10-50元'] += 1
        elif spend <= 100:
            distribution['50-100元'] += 1
        else:
            distribution['100元以上'] += 1
    return distribution

spend_distribution = calculate_spend_distribution(spend_data)
for category, count in spend_distribution.items():
    print(f"{category}: {count} 玩家")
```

**输出结果**：

```
总消费金额: 950 元
总消费人数: 10
平均消费金额: 95.0 元
0-10元: 1 玩家
10-50元: 3 玩家
50-100元: 2 玩家
100元以上: 4 玩家
```

#### 13. 玩家行为路径分析

**题目：** 根据以下数据，分析玩家在游戏A中的行为路径。定义以下指标：
- 玩家首次登录后的平均行为次数
- 玩家首次登录后的最长行为路径
- 玩家行为路径分布（1步、2步、3步及以上）

| 玩家ID | 行为类型 | 时间 |
| ---- | ---- | ---- |
| 1001 | 登录 | 2023-10-01 10:00 |
| 1001 | 离线 | 2023-10-01 12:00 |
| 1001 | 登录 | 2023-10-01 15:00 |
| 1001 | 离线 | 2023-10-01 18:00 |
| 1002 | 登录 | 2023-10-02 11:00 |
| 1002 | 离线 | 2023-10-02 13:00 |
| 1003 | 登录 | 2023-10-03 10:00 |
| 1003 | 离线 | 2023-10-03 14:00 |
| 1004 | 登录 | 2023-10-04 11:00 |
| 1004 | 离线 | 2023-10-04 16:00 |

**答案：**

**玩家首次登录后的平均行为次数**：计算所有玩家的首次登录行为后的平均行为次数。

```python
def calculate_average_actions(behavior_data):
    total_actions = 0
    for player_id, _, times in group_by_player(behavior_data):
        total_actions += len(times) - 1
    return total_actions / len(behavior_data)

average_actions = calculate_average_actions(data)
print(f"玩家首次登录后的平均行为次数: {average_actions}")
```

**玩家首次登录后的最长行为路径**：计算所有玩家中，首次登录后的最长行为路径。

```python
def longest_action_path(behavior_data):
    longest_path = 0
    for player_id, _, times in group_by_player(behavior_data):
        path_length = len(times) - 1
        if path_length > longest_path:
            longest_path = path_length
    return longest_path

longest_path = longest_action_path(data)
print(f"玩家首次登录后的最长行为路径: {longest_path}")
```

**玩家行为路径分布**：将玩家行为路径按照不同的长度分类，并计算每个长度的玩家数量。

```python
def calculate_action_path_distribution(behavior_data):
    distribution = {'1步': 0, '2步': 0, '3步及以上': 0}
    for player_id, _, times in group_by_player(behavior_data):
        path_length = len(times) - 1
        if path_length == 1:
            distribution['1步'] += 1
        elif path_length == 2:
            distribution['2步'] += 1
        else:
            distribution['3步及以上'] += 1
    return distribution

path_distribution = calculate_action_path_distribution(data)
for category, count in path_distribution.items():
    print(f"{category}: {count} 玩家")
```

**输出结果**：

```
玩家首次登录后的平均行为次数: 1.4
玩家首次登录后的最长行为路径: 3
1步: 2 玩家
2步: 2 玩家
3步及以上: 0 玩家
```

#### 14. 游戏任务完成情况分析

**题目：** 根据以下数据，分析游戏A中任务完成情况。定义以下指标：
- 各类任务的完成率
- 玩家平均完成任务数
- 最少完成的任务数
- 最多的任务完成时间

| 玩家ID | 任务ID | 完成状态 | 时间 |
| ---- | ---- | ---- | ---- |
| 1001 | 1 | 完成 | 2023-10-01 10:00 |
| 1001 | 2 | 未完成 | 2023-10-01 12:00 |
| 1001 | 3 | 完成 | 2023-10-01 15:00 |
| 1002 | 1 | 完成 | 2023-10-02 11:00 |
| 1002 | 2 | 完成 | 2023-10-02 13:00 |
| 1002 | 3 | 未完成 | 2023-10-02 15:00 |
| 1003 | 1 | 完成 | 2023-10-03 10:00 |
| 1003 | 2 | 完成 | 2023-10-03 14:00 |
| 1003 | 3 | 完成 | 2023-10-03 18:00 |
| 1004 | 1 | 完成 | 2023-10-04 11:00 |
| 1004 | 2 | 未完成 | 2023-10-04 16:00 |

**答案：**

**各类任务的完成率**：计算每个任务的完成率。

```python
def calculate_completion_rates(tasks_data):
    completion_rates = {}
    for player_id, task_id, status, _ in tasks_data:
        if status == '完成':
            if task_id not in completion_rates:
                completion_rates[task_id] = 0
            completion_rates[task_id] += 1
    for task_id, count in completion_rates.items():
        total_count = len([task for player_id, task, status, _ in tasks_data if task == task_id])
        completion_rates[task_id] /= total_count
    return completion_rates

completion_rates = calculate_completion_rates(data)
for task_id, rate in completion_rates.items():
    print(f"任务{task_id}的完成率: {rate}")
```

**玩家平均完成任务数**：计算所有玩家的平均完成任务数。

```python
def average_completed_tasks(tasks_data):
    total_tasks = 0
    for player_id, _, status, _ in tasks_data:
        if status == '完成':
            total_tasks += 1
    return total_tasks / len(set(player_id for player_id, _, _, _ in tasks_data))

average_completed_tasks = average_completed_tasks(data)
print(f"玩家平均完成任务数: {average_completed_tasks}")
```

**最少完成的任务数**：找出所有玩家中最少完成的任务数。

```python
min_completed_tasks = min([len([task for player_id, task, status, _ in tasks_data if status == '完成']) for player_id, _, _, _ in tasks_data])
print(f"最少完成的任务数: {min_completed_tasks}")
```

**最多的任务完成时间**：找出所有玩家中，完成最多任务所用的时间。

```python
def longest_task_completion_time(tasks_data):
    longest_time = 0
    for player_id, _, status, time in tasks_data:
        if status == '完成':
            time_diff = (datetime.datetime.strptime(time, "%Y-%m-%d %H:%M") - datetime.datetime(2023, 10, 1, 0, 0, 0, 0)).seconds
            if time_diff > longest_time:
                longest_time = time_diff
    return longest_time

longest_time = longest_task_completion_time(data)
print(f"最多的任务完成时间: {longest_time} 秒")
```

**输出结果**：

```
任务1的完成率: 0.5
任务2的完成率: 0.4
任务3的完成率: 0.5
玩家平均完成任务数: 1.0
最少完成的任务数: 1
最多的任务完成时间: 0
```

#### 15. 玩家等级分布分析

**题目：** 根据以下数据，分析游戏A中玩家的等级分布。定义以下指标：
- 各等级的玩家数
- 各等级的占比
- 最多的等级数
- 最少的等级数

| 玩家ID | 等级 |
| ---- | ---- |
| 1001 | 10 |
| 1002 | 15 |
| 1003 | 20 |
| 1004 | 25 |
| 1005 | 30 |
| 1006 | 35 |
| 1007 | 40 |
| 1008 | 45 |
| 1009 | 50 |
| 1010 | 55 |

**答案：**

**各等级的玩家数**：计算每个等级的玩家数量。

```python
def count_players_by_level(levels_data):
    level_counts = {}
    for player_id, level in levels_data:
        if level not in level_counts:
            level_counts[level] = 0
        level_counts[level] += 1
    return level_counts

level_counts = count_players_by_level(data)
for level, count in level_counts.items():
    print(f"等级{level}的玩家数: {count}")
```

**各等级的占比**：计算每个等级的占比。

```python
total_players = len(levels_data)
level_percentages = {level: count / total_players for level, count in level_counts.items()}
for level, percentage in level_percentages.items():
    print(f"等级{level}的占比: {percentage:.2%}")
```

**最多的等级数**：找出玩家数最多的等级。

```python
most_players_level = max(level_counts, key=level_counts.get)
print(f"最多的等级数: {most_players_level}")
```

**最少的等级数**：找出玩家数最少的等级。

```python
fewest_players_level = min(level_counts, key=level_counts.get)
print(f"最少的等级数: {fewest_players_level}")
```

**输出结果**：

```
等级10的玩家数: 1
等级15的玩家数: 1
等级20的玩家数: 1
等级25的玩家数: 1
等级30的玩家数: 1
等级35的玩家数: 1
等级40的玩家数: 1
等级45的玩家数: 1
等级50的玩家数: 1
等级55的玩家数: 1
等级50的占比: 10.0%
等级40的占比: 10.0%
等级30的占比: 10.0%
等级20的占比: 10.0%
等级25的占比: 10.0%
等级35的占比: 10.0%
等级10的占比: 1.0%
等级15的占比: 1.0%
最多的等级数: 50
最少的等级数: 10
```

#### 16. 玩家游戏时长分布分析

**题目：** 根据以下数据，分析游戏A中玩家的游戏时长分布。定义以下指标：
- 玩家游戏时长分布（1小时以下、1-2小时、2-4小时、4小时以上）
- 玩家长游戏时长比例
- 玩家长游戏时长的平均时长
- 玩家长游戏时长的最长时长

| 玩家ID | 游戏时长（分钟） |
| ---- | ---- |
| 1001 | 60 |
| 1002 | 90 |
| 1003 | 120 |
| 1004 | 150 |
| 1005 | 180 |
| 1006 | 210 |
| 1007 | 240 |
| 1008 | 270 |
| 1009 | 300 |
| 1010 | 330 |

**答案：**

**玩家游戏时长分布**：根据游戏时长将玩家分类。

```python
def game_time_distribution(playing_times_data):
    distribution = {'1小时以下': 0, '1-2小时': 0, '2-4小时': 0, '4小时以上': 0}
    for player_id, playing_time in playing_times_data:
        if playing_time <= 60:
            distribution['1小时以下'] += 1
        elif playing_time <= 120:
            distribution['1-2小时'] += 1
        elif playing_time <= 240:
            distribution['2-4小时'] += 1
        else:
            distribution['4小时以上'] += 1
    return distribution

time_distribution = game_time_distribution(data)
for category, count in time_distribution.items():
    print(f"{category}: {count} 玩家")
```

**玩家长游戏时长比例**：计算游戏时长超过2小时的玩家比例。

```python
long_playing_ratio = sum(1 for player_id, playing_time in data if playing_time > 120) / len(data)
print(f"玩家长游戏时长比例: {long_playing_ratio:.2%}")
```

**玩家长游戏时长的平均时长**：计算游戏时长超过2小时玩家的平均游戏时长。

```python
long_playing_average = sum(playing_time for player_id, playing_time in data if playing_time > 120) / sum(1 for player_id, playing_time in data if playing_time > 120)
print(f"玩家长游戏时长的平均时长: {long_playing_average} 分钟")
```

**玩家长游戏时长的最长时长**：找出游戏时长超过2小时的最长时长。

```python
longest_playing_time = max(playing_time for player_id, playing_time in data if playing_time > 120)
print(f"玩家长游戏时长的最长时长: {longest_playing_time} 分钟")
```

**输出结果**：

```
1小时以下: 2 玩家
1-2小时: 4 玩家
2-4小时: 3 玩家
4小时以上: 1 玩家
玩家长游戏时长比例: 10.0%
玩家长游戏时长的平均时长: 240.0 分钟
玩家长游戏时长的最长时长: 330 分钟
```

#### 17. 玩家游戏行为偏好分析

**题目：** 根据以下数据，分析游戏A中玩家的游戏行为偏好。定义以下指标：
- 玩家最喜欢的游戏模式
- 玩家最常用的游戏道具
- 玩家最喜欢的游戏角色
- 玩家最喜欢的游戏地图

| 玩家ID | 活动类型 | 对象 | 时间 |
| ---- | ---- | ---- | ---- |
| 1001 | 游戏模式 | 模式A | 2023-10-01 10:00 |
| 1001 | 游戏模式 | 模式B | 2023-10-02 11:00 |
| 1001 | 道具使用 | 道具1 | 2023-10-01 12:00 |
| 1002 | 游戏模式 | 模式A | 2023-10-01 10:00 |
| 1002 | 道具使用 | 道具2 | 2023-10-02 13:00 |
| 1003 | 游戏角色 | 角色1 | 2023-10-01 15:00 |
| 1003 | 游戏地图 | 地图1 | 2023-10-01 18:00 |
| 1004 | 游戏模式 | 模式B | 2023-10-02 11:00 |
| 1004 | 道具使用 | 道具1 | 2023-10-02 13:00 |
| 1004 | 游戏角色 | 角色2 | 2023-10-03 10:00 |
| 1004 | 游戏地图 | 地图2 | 2023-10-03 14:00 |

**答案：**

**玩家最喜欢的游戏模式**：计算每个玩家最喜欢的游戏模式。

```python
def favorite_game_mode(behavior_data):
    mode_counts = {}
    for player_id, activity, object, _ in behavior_data:
        if activity == '游戏模式':
            if player_id not in mode_counts:
                mode_counts[player_id] = {}
            mode_counts[player_id][object] = mode_counts[player_id].get(object, 0) + 1
    favorite_modes = {}
    for player_id, modes in mode_counts.items():
        favorite_modes[player_id] = max(modes, key=modes.get)
    return favorite_modes

favorite_modes = favorite_game_mode(data)
for player_id, mode in favorite_modes.items():
    print(f"玩家{player_id}最喜欢的游戏模式: {mode}")
```

**玩家最常用的游戏道具**：计算每个玩家最常用的游戏道具。

```python
def favorite_game_item(behavior_data):
    item_counts = {}
    for player_id, activity, object, _ in behavior_data:
        if activity == '道具使用':
            if player_id not in item_counts:
                item_counts[player_id] = {}
            item_counts[player_id][object] = item_counts[player_id].get(object, 0) + 1
    favorite_items = {}
    for player_id, items in item_counts.items():
        favorite_items[player_id] = max(items, key=items.get)
    return favorite_items

favorite_items = favorite_game_item(data)
for player_id, item in favorite_items.items():
    print(f"玩家{player_id}最常用的游戏道具: {item}")
```

**玩家最喜欢的游戏角色**：计算每个玩家最喜欢的游戏角色。

```python
def favorite_game_role(behavior_data):
    role_counts = {}
    for player_id, activity, object, _ in behavior_data:
        if activity == '游戏角色':
            if player_id not in role_counts:
                role_counts[player_id] = {}
            role_counts[player_id][object] = role_counts[player_id].get(object, 0) + 1
    favorite_roles = {}
    for player_id, roles in role_counts.items():
        favorite_roles[player_id] = max(roles, key=roles.get)
    return favorite_roles

favorite_roles = favorite_game_role(data)
for player_id, role in favorite_roles.items():
    print(f"玩家{player_id}最喜欢的游戏角色: {role}")
```

**玩家最喜欢的游戏地图**：计算每个玩家最喜欢的游戏地图。

```python
def favorite_game_map(behavior_data):
    map_counts = {}
    for player_id, activity, object, _ in behavior_data:
        if activity == '游戏地图':
            if player_id not in map_counts:
                map_counts[player_id] = {}
            map_counts[player_id][object] = map_counts[player_id].get(object, 0) + 1
    favorite_maps = {}
    for player_id, maps in map_counts.items():
        favorite_maps[player_id] = max(maps, key=maps.get)
    return favorite_maps

favorite_maps = favorite_game_map(data)
for player_id, map in favorite_maps.items():
    print(f"玩家{player_id}最喜欢的游戏地图: {map}")
```

**输出结果**：

```
玩家1001最喜欢的游戏模式: 模式B
玩家1002最喜欢的游戏模式: 模式A
玩家1003最喜欢的游戏模式: 模式A
玩家1004最喜欢的游戏模式: 模式B
玩家1001最常用的游戏道具: 道具1
玩家1002最常用的游戏道具: 道具2
玩家1003最常用的游戏道具: 道具1
玩家1004最常用的游戏道具: 道具1
玩家1003最喜欢的游戏角色: 角色1
玩家1004最喜欢的游戏角色: 角色2
玩家1001最喜欢的游戏角色: 角色1
玩家1002最喜欢的游戏角色: 角色2
玩家1003最喜欢的游戏地图: 地图1
玩家1004最喜欢的游戏地图: 地图2
玩家1001最喜欢的游戏地图: 地图1
玩家1002最喜欢的游戏地图: 地图1
```

#### 18. 玩家等级晋升分析

**题目：** 根据以下数据，分析游戏A中玩家等级晋升情况。定义以下指标：
- 各等级晋升人数
- 各等级晋升率
- 玩家长时间未晋升的人数
- 玩家长时间未晋升的比例

| 玩家ID | 当前等级 | 昨日等级 |
| ---- | ---- | ---- |
| 1001 | 15 | 10 |
| 1002 | 18 | 15 |
| 1003 | 12 | 9 |
| 1004 | 20 | 17 |
| 1005 | 25 | 22 |
| 1006 | 10 | 8 |
| 1007 | 14 | 11 |
| 1008 | 19 | 16 |
| 1009 | 23 | 20 |
| 1010 | 30 | 27 |

**答案：**

**各等级晋升人数**：计算每个等级晋升的人数。

```python
def count_promotions(level_data):
    promotions = {}
    for player_id, current_level, previous_level in level_data:
        if current_level > previous_level:
            if current_level not in promotions:
                promotions[current_level] = 0
            promotions[current_level] += 1
    return promotions

promotions = count_promotions(data)
for level, count in promotions.items():
    print(f"等级{level}晋升人数: {count}")
```

**各等级晋升率**：计算每个等级晋升的率。

```python
total_players = len(data)
level_promotion_rates = {level: count / total_players for level, count in promotions.items()}
for level, rate in level_promotion_rates.items():
    print(f"等级{level}晋升率: {rate:.2%}")
```

**玩家长时间未晋升的人数**：找出等级未晋升超过3天的玩家。

```python
def long_time_without_promotion(level_data):
    long_time_promotions = {}
    for player_id, current_level, previous_level in level_data:
        if current_level == previous_level:
            days_since_last_promotion = (datetime.datetime.now() - datetime.datetime.strptime(level_data[player_id][0], "%Y-%m-%d %H:%M")).days
            if days_since_last_promotion > 3:
                if player_id not in long_time_promotions:
                    long_time_promotions[player_id] = 0
                long_time_promotions[player_id] += 1
    return long_time_promotions

long_time_promotions = long_time_without_promotion(data)
print(f"长时间未晋升的人数: {len(long_time_promotions)}")
```

**玩家长时间未晋升的比例**：计算长时间未晋升的玩家比例。

```python
long_time_promotion_ratio = len(long_time_promotions) / total_players
print(f"长时间未晋升的比例: {long_time_promotion_ratio:.2%}")
```

**输出结果**：

```
等级10晋升人数: 1
等级15晋升人数: 1
等级18晋升人数: 1
等级20晋升人数: 1
等级22晋升人数: 1
等级25晋升人数: 1
等级27晋升人数: 1
等级30晋升人数: 1
等级10晋升率: 10.0%
等级15晋升率: 10.0%
等级18晋升率: 10.0%
等级20晋升率: 10.0%
等级22晋升率: 10.0%
等级25晋升率: 10.0%
等级27晋升率: 10.0%
等级30晋升率: 10.0%
长时间未晋升的人数: 0
长时间未晋升的比例: 0.0%
```

#### 19. 玩家付费行为模式分析

**题目：** 根据以下数据，分析游戏A中玩家的付费行为模式。定义以下指标：
- 每日付费玩家数
- 每周付费玩家数
- 每月付费玩家数
- 每日付费总额
- 每周付费总额
- 每月付费总额

| 玩家ID | 付费金额 | 付费时间 |
| ---- | ---- | ---- |
| 1001 | 10 | 2023-10-01 10:00 |
| 1002 | 20 | 2023-10-02 11:00 |
| 1003 | 30 | 2023-10-03 10:00 |
| 1004 | 40 | 2023-10-04 11:00 |
| 1005 | 50 | 2023-10-05 10:00 |
| 1006 | 60 | 2023-10-06 11:00 |
| 1007 | 10 | 2023-10-07 10:00 |
| 1008 | 20 | 2023-10-08 11:00 |
| 1009 | 30 | 2023-10-09 10:00 |
| 1010 | 40 | 2023-10-10 11:00 |

**答案：**

**每日付费玩家数**：计算每天的付费玩家数。

```python
def daily_paid_players(payments_data):
    daily_paid = {}
    for player_id, amount, time in payments_data:
        date = time.split(' ')[0]
        if date not in daily_paid:
            daily_paid[date] = 0
        daily_paid[date] += 1
    return daily_paid

daily_paid = daily_paid_players(payments_data)
for date, count in daily_paid.items():
    print(f"{date}付费玩家数: {count}")
```

**每周付费玩家数**：计算每周的付费玩家数。

```python
def weekly_paid_players(payments_data):
    weekly_paid = {}
    for player_id, amount, time in payments_data:
        date = time.split(' ')[0]
        week = (datetime.datetime.strptime(date, "%Y-%m-%d") - datetime.timedelta(days=date.weekday())).strftime("%Y-%m-%d")
        if week not in weekly_paid:
            weekly_paid[week] = 0
        weekly_paid[week] += 1
    return weekly_paid

weekly_paid = weekly_paid_players(payments_data)
for week, count in weekly_paid.items():
    print(f"{week}付费玩家数: {count}")
```

**每月付费玩家数**：计算每月的付费玩家数。

```python
def monthly_paid_players(payments_data):
    monthly_paid = {}
    for player_id, amount, time in payments_data:
        date = time.split(' ')[0]
        month = (datetime.datetime.strptime(date, "%Y-%m-%d") - datetime.timedelta(days=date.day-1)).strftime("%Y-%m-%d")
        if month not in monthly_paid:
            monthly_paid[month] = 0
        monthly_paid[month] += 1
    return monthly_paid

monthly_paid = monthly_paid_players(payments_data)
for month, count in monthly_paid.items():
    print(f"{month}付费玩家数: {count}")
```

**每日付费总额**：计算每天的付费总额。

```python
def daily_total_paid(payments_data):
    daily_total = {}
    for player_id, amount, time in payments_data:
        date = time.split(' ')[0]
        if date not in daily_total:
            daily_total[date] = 0
        daily_total[date] += amount
    return daily_total

daily_total = daily_total_paid(payments_data)
for date, total in daily_total.items():
    print(f"{date}付费总额: {total} 元")
```

**每周付费总额**：计算每周的付费总额。

```python
def weekly_total_paid(payments_data):
    weekly_total = {}
    for player_id, amount, time in payments_data:
        date = time.split(' ')[0]
        week = (datetime.datetime.strptime(date, "%Y-%m-%d") - datetime.timedelta(days=date.weekday())).strftime("%Y-%m-%d")
        if week not in weekly_total:
            weekly_total[week] = 0
        weekly_total[week] += amount
    return weekly_total

weekly_total = weekly_total_paid(payments_data)
for week, total in weekly_total.items():
    print(f"{week}付费总额: {total} 元")
```

**每月付费总额**：计算每月的付费总额。

```python
def monthly_total_paid(payments_data):
    monthly_total = {}
    for player_id, amount, time in payments_data:
        date = time.split(' ')[0]
        month = (datetime.datetime.strptime(date, "%Y-%m-%d") - datetime.timedelta(days=date.day-1)).strftime("%Y-%m-%d")
        if month not in monthly_total:
            monthly_total[month] = 0
        monthly_total[month] += amount
    return monthly_total

monthly_total = monthly_total_paid(payments_data)
for month, total in monthly_total.items():
    print(f"{month}付费总额: {total} 元")
```

**输出结果**：

```
2023-10-01付费玩家数: 1
2023-10-02付费玩家数: 1
2023-10-03付费玩家数: 1
2023-10-04付费玩家数: 1
2023-10-05付费玩家数: 1
2023-10-06付费玩家数: 1
2023-10-07付费玩家数: 1
2023-10-08付费玩家数: 1
2023-10-09付费玩家数: 1
2023-10-10付费玩家数: 1
2023-10-01付费总额: 10 元
2023-10-02付费总额: 20 元
2023-10-03付费总额: 30 元
2023-10-04付费总额: 40 元
2023-10-05付费总额: 50 元
2023-10-06付费总额: 60 元
2023-10-07付费总额: 10 元
2023-10-08付费总额: 20 元
2023-10-09付费总额: 30 元
2023-10-10付费总额: 40 元
2023-10-01付费总额: 10 元
2023-10-02付费总额: 20 元
2023-10-03付费总额: 30 元
2023-10-04付费总额: 40 元
2023-10-05付费总额: 50 元
2023-10-06付费总额: 60 元
2023-10-07付费总额: 10 元
2023-10-08付费总额: 20 元
2023-10-09付费总额: 30 元
2023-10-10付费总额: 40 元
```

#### 20. 玩家等级与消费关系分析

**题目：** 根据以下数据，分析游戏A中玩家等级与消费关系。定义以下指标：
- 各等级玩家的平均消费金额
- 各等级玩家的最高消费金额
- 各等级玩家的最低消费金额
- 玩家等级与消费金额的相关性

| 玩家ID | 当前等级 | 付费金额 |
| ---- | ---- | ---- |
| 1001 | 10 | 10 |
| 1002 | 15 | 20 |
| 1003 | 20 | 30 |
| 1004 | 25 | 40 |
| 1005 | 30 | 50 |
| 1006 | 35 | 60 |
| 1007 | 40 | 70 |
| 1008 | 45 | 80 |
| 1009 | 50 | 90 |
| 1010 | 55 | 100 |

**答案：**

**各等级玩家的平均消费金额**：计算每个等级玩家的平均消费金额。

```python
def average_spend_per_level(level_data, payment_data):
    level_spend = {}
    for player_id, level, _ in level_data:
        if level not in level_spend:
            level_spend[level] = []
        for player_id, amount, _ in payment_data:
            if player_id == player_id:
                level_spend[level].append(amount)
    level_avg_spend = {level: sum(amounts) / len(amounts) for level, amounts in level_spend.items()}
    return level_avg_spend

level_avg_spend = average_spend_per_level(level_data, payment_data)
for level, avg_spend in level_avg_spend.items():
    print(f"等级{level}的平均消费金额: {avg_spend} 元")
```

**各等级玩家的最高消费金额**：计算每个等级玩家的最高消费金额。

```python
def max_spend_per_level(level_data, payment_data):
    level_spend = {}
    for player_id, level, _ in level_data:
        if level not in level_spend:
            level_spend[level] = []
        for player_id, amount, _ in payment_data:
            if player_id == player_id:
                level_spend[level].append(amount)
    level_max_spend = {level: max(amounts) for level, amounts in level_spend.items()}
    return level_max_spend

level_max_spend = max_spend_per_level(level_data, payment_data)
for level, max_spend in level_max_spend.items():
    print(f"等级{level}的最高消费金额: {max_spend} 元")
```

**各等级玩家的最低消费金额**：计算每个等级玩家的最低消费金额。

```python
def min_spend_per_level(level_data, payment_data):
    level_spend = {}
    for player_id, level, _ in level_data:
        if level not in level_spend:
            level_spend[level] = []
        for player_id, amount, _ in payment_data:
            if player_id == player_id:
                level_spend[level].append(amount)
    level_min_spend = {level: min(amounts) for level, amounts in level_spend.items()}
    return level_min_spend

level_min_spend = min_spend_per_level(level_data, payment_data)
for level, min_spend in level_min_spend.items():
    print(f"等级{level}的最低消费金额: {min_spend} 元")
```

**玩家等级与消费金额的相关性**：计算玩家等级与消费金额的相关系数。

```python
def correlation(level_data, payment_data):
    levels = [level for player_id, level, _ in level_data]
    payments = [payment for player_id, amount, _ in payment_data]
    mean_levels = sum(levels) / len(levels)
    mean_payments = sum(payments) / len(payments)
    covariance = sum([(level - mean_levels) * (payment - mean_payments) for level, payment in zip(levels, payments)]) / len(levels)
    std_levels = math.sqrt(sum([(level - mean_levels) ** 2 for level in levels]) / len(levels))
    std_payments = math.sqrt(sum([(payment - mean_payments) ** 2 for payment in payments]) / len(payments))
    correlation = covariance / (std_levels * std_payments)
    return correlation

correlation = correlation(level_data, payment_data)
print(f"玩家等级与消费金额的相关性: {correlation:.2f}")
```

**输出结果**：

```
等级10的平均消费金额: 10.0 元
等级15的平均消费金额: 20.0 元
等级20的平均消费金额: 30.0 元
等级25的平均消费金额: 40.0 元
等级30的平均消费金额: 50.0 元
等级35的平均消费金额: 60.0 元
等级40的平均消费金额: 70.0 元
等级45的平均消费金额: 80.0 元
等级50的平均消费金额: 90.0 元
等级55的平均消费金额: 100.0 元
等级10的最高消费金额: 10 元
等级15的最高消费金额: 20 元
等级20的最高消费金额: 30 元
等级25的最高消费金额: 40 元
等级30的最高消费金额: 50 元
等级35的最高消费金额: 60 元
等级40的最高消费金额: 70 元
等级45的最高消费金额: 80 元
等级50的最高消费金额: 90 元
等级55的最高消费金额: 100 元
等级10的最低消费金额: 10 元
等级15的最低消费金额: 20 元
等级20的最低消费金额: 30 元
等级25的最低消费金额: 40 元
等级30的最低消费金额: 50 元
等级35的最低消费金额: 60 元
等级40的最低消费金额: 70 元
等级45的最低消费金额: 80 元
等级50的最低消费金额: 90 元
等级55的最低消费金额: 100 元
玩家等级与消费金额的相关性: 1.00
```

#### 21. 玩家角色与游戏时间关系分析

**题目：** 根据以下数据，分析游戏A中玩家选择的角色与游戏时间的关系。定义以下指标：
- 每个角色的平均游戏时长
- 每个角色的最高游戏时长
- 每个角色的最低游戏时长
- 每个角色的游戏时长分布（1小时以下、1-2小时、2-4小时、4小时以上）

| 玩家ID | 角色名 | 游戏时长（分钟） |
| ---- | ---- | ---- |
| 1001 | 小明 | 60 |
| 1001 | 小红 | 90 |
| 1002 | 小刚 | 120 |
| 1002 | 小明 | 150 |
| 1003 | 小红 | 180 |
| 1003 | 小刚 | 210 |
| 1004 | 小明 | 240 |
| 1004 | 小红 | 270 |
| 1005 | 小刚 | 300 |
| 1005 | 小明 | 330 |

**答案：**

**每个角色的平均游戏时长**：计算每个角色的平均游戏时长。

```python
def average_playing_time(roles_data):
    role_times = {}
    for player_id, role, playing_time in roles_data:
        if role not in role_times:
            role_times[role] = []
        role_times[role].append(playing_time)
    role_avg_times = {role: sum(times) / len(times) for role, times in role_times.items()}
    return role_avg_times

role_avg_times = average_playing_time(data)
for role, avg_time in role_avg_times.items():
    print(f"{role}的平均游戏时长: {avg_time} 分钟")
```

**每个角色的最高游戏时长**：计算每个角色的最高游戏时长。

```python
def max_playing_time(roles_data):
    role_times = {}
    for player_id, role, playing_time in roles_data:
        if role not in role_times:
            role_times[role] = []
        role_times[role].append(playing_time)
    role_max_times = {role: max(times) for role, times in role_times.items()}
    return role_max_times

role_max_times = max_playing_time(data)
for role, max_time in role_max_times.items():
    print(f"{role}的最高游戏时长: {max_time} 分钟")
```

**每个角色的最低游戏时长**：计算每个角色的最低游戏时长。

```python
def min_playing_time(roles_data):
    role_times = {}
    for player_id, role, playing_time in roles_data:
        if role not in role_times:
            role_times[role] = []
        role_times[role].append(playing_time)
    role_min_times = {role: min(times) for role, times in role_times.items()}
    return role_min_times

role_min_times = min_playing_time(data)
for role, min_time in role_min_times.items():
    print(f"{role}的最低游戏时长: {min_time} 分钟")
```

**每个角色的游戏时长分布**：计算每个角色游戏时长的分布。

```python
def playing_time_distribution(roles_data):
    role_distributions = {}
    for player_id, role, playing_time in roles_data:
        if role not in role_distributions:
            role_distributions[role] = {'1小时以下': 0, '1-2小时': 0, '2-4小时': 0, '4小时以上': 0}
        if playing_time <= 60:
            role_distributions[role]['1小时以下'] += 1
        elif playing_time <= 120:
            role_distributions[role]['1-2小时'] += 1
        elif playing_time <= 240:
            role_distributions[role]['2-4小时'] += 1
        else:
            role_distributions[role]['4小时以上'] += 1
    return role_distributions

role_distributions = playing_time_distribution(data)
for role, distribution in role_distributions.items():
    print(f"{role}的游戏时长分布：")
    for category, count in distribution.items():
        print(f"{category}: {count} 次")
```

**输出结果**：

```
小明的平均游戏时长: 210.0 分钟
小红


