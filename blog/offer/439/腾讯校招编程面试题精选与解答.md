                 

# 2025腾讯校招编程面试题精选与解答

## 1. 链表操作与反转

### 1.1 单链表反转

**题目：** 实现一个函数，将单链表反转。

**思路：** 使用递归或迭代的方法，将链表的每个节点指向它的前一个节点。

**解答：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

### 1.2 双向链表反转

**题目：** 实现一个函数，将双向链表反转。

**思路：** 与单链表反转类似，只是需要改变前后节点的关系。

**解答：**

```go
type双向链表Node {
    Val  int
    Pre  *双向链表Node
    Next *双向链表Node
}

func reverseDoubleList(head *双向链表Node) *双向链表Node {
    if head == nil || head.Next == nil {
        return head
    }
    prev := nil
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        curr.Pre = nextTemp
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

## 2. 栈与队列

### 2.1 实现一个栈

**题目：** 实现一个栈，支持 push、pop、isEmpty、peek 操作。

**思路：** 使用数组或链表实现栈。

**解答：**

```go
type Stack struct {
    elements []int
}

func (s *Stack) Push(val int) {
    s.elements = append(s.elements, val)
}

func (s *Stack) Pop() (int, bool) {
    if len(s.elements) == 0 {
        return 0, false
    }
    elem := s.elements[len(s.elements)-1]
    s.elements = s.elements[:len(s.elements)-1]
    return elem, true
}

func (s *Stack) IsEmpty() bool {
    return len(s.elements) == 0
}

func (s *Stack) Peek() (int, bool) {
    if len(s.elements) == 0 {
        return 0, false
    }
    return s.elements[len(s.elements)-1], true
}
```

### 2.2 实现一个队列

**题目：** 实现一个队列，支持 enqueue、dequeue、isEmpty 操作。

**思路：** 使用数组或链表实现队列。

**解答：**

```go
type Queue struct {
    elements []int
    front    int
    rear     int
}

func (q *Queue) Enqueue(val int) {
    q.elements = append(q.elements, val)
    q.rear++
}

func (q *Queue) Dequeue() (int, bool) {
    if q.isEmpty() {
        return 0, false
    }
    elem := q.elements[q.front]
    q.front++
    return elem, true
}

func (q *Queue) IsEmpty() bool {
    return q.front == q.rear
}
```

## 3. 递归与分治

### 3.1 斐波那契数列

**题目：** 实现一个函数，计算斐波那契数列的第 n 项。

**思路：** 使用递归或动态规划的方法。

**解答：**

递归：

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}
```

动态规划：

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

## 4. 字符串处理

### 4.1 最长公共前缀

**题目：** 编写一个函数，找到字符串数组中的最长公共前缀。

**思路：** 使用横向扫描的方法。

**解答：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
        }
        if prefix == "" {
            return ""
        }
    }
    return prefix
}
```

## 5. 数据结构

### 5.1 二叉树

**题目：** 实现一个二叉树，支持插入、删除、查找等操作。

**思路：** 使用链式存储结构。

**解答：**

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func (t *TreeNode) Insert(val int) {
    if val < t.Val {
        if t.Left == nil {
            t.Left = &TreeNode{Val: val}
        } else {
            t.Left.Insert(val)
        }
    } else {
        if t.Right == nil {
            t.Right = &TreeNode{Val: val}
        } else {
            t.Right.Insert(val)
        }
    }
}

func (t *TreeNode) Delete(val int) {
    if t.Val == val {
        if t.Left == nil && t.Right == nil {
            t = nil
        } else if t.Left == nil {
            t = t.Right
        } else if t.Right == nil {
            t = t.Left
        } else {
            minNode := t.Right
            for minNode.Left != nil {
                minNode = minNode.Left
            }
            t.Val = minNode.Val
            t.Right.Delete(minNode.Val)
        }
    } else if val < t.Val {
        t.Left.Delete(val)
    } else {
        t.Right.Delete(val)
    }
}

func (t *TreeNode) Contains(val int) bool {
    if t == nil {
        return false
    }
    if t.Val == val {
        return true
    } else if val < t.Val {
        return t.Left.Contains(val)
    } else {
        return t.Right.Contains(val)
    }
}
```

## 6. 算法与数据结构综合应用

### 6.1 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表。

**思路：** 递归或迭代比较两个链表的节点，将较小的节点插入新链表中。

**解答：**

递归：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}
```

### 6.2 二分查找

**题目：** 在排序数组中查找某个元素的索引。

**思路：** 使用二分查找算法。

**解答：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

### 6.3 最长公共子序列

**题目：** 给定两个字符串，找到它们的最长公共子序列。

**思路：** 使用动态规划算法。

**解答：**

```go
func longestCommonSubsequence(text1, text2 string) string {
    dp := make([][]int, len(text1)+1)
    for i := range dp {
        dp[i] = make([]int, len(text2)+1)
    }
    for i := 1; i <= len(text1); i++ {
        for j := 1; j <= len(text2); j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var result []byte
    i, j := len(text1), len(text2)
    for dp[i][j] > 0 {
        if text1[i-1] == text2[j-1] {
            result = append(result, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(result)
    return string(result)
}

func reverse(s []byte) {
    n := len(s)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 7. 其他常见问题

### 7.1 判断回文数

**题目：** 判断一个整数是否是回文数。

**思路：** 将整数转换为字符串，然后比较字符串的首尾是否相同。

**解答：**

```go
func isPalindrome(x int) bool {
    if x < 0 || (x%10 == 0 && x != 0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x /= 10
    }
    return x == reversed || x == reversed/10
}
```

### 7.2 合并两个有序数组

**题目：** 将两个按升序排列的数组合并为一个数组。

**思路：** 使用双指针方法。

**解答：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    idx := m + n - 1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[idx] = nums1[p1]
            p1--
        } else {
            nums1[idx] = nums2[p2]
            p2--
        }
        idx--
    }
    for p2 >= 0 {
        nums1[idx] = nums2[p2]
        p2--
        idx--
    }
}
```

### 7.3 最小栈

**题目：** 设计一个支持 push、pop、getMin 操作的最小栈。

**思路：** 使用辅助栈记录最小值。

**解答：**

```go
type MinStack struct {
    stack []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack: make([]int, 0),
        minStack: make([]int, 0),
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if len(this.minStack) == 0 || val <= this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    }
}

func (this *MinStack) Pop() {
    if this.stack[len(this.stack)-1] == this.minStack[len(this.minStack)-1] {
        this.minStack = this.minStack[:len(this.minStack)-1]
    }
    this.stack = this.stack[:len(this.stack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

