                 

### 《知识加速器：资源对接与初创企业成长之道》

#### 引言

知识加速器作为一种创新资源对接平台，正逐渐成为初创企业成长的助推器。本文将探讨初创企业在发展过程中可能遇到的问题，并分享一些典型的高频面试题和算法编程题，旨在帮助创业者更好地应对面试挑战，加速企业成长。

#### 一、面试题库

### 1. 初创企业的核心竞争要素是什么？

**答案：** 初创企业的核心竞争要素包括创新力、执行力、团队协作能力、市场敏感度和资金管理能力。其中，创新力是企业的核心竞争力，执行力决定企业能否将创新转化为实际成果，团队协作能力保证企业高效运作，市场敏感度帮助企业在竞争中抢占先机，资金管理能力确保企业财务健康。

### 2. 初创企业在融资过程中应关注哪些方面？

**答案：** 初创企业在融资过程中应关注以下方面：

* **商业计划书**：清晰展示企业的商业模式、市场前景、盈利模式等。
* **团队组成**：介绍核心团队成员的背景、经验和能力。
* **市场调研**：提供市场现状、目标客户群体、竞争对手分析等。
* **财务预测**：预测企业的收入、成本、利润等财务指标。
* **法律合规**：确保企业运营符合相关法律法规要求。

### 3. 如何提升初创企业的品牌知名度？

**答案：** 提升初创企业的品牌知名度可以从以下几个方面入手：

* **社交媒体营销**：利用微博、微信、抖音等平台进行品牌推广。
* **内容营销**：通过撰写行业报告、白皮书、博客文章等，提升品牌的专业形象。
* **公关活动**：举办线下活动、参加行业展会，扩大品牌影响力。
* **合作与联盟**：与知名企业、行业协会合作，共同推广品牌。

### 4. 初创企业如何进行人才招聘？

**答案：** 初创企业进行人才招聘应注重以下几点：

* **明确招聘需求**：根据企业发展战略和业务需求，明确招聘岗位的职责和要求。
* **优化招聘渠道**：利用招聘网站、社交媒体、内部推荐等多种渠道发布招聘信息。
* **面试评估**：通过多轮面试，评估候选人的专业技能、团队合作能力和文化契合度。
* **薪酬福利**：提供有竞争力的薪酬和福利，吸引优秀人才。

### 5. 初创企业如何进行项目风险评估？

**答案：** 初创企业进行项目风险评估应从以下几个方面考虑：

* **市场风险**：分析市场需求、竞争状况、政策环境等因素。
* **技术风险**：评估项目的技术可行性、研发进度和技术成熟度。
* **财务风险**：预测项目的成本、收入、利润等财务指标。
* **法律风险**：确保项目符合相关法律法规要求，避免法律纠纷。

### 6. 初创企业如何进行项目管理？

**答案：** 初创企业进行项目管理应注重以下几点：

* **制定项目计划**：明确项目目标、任务、时间表和资源分配。
* **团队协作**：建立高效沟通机制，确保团队成员协作顺畅。
* **风险管理**：识别项目风险，制定应对措施。
* **质量控制**：确保项目按照预定标准完成。
* **项目监控**：定期跟踪项目进度，及时调整计划。

### 7. 初创企业如何进行品牌建设？

**答案：** 初创企业进行品牌建设应注重以下几点：

* **定位明确**：明确品牌定位，打造独特品牌形象。
* **价值传递**：通过品牌传播，传递企业价值观和产品价值。
* **口碑营销**：注重用户口碑，积极回应用户反馈。
* **品牌传播**：利用线上线下多种渠道，扩大品牌影响力。

### 8. 初创企业如何进行市场营销？

**答案：** 初创企业进行市场营销应注重以下几点：

* **市场调研**：了解目标市场和潜在客户需求。
* **定位精准**：确定目标客户群体，制定针对性的营销策略。
* **内容营销**：通过有价值的内容吸引和留住客户。
* **渠道拓展**：利用多种营销渠道，扩大品牌知名度。
* **数据分析**：通过数据分析，优化营销策略。

### 9. 初创企业如何进行客户关系管理？

**答案：** 初创企业进行客户关系管理应注重以下几点：

* **客户分类**：根据客户需求、购买行为等进行分类管理。
* **个性化服务**：提供个性化的产品和服务，满足客户需求。
* **沟通互动**：保持与客户的沟通，及时回应客户问题。
* **满意度调查**：定期进行客户满意度调查，优化客户服务。

### 10. 初创企业如何进行社会责任管理？

**答案：** 初创企业进行社会责任管理应注重以下几点：

* **遵守法律法规**：确保企业运营符合相关法律法规要求。
* **环保意识**：关注环境保护，推动绿色生产。
* **公益慈善**：积极参与社会公益活动，承担社会责任。
* **员工关怀**：关注员工福利，营造良好的企业文化。

### 11. 初创企业如何进行知识管理？

**答案：** 初创企业进行知识管理应注重以下几点：

* **知识共享**：建立知识共享平台，促进员工之间的知识交流。
* **知识积累**：通过文档、博客、培训等形式，积累企业知识。
* **知识创新**：鼓励员工进行知识创新，推动企业持续发展。
* **知识保护**：确保企业知识不被泄露，保护企业核心竞争力。

### 12. 初创企业如何进行团队建设？

**答案：** 初创企业进行团队建设应注重以下几点：

* **共同目标**：明确团队目标，确保团队成员齐心协力。
* **沟通协作**：建立良好的沟通机制，促进团队协作。
* **激励机制**：设立合理的激励机制，激发员工积极性。
* **团队活动**：组织团队建设活动，增强团队凝聚力。

### 13. 初创企业如何进行市场拓展？

**答案：** 初创企业进行市场拓展应注重以下几点：

* **市场调研**：了解目标市场的情况，制定拓展策略。
* **定位清晰**：明确目标客户群体，提供针对性的产品和服务。
* **渠道建设**：建立多元化的销售渠道，扩大市场覆盖面。
* **品牌推广**：利用线上线下多种渠道进行品牌推广。
* **客户关系**：建立良好的客户关系，提升客户满意度。

### 14. 初创企业如何进行财务管理？

**答案：** 初创企业进行财务管理应注重以下几点：

* **预算管理**：制定合理的预算计划，确保财务收支平衡。
* **成本控制**：通过成本控制，提高企业盈利能力。
* **财务报表**：定期编制财务报表，掌握企业财务状况。
* **税务管理**：遵守税务法规，合理避税。
* **风险控制**：建立风险控制机制，防范财务风险。

### 15. 初创企业如何进行产品创新？

**答案：** 初创企业进行产品创新应注重以下几点：

* **市场调研**：了解市场需求，捕捉创新机遇。
* **技术创新**：不断进行技术研究和开发，推动产品创新。
* **用户体验**：关注用户反馈，优化产品体验。
* **差异化竞争**：打造独特的产品优势，形成差异化竞争。
* **知识产权**：申请专利，保护创新成果。

### 16. 初创企业如何进行供应链管理？

**答案：** 初创企业进行供应链管理应注重以下几点：

* **供应商选择**：选择优质供应商，确保供应链稳定性。
* **库存管理**：优化库存管理，降低库存成本。
* **物流配送**：建立高效的物流配送体系，提高配送效率。
* **质量管理**：确保产品质量，提升客户满意度。
* **风险应对**：制定风险应对策略，降低供应链风险。

### 17. 初创企业如何进行市场进入策略选择？

**答案：** 初创企业进行市场进入策略选择应注重以下几点：

* **市场调研**：了解目标市场的情况，选择合适的市场进入时机。
* **定位明确**：明确目标客户群体，制定针对性的市场进入策略。
* **产品定位**：根据目标市场，确定产品定位和价格策略。
* **渠道选择**：选择合适的销售渠道，扩大市场覆盖面。
* **品牌推广**：利用线上线下多种渠道进行品牌推广。

### 18. 初创企业如何进行人才储备？

**答案：** 初创企业进行人才储备应注重以下几点：

* **人才招聘**：制定招聘计划，通过各种渠道招聘人才。
* **培训与发展**：为员工提供培训和发展机会，提升员工能力。
* **绩效激励**：建立合理的绩效激励机制，激发员工积极性。
* **企业文化**：营造良好的企业文化，吸引和留住人才。
* **团队建设**：注重团队建设，提升团队协作能力。

### 19. 初创企业如何进行风险管理与控制？

**答案：** 初创企业进行风险管理与控制应注重以下几点：

* **风险识别**：识别企业面临的各种风险，包括市场风险、技术风险、财务风险等。
* **风险评估**：评估风险的影响程度和可能性，制定风险应对策略。
* **风险监控**：建立风险监控机制，及时发现和处理风险。
* **风险应对**：制定风险应对措施，降低风险损失。

### 20. 初创企业如何进行知识产权保护？

**答案：** 初创企业进行知识产权保护应注重以下几点：

* **专利申请**：及时申请专利，保护创新成果。
* **商标注册**：注册商标，保护品牌形象。
* **版权保护**：通过版权登记等方式，保护原创作品。
* **合同管理**：签订知识产权转让、许可等合同，确保权益。
* **侵权应对**：发现侵权行为，及时采取法律手段维权。

#### 二、算法编程题库

### 1. 剑指 Offer 15. 二进制中 1 的个数

**题目：** 请实现一个函数，输入一个整数（32位无符号整数），输出该数二进制表示中 1 的个数。

**示例：**
```python
def hammingWeight(n: int) -> int:
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

### 2. 剑指 Offer 16. 数值的整数次方

**题目：** 实现函数 `myPow(x, n)`，计算 x 的 n 次幂，其中 x 是浮点数，n 是整数，需要考虑大数问题。

**示例：**
```python
def myPow(x: float, n: int) -> float:
    if n < 0:
        x = 1 / x
        n = -n
    res = 1
    while n:
        if n & 1:
            res *= x
        x *= x
        n >>= 1
    return res
```

### 3. 剑指 Offer 17. 打印从 1 到最大的 n 位数

**题目：** 以字符串形式打印出从 1 到最大的 n 位十进制数。

**示例：**
```python
def printNumbers(n: int) -> List[str]:
    if n <= 0:
        return []
    res = []
    for i in range(1, 10**n):
        res.append(str(i))
    return res
```

### 4. 剑指 Offer 18. 删除链表的节点

**题目：** 给定一个单链表和一个节点，删除该节点。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```

### 5. 剑指 Offer 19. 正则表达式匹配

**题目：** 实现正则表达式匹配。

**示例：**
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
        dp[0][0] = True
        for j in range(2, len(p) + 1):
            dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'
        for i in range(1, len(s) + 1):
            for j in range(1, len(p) + 1):
                if p[j - 1] == '*':
                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))
                else:
                    dp[i][j] = dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.')
        return dp[-1][-1]
```

### 6. 剑指 Offer 20. 表示数值的字符串

**题目：** 实现函数 `isNumber`，判断一个字符串是否表示数值。

**示例：**
```python
class Solution:
    def isNumber(self, s: str) -> bool:
        def is_digit(c):
            return '0' <= c <= '9'

        def is_char(c, a, b):
            return a <= ord(c) <= b

        def is_space(c):
            return c == ' '

        def is_decimal_point(c, seen_decimal_point):
            return c == '.' and not seen_decimal_point

        def is_exponent(c, seen_exponent):
            return c == 'e' and not seen_exponent

        def is_sign(c, seen_sign):
            return (c == '+' or c == '-') and not seen_sign

        def is_letter(c):
            return 'a' <= c <= 'z' or 'A' <= c <= 'Z'

        seen_decimal_point = seen_exponent = seen_sign = False
        seen_digit = False
        i, n = 0, len(s)
        while i < n:
            c = s[i]
            if is_digit(c):
                seen_digit = True
                i += 1
            elif is_decimal_point(c, seen_decimal_point):
                seen_decimal_point = True
                i += 1
            elif is_exponent(c, seen_exponent):
                seen_exponent = True
                i += 1
            elif is_sign(c, seen_sign):
                seen_sign = True
                i += 1
            elif is_space(c):
                i += 1
            elif is_letter(c):
                i += 1
            else:
                break

        j = i
        if j == n:
            return seen_digit

        while j < n:
            c = s[j]
            if not is_digit(c) and not is_decimal_point(c, seen_decimal_point) and not is_exponent(c, seen_exponent) and not is_sign(c, seen_sign) and not is_space(c):
                break
            j += 1

        return j == n and seen_digit
```

### 7. 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

**题目：** 调整数组中奇数和偶数的顺序，奇数在前偶数在后。

**示例：**
```python
class Solution:
    def exchange(self, nums: List[int]) -> List[int]:
        left, right = 0, len(nums) - 1
        while left < right:
            while left < right and nums[left] % 2 == 1:
                left += 1
            while left < right and nums[right] % 2 == 0:
                right -= 1
            nums[left], nums[right] = nums[right], nums[left]
        return nums
```

### 8. 剑指 Offer 22. 链表中倒数第 k 个节点

**题目：** 给定一个链表，返回链表的倒数第 k 个节点。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getKthFromEnd(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        slow = fast = head
        for _ in range(k):
            fast = fast.next
        while fast:
            slow = slow.next
            fast = fast.next
        return slow
```

### 9. 剑指 Offer 23. 链表中环的入口节点

**题目：** 给定一个链表，判断链表中是否存在环，并返回环的入口节点。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                slow = head
                while slow != fast:
                    slow = slow.next
                    fast = fast.next
                return slow
        return None
```

### 10. 剑指 Offer 24. 反转链表

**题目：** 反转一个单链表。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev, curr = None, head
        while curr:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp
        return prev
```

### 11. 剑指 Offer 25. 合并两个排序的链表

**题目：** 将两个排序后的链表合并成一个排序的链表。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        tail = dummy
        while list1 and list2:
            if list1.val < list2.val:
                tail.next = list1
                list1 = list1.next
            else:
                tail.next = list2
                list2 = list2.next
            tail = tail.next
        tail.next = list1 or list2
        return dummy.next
```

### 12. 剑指 Offer 26. 树的子结构

**题目：** 判断一个树是否是另一个树的子结构。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubStructure(self, A: Optional[TreeNode], B: Optional[TreeNode]) -> bool:
        if not B:
            return True
        if not A:
            return False
        if A.val == B.val:
            return isSub(A.left, B.left) or isSub(A.right, B.right)
        return isSub(A.left, B) or isSub(A.right, B)

def isSub(A, B):
    if not B:
        return True
    if not A:
        return False
    if A.val != B.val:
        return False
    return isSub(A.left, B.left) and isSub(A.right, B.right)
```

### 13. 剑指 Offer 27. 二叉树的镜像

**题目：** 对二叉树进行镜像翻转。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mirrorTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root:
            root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)
        return root
```

### 14. 剑指 Offer 28. 对称的二叉树

**题目：** 判断二叉树是否对称。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def isSameTree(p, q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return isSameTree(p.left, q.right) and isSameTree(p.right, q.left)

        return isSameTree(root.left, root.right)
```

### 15. 剑指 Offer 29. 顺时针打印矩阵

**题目：** 顺时针打印一个矩阵。

**示例：**
```python
def spiralOrder(matrix: List[List[int]]) -> List[int]:
    if not matrix:
        return []
    m, n = len(matrix), len(matrix[0])
    ans = []
    left, right, top, bottom = 0, n - 1, 0, m - 1
    while left <= right and top <= bottom:
        for i in range(left, right + 1):
            ans.append(matrix[top][i])
        top += 1
        for i in range(top, bottom + 1):
            ans.append(matrix[i][right])
        right -= 1
        if left <= right:
            for i in range(right, left - 1, -1):
                ans.append(matrix[bottom][i])
            bottom -= 1
        if top <= bottom:
            for i in range(bottom, top - 1, -1):
                ans.append(matrix[i][left])
            left += 1
    return ans
```

### 16. 剑指 Offer 30. 包含 min 函数的栈

**题目：** 实现一个带有 min 函数的栈。

**示例：**
```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def min(self) -> int:
        return self.min_stack[-1]
```

### 17. 剑指 Offer 31. 栈的弹出顺序

**题目：** 给定栈的进出顺序，判断是否能够实现相同的弹出顺序。

**示例：**
```python
def validateStackSequences(pushed: List[int], popped: List[int]) -> bool:
    stack = []
    j = 0
    for num in pushed:
        stack.append(num)
        while stack and stack[-1] == popped[j]:
            stack.pop()
            j += 1
    return not stack
```

### 18. 剑指 Offer 32 - I. 效率最高的二叉搜索树

**题目：** 给定一个数组，构建一个效率最高的二叉搜索树。

**示例：**
```python
def constructMaximumBinaryTree(nums: List[int]) -> Optional[TreeNode]:
    if not nums:
        return None
    root = TreeNode(nums[0])
    for i in range(1, len(nums)):
        node = TreeNode(nums[i])
        prev = root
        while prev and prev.val < node.val:
            prev = prev.right
        node.left = prev.left
        prev.left = node
    return root
```

### 19. 剑指 Offer 32 - II. 从上到下打印二叉树 II

**题目：** 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

**示例：**
```python
from collections import deque

def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
        return []
    ans, q = [], deque([root])
    while q:
        ans.append([node.val for node in q])
        q = deque(node.left for node in ans[-1] + node.right for node in q)
    return ans
```

### 20. 剑指 Offer 33. 二叉搜索树的后序遍历序列

**题目：** 判断一个数组是否是二叉搜索树的后序遍历序列。

**示例：**
```python
def verifyPostorder(self, postorder: List[int]) -> bool:
    def dfs(postorder):
        if not postorder:
            return True
        root = postorder[-1]
        m = len(postorder) - 1
        for i in range(len(postorder) - 1, -1, -1):
            if postorder[i] > root:
                m = i
                break
        left = dfs(postorder[:i + 1])
        right = dfs(postorder[i + 1 : m])
        return left and right and postorder[i] > root

    return dfs(postorder[:-1])
```

### 21. 剑指 Offer 34. 二叉树中和为某一值的路径

**题目：** 找到二叉树中和为某一值的路径。

**示例：**
```python
from collections import defaultdict

def pathSum(self, root: Optional[TreeNode], target: int) -> List[List[int]]:
    def dfs(root, path, path_sum):
        if root:
            path.append(root.val)
            path_sum += root.val
            if root.val == target and not root.left and not root.right:
                ans.append(path.copy())
            dfs(root.left, path, path_sum)
            dfs(root.right, path, path_sum)
            path.pop()

    ans = []
    dfs(root, [], 0)
    return ans
```

### 22. 剑指 Offer 35. 复杂链表的复制

**题目：** 复制一个复杂链表，每个节点都有随机指针。

**示例：**
```python
class Node:
    def __init__(self, val: int, next: 'Node' = None, random: 'Node' = None):
        self.val = val
        self.next = next
        self.random = random

def copyRandomList(head: 'Optional[Node]') -> 'Optional[Node]':
    if not head:
        return None
    nodes = {None: Node(0)}
    current = head
    while current:
        node = Node(current.val)
        nodes[current] = node
        current = current.next
    current = head
    while current:
        node = nodes[current]
        node.next = nodes.get(current.next)
        node.random = nodes.get(current.random)
        current = current.next
    return nodes[head]
```

### 23. 剑指 Offer 36. 二叉搜索树与双向链表

**题目：** 将一棵二叉搜索树转换成一个排序的双向链表。

**示例：**
```python
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def treeToDoublyList(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return None
        prev = None
        head = None

        def dfs(root):
            nonlocal prev, head
            if root:
                dfs(root.left)
                if prev:
                    prev.right = root
                    root.left = prev
                else:
                    head = root
                prev = root
                dfs(root.right)

        dfs(root)
        head.left = prev
        prev.right = head
        return head
```

### 24. 剑指 Offer 37. 序列化二叉树

**题目：** 实现二叉树的序列化和反序列化。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:
    def serialize(self, root: TreeNode) -> str:
        def dfs(root):
            if not root:
                return 'None,'
            return f'{root.val},' + dfs(root.left) + dfs(root.right)

        return dfs(root)

    def deserialize(self, data: str) -> TreeNode:
        def dfs():
            val = next(iter)
            if val == 'None':
                return None
            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node

        iter = iter(data.split(','))
        return dfs()
```

### 25. 剑指 Offer 38. 字符串的排列

**题目：** 求出字符串中所有排列组合。

**示例：**
```python
from itertools import permutations

def permutation(self, s: str) -> List[str]:
    return [''.join(p) for p in permutations(s)]
```

### 26. 剑指 Offer 39. 数组中出现次数超过一半的数字

**题目：** 找出数组中超过一半次数出现的数字。

**示例：**
```python
def majorityElement(self, nums: List[int]) -> int:
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate
```

### 27. 剑指 Offer 40. 最小的k个数

**题目：** 从未排序的数组中找到最小的 k 个数。

**示例：**
```python
import heapq

def getLeastNumbers(self, arr: List[int], k: int) -> List[int]:
    return heapq.nsmallest(k, arr)
```

### 28. 剑指 Offer 41. 数据流中的中位数

**题目：** 实现一个数据流的中位数统计。

**示例：**
```python
from sortedcontainers import SortedList

class MedianFinder:
    def __init__(self):
        self.s = SortedList()

    def addNum(self, num: int) -> None:
        self.s.add(num)

    def findMedian(self) -> float:
        if len(self.s) % 2 == 1:
            return float(self.s[len(self.s) // 2])
        else:
            return (self.s[len(self.s) // 2 - 1] + self.s[len(self.s) // 2]) / 2
```

### 29. 剑指 Offer 42. 连续子数组的和为正数

**题目：** 找到连续子数组中和为正数的最大长度。

**示例：**
```python
def findMaxSubArray(nums: List[int]) -> int:
    ans = cur_sum = 0
    for num in nums:
        cur_sum += num
        if cur_sum > ans:
            ans = cur_sum
        if cur_sum < 0:
            cur_sum = 0
    return ans
```

### 30. 剑指 Offer 43. 1 的个数

**题目：** 计算数组中 1 的个数。

**示例：**
```python
def findNumberOf1s(self, num: int) -> int:
    if num < 0:
        num = -num
    res = 0
    while num:
        res += num % 2
        num = num >> 1
    return res
```

### 31. 剑指 Offer 44. 数字序列中某一位的数字

**题目：** 求出一个数字序列中某一位的数字。

**示例：**
```python
def findNthDigit(self, n: int) -> int:
    for i, base in enumerate([10, 100, 1000]):
        if n < base * (i + 1):
            digits = base // 10
            start = 10 ** (i + 1)
            num = (n - 1) // digits + start
            return int(str(num)[(n - 1) % digits])
```

### 32. 剑指 Offer 45. 把数组排成最小的数

**题目：** 把数组排成最小的数。

**示例：**
```python
from functools import cmp_to_key

def minNumber(nums: List[str]) -> str:
    def cmp(a, b):
        return (int(b + a) - int(a + b))

    return ''.join(sorted(nums, key=cmp_to_key(cmp)))
```

### 33. 剑指 Offer 46. 把数字翻译成字符串

**题目：** 把数字翻译成字符串。

**示例：**
```python
def translateNum(self, num: int) -> int:
    a, b, ans = 0, 1, 1
    while num > 0:
        a, b = b, a + (num % 10) * b
        num //= 10
        ans *= b
    return ans
```

### 34. 剑指 Offer 47. 礼物的最大价值

**题目：** 计算到达终点的最大价值。

**示例：**
```python
def maxValue(grid: List[List[int]]) -> int:
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j - 1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    return grid[-1][-1]
```

### 35. 剑指 Offer 48. 最长序列

**题目：** 求最长公共子序列。

**示例：**
```python
def longestSubsequenceRepeated Twice(nums: List[int]) -> int:
    cnt = Counter(nums)
    ans = 0
    for k, v in cnt.items():
        if v >= 2:
            ans = max(ans, 2 * (v // 2 + 1) + (v % 2))
        else:
            ans = max(ans, v + 1)
    return ans
```

### 36. 剑指 Offer 49. 最少交换次数

**题目：** 最少交换次数使数组元素有序。

**示例：**
```python
from heapq import nlargest

def minimum交换次数(self, nums: List[int]) -> int:
    freq = Counter(nums)
    return sum(v // 2 for v in nlargest(3, freq.values(), key=lambda x: x // 2))
```

### 37. 剑指 Offer 50. 第一个只出现一次的字符

**题目：** 找到第一个只出现一次的字符。

**示例：**
```python
def firstUniqCharacter(self, s: str) -> str:
    cnt = Counter(s)
    for c in s:
        if cnt[c] == 1:
            return c
    return ''
```

### 38. 剑指 Offer 51. 数组中的逆序对

**题目：** 计算数组中的逆序对。

**示例：**
```python
def reversePairs(self, nums: List[int]) -> int:
    def mergeSort(l, r):
        if l >= r:
            return 0
        mid = (l + r) >> 1
        left = mergeSort(l, mid)
        right = mergeSort(mid + 1, r)
        p = [0] * (r - l + 1)
        i, j = l, mid + 1
        cnt = 0
        k = 0
        while i <= mid and j <= r:
            if nums[i] <= nums[j]:
                p[k++] = nums[i]
                i += 1
            else:
                p[k++] = nums[j]
                cnt += mid - i + 1
                j += 1
        while i <= mid:
            p[k++] = nums[i]
            i += 1
        while j <= r:
            p[k++] = nums[j]
            j += 1
        for i in range(k):
            nums[l + i] = p[i]
        return left + right + cnt

    return mergeSort(0, len(nums) - 1)
```

### 39. 剑指 Offer 52. 两个链表的第一个公共节点

**题目：** 找到两个链表的第一个公共节点。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        pa, pb = headA, headB
        while pa != pb:
            pa = pa.next if pa else headB
            pb = pb.next if pb else headA
        return pa
```

### 40. 剑指 Offer 53. 在排序数组中查找元素的第一个和最后一个位置

**题目：** 在排序数组中查找元素的第一个和最后一个位置。

**示例：**
```python
def searchRange(self, nums: List[int], target: int) -> List[int]:
    def find_left(nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r) >> 1
            if nums[mid] >= target:
                r = mid
            else:
                l = mid + 1
        return l

    def find_right(nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r + 1) >> 1
            if nums[mid] > target:
                r = mid - 1
            else:
                l = mid
        return l

    return [find_left(nums, target), find_right(nums, target)]
```

### 41. 剑指 Offer 54. 二叉搜索树的第 k 大节点

**题目：** 找到二叉搜索树中的第 k 大节点。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargest(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(root):
            nonlocal k, ans
            if root:
                dfs(root.right)
                k -= 1
                if k == 0:
                    ans = root.val
                dfs(root.left)

        ans = 0
        dfs(root)
        return ans
```

### 42. 剑指 Offer 55 - I. 二叉树的深度

**题目：** 计算二叉树的深度。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

### 43. 剑指 Offer 55 - II. 平衡二叉树

**题目：** 判断二叉树是否是平衡二叉树。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def check(root):
            if not root:
                return 0
            left = check(root.left)
            right = check(root.right)
            if abs(left - right) > 1:
                return -1
            return max(left, right) + 1

        return check(root) >= 0
```

### 44. 剑指 Offer 56. 数组中数字出现的次数 II

**题目：** 查找出现次数为奇数的数字。

**示例：**
```python
def singleNumber(self, nums: List[int]) -> int:
    seen = [0] * 32
    for num in nums:
        for i in range(32):
            seen[i] ^= (num >> i) & 1
    return seen.index(1) << 1
```

### 45. 剑指 Offer 57. 和为两数目标的数字

**题目：** 找到两个数，它们的和等于目标值。

**示例：**
```python
def twoSum(self, nums: List[int], target: int) -> List[int]:
    ans = []
    cnt = Counter(nums)
    for num in nums:
        x = target - num
        if x in cnt and cnt[x] > 0:
            cnt[x] -= 1
            ans.append(num)
            ans.append(x)
            break
    return ans
```

### 46. 剑指 Offer 58. 读数字器

**题目：** 将字符串转换为数字。

**示例：**
```python
def strToInt(self, s: str) -> int:
    if not s:
        return 0
    sign = 1
    num = 0
    i = 0
    if s[0] == '+':
        i += 1
    elif s[0] == '-':
        sign = -1
        i += 1
    while i < len(s) and s[i].isdigit():
        num = num * 10 + int(s[i])
        i += 1
    if sign < 0:
        num = -num
    if num > 2 ** 31 - 1:
        return 2 ** 31 - 1
    if num < -2 ** 31:
        return -2 ** 31
    return num
```

### 47. 剑指 Offer 59. 最大数字

**题目：** 将数组中的数字拼接成最大的数。

**示例：**
```python
from functools import cmp_to_key

def maxNumber(self, nums1: List[int], nums2: List[int]) -> str:
    def merge(a, b):
        if a + b > b + a:
            return a
        return b

    def cmp(a, b):
        if a == b:
            return 0
        return -1 if a < b else 1

    def next_permutation(arr):
        i = len(arr) - 1
        while i > 0 and arr[i - 1] >= arr[i]:
            i -= 1
        if i == 0:
            return False
        j = len(arr) - 1
        while arr[j] <= arr[i - 1]:
            j -= 1
        arr[i - 1], arr[j] = arr[j], arr[i - 1]
        arr[i:] = arr[len(arr) - 1 : i - 1 : -1]
        return True

    ans = []
    for i in range(max(len(nums1), len(nums2)) + 1):
        x = nums1[:min(len(nums1), i)] + nums2[:min(len(nums2), i)]
        if not ans or cmp_to_key(merge)(ans, x) == 1:
            ans = x
        if not next_permutation(x):
            break
    return ''.join(ans)
```

### 48. 剑指 Offer 60. n 个骰子的点数

**题目：** 计算投掷 n 个均匀点数的骰子，各种可能点数的概率。

**示例：**
```python
def dicesProbability(n):
    mod = 10**9 + 7
    f = [[0] * 7 for _ in range(n + 1)]
    for i in range(1, 7):
        f[1][i] = 1
    for i in range(2, n + 1):
        for j in range(1, 7):
            for k in range(1, 7):
                f[i][j] = (f[i][j] + f[i - 1][k]) % mod
    ans = [0] * 7
    for i in range(1, 7):
        ans[i] = sum(f[n][i]) % mod
    return ans
```

### 49. 剑指 Offer 61. 和为 K 的子数组

**题目：** 计算数组中和为给定值的子数组个数。

**示例：**
```python
from collections import Counter

def subarraySum(self, nums: List[int], k: int) -> int:
    ans = cnt = 0
    cnt[k] = 1
    for num in nums:
        cnt[0] += cnt[k]
        cnt[k] = cnt[k - num]
    return ans
```

### 50. 剑指 Offer 62. 矩阵中的路径

**题目：** 判断矩阵中是否存在从起点到终点的路径。

**示例：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if not 0 <= i < m and not 0 <= j < n:
            return False
        if board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True
        board[i][j] = '#'
        a = dfs(i + 1, j, k + 1)
        b = dfs(i - 1, j, k + 1)
        c = dfs(i, j + 1, k + 1)
        d = dfs(i, j - 1, k + 1)
        return a or b or c or d

    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```

### 51. 剑指 Offer 63. 股票的最大利润

**题目：** 计算股票的最大利润。

**示例：**
```python
def maxProfit(prices):
    ans = 0
    for i in range(1, len(prices)):
        ans += max(0, prices[i] - prices[i - 1])
    return ans
```

### 52. 剑指 Offer 64. 最小的K个数

**题目：** 从未排序的数组中找出最小的 K 个数。

**示例：**
```python
import heapq

def getLeastNumbers(arr, k):
    return heapq.nsmallest(k, arr)
```

### 53. 剑指 Offer 65. 等差数列

**题目：** 找出等差数列中缺失的数字。

**示例：**
```python
def missingNumber(nums):
    n = len(nums)
    return n * (n + 1) // 2 - sum(nums)
```

### 54. 剑指 Offer 66. 构建乘积数组

**题目：** 构建一个数组，其中每个元素都是原数组中除了其索引位置元素之外的所有元素的乘积。

**示例：**
```python
def constructArray(n):
    if n == 1:
        return [1]
    arr = [0] * n
    for i in range(n):
        if i == 0:
            arr[i + 1] = arr[i + 2]
        elif i == n - 1:
            arr[i - 1] = arr[i - 2]
        else:
            arr[i - 1], arr[i + 1] = arr[i + 1], arr[i - 1]
    return arr
```

### 55. 剑指 Offer 67. 相对名次

**题目：** 给定一组学生的成绩，返回每个学生的相对名次。

**示例：**
```python
def findRelativeRanks(scores):
    ranks = [0] * len(scores)
    sorted_scores = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    for i, (score, index) in enumerate(sorted_scores, 1):
        ranks[index] = "Gold Medal" if i == 1 else str(i)
    return ranks
```

### 56. 剑指 Offer 68. 颜色分类

**题目：** 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序。

**示例：**
```python
def sortColors(nums):
    zero, one, two = 0, 0, len(nums)
    while one < two:
        if nums[one] < 1:
            nums[zero], nums[one] = nums[one], nums[zero]
            zero += 1
            one += 1
        elif nums[one] > 1:
            nums[two], nums[one] = nums[one], nums[two]
            two -= 1
        else:
            one += 1
```

### 57. 剑指 Offer 69. x 的平方根

**题目：** 实现 int sqrt(int x) 函数。

**示例：**
```python
def mySqrt(x):
    l, r = 0, x
    while l <= r:
        mid = (l + r) // 2
        if mid * mid > x:
            r = mid - 1
        else:
            l = mid + 1
    return r
```

### 58. 剑指 Offer 70. 螺旋矩阵

**题目：** 给定一个包含 m x n 个元素的矩阵（m 行、n 列），按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例：**
```python
def spiralOrder(matrix):
    ans = []
    while matrix:
        ans.extend(matrix.pop(0))
        if matrix and matrix[0]:
            for row in matrix:
                ans.append(row.pop())
        if matrix:
            ans.extend(matrix.pop()[::-1])
        if matrix and matrix[0]:
            for row in matrix[::-1]:
                ans.append(row.pop(0))
    return ans
```

### 59. 剑指 Offer 71. 反转链表

**题目：** 反转单链表。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev, curr = None, head
        while curr:
            next = curr.next
            curr.next = prev
            prev = curr
            curr = next
        return prev
```

### 60. 剑指 Offer 72. 编辑距离

**题目：** 给定两个单词 word1 和 word2，计算将 word1 转换成 word2 所使用的最少操作次数。

**示例：**
```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])
    return dp[m][n]
```

### 61. 剑指 Offer 73. 矩阵中的路径

**题目：** 给定一个包含 ' '，'.' 和 '*' 的二维字符网格（其中 ' '代表空地，'.'代表地面，'*'代表障碍物），设计一个算法，检查是否存在一条从左上角到右下角的路径，路径中只包含地面。

**示例：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if not (0 <= i < m and 0 <= j < n):
            return False
        if board[i][j] != word[k]:
            return False
        if k == len(word) - 1:
            return True
        board[i][j] = '#'
        a = dfs(i + 1, j, k + 1)
        b = dfs(i - 1, j, k + 1)
        c = dfs(i, j + 1, k + 1)
        d = dfs(i, j - 1, k + 1)
        return a or b or c or d

    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```

### 62. 剑指 Offer 74. 搜索二维矩阵

**题目：** 给定一个 m x n 的矩阵 matrix，如果在矩阵中找到一条从左上角到右下角的对角线，返回 true，否则返回 false。

**示例：**
```python
def searchMatrix(matrix, target):
    m, n = len(matrix), len(matrix[0])
    row, col = 0, n - 1
    while row < m and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False
```

### 63. 剑指 Offer 75. 零矩阵

**题目：** 给定一个 m x n 的矩阵 matrix，如果矩阵中存在一个 N x N 的子矩阵，其中每一个元素都为 0，则返回 true，否则返回 false。

**示例：**
```python
def zeroMatrix(matrix):
    m, n = len(matrix), len(matrix[0])
    zero_set = set()
    for i in range(m):
        for j in range(n):
            if matrix[i][j] == 0:
                zero_set.add(i)
                zero_set.add(j)
    for i in range(m):
        for j in range(n):
            if i in zero_set or j in zero_set:
                matrix[i][j] = 0
    return matrix
```

### 64. 剑指 Offer 76. 数字在排序数组中出现的次数

**题目：** 给定一个排序数组和一个目标值，返回数组中目标值出现的次数。

**示例：**
```python
def search(nums, target):
    def find_left(nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r) >> 1
            if nums[mid] >= target:
                r = mid
            else:
                l = mid + 1
        return l

    def find_right(nums, target):
        l, r = 0, len(nums)
        while l < r:
            mid = (l + r + 1) >> 1
            if nums[mid] > target:
                r = mid - 1
            else:
                l = mid
        return l

    return find_right(nums, target) - find_left(nums, target)
```

### 65. 剑指 Offer 77. 组合

**题目：** 给定两个数字 n 和 k，返回所有可能的 k 个数字组合。

**示例：**
```python
def combine(n, k):
    def dfs(nums, start, path):
        if len(path) == k:
            ans.append(path)
            return
        for i in range(start, n + 1):
            dfs(nums, i, path + [i])

    ans = []
    dfs(n, 1, [])
    return ans
```

### 66. 剑指 Offer 78. 子集

**题目：** 给定一个整数 n，返回所有可能的子集。

**示例：**
```python
def subsets(nums):
    ans = [[]]
    for num in nums:
        ans += [p + [num] for p in ans]
    return ans
```

### 67. 剑指 Offer 79. 单调数列

**题目：** 给定一个整数数组，判断是否存在长度为 3 的递增子序列。

**示例：**
```python
def increasingTriplet(nums):
    first = second = float('inf')
    for num in nums:
        if num <= first:
            first = num
        elif num <= second:
            second = num
        else:
            return True
    return False
```

### 68. 剑指 Offer 80. 删除有序数组中的重复项 II

**题目：** 给定一个排序数组，删除数组中的重复项，使每个元素出现的次数不超过两次。

**示例：**
```python
def removeDuplicates(nums):
    if not nums:
        return 0
    k = 1
    for num in nums[1:]:
        if num != nums[k - 1]:
            nums[k] = num
            k += 1
    return k
```

### 69. 剑指 Offer 81. 缀点成线

**题目：** 给定一个有 m 个元素和 n 个查询的序列，求是否存在一条线段，其长度大于等于查询的最小值。

**示例：**
```python
def checkStraightLine(points):
    x_diff, y_diff = points[1][0] - points[0][0], points[1][1] - points[0][1]
    if x_diff == 0:
        x_diff = 1
    if y_diff == 0:
        y_diff = 1
    for i in range(2, len(points)):
        if (points[i][0] - points[0][0]) * y_diff != (points[i][1] - points[0][1]) * x_diff:
            return False
    return True
```

### 70. 剑指 Offer 82. 删除排序数组中的重复项 III

**题目：** 给定一个排序数组，删除数组中的重复项，使每个元素出现的次数不超过三次。

**示例：**
```python
def removeDuplicates(nums):
    k = 3
    i = 0
    for num in nums:
        if i >= 2 and num == nums[i - 2] == nums[i - 1]:
            continue
        nums[i] = num
        i += 1
    return i
```

### 71. 剑指 Offer 83. 搜索旋转排序数组

**题目：** 给定一个旋转排序数组，找出旋转数组中的最小元素。

**示例：**
```python
def search(nums):
    l, r = 0, len(nums) - 1
    while l < r:
        mid = (l + r) >> 1
        if nums[mid] > nums[r]:
            l = mid + 1
        else:
            r = mid
    return nums[l]
```

### 72. 剑指 Offer 84. 柱状图中最大的矩形

**题目：** 给定 n 个非负整数，每组三个数字构成一个矩形，求这些矩形中最大的面积。

**示例：**
```python
def largestRectangleArea(heights):
    heights = [0] + heights + [0]
    stk = []
    ans = 0
    for i, h in enumerate(heights):
        while stk and heights[stk[-1]] >= h:
            t = stk.pop()
            ans = max(ans, (i - stk[-1] - 1) * heights[t])
        stk.append(i)
    return ans
```

### 73. 剑指 Offer 85. 最大树值

**题目：** 给定一棵二叉树的根节点 root，求这棵树的节点中最大的树值。

**示例：**
```python
def dfs(root):
    nonlocal ans
    if root:
        ans = max(ans, root.val)
        dfs(root.left)
        dfs(root.right)

def maxTree(root):
    ans = float('-inf')
    dfs(root)
    return ans
```

### 74. 剑指 Offer 86. 链表中倒数第 k 个节点

**题目：** 给定一个链表，返回链表的倒数第 k 个节点。

**示例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head, k):
    fast = head
    for _ in range(k):
        if not fast:
            return None
        fast = fast.next
    slow = head
    while fast:
        fast = fast.next
        slow = slow.next
    return slow
```

### 75. 剑指 Offer 87. 两个链表的第一个公共节点

**题目：** 给定两个链表，找到它们的第一个公共节点。

**示例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getIntersectionNode(headA, headB):
    pa, pb = headA, headB
    while pa != pb:
        pa = pa.next if pa else headB
        pb = pb.next if pb else headA
    return pa
```

### 76. 剑指 Offer 88. 数组翻转

**题目：** 给定一个数组，将其反转。

**示例：**
```python
def reverseArray(nums):
    n = len(nums)
    for i in range(n // 2):
        nums[i], nums[n - i - 1] = nums[n - i - 1], nums[i]
    return nums
```

### 77. 剑指 Offer 89. 旋转数组的最小数字

**题目：** 给定一个旋转排序的数组，找出其最小元素。

**示例：**
```python
def findMin(nums):
    l, r = 0, len(nums) - 1
    while l < r:
        mid = (l + r) >> 1
        if nums[mid] > nums[r]:
            l = mid + 1
        else:
            r = mid
    return nums[l]
```

### 78. 剑指 Offer 90. 螺旋矩阵 II

**题目：** 给定一个正整数 n，生成一个包含从 1 到 n2 所有元素，按顺时针顺序填充的 n×n 螺旋矩阵。

**示例：**
```python
def generateMatrix(n):
    ans = [[0] * n for _ in range(n)]
    a, b, c, d = 0, n - 1, 0, n - 1
    x = 1
    while a <= b and c <= d:
        for i in range(a, b + 1):
            ans[a][i] = x
            x += 1
        a += 1
        for i in range(c, d + 1):
            ans[i][b] = x
            x += 1
        b -= 1
        for i in range(b, a - 1, -1):
            ans[d][i] = x
            x += 1
        d -= 1
        for i in range(d, c - 1, -1):
            ans[i][a] = x
            x += 1
        c += 1
    return ans
```

### 79. 剑指 Offer 91. 翻转数组合并

**题目：** 给定两个已排序的数组合并成一个已排序的数组。

**示例：**
```python
def merge(nums1, m, nums2, n):
    i, j = m - 1, n - 1
    t = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[t] = nums1[i]
            i -= 1
        else:
            nums1[t] = nums2[j]
            j -= 1
        t -= 1
    while i >= 0:
        nums1[t] = nums1[i]
        i -= 1
        t -= 1
    while j >= 0:
        nums1[t] = nums2[j]
        j -= 1
        t -= 1
```

### 80. 剑指 Offer 92. 等倍数的最小数组长度

**题目：** 给定一个数组 arr，找到最小数组长度 L，使得 arr 中所有元素都乘以同一个数后，至少有一个子数组长度为 L，并且子数组内所有元素的乘积大于等于 2 的 n 次方。

**示例：**
```python
from bisect import bisect_left

def minArrayLen(arr, target, n):
    l, r = 0, len(arr)
    while l < r:
        mid = (l + r) >> 1
        if arr[mid] * (mid - l + 1) >= target * (2 ** n):
            r = mid
        else:
            l = mid + 1
    left = bisect_left(arr, target * (2 ** n))
    ans = l + n - 1
    for i in range(left, len(arr)):
        if arr[i] * (i - left + 1) >= target * (2 ** n):
            ans = min(ans, i - left + 1)
            break
    return ans
```

### 81. 剑指 Offer 93. 找出数组中的重复数

**题目：** 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），找出数组中的重复数。

**示例：**
```python
def findRepeatNumber(nums):
    s = set()
    for num in nums:
        if num in s:
            return num
        s.add(num)
    return -1
```

### 82. 剑指 Offer 94. 删除链表的节点

**题目：** 给定一个单链表的头节点 head 和一个整数 val，删除链表中值为 val 的节点。

**示例：**
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, head: 'Optional[ListNode]', val: int) -> 'Optional[ListNode]':
        dummy = ListNode(0, head)
        prev, cur = dummy, head
        while cur:
            if cur.val == val:
                prev.next = cur.next
                return dummy.next
            prev, cur = prev, cur.next
        return dummy.next
```

### 83. 剑指 Offer 95. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，找出在 text1 中是 text2 子序列的最长字符串。

**示例：**
```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

### 84. 剑指 Offer 96. 重复的数字

**题目：** 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内，找出数组中任意一个重复的数字。

**示例：**
```python
def findRepeatNumber(nums):
    n = len(nums)
    for i, num in enumerate(nums):
        while num != i:
            if nums[i] == nums[num]:
                return nums[i]
            nums[num], nums[i] = nums[i], nums[num]
    return -1
```

### 85. 剑指 Offer 97. 旋转数组的最小数字

**题目：** 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增的排序数组的一个旋转，输出旋转数组的最小元素。

**示例：**
```python
def findMin(nums):
    l, r = 0, len(nums) - 1
    while l < r:
        mid = (l + r) >> 1
        if nums[mid] > nums[r]:
            l = mid + 1
        else:
            r = mid
    return nums[l]
```

### 86. 剑指 Offer 98. 颜色分类

**题目：** 给定一个包含红色、白色和蓝色、共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

**示例：**
```python
def sortColors(nums):
    zero, one, two = 0, 0, len(nums)
    while one < two:
        if nums[one] < 1:
            nums[zero], nums[one] = nums[one], nums[zero]
            zero += 1
            one += 1
        elif nums[one] > 1:
            nums[two], nums[one] = nums[one], nums[two]
            two -= 1
        else:
            one += 1
```

### 87. 剑指 Offer 99. 重建二叉树

**题目：** 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

**示例：**
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        val = preorder[0]
        root = TreeNode(val)
        i = inorder.index(val)
        root.left = self.buildTree(preorder[1:i + 1], inorder[:i])
        root.right = self.buildTree(preorder[i + 1:], inorder[i + 1:])
        return root
```

### 88. 剑指 Offer 100. 合并两个排序的数组

**题目：** 给定两个排序后的数组 nums1 和 nums2，合并两个数组使得 nums1 从起始索引 k 到末尾，nums2 从起始索引 m 到末尾。

**示例：**
```python
def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    i, j = m - 1, n - 1
    t = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[t] = nums1[i]
            i -= 1
        else:
            nums1[t] = nums2[j]
            j -= 1
        t -= 1
    while i >= 0:
        nums1[t] = nums1[i]
        i -= 1
        t -= 1
    while j >= 0:
        nums1[t] = nums2[j]
        j -= 1
        t -= 1
```

