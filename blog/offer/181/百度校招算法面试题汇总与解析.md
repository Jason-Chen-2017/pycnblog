                 

### 2025百度校招算法面试题汇总与解析

百度作为国内一线互联网大厂，其校招算法面试题内容广泛且难度较大，涵盖了数据结构、算法、系统设计等多个方面。以下是针对2025百度校招算法面试题的汇总与解析，帮助大家更好地准备面试。

### 1. 数据结构与算法

**题目1：实现一个堆排序算法。**

**答案：** 

堆排序是一种选择排序算法，它利用堆这种数据结构所特有的性质来进行排序。以下是堆排序的 Python 实现代码：

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    for i in range(n, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# 测试代码
arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
print("Sorted array is:", arr)
```

**解析：** 该代码首先定义了一个 `heapify` 函数，用于将一个子树转换成最大堆。接着，定义了一个 `heapSort` 函数，首先将数组转换成最大堆，然后依次将堆顶元素与堆的最后一个元素交换，再对剩余的堆进行堆化，直到整个数组排序完成。

**题目2：实现一个二叉搜索树。**

**答案：**

```python
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, key):
    if root is None:
        return Node(key)
  
    if key < root.val:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
  
    return root

def inorder(root):
    if root:
        inorder(root.left)
        print(root.val, end=" ")
        inorder(root.right)

# 测试代码
root = None
keys = [50, 30, 20, 40, 70, 60, 80]

for key in keys:
    root = insert(root, key)

inorder(root)
```

**解析：** 该代码定义了一个 `Node` 类，用于表示二叉搜索树的一个节点。`insert` 函数用于插入新的节点，`inorder` 函数用于遍历二叉搜索树，并按照升序打印节点值。

### 2. 算法与系统设计

**题目3：给定一个未排序的数组，找出其中最小的 k 个数。**

**答案：**

```python
import heapq

def findSmallestK(nums, k):
    return heapq.nsmallest(k, nums)

# 测试代码
nums = [3, 2, 1, 5, 6, 4, 7]
k = 3
print(findSmallestK(nums, k))
```

**解析：** 使用 Python 的 `heapq` 模块，`nsmallest` 函数可以找出数组中最小的 k 个数。

**题目4：设计一个支持异步调用的并发队列。**

**答案：**

```python
import asyncio

class AsyncQueue:
    def __init__(self):
        self.queue = asyncio.Queue()

    async def put(self, item):
        await self.queue.put(item)

    async def get(self):
        return await self.queue.get()

# 测试代码
async def main():
    queue = AsyncQueue()

    async def producer():
        for i in range(5):
            await queue.put(i)
            print(f"Produced {i}")

    async def consumer():
        while True:
            item = await queue.get()
            print(f"Consumed {item}")

    await asyncio.wait([producer(), consumer()])

asyncio.run(main())
```

**解析：** 使用 Python 的 `asyncio` 模块，创建了一个支持异步 put 和 get 操作的队列。

### 3. 编码挑战

**题目5：实现一个简单的 HTTP 客户端。**

**答案：**

```python
import socket

def send_request(url, method="GET"):
    host = url.split("//")[1]

    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, 80))

    request = f"{method} {url} HTTP/1.1\r\nHost: {host}\r\n\r\n"
    client_socket.sendall(request.encode())

    response = client_socket.recv(4096)
    client_socket.close()

    print(response.decode())

# 测试代码
send_request("http://example.com")
```

**解析：** 该代码使用 Python 的 `socket` 模块，发送了一个简单的 HTTP GET 请求，并打印了响应内容。

### 4. 谈判

**题目6：如何在两个城市之间分配物资，使得两个城市满意度最大？**

**答案：**

这是一个经典的“01 背包问题”。可以使用动态规划来求解。以下是 Python 代码示例：

```python
def find_max_satisfaction(capacity1, capacity2, jobs):
    dp = [[0] * (capacity2 + 1) for _ in range(len(jobs) + 1)]

    for i in range(1, len(jobs) + 1):
        for j in range(1, capacity2 + 1):
            if jobs[i - 1] <= j:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - jobs[i - 1]] + jobs[i - 1])
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[-1][-1]

# 测试代码
capacity1 = 50
capacity2 = 70
jobs = [10, 20, 30, 40]
print(find_max_satisfaction(capacity1, capacity2, jobs))
```

**解析：** 该代码定义了一个 `find_max_satisfaction` 函数，使用动态规划求解了在两个城市的容量限制下，分配物资使得两个城市满意度最大的问题。

以上是针对2025百度校招算法面试题的汇总与解析，希望对大家的面试准备有所帮助。注意，这些题目只是冰山一角，实际面试中可能会遇到更复杂的问题，所以还需大家全面地学习和复习相关知识点。祝大家面试成功！

