                 

### 百度2025年校招算法面试题库及答案

在本篇博客中，我们将探讨百度2025年校招中的算法面试题库及答案，涵盖了数据结构、算法、系统设计等多个领域。每一道题目都将提供详尽的答案解析和源代码实例。

#### 1. 扩展树遍历算法

**题目：** 请实现一个扩展的树遍历算法，除了支持前序遍历、中序遍历和后序遍历外，还支持层序遍历。

**答案：**

**前序遍历：**

```go
func preorder(root *TreeNode) []int {
    var result []int
    if root == nil {
        return result
    }
    stack := []*TreeNode{root}
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, node.Val)
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
    }
    return result
}
```

**中序遍历：**

```go
func inorder(root *TreeNode) []int {
    var result []int
    if root == nil {
        return result
    }
    stack := []*TreeNode{}
    for root != nil || len(stack) > 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, node.Val)
        root = node.Right
    }
    return result
}
```

**后序遍历：**

```go
func postorder(root *TreeNode) []int {
    var result []int
    if root == nil {
        return result
    }
    stack := []*TreeNode{}
    prev := nil
    for root != nil || len(stack) > 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        node := stack[len(stack)-1]
        if node.Right == nil || node.Right == prev {
            stack = stack[:len(stack)-1]
            result = append(result, node.Val)
            prev = node
        } else {
            stack = append(stack, node.Right)
            root = node.Right
        }
    }
    return result
}
```

**层序遍历：**

```go
func levelOrder(root *TreeNode) [][]int {
    var result [][]int
    if root == nil {
        return result
    }
    queue := []*TreeNode{root}
    for len(queue) > 0 {
        level := []int{}
        nextQueue := []*TreeNode{}
        for _, node := range queue {
            level = append(level, node.Val)
            if node.Left != nil {
                nextQueue = append(nextQueue, node.Left)
            }
            if node.Right != nil {
                nextQueue = append(nextQueue, node.Right)
            }
        }
        result = append(result, level)
        queue = nextQueue
    }
    return result
}
```

#### 2. 单调栈问题

**题目：** 给定一个整数数组 `nums`，返回每个元素的右下标。如果 `i` 的右下标不存在，将该值设置为 `-1`。

**答案：**

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    m := len(nums1)
    n := len(nums2)
    var result []int
    stack := []int{}
    for i := n - 1; i >= 0; i-- {
        for len(stack) > 0 && stack[len(stack)-1] <= nums2[i] {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            result = append(result, -1)
        } else {
            result = append(result, stack[len(stack)-1])
        }
        stack = append(stack, nums2[i])
    }
    return reverse(result)
}

func reverse(arr []int) []int {
    var result []int
    for i := len(arr) - 1; i >= 0; i-- {
        result = append(result, arr[i])
    }
    return result
}
```

#### 3. 合并区间

**题目：** 给定一个区间列表，请合并所有重叠的区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 4. 最小路径和

**题目：** 给定一个包含非负数的 `m x n` 网格，找到路径从左上角到右下角且路径上的数字总和最小时的路径。

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 5. 最长回文子串

**题目：** 给定一个字符串 `s`，找到其最长的回文子串。

**答案：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        len1, len2 := expandAroundCenter(s, i, i), expandAroundCenter(s, i, i+1)
        len := max(len1, len2)
        if len > maxLen {
            maxLen = len
            start = i - (len - 1) / 2
        }
    }
    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    n := len(s)
    for left >= 0 && right < n && s[left] == s[right] {
        left--
        right++
    }
    return right - left - 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 6. 二进制表示中质数数量

**题目：** 给定一个正整数 `n`，找出其二进制表示中质数数字的数量。

**答案：**

```go
func countPrimeSetBits(num int) int {
    primes := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29}
    for i := 0; i < 10; i++ {
        if num&(1<<i) != 0 {
            for j := 0; j < 10; j++ {
                if primes[j] == i+2 {
                    return j + 1
                }
            }
        }
    }
    return 0
}
```

#### 7. 数据流中的中位数

**题目：** 设计一个数据结构，实现一个能在数据流中获取中位数的算法。

**答案：**

```go
type MedianFinder struct {
    nums1, nums2 []int
}

func Constructor() MedianFinder {
    return MedianFinder{
        nums1: []int{},
        nums2: []int{1<<31 - 1},
    }
}

func (this *MedianFinder) AddNum(num int) {
    if len(this.nums2) == len(this.nums1) {
        this.nums1 = append(this.nums1, num)
        sort.Ints(this.nums1)
        mid := len(this.nums1) / 2
        for i := mid; i >= 0; i-- {
            if this.nums1[i] <= this.nums2[0] {
                this.nums2 = append(this.nums2, this.nums1[i])
                this.nums2 = this.nums2[:len(this.nums2)-1]
                break
            }
        }
    } else {
        this.nums2 = append(this.nums2, num)
        sort.Ints(this.nums2)
        mid := len(this.nums2) / 2
        for i := mid; i >= 0; i-- {
            if this.nums2[i] >= this.nums1[0] {
                this.nums1 = append(this.nums1, this.nums2[i])
                this.nums1 = this.nums1[:len(this.nums1)-1]
                break
            }
        }
    }
}

func (this *MedianFinder) FindMedian() float64 {
    n := len(this.nums1) + len(this.nums2)
    if n%2 == 0 {
        return float64(this.nums1[0] + this.nums2[0]) / 2.0
    }
    if len(this.nums1) > len(this.nums2) {
        return float64(this.nums1[n/2])
    }
    return float64(this.nums2[n/2])
}
```

#### 8. 滑动窗口最大值

**题目：** 给定一个数组 `nums` 和一个整数 `k`，找到滑动窗口中的最大值。

**答案：**

```go
func maxSlidingWindow(nums []int, k int) []int {
    var result []int
    queue := []int{}
    for i := 0; i < len(nums); i++ {
        for len(queue) > 0 && queue[0] <= i-k {
            queue = queue[1:]
        }
        for len(queue) > 0 && nums[queue[len(queue)-1]] < nums[i] {
            queue = queue[:len(queue)-1]
        }
        queue = append(queue, i)
        if i >= k-1 {
            result = append(result, nums[queue[0]])
        }
    }
    return result
}
```

#### 9. 柱状图中最大的矩形

**题目：** 给定一个由若干 0 和 1 组成的矩阵，找到矩阵中的矩形区域，其填充的所有值为 1 的单元格数最多。

**答案：**

```go
func largestRectangleArea(heights []int) int {
    var result, curMax int
    stack := []int{}
    for i, h := range heights {
        for len(stack) > 0 && (h <= stack[len(stack)-1]) {
            curH := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            curW := i - int(stack[len(stack)-1])
            curMax = curMax * curH + curW * curH
        }
        stack = append(stack, i)
    }
    for len(stack) > 0 {
        curH := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        curW := len(heights) - int(stack[len(stack)-1])
        curMax = curMax * curH + curW * curH
    }
    return result
}
```

#### 10. 相同的树

**题目：** 给定两个二叉树，判断它们是否相同。

**答案：**

```go
func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil {
        return true
    }
    if p == nil || q == nil {
        return false
    }
    if p.Val != q.Val {
        return false
    }
    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}
```

#### 11. 翻转二叉树

**题目：** 翻转一棵二叉树。

**答案：**

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

#### 12. 有效的括号字符串

**题目：** 给定一个只包含 '('、')'、'{'、'}'、'['、']' 的字符串，判断字符串是否有效。

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, c := range s {
        if c == '(' || c == '{' || c == '[' {
            stack = append(stack, c)
        } else {
            if len(stack) == 0 {
                return false
            }
            top := stack[len(stack)-1]
            if (c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[') {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

#### 13. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return [][]int{}
    }
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] < intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })
    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 14. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 15. 合并有序数组

**题目：** 给你两个整数数组 `nums1` 和 `nums2` ，按升序合并它们，并在 `nums1` 的额外空间中填充 `nums2` 的所有元素。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    for i, j := m, 0; i < m+n && j < n; i++ {
        if nums1[i-m] < nums2[j] {
            nums1[i] = nums2[j]
            j++
        }
    }
    for j < n {
        nums1[i] = nums2[j]
        i++
        j++
    }
}
```

#### 16. 链表的中间结点

**题目：** 给你一个单链表的头部节点 `head` ，请你找出链表的中间结点，并返回该结点。如果有两个中间结点，则返回第二个中间结点。

**答案：**

```go
func middleNode(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
```

#### 17. 颠倒二叉树

**题目：** 翻转一棵二叉树。

**答案：**

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

#### 18. 二进制求和

**题目：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**答案：**

```go
func addBinary(a string, b string) string {
    var carry byte
    var ans []byte
    i, j := len(a)-1, len(b)-1
    for i >= 0 || j >= 0 || carry > 0 {
        sum := carry
        if i >= 0 {
            sum += int(a[i] - '0')
            i--
        }
        if j >= 0 {
            sum += int(b[j] - '0')
            j--
        }
        carry = sum / 2
        ans = append([]byte{byte(sum%2 + '0')}, ans...)
    }
    return string(ans)
}
```

#### 19. 岛屿的最大面积

**题目：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。每个岛屿都是四个方向（水平或垂直）相连的 1 形成的组合。

**答案：**

```go
func numIslands(grid [][]byte) int {
    var count int
    rows, cols := len(grid), len(grid[0])
    var dfs func(int, int)
    dfs = func(i, j int) {
        if i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] != '1' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    }
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if grid[i][j] == '1' {
                dfs(i, j)
                count++
            }
        }
    }
    return count
}
```

#### 20. 股票交易的最小代价

**题目：** 给定一个整数数组 `prices`，其中每个元素表示一天内的股票价格，返回可以获得的最低交易成本，其中交易包括买入和卖出股票。

**答案：**

```go
func minCost(prices []int) int {
    n := len(prices)
    dp := make([]int, n)
    for i := 0; i < n; i++ {
        if i == 0 {
            dp[i] = 0
        } else {
            dp[i] = math.MaxInt32
            for j := 0; j < i; j++ {
                if prices[i]-prices[j] > 0 {
                    dp[i] = min(dp[i], dp[j]+prices[i]-prices[j])
                }
            }
        }
    }
    return dp[n-1]
}
```

#### 21. 汉明距离

**题目：** 给定两个字符串 `s` 和 `t`，返回它们之间的汉明距离。汉明距离是指两个等长字符串之间对应位置上的字符不同的数量。

**答案：**

```go
func hammingDistance(x, y int) int {
    xor := x ^ y
    distance := 0
    for xor > 0 {
        distance += xor & 1
        xor >>= 1
    }
    return distance
}
```

#### 22. 环形链表

**题目：** 给定一个链表的头节点 `head` ，判断链表是否为环形。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

#### 23. 有效括号字符串

**题目：** 给定一个仅包含 '('、')'、'{'、'}'、'['、']' 的字符串 `s`，判断字符串是否有效。

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, c := range s {
        switch c {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || c != stack[len(stack)-1] {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

#### 24. 删除链表的倒数第 `n` 个结点

**题目：** 给定一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的新头结点。

**答案：**

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{0, head}
    slow, fast := dummy, head
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

#### 25. 路径总和 III

**题目：** 给你一个二叉树的根节点 `root` ，和一个表示目标和值的整数 `targetSum` ，判断该树是否存在根节点到叶子节点的路径，且该路径上所有节点值相加等于目标和 `targetSum` 。

**答案：**

```go
func pathSum(root *TreeNode, targetSum int) bool {
    var dfs func(*TreeNode, int)
    dfs = func(node *TreeNode, sum int) bool {
        if node == nil {
            return false
        }
        sum -= node.Val
        if sum == 0 && node.Left == nil && node.Right == nil {
            return true
        }
        return dfs(node.Left, sum) || dfs(node.Right, sum)
    }
    return dfs(root, targetSum)
}
```

#### 26. 反转链表

**题目：** 反转一个单链表。

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev, cur *ListNode
    cur = head
    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}
```

#### 27. 螺旋矩阵

**题目：** 给你一个 `m x n` 的矩阵 `matrix` ，请你返回矩阵的螺旋顺序遍历。

**答案：**

```go
func spiralOrder(matrix [][]int) []int {
    var ans []int
    top, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1
    for len(ans) < len(matrix)*len(matrix[0]) {
        for right >= left; right >= left; right-- {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[top][right])
        }
        top++
        for top <= bottom; top <= bottom; top++ {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[top][right])
        }
        right--
        for left <= right; left <= right; left++ {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[bottom][left])
        }
        bottom--
        for bottom >= top; bottom >= top; bottom-- {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[bottom][left])
        }
        left++
    }
    return ans
}
```

#### 28. 翻转字符串中的单词 III

**题目：** 给你一个字符串 `s` ，请你翻转字符串中每个单词的位置，单词之间用单个空格分隔，然后返回翻转后的字符串。

**答案：**

```go
func reverseWords(s string) string {
    s = " " + s
    var words []string
    var word string
    for _, c := range s {
        if c == ' ' {
            words = append(words, word)
            word = ""
        } else {
            word += string(c)
        }
    }
    words = append(words, word)
    var ans string
    for i := len(words) - 1; i >= 0; i-- {
        ans += words[i]
        if i != 0 {
            ans += " "
        }
    }
    return ans
}
```

#### 29. 螺旋矩阵 IV

**题目：** 给定一个 `m x n` 矩阵 `mat` 和一个整数列表 `nums`，返回一个由 `nums` 排序形成的螺旋矩阵。

**答案：**

```go
func constructSpiralMatrix(mat [][]int, nums []int) [][]int {
    m, n := len(mat), len(mat[0])
    t := 0
    b := m - 1
    l := 0
    r := n - 1
    ans := make([][]int, m)
    for i := 0; i < m; i++ {
        ans[i] = make([]int, n)
    }
    for len(nums) > 0 {
        for r >= l; r >= l; r-- {
            if len(nums) == 0 {
                return ans
            }
            ans[t][r] = nums[0]
            nums = nums[1:]
        }
        t++
        for t <= b; t <= b; t++ {
            if len(nums) == 0 {
                return ans
            }
            ans[t][r] = nums[0]
            nums = nums[1:]
        }
        r--
        for b >= t; b >= t; b-- {
            if len(nums) == 0 {
                return ans
            }
            ans[b][r] = nums[0]
            nums = nums[1:]
        }
        b--
        for l <= r; l <= r; l++ {
            if len(nums) == 0 {
                return ans
            }
            ans[b][l] = nums[0]
            nums = nums[1:]
        }
        l++
    }
    return ans
}
```

#### 30. 单词搜索

**题目：** 给定一个二维网格和一个单词，找出该单词是否存在于网格中。

**答案：**

```go
func exist(board [][]byte, word string) bool {
    var dfs func(int, int, int)
    rows, cols := len(board), len(board[0])
    dfs = func(i, j, k int) bool {
        if board[i][j] != word[k] {
            return false
        }
        if k == len(word)-1 {
            return true
        }
        board[i][j] = '#'
        var res bool
        if i-1 >= 0 && dfs(i-1, j, k+1) {
            res = true
        }
        if i+1 < rows && dfs(i+1, j, k+1) {
            res = true
        }
        if j-1 >= 0 && dfs(i, j-1, k+1) {
            res = true
        }
        if j+1 < cols && dfs(i, j+1, k+1) {
            res = true
        }
        board[i][j] = word[k]
        return res
    }
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if dfs(i, j, 0) {
                return true
            }
        }
    }
    return false
}
```

#### 31. 旋转图像

**题目：** 给定一个 `n x n` 的二维矩阵 `matrix` ，旋转矩阵 90 度得到新的矩阵 `matrixNew` 。

**答案：**

```go
func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := i; j < n-i-1; j++ {
            temp := matrix[i][j]
            matrix[i][j] = matrix[n-1-j][i]
            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]
            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]
            matrix[j][n-1-i] = temp
        }
    }
}
```

#### 32. 接雨水

**题目：** 给定一个整数数组 `height` ，表示一个楼群的高度图，返回该楼群能接的雨水量。

**答案：**

```go
func trap(height []int) int {
    n := len(height)
    leftMax := make([]int, n)
    rightMax := make([]int, n)
    leftMax[0] = height[0]
    for i := 1; i < n; i++ {
        leftMax[i] = max(leftMax[i-1], height[i])
    }
    rightMax[n-1] = height[n-1]
    for i := n - 2; i >= 0; i-- {
        rightMax[i] = max(rightMax[i+1], height[i])
    }
    var res int
    for i := 0; i < n; i++ {
        res += min(leftMax[i], rightMax[i]) - height[i]
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 33. 翻转二叉树

**题目：** 给定一个二叉树，返回它的翻转二叉树。

**答案：**

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

#### 34. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 35. 路径总和

**题目：** 给你一个二叉树的根节点 `root` 和一个表示目标和值的整数 `targetSum` ，找出所有从根节点到叶子节点的路径总和等于 `targetSum` 的路径。

**答案：**

```go
func pathSum(root *TreeNode, targetSum int) [][]int {
    var paths [][]int
    var dfs func(*TreeNode, int, []int)
    dfs = func(node *TreeNode, sum int, path []int) {
        if node == nil {
            return
        }
        path = append(path, node.Val)
        sum -= node.Val
        if sum == 0 && node.Left == nil && node.Right == nil {
            paths = append(paths, append([]int{}, path...))
        } else {
            dfs(node.Left, sum, path)
            dfs(node.Right, sum, path)
        }
        path = path[:len(path)-1]
    }
    dfs(root, targetSum, []int{})
    return paths
}
```

#### 36. 删除链表的倒数第 `n` 个结点

**题目：** 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的新头节点。

**答案：**

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{0, head}
    slow, fast := dummy, head
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

#### 37. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 38. 合并两个有序数组

**题目：** 给你两个整数数组 `nums1` 和 `nums2` ，按升序合并它们，并在 `nums1` 的额外空间中填充 `nums2` 的所有元素。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    for i, j := m, 0; i < m+n && j < n; i++ {
        if nums1[i-m] < nums2[j] {
            nums1[i] = nums2[j]
            j++
        }
    }
    for j < n {
        nums1[i] = nums2[j]
        i++
        j++
    }
}
```

#### 39. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

#### 40. 缩小范围

**题目：** 给定一个范围 [low, high]，其中 `low` 和 `high` 都是整数，且 `low <= high` 。在范围 [low, high] 中，按任意顺序返回一个长度为 `k` 的缩小的范围。

**答案：**

```go
func smallestRangeII(nums []int, k int) int {
    sort.Ints(nums)
    ans := nums[len(nums)-1] - nums[0]
    for i := 0; i < len(nums)-1; i++ {
        minVal := nums[i] + k
        maxVal := nums[i+1] - k
        ans = min(ans, maxVal-minVal)
    }
    return ans
}
```

#### 41. 合并两个有序链表

**题目：** 给定两个单链表，这两个链表中的元素都按照升序排列，将它们合并为一个链表并返回。如果其中一个链表为空，则返回另一个链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 42. 合并两个有序数组

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，按升序合并它们，并在 `nums1` 的额外空间中填充 `nums2` 的所有元素。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    p := m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    for p2 >= 0 {
        nums1[p] = nums2[p2]
        p2--
        p--
    }
}
```

#### 43. 缩小范围

**题目：** 给定一个范围 [low, high]，其中 `low` 和 `high` 都是整数，且 `low <= high` 。在范围 [low, high] 中，按任意顺序返回一个长度为 `k` 的缩小的范围。

**答案：**

```go
func smallestRangeII(nums []int, k int) int {
    sort.Ints(nums)
    ans := nums[len(nums)-1] - nums[0]
    for i := 0; i < len(nums)-1; i++ {
        minVal := nums[i] + k
        maxVal := nums[i+1] - k
        ans = min(ans, maxVal-minVal)
    }
    return ans
}
```

#### 44. 合并两个有序链表

**题目：** 给定两个单链表，这两个链表中的元素都按照升序排列，将它们合并为一个链表并返回。如果其中一个链表为空，则返回另一个链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 45. 合并两个有序数组

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，按升序合并它们，并在 `nums1` 的额外空间中填充 `nums2` 的所有元素。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    p := m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    for p2 >= 0 {
        nums1[p] = nums2[p2]
        p2--
        p--
    }
}
```

#### 46. 合并区间

**题目：** 给定一组区间列表，找到并合并所有重叠的区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] < intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })
    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 47. 合并两个有序链表

**题目：** 给定两个单链表，这两个链表中的元素都按照升序排列，将它们合并为一个链表并返回。如果其中一个链表为空，则返回另一个链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 48. 合并两个有序数组

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，按升序合并它们，并在 `nums1` 的额外空间中填充 `nums2` 的所有元素。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    p := m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    for p2 >= 0 {
        nums1[p] = nums2[p2]
        p2--
        p--
    }
}
```

#### 49. 最小路径和

**题目：** 给定一个包含非负数的 `m x n` 网格，找到路径从左上角到右下角且路径上的数字总和最小。

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 50. 三数和

**题目：** 给你一个整数数组 `nums` ，判断是否存在三个数 `nums[i]`、`nums[j]` 和 `nums[k]` 使得 `nums[i] + nums[j] + nums[k] == 0` 。请

**答案：**

```go
func threeSum(nums []int) [][]int {
    var result [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return result
}
```

#### 51. 翻转整数

**题目：** 给你一个整数 `x` ，返回 `x` 整数部分反转后的结果。

**答案：**

```go
func reverse(x int) int {
    var res int
    for x > 0 || x < 0 && x != -2147483648 {
        res = res*10 + x%10
        x /= 10
    }
    if res < -214748364 || res > 214748364 {
        return 0
    }
    return res
}
```

#### 52. 罗马数字转换

**题目：** 罗马数字包含以下七种字符: `I`, `V`, `X`, `L`, `C`, `D` 和 `M`。例如，`2` 写作 `II` ，`12` 写作 `XII` 。罗马数字中，`I` 可以放在 `V` (5) 和 `X` (10) 的左边，但不能放在他们的右边。数字 `(6)`, `(7)` ，` `(9)` 需要特别处理，例如 `6` 写作 `VI` ，`9` 写作 `IX` 。这个相同的规则也适用于四个数字，例如 `40` 写作 `XL` ，`90` 写作 `XC` 。罗马数字中，`X` 不能放在 `V` (`5`) 和 `L` (`50`) 的左边，也不能放在他们的右边。数字 `(4)`, `(5)` ，` `(9)` 需要特别处理，例如 `4` 写作 `IV` ，`9` 写作 `IX` 。这个相同的规则也适用于六个数字，例如 `60` 写作 `LX` ，`90` 写作 `XC` 。

**答案：**

```go
func romanToInt(s string) int {
    m := map[rune]int{'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    var prev, ans int
    for _, c := range s {
        val := m[c]
        if prev < val {
            ans -= 2 * prev
        }
        ans += val
        prev = val
    }
    return ans
}
```

#### 53. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）。返回其最大和。

**答案：**

```go
func maxSubArray(nums []int) int {
    ans, sum := nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        sum = max(nums[i], sum+nums[i])
        ans = max(ans, sum)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 54. 寻找重复的子串

**题目：** 给定一个字符串 `s` ，你的任务是找出其中最长的重复子串，并返回其长度。如果不存在重复子串，返回 `0` 。

**答案：**

```go
func longestRepeatingSubstring(s string) int {
    mod := int(1e9 + 7)
    n := len(s)
    power := make([]int, n+1)
    power[0] = 1
    for i := 1; i <= n; i++ {
        power[i] = (power[i-1] * 26) % mod
    }
    hash := 0
    for _, c := range s {
        hash = (hash*26 + int(c-'a')) % mod
    }
    hash %= mod
    sMap := map[int]int{hash: 0}
    ans := 0
    for i := 0; i < n; i++ {
        if v, ok := sMap[hash]; ok {
            ans = max(ans, i-v)
        }
        hash = (hash*26 + int(s[i]-'a') + mod) % mod
        sMap[hash] = i
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 55. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 `0` 。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 56. 最小路径和

**题目：** 给定一个包含非负数的 `m x n` 网格，找到路径从左上角到右下角且路径上的数字总和最小。

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 57. 爬楼梯

**题目：** 一个楼梯总共有 `n` 阶台阶，每级都有 `1` 或 `2` 个台阶。要求用最少的步数爬到楼顶。

**答案：**

```go
func climbStairs(n int) int {
    if n < 2 {
        return n
    }
    a, b := 1, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

#### 58. 两个数组的交集 II

**题目：** 给定两个整数数组 `nums1` 和 `nums2` ，返回 `nums1` 和 `nums2` 的交集。每个元素最多出现在答案数组中两次。

**答案：**

```go
func intersect(nums1 []int, nums2 []int) []int {
    m, n := len(nums1), len(nums2)
    i, j := 0, 0
    ans := make([]int, 0, min(m, n))
    for i < m && j < n {
        if nums1[i] == nums2[j] {
            ans = append(ans, nums1[i])
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }
    return ans
}
```

#### 59. 螺旋矩阵

**题目：** 给你一个 `m x n` 的矩阵 `matrix` ，请你返回矩阵的螺旋顺序遍历。

**答案：**

```go
func spiralOrder(matrix [][]int) []int {
    var ans []int
    top, bottom, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1
    for len(ans) < len(matrix)*len(matrix[0]) {
        for right >= left; right >= left; right-- {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[top][right])
        }
        top++
        for top <= bottom; top <= bottom; top++ {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[top][right])
        }
        right--
        for left <= right; left <= right; left++ {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[bottom][left])
        }
        bottom--
        for bottom >= top; bottom >= top; bottom-- {
            if len(ans) >= len(matrix)*len(matrix[0]) {
                return ans
            }
            ans = append(ans, matrix[bottom][left])
        }
        left++
    }
    return ans
}
```

#### 60. 有效的括号字符串

**题目：** 给定一个只包含 '('、')'、'{'、'}'、'['、']' 的字符串 `s` ，判断字符串是否有效。

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, c := range s {
        switch c {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || c != stack[len(stack)-1] {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

#### 61. 合并两棵二叉树

**题目：** 给你两棵二叉树 `root1` 和 `root2` ，请你拼合它们并返回拼合后的二叉树。通俗地说，拼合意味着从两个树的根结点开始，将两个树的每个节点合并在一起。

**答案：**

```go
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}
```

#### 62. 删除链表的倒数第 `n` 个结点

**题目：** 给你一个单链表的头部节点 `head` 和一个整数 `n` 。请删除链表中第 `n` 个节点，并返回结果链表的头节点。

**答案：**

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{0, head}
    slow, fast := dummy, head
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

#### 63. 罗马数字转整数

**题目：** 罗马数字包含以下七种字符: `I`, `V`, `X`, `L`, `C`, `D` 和 `M`。例如，`2` 写作 `II` ，`12` 写作 `XII` 。罗马数字中，`I` 可以放在 `V` (5) 和 `X` (10) 的左边，但不能放在他们的右边。数字 `(6)`, `(7)` ，` `(9)` 需要特别处理，例如 `6` 写作 `VI` ，`9` 写作 `IX` 。这个相同的规则也适用于四个数字，例如 `40` 写作 `XL` ，`90` 写作 `XC` 。

**答案：**

```go
func romanToInt(s string) int {
    m := map[rune]int{'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    var prev, ans int
    for _, c := range s {
        val := m[c]
        if prev < val {
            ans -= 2 * prev
        }
        ans += val
        prev = val
    }
    return ans
}
```

#### 64. 最小路径和

**题目：** 给定一个包含非负数的 `m x n` 网格，找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 65. 路径和为给定值的节点个数

**题目：** 你需要返回满足其子节点之和等于节点值的树中节点数目。如果没有节点满足这个条件，返回 `0` 。

**答案：**

```go
func pathSum(root *TreeNode, targetSum int) int {
    var dfs func(*TreeNode, int) int
    dfs = func(node *TreeNode, sum int) int {
        if node == nil {
            return 0
        }
        sum -= node.Val
        var cnt int
        if sum == 0 {
            cnt++
        }
        cnt += dfs(node.Left, sum)
        cnt += dfs(node.Right, sum)
        return cnt
    }
    return dfs(root, targetSum)
}
```

#### 66. 合并二叉树

**题目：** 给你两个二叉树的根节点 `root1` 和 `root2` ，想象你自己站在其中一个二叉树的根节点位置，当你从这条边上开始向上走路

