                 

### 小米校招算法岗位面试题目汇编

#### 1. 链表中的倒数第k个节点

**题目描述：** 
给定一个链表，返回链表中的第 k 个节点。链表中的节点从 1 开始计数。

**输入示例：**
```plaintext
1 -> 2 -> 3 -> 4 -> 5
k = 2
```
**输出示例：**
```plaintext
3
```

**答案解析：**
```go
func getKthFromEnd(head *ListNode, k int) int {
    fast, slow := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow.Val
}

// ListNode 是已定义的链表节点结构
type ListNode struct {
    Val  int
    Next *ListNode
}
```
**说明：** 使用快慢指针法，快指针先走 k 步，然后快慢指针同时前进，当快指针到达链表末尾时，慢指针即为倒数第 k 个节点。

#### 2. 数组中的第k大元素

**题目描述：**
给定一个整数数组，找出数组中的第 k 大元素。你可以假设数组中的所有元素都是互异的。

**输入示例：**
```plaintext
[3, 2, 1, 5, 6, 4]
k = 2
```
**输出示例：**
```plaintext
5
```

**答案解析：**
```go
func findKthLargest(nums []int, k int) int {
    n := len(nums)
    for i := 0; i < k; i++ {
        maxIndex := i
        for j := i + 1; j < n; j++ {
            if nums[j] > nums[maxIndex] {
                maxIndex = j
            }
        }
        nums[i], nums[maxIndex] = nums[maxIndex], nums[i]
    }
    return nums[0]
}
```
**说明：** 使用快速选择算法，将数组部分排序，最终得到第 k 大元素。

#### 3. 合并两个有序链表

**题目描述：**
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入示例：**
```plaintext
l1: 1 -> 2 -> 4
l2: 1 -> 3 -> 4
```
**输出示例：**
```plaintext
1 -> 1 -> 2 -> 3 -> 4 -> 4
```

**答案解析：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    curr.Next = l1 // 或 l2，取决于哪个链表非空
    return dummy.Next
}
```
**说明：** 使用迭代方法合并两个链表，按照升序排列。

#### 4. 最长公共前缀

**题目描述：**
编写一个函数来查找字符串数组中的最长公共前缀。

**输入示例：**
```plaintext
["flower", "flow", "flight"]
```
**输出示例：**
```plaintext
"fl"
```

**答案解析：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```
**说明：** 遍历字符串数组，找出最长的公共前缀。

#### 5. 两数之和

**题目描述：**
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**输入示例：**
```plaintext
nums = [2, 7, 11, 15], target = 9
```
**输出示例：**
```plaintext
[0, 1]
```

**答案解析：**
```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if v, ok := m[target-num]; ok {
            return []int{v, i}
        }
        m[num] = i
    }
    return nil
}
```
**说明：** 使用哈希表存储数组的元素和下标，遍历数组，通过哈希表查找是否存在与当前元素相加等于目标值的另一个元素。

#### 6. 判断二叉树是否对称

**题目描述：**
给定一个二叉树，判断它是否是镜像对称的。

**输入示例：**
```plaintext
     1
   /   \
  2     2
 / \   / \
3   4 4   3
```
**输出示例：**
```plaintext
true
```

**答案解析：**
```go
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isMirror(root.Left, root.Right)
}

func isMirror(l, r *TreeNode) bool {
    if l == nil && r == nil {
        return true
    }
    if l == nil || r == nil {
        return false
    }
    if l.Val != r.Val {
        return false
    }
    return isMirror(l.Left, r.Right) && isMirror(l.Right, r.Left)
}

// TreeNode 是已定义的二叉树节点结构
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```
**说明：** 使用递归方法，判断二叉树的左右子树是否镜像对称。

#### 7. 最长公共子序列

**题目描述：**
给定两个字符串，找出它们的最长公共子序列。

**输入示例：**
```plaintext
"abcde", "ace"
```
**输出示例：**
```plaintext
"ace"
```

**答案解析：**
```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var result []byte
    for i, j := m, n; i > 0 && j > 0; {
        if text1[i-1] == text2[j-1] {
            result = append(result, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```
**说明：** 使用动态规划方法，计算最长公共子序列的长度，然后回溯构建最长公共子序列。

#### 8. 设计哈希表

**题目描述：**
设计一个哈希函数，实现哈希表。

**输入示例：**
```plaintext
["MyHashMap", "put", "put", "get", "get", "put", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 3], [2]]
```
**输出示例：**
```plaintext
[null, null, null, 1, -1, null, 3]
```

**答案解析：**
```go
type MyHashMap struct {
    hash map[int]int
}

func Constructor() MyHashMap {
    return MyHashMap{map[int]int{}}
}

func (this *MyHashMap) Put(key int, value int) {
    this.hash[key] = value
}

func (this *MyHashMap) Get(key int) int {
    if v, ok := this.hash[key]; ok {
        return v
    }
    return -1
}
```
**说明：** 使用映射实现哈希表，提供 `put` 和 `get` 操作。

#### 9. 设计循环队列

**题目描述：**
设计一个支持循环队列的类：在循环队列中插入一个元素会使队首元素成为队尾元素。

**输入示例：**
```plaintext
["MyCircularQueue", "enQueue", "deQueue", "enQueue", "Rear", "isFull", "enQueue"]
[[], [3], [1], [2], [], [], [4]]
```
**输出示例：**
```plaintext
[null, true, true, true, 2, false, true]
```

**答案解析：**
```go
type MyCircularQueue struct {
    queue   []int
    front   int
    rear    int
    size    int
}

func Constructor(k int) MyCircularQueue {
    return MyCircularQueue{make([]int, k), 0, 0, k}
}

func (this *MyCircularQueue) EnQueue(value int) bool {
    if this.isFull() {
        return false
    }
    this.queue[this.rear] = value
    this.rear = (this.rear + 1) % this.size
    return true
}

func (this *MyCircularQueue) DeQueue() bool {
    if this.isEmpty() {
        return false
    }
    this.front = (this.front + 1) % this.size
    return true
}

func (this *MyCircularQueue) Front() int {
    if this.isEmpty() {
        return -1
    }
    return this.queue[this.front]
}

func (this *MyCircularQueue) Rear() int {
    if this.isEmpty() {
        return -1
    }
    return this.queue[this.rear-1]
}

func (this *MyCircularQueue) isEmpty() bool {
    return this.front == this.rear
}

func (this *MyCircularQueue) isFull() bool {
    return (this.rear+1)%this.size == this.front
}
```
**说明：** 使用数组实现循环队列，提供 `enQueue`、`deQueue`、`front`、`rear`、`isEmpty` 和 `isFull` 操作。

#### 10. 二进制求和

**题目描述：**
编写一个函数，实现二进制加法。

**输入示例：**
```plaintext
"11"
"1"
```
**输出示例：**
```plaintext
"100"
```

**答案解析：**
```go
func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    res := []byte{}
    for i >= 0 || j >= 0 || carry != 0 {
        x := 0
        if i >= 0 {
            x = int(a[i] - '0')
            i--
        }
        y := 0
        if j >= 0 {
            y = int(b[j] - '0')
            j--
        }
        sum := x + y + carry
        carry = sum / 2
        res = append(res, byte(sum%2)+'0')
    }
    reverse(res)
    return string(res)
}

func reverse(data []byte) {
    for i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {
        data[i], data[j] = data[j], data[i]
    }
}
```
**说明：** 将二进制字符串转换为数字相加，再将结果转换为二进制字符串。

#### 11. 合并两个有序链表

**题目描述：**
将两个有序链表合并为一个新的有序链表并返回。

**输入示例：**
```plaintext
l1: 1 -> 2 -> 4
l2: 1 -> 3 -> 4
```
**输出示例：**
```plaintext
1 -> 1 -> 2 -> 3 -> 4 -> 4
```

**答案解析：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

// ListNode 是已定义的链表节点结构
type ListNode struct {
    Val  int
    Next *ListNode
}
```
**说明：** 递归合并两个有序链表。

#### 12. 删除链表的倒数第 n 个节点

**题目描述：**
给定一个链表，删除链表的倒数第 n 个节点，并返回链表的头节点。

**输入示例：**
```plaintext
head: 1 -> 2 -> 3 -> 4 -> 5, n = 2
```
**输出示例：**
```plaintext
1 -> 2 -> 3 -> 4 -> 5
```

**答案解析：**
```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{0, head}
    fast, slow := dummy, dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```
**说明：** 使用快慢指针法，找到倒数第 n 个节点的前一个节点，删除该节点。

#### 13. 翻转字符串中的单词

**题目描述：**
给定一个字符串，你需要翻转字符串中的每个单词。

**输入示例：**
```plaintext
"the sky is blue"
```
**输出示例：**
```plaintext
"blue is sky the"
```

**答案解析：**
```go
func reverseWords(s string) string {
    s = " " + s
    n := len(s)
    i, j, k := 0, 0, 0
    ans := []byte{}
    for i < n {
        if s[i] != ' ' {
            if k > 0 {
                ans = append(ans, ' ')
            }
            j = i
            for j < n && s[j] != ' ' {
                j++
            }
            for ; i < j; i++ {
                ans = append(ans, s[i])
            }
            k++
        }
        i++
    }
    return string(ans)
}
```
**说明：** 使用字符串遍历和反转，拆分和合并单词。

#### 14. 两数相加

**题目描述：**
给定两个非空链表表示的两个非负整数，分别位于链表节点中，数字按照逆序方式存储，每个节点包含一个数字。请将这两个数相加，并以链表形式返回结果。

**输入示例：**
```plaintext
l1: 2 -> 4 -> 3
l2: 5 -> 6 -> 4
```
**输出示例：**
```plaintext
7 -> 0 -> 8
```

**答案解析：**
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```
**说明：** 使用链表节点模拟整数相加，处理进位。

#### 15. 最长公共前缀

**题目描述：**
编写一个函数来查找字符串数组中的最长公共前缀。

**输入示例：**
```plaintext
["flower", "flow", "flight"]
```
**输出示例：**
```plaintext
"fl"
```

**答案解析：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for i := 1; i < len(strs); i++ {
        j := 0
        for j < len(ans) && j < len(strs[i]) && ans[j] == strs[i][j] {
            j++
        }
        ans = ans[:j]
        if ans == "" {
            return ""
        }
    }
    return ans
}
```
**说明：** 遍历字符串数组，找出最长的公共前缀。

#### 16. 三数之和

**题目描述：**
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那三个整数，并返回索引数组。

**输入示例：**
```plaintext
nums = [-1, 0, 1, 2, -1, -4], target = 0
```
**输出示例：**
```plaintext
[0, 1, 2]
```

**答案解析：**
```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum < 0 {
                left++
            } else if sum > 0 {
                right--
            } else {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            }
        }
    }
    return ans
}
```
**说明：** 使用排序和双指针法，找出三数之和为目标值的所有组合。

#### 17. 四数之和

**题目描述：**
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那四个整数，并返回索引数组。

**输入示例：**
```plaintext
nums = [1, 0, -1, 0, -2, 2], target = 0
```
**输出示例：**
```plaintext
[0, 1, 2, 4]
```

**答案解析：**
```go
func fourSum(nums []int, target int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        for j := i + 1; j < len(nums)-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            left, right := j+1, len(nums)-1
            for left < right {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum < 0 {
                    left++
                } else if sum > 0 {
                    right--
                } else {
                    ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]})
                    for left < right && nums[left] == nums[left+1] {
                        left++
                    }
                    for left < right && nums[right] == nums[right-1] {
                        right--
                    }
                    left++
                    right--
                }
            }
        }
    }
    return ans
}
```
**说明：** 使用排序和双指针法，找出四数之和为目标值的所有组合。

#### 18. 删除链表的倒数第 n 个节点

**题目描述：**
给定一个链表，删除链表的倒数第 n 个节点，并返回链表的头节点。

**输入示例：**
```plaintext
head: 1 -> 2 -> 3 -> 4 -> 5, n = 2
```
**输出示例：**
```plaintext
1 -> 2 -> 3 -> 4 -> 5
```

**答案解析：**
```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{0, head}
    fast, slow := dummy, dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```
**说明：** 使用快慢指针法，找到倒数第 n 个节点的前一个节点，删除该节点。

#### 19. 盛最多水的容器

**题目描述：**
给定一个二

