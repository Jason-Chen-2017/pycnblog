                 

### 2025年小米社招算法岗位面试题目汇编

在本篇博客中，我们将汇编2025年小米社招算法岗位的一些典型面试题目，涵盖数据结构、算法、系统设计、机器学习等多个领域。以下是一系列题目及其详尽解析：

--------------------------------------------------------

### 1. 二叉搜索树的最小绝对差值

**题目：** 给定一棵二叉搜索树，找出树中最小的绝对差值。

**输入：** 根节点

**输出：** 最小的绝对差值

**示例：**
```
输入：[5, 3, 7, 2, 4, 6, 8]
输出：1
```

**答案：**
```go
func getMinimumDifference(root *TreeNode) int {
    prev, res := -1, +inf
    for node := root; node != nil; node = node.Left {
        res = min(res, node.Val-prev)
        prev = node.Val
    }
    for node := root; node != nil; node = node.Right {
        res = min(res, node.Val-prev)
        prev = node.Val
    }
    return res
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 遍历二叉搜索树，记录前一个节点的值，计算当前节点与前一个节点的差值，更新最小差值。

--------------------------------------------------------

### 2. 单调栈

**题目：** 使用单调栈解决数组中的下一个更大元素问题。

**输入：** 整数数组

**输出：** 每个元素对应下一个更大元素，如果不存在则返回 -1。

**示例：**
```
输入：[1, 2, 1]
输出：[2, -1, -1]
```

**答案：**
```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    m := map[int]int{}
    for _, v := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] < v {
            m[stack[len(stack)-1]] = v
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, v)
    }
    ans := make([]int, len(nums1))
    for i, v := range nums1 {
        ans[i] = m[v]
    }
    return ans
}
```

**解析：** 遍历nums2，使用单调栈维护递减的元素序列，更新m映射每个元素的下一个更大元素。对于nums1中的每个元素，从m中获取其对应的下一个更大元素。

--------------------------------------------------------

### 3. 快排算法

**题目：** 使用快速排序算法对数组进行排序。

**输入：** 整数数组

**输出：** 排序后的数组。

**示例：**
```
输入：[5, 2, 9, 1, 5, 6]
输出：[1, 2, 5, 5, 6, 9]
```

**答案：**
```go
func quickSort(nums []int) {
    if len(nums) <= 1 {
        return
    }
    pivot := nums[len(nums)/2]
    left, right := 0, len(nums)-1
    for {
        for nums[left] < pivot {
            left++
        }
        for nums[right] > pivot {
            right--
        }
        if left >= right {
            break
        }
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
    quickSort(nums[:left])
    quickSort(nums[left:])
}
```

**解析：** 选择一个基准值，将数组划分为小于和大于基准值的两部分，递归排序两部分。

--------------------------------------------------------

### 4. 最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**输入：** 字符串数组

**输出：** 最长公共前缀。

**示例：**
```
输入：["flower", "flow", "flight"]
输出："fl"
```

**答案：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 依次比较字符串数组中的每个字符串，更新公共前缀。

--------------------------------------------------------

### 5. 两数相加

**题目：** 使用链表实现两数相加。

**输入：** 两个链表

**输出：** 相加后的链表。

**示例：**
```
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：(7 -> 8 -> 0 -> 7)
```

**答案：**
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：** 模拟链表相加过程，处理进位。

--------------------------------------------------------

### 6. 有效的括号

**题目：** 判断字符串中的括号是否有效。

**输入：** 字符串

**输出：** 是否有效

**示例：**
```
输入："()"
输出：true
```

**答案：**
```go
func isValid(s string) bool {
    stack := []rune{}
    for _, v := range s {
        switch v {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || stack[len(stack)-1] != v {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

**解析：** 使用栈存储匹配的括号，判断是否匹配。

--------------------------------------------------------

### 7. 回文数

**题目：** 判断一个整数是否是回文数。

**输入：** 整数

**输出：** 是否回文

**示例：**
```
输入：121
输出：true
```

**答案：**
```go
func isPalindrome(x int) bool {
    if x < 0 || (x%10==0 && x!=0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x /= 10
    }
    return x == reversed || x == reversed/10
}
```

**解析：** 将整数反转，与原整数比较。

--------------------------------------------------------

### 8. 罗马数字转整数

**题目：** 将罗马数字转换为整数。

**输入：** 字符串

**输出：** 整数

**示例：**
```
输入："MCMXCVI"
输出：1996
```

**答案：**
```go
var romanToInt = map[rune]int{
    'I': 1,
    'V': 5,
    'X': 10,
    'L': 50,
    'C': 100,
    'D': 500,
    'M': 1000,
}

func romanToInteger(s string) int {
    prev, ans := 0, 0
    for i := len(s) - 1; i >= 0; i-- {
        value := romanToInt[rune(s[i])]
        if value < prev {
            ans -= value
        } else {
            ans += value
        }
        prev = value
    }
    return ans
}
```

**解析：** 从后向前遍历字符串，根据罗马数字规则计算整数。

--------------------------------------------------------

### 9. 逆波兰表达式求值

**题目：** 计算逆波兰表达式（后缀表示法）的值。

**输入：** 逆波兰表达式

**输出：** 表达式的值

**示例：**
```
输入：["2", "1", "+", "3", "*"]
输出：9
```

**答案：**
```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    ans := 0
    for i := 0; i < len(token); i++ {
        ans = ans*10 + int(token[i]-'0')
    }
    return ans * sign
}
```

**解析：** 遍历逆波兰表达式，根据运算符执行相应的操作。

--------------------------------------------------------

### 10. 合并两个有序链表

**题目：** 合并两个有序链表。

**输入：** 两个有序链表

**输出：** 合并后的有序链表。

**示例：**
```
输入：l1: 1->3->4, l2: 1->2->4
输出：1->1->2->3->4->4
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 比较两个链表的头节点，选择较小的值作为新的头节点，递归合并剩余部分。

--------------------------------------------------------

### 11. 字符串转换整数 (atoi)

**题目：** 实现atoi函数，将字符串转换为整数。

**输入：** 字符串

**输出：** 整数

**示例：**
```
输入："42"
输出：42
```

**答案：**
```go
func myAtoi(s string) int {
    sign := 1
    ans := 0
    for i := 0; i < len(s) && s[i] == ' '; i++
    if i < len(s) && (s[i] == '-' || s[i] == '+') {
        sign = 1 - 2 * (s[i] == '+')
        i++
    }
    for ; i < len(s) && isDigit(s[i]); i++ {
        if ans > (int(1)<<(31)-1)/10 || (ans == (int(1)<<(31)-1)/10 && digit > 7) {
            return sign == 1 ? int(1)<<31 - 1 : int(-1)<<31
        }
        ans = ans*10 + int(s[i]-'0')
    }
    return sign * ans
}

func isDigit(c byte) bool {
    return '0' <= c && c <= '9'
}
```

**解析：** 处理字符串中的空格，符号和数字字符，将字符串转换为整数。

--------------------------------------------------------

### 12. 有效的数字

**题目：** 判断字符串是否是有效的数字。

**输入：** 字符串

**输出：** 是否有效

**示例：**
```
输入："0"
输出：true
```

**答案：**
```go
func isNumber(s string) bool {
    f, e := false, false
    for _, c := range s {
        switch {
        case '0' <= c && c <= '9':
            f = true
        case c == '.':
            if e {
                return false
            }
            e = true
        case c == 'e' || c == 'E':
            if e || !f {
                return false
            }
            f = false
            e = false
        case c == '+' || c == '-':
            if e || c != s[0] {
                return false
            }
        default:
            return false
        }
    }
    return f && e
}
```

**解析：** 分析字符串中的字符，判断是否是有效的数字。

--------------------------------------------------------

### 13. 最长公共子序列

**题目：** 找出两个字符串的最长公共子序列。

**输入：** 两个字符串

**输出：** 最长公共子序列的长度

**示例：**
```
输入："abcde", "ace"
输出：3
```

**答案：**
```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划求解最长公共子序列。

--------------------------------------------------------

### 14. 判断二分查找树是否合法

**题目：** 判断一棵二分查找树是否合法。

**输入：** 二分查找树的根节点

**输出：** 是否合法

**示例：**
```
输入：[5, 3, 7, 2, 4, 6, 8]
输出：true
```

**答案：**
```go
func isValidBST(root *TreeNode) bool {
    var dfs func(node *TreeNode, lower, upper int) bool
    dfs = func(node *TreeNode, lower, upper int) bool {
        if node == nil {
            return true
        }
        if node.Val <= lower || node.Val >= upper {
            return false
        }
        return dfs(node.Left, lower, node.Val) && dfs(node.Right, node.Val, upper)
    }
    return dfs(root, -1<<63, 1<<63-1)
}
```

**解析：** 递归检查每个节点是否在有效范围内。

--------------------------------------------------------

### 15. 翻转整数

**题目：** 翻转一个整数的数字。

**输入：** 整数

**输出：** 翻转后的整数

**示例：**
```
输入：123
输出：321
```

**答案：**
```go
func reverse(x int) int {
    const INT_MAX = 1 << 31 - 1
    const INT_MIN = -1 << 31
    y := 0
    for x > 0 {
        if y > INT_MAX/10 || y < INT_MIN/10 {
            return 0
        }
        y = y*10 + x%10
        x /= 10
    }
    if x < 0 && y < INT_MIN || x > 0 && y > INT_MAX {
        return 0
    }
    return y
}
```

**解析：** 将整数转换为字符串，逐位反转。

--------------------------------------------------------

### 16. 判断二分图

**题目：** 判断一个无向图是否为二分图。

**输入：** 无向图的邻接表

**输出：** 是否为二分图

**示例：**
```
输入：[[1, 2], [2, 3], [3, 0], [0, 4]]
输出：true
```

**答案：**
```go
var color []int
var dfs = func(i int, c int) bool {
    color[i] = c
    for _, j := range g[i] {
        if color[j] == c {
            return false
        }
        if color[j] == 0 && !dfs(j, -c) {
            return false
        }
    }
    return true
}

func isBipartite(graph [][]int) bool {
    color = make([]int, len(graph))
    for i := range color {
        if color[i] == 0 {
            if !dfs(i, 1) {
                return false
            }
        }
    }
    return true
}
```

**解析：** 使用DFS将图划分为两个集合，检查是否有相邻节点同属于一个集合。

--------------------------------------------------------

### 17. 单调栈求解下一个最小元素

**题目：** 给定一个数组，使用单调栈找出每个元素对应下一个小于该元素的下标。

**输入：** 整数数组

**输出：** 对应的下标数组

**示例：**
```
输入：[4, 5, 2, 25]
输出：[3, 2, 0, -1]
```

**答案：**
```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    m := map[int]int{}
    for _, v := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] < v {
            m[stack[len(stack)-1]] = v
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, v)
    }
    ans := make([]int, len(nums1))
    for i, v := range nums1 {
        ans[i] = m[v]
    }
    return ans
}
```

**解析：** 遍历nums2，使用单调栈找出nums1中每个元素对应下一个更小的元素。

--------------------------------------------------------

### 18. 子数组最大平均数 I

**题目：** 给定一个整数数组和一个整数k，找出长度为k的子数组最大平均数。

**输入：** 整数数组nums和整数k

**输出：** 子数组最大平均数

**示例：**
```
输入：nums = [1,12,-5,-6,50,3], k = 4
输出：12.75
```

**答案：**
```go
func largesteyerger(nums []int, k int) float64 {
    sum := 0
    for i := 0; i < k; i++ {
        sum += nums[i]
    }
    mx := sum
    for i := k; i < len(nums); i++ {
        sum += nums[i] - nums[i-k]
        mx = max(mx, sum)
    }
    return float64(mx) / float64(k)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 遍历数组，计算长度为k的子数组的和，更新最大平均值。

--------------------------------------------------------

### 19. 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组中的一个目标值。

**输入：** 整数数组nums和一个目标值target

**输出：** 目标值在数组中的索引，如果不存在则返回-1。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**答案：**
```go
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := l + (r-l)/2
        if nums[mid] == target {
            return mid
        }
        if nums[l] <= nums[mid] {
            if target >= nums[l] && target < nums[mid] {
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[r] {
                l = mid + 1
            } else {
                r = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 使用二分查找，处理旋转数组。

--------------------------------------------------------

### 20. 有效的括号字符串

**题目：** 判断字符串是否是有效的括号字符串。

**输入：** 字符串

**输出：** 是否有效

**示例：**
```
输入："()"
输出：true
```

**答案：**
```go
func isValid(str string) bool {
    cnt := 0
    for _, ch := range str {
        if ch == '(' {
            cnt++
        } else if cnt == 0 || ch != ')' {
            return false
        } else {
            cnt--
        }
    }
    return cnt == 0
}
```

**解析：** 遍历字符串，使用计数器判断是否有效。

--------------------------------------------------------

### 21. 合并两个有序链表

**题目：** 合并两个有序链表。

**输入：** 两个有序链表

**输出：** 合并后的有序链表。

**示例：**
```
输入：l1: 1->3->4, l2: 1->2->4
输出：1->1->2->3->4->4
```

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 比较两个链表的头节点，选择较小的值作为新的头节点，递归合并剩余部分。

--------------------------------------------------------

### 22. 最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**输入：** 字符串数组

**输出：** 最长公共前缀

**示例：**
```
输入：["flower","flow","flight"]
输出："fl"
```

**答案：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 依次比较字符串数组中的每个字符串，更新公共前缀。

--------------------------------------------------------

### 23. 二分查找

**题目：** 实现二分查找算法。

**输入：** 整数数组和一个目标值

**输出：** 目标值在数组中的索引，如果不存在则返回-1。

**示例：**
```
输入：[4,5,6,7,0,1,2], target = 0
输出：4
```

**答案：**
```go
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := l + (r-l)/2
        if nums[mid] == target {
            return mid
        }
        if nums[l] <= nums[mid] {
            if target >= nums[l] && target < nums[mid] {
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[r] {
                l = mid + 1
            } else {
                r = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 使用二分查找算法在有序数组中查找目标值。

--------------------------------------------------------

### 24. 环形链表

**题目：** 判断一个链表是否为环形链表。

**输入：** 链表的头节点

**输出：** 是否为环形链表

**示例：**
```
输入：[3, 2, 0, -4]
输出：true
```

**答案：**
```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 使用快慢指针检测环形链表。

--------------------------------------------------------

### 25. 字符串转换整数 (atoi)

**题目：** 实现atoi函数，将字符串转换为整数。

**输入：** 字符串

**输出：** 整数

**示例：**
```
输入："42"
输出：42
```

**答案：**
```go
func myAtoi(s string) int {
    sign := 1
    ans := 0
    for i := 0; i < len(s) && s[i] == ' '; i++
    if i < len(s) && (s[i] == '-' || s[i] == '+') {
        sign = 1 - 2 * (s[i] == '+')
        i++
    }
    for ; i < len(s) && isDigit(s[i]); i++ {
        if ans > (int(1)<<31 - 1)/10 || (ans == (int(1)<<31 - 1)/10 && digit > 7) {
            return sign == 1 ? int(1)<<31 - 1 : int(-1)<<31
        }
        ans = ans*10 + int(s[i]-'0')
    }
    return sign * ans
}

func isDigit(c byte) bool {
    return '0' <= c && c <= '9'
}
```

**解析：** 处理字符串中的空格，符号和数字字符，将字符串转换为整数。

--------------------------------------------------------

以上是2025年小米社招算法岗位的一些典型面试题目及其详尽的解析。这些题目涵盖了算法和数据结构的基础知识，以及在实际工作中可能遇到的常见问题。通过这些题目的练习和解决，可以提升解决实际问题的能力，为面试和职业发展打下坚实的基础。

