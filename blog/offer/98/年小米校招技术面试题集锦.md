                 

### 2025年小米校招技术面试题集锦：经典算法题解析

在小米的校招技术面试中，算法题一直是考查的重点。以下我们整理了20道具有代表性的面试题，并给出详细的答案解析。

#### 1. 快乐数

**题目：** 编写一个算法，用来找出是否一个数是快乐数。

**解答：**

快乐数定义为：一个正整数，依次拆分它各个位上的数字，然后把这些位上的数字组合成一个新数，重复这个步骤。如果这个过程中出现某个数位序列出现重复，那么这个数就是一个快乐数。

**代码示例：**

```python
def is_happy(num):
    def get_next_num(n):
        sum = 0
        while n > 0:
            sum += (n % 10) ** 2
            n //= 10
        return sum

    slow_runner, fast_runner = num, get_next_num(num)
    while fast_runner != 1 and slow_runner != fast_runner:
        slow_runner = get_next_num(slow_runner)
        fast_runner = get_next_num(get_next_num(fast_runner))
    return fast_runner == 1

# 测试
print(is_happy(19))  # True
print(is_happy(1))   # False
```

#### 2. 合并两个有序链表

**题目：** 合并两个有序链表。

**解答：**

合并两个有序链表的思路比较简单，可以从头节点开始，比较两个链表的节点值，选择更小的值链接到结果链表上。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 测试
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged = merge_two_lists(l1, l2)
while merged:
    print(merged.val, end=' ')
    merged = merged.next
# 输出:1 2 3 4 5 6
```

#### 3. 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**解答：**

使用动态规划的方法，创建一个二维数组 dp，其中 dp[i][j] 表示字符串 s1 的前 i 个字符和字符串 s2 的前 j 个字符的最长公共子序列的长度。

**代码示例：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

# 测试
s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))  # 输出:2
```

#### 4. 最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**解答：**

使用动态规划的方法，创建一个二维数组 dp，其中 dp[i][j] 表示字符串 s1 的前 i 个字符和字符串 s2 的前 j 个字符的最长公共子串的长度。

**代码示例：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len, max_end = 0, 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    max_end = i
            else:
                dp[i][j] = 0
    return s1[max_end - max_len: max_end]

# 测试
s1 = "ABCD"
s2 = "ACDF"
print(longest_common_substring(s1, s2))  # 输出:"AC"
```

#### 5. 寻找两个有序数组的中位数

**题目：** 给定两个有序数组 nums1 和 nums2，找出它们的第 k 小的公共元素。

**解答：**

首先找出两个数组中的第 k 小的元素，可以通过二分查找的方法来实现。

**代码示例：**

```python
def find_kth_smallest(nums1, nums2, k):
    if len(nums1) > len(nums2):
        return find_kth_smallest(nums2, nums1, k)
    if len(nums1) == 0:
        return nums2[k - 1]
    if k == 1:
        return min(nums1[0], nums2[0])
    i = min(k // 2, len(nums1))
    j = min(k // 2, len(nums2))
    if nums1[i - 1] > nums2[j - 1]:
        return find_kth_smallest(nums1, nums2[j:], k - j)
    else:
        return find_kth_smallest(nums1[i:], nums2, k - i)

# 测试
nums1 = [1, 3, 5]
nums2 = [2, 4, 6]
k = 3
print(find_kth_smallest(nums1, nums2, k))  # 输出:3
```

#### 6. 寻找旋转排序数组中的最小值

**题目：** 给定一个旋转排序的数组，找出旋转数组的最小元素。

**解答：**

可以使用二分查找的方法，判断中间元素是否小于其前一个元素或大于其后一个元素。

**代码示例：**

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = left + (right - left) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

# 测试
nums = [3, 4, 5, 1, 2]
print(find_min(nums))  # 输出:1
```

#### 7. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**解答：**

使用哈希表记录每个数是否出现过，然后遍历数组，对于每个未出现的数，尝试扩展最长连续序列。

**代码示例：**

```python
def longest_consecutive(nums):
    if not nums:
        return 0
    num_set = set(nums)
    max_len = 0
    for num in nums:
        if num - 1 not in num_set:
            curr_num = num
            curr_len = 1
            while curr_num + 1 in num_set:
                curr_num += 1
                curr_len += 1
            max_len = max(max_len, curr_len)
    return max_len

# 测试
nums = [100, 4, 200, 1, 3, 2]
print(longest_consecutive(nums))  # 输出:4
```

#### 8. 二分查找

**题目：** 实现二分查找。

**解答：**

二分查找的基本思路是：将数组分成两半，取中间的元素与目标值比较，如果相等则返回，如果目标值小于中间元素则搜索左侧，否则搜索右侧。

**代码示例：**

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 测试
nums = [1, 3, 5, 6]
target = 5
print(binary_search(nums, target))  # 输出:2
```

#### 9. 剑指 Offer 56 - I. 数组中数字出现的次数

**题目：** 一个整数数组 nums 中只有一个数字出现了两次，其他数字都只出现了一次，请找出这个只出现一次的数字。

**解答：**

使用异或运算，任何数字与 0 异或还是其本身，任何数字与其本身异或为 0。因此，所有出现两次的数字在异或运算后都会变成 0，而只出现一次的数字异或结果不为 0。

**代码示例：**

```python
def single_number(nums):
    xor = 0
    for num in nums:
        xor ^= num
    return xor

# 测试
nums = [2, 2, 3]
print(single_number(nums))  # 输出:3
```

#### 10. 剑指 Offer 45. 把数组排成最小的数

**题目：** 把一个整数数组从小到大排列。

**解答：**

使用快速排序，这是一种基于选择排序的改进算法。选择排序每次选择最大或最小的元素放到数组的一端，快速排序则通过一趟排序将数组分成两部分，其中一部分的所有元素都不大于另一部分的所有元素。

**代码示例：**

```python
def quick_sort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 测试
nums = [3, 1, 4, 1, 5, 9, 2, 6, 5]
print(quick_sort(nums))  # 输出:[1, 1, 2, 3, 4, 5, 5, 6, 9]
```

#### 11. 剑指 Offer 39. 数组中出现次数超过一半的数字

**题目：** 找出数组中频率超过一半的数字。

**解答：**

使用 Boyer-Moore 投票算法。首先假设出现次数超过一半的数字是多数元素，然后遍历数组，用当前元素去投票，如果当前元素与多数元素相同，票数加一，否则票数减一。如果票数减为零，说明当前多数元素不是我们要找的，然后更换多数元素，并重置票数为零。遍历结束后，找到的多数元素就是出现次数超过一半的数字。

**代码示例：**

```python
def majority_element(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate

# 测试
nums = [1, 2, 3, 2, 2, 2, 5, 4, 2]
print(majority_element(nums))  # 输出:2
```

#### 12. 剑指 Offer 43. 1～n 整数中1出现的次数

**题目：** 计算从 1 到 n 中 1 出现的次数。

**解答：**

递归处理每一位数字，对于当前位上的数字 x，可以计算出前缀数字中 1 出现的次数，然后分别处理当前位为 1、小于 1、大于 1 的情况。

**代码示例：**

```python
def count_digit_one(n):
    if n <= 0:
        return 0
    count = 0
    for i in range(1, n + 1):
        count += str(i).count('1')
    return count

# 测试
n = 13
print(count_digit_one(n))  # 输出:6
```

#### 13. 剑指 Offer 34. 二叉树中和为某一值的路径

**题目：** 找出二叉树中两个节点之和等于给定值 target 的路径。

**解答：**

使用回溯算法，遍历每个节点，判断当前路径和是否等于 target，如果是，则记录路径；如果不是，则继续遍历下一层节点。

**代码示例：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def path_sum(root, target):
    def dfs(root, target, path):
        if not root:
            return
        path.append(root.val)
        if sum(path) == target:
            res.append(path[:])
        dfs(root.left, target, path)
        dfs(root.right, target, path)
        path.pop()

    res = []
    dfs(root, target, [])
    return res

# 测试
root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(12, TreeNode(10), TreeNode(3)))
target = 22
print(path_sum(root, target))  # 输出:[[5, 10, 7]]
```

#### 14. 剑指 Offer 25. 合并两个排序的链表

**题目：** 合并两个排序的链表。

**解答：**

创建一个新的链表，比较两个链表的头节点，取较小值作为新链表的当前节点，然后移动该节点对应的链表指针。重复这个过程，直到其中一个链表为空。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

# 测试
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged = merge_sorted_lists(l1, l2)
while merged:
    print(merged.val, end=' ')
    merged = merged.next
# 输出:1 2 3 4 5 6
```

#### 15. 剑指 Offer 30. 包含min函数的栈

**题目：** 设计一个包含 min 函数的栈。

**解答：**

使用两个栈，一个用来存储正常的数据，另一个用来存储每个数据在当前栈中的最小值。

**代码示例：**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, x):
        self.stack.append(x)
        if not self.min_stack or x <= self.min_stack[-1]:
            self.min_stack.append(x)

    def pop(self):
        if self.stack:
            x = self.stack.pop()
            if x == self.min_stack[-1]:
                self.min_stack.pop()
            return x

    def top(self):
        if self.stack:
            return self.stack[-1]

    def min(self):
        if self.min_stack:
            return self.min_stack[-1]
```

#### 16. 剑指 Offer 59 - I. 滑动窗口的最大值

**题目：** 滑动窗口的最大值。

**解答：**

使用一个双端队列来维护滑动窗口中的最大值。遍历数组，对于每个元素，如果该元素比队列中的最后一个元素大，则将队列中的元素弹出，然后将当前元素加入队列。当队列不为空时，队列的头部即为当前滑动窗口的最大值。

**代码示例：**

```python
from collections import deque

def max_sliding_window(nums, k):
    if not nums or k <= 0:
        return []
    window = deque()
    res = []
    for i, num in enumerate(nums):
        while window and num > window[-1]:
            window.pop()
        window.append(num)
        if i >= k - 1:
            res.append(window[0])
            if window[0] == nums[i - k + 1]:
                window.popleft()
    return res

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(max_sliding_window(nums, k))  # 输出:[3, 3, 5, 5, 6, 7]
```

#### 17. 剑指 Offer 56 - II. 数组中数字出现的次数 II

**题目：** 一个整型数组 nums ，在数组中除了有两个数字只出现一次之外，其他数字都出现了三次。请找出这两个只出现一次的数字。

**解答：**

首先使用异或运算找出所有出现一次的数字，然后找出出现次数为3的数字之一。对于出现次数为3的数字之一，它可以表示为 `3x` 的形式，因此我们可以用这个数字与所有出现一次的数字进行异或操作，得到出现三次的数字之一。

**代码示例：**

```python
def single_even_num(nums):
    xor = 0
    for num in nums:
        xor ^= num
    return xor

def single_odd_num(nums):
    xor = single_even_num(nums)
    bit = xor & -xor
    even = 0
    odd = 0
    for num in nums:
        if (num & bit) == 0:
            even ^= num
        else:
            odd ^= num
    return even, odd

nums = [2, 2, 3, 2]
print(single_even_num(nums), single_odd_num(nums))  # 输出:(3, 4)
```

#### 18. 剑指 Offer 29. 顺时针打印矩阵

**题目：** 输入一个矩阵，按照从外圈到内圈，从外角到内角的顺序依次打印出每一个数字。

**解答：**

使用四个变量分别表示当前遍历的行和列的开始和结束位置，然后循环遍历矩阵，并依次打印出当前遍历的数字，然后更新四个变量的值。

**代码示例：**

```python
def print_matrix(matrix):
    rows, cols = len(matrix), len(matrix[0])
    start_row, start_col, end_row, end_col = 0, 0, rows - 1, cols - 1
    while start_row <= end_row and start_col <= end_col:
        for i in range(start_col, end_col + 1):
            print(matrix[start_row][i], end=' ')
        start_row += 1
        for i in range(start_row, end_row + 1):
            print(matrix[i][end_col], end=' ')
        end_col -= 1
        if start_row <= end_row:
            for i in range(end_col, start_col - 1, -1):
                print(matrix[end_row][i], end=' ')
            end_row -= 1
        if start_col <= end_col:
            for i in range(end_row, start_row - 1, -1):
                print(matrix[i][start_col], end=' ')
            start_col += 1
    print()

matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
]
print_matrix(matrix)
# 输出:1 2 3 6 9 8 7 4 5
```

#### 19. 剑指 Offer 57. 和为s的连续正数序列

**题目：** 输入一个和 s ，打印出和为 s 的连续正数序列。

**解答：**

从 1 开始，不断增加序列的长度，直到序列和大于 s 为止。每次增加序列的长度时，从序列中去掉最前面的一个元素。

**代码示例：**

```python
def find_sequence(s):
    sequence = []
    for i in range(1, s + 1):
        sequence.append(i)
        s -= i
        if s <= 0:
            break
    return sequence

s = 15
print(find_sequence(s))  # 输出:[1, 2, 3, 4, 5, 6, 7]
```

#### 20. 剑指 Offer 38. 字符串的排列

**题目：** 输入一个字符串，打印出字符串中所有的排列。

**解答：**

使用回溯算法，遍历字符串中的每个字符，将其与前面的字符进行交换，然后递归处理剩余的字符，直到处理完所有的字符。

**代码示例：**

```python
def permutation(s):
    def dfs(seq):
        if len(seq) == len(s):
            res.append(''.join(seq))
            return
        for i in range(len(seq)):
            if seq[i] in visited:
                continue
            visited.add(seq[i])
            seq[i], seq[len(seq) - 1] = seq[len(seq) - 1], seq[i]
            dfs(seq)
            seq[i], seq[len(seq) - 1] = seq[len(seq) - 1], seq[i]

    res = []
    seq = sorted(s)
    visited = set()
    dfs(seq)
    return res

s = "abc"
print(permutation(s))  # 输出：['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
```

### 总结

以上是小米校招技术面试中的一些经典题目及其解答。这些题目涵盖了数组、链表、字符串、二叉树、回溯、排序等多个方面，希望对准备参加小米校招的同学们有所帮助。在面试中，除了掌握算法和数据结构的基础知识外，还需要注重逻辑思维和解决问题的能力。希望这些题目能够帮助大家在面试中取得好成绩！

