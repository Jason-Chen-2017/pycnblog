                 

### 计算的极限：复杂性的简单算法

#### 题目 1：计算斐波那契数列

**题目描述：** 实现一个函数，计算斐波那契数列的第 n 项。

**算法思路：** 斐波那契数列的特点是每一项都是前两项之和，可以用递归或迭代的方式实现。

**答案解析：**

递归实现：

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}
```

迭代实现：

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

#### 题目 2：最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**算法思路：** 使用动态规划实现。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s1` 的前 `i` 个字符和字符串 `s2` 的前 `j` 个字符的最长公共子序列的长度。

**答案解析：**

```go
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

#### 题目 3：合并两个有序链表

**题目描述：** 给定两个有序链表，合并它们为一个新的有序链表。

**算法思路：** 使用两个指针分别遍历两个链表，比较当前节点值，将较小的值添加到新链表中，并移动对应的指针。

**答案解析：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 题目 4：查找旋转排序数组中的目标值

**题目描述：** 给定一个旋转排序的数组，查找目标值，并返回其索引。如果目标值不存在，返回 `-1`。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        // 判断左边是否有序
        if nums[left] < nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

#### 题目 5：设计哈希表

**题目描述：** 设计一个哈希表，实现基本的操作，如添加、删除和查找。

**算法思路：** 使用哈希表实现，包括链表和开地址法处理冲突。

**答案解析：**

```go
type HashTable struct {
    size int
    table [][]*Node
}

func (this *HashTable) put(key int, value int) {
    index := hash(key)
    this.table[index] = append(this.table[index], &Node{key, value})
}

func (this *HashTable) get(key int) int {
    index := hash(key)
    for _, node := range this.table[index] {
        if node.key == key {
            return node.value
        }
    }
    return -1
}

func hash(key int) int {
    return key % len(this.table)
}

type Node struct {
    key  int
    value int
}
```

#### 题目 6：两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**算法思路：** 使用哈希表记录数组中的每个数字和其对应的下标。

**答案解析：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        m[num] = i
    }
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok && j != i {
            return []int{i, j}
        }
    }
    return []int{}
}
```

#### 题目 7：两数乘积小于 K

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，找出数组中两数乘积小于 `k` 的所有组合。

**算法思路：** 使用双指针遍历数组，找到符合条件的组合。

**答案解析：**

```go
func twoSumLessThan(nums []int, k int) int {
    ans := -1
    left, right := 0, len(nums)-1
    for left < right {
        product := nums[left] * nums[right]
        if product < k {
            ans = product
            left++
        } else {
            right--
        }
    }
    return ans
}
```

#### 题目 8：三数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中三个元素的和为目标值的那三个元素。

**算法思路：** 使用哈希表记录数组中的每个数字和其对应的下标。

**答案解析：**

```go
func threeSum(nums []int, target int) [][]int {
    m := make(map[int]int)
    res := [][]int{}
    for i, num := range nums {
        m[num] = i
    }
    for i := range nums {
        for j := i + 1; j < len(nums); j++ {
            complement := target - nums[i] - nums[j]
            if j2, ok := m[complement]; ok && j2 != i && j2 != j {
                res = append(res, []int{nums[i], nums[j], complement})
                break
            }
        }
    }
    return res
}
```

#### 题目 9：四数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中四个元素的和为目标值的那四个元素。

**算法思路：** 使用哈希表记录数组中的每个数字和其对应的下标。

**答案解析：**

```go
func fourSum(nums []int, target int) [][]int {
    m := make(map[int]int)
    res := [][]int{}
    for i, num := range nums {
        m[num] = i
    }
    for i := range nums {
        for j := i + 1; j < len(nums); j++ {
            for k := j + 1; k < len(nums); k++ {
                complement := target - nums[i] - nums[j] - nums[k]
                if k2, ok := m[complement]; ok && k2 != i && k2 != j && k2 != k {
                    res = append(res, []int{nums[i], nums[j], nums[k], complement})
                    break
                }
            }
        }
    }
    return res
}
```

#### 题目 10：寻找旋转排序数组中的最小值

**题目描述：** 给你一个旋转排序的数组 nums ，数组可能包含重复的元素，找出并返回数组中的最小元素。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func findMin(nums []int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 题目 11：寻找旋转排序数组中的唯一元素

**题目描述：** 给你一个旋转排序的数组 nums ，数组可能包含重复的元素，找出并返回数组中的唯一元素。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func findPeakElement(nums []int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[mid+1] {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}
```

#### 题目 12：删除排序数组中的重复项

**题目描述：** 给你一个有序数组 `nums` ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

**算法思路：** 使用双指针遍历数组，一个指针用于遍历原数组，一个指针用于记录新数组的当前位置。

**答案解析：**

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    j := 0
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[j] {
            j++
            nums[j] = nums[i]
        }
    }
    return j + 1
}
```

#### 题目 13：移动零

**题目描述：** 给定一个数组 `nums`，编写一个函数来移动所有 0 到数组的末尾，同时保持非零元素的相对顺序。

**算法思路：** 使用双指针遍历数组，一个指针用于遍历原数组，一个指针用于记录非零元素的当前位置。

**答案解析：**

```go
func moveZeroes(nums []int) {
    j := 0
    for i := 0; i < len(nums); i++ {
        if nums[i] != 0 {
            nums[j] = nums[i]
            j++
        }
    }
    for i := j; i < len(nums); i++ {
        nums[i] = 0
    }
}
```

#### 题目 14：环形数组循环移动

**题目描述：** 给你一个数组 `nums` 和一个整数 `k` 。请你返回 `nums` 的子数组中所有元素的和都小于或等于 `x` 的最长子数组的长度。

**算法思路：** 使用双指针遍历数组，一个指针用于遍历原数组，一个指针用于记录当前子数组的起始位置。

**答案解析：**

```go
func longestSubarray(nums []int, k int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    j := 0
    maxLen := 0
    for i := 0; i < n; i++ {
        for ; j < n && nums[j] < k; j++ {
        }
        if j-i > maxLen {
            maxLen = j - i
        }
        if j == n {
            break
        }
        j++
    }
    return maxLen
}
```

#### 题目 15：寻找旋转数组中的最小值 II

**题目描述：** 给定一个可能包含重复元素的整数数组 `nums`，找出并返回数组中的所有旋转索引。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] == nums[mid] && nums[right] == nums[mid] {
            left++
            right--
        } else if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

#### 题目 16：有序数组中的单一元素

**题目描述：** 给你一个已排序的整数数组 `nums` ，其中可能包含多个相同的元素，请你找出并返回数组中的单一元素。

**算法思路：** 使用二分查找算法，但需要特殊处理单一元素的情况。

**答案解析：**

```go
func singleNonDuplicate(nums []int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == nums[mid^1] {
            if mid%2 == 0 {
                left = mid + 1
            } else {
                right = mid - 1
            }
        } else {
            if mid%2 == 0 {
                right = mid - 1
            } else {
                left = mid + 1
            }
        }
    }
    return nums[left]
}
```

#### 题目 17：寻找旋转数组中的最小值 III

**题目描述：** 给定一个大小为 n 的整数数组 `nums` ，判断是否存在三个下标 `i`、`j` 和 `k` ，使得 `nums[i]`、`nums[j]` 和 `nums[k]` 严格递增，并且 `i < j < k` 。

**算法思路：** 使用双指针遍历数组，一个指针用于遍历原数组，一个指针用于记录当前子数组的起始位置。

**答案解析：**

```go
func increasingTriplet(nums []int) bool {
    if len(nums) < 3 {
        return false
    }
    first, second := nums[0], nums[1]
    for i := 2; i < len(nums); i++ {
        if nums[i] > second {
            return true
        }
        if nums[i] > first {
            second = nums[i]
        } else {
            first = nums[i]
        }
    }
    return false
}
```

#### 题目 18：最小路径和

**题目描述：** 给你一个 `m x n` 网格 `grid` ，其中 `grid[i][j]` 是网格 `grid` 中的路径点（单元格）的数值，现在从点的（`0,0`）开始，每次可以向下或者向右移动一步，直到到达点（`m-1, n-1`）。返回通过网格的一个路径的最小和。

**算法思路：** 使用动态规划实现，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示到达点 `(i, j)` 的最小路径和。

**答案解析：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}
```

#### 题目 19：搜索二维矩阵

**题目描述：** 写一个函数，搜索二维矩阵，并判断一个给定的数是否存在矩阵中。

**算法思路：** 使用二分查找算法，将矩阵看成一个一维数组，根据数组的中间元素判断目标值的位置，递归或迭代地缩小搜索范围。

**答案解析：**

递归实现：

```go
func searchMatrix(matrix [][]int, target int) bool {
    n := len(matrix)
    m := len(matrix[0])
    return search(matrix, target, 0, n-1, 0, m-1)
}

func search(matrix [][]int, target, row1, row2, col1, col2 int) bool {
    if row1 > row2 || col1 > col2 {
        return false
    }
    midRow := (row1 + row2) / 2
    midCol := (col1 + col2) / 2
    if matrix[midRow][midCol] == target {
        return true
    } else if matrix[midRow][midCol] < target {
        if midRow < row2 && matrix[midRow+1][midCol] >= target {
            return search(matrix, target, midRow+1, row2, col1, midCol)
        }
        return search(matrix, target, row1, midRow-1, midCol+1, col2)
    } else {
        if midRow > row1 && matrix[midRow-1][midCol] <= target {
            return search(matrix, target, midRow-1, row1, midCol-1, col1)
        }
        return search(matrix, target, row1, midRow+1, col1, midCol)
    }
}
```

迭代实现：

```go
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    row, col := 0, n-1
    for row < m && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] < target {
            row++
        } else {
            col--
        }
    }
    return false
}
```

#### 题目 20：二分查找

**题目描述：** 实现一个二分查找函数，在排序数组中查找一个特定的元素。

**算法思路：** 使用二分查找算法，不断将搜索范围缩小。

**答案解析：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

#### 题目 21：有序数组中的单一元素

**题目描述：** 给定一个有序数组，其中恰好有一个重复的元素，找出这个重复的元素。

**算法思路：** 使用二分查找算法，但需要特殊处理重复元素的情况。

**答案解析：**

```go
func singleNonDuplicate(nums []int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == nums[mid^1] {
            if mid%2 == 0 {
                left = mid + 1
            } else {
                right = mid - 1
            }
        } else {
            if mid%2 == 0 {
                right = mid - 1
            } else {
                left = mid + 1
            }
        }
    }
    return nums[left]
}
```

#### 题目 22：搜索旋转排序数组

**题目描述：** 给定一个旋转后排序的数组，实现一个函数查找给定的目标值是否存在于数组中。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func search(nums []int, target int) bool {
    n := len(nums)
    left, right := 0, n-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return true
        }
        if nums[left] < nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return false
}
```

#### 题目 23：寻找旋转排序数组中的最小值

**题目描述：** 给定一个旋转后排序的数组，找出并返回数组中的最小元素。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func findMin(nums []int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 题目 24：寻找旋转排序数组中的唯一元素

**题目描述：** 给定一个旋转后排序的数组，找出并返回数组中的唯一元素。

**算法思路：** 使用二分查找算法，但需要特殊处理旋转的情况。

**答案解析：**

```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == nums[left] && nums[mid] == nums[right] {
            left++
            right--
        } else if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 题目 25：旋转图像

**题目描述：** 给定一个 `n x n` 的二维矩阵 `matrix` 表示一个图像，请你将图像顺时针旋转 90 度。

**算法思路：** 按层遍历矩阵，将每层的元素按照逆时针方向旋转 90 度。

**答案解析：**

```go
func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := i; j < n-i-1; j++ {
            temp := matrix[i][j]
            matrix[i][j] = matrix[n-1-j][i]
            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]
            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]
            matrix[j][n-1-i] = temp
        }
    }
}
```

#### 题目 26：翻转图像

**题目描述：** 给定一个二进制矩阵 `matrix`，返回一个新矩阵，且每行中的 0 都应当被移动到行的末尾，同时保持其原始顺序。

**算法思路：** 使用双指针遍历矩阵，将每行的 0 移动到行末尾。

**答案解析：**

```go
func flipAndInvertImage(matrix [][]int) [][]int {
    m, n := len(matrix), len(matrix[0])
    for i := 0; i < m; i++ {
        left, right := 0, n-1
        for left < right {
            matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]
            left++
            right--
        }
        for j := 0; j < n; j++ {
            if matrix[i][j] == 0 {
                matrix[i][j] = 1
            } else {
                matrix[i][j] = 0
            }
        }
    }
    return matrix
}
```

#### 题目 27：合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**算法思路：** 从后向前比较两个数组中的元素，将较大的元素放到 `nums1` 的末尾。

**答案解析：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p3 := m-1, n-1, m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p3] = nums1[p1]
            p1--
        } else {
            nums1[p3] = nums2[p2]
            p2--
        }
        p3--
    }
    for p2 >= 0 {
        nums1[p3] = nums2[p2]
        p2--
        p3--
    }
}
```

#### 题目 28：合并区间

**题目描述：** 给定一组区间，找到它们交集形成的区间。

**算法思路：** 对区间按照起始点排序，然后遍历区间，合并重叠的区间。

**答案解析：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

#### 题目 29：最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**算法思路：** 使用动态规划实现，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s1` 的前 `i` 个字符和字符串 `s2` 的前 `j` 个字符的最长公共子序列的长度。

**答案解析：**

```go
func longestCommonSubsequence(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var ans []byte
    i, j := m, n
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            ans = append(ans, s1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(ans)
    return string(ans)
}
```

#### 题目 30：最长公共子串

**题目描述：** 给定两个字符串，找出它们的最长公共子串。

**算法思路：** 使用动态规划实现，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s1` 的前 `i` 个字符和字符串 `s2` 的前 `j` 个字符的最长公共子串的长度。

**答案解析：**

```go
func longestCommonSubstring(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen := 0
    maxI := 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    maxI = i
                }
            }
        }
    }
    var ans []byte
    for i := maxI - maxLen; i < maxI; i++ {
        ans = append(ans, s1[i])
    }
    reverse(ans)
    return string(ans)
}
```

### 总结

在本章中，我们介绍了计算领域的复杂性的简单算法。通过解析一系列典型的高频面试题和算法编程题，我们详细展示了如何使用递归、动态规划、二分查找等算法来解决问题。这些算法不仅在面试中经常出现，也是实际工作中解决复杂问题的重要工具。希望读者通过这些示例能够加深对算法的理解，并在实际编码中灵活运用。下一章，我们将继续探索更复杂的算法问题，敬请期待。

