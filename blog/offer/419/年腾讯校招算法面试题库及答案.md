                 

### 2025年腾讯校招算法面试题库及答案

#### 1. 最长公共子序列

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子序列。返回最长公共子序列的长度。

**示例：**
```
输入：s1 = "abcde", s2 = "ace" 
输出：3 
说明：最长公共子序列为 "ace"，所以返回 3。
```

**答案解析：** 
使用动态规划解决最长公共子序列问题。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列长度。

状态转移方程：
```
if s1[i - 1] == s2[j - 1]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```

初始化：
```
dp[0][j] = 0
dp[i][0] = 0
```

时间复杂度：O(m*n)，空间复杂度：O(m*n)

**源代码示例：**
```go
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 2. 合并两个有序链表

**题目描述：** 给定两个有序链表 `l1` 和 `l2`，将它们合并成一个有序链表并返回。如果链表长度不相等，则返回较长的链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**
使用两个指针遍历两个链表，每次选择较小的节点添加到结果链表中，然后移动指针。

时间复杂度：O(m+n)，空间复杂度：O(1)

**源代码示例：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

#### 3. 二进制求和

**题目描述：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**
```
输入：a = "11", b = "1"
输出："100"
```

**答案解析：**
将二进制字符串转换为整数，进行求和，然后将结果转换为二进制字符串。

时间复杂度：O(max(m, n))，空间复杂度：O(max(m, n))

**源代码示例：**
```go
func addBinary(a string, b string) string {
    x, _ := strconv.ParseInt(a, 2, 64)
    y, _ := strconv.ParseInt(b, 2, 64)
    z := x + y
    return strconv.FormatInt(z, 2)
}
```

#### 4. 二叉树的层序遍历

**题目描述：** 给定一个二叉树，返回其层序遍历结果。

**示例：**
```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**答案解析：**
使用广度优先搜索（BFS）进行层序遍历。使用队列存储每一层的节点，然后逐层遍历。

时间复杂度：O(n)，空间复杂度：O(n)

**源代码示例：**
```go
func levelOrder(root *TreeNode) [][]int {
    var ans [][]int
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        var t [][]int
        n := len(q)
        for i := 0; i < n; i++ {
            node := q[0]
            q = q[1:]
            t = append(t, []int{node.Val})
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, t...)
    }
    return ans
}

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

#### 5. 字符串转换整数 (atoi)

**题目描述：** 实现一个 `atoi` 函数，它可以将字符串转换为整数。

**示例：**
```
输入：s = "42"
输出：42
```

**答案解析：**
使用字符串遍历方法，对字符串进行操作，遇到非数字字符时停止。

时间复杂度：O(n)，空间复杂度：O(1)

**源代码示例：**
```go
func myAtoi(s string) int {
    sign := 1
    num := 0
    i := 0
    n := len(s)
    if n == 0 {
        return 0
    }
    if s[0] == '-' {
        sign = -1
        i++
    } else if s[0] == '+' {
        i++
    }
    for ; i < n; i++ {
        if s[i] < '0' || s[i] > '9' {
            break
        }
        num = num*10 + int(s[i]-'0')
        if num < 0 {
            return sign * int(^uint(0) >> 1)
        }
    }
    return sign * num
}
```

#### 6. 罗马数字转整数

**题目描述：** 给定一个罗马数字，转换为整数。

**示例：**
```
输入：s = "III"
输出：3
```

**答案解析：**
定义一个哈希表存储罗马数字和对应的整数，然后遍历字符串，计算结果。

时间复杂度：O(n)，空间复杂度：O(1)

**源代码示例：**
```go
func romanToInt(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    ans := 0
    for i := 0; i < len(s); i++ {
        v1 := m[s[i]]
        if i+1 < len(s) && v1 < m[s[i+1]] {
            ans -= v1
        } else {
            ans += v1
        }
    }
    return ans
}
```

#### 7. 最长公共前缀

**题目描述：** 给定一个字符串数组，找到它们的公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案解析：**
从第一个字符串开始，逐个比较后续字符串，找出它们的公共前缀。

时间复杂度：O(m*n)，空间复杂度：O(1)

**源代码示例：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, s := range strs {
        for i, j := 0, 0; i < len(prefix) && j < len(s); i, j = i+1, j+1 {
            if prefix[i] != s[j] {
                break
            }
        }
        prefix = prefix[:i]
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}
```

#### 8. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将它们合并成一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**
从后向前比较两个数组中的元素，将较大的元素放入 `nums1` 的最后。

时间复杂度：O(m+n)，空间复杂度：O(1)

**源代码示例：**
```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

#### 9. 爬楼梯

**题目描述：** 一个楼梯总共有 `n` 阶台阶，每次可以爬 1 或 2 个台阶，求爬到楼顶的方法数。

**示例：**
```
输入：n = 3
输出：3
说明：有三种方法可以爬到楼顶，分别是：1+1+1、1+2、2+1。
```

**答案解析：**
使用动态规划求解。定义一个数组 `dp`，其中 `dp[i]` 表示爬到第 `i` 阶台阶的方法数。状态转移方程为：
```
dp[i] = dp[i-1] + dp[i-2]
```

初始化：
```
dp[0] = 1
dp[1] = 1
```

时间复杂度：O(n)，空间复杂度：O(n)

**源代码示例：**
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    dp := make([]int, n)
    dp[0], dp[1] = 1, 1
    for i := 2; i < n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n-1]
}
```

#### 10. 最长回文子串

**题目描述：** 给定一个字符串，找出最长的回文子串。

**示例：**
```
输入：s = "babad"
输出："bab"
说明："aba" 也是回文子串，但比 "bab" 更长。
```

**答案解析：**
使用中心扩展算法。对于每个字符，将其作为回文串的中心，向两边扩展，找到最长的回文子串。

时间复杂度：O(n^2)，空间复杂度：O(1)

**源代码示例：**
```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, mx := 0, 1
    for i := 0; i < n; i++ {
        l, r := i, i
        if i+1 < n && s[i] == s[i+1] {
            l, r = i, i+1
        }
        for l >= 0 && r < n && s[l] == s[r] {
            if r-l+1 > mx {
                mx = r - l + 1
                start = l
            }
            l--
            r++
        }
    }
    return s[start : start+mx]
}
```

#### 11. 搜索旋转排序数组

**题目描述：** 给定一个旋转后排列的数组 `nums` ，请返回其中最小的元素。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2]
输出：0
```

**答案解析：**
使用二分查找法。在旋转后的数组中，最小的元素一定位于中间部分或左半部分，因此可以通过二分查找找到。

时间复杂度：O(log n)，空间复杂度：O(1)

**源代码示例：**
```go
func findMin(nums []int) int {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 12. 盛最多水的容器

**题目描述：** 给定一个非空数组 `nums` ，返回其中最大矩形面积。

**示例：**
```
输入：nums = [1,8,6,2,5,4,8,3,7]
输出：6 * 4 = 24
```

**答案解析：**
使用单调栈方法。遍历数组，使用栈存储下标的索引，栈中元素按照从栈底到栈顶的顺序递增。对于当前遍历到的下标 `i`，从栈顶弹出所有小于 `nums[i]` 的下标，计算最大矩形面积。

时间复杂度：O(n)，空间复杂度：O(n)

**源代码示例：**
```go
func largestRectangleArea(nums []int) int {
    n := len(nums)
    var stk []int
    ans := 0
    for i := 0; i <= n || len(stk) > 0; i++ {
        for len(stk) > 0 && (i == n || nums[stk[len(stk)-1]] <= nums[i]) {
            height := nums[stk[len(stk)-1]]
            stk = stk[:len(stk)-1]
            if len(stk) == 0 {
                width := i
            } else {
                width := i - stk[len(stk)-1] - 1
            }
            ans = max(ans, height*width)
        }
        stk = append(stk, i)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 13. 合并两个有序链表

**题目描述：** 给定两个有序链表，将它们合并成一个有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**
使用两个指针遍历两个链表，每次选择较小的节点添加到结果链表中，然后移动指针。

时间复杂度：O(m+n)，空间复杂度：O(1)

**源代码示例：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

#### 14. 合并K个排序链表

**题目描述：** 给定 `k` 个排序链表，将它们合并成一个排序链表。

**示例：**
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
```

**答案解析：**
使用优先级队列（最小堆）进行合并。将所有链表的头节点加入优先级队列，然后不断从队列中取出最小的节点，将其后续节点加入队列，直到队列为空。

时间复杂度：O(nlogk)，空间复杂度：O(k)

**源代码示例：**
```go
type Node struct {
    Val  int
    Next *Node
}

func mergeKLists(lists []*Node) *Node {
    if len(lists) == 0 {
        return nil
    }
    dummy := &Node{}
    curr := dummy
    heap := &priorityQueue{}
    for _, l := range lists {
        if l != nil {
            heap.push(l)
        }
    }
    for heap.Len() > 0 {
        node := heap.pop()
        curr.Next = node
        curr = curr.Next
        if node.Next != nil {
            heap.push(node.Next)
        }
    }
    return dummy.Next
}

type priorityQueue struct {
    heap []interface{}
}

func (pq *priorityQueue) push(v interface{}) {
    pq.heap = append(pq.heap, v)
    pq.siftUp(len(pq.heap) - 1)
}

func (pq *priorityQueue) pop() interface{} {
    n := len(pq.heap)
    if n == 0 {
        return nil
    }
    v := pq.heap[0]
    pq.heap[0] = pq.heap[n-1]
    pq.heap = pq.heap[:n-1]
    pq.siftDown(0)
    return v
}

func (pq *priorityQueue) siftUp(i int) {
    for {
        left := 2*i + 1
        if left >= len(pq.heap) {
            break
        }
        right := left + 1
        if right < len(pq.heap) && pq.heap[right].(*Node).Val < pq.heap[left].(*Node).Val {
            left = right
        }
        if pq.heap[left].(*Node).Val < pq.heap[i].(*Node).Val {
            pq.heap[left], pq.heap[i] = pq.heap[i], pq.heap[left]
            i = left
        } else {
            break
        }
    }
}

func (pq *priorityQueue) siftDown(i int) {
    for {
        left := 2*i + 1
        if left >= len(pq.heap) {
            break
        }
        right := left + 1
        if right < len(pq.heap) && pq.heap[right].(*Node).Val < pq.heap[left].(*Node).Val {
            left = right
        }
        if pq.heap[left].(*Node).Val >= pq.heap[i].(*Node).Val {
            break
        }
        pq.heap[left], pq.heap[i] = pq.heap[i], pq.heap[left]
        i = left
    }
}
```

#### 15. 三数之和

**题目描述：** 给定一个整数数组 `nums` ，返回所有满足 `i < j < k` 的三元组 `[nums[i], nums[j], nums[k]]` ，且 `nums[i] + nums[j] + nums[k] == 0` 。

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案解析：**
使用哈希表或双指针方法。首先对数组进行排序，然后遍历数组，对于每个元素，使用双指针方法找出满足条件的三元组。

时间复杂度：O(n^2)，空间复杂度：O(n)

**源代码示例：**
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var ans [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}
```

#### 16. 四数之和

**题目描述：** 给定一个整数数组 `nums` ，返回所有满足 `i < j < k < l` 的四元组 `[nums[i], nums[j], nums[k], nums[l]]` ，使得这四个数字之和等于 `0` 。

**示例：**
```
输入：nums = [1,0,-1,0,-2,2]
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**答案解析：**
使用哈希表或双指针方法。首先对数组进行排序，然后遍历数组，对于每个元素，使用双指针方法找出满足条件的四元组。

时间复杂度：O(n^3)，空间复杂度：O(n)

**源代码示例：**
```go
func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    var ans [][]int
    for i := 0; i < len(nums)-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        for j := i + 1; j < len(nums)-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            left, right := j+1, len(nums)-1
            for left < right {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum == target {
                    ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]})
                    for left < right && nums[left] == nums[left+1] {
                        left++
                    }
                    for left < right && nums[right] == nums[right-1] {
                        right--
                    }
                    left++
                    right--
                } else if sum < target {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    return ans
}
```

#### 17. 二叉树的层序遍历 II

**题目描述：** 给你一个二叉树，请你返回其按层序遍历后的二叉树，每层节点按顺序排列，且上一层的节点位于下一层节点左侧。

**示例：**
```
输入：root = [1,2,3,4,5,6,7]
输出：[[1],[2,3],[4,5,6,7]]
```

**答案解析：**
使用广度优先搜索（BFS）进行层序遍历。在遍历过程中，将每一层的节点存储在一个列表中，然后反转列表。

时间复杂度：O(n)，空间复杂度：O(n)

**源代码示例：**
```go
func levelOrderBottom(root *TreeNode) [][]int {
    var ans [][]int
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        var t [][]int
        n := len(q)
        for i := 0; i < n; i++ {
            node := q[0]
            q = q[1:]
            t = append(t, []int{node.Val})
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, t...)
    }
    reverse(ans)
    return ans
}

func reverse(s [][]int) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

#### 18. 搜索旋转排序数组 II

**题目描述：** 给你一个可能包含重复元素的整数数组 `nums` ，请你编写一个函数来检查该数组是否能够变成一个递增的数组。

**示例：**
```
输入：nums = [1,2,3,1]
输出：false
```

**答案解析：**
使用二分查找法。在旋转后的数组中，最小的元素一定位于中间部分或左半部分。通过二分查找找到最小元素的位置，然后判断该位置是否大于 1。

时间复杂度：O(log n)，空间复杂度：O(1)

**源代码示例：**
```go
func checkIfSorted(nums []int) bool {
    n := len(nums)
    left, right := 0, n-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == nums[right] {
            right--
        } else if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left >= 1 && nums[left-1] < nums[left]
}
```

#### 19. 最长公共子序列

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找出它们的最长公共子序列。

**示例：**
```
输入：s1 = "abcde", s2 = "ace"
输出："ace"
```

**答案解析：**
使用动态规划方法。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列长度。

状态转移方程：
```
if s1[i - 1] == s2[j - 1]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```

时间复杂度：O(m*n)，空间复杂度：O(m*n)

**源代码示例：**
```go
func longestCommonSubsequence(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var ans string
    i, j := m, n
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            ans = string(s1[i-1]) + ans
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 20. 合并两个有序链表

**题目描述：** 给定两个有序链表，将它们合并成一个有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**
使用两个指针遍历两个链表，每次选择较小的节点添加到结果链表中，然后移动指针。

时间复杂度：O(m+n)，空间复杂度：O(1)

**源代码示例：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

#### 21. 螺旋矩阵

**题目描述：** 给定一个 `m x n` 的矩阵 `matrix` ，按照顺时针螺旋顺序返回矩阵中的元素。

**示例：**
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**答案解析：**
使用模拟方法。定义四个指针 `top`, `bottom`, `left`, `right`，分别表示当前层的顶部、底部、左侧和右侧边界。每次循环遍历一层，然后更新边界。

时间复杂度：O(m*n)，空间复杂度：O(1)

**源代码示例：**
```go
func spiralOrder(matrix [][]int) []int {
    var ans []int
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return ans
    }
    m, n := len(matrix), len(matrix[0])
    top, bottom, left, right := 0, m-1, 0, n-1
    for {
        for j := left; j <= right; j++ {
            ans = append(ans, matrix[top][j])
        }
        top++
        if top > bottom {
            break
        }
        for i := top; i <= bottom; i++ {
            ans = append(ans, matrix[i][right])
        }
        right--
        if left > right {
            break
        }
        for j := right; j >= left; j-- {
            ans = append(ans, matrix[bottom][j])
        }
        bottom--
        if top > bottom {
            break
        }
        for i := bottom; i >= top; i-- {
            ans = append(ans, matrix[i][left])
        }
        left++
        if left > right {
            break
        }
    }
    return ans
}
```

#### 22. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 `head` 和一个整数 `val`，删除链表中值为 `val` 的节点。

**示例：**
```
输入：head = [4,5,1,9], val = 5
输出：[4,1,9]
```

**答案解析：**
使用虚拟头节点的方法，避免处理头节点的情况。遍历链表，找到值为 `val` 的节点的前一个节点，将其指向下一个节点。

时间复杂度：O(n)，空间复杂度：O(1)

**源代码示例：**
```go
func deleteNode(head *ListNode, val int) *ListNode {
    dummy := &ListNode{Val: 0, Next: head}
    prev := dummy
    for prev.Next != nil && prev.Next.Val != val {
        prev = prev.Next
    }
    if prev.Next != nil {
        prev.Next = prev.Next.Next
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

#### 23. 最小栈

**题目描述：** 设计一个支持 `push` 、 `pop` 、 `top` 操作，并能在常数时间内检索到最小元素的栈。

**示例：**
```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[(-2)], [--2], [--2], [], [], [], []]
输出：
[null,null,null,null,-2,null,0,-2]
```

**答案解析：**
使用两个栈，一个用于存储所有元素，另一个用于存储最小元素。

时间复杂度：O(1)，空间复杂度：O(n)

**源代码示例：**
```go
type MinStack struct {
    stack1 []int
    stack2 []int
}

func Constructor() MinStack {
    return MinStack{[]int{}, []int{}}
}

func (this *MinStack) Push(val int) {
    this.stack1 = append(this.stack1, val)
    if len(this.stack2) == 0 || val <= this.stack2[len(this.stack2)-1] {
        this.stack2 = append(this.stack2, val)
    }
}

func (this *MinStack) Pop() {
    if this.stack1[len(this.stack1)-1] == this.stack2[len(this.stack2)-1] {
        this.stack2 = this.stack2[:len(this.stack2)-1]
    }
    this.stack1 = this.stack1[:len(this.stack1)-1]
}

func (this *MinStack) Top() int {
    return this.stack1[len(this.stack1)-1]
}

func (this *MinStack) GetMin() int {
    return this.stack2[len(this.stack2)-1]
}
```

#### 24. 盛水的容器

**题目描述：** 给定一个二进制矩阵 `mat`，找到矩阵中的最大岛屿面积。

**示例：**
```
输入：
mat = [
    [1, 0, 0, 0, 0],
    [1, 0, 1, 1, 1],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1]
]

输出：12
说明：最大的岛屿面积为 12，由红色矩形标记。
```

**答案解析：**
使用深度优先搜索（DFS）或并查集方法。对于每个岛屿，找到岛屿的边界，计算岛屿的面积。

时间复杂度：O(m*n)，空间复杂度：O(m*n)

**源代码示例：**
```go
func maxAreaOfIsland(mat [][]int) int {
    m, n := len(mat), len(mat[0])
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || i >= m || j < 0 || j >= n || mat[i][j] == 0 {
            return 0
        }
        mat[i][j] = 0
        area := 1
        area += dfs(i+1, j)
        area += dfs(i-1, j)
        area += dfs(i, j+1)
        area += dfs(i, j-1)
        return area
    }
    var maxArea int
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if mat[i][j] == 1 {
                maxArea = max(maxArea, dfs(i, j))
            }
        }
    }
    return maxArea
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 25. 合并两个有序链表

**题目描述：** 给定两个有序链表，将它们合并成一个有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**
使用两个指针遍历两个链表，每次选择较小的节点添加到结果链表中，然后移动指针。

时间复杂度：O(m+n)，空间复杂度：O(1)

**源代码示例：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

#### 26. 合并K个排序链表

**题目描述：** 给定 `k` 个排序链表，将它们合并成一个排序链表。

**示例：**
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
```

**答案解析：**
使用优先级队列（最小堆）进行合并。将所有链表的头节点加入优先级队列，然后不断从队列中取出最小的节点，将其后续节点加入队列，直到队列为空。

时间复杂度：O(nlogk)，空间复杂度：O(k)

**源代码示例：**
```go
type Node struct {
    Val  int
    Next *Node
}

func mergeKLists(lists []*Node) *Node {
    if len(lists) == 0 {
        return nil
    }
    dummy := &Node{}
    curr := dummy
    heap := &priorityQueue{}
    for _, l := range lists {
        if l != nil {
            heap.push(l)
        }
    }
    for heap.Len() > 0 {
        node := heap.pop()
        curr.Next = node
        curr = curr.Next
        if node.Next != nil {
            heap.push(node.Next)
        }
    }
    return dummy.Next
}

type priorityQueue struct {
    heap []interface{}
}

func (pq *priorityQueue) push(v interface{}) {
    pq.heap = append(pq.heap, v)
    pq.siftUp(len(pq.heap) - 1)
}

func (pq *priorityQueue) pop() interface{} {
    n := len(pq.heap)
    if n == 0 {
        return nil
    }
    v := pq.heap[0]
    pq.heap[0] = pq.heap[n-1]
    pq.heap = pq.heap[:n-1]
    pq.siftDown(0)
    return v
}

func (pq *priorityQueue) siftUp(i int) {
    for {
        left := 2*i + 1
        if left >= len(pq.heap) {
            break
        }
        right := left + 1
        if right < len(pq.heap) && pq.heap[right].(*Node).Val < pq.heap[left].(*Node).Val {
            left = right
        }
        if pq.heap[left].(*Node).Val < pq.heap[i].(*Node).Val {
            pq.heap[left], pq.heap[i] = pq.heap[i], pq.heap[left]
            i = left
        } else {
            break
        }
    }
}

func (pq *priorityQueue) siftDown(i int) {
    for {
        left := 2*i + 1
        if left >= len(pq.heap) {
            break
        }
        right := left + 1
        if right < len(pq.heap) && pq.heap[right].(*Node).Val < pq.heap[left].(*Node).Val {
            left = right
        }
        if pq.heap[left].(*Node).Val >= pq.heap[i].(*Node).Val {
            break
        }
        pq.heap[left], pq.heap[i] = pq.heap[i], pq.heap[left]
        i = left
    }
}
```

#### 27. 三数之和

**题目描述：** 给定一个整数数组 `nums` ，返回所有满足 `i < j < k` 的三元组 `[nums[i], nums[j], nums[k]]` ，使得这个三元组和为 `0` 。

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案解析：**
使用双指针方法。首先对数组进行排序，然后遍历数组，对于每个元素，使用双指针方法找出满足条件的三元组。

时间复杂度：O(n^2)，空间复杂度：O(1)

**源代码示例：**
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var ans [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}
```

#### 28. 四数之和

**题目描述：** 给定一个整数数组 `nums` ，返回所有满足 `i < j < k < l` 的四元组 `[nums[i], nums[j], nums[k], nums[l]]` ，使得这四个数字的和为 `0` 。

**示例：**
```
输入：nums = [1,0,-1,0,-2,2]
输出：[[-2,-1,0,1],[-2,0,0,2]]
```

**答案解析：**
使用双指针方法。首先对数组进行排序，然后遍历数组，对于每个元素，使用双指针方法找出满足条件的四元组。

时间复杂度：O(n^3)，空间复杂度：O(1)

**源代码示例：**
```go
func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    var ans [][]int
    for i := 0; i < len(nums)-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        for j := i + 1; j < len(nums)-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            left, right := j+1, len(nums)-1
            for left < right {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum == target {
                    ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]})
                    for left < right && nums[left] == nums[left+1] {
                        left++
                    }
                    for left < right && nums[right] == nums[right-1] {
                        right--
                    }
                    left++
                    right--
                } else if sum < target {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    return ans
}
```

#### 29. 螺旋矩阵

**题目描述：** 给你一个 `m x n` 的矩阵 `matrix` ，请你返回 `matrix` 的螺旋有序遍历。

**示例：**
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**答案解析：**
使用模拟方法。定义四个指针 `top`, `bottom`, `left`, `right`，分别表示当前层的顶部、底部、左侧和右侧边界。每次循环遍历一层，然后更新边界。

时间复杂度：O(m*n)，空间复杂度：O(1)

**源代码示例：**
```go
func spiralOrder(matrix [][]int) []int {
    var ans []int
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return ans
    }
    m, n := len(matrix), len(matrix[0])
    top, bottom, left, right := 0, m-1, 0, n-1
    for {
        for j := left; j <= right; j++ {
            ans = append(ans, matrix[top][j])
        }
        top++
        if top > bottom {
            break
        }
        for i := top; i <= bottom; i++ {
            ans = append(ans, matrix[i][right])
        }
        right--
        if left > right {
            break
        }
        for j := right; j >= left; j-- {
            ans = append(ans, matrix[bottom][j])
        }
        bottom--
        if top > bottom {
            break
        }
        for i := bottom; i >= top; i-- {
            ans = append(ans, matrix[i][left])
        }
        left++
        if left > right {
            break
        }
    }
    return ans
}
```

#### 30. 翻转链表

**题目描述：** 反转一个单链表。

**示例：**
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**答案解析：**
使用迭代方法。定义一个虚拟头节点，遍历链表，将当前节点指向其前一个节点。

时间复杂度：O(n)，空间复杂度：O(1)

**源代码示例：**
```go
func reverseList(head *ListNode) *ListNode {
    var dummy *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = dummy
        dummy = curr
        curr = next
    }
    return dummy
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

### 总结

本篇博客详细介绍了腾讯校招算法面试题库及答案，包括最长公共子序列、合并两个有序链表、二进制求和、二叉树的层序遍历、字符串转换整数（atoi）、罗马数字转整数、最长公共前缀、合并两个有序数组、爬楼梯、最长回文子串、搜索旋转排序数组、盛最多水的容器、合并两个有序链表、合并K个排序链表、三数之和、四数之和、螺旋矩阵、删除链表的节点、最小栈、盛水的容器、合并两个有序链表、合并K个排序链表、三数之和、四数之和、螺旋矩阵、翻转链表等30道经典面试题的满分答案解析和源代码示例。通过学习和实践这些题目，可以提升算法和数据结构的能力，为求职和职业发展打下坚实的基础。

