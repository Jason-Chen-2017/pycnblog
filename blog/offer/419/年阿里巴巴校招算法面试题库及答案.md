                 

 #<|user|>### 2025年阿里巴巴校招算法面试题库及答案

在本文中，我们将深入探讨2025年阿里巴巴校招算法面试题库及答案。这些题目涵盖了算法和数据结构的核心概念，包括排序、查找、图论、动态规划等。以下是阿里巴巴校招算法面试题库及其详细解析。

#### 1. 最长递增子序列

**题目描述：** 给定一个无序数组，找出最长的递增子序列的长度。

**示例：** 输入：`[10, 9, 2, 5, 3, 7, 101, 18]`，输出：`4`。

**答案：** 使用动态规划。

```python
def lengthOfLIS(nums):
    n = len(nums)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**解析：** 我们用 `dp[i]` 表示以 `nums[i]` 为结尾的最长递增子序列的长度。遍历数组，对于每个元素 `nums[i]`，我们检查所有小于 `nums[i]` 的元素 `nums[j]`，更新 `dp[i]` 的值。

#### 2. 反转整数

**题目描述：** 给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

**示例：** 输入：`123`，输出：`321`；输入：`-123`，输出：`-321`。

**答案：** 使用取模和整除。

```python
def reverse(x):
    sign = 1 if x >= 0 else -1
    x = abs(x)
    rev = 0
    while x:
        rev = rev * 10 + x % 10
        x = x // 10
    return sign * rev
```

**解析：** 我们通过取模获取 `x` 的个位数，然后将其加到 `rev` 上，通过整除操作去掉 `x` 的个位数。

#### 3. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：** 输入：`[2, 7, 11, 15]`，`target = 9`，输出：`[0, 1]`。

**答案：** 使用哈希表。

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

**解析：** 我们遍历数组，对于每个元素 `num`，我们计算其补数 `complement`，然后在哈希表中查找 `complement`。如果找到了，返回当前下标和 `complement` 的下标。

#### 4. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** 输入：`l1 = [1, 2, 4]`，`l2 = [1, 3, 4]`，输出：`[1, 1, 2, 3, 4, 4]`。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**解析：** 我们比较两个链表的头节点，选择较小的值，将其连接到结果链表，并递归处理剩余部分。

#### 5. 合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：** 输入：`intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]`，输出：`[[1, 6], [8, 10], [15, 18]]`。

**答案：** 使用排序和合并。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        last = result[-1]
        if last[1] >= interval[0]:
            last[1] = max(last[1], interval[1])
        else:
            result.append(interval)
    return result
```

**解析：** 我们首先对区间进行排序，然后逐个合并。如果当前区间的起始值大于前一个区间的结束值，我们将其添加到结果中；否则，我们将两个区间的结束值合并。

#### 6. 二叉树的层序遍历

**题目描述：** 给你一个二叉树，请你返回其按层序遍历的节点值。 （即逐层地，从左到右访问所有节点。）

**示例：** 输入：`[3,9,20,null,null,15,7]`，输出：`[[3], [9, 20], [15, 7]]`。

**答案：** 使用广度优先搜索。

```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    queue = deque([root])
    result = []
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```

**解析：** 我们使用队列来实现广度优先搜索。每次循环中，我们取出队列中的所有元素，并将其子节点添加到队列中。

#### 7. 翻转整数

**题目描述：** 给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

**示例：** 输入：`123`，输出：`321`；输入：`-123`，输出：`-321`。

**答案：** 使用取模和整除。

```python
def reverse(x):
    sign = 1 if x >= 0 else -1
    x = abs(x)
    rev = 0
    while x:
        rev = rev * 10 + x % 10
        x = x // 10
    return sign * rev
```

**解析：** 我们通过取模获取 `x` 的个位数，然后将其加到 `rev` 上，通过整除操作去掉 `x` 的个位数。

#### 8. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** 输入：`["flower","flow","flight"]`，输出：`"fl"`。

**答案：** 使用分治策略。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    low, high = 0, len(min(strs))
    while low < high:
        mid = (low + high) // 2
        if any(s[mid] != strs[0][mid] for s in strs):
            high = mid
        else:
            low = mid + 1
    return strs[0][low:]
```

**解析：** 我们将问题划分为两个子问题，一个是查找最长公共前缀的前半部分，另一个是查找最长公共前缀的后半部分。递归地进行这个过程，直到找到公共前缀。

#### 9. 合并两个有序列表

**题目描述：** 将两个升序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** 输入：`l1 = [1, 2, 4]`，`l2 = [1, 3, 4]`，输出：`[1, 1, 2, 3, 4, 4]`。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**解析：** 我们比较两个链表的头节点，选择较小的值，将其连接到结果链表，并递归处理剩余部分。

#### 10. 三数之和

**题目描述：** 给定一个整数数组 `nums` ，返回所有关于 `nums` 中三元组 `nums[i], nums[j]` 和 `nums[k]` ，其中 `i != j` 且 `i != k` 且 `j != k` 的和为 `0` 的三元组。

**示例：** 输入：`[-1, 0, 1, 2, -1, -4]`，输出：`[[-1, 0, 1], [-1, -1, 2]]`。

**答案：** 使用排序和双指针。

```python
def threeSum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result
```

**解析：** 我们首先对数组进行排序，然后固定第一个数，使用双指针法查找剩余的两个数。同时，我们跳过重复的元素，以避免重复的结果。

#### 11. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回它们的最长公共子序列的长度。

**示例：** 输入：`"abcde"`，`"ace"`，输出：`3`。

**答案：** 使用动态规划。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：** 我们创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。我们通过填充这个数组来计算最长公共子序列的长度。

#### 12. 有效的括号

**题目描述：** 给定一个包含 `'('`、`')'`、`'{'`、`'}'`、`'['` 和 `']'` 的字符串 `s` ，判断字符串是否有效。

**示例：** 输入：`"()"`，输出：`true`；输入：`"{[]}"`，输出：`true`；输入：`"(]"`，输出：`false`。

**答案：** 使用栈。

```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack
```

**解析：** 我们使用一个栈来存储左括号。当遇到一个右括号时，我们将其与栈顶元素匹配。如果它们不匹配，字符串无效。最后，如果栈为空，字符串有效。

#### 13. 二进制求和

**题目描述：** 给定两个二进制字符串，返回他们的和（用二进制表示）。

**示例：** 输入：`"11"`，`"1"`，输出：`"100"`。

**答案：** 使用位操作。

```python
def addBinary(a, b):
    while b:
        carry = a & b
        a = a ^ b
        b = carry << 1
    return bin(a)[2:]
```

**解析：** 我们使用两个变量 `a` 和 `b` 来表示两个二进制字符串。我们通过按位与操作计算进位，通过按位异或操作计算和。然后，我们将进位移到下一位。

#### 14. 盛水最多的容器

**题目描述：** 给定一个长度为 `n` 的整数数组 `height` ，其中 `height[i]` 表示第 `i` 行的高度。求出在该下雨天，这些柱子能够接到的最大雨水量。

**示例：** 输入：`[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`，输出：`6`。

**答案：** 使用双指针。

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    result = 0
    while left < right:
        result = max(result, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return result
```

**解析：** 我们使用两个指针，一个从左到右移动，一个从右到左移动。每次迭代，我们计算当前能够容纳的水量，并更新最大水量。如果左边的柱子高度小于右边，我们移动左指针；否则，我们移动右指针。

#### 15. 二叉树的直径

**题目描述：** 给定一棵二叉树，求出它的直径长度。树直径是指树中任意两节点路径上的最大边数。

**示例：** 输入：`[1, 2, 3, 4, 5]`，输出：`3`。

**答案：** 使用后序遍历。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def diameterOfBinaryTree(root):
    def dfs(node):
        if not node:
            return 0
        left = dfs(node.left)
        right = dfs(node.right)
        nonlocal max_diameter
        max_diameter = max(max_diameter, left + right)
        return max(left, right) + 1

    max_diameter = 0
    dfs(root)
    return max_diameter
```

**解析：** 我们使用后序遍历，计算每个节点的左右子树的深度。我们同时更新全局变量 `max_diameter`，以记录最大直径。

#### 16. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** 输入：`l1 = [1, 2, 4]`，`l2 = [1, 3, 4]`，输出：`[1, 1, 2, 3, 4, 4]`。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**解析：** 我们比较两个链表的头节点，选择较小的值，将其连接到结果链表，并递归处理剩余部分。

#### 17. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 `head` 和一个整数 `val` ，删除链表中所有值为 `val` 的节点。

**示例：** 输入：`[1, 2, 6, 3, 4, 5, 6]`，`val = 6`，输出：`[1, 2, 3, 4, 5]`。

**答案：** 使用哑节点。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeElements(head, val):
    dummy = ListNode(0)
    dummy.next = head
    cur = dummy
    while cur.next:
        if cur.next.val == val:
            cur.next = cur.next.next
        else:
            cur = cur.next
    return dummy.next
```

**解析：** 我们使用一个哑节点，然后遍历链表，删除所有值为 `val` 的节点。

#### 18. 判断链表是否为回文

**题目描述：** 请判断一个链表是否为回文结构。

**示例：** 输入：`[1, 2, 3, 2, 1]`，输出：`True`。

**答案：** 使用快慢指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def isPalindrome(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    mid = reverse(slow)
    n = slow
    while mid and head and mid.val == head.val:
        mid = mid.next
        head = head.next
    return mid is None
```

**解析：** 我们使用快慢指针找到链表的中间节点，然后反转后半部分链表。最后，我们比较前半部分和反转后的后半部分是否相同。

#### 19. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** 输入：`["flower","flow","flight"]`，输出：`"fl"`。

**答案：** 使用分治策略。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    low, high = 0, len(min(strs))
    while low < high:
        mid = (low + high) // 2
        if all(s[mid] == strs[0][mid] for s in strs):
            low = mid + 1
        else:
            high = mid
    return strs[0][low:]
```

**解析：** 我们将问题划分为两个子问题，一个是查找最长公共前缀的前半部分，另一个是查找最长公共前缀的后半部分。递归地进行这个过程，直到找到公共前缀。

#### 20. 翻转链表

**题目描述：** 定义一个函数，实现链表的翻转。

**示例：** 输入：`[1, 2, 3, 4, 5]`，输出：`[5, 4, 3, 2, 1]`。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    if not head or not head.next:
        return head
    p = reverseList(head.next)
    head.next.next = head
    head.next = None
    return p
```

**解析：** 我们递归地反转链表的剩余部分，然后将当前节点连接到前一个节点的下一个节点。

#### 21. 爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：** 输入：`3`，输出：`3`。

**答案：** 使用动态规划。

```python
def climbStairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

**解析：** 我们使用一个数组 `dp` 来存储到达第 `i` 阶的方法数。我们通过迭代计算每个阶的方法数。

#### 22. 合并两个有序数组

**题目描述：** 给你两个整数数组 `nums1` 和 `nums2` ，按升序整理两个数组中的元素并返回合并数组。

**示例：** 输入：`nums1 = [1,2,3,0,0,0]`，`nums2 = [2,5,6]`，输出：`[1,2,2,3,5,6]`。

**答案：** 使用双指针。

```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
```

**解析：** 我们使用三个指针 `i`、`j` 和 `k` 分别指向 `nums1`、`nums2` 和合并后的数组。我们比较两个数组中的元素，将较大的元素放入合并后的数组中。

#### 23. 股票买卖

**题目描述：** 给定一个数组 `prices` ，其中 `prices[i]` 是第 `i` 天的股票价格。如果你只能完成最多一笔买卖，且卖出的股票不能同时买入（即买卖不能同时发生），请返回你能获得的最大利润。

**示例：** 输入：`[7,1,5,3,6,4]`，输出：`5`。

**答案：** 使用动态规划。

```python
def maxProfit(prices):
    if not prices:
        return 0
    min_price = prices[0]
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    return max_profit
```

**解析：** 我们用一个变量 `min_price` 来存储到目前为止遇到的最小价格，并用另一个变量 `max_profit` 来存储最大利润。

#### 24. 最小路径和

**题目描述：** 给定一个包含非负整数的 `m x n` 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**示例：** 输入：`[[1, 3, 1], [1, 5, 1], [4, 2, 1]]`，输出：`7`。

**答案：** 使用动态规划。

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j - 1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    return grid[-1][-1]
```

**解析：** 我们通过动态规划来更新网格中的每个元素，使其表示到达当前位置的最小路径和。

#### 25. 无重复字符的最长子串

**题目描述：** 给定一个字符串 `s` ，找出其中不含有重复字符的最长子串的长度。

**示例：** 输入：`"abcabcbb"`，输出：`3`。

**答案：** 使用双指针。

```python
def lengthOfLongestSubstring(s):
    start = 0
    max_length = 0
    used = {}
    for i, char in enumerate(s):
        if char in used and start <= used[char]:
            start = used[char] + 1
        used[char] = i
        max_length = max(max_length, i - start + 1)
    return max_length
```

**解析：** 我们使用两个指针 `start` 和 `i` 来跟踪当前窗口的起始和结束位置。使用一个字典 `used` 来存储已访问字符的最后位置。

#### 26. 删除链表的倒数第 N 个节点

**题目描述：** 给你一个链表，删除链表的倒数第 `n` 个节点，并且返回链表的头节点。

**示例：** 输入：`[1, 2, 3, 4, 5]`，`n = 2`，输出：`[1, 2, 3, 5]`。

**答案：** 使用快慢指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeNthFromEnd(head, n):
    dummy = ListNode(0)
    dummy.next = head
    slow = fast = dummy
    for _ in range(n + 1):
        fast = fast.next
    while fast:
        slow = slow.next
        fast = fast.next
    slow.next = slow.next.next
    return dummy.next
```

**解析：** 我们使用快慢指针，当快指针移动到链表末尾时，慢指针指向倒数第 `n` 个节点。我们跳过这个节点，从而删除它。

#### 27. 有效的括号

**题目描述：** 给定一个字符串 `s` ，判断 `s` 是否为有效的括号字符串。

**示例：** 输入：`"()"`，输出：`true`；输入：`"{[()()]}"`，输出：`true`；输入：`"(])"`，输出：`false`。

**答案：** 使用栈。

```python
def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack
```

**解析：** 我们使用一个栈来存储左括号。当遇到一个右括号时，我们将其与栈顶元素匹配。如果它们不匹配，字符串无效。最后，如果栈为空，字符串有效。

#### 28. 两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的。将这两个数相加，返回 和 的链表。

**示例：** 输入：`[2 -> 4 -> 3]`，`[5 -> 6 -> 4]`，输出：`7 -> 0 -> 8`。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    carry = l1.val + l2.val
    l1.val = carry % 10
    if carry >= 10:
        l1.next = ListNode(1)
    else:
        l1.next = l2.next
    return addTwoNumbers(l1.next, l2.next)
```

**解析：** 我们递归地处理两个链表，将当前节点的值相加，并根据需要创建新的节点。

#### 29. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** 输入：`["flower","flow","flight"]`，输出：`"fl"`。

**答案：** 使用分治策略。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    low, high = 0, len(min(strs))
    while low < high:
        mid = (low + high) // 2
        if all(s[mid] == strs[0][mid] for s in strs):
            low = mid + 1
        else:
            high = mid
    return strs[0][low:]
```

**解析：** 我们将问题划分为两个子问题，一个是查找最长公共前缀的前半部分，另一个是查找最长公共前缀的后半部分。递归地进行这个过程，直到找到公共前缀。

#### 30. 删除排序数组中的重复项

**题目描述：** 给你一个有序数组 `nums` ，你需要 原地 删除重复出现的元素，使每个元素 只出现一次 。返回移除后数组的新长度。

**示例：** 输入：`[0,0,1,1,1,2,2,3,3,4]`，输出：`5`，且 `nums = [0,1,2,3,4]`。

**答案：** 使用双指针。

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    fast = 0
    for slow in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            fast += 1
            nums[fast] = nums[slow]
    return fast + 1
```

**解析：** 我们使用两个指针 `fast` 和 `slow`。当 `nums[fast]` 不等于 `nums[slow]` 时，我们将 `nums[slow]` 移动到 `nums[fast]` 的下一个位置，并将 `fast` 指针向前移动。最终，`fast + 1` 就是新的长度。

