                 

# 腾讯2025届校招面试高频算法题解析

## 1. 题目1：二分查找

**题目描述：** 在一个有序数组中，找到目标值的位置。如果存在，返回其索引；否则，返回 -1。

```python
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**答案解析：** 这个算法是经典的二分查找算法，用于在有序数组中查找目标值。算法的时间复杂度是 O(log n)，空间复杂度是 O(1)。

## 2. 题目2：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
        if prefix == "":
            return ""
    return prefix
```

**答案解析：** 这个算法通过逐步减少前缀的长度，找到所有字符串的最长公共前缀。算法的时间复杂度是 O(m * n)，其中 m 是最短字符串的长度，n 是字符串的数量；空间复杂度是 O(1)。

## 3. 题目3：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。链表中的节点数目是连续的。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    p = dummy
    while l1 and l2:
        if l1.val < l2.val:
            p.next = l1
            l1 = l1.next
        else:
            p.next = l2
            l2 = l2.next
        p = p.next
    p.next = l1 or l2
    return dummy.next
```

**答案解析：** 这个算法通过迭代合并两个链表。算法的时间复杂度是 O(m + n)，其中 m 和 n 分别是两个链表的长度；空间复杂度是 O(1)。

## 4. 题目4：环形链表

**题目描述：** 给定一个链表，判断是否存在环路。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head):
    if not head:
        return False
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**答案解析：** 这个算法使用双指针法判断链表中是否存在环路。算法的时间复杂度是 O(n)，其中 n 是链表的长度；空间复杂度是 O(1)。

## 5. 题目5：有效的括号

**题目描述：** 给定一个字符串，判断其是否有效括号。

```python
def isValid(s):
    stack = []
    for c in s:
        if c in ["(", "{", "["]:
            stack.append(c)
        elif (len(stack) == 0 or
              (c == ")" and stack[-1] != "(" or
               c == "}" and stack[-1] != "{" or
               c == "]" and stack[-1] != "[")]:
            return False
        else:
            stack.pop()
    return len(stack) == 0
```

**答案解析：** 这个算法使用栈来存储括号。算法的时间复杂度是 O(n)，其中 n 是字符串的长度；空间复杂度是 O(n)。

## 6. 题目6：最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**答案解析：** 这个算法使用动态规划求解最长公共子序列。算法的时间复杂度是 O(m * n)，其中 m 和 n 分别是两个字符串的长度；空间复杂度是 O(m * n)。

## 7. 题目7：两数相加

**题目描述：** 给定两个非空链表，表示两个非负整数，分别位于链表节点中，返回它们相加的结果。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode()
    p = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        p.next = ListNode(total % 10)
        p = p.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**答案解析：** 这个算法通过遍历两个链表，求和并处理进位，构建新的链表。算法的时间复杂度是 O(max(m, n))，其中 m 和 n 分别是两个链表的长度；空间复杂度是 O(max(m, n))。

## 8. 题目8：有效的数字

**题目描述：** 给定一个字符串，判断其是否是有效的数字。

```python
def isNumber(s):
    s = s.strip()
    if not s:
        return False
    i = 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i == len(s):
        return False
    
    has_dot = False
    has_e = False
    has_number = False
    while i < len(s):
        if s[i].isdigit():
            has_number = True
        elif s[i] == '.':
            if has_dot or has_e:
                return False
            has_dot = True
        elif s[i] == 'e':
            if not has_number or has_e:
                return False
            has_e = True
            has_number = False
        elif not s[i].isalpha():
            return False
        i += 1
    
    return has_number
```

**答案解析：** 这个算法通过遍历字符串，判断字符是否符合数字的规则。算法的时间复杂度是 O(n)，其中 n 是字符串的长度；空间复杂度是 O(1)。

## 9. 题目9：合并区间

**题目描述：** 给定一组区间，合并所有重叠的区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for i in range(1, len(intervals)):
        if intervals[i][0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])
    return result
```

**答案解析：** 这个算法首先对区间进行排序，然后合并重叠的区间。算法的时间复杂度是 O(n log n)，其中 n 是区间的数量；空间复杂度是 O(n)。

## 10. 题目10：反转链表

**题目描述：** 反转一个单链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**答案解析：** 这个算法使用迭代法反转链表。算法的时间复杂度是 O(n)，其中 n 是链表的长度；空间复杂度是 O(1)。

## 11. 题目11：排序链表

**题目描述：** 对链表进行排序。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def sortList(head):
    if not head or not head.next:
        return head
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    mid = slow.next
    slow.next = None
    left = sortList(head)
    right = sortList(mid)
    return mergeTwoLists(left, right)

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    p = dummy
    while l1 and l2:
        if l1.val < l2.val:
            p.next = l1
            l1 = l1.next
        else:
            p.next = l2
            l2 = l2.next
        p = p.next
    p.next = l1 or l2
    return dummy.next
```

**答案解析：** 这个算法使用归并排序对链表进行排序。算法的时间复杂度是 O(n log n)，其中 n 是链表的长度；空间复杂度是 O(log n)。

## 12. 题目12：最小栈

**题目描述：** 设计一个最小栈，支持 push、pop、getMin 操作。

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val < self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**答案解析：** 这个算法使用两个栈来维护最小值。算法的时间复杂度是 O(1)，空间复杂度是 O(n)。

## 13. 题目13：合并K个排序链表

**题目描述：** 合并 K 个已排序的链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None
    heap = [(node.val, idx, node) for idx, node in enumerate(lists) if node]
    heapq.heapify(heap)
    head = ListNode()
    tail = head
    while heap:
        val, _, node = heapq.heappop(heap)
        tail.next = node
        tail = tail.next
        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))
    return head.next
```

**答案解析：** 这个算法使用优先队列（小根堆）合并链表。算法的时间复杂度是 O(n log k)，其中 n 是所有链表的总节点数，k 是链表的个数；空间复杂度是 O(k)。

## 14. 题目14：最长公共子串

**题目描述：** 给定两个字符串，找出它们的最长公共子串。

```python
def longestCommonSubstring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_len = max(max_len, dp[i][j])
            else:
                dp[i][j] = 0
    return max_len
```

**答案解析：** 这个算法使用动态规划求解最长公共子串。算法的时间复杂度是 O(m * n)，其中 m 和 n 分别是两个字符串的长度；空间复杂度是 O(m * n)。

## 15. 题目15：LRU缓存

**题目描述：** 设计一个LRU（最近最少使用）缓存。

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        value = self.cache.pop(key)
        self.cache[key] = value
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**答案解析：** 这个算法使用OrderedDict实现LRU缓存。算法的时间复杂度是 O(1)，空间复杂度是 O(capacity)。

## 16. 题目16：两数之和

**题目描述：** 给定一个整数数组，找到两个数使其和等于目标值，并返回它们的位置。

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

**答案解析：** 这个算法使用哈希表存储数组的值和索引，通过计算补数并查找。算法的时间复杂度是 O(n)，空间复杂度是 O(n)。

## 17. 题目17：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = list(set(nums))
    nums.sort()
    max_length = 1
    current_length = 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            current_length += 1
            max_length = max(max_length, current_length)
        else:
            current_length = 1
    return max_length
```

**答案解析：** 这个算法首先将数组去重并排序，然后找出最长连续序列。算法的时间复杂度是 O(n log n)，空间复杂度是 O(n)。

## 18. 题目18：最大子序和

**题目描述：** 给定一个整数数组，找出连续子序列中的最大和。

```python
def maxSubArray(nums):
    if not nums:
        return 0
    max_so_far = nums[0]
    curr_max = nums[0]
    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far
```

**答案解析：** 这个算法使用贪心策略找出最大子序和。算法的时间复杂度是 O(n)，空间复杂度是 O(1)。

## 19. 题目19：合并文件系统

**题目描述：** 设计一个文件系统，支持如下操作：创建文件夹、删除文件夹、移动文件、复制文件。

```python
class Filesystem:
    def __init__(self):
        self.fs = {}

    def mkdir(self, path: str) -> None:
        parts = path.split('/')
        curr = self.fs
        for part in parts[:-1]:
            if part not in curr:
                curr[part] = {}
            curr = curr[part]

    def delete(self, path: str) -> None:
        parts = path.split('/')
        curr = self.fs
        for part in parts[:-1]:
            curr = curr[part]
        del curr[parts[-1]]

    def move(self, src_path: str, dst_path: str) -> None:
        self.copy(src_path, dst_path)
        self.delete(src_path)

    def copy(self, src_path: str, dst_path: str) -> None:
        parts = src_path.split('/')
        curr = self.fs
        for part in parts[:-1]:
            curr = curr[part]
        file = curr[parts[-1]]
        self.mkdir(dst_path)
        parts = dst_path.split('/')
        curr = self.fs
        for part in parts[:-1]:
            curr = curr[part]
        curr[parts[-1]] = file

    def ls(self, path: str) -> List[str]:
        parts = path.split('/')
        curr = self.fs
        for part in parts:
            if part:
                curr = curr[part]
        return list(curr.keys())
```

**答案解析：** 这个算法实现了一个简单的文件系统，支持创建、删除、移动和复制文件夹。算法的时间复杂度是 O(n)，其中 n 是路径的长度；空间复杂度是 O(n)。

## 20. 题目20：买卖股票的最佳时机 IV

**题目描述：** 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格。非负整数 k 代表了最大交易次数。返回你所能获取的最大利润。

```python
def maxProfit(k, prices):
    if not prices:
        return 0
    n = len(prices)
    if k > n // 2:
        return sum(max(0, prices[i] - prices[i - 1]) for i in range(1, n))
    dp = [[0] * (n + 1) for _ in range(k + 1)]
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
            max_diff = max(max_diff, dp[i - 1][j] - prices[j])
    return dp[-1][-1]
```

**答案解析：** 这个算法使用动态规划求解买卖股票的最佳时机 IV。算法的时间复杂度是 O(k * n)，空间复杂度是 O(k * n)。

## 21. 题目21：零钱兑换

**题目描述：** 给定一个整数数组 coins 表示不同的硬币面额，和一个整数 amount 表示总金额，计算最少需要多少硬币组合来凑出 amount。

```python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    return -1 if dp[amount] == float('inf') else dp[amount]
```

**答案解析：** 这个算法使用动态规划求解零钱兑换问题。算法的时间复杂度是 O(amount * n)，其中 n 是硬币的种类数；空间复杂度是 O(amount)。

## 22. 题目22：单词搜索 II

**题目描述：** 给定一个二维字符网格 board 和一个单词列表 words，找出并返回所有出现在网格中的单词。单词应该按照字典序排列。

```python
def findWords(board, words):
    def dfs(i, j, word, k):
        if k == len(words[word]):
            return True
        if (
            i < 0
            or i >= len(board)
            or j < 0
            or j >= len(board[0])
            or board[i][j] != word[k]
            or visited[i][j]
        ):
            return False
        visited[i][j] = True
        if dfs(i + 1, j, word, k + 1):
            return True
        if dfs(i - 1, j, word, k + 1):
            return True
        if dfs(i, j + 1, word, k + 1):
            return True
        if dfs(i, j - 1, word, k + 1):
            return True
        visited[i][j] = False
        return False

    def search(i, j):
        if board[i][j] not in word_set:
            return
        if dfs(i, j, board[i][j], 0):
            ans.append(board[i][j])
            board[i][j] = "#"
        for x, y in [[0, -1], [0, 1], [-1, 0], [1, 0]]:
            if 0 <= i + x < m and 0 <= j + y < n:
                search(i + x, j + y)

    m, n = len(board), len(board[0])
    ans = []
    for word in words:
        word_set[word] = True
    for i in range(m):
        for j in range(n):
            search(i, j)
    return sorted(ans)

words = ["oath", "pea", "eat", "rain"]
board = [
    ["o", "a", "a", "n"],
    ["e", "t", "a", "e"],
    ["i", "h", "k", "r"],
    ["i", "f", "l", "v"],
]
```

**答案解析：** 这个算法使用回溯法找出所有出现在网格中的单词。算法的时间复杂度是 O(m * n * 3 ^ l)，其中 m 和 n 是网格的尺寸，l 是单词的长度；空间复杂度是 O(m * n)。

## 23. 题目23：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or s[i] != prefix[i]:
                prefix = prefix[:i]
                break
    return prefix
```

**答案解析：** 这个算法通过遍历字符串数组，逐步减少前缀的长度，直到找到最长公共前缀。算法的时间复杂度是 O(m * n)，其中 m 是最短字符串的长度，n 是字符串的数量；空间复杂度是 O(1)。

## 24. 题目24：最长递增子序列

**题目描述：** 给定一个整数数组，找出最长递增子序列的长度。

```python
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**答案解析：** 这个算法使用动态规划求解最长递增子序列的长度。算法的时间复杂度是 O(n^2)，空间复杂度是 O(n)。

## 25. 题目25：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    p = dummy
    while l1 and l2:
        if l1.val < l2.val:
            p.next = l1
            l1 = l1.next
        else:
            p.next = l2
            l2 = l2.next
        p = p.next
    p.next = l1 or l2
    return dummy.next
```

**答案解析：** 这个算法通过迭代两个链表，合并为一个新的升序链表。算法的时间复杂度是 O(n + m)，其中 n 和 m 分别是两个链表的长度；空间复杂度是 O(1)。

## 26. 题目26：判断二叉树是否对称

**题目描述：** 给定一个二叉树，判断它是否是自己的镜像。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSymmetric(root):
    if not root:
        return True
    return isMirror(root.left, root.right)

def isMirror(l, r):
    if l is None and r is None:
        return True
    if l is None or r is None or l.val != r.val:
        return False
    return isMirror(l.left, r.right) and isMirror(l.right, r.left)
```

**答案解析：** 这个算法通过递归判断两个子树是否镜像对称。算法的时间复杂度是 O(n)，其中 n 是树中的节点数；空间复杂度是 O(height)，其中 height 是树的高度。

## 27. 题目27：电话号码的字母组合

**题目描述：** 给定一个字符串数字，返回所有可能的字母组合。

```python
def letterCombinations(digits):
    if not digits:
        return []
    phone = [
        [],
        [],
        ['a', 'b', 'c'],
        ['d', 'e', 'f'],
        ['g', 'h', 'i'],
        ['j', 'k', 'l'],
        ['m', 'n', 'o'],
        ['p', 'q', 'r', 's'],
        ['t', 'u', 'v'],
        ['w', 'x', 'y', 'z'],
    ]
    ans = [""]
    for d in digits:
        t = []
        for a in ans:
            for b in phone[int(d)]:
                t.append(a + b)
        ans = t
    return ans
```

**答案解析：** 这个算法使用递归法生成所有可能的字母组合。算法的时间复杂度是 O(3 ^ n)，其中 n 是数字字符串的长度；空间复杂度是 O(n)。

## 28. 题目28：岛屿数量

**题目描述：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。

```python
def numIslands(grid):
    def dfs(i, j):
        grid[i][j] = '0'
        for a, b in [[0, -1], [0, 1], [-1, 0], [1, 0]]:
            x, y = i + a, j + b
            if 0 <= x < m and 0 <= y < n and grid[x][y] == '1':
                dfs(x, y)

    m, n = len(grid), len(grid[0])
    ans = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                dfs(i, j)
                ans += 1
    return ans
```

**答案解析：** 这个算法使用深度优先搜索（DFS）计算岛屿数量。算法的时间复杂度是 O(m * n)，其中 m 和 n 是网格的尺寸；空间复杂度是 O(m * n)。

## 29. 题目29：翻转二叉树

**题目描述：** 翻转一棵二叉树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invertTree(root):
    if not root:
        return root
    root.left, root.right = invertTree(root.right), invertTree(root.left)
    return root
```

**答案解析：** 这个算法通过递归交换左子树和右子树，实现二叉树翻转。算法的时间复杂度是 O(n)，其中 n 是树中的节点数；空间复杂度是 O(height)，其中 height 是树的高度。

## 30. 题目30：最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**答案解析：** 这个算法使用动态规划求解最长公共子序列。算法的时间复杂度是 O(m * n)，其中 m 和 n 分别是两个字符串的长度；空间复杂度是 O(m * n)。

