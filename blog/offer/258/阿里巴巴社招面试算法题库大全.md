                 

### 阿里巴巴社招面试算法题库大全

以下整理了 2024 年阿里巴巴社招面试中可能遇到的典型高频算法题，并提供了详尽的答案解析和源代码实例。

#### 1. 最长公共子序列

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子序列。

**答案解析：** 使用动态规划的方法，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列的长度。

```go
func longestCommonSubsequence(str1, str2 string) int {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 2. 二分查找

**题目描述：** 给定一个有序数组 `nums` 和一个目标值 `target`，在数组中查找 `target` 的位置，返回其下标，如果不存在则返回 `-1`。

**答案解析：** 利用二分查找算法，逐步缩小区间，找到目标值或确定其不存在。

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

#### 3. 逆波兰表达式求值

**题目描述：** 根据逆波兰表示法，求表达式的值。

**答案解析：** 利用栈实现，遍历逆波兰表达式，根据操作符进行相应的运算。

```go
func evalRPN(tokens []string) int {
    var stk []int
    for _, token := range tokens {
        switch token {
        case "+":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a+b)
        case "-":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a-b)
        case "*":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a*b)
        case "/":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a/b)
        default:
            stk = append(stk, atoi(token))
        }
    }
    return stk[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    ans := 0
    for i := 0; i < len(token); i++ {
        ans = ans*10 + int(token[i]-'0')
    }
    return ans * sign
}
```

#### 4. 判断子序列

**题目描述：** 给定字符串 `s` 和 `t`，判断 `s` 是否是 `t` 的子序列。

**答案解析：** 使用双指针的方法，遍历字符串 `t`，找到与 `s` 相对应的子序列。

```go
func isSubsequence(s string, t string) bool {
    i, j := 0, 0
    for i < len(s) && j < len(t) {
        if s[i] == t[j] {
            i++
        }
        j++
    }
    return i == len(s)
}
```

#### 5. 合并区间

**题目描述：** 给定一个区间列表，合并所有重叠的区间。

**答案解析：** 将区间按照左端点排序，遍历区间，合并重叠的区间。

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 6. 二叉树的遍历

**题目描述：** 实现二叉树的先序遍历、中序遍历和后序遍历。

**答案解析：** 使用递归的方法实现二叉树的遍历。

```go
// Definition for a binary tree node.
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func preorderTraversal(root *TreeNode) []int {
    var ans []int
    dfs(root, &ans)
    return ans
}

func dfs(node *TreeNode, ans *[]int) {
    if node == nil {
        return
    }
    *ans = append(*ans, node.Val)
    dfs(node.Left, ans)
    dfs(node.Right, ans)
}

func inorderTraversal(root *TreeNode) []int {
    var ans []int
    dfsInorder(root, &ans)
    return ans
}

func dfsInorder(node *TreeNode, ans *[]int) {
    if node == nil {
        return
    }
    dfsInorder(node.Left, ans)
    *ans = append(*ans, node.Val)
    dfsInorder(node.Right, ans)
}

func postorderTraversal(root *TreeNode) []int {
    var ans []int
    dfsPostorder(root, &ans)
    return ans
}

func dfsPostorder(node *TreeNode, ans *[]int) {
    if node == nil {
        return
    }
    dfsPostorder(node.Left, ans)
    dfsPostorder(node.Right, ans)
    *ans = append(*ans, node.Val)
}
```

#### 7. 拓扑排序

**题目描述：** 给定一个无向图的边列表，进行拓扑排序。

**答案解析：** 使用 DFS 和 Kahn 算法进行拓扑排序。

```go
func topologySort(edges [][]int) []int {
    var ans []int
    graph := make([][]int, len(edges))
    indeg := make([]int, len(edges))
    for _, edge := range edges {
        u, v := edge[0], edge[1]
        graph[u] = append(graph[u], v)
        indeg[v]++
    }
    q := make([]int, 0, len(edges))
    for i, inde := range indeg {
        if inde == 0 {
            q = append(q, i)
        }
    }
    for len(q) > 0 {
        u := q[0]
        q = q[1:]
        ans = append(ans, u)
        for _, v := range graph[u] {
            indeg[v]--
            if indeg[v] == 0 {
                q = append(q, v)
            }
        }
    }
    return ans
}
```

#### 8. 单词梯

**题目描述：** 给定两个单词，判断是否可以通过改变单词中的单个字母来形成另一个单词。

**答案解析：** 使用 BFS 算法，从源单词开始，逐步改变字母，直到达到目标单词或确定无法形成。

```go
func isTransformable(word1 string, word2 string) bool {
    q := [][]int{{0, word1}}
    visited := make(map[int]bool)
    for len(q) > 0 {
        level, size := 0, len(q)
        for i := 0; i < size; i++ {
            pos, word := q[0]
            q = q[1:]
            if word == word2 {
                return true
            }
            for j := 0; j < len(word); j++ {
                if visited[pos+j] {
                    continue
                }
                for k := 'a'; k <= 'z'; k++ {
                    if k == word[j] {
                        continue
                    }
                    newWord := []byte(word)
                    newWord[j] = k
                    if _, ok := visited[pos+j+1]; !ok {
                        q = append(q, []int{pos + j + 1, string(newWord)})
                        visited[pos+j+1] = true
                    }
                }
            }
            visited[pos] = true
            level++
        }
        if level > len(word1) {
            return false
        }
    }
    return false
}
```

#### 9. 有效的数独

**题目描述：** 判断一个 9x9 的数独是否有效。

**答案解析：** 分别检查行、列和宫格是否符合数独的规则。

```go
func isValidSudoku(board [][]byte) bool {
    row, col, block := make([][9]bool, 9), make([][9]bool, 9), make([][9]bool, 9)
    for i, row := range board {
        for j, v := range row {
            if v != '.' {
                if row[v-'1"] || col[j][v-'1"] || block[i/3*3+j/3][v-'1"] {
                    return false
                }
                row[v-'1"] = col[j][v-'1"] = block[i/3*3+j/3][v-'1"] = true
            }
        }
    }
    return true
}
```

#### 10. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，判断它们是否是字母异位词。

**答案解析：** 使用哈希表统计字符频率，比较两个字符串的字符频率是否相同。

```go
func isAnagram(s string, t string) bool {
    m1, m2 := make(map[rune]int), make(map[rune]int)
    for _, c := range s {
        m1[c]++
    }
    for _, c := range t {
        m2[c]++
    }
    return len(m1) == len(m2) && reflect.DeepEqual(m1, m2)
}
```

#### 11. 螺旋矩阵

**题目描述：** 给定一个 `n x n` 的矩阵 `matrix`，返回矩阵的螺旋有序遍历。

**答案解析：** 使用方向数组 `directions` 来控制遍历的方向，按照螺旋的路径遍历矩阵。

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    directions := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}
    ans := make([]int, 0, len(matrix)*len(matrix[0]))
    rows, cols := len(matrix), len(matrix[0])
    row, col, dir := 0, 0, 0
    for i := 0; i < rows*cols; i++ {
        ans = append(ans, matrix[row][col])
        nextRow, nextCol := row+directions[dir][0], col+directions[dir][1]
        if nextRow < 0 || nextRow >= rows || nextCol < 0 || nextCol >= cols || matrix[nextRow][nextCol] == 0 {
            dir = (dir + 1) % 4
        }
        row, col = row+directions[dir][0], col+directions[dir][1]
    }
    return ans
}
```

#### 12. 电话号码的字母组合

**题目描述：** 给定一个字符串 `digits`，返回按键按序列出的字母组合。

**答案解析：** 使用递归和回溯的方法，遍历所有的可能性。

```go
var letterMap = []string{"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}

func letterCombinations(digits string) []string {
    ans := []string{}
    if len(digits) == 0 {
        return ans
    }
    backTrack(digits, 0, "", &ans)
    return ans
}

func backTrack(digits string, index int, cur string, ans *[]string) {
    if index == len(digits) {
        *ans = append(*ans, cur)
        return
    }
    digit := string(digits[index])
    letters := letterMap[digit]
    for _, letter := range letters {
        backTrack(digits, index+1, cur+string(letter), ans)
    }
}
```

#### 13. 最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找出数组中最大和连续子序列，返回最大子序和。

**答案解析：** 使用动态规划的方法，计算以每个位置为起点的最大子序和。

```go
func maxSubArray(nums []int) int {
    ans := nums[0]
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        dp[i] = max(nums[i], dp[i-1]+nums[i])
        ans = max(ans, dp[i])
    }
    return ans
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

#### 14. 删除链表的节点

**题目描述：** 给定一个链表和一个节点值，删除该节点。

**答案解析：** 将前一个节点的值替换成当前节点的值，然后删除当前节点。

```go
func deleteNode(node *ListNode) {
    if node == nil {
        return
    }
    next := node.Next
    node.Val = next.Val
    node.Next = next.Next
    next = nil
}
```

#### 15. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的数组，找出给定目标值的位置。

**答案解析：** 利用二分查找的方法，找到目标值的位置。

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[right] && target <= nums[left] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

#### 16. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**答案解析：** 使用递归的方法合并两个有序链表。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 17. 删除排序数组中的重复项

**题目描述：** 删除排序数组中的重复项，返回新数组的长度。

**答案解析：** 使用双指针的方法，移动快指针，找到新的数组长度。

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    slow, fast := 0, 0
    for fast < len(nums) {
        if nums[slow] != nums[fast] {
            slow++
            nums[slow] = nums[fast]
        }
        fast++
    }
    return slow + 1
}
```

#### 18. 两数相加

**题目描述：** 给定两个非空链表表示两个非负整数，每个节点包含一个数字，返回这两个数字相加的结果。

**答案解析：** 使用链表表示的两个数相加，处理进位。

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := carry + x + y
        carry = sum / 10
        cur.Next = &ListNode{Val: sum % 10}
        cur = cur.Next
    }
    return dummy.Next
}
```

#### 19. 快乐数

**题目描述：** 编写一个函数，判断一个正整数是否是「快乐数」。

**答案解析：** 使用快慢指针法判断是否进入循环。

```go
func isHappy(n int) bool {
    slow, fast := n, n
    for {
        slow = squareSum(slow)
        fast = squareSum(squareSum(fast))
        if slow == fast {
            break
        }
    }
    return slow == 1
}

func squareSum(n int) int {
    sum := 0
    for n > 0 {
        sum += (n % 10) * (n % 10)
        n /= 10
    }
    return sum
}
```

#### 20. 存在重复元素

**题目描述：** 给定一个整数数组，判断是否存在重复元素。

**答案解析：** 使用哈希表判断是否存在重复元素。

```go
func containsDuplicate(nums []int) bool {
    m := make(map[int]bool)
    for _, num := range nums {
        if _, ok := m[num]; ok {
            return true
        }
        m[num] = true
    }
    return false
}
```

#### 21. 寻找两个正序数组的中位数

**题目描述：** 给定两个正序的整数数组 `nums1` 和 `nums2`，找到这两个数组的中位数。

**答案解析：** 使用二分查找的方法，找到两个数组合并后的中位数。

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2, m, n = nums2, nums1, n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i == m {
                minOfRight = nums2[j]
            } else if j == n {
                minOfRight = nums1[i]
            } else {
                minOfRight = min(nums1[i], nums2[j])
            }
            return float64(maxOfLeft+minOfRight) / 2
        }
    }
    return 0
}
```

#### 22. 寻找两个正序数组的中位数（优化版）

**题目描述：** 给定两个正序的整数数组 `nums1` 和 `nums2`，找到这两个数组的中位数。

**答案解析：** 使用二分查找的方法，找到两个数组合并后的中位数，优化了空间和时间复杂度。

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    if len(nums1) > len(nums2) {
        nums1, nums2 = nums2, nums1
    }
    m, n := len(nums1), len(nums2)
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i == m {
                minOfRight = nums2[j]
            } else if j == n {
                minOfRight = nums1[i]
            } else {
                minOfRight = min(nums1[i], nums2[j])
            }
            return float64(maxOfLeft+minOfRight) / 2
        }
    }
    return 0
}
```

#### 23. 合并K个排序链表

**题目描述：** 合并 `k` 个已经排序的链表，返回合并后的链表。

**答案解析：** 使用优先队列来维护当前最小值的链表节点。

```go
type Node struct {
    Val  int
    Next *Node
}

func mergeKLists(lists []*Node) *Node {
    if lists == nil || len(lists) == 0 {
        return nil
    }
    minHeap := &Heap{}
    for _, list := range lists {
        if list != nil {
            minHeap.Push(&Node{Val: list.Val, Next: list.Next})
        }
    }
    dummyHead := &Node{}
    curr := dummyHead
    for !minHeap.IsEmpty() {
        node := minHeap.Pop()
        curr.Next = &Node{Val: node.Val}
        curr = curr.Next
        if node.Next != nil {
            minHeap.Push(node.Next)
        }
    }
    return dummyHead.Next
}

type Heap struct {
    arr []*Node
}

func (h *Heap) Len() int {
    return len(h.arr)
}

func (h *Heap) Empty() bool {
    return len(h.arr) == 0
}

func (h *Heap) Push(v *Node) {
    h.arr = append(h.arr, v)
    h.up(len(h.arr) - 1)
}

func (h *Heap) Pop() *Node {
    if h.Empty() {
        return nil
    }
    v := h.arr[0]
    h.arr[0] = h.arr[len(h.arr)-1]
    h.arr = h.arr[:len(h.arr)-1]
    h.down(0)
    return v
}

func (h *Heap) up(i int) {
    for i > 0 {
        p := (i-1)/2
        if h.arr[p].Val <= h.arr[i].Val {
            break
        }
        h.swap(p, i)
        i = p
    }
}

func (h *Heap) down(i int) {
    l := i*2 + 1
    r := i*2 + 2
    min := i
    if l < len(h.arr) && h.arr[l].Val < h.arr[min].Val {
        min = l
    }
    if r < len(h.arr) && h.arr[r].Val < h.arr[min].Val {
        min = r
    }
    if min != i {
        h.swap(i, min)
        h.down(min)
    }
}

func (h *Heap) swap(i, j int) {
    h.arr[i], h.arr[j] = h.arr[j], h.arr[i]
}
```

#### 24. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**答案解析：** 使用递归的方法，合并两个有序链表。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 25. 合并两个有序数组

**题目描述：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，合并它们。

**答案解析：** 使用双指针的方法，将两个数组合并到一个数组中。

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for i >= 0 {
        nums1[k] = nums1[i]
        i--
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

#### 26. 三数之和

**题目描述：** 给定一个整数数组 `nums`，返回所有满足条件的三元组 `[nums[a], nums[b], nums[c]]`，使得 `nums[a] + nums[b] + nums[c] == 0`。

**答案解析：** 使用排序和双指针的方法，找到所有满足条件的三元组。

```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}
```

#### 27. 四数之和

**题目描述：** 给定一个整数数组 `nums`，返回所有满足条件的三元组 `[nums[a], nums[b], nums[c], nums[d]]`，使得 `nums[a] + nums[b] + nums[c] + nums[d] == 0`。

**答案解析：** 使用排序和双指针的方法，找到所有满足条件的四元组。

```go
func fourSum(nums []int, target int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        for j := i + 1; j < len(nums)-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            left, right := j+1, len(nums)-1
            for left < right {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum == target {
                    ans = append(ans, []int{nums[i], nums[j], nums[left], nums[right]})
                    for left < right && nums[left] == nums[left+1] {
                        left++
                    }
                    for left < right && nums[right] == nums[right-1] {
                        right--
                    }
                    left++
                    right--
                } else if sum < target {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    return ans
}
```

#### 28. 盲提问题

**题目描述：** 有一个函数，它接受一个整数数组，然后返回一个布尔值，表示数组中是否存在重复元素。

**答案解析：** 可以使用哈希表来实现这个功能。

```go
func hasDuplicate(nums []int) bool {
    m := make(map[int]bool)
    for _, num := range nums {
        if _, ok := m[num]; ok {
            return true
        }
        m[num] = true
    }
    return false
}
```

#### 29. 二叉搜索树中的搜索

**题目描述：** 给定一个二叉搜索树和目标值，判断树中是否存在该值。

**答案解析：** 可以通过比较当前节点的值和目标值，递归地在左子树或右子树中搜索。

```go
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }
    if root.Val < val {
        return searchBST(root.Right, val)
    }
    return searchBST(root.Left, val)
}
```

#### 30. 删除二叉搜索树中的节点

**题目描述：** 给定一个二叉搜索树和要删除的节点值，删除该节点并返回新的二叉搜索树。

**答案解析：** 需要考虑三种情况：

1. 如果该节点没有子节点，直接删除。
2. 如果该节点有一个子节点，将子节点移动到删除节点的位置。
3. 如果该节点有两个子节点，找到中序遍历的下一个节点，将其值赋给删除的节点，然后删除中序遍历的下一个节点。

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil {
        return root
    }
    if key < root.Val {
        root.Left = deleteNode(root.Left, key)
    } else if key > root.Val {
        root.Right = deleteNode(root.Right, key)
    } else {
        if root.Left == nil && root.Right == nil {
            return nil
        }
        if root.Left == nil {
            return root.Right
        }
        if root.Right == nil {
            return root.Left
        }
        minNode := root.Right
        for minNode.Left != nil {
            minNode = minNode.Left
        }
        root.Val = minNode.Val
        root.Right = deleteNode(root.Right, minNode.Val)
    }
    return root
}
```

以上就是2024阿里巴巴社招面试算法题库大全的相关内容，希望对您有所帮助。在面试中，不仅要掌握算法和数据结构的基本原理，还要学会灵活运用，希望这些题目能帮助您在面试中取得好成绩。

