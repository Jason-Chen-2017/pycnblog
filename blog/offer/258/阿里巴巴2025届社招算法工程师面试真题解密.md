                 

### 阿里巴巴2025届社招算法工程师面试真题解密

#### 目录

1. [二叉树的遍历](#二叉树的遍历)
2. [动态规划](#动态规划)
3. [图算法](#图算法)
4. [字符串处理](#字符串处理)
5. [数据结构](#数据结构)
6. [数学问题](#数学问题)
7. [系统设计](#系统设计)
8. [编程题](#编程题)

#### 1. 二叉树的遍历

##### 1.1 前序遍历、中序遍历、后序遍历

**题目：** 请用递归和非递归的方法分别实现二叉树的前序遍历、中序遍历、后序遍历。

**答案：**

递归实现：

```python
# 前序遍历
def preorderTraversal(root):
    if root is None:
        return
    print(root.val, end=' ')
    preorderTraversal(root.left)
    preorderTraversal(root.right)

# 中序遍历
def inorderTraversal(root):
    if root is None:
        return
    inorderTraversal(root.left)
    print(root.val, end=' ')
    inorderTraversal(root.right)

# 后序遍历
def postorderTraversal(root):
    if root is None:
        return
    postorderTraversal(root.left)
    postorderTraversal(root.right)
    print(root.val, end=' ')
```

非递归实现：

```python
from collections import deque

# 前序遍历
def preorderTraversal(root):
    if root is None:
        return
    stack = deque([root])
    while stack:
        node = stack.pop()
        print(node.val, end=' ')
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

# 中序遍历
def inorderTraversal(root):
    if root is None:
        return
    stack = deque()
    node = root
    while node or stack:
        while node:
            stack.append(node)
            node = node.left
        node = stack.pop()
        print(node.val, end=' ')
        node = node.right

# 后序遍历
def postorderTraversal(root):
    if root is None:
        return
    stack = deque([root])
    visited = set()
    while stack:
        node = stack.pop()
        if node in visited:
            print(node.val, end=' ')
            continue
        visited.add(node)
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)
```

**解析：** 递归实现简单直观，但可能导致栈溢出；非递归实现使用栈模拟递归过程，避免了栈溢出的问题。

#### 2. 动态规划

##### 2.1 最长上升子序列

**题目：** 给定一个无序数组，求最长上升子序列的长度。

**答案：**

```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**解析：** 使用动态规划，状态 `dp[i]` 表示以 `nums[i]` 结尾的最长上升子序列的长度。

#### 3. 图算法

##### 3.1 单源最短路径

**题目：** 使用迪杰斯特拉算法实现单源最短路径。

**答案：**

```python
def dijkstra(graph, start):
    n = len(graph)
    dist = [float('inf')] * n
    dist[start] = 0
    visited = [False] * n
    for _ in range(n):
        min_dist = float('inf')
        min_idx = -1
        for i in range(n):
            if not visited[i] and dist[i] < min_dist:
                min_dist = dist[i]
                min_idx = i
        visited[min_idx] = True
        for j in range(n):
            if graph[min_idx][j] and dist[j] > dist[min_idx] + graph[min_idx][j]:
                dist[j] = dist[min_idx] + graph[min_idx][j]
    return dist
```

**解析：** 迪杰斯特拉算法是一种基于贪心的单源最短路径算法，适用于图中所有边都是非负权值的情况。

#### 4. 字符串处理

##### 4.1 最长公共前缀

**题目：** 给定一个字符串数组，求最长公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i, c in enumerate(strs[0]):
        for s in strs[1:]:
            if i >= len(s) or c != s[i]:
                return prefix
        prefix += c
    return prefix
```

**解析：** 从第一个字符串开始，逐个比较后续字符串，直到找到不同的字符为止。

#### 5. 数据结构

##### 5.1 单调栈

**题目：** 使用单调栈求解下一个更大元素。

**答案：**

```python
def nextGreaterElements(nums):
    n = len(nums)
    stack = []
    result = [-1] * n
    for i in range(2 * n - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i % n]:
            stack.pop()
        if stack:
            result[i % n] = nums[stack[-1]]
        stack.append(i % n)
    return result
```

**解析：** 单调栈可以用于求解数组中的下一个更大元素。

#### 6. 数学问题

##### 6.1 素数环

**题目：** 判断一个数组是否可以构成素数环。

**答案：**

```python
def isPrime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def isPrimeRing(nums):
    n = len(nums)
    for i in range(n):
        if not isPrime(nums[i]):
            return False
    for i in range(n):
        if nums[i] + nums[(i + 1) % n] > nums[(i + 2) % n]:
            return False
    return True
```

**解析：** 判断每个数字是否为素数，以及相邻数字之和是否小于第三个数字。

#### 7. 系统设计

##### 7.1 负载均衡

**题目：** 设计一个负载均衡算法。

**答案：**

```python
class LoadBalancer:
    def __init__(self, servers):
        self.servers = servers
        self.server_index = 0

    def choose_server(self):
        server = self.servers[self.server_index]
        self.server_index = (self.server_index + 1) % len(self.servers)
        return server
```

**解析：** 采用轮询算法，循环选择下一个服务器。

#### 8. 编程题

##### 8.1 打乱数组

**题目：** 打乱一个没有重复元素的数组。

**答案：**

```python
import random

class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        ans = []
        for i in range(n):
            ans.append(nums[i])
            ans.append(nums[i + n])
        random.shuffle(ans)
        return ans
```

**解析：** 将数组分成两部分，分别放入新数组中，然后随机打乱新数组。


##### 8.2 两数相加

**题目：** 定义一个函数，实现两个链表表示的数字相加。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

**解析：** 使用哑节点构建结果链表，循环遍历两个链表，将每个节点的值相加，处理进位，构建下一个节点。


##### 8.3 寻找旋转排序数组中的最小值

**题目：** 寻找旋转排序数组中的最小值。

**答案：**

```python
def findMin(nums):
    low, high = 0, len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        else:
            high = mid
    return nums[low]
```

**解析：** 二分查找，找到旋转点，旋转点后的第一个元素即为最小值。

##### 8.4 最小路径和

**题目：** 给定一个包含非负整数的 m x n 网格，找出从左上角到右下角的最小路径和。

**答案：**

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j - 1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    return grid[-1][-1]
```

**解析：** 动态规划，更新第一行和第一列的值，然后从左上角开始遍历，每次取上一行和左边的最小值。


##### 8.5 盲数检测

**题目：** 设计一个算法，检测一个列表中是否存在盲数（即没有数字“2”的数字）。

**答案：**

```python
def has-blind-number(nums):
    for num in nums:
        if '2' not in str(num):
            return True
    return False
```

**解析：** 将每个数字转换为字符串，检查字符串中是否包含字符“2”。

##### 8.6 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i, c in enumerate(strs[0]):
        for s in strs[1:]:
            if i >= len(s) or c != s[i]:
                return prefix
        prefix += c
    return prefix
```

**解析：** 从第一个字符串开始，逐个比较后续字符串，直到找到不同的字符为止。

##### 8.7 单调栈

**题目：** 使用单调栈求解数组中的下一个更大元素。

**答案：**

```python
def nextGreaterElements(nums):
    n = len(nums)
    stack = []
    result = [-1] * n
    for i in range(2 * n - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i % n]:
            stack.pop()
        if stack:
            result[i % n] = nums[stack[-1]]
        stack.append(i % n)
    return result
```

**解析：** 单调栈，从后往前遍历，更新结果数组。

##### 8.8 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next
        curr.next = list1 or list2
        return dummy.next
```

**解析：** 遍历两个链表，比较当前节点值，将较小的节点链接到结果链表，直到一个链表结束，然后将另一个链表剩余部分链接到结果链表。

##### 8.9 排序链表

**题目：** 给定一个链表，实现链表排序。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None
        left = self.sortList(head)
        right = self.sortList(mid)
        return self.mergeTwoLists(left, right)

    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next
        curr.next = list1 or list2
        return dummy.next
```

**解析：** 分治法，将链表分为两半，分别递归排序，然后合并两个有序链表。

##### 8.10 二进制数转十进制

**题目：** 将一个二进制字符串转换为十进制数。

**答案：**

```python
def myAtoi(s: str) -> int:
    sign = 1
    result = 0
    i = 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i < len(s) and (s[i] == '+' or s[i] == '-'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        digit = ord(s[i]) - ord('0')
        if result > (1 << 31) // 10 or (result == (1 << 31) // 10 and digit > 7):
            return (1 << 31) * sign if sign > 0 else -(1 << 31)
        result = result * 10 + digit
        i += 1
    return result * sign
```

**解析：** 处理空格、符号位、溢出。

##### 8.11 路径总和

**题目：** 给定一个二叉树，找到从根节点到叶子节点的路径和等于给定目标值的路径。

**答案：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        def dfs(node, path, target):
            if node is None:
                return
            path.append(node.val)
            target -= node.val
            if node.left is None and node.right is None and target == 0:
                ans.append(list(path))
            dfs(node.left, path, target)
            dfs(node.right, path, target)
            path.pop()

        ans = []
        dfs(root, [], targetSum)
        return ans
```

**解析：** 深度优先搜索，每次遍历路径和，若到达叶子节点且路径和等于目标值，则添加到结果列表中。

##### 8.12 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组。

**答案：**

```python
def search(nums, target):
    low, high = 0, len(nums) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        if nums[low] <= nums[mid]:
            if nums[low] <= target < nums[mid]:
                high = mid - 1
            else:
                low = mid + 1
        else:
            if nums[mid] < target <= nums[high]:
                low = mid + 1
            else:
                high = mid - 1
    return -1
```

**解析：** 二分查找，判断中间值与边界值的关系，确定在哪个区间内搜索。

##### 8.13 最大子序和

**题目：** 给定一个整数数组，找出所有可能的连续子序列，计算它们的和，并返回最大和。

**答案：**

```python
def maxSubArray(nums):
    ans = nums[0]
    curr = nums[0]
    for num in nums[1:]:
        curr = max(num, curr + num)
        ans = max(ans, curr)
    return ans
```

**解析：** 动态规划，当前最大子序和等于当前元素和前一个最大子序和的最大值。

##### 8.14 快乐数

**题目：** 编写一个算法来判断一个数是否是“快乐数”。

**答案：**

```python
def isHappy(n):
    def get_next(n):
        s = 0
        while n:
            s += n % 10 ** 2 * n % 10
            n //= 10
        return s

    slow, fast = n, get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
```

**解析：** 快慢指针法，判断是否进入循环。

##### 8.15 汇总

**题目：** 编写一个函数，计算并返回字符串中单词的总数。

**答案：**

```python
def countWords(sentence):
    return len(sentence.split())
```

**解析：** 使用空格分隔字符串，计算单词数量。

##### 8.16 删除链表的节点

**题目：** 给定一个单链表和一个节点，删除该节点。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

**解析：** 将下一个节点的值赋给当前节点，然后删除下一个节点。

##### 8.17 二分查找

**题目：** 使用二分查找在有序数组中查找目标值。

**答案：**

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1
```

**解析：** 二分查找的基本实现。

##### 8.18 字符串查找

**题目：** 编写一个函数，在字符串中查找子字符串。

**答案：**

```python
def search(s, t):
    return t in s
```

**解析：** 使用 `in` 关键字判断子字符串是否存在于字符串中。

##### 8.19 合并区间

**题目：** 给定一组区间，合并重叠的区间。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        last = ans[-1]
        if last[1] >= interval[0]:
            ans[-1] = [last[0], max(last[1], interval[1])]
        else:
            ans.append(interval)
    return ans
```

**解析：** 排序后，合并重叠的区间。

##### 8.20 最大子序和

**题目：** 给定一个整数数组，找出最大子序和。

**答案：**

```python
def maxSubArray(nums):
    ans = curr = nums[0]
    for num in nums[1:]:
        curr = max(num, curr + num)
        ans = max(ans, curr)
    return ans
```

**解析：** 动态规划，当前最大子序和等于当前元素和前一个最大子序和的最大值。

##### 8.21 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 遍历两个链表，比较当前节点值，将较小的节点链接到结果链表。

##### 8.22 旋转链表

**题目：** 旋转一个链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def rotateRight(head, k):
    if not head:
        return head
    dummy = ListNode(0, head)
    prev, curr = dummy, head
    length = 1
    while curr.next:
        curr = curr.next
        length += 1
    k %= length
    for _ in range(length - k - 1):
        curr = curr.next
    curr.next = head
    dummy.next = prev.next
    prev.next = None
    return dummy.next
```

**解析：** 先计算链表长度，然后找到倒数第 `k` 个节点，将链表旋转。

##### 8.23 奇偶链表

**题目：** 将一个链表分隔为奇数链表和偶数链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def oddEvenList(head):
    if not head:
        return head
    odd, even, even_head = head, head.next, head.next
    while even and even.next:
        odd.next = even.next
        odd = odd.next
        even.next = odd.next
        even = even.next
    odd.next = even_head
    return head
```

**解析：** 遍历链表，将奇数节点和偶数节点分开，最后将奇数链表的最后一个节点链接到偶数链表。

##### 8.24 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```python
def longestCommonSubsequence(s1, s2):
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**解析：** 动态规划，构建一个二维数组，保存最长公共子序列的长度。

##### 8.25 最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**答案：**

```python
def longestCommonSubstring(s1, s2):
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    max_len = 0
    max_end = 0
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    max_end = i
            else:
                dp[i][j] = 0
    return s1[max_end - max_len: max_end]
```

**解析：** 动态规划，记录最长公共子串的结束位置和长度。

##### 8.26 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组。

**答案：**

```python
def search(nums, target):
    low, high = 0, len(nums) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        if nums[low] <= nums[mid]:
            if nums[low] <= target < nums[mid]:
                high = mid - 1
            else:
                low = mid + 1
        else:
            if nums[mid] < target <= nums[high]:
                low = mid + 1
            else:
                high = mid - 1
    return -1
```

**解析：** 二分查找，判断中间值与边界值的关系，确定在哪个区间内搜索。

##### 8.27 搜索二维矩阵

**题目：** 搜索一个二维矩阵。

**答案：**

```python
def searchMatrix(matrix, target):
    row, col = 0, len(matrix[0]) - 1
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False
```

**解析：** 从右上角开始搜索，根据当前值与目标值的关系，调整行或列。

##### 8.28 螺旋矩阵

**题目：** 给定一个矩阵，按螺旋顺序打印。

**答案：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    row_start, row_end = 0, len(matrix)
    col_start, col_end = 0, len(matrix[0])
    ans = []
    while row_start < row_end and col_start < col_end:
        for i in range(col_start, col_end):
            ans.append(matrix[row_start][i])
        row_start += 1
        for i in range(row_start, row_end):
            ans.append(matrix[i][col_end - 1])
        col_end -= 1
        if row_start < row_end:
            for i in range(col_end - 1, col_start - 1, -1):
                ans.append(matrix[row_end - 1][i])
            row_end -= 1
        if col_start < col_end:
            for i in range(row_end - 1, row_start - 1, -1):
                ans.append(matrix[i][col_start])
            col_start += 1
    return ans
```

**解析：** 循环遍历矩阵的四个边界，每次循环后缩小边界。

##### 8.29 合并两个有序数组

**题目：** 合并两个有序数组。

**答案：**

```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
```

**解析：** 从后往前比较两个数组中的元素，将较大的元素放入结果数组。

##### 8.30 添加两个正数

**题目：** 添加两个正数。

**答案：**

```python
def addPositive(a, b):
    return a + b
```

**解析：** 简单的加法操作。

