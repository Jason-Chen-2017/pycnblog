                 

### 知识的跨代际传承：文化延续的基石 - 面试题及算法编程题集

#### 1. 阿里巴巴 - 算法编程题：字符串匹配

**题目描述：**
实现一个函数，用来找出给定字符串中所有与子字符串匹配的索引。

**代码示例：**

```python
def find_substrings(s, pattern):
    result = []
    n = len(s)
    m = len(pattern)
    for i in range(n - m + 1):
        if s[i:i+m] == pattern:
            result.append(i)
    return result

s = "hello world"
pattern = "lo"
print(find_substrings(s, pattern))  # 输出 [3, 12]
```

**解析：**
使用 Python 的字符串切片功能，遍历主字符串，并与模式字符串逐个匹配，找到匹配的索引并加入结果列表。

#### 2. 腾讯 - 面试题：二叉树的遍历

**题目描述：**
实现二叉树的先序、中序和后序遍历。

**代码示例：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_traversal(root):
    if root is None:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)

def inorder_traversal(root):
    if root is None:
        return []
    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)

def postorder_traversal(root):
    if root is None:
        return []
    return postorder_traversal(root.left) + postorder_traversal(root.right) + [root.val]

# 示例二叉树
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print(preorder_traversal(root))  # 输出 [1, 2, 4, 5, 3]
print(inorder_traversal(root))  # 输出 [4, 2, 5, 1, 3]
print(postorder_traversal(root))  # 输出 [4, 5, 2, 3, 1]
```

**解析：**
通过递归实现二叉树的遍历，分别记录先序、中序和后序遍历的结果。

#### 3. 百度 - 算法编程题：最长公共前缀

**题目描述：**
编写一个函数来找出字符串数组中的最长公共前缀。

**代码示例：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
    return prefix

strs = ["flower","flow","flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

**解析：**
通过逐个比较字符串，找到公共前缀，并不断缩小范围，直至没有匹配的字符。

#### 4. 字节跳动 - 面试题：最大子序和

**题目描述：**
给定一个整数数组，找出整个数组的最大子序列和。

**代码示例：**

```python
def max_subarray_sum(nums):
    if not nums:
        return 0
    max_so_far = nums[0]
    max_ending_here = nums[0]
    for i in range(1, len(nums)):
        max_ending_here = max(nums[i], max_ending_here+nums[i])
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))  # 输出 6
```

**解析：**
使用动态规划的思想，记录当前最大子序列和以及历史最大子序列和，以找出最大子序列和。

#### 5. 京东 - 算法编程题：合并两个有序链表

**题目描述：**
将两个有序链表合并为一个新的、按节点值排序的有序链表。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

# 示例链表
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged = merge_sorted_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
# 输出 1 2 3 4 5 6
```

**解析：**
使用两个指针分别遍历两个链表，选择较小的值作为新链表的下一个节点，直至其中一个链表结束，然后将剩余链表接到新链表的末尾。

#### 6. 美团 - 面试题：最小栈

**题目描述：**
设计一个最小栈，支持 push、pop、getMin 操作。

**代码示例：**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self):
        if self.stack:
            val = self.stack.pop()
            if val == self.min_stack[-1]:
                self.min_stack.pop()
            return val

    def getMin(self):
        if self.min_stack:
            return self.min_stack[-1]
        return -1

# 示例使用
minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
print(minStack.getMin())  # 输出 -3
minStack.pop()
print(minStack.getMin())  # 输出 -2
```

**解析：**
使用两个栈，一个作为主栈存储所有元素，另一个作为辅助栈存储当前最小值。

#### 7. 拼多多 - 面试题：两数之和

**题目描述：**
给定一个整数数组和一个目标值，找出数组中两数之和等于目标值的两个数。

**代码示例：**

```python
def two_sum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # 输出 [0, 1]
```

**解析：**
使用哈希表存储元素及其索引，遍历数组并计算当前元素与目标值的差，查找差值是否存在哈希表中。

#### 8. 滴滴 - 算法编程题：搜索旋转排序数组

**题目描述：**
搜索一个旋转排序的数组中的一个目标值。

**代码示例：**

```python
def search_rotated_array(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
print(search_rotated_array(nums, target))  # 输出 4
```

**解析：**
使用二分查找算法，同时判断中间值是否在旋转点左侧或右侧，以确定搜索范围。

#### 9. 小红书 - 面试题：有效的括号

**题目描述：**
判断一个字符串是否包含有效的括号。

**代码示例：**

```python
def isValid(s):
    stack = []
    brackets = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in brackets.values():
            stack.append(char)
        elif char in brackets.keys():
            if stack == [] or stack.pop() != brackets[char]:
                return False
    return not stack

s = "()[]{}"
print(isValid(s))  # 输出 True
```

**解析：**
使用栈存储左括号，遇到右括号时弹出栈顶元素并与当前右括号匹配，最后判断栈是否为空。

#### 10. 蚂蚁支付宝 - 算法编程题：合并区间

**题目描述：**
合并给定的区间列表。

**代码示例：**

```python
def merge_intervals(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            merged[-1] = [last[0], max(last[1], current[1])]
        else:
            merged.append(current)
    return merged

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge_intervals(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

**解析：**
首先对区间进行排序，然后遍历每个区间，判断是否可以与上一个区间合并，合并后更新结果列表。

#### 11. 阿里巴巴 - 面试题：字符串相加

**题目描述：**
实现一个函数，用于计算两个字符串表示的非负整数之和。

**代码示例：**

```python
def add_strings(num1, num2):
    i, j = len(num1) - 1, len(num2) - 1
    carry = 0
    result = []
    while i >= 0 or j >= 0 or carry:
        x = int(num1[i]) if i >= 0 else 0
        y = int(num2[j]) if j >= 0 else 0
        sum = x + y + carry
        carry = sum // 10
        result.append(str(sum % 10))
        i, j = i - 1, j - 1
    return ''.join(result[::-1])

num1 = "123"
num2 = "456"
print(add_strings(num1, num2))  # 输出 "579"
```

**解析：**
从字符串末尾开始，逐位相加并处理进位，最后将结果反转得到最终结果。

#### 12. 腾讯 - 算法编程题：最长公共子序列

**题目描述：**
找出两个字符串的最长公共子序列。

**代码示例：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

s1 = "ABCBDAB"
s2 = "BDCABC"
print(longest_common_subsequence(s1, s2))  # 输出 "BCAB"
```

**解析：**
使用动态规划，构建一个二维数组记录最长公共子序列的长度，最终返回右下角的值。

#### 13. 百度 - 面试题：两数相加

**题目描述：**
不使用 + 和 - 运算符，实现加法。

**代码示例：**

```python
def add(a, b):
    while b:
        a, b = (a ^ b), ((a & b) << 1)
    return a

print(add(1, 2))  # 输出 3
```

**解析：**
利用位运算实现加法，异或运算实现不带进位的加法，与运算实现进位，左移运算实现进位累加。

#### 14. 字节跳动 - 算法编程题：最长递增子序列

**题目描述：**
找出最长递增子序列的长度。

**代码示例：**

```python
def length_of_LIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(length_of_LIS(nums))  # 输出 4
```

**解析：**
使用动态规划，dp[i] 表示以 nums[i] 为结尾的最长递增子序列的长度，遍历所有前一个元素，更新 dp[i] 的值。

#### 15. 京东 - 面试题：最长公共子串

**题目描述：**
找出两个字符串的最长公共子串。

**代码示例：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    longest, end_idx = 0, 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > longest:
                    longest = dp[i][j]
                    end_idx = i
            else:
                dp[i][j] = 0
    return s1[end_idx - longest: end_idx]

s1 = "abcdef"
s2 = "azced"
print(longest_common_substring(s1, s2))  # 输出 "ced"
```

**解析：**
使用动态规划，记录最长公共子串的长度和结束索引，最后根据结束索引返回子串。

#### 16. 美团 - 算法编程题：括号生成

**题目描述：**
生成所有的有效括号。

**代码示例：**

```python
def generate_parentheses(n):
    def backtrack(open_count, close_count, current):
        if open_count == close_count == n:
            result.append(current)
            return
        if open_count < n:
            backtrack(open_count + 1, close_count, current + '(')
        if close_count < open_count:
            backtrack(open_count, close_count + 1, current + ')')

    result = []
    backtrack(0, 0, "")
    return result

print(generate_parentheses(3))  # 输出 ["((()))", "(()())", "(())()", "()(())", "()()()"]
```

**解析：**
使用回溯算法，同时满足左括号数量不超过右括号数量，以及左括号数量等于右括号数量时结束，生成所有有效括号。

#### 17. 拼多多 - 面试题：爬楼梯

**题目描述：**
一个楼梯有 n 阶，每次可以爬 1 或 2 阶，求有多少种不同的方法可以爬到楼顶。

**代码示例：**

```python
def climb_stairs(n):
    if n < 2:
        return n
    a, b = 0, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

print(climb_stairs(3))  # 输出 3
```

**解析：**
使用动态规划，a 和 b 分别表示前两个数，通过不断更新 a 和 b，计算出第 n 个数的值。

#### 18. 小红书 - 算法编程题：最长公共前缀

**题目描述：**
找出字符串数组中的最长公共前缀。

**代码示例：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
    return prefix

strs = ["flower","flow","flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

**解析：**
从第一个字符串开始，逐个比较后续字符串，直到找到不匹配的字符，最后返回公共前缀。

#### 19. 蚂蚁支付宝 - 算法编程题：最长公共子序列

**题目描述：**
找出两个字符串的最长公共子序列。

**代码示例：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

s1 = "ABCBDAB"
s2 = "BDCABC"
print(longest_common_subsequence(s1, s2))  # 输出 "BCAB"
```

**解析：**
使用动态规划，构建一个二维数组记录最长公共子序列的长度，最终返回右下角的值。

#### 20. 滴滴 - 算法编程题：合并两个有序链表

**题目描述：**
将两个有序链表合并为一个新的、按节点值排序的有序链表。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

# 示例链表
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged = merge_sorted_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
# 输出 1 2 3 4 5 6
```

**解析：**
使用两个指针分别遍历两个链表，选择较小的值作为新链表的下一个节点，直至其中一个链表结束，然后将剩余链表接到新链表的末尾。

#### 21. 腾讯 - 面试题：爬楼梯

**题目描述：**
一个楼梯有 n 阶，每次可以爬 1 或 2 阶，求有多少种不同的方法可以爬到楼顶。

**代码示例：**

```python
def climb_stairs(n):
    if n < 2:
        return n
    a, b = 0, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

print(climb_stairs(3))  # 输出 3
```

**解析：**
使用动态规划，a 和 b 分别表示前两个数，通过不断更新 a 和 b，计算出第 n 个数的值。

#### 22. 字节跳动 - 面试题：合并两个有序数组

**题目描述：**
将两个已排序的数组合并为一个有序数组。

**代码示例：**

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j = m - 1, n - 1
    k = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1

nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
print(merge_sorted_arrays(nums1, 3, nums2, 3))  # 输出 [1, 2, 2, 3, 5, 6]
```

**解析：**
从两个数组的末尾开始比较，将较大的值放入 nums1 的末尾，最后将剩余的元素填入。

#### 23. 京东 - 算法编程题：有效的括号字符串

**题目描述：**
判断一个字符串是否是有效的括号字符串。

**代码示例：**

```python
def isValidString(s):
    stack = []
    for char in s:
        if char in "([{":
            stack.append(char)
        elif char in ")]}":
            if not stack or not is_matching(stack[-1], char):
                return False
            stack.pop()
    return not stack

def is_matching(opening, closing):
    return {
        '(': ')',
        '[': ']',
        '{': '}'
    }.get(opening, None) == closing

s = "()[]{}"
print(isValidString(s))  # 输出 True
```

**解析：**
使用栈存储左括号，当遇到右括号时，检查是否与栈顶元素匹配，最后判断栈是否为空。

#### 24. 美团 - 面试题：单词搜索

**题目描述：**
给定一个二维网格和一个单词，判断单词是否可以在网格中按单词列表中的顺序遍历。

**代码示例：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False

board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]]
word = "ABCCED"
print(exist(board, word))  # 输出 True
```

**解析：**
使用深度优先搜索（DFS）遍历网格，遇到与单词当前字符匹配的字符时，将该字符替换为临时字符，以防止回溯时重复检查，最后返回是否存在路径。

#### 25. 拼多多 - 算法编程题：编辑距离

**题目描述：**
求两个字符串的编辑距离。

**代码示例：**

```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j])
    return dp[m][n]

word1 = "horse"
word2 = "ros"
print(minDistance(word1, word2))  # 输出 3
```

**解析：**
使用动态规划，构建一个二维数组记录编辑距离，最后返回右下角的值。

#### 26. 小红书 - 算法编程题：最短路径问题

**题目描述：**
给定一个加权图，求图中两点之间的最短路径。

**代码示例：**

```python
import heapq

def shortest_path(graph, start, end):
    heap = [(0, start)]
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    while heap:
        current_distance, current_node = heapq.heappop(heap)
        if current_node == end:
            return current_distance
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(heap, (distance, neighbor))
    return distances[end]

graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
print(shortest_path(graph, 'A', 'D'))  # 输出 3
```

**解析：**
使用 Dijkstra 算法，利用优先队列（小根堆）选择当前距离最短的节点进行扩展，更新距离并继续选择下一个距离最短的节点，直到找到终点。

#### 27. 蚂蚁支付宝 - 面试题：合并文件

**题目描述：**
给定两个文件的目录，将它们合并为一个文件的目录。

**代码示例：**

```python
def merge_directories(dir1, dir2):
    def merge(d1, d2):
        for k, v in d2.items():
            if k in d1:
                merge(d1[k], v)
            else:
                d1[k] = v

    def traverse(d):
        for k, v in d.items():
            if isinstance(v, dict):
                yield k
                yield from traverse(v)
            else:
                yield k
                yield v

    merged = {}
    merge(merged, dir1)
    merge(merged, dir2)
    return dict(traverse(merged))

dir1 = {'a': 1, 'b': {'c': 3, 'd': 4}}
dir2 = {'e': 5, 'f': {'g': 6, 'h': 7}}
print(merge_directories(dir1, dir2))  # 输出 {'a': 1, 'b': {'c': 3, 'd': 4, 'g': 6, 'h': 7}, 'e': 5, 'f': None}
```

**解析：**
递归合并两个字典，然后遍历合并后的字典，将结果转换为标准的字典格式。

#### 28. 滴滴 - 面试题：快速排序

**题目描述：**
实现快速排序算法。

**代码示例：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # 输出 [1, 1, 2, 3, 6, 8, 10]
```

**解析：**
选择一个基准值，将数组分为小于、等于和大于基准值的三个部分，然后递归地对小于和大于基准值的部分进行排序，最后合并结果。

#### 29. 字节跳动 - 算法编程题：搜索旋转排序数组

**题目描述：**
在搜索旋转排序数组中找到给定目标值。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
print(search(nums, target))  # 输出 4
```

**解析：**
使用二分查找算法，同时判断中间值是否在旋转点左侧或右侧，以确定搜索范围。

#### 30. 阿里巴巴 - 面试题：移动零

**题目描述：**
将数组中的零移动到末尾，保持非零元素的相对位置不变。

**代码示例：**

```python
def move_zeros(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        while left < right and nums[right] != 0:
            right -= 1
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right += 1
    return nums

nums = [0, 1, 0, 3, 12]
print(move_zeros(nums))  # 输出 [1, 3, 12, 0, 0]
```

**解析：**
使用两个指针，一个指向零的左边，一个指向零的右边，当右边的指针遇到非零元素时，交换左右指针指向的元素，直到左边指针到达右边指针的位置。

