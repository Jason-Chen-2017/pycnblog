                 

### 华为2024社招面试真题与算法题解

**一、面试真题解析**

#### 1. 计算器表达式求值

**题目：** 实现一个计算器，支持四则运算，计算一个字符串表达式的值。

**解析：** 使用栈模拟运算过程，遇到操作数直接入栈，遇到运算符则取出栈顶两个操作数进行运算，再将结果入栈。

**答案：**

```python
class Solution:
    def calculate(self, s: str) -> int:
        def operate(a, b, op):
            if op == '+':
                return a + b
            if op == '-':
                return a - b
            if op == '*':
                return a * b
            if op == '/':
                return a // b

        stk = []
        num = 0
        op = '+'
        for ch in s:
            if ch.isdigit():
                num = num * 10 + int(ch)
            if ch in "+-*/" or ch == s[-1]:
                stk.append(operate(stk.pop(), stk.pop(), op))
                op = ch
                num = 0
        return stk[-1]
```

#### 2. 合并两个有序链表

**题目：** 合并两个有序链表，将其合并成一个有序链表。

**解析：** 使用两个指针分别遍历两个链表，比较当前节点值，选择较小的一个作为新链表的下一个节点。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        p, q = list1, list2
        while p and q:
            if p.val < q.val:
                curr.next = p
                p = p.next
            else:
                curr.next = q
                q = q.next
            curr = curr.next
        curr.next = p if p else q
        return dummy.next
```

#### 3. 二叉树的最近公共祖先

**题目：** 给定一个二叉树和一个目标节点，找到二叉树中最近公共祖先节点。

**解析：** 递归遍历左右子树，若当前节点等于目标节点，返回当前节点。若左右子树返回的节点非空，则当前节点为最近公共祖先。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == p or root == q:
            return root
        if not root.left and not root.right:
            return None
        left, right = self.lowestCommonAncestor(root.left, p, q), self.lowestCommonAncestor(root.right, p, q)
        if left and right:
            return root
        if left:
            return left
        if right:
            return right
```

#### 4. 最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**解析：** 从第一个字符串开始，逐个比较后续字符串，一旦出现不同则停止比较。

**答案：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for i in range(len(strs[0])):
            ch = strs[0][i]
            for j in range(1, len(strs)):
                if i >= len(strs[j]) or strs[j][i] != ch:
                    return prefix
            prefix += ch
        return prefix
```

#### 5. 合并区间

**题目：** 合并一个区间的列表。

**解析：** 首先对区间列表进行排序，然后遍历合并相邻的区间。

**答案：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if not intervals:
            return []
        intervals.sort(key=lambda x: x[0])
        ans = [intervals[0]]
        for i in range(1, len(intervals)):
            if ans[-1][1] >= intervals[i][0]:
                ans[-1][1] = max(ans[-1][1], intervals[i][1])
            else:
                ans.append(intervals[i])
        return ans
```

#### 6. 双指针

**题目：** 利用双指针找出两个有序数组的中位数。

**解析：** 分别定义两个指针，分别遍历两个数组，比较当前指针指向的元素，移动较小的一个指针。

**答案：**

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p, q = 0, 0
        mid, n = 0, len(nums1) + len(nums2)
        if n % 2 == 0:
            mid = (findKth(nums1, nums2, p, q, n // 2) + findKth(nums1, nums2, p, q, n // 2 + 1)) / 2
        else:
            mid = findKth(nums1, nums2, p, q, n // 2 + 1)
        return mid

    def findKth(self, nums1, nums2, p, q, k):
        m, n = len(nums1), len(nums2)
        if p >= m:
            return nums2[q + k - 1]
        if q >= n:
            return nums1[p + k - 1]
        if k == 1:
            return min(nums1[p], nums2[q])
        i, j = min(k // 2, m - p), min(k // 2, n - q)
        if nums1[p + i - 1] > nums2[q + j - 1]:
            return self.findKth(nums1, nums2, p + i, q, k - i)
        else:
            return self.findKth(nums1, nums2, p, q + j, k - j)
```

#### 7. 二分查找

**题目：** 实现一个二分查找算法，找出给定有序数组中的目标元素。

**解析：** 根据目标元素与中间元素的大小关系，决定是继续在左侧还是右侧查找。

**答案：**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

#### 8. 快排

**题目：** 实现一个快速排序算法，对给定数组进行排序。

**解析：** 选择一个基准元素，将数组分为两部分，一部分比基准元素小，一部分比基准元素大。

**答案：**

```python
class Solution:
    def quickSort(self, nums):
        if len(nums) <= 1:
            return nums
        pivot = nums[len(nums) // 2]
        left = [x for x in nums if x < pivot]
        middle = [x for x in nums if x == pivot]
        right = [x for x in nums if x > pivot]
        return self.quickSort(left) + middle + self.quickSort(right)
```

#### 9. 广度优先搜索

**题目：** 利用广度优先搜索实现图的最短路径问题。

**解析：** 使用队列存储待搜索的节点，每次取出节点，遍历其邻居，将其加入队列。

**答案：**

```python
from collections import deque

class Solution:
    def shortestPathGraph(self, graph, start, end):
        queue = deque([start])
        distances = {start: 0}
        while queue:
            node = queue.popleft()
            if node == end:
                break
            for neighbor in graph[node]:
                if neighbor not in distances:
                    distances[neighbor] = distances[node] + 1
                    queue.append(neighbor)
        return distances[end]
```

#### 10. 深度优先搜索

**题目：** 利用深度优先搜索实现图的遍历。

**解析：** 递归遍历每个节点的邻居。

**答案：**

```python
def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

visited = set()
dfs(graph, 'A', visited)
```

#### 11. 爬楼梯问题

**题目：** 一个楼梯共有 n 个台阶，每次可以爬 1 或 2 个台阶，求有多少种不同的方法可以爬到楼顶。

**解析：** 使用动态规划，定义 dp[i] 表示到达第 i 个台阶的方法数。

**答案：**

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[n]
```

#### 12. 股票买卖问题

**题目：** 给定一个股票价格数组，找出一个最大利润的买卖点。

**解析：** 使用动态规划，定义 dp[i] 表示到达第 i 天的最大利润。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], -prices[i])
        return dp[n - 1][0]
```

#### 13. 动态规划

**题目：** 计算斐波那契数列的第 n 项。

**解析：** 使用动态规划，定义 dp[i] 表示斐波那契数列的第 i 项。

**答案：**

```python
class Solution:
    def fib(self, n: int) -> int:
        if n <= 1:
            return n
        dp = [0] * (n + 1)
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[n]
```

#### 14. 字符串匹配

**题目：** 使用 KMP 算法实现字符串匹配。

**解析：** 构造部分匹配表，用于优化模式串与主串的匹配过程。

**答案：**

```python
class Solution:
    def kmp(self, s: str, p: str) -> int:
        n, m = len(s), len(p)
        lps = [0] * m
        j = 0
        for i in range(1, m):
            while j > 0 and p[j] != p[i]:
                j = lps[j - 1]
            if p[j] == p[i]:
                lps[i] = j + 1
                j += 1
        i = 0
        j = 0
        while i < n:
            while j > 0 and s[i] != p[j]:
                j = lps[j - 1]
            if s[i] == p[j]:
                i += 1
                j += 1
            if j == m:
                return i - j
        return -1
```

#### 15. 数据结构

**题目：** 设计一个 LRU 缓存。

**解析：** 使用哈希表和双向链表实现，哈希表存储键值对，双向链表存储最近最少使用的数据。

**答案：**

```python
from collections import deque

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.queue = deque()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.queue.append(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache[key] = value
            self.queue.append(key)
        else:
            self.cache[key] = value
            self.queue.append(key)
            if len(self.queue) > self.capacity:
                old_key = self.queue.popleft()
                del self.cache[old_key]
```

#### 16. 位操作

**题目：** 实现一个位运算的加法。

**解析：** 使用位运算实现无进位的加法，然后逐位判断是否有进位，累加进位。

**答案：**

```python
class Solution:
    def add(self, num1: int, num2: int) -> int:
        while num2 != 0:
            carry = num1 & num2
            num1 = num1 ^ num2
            num2 = carry << 1
        return num1
```

#### 17. 二进制表示

**题目：** 判断一个整数是否是 2 的幂。

**解析：** 一个数如果是 2 的幂，那么它的二进制表示中只有一个 1。

**答案：**

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0
```

#### 18. 双指针

**题目：** 找出数组中的重复元素。

**解析：** 使用双指针，一个指针向前遍历，一个指针指向当前元素的位置。

**答案：**

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[nums[0]]
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        slow = 0
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```

#### 19. 线段树

**题目：** 设计一个线段树，支持查询和更新操作。

**解析：** 线段树是一种高效处理区间查询和更新的数据结构。

**答案：**

```python
class Node:
    def __init__(self, l, r):
        self.l = l
        self.r = r
        self.mid = (l + r) // 2
        self.left = None
        self.right = None
        self.v = 0

class SegmentTree:
    def build(self, nums):
        self.root = self._build_tree(nums, 0, len(nums) - 1)

    def _build_tree(self, nums, l, r):
        if l > r:
            return None
        node = Node(l, r)
        if l == r:
            node.v = nums[l]
            return node
        mid = (l + r) // 2
        node.left = self._build_tree(nums, l, mid)
        node.right = self._build_tree(nums, mid + 1, r)
        node.v = node.left.v + node.right.v
        return node

    def update(self, i, val):
        self._update_tree(self.root, i, val)

    def _update_tree(self, node, i, val):
        if node.l == i and node.r == i:
            node.v = val
            return
        mid = (node.l + node.r) // 2
        if i <= mid:
            self._update_tree(node.left, i, val)
        else:
            self._update_tree(node.right, i, val)
        node.v = node.left.v + node.right.v

    def query(self):
        return self.root.v

tree = SegmentTree()
nums = [1, 2, 3, 4, 5]
tree.build(nums)
tree.update(2, 10)
print(tree.query())  # 输出 15
```

#### 20. 字符串

**题目：** 判断字符串是否是回文。

**解析：** 使用双指针，一个指针指向字符串开头，一个指针指向字符串结尾，逐个比较字符。

**答案：**

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        left, right = 0, len(s) - 1
        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            if s[left].lower() != s[right].lower():
                return False
            left, right = left + 1, right - 1
        return True
```

#### 21. 前缀树

**题目：** 设计一个前缀树，支持插入和搜索操作。

**解析：** 使用哈希表实现前缀树，哈希表中的键为字符串的前缀，值为节点。

**答案：**

```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, word):
        node = self
        for ch in word:
            idx = ord(ch) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end = True

    def search(self, word):
        node = self
        for ch in word:
            idx = ord(ch) - ord('a')
            if node.children[idx] is None:
                return False
            node = node.children[idx]
        return node.is_end

trie = Trie()
words = ["apple", "app", "bat"]
for word in words:
    trie.insert(word)
print(trie.search("apple"))  # 输出 True
print(trie.search("app"))  # 输出 True
print(trie.search("bat"))  # 输出 True
print(trie.search("banana"))  # 输出 False
```

#### 22. 数学

**题目：** 计算两个整数的最大公约数。

**解析：** 使用辗转相除法，也称为欧几里得算法。

**答案：**

```python
class Solution:
    def gcd(self, a: int, b: int) -> int:
        while b:
            a, b = b, a % b
        return a
```

#### 23. 栈和队列

**题目：** 用两个栈实现一个队列。

**解析：** 一个栈用于入队操作，一个栈用于出队操作。

**答案：**

```python
class MyQueue:
    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def push(self, x: int) -> None:
        self.stack_in.append(x)

    def pop(self) -> int:
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())
        return self.stack_out.pop()

    def empty(self) -> bool:
        return not (self.stack_in or self.stack_out)
```

#### 24. 排序算法

**题目：** 实现一个快速排序算法。

**解析：** 选择一个基准元素，将数组分为两部分，一部分比基准元素小，一部分比基准元素大。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))
```

#### 25. 链表

**题目：** 反转一个单链表。

**解析：** 使用递归或迭代方式，逐个调整节点指向。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    if not head or not head.next:
        return head
    p = reverse_linked_list(head.next)
    head.next.next = head
    head.next = None
    return p

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
new_head = reverse_linked_list(head)
while new_head:
    print(new_head.val, end=" ")
    new_head = new_head.next
```

#### 26. 树

**题目：** 计算二叉树的节点数量。

**解析：** 递归遍历二叉树，累加节点数量。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def count_nodes(root):
    if not root:
        return 0
    return 1 + count_nodes(root.left) + count_nodes(root.right)

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
print(count_nodes(root))
```

#### 27. 动态规划

**题目：** 计算最长公共子序列。

**解析：** 使用动态规划，定义 dp[i][j] 表示文本 s1 的前 i 个字符和文本 s2 的前 j 个字符的最长公共子序列长度。

**答案：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))
```

#### 28. 网络流

**题目：** 使用 Ford-Fulkerson 算法计算网络的最大流。

**解析：** 递归查找增广路径，更新网络流，直到无法找到增广路径。

**答案：**

```python
def max_flow(graph, source, sink):
    def dfs(u, flow):
        if u == sink:
            return flow
        for v, capacity in graph[u].items():
            if capacity > 0 and not visited[v]:
                visited[v] = True
                f = dfs(v, min(flow, capacity))
                if f > 0:
                    graph[u][v] -= f
                    graph[v][u] += f
                    return f
        return 0

    visited = [False] * len(graph)
    max_flow = 0
    while True:
        visited = [False] * len(graph)
        f = dfs(source, float("inf"))
        while f > 0:
            max_flow += f
            f = dfs(source, float("inf"))
        return max_flow

graph = {
    0: {1: 3, 2: 3},
    1: {2: 2, 3: 3},
    2: {4: 3},
    3: {4: 2},
    4: {}
}

source, sink = 0, 4
print(max_flow(graph, source, sink))
```

#### 29. 并查集

**题目：** 使用并查集实现集合的操作。

**解析：** 使用路径压缩和按秩合并优化并查集。

**答案：**

```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.size = [1] * size

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]

uf = UnionFind(5)
uf.union(1, 2)
uf.union(2, 3)
uf.union(4, 5)
print(uf.find(1) == uf.find(3))  # 输出 True
print(uf.find(1) == uf.find(4))  # 输出 True
```

#### 30. 状态压缩动态规划

**题目：** 使用状态压缩动态规划计算 01 背包问题的解。

**解析：** 将物品和背包状态编码为整数，使用动态规划求解。

**答案：**

```python
def knapsack(values, weights, W):
    n = len(values)
    dp = [[False] * (W + 1) for _ in range(1 << n)]
    dp[0][0] = True
    for i in range(1, 1 << n):
        bit = i & -i
        j = i - bit
        v, w = values[j], weights[j]
        if dp[j][i - j]:
            dp[i][i - j + w] = True
        if dp[j][i]:
            dp[i][i - j] = True
    return sum(dp[-1]) - 1

values = [2, 3, 4]
weights = [3, 4, 5]
W = 8
print(knapsack(values, weights, W))
```

### 二、算法编程题解

#### 1. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 从 beginning 到 end 都是有序的。

**解析：** 从两个数组的末尾开始比较，将较大的元素依次放入 nums1 的末尾。

**答案：**

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        i, j = m - 1, n - 1
        k = m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

#### 2. 三数之和

**题目：** 给定一个数组 nums 和一个目标值 target，找出三个元素使得它们的和等于 target。

**解析：** 首先对数组进行排序，然后使用双指针法，一个指针指向当前元素，另外两个指针分别在当前元素的左右两端。

**答案：**

```python
class Solution:
    def threeSum(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total < target:
                    left += 1
                elif total > target:
                    right -= 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
        return ans
```

#### 3. 最长上升子序列

**题目：** 给定一个整数数组 nums ，找到一个连续的子数组，使子数组内的每个数均递增，且长度最长。

**解析：** 使用动态规划，定义 dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。

**答案：**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        ans = 1
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
            ans = max(ans, dp[i])
        return ans
```

#### 4. 盛水问题

**题目：** 给定一个长度为 n 的整数数组 height ，表示一个由长方体块组成的墙，计算在墙内可以盛水的最大体积。

**解析：** 使用双指针法，一个指针指向墙的左侧，一个指针指向墙的右侧，计算当前两个指针之间的水柱面积，然后移动较短的一侧的指针。

**答案：**

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        ans = 0
        left, right = 0, len(height) - 1
        left_max, right_max = 0, 0
        while left < right:
            left_max = max(left_max, height[left])
            right_max = max(right_max, height[right])
            if left_max < right_max:
                ans += left_max - height[left]
                left += 1
            else:
                ans += right_max - height[right]
                right -= 1
        return ans
```

#### 5. 排序链表

**题目：** 给定一个单链表，将其排序。

**解析：** 使用归并排序，将链表拆分为两个子链表，分别排序，然后合并。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        mid = self.getMid(head)
        left, right = self.sortList(head), self.sortList(mid)
        return self.merge(left, right)

    def getMid(self, head):
        slow, fast = head, head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None
        return mid

    def merge(self, left, right):
        dummy = ListNode(0)
        curr = dummy
        while left and right:
            if left.val < right.val:
                curr.next = left
                left = left.next
            else:
                curr.next = right
                right = right.next
            curr = curr.next
        curr.next = left if left else right
        return dummy.next
```

#### 6. 长字转换

**题目：** 将一个数字转换为其对应的英文表示。

**解析：** 将数字拆分为千、百万、亿等单位，分别转换为英文表示，然后拼接。

**答案：**

```python
class Solution:
    def numberToWords(self, num: int) -> str:
        def one(num):
            if num < 20:
                return ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"][num]
            else:
                return ["Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"][num // 10] + ("-" if num % 10 else "")

        def ten(num):
            return one(num % 10)

        def thousand(num):
            if num < 1000:
                return one(num)
            return one(num // 1000) + " Thousand" + ("-" if num % 1000 else "")

        if num == 0:
            return "Zero"
        ans = ""
        while num:
            if num % 1000 == 0:
                ans = thousand(num) + " " + ans
                num = num // 1000
            else:
                ans = one(num % 1000) + " " + ans
                num = num // 1000
        return ans.strip()
```

#### 7. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，查找一个给定目标值的索引。

**解析：** 利用二分查找，寻找旋转点，然后分别在两个有序数组中查找。

**答案：**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def find_rotate_index(left, right):
            if nums[left] < nums[right]:
                return 0
            while left <= right:
                pivot = (left + right) // 2
                if nums[pivot] > nums[pivot + 1]:
                    return pivot + 1
                if nums[pivot] < nums[left]:
                    right = pivot - 1
                else:
                    left = pivot + 1

        n = len(nums)
        rotate_index = find_rotate_index(0, n - 1)
        left, right = 0, n - 1
        if target >= nums[0]:
            left = rotate_index
            right = n - 1
        else:
            left = 0
            right = rotate_index - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        return -1
```

#### 8. 最大子序和

**题目：** 给定一个整数数组，找出最大子序和。

**解析：** 使用动态规划，定义 dp[i] 表示以 nums[i] 结尾的最大子序和。

**答案：**

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        ans = nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            dp[i] = max(dp[i - 1] + nums[i], nums[i])
            ans = max(ans, dp[i])
        return ans
```

#### 9. 二分查找

**题目：** 实现一个二分查找算法，查找给定有序数组中的目标元素。

**解析：** 根据目标元素与中间元素的大小关系，决定是继续在左侧还是右侧查找。

**答案：**

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```

#### 10. 快排

**题目：** 实现一个快速排序算法，对给定数组进行排序。

**解析：** 选择一个基准元素，将数组分为两部分，一部分比基准元素小，一部分比基准元素大。

**答案：**

```python
class Solution:
    def quickSort(self, nums):
        if len(nums) <= 1:
            return nums
        pivot = nums[len(nums) // 2]
        left = [x for x in nums if x < pivot]
        middle = [x for x in nums if x == pivot]
        right = [x for x in nums if x > pivot]
        return self.quickSort(left) + middle + self.quickSort(right)
```

#### 11. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 从 beginning 到 end 都是有序的。

**解析：** 从两个数组的末尾开始比较，将较大的元素依次放入 nums1 的末尾。

**答案：**

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        i, j = m - 1, n - 1
        k = m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

#### 12. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，找出它们的最长公共子序列。

**解析：** 使用动态规划，定义 dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列长度。

**答案：**

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

#### 13. 最小生成树

**题目：** 给定一个无向图的边数组，找出最小生成树的总权重。

**解析：** 使用 Prim 算法或 Kruskal 算法求解。

**答案：**

```python
from heapq import heappop, heappush

def prim(edges, n):
    mst = [False] * n
    weight = 0
    edges.sort(key=lambda x: x[2])
    for edge in edges:
        u, v, w = edge
        if mst[u] or mst[v]:
            continue
        weight += w
        mst[u] = mst[v] = True
    return weight

def kruskal(edges, n):
    parent = list(range(n))
    rank = [0] * n
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]

    def union(x, y):
        rootX = find(x)
        rootY = find(y)
        if rootX != rootY:
            if rank[rootX] > rank[rootY]:
                parent[rootY] = rootX
            elif rank[rootX] < rank[rootY]:
                parent[rootX] = rootY
            else:
                parent[rootY] = rootX
                rank[rootX] += 1

    edges.sort(key=lambda x: x[2])
    weight = 0
    for edge in edges:
        u, v, w = edge
        if find(u) != find(v):
            weight += w
            union(u, v)
    return weight
```

#### 14. 单调栈

**题目：** 给定一个数组，求出每个元素左边第一个比它大的元素和右边第一个比它小的元素。

**解析：** 使用单调栈实现。

**答案：**

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        ans = [-1] * len(nums1)
        for num in nums2:
            while stack and num > stack[-1]:
                ans[stack.pop()] = num
            stack.append(num)
        return ans
```

#### 15. 动态规划

**题目：** 给定一个字符串，找出最长回文子串。

**解析：** 使用动态规划，定义 dp[i][j] 表示字符串 s 的子串 s[i][j] 是否是回文。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        start, max_len = 0, 1
        for i in range(n):
            dp[i][i] = True
            if i < n - 1 and s[i] == s[i + 1]:
                dp[i][i + 1] = True
                start, max_len = i, 2
        for i in range(n - 2, -1, -1):
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    if j - i == 1 or dp[i + 1][j - 1]:
                        dp[i][j] = True
                        start, max_len = i, j - i + 1
        return s[start: start + max_len]
```

#### 16. 前缀和

**题目：** 给定一个整数数组，找出两个和为给定值的元素。

**解析：** 使用前缀和和哈希表实现。

**答案：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        s = {0: -1}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in s:
                return [s[complement] + 1, i]
            s[num] = i
        return []
```

#### 17. 滑动窗口

**题目：** 给定一个字符串，找出其中最长的重复子串。

**解析：** 使用滑动窗口实现。

**答案：**

```python
class Solution:
    def longestRepeatingSubstring(self, s: str) -> str:
        def kmp(s):
            n = len(s)
            pi = [0] * n
            j = 0
            for i in range(1, n):
                while j and s[i] != s[j]:
                    j = pi[j - 1]
                if s[i] == s[j]:
                    j += 1
                    pi[i] = j
            return pi

        pi = kmp(s)
        j = 0
        for i in range(len(pi)):
            if pi[-1] - i > j:
                j = pi[-1] - i
        return s[-j:]
```

#### 18. 双指针

**题目：** 给定一个整数数组，找出两个数使得它们的和等于给定值。

**解析：** 使用双指针实现。

**答案：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while left < right:
            total = nums[left] + nums[right]
            if total == target:
                return [left, right]
            elif total < target:
                left += 1
            else:
                right -= 1
        return []
```

#### 19. 树状数组

**题目：** 给定一个整数数组，求每个前缀和的异或值。

**解析：** 使用树状数组实现。

**答案：**

```python
class BinaryIndexedTree:
    def __init__(self, n):
        self.n = n
        self.c = [0] * (n + 1)

    def update(self, i, x):
        while i <= self.n:
            self.c[i] ^= x
            i += i & -i

    def query(self, i):
        s = 0
        while i > 0:
            s ^= self.c[i]
            i -= i & -i
        return s

nums = [1, 3, 5, 7, 9]
bit = BinaryIndexedTree(len(nums))
for num in nums:
    bit.update(num, num)
for i in range(len(nums) + 1):
    print(bit.query(i))
```

#### 20. 链表

**题目：** 反转单链表。

**解析：** 使用递归或迭代反转链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    if not head or not head.next:
        return head
    p = reverse_linked_list(head.next)
    head.next.next = head
    head.next = None
    return p

head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
new_head = reverse_linked_list(head)
while new_head:
    print(new_head.val, end=" ")
    new_head = new_head.next
```

#### 21. 图

**题目：** 求图中两个顶点的最短路径。

**解析：** 使用 Dijkstra 算法或 BFS 算法求解。

**答案：**

```python
from heapq import heappop, heappush

def dijkstra(edges, n, start):
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]
    while pq:
        d, u = heappop(pq)
        if d > dist[u]:
            continue
        for v, w in edges[u]:
            if dist[v] > d + w:
                dist[v] = d + w
                heappush(pq, (dist[v], v))
    return dist

edges = [
    [(1, 3), (2, 2)],
    [(1, 1), (3, 3)],
    [(2, 1), (3, 1)],
    [(1, 2), (2, 1)],
    [(1, 1), (2, 1), (3, 1)]
]
print(dijkstra(edges, 4, 0))
```

#### 22. 并查集

**题目：** 求图中连通分量数量。

**解析：** 使用并查集实现。

**答案：**

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]

uf = UnionFind(5)
uf.union(1, 2)
uf.union(2, 3)
uf.union(4, 5)
print(uf.find(1) == uf.find(3))  # 输出 True
print(uf.find(1) == uf.find(4))  # 输出 True
```

#### 23. 字符串

**题目：** 求最长公共前缀。

**解析：** 从第一个字符串开始，逐个比较后续字符串。

**答案：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for i in range(len(strs[0])):
            ch = strs[0][i]
            for j in range(1, len(strs)):
                if i >= len(strs[j]) or strs[j][i] != ch:
                    return prefix
            prefix += ch
        return prefix
```

#### 24. 前缀树

**题目：** 实现一个前缀树。

**解析：** 使用哈希表实现前缀树，哈希表中的键为字符串的前缀，值为节点。

**答案：**

```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, word):
        node = self
        for ch in word:
            idx = ord(ch) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end = True

    def search(self, word):
        node = self
        for ch in word:
            idx = ord(ch) - ord('a')
            if node.children[idx] is None:
                return False
            node = node.children[idx]
        return node.is_end

trie = Trie()
words = ["apple", "app", "bat"]
for word in words:
    trie.insert(word)
print(trie.search("apple"))  # 输出 True
print(trie.search("app"))  # 输出 True
print(trie.search("bat"))  # 输出 True
print(trie.search("banana"))  # 输出 False
```

#### 25. 双向链表

**题目：** 实现一个双向链表。

**解析：** 使用两个指针分别指向头节点和尾节点。

**答案：**

```python
class Node:
    def __init__(self, val=0, next=None, prev=None):
        self.val = val
        self.next = next
        self.prev = prev

class DoublyLinkedList:
    def __init__(self):
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head

    def append(self, val):
        new_node = Node(val)
        new_node.prev = self.tail.prev
        self.tail.prev.next = new_node
        self.tail.prev = new_node

    def remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def print_list(self):
        curr = self.head.next
        while curr != self.tail:
            print(curr.val, end=" ")
            curr = curr.next
        print()

dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.print_list()  # 输出 1 2 3
dll.remove(dll.head.next.next)
dll.print_list()  # 输出 1 2
```

#### 26. 设计模式

**题目：** 实现单例模式。

**解析：** 使用静态方法确保单例的唯一性。

**答案：**

```python
class Singleton:
    _instance = None

    @classmethod
    def getInstance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

singleton1 = Singleton.getInstance()
singleton2 = Singleton.getInstance()
print(singleton1 is singleton2)  # 输出 True
```

#### 27. 状态机

**题目：** 实现一个状态机。

**解析：** 使用类表示状态，类中定义转移方法和状态。

**答案：**

```python
class State:
    def __init__(self, name):
        self.name = name

    def on_entry(self):
        print(f"Entering {self.name} state")

    def on_exit(self):
        print(f"Exiting {self.name} state")

    def on_event(self, event):
        print(f"State {self.name} does not handle event {event}")

class StateMachine:
    def __init__(self):
        self.states = {
            "state1": State("State1"),
            "state2": State("State2"),
            "state3": State("State3"),
        }
        self.current_state = self.states["state1"]

    def change_state(self, state_name):
        self.current_state.on_exit()
        self.current_state = self.states[state_name]
        self.current_state.on_entry()

    def handle_event(self, event):
        self.current_state.on_event(event)

state_machine = StateMachine()
state_machine.handle_event("event1")
state_machine.change_state("state2")
state_machine.handle_event("event2")
state_machine.change_state("state3")
state_machine.handle_event("event3")
```

#### 28. 多线程

**题目：** 实现一个生产者消费者问题。

**解析：** 使用多线程模拟生产者和消费者。

**答案：**

```python
import threading

class ProducerConsumer:
    def __init__(self, size):
        self.buffer = [None] * size
        self.in_index = 0
        self.out_index = 0
        self.lock = threading.Lock()
        self.not_full = threading.Condition(self.lock)
        self.not_empty = threading.Condition(self.lock)

    def produce(self, item):
        with self.not_full:
            self.buffer[self.in_index] = item
            self.in_index = (self.in_index + 1) % len(self.buffer)
            self.not_empty.notify()

    def consume(self):
        with self.not_empty:
            item = self.buffer[self.out_index]
            self.out_index = (self.out_index + 1) % len(self.buffer)
            return item

producer_consumer = ProducerConsumer(5)

def producer():
    for i in range(10):
        producer_consumer.produce(i)
        print(f"Produced: {i}")

def consumer():
    for _ in range(10):
        item = producer_consumer.consume()
        print(f"Consumed: {item}")

t1 = threading.Thread(target=producer)
t2 = threading.Thread(target=consumer)
t1.start()
t2.start()
t1.join()
t2.join()
```

#### 29. 网络编程

**题目：** 实现一个简单的 HTTP 服务器。

**解析：** 使用 socket 编写 HTTP 服务器。

**答案：**

```python
import socket

def handle_request(client_socket):
    request = client_socket.recv(1024).decode()
    print(f"Request: {request}")
    response = "HTTP/1.1 200 OK\nContent-Type: text/html\n\nHello, World!"
    client_socket.send(response.encode())
    client_socket.close()

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('0.0.0.0', 8080))
server_socket.listen(5)

print("Server started on port 8080...")
while True:
    client_socket, client_address = server_socket.accept()
    print(f"Connected by {client_address}")
    client_thread = threading.Thread(target=handle_request, args=(client_socket,))
    client_thread.start()
```

#### 30. 网络爬虫

**题目：** 使用 Python 实现一个简单的网络爬虫。

**解析：** 使用 requests 和 BeautifulSoup 库实现。

**答案：**

```python
import requests
from bs4 import BeautifulSoup

def crawl(url):
    response = requests.get(url)
    if response.status_code == 200:
        print(f"URL: {url}")
        print(f"Content: {response.text}")
        soup = BeautifulSoup(response.text, 'html.parser')
        for link in soup.find_all('a'):
            href = link.get('href')
            if href and not href.startswith('#'):
                crawl(href)

crawl("https://www.example.com")
```

