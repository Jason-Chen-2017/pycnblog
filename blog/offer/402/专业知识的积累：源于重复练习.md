                 

### 标题：专业知识的积累：源于重复练习 — 国内一线大厂面试题及算法编程题集与解析

#### 目录：

1. **基础算法题**
   - [1. 两数之和](#1-两数之和)
   - [2. 爬楼梯](#2-爬楼梯)
   - [3. 合并两个有序链表](#3-合并两个有序链表)

2. **数据结构题**
   - [4. 链表反转](#4-链表反转)
   - [5. 栈与队列](#5-栈与队列)
   - [6. 二叉树遍历](#6-二叉树遍历)

3. **动态规划题**
   - [7. 最长递增子序列](#7-最长递增子序列)
   - [8. 最长公共子序列](#8-最长公共子序列)
   - [9. 最小路径和](#9-最小路径和)

4. **字符串处理题**
   - [10. 字符串匹配算法](#10-字符串匹配算法)
   - [11. 编辑距离](#11-编辑距离)

5. **数学题**
   - [12. 素数筛法](#12-素数筛法)
   - [13. 快速幂算法](#13-快速幂算法)

6. **图算法题**
   - [14. 拓扑排序](#14-拓扑排序)
   - [15. 最短路径算法](#15-最短路径算法)

7. **其他高频题**
   - [16. 翻转整数](#16-翻转整数)
   - [17. 逆波兰表达式求值](#17-逆波兰表达式求值)
   - [18. 岛屿数量](#18-岛屿数量)

#### 正文：

##### 1. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```text
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9
```

**解析：**

```go
func twoSum(nums []int, target int) []int {
    var indices []int
    for i, num1 := range nums {
        for j, num2 := range nums {
            if i != j && num1 + num2 == target {
                indices = append(indices, i, j)
                return indices
            }
        }
    }
    return indices
}
```

##### 2. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**

```text
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**解析：**

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

##### 3. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```text
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**解析：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

##### 4. 链表反转

**题目：** 反转一个单链表。

**示例：**

```text
输入：1->2->3->4->5->NULL
输出：5->4->3->2->1->NULL
```

**解析：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    for head != nil {
        nextTemp := head.Next
        head.Next = prev
        prev = head
        head = nextTemp
    }
    return prev
}
```

##### 5. 栈与队列

**题目：** 用栈实现队列，用队列实现栈。

**解析：**

```go
// 用栈实现队列
type MyQueue struct {
    stack1 []int
    stack2 []int
}

func Constructor() MyQueue {
    return MyQueue{
        stack1: []int{},
        stack2: []int{},
    }
}

func (this *MyQueue) Push(x int) {
    this.stack1 = append(this.stack1, x)
}

func (this *MyQueue) Pop() int {
    if len(this.stack2) == 0 {
        for len(this.stack1) > 0 {
            this.stack2 = append(this.stack2, this.stack1[len(this.stack1)-1])
            this.stack1 = this.stack1[:len(this.stack1)-1]
        }
    }
    top := this.stack2[len(this.stack2)-1]
    this.stack2 = this.stack2[:len(this.stack2)-1]
    return top
}

func (this *MyQueue) Peek() int {
    if len(this.stack2) == 0 {
        for len(this.stack1) > 0 {
            this.stack2 = append(this.stack2, this.stack1[len(this.stack1)-1])
            this.stack1 = this.stack1[:len(this.stack1)-1]
        }
    }
    return this.stack2[len(this.stack2)-1]
}

func (this *MyQueue) Empty() bool {
    return len(this.stack1) == 0 && len(this.stack2) == 0
}

// 用队列实现栈
type MyStack struct {
    queue []int
    queue1 []int
}

func Constructor() MyStack {
    return MyStack{
        queue: []int{},
        queue1: []int{},
    }
}

func (this *MyStack) Push(x int) {
    this.queue = append(this.queue, x)
}

func (this *MyStack) Pop() int {
    for len(this.queue) > 1 {
        this.queue1 = append(this.queue1, this.queue[0])
        this.queue = this.queue[1:]
    }
    top := this.queue[0]
    this.queue = this.queue[1:]
    this.queue, this.queue1 = this.queue1, this.queue
    return top
}

func (this *MyStack) Top() int {
    for len(this.queue) > 1 {
        this.queue1 = append(this.queue1, this.queue[0])
        this.queue = this.queue[1:]
    }
    top := this.queue[0]
    this.queue = this.queue[1:]
    this.queue, this.queue1 = this.queue1, this.queue
    return top
}

func (this *MyStack) Empty() bool {
    return len(this.queue) == 0
}
```

##### 6. 二叉树遍历

**题目：** 实现二叉树的先序遍历、中序遍历和后序遍历。

**示例：**

```text
输入：[3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
输出：
先序遍历：[3,9,20,15,7]
中序遍历：[9,3,15,20,7]
后序遍历：[9,15,7,20,3]
```

**解析：**

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func preOrderTraversal(root *TreeNode) []int {
    var ans []int
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        ans = append(ans, node.Val)
        dfs(node.Left)
        dfs(node.Right)
    }
    dfs(root)
    return ans
}

func inOrderTraversal(root *TreeNode) []int {
    var ans []int
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        ans = append(ans, node.Val)
        dfs(node.Right)
    }
    dfs(root)
    return ans
}

func postOrderTraversal(root *TreeNode) []int {
    var ans []int
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        dfs(node.Right)
        ans = append(ans, node.Val)
    }
    dfs(root)
    return ans
}
```

##### 7. 最长递增子序列

**题目：** 给定一个无序数组，找出其中最长递增子序列的长度。

**示例：**

```text
输入：[10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。
```

**解析：**

```go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return maxElement(dp)
}

func maxElement(nums []int) int {
    max := nums[0]
    for _, num := range nums {
        if num > max {
            max = num
        }
    }
    return max
}
```

##### 8. 最长公共子序列

**题目：** 给定两个字符串，找出其中最长公共子序列的长度。

**示例：**

```text
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，所以长度为 3。
```

**解析：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

##### 9. 最小路径和

**题目：** 给定一个包含非负整数的 `mx` x `n` 网格，找出路径的最低成本和。

**示例：**

```text
输入：
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**解析：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

##### 10. 字符串匹配算法

**题目：** 给定一个 `text` 字符串和一个 `pattern` 字符串，实现一个算法实现字符串的匹配。

**示例：**

```text
输入：text = "abcabcabcabcabcabcabcabcabcabcabc"，pattern = "abc"
输出：7
解释：匹配到的位置有 0, 6, 12, 18, 24, 30, 36，共 7 个位置。
```

**解析：**

```go
func findTheAnchors(text string, pattern string) (int, int) {
    l1, l2 := len(text), len(pattern)
    dp := make([][]int, l1+1)
    for i := range dp {
        dp[i] = make([]int, l2+1)
    }
    for i := 1; i <= l1; i++ {
        for j := 1; j <= l2; j++ {
            if i >= j {
                dp[i][j] = dp[i-j][j]
            }
            if i >= j && text[i-1] == pattern[j-1] {
                dp[i][j] += 1
            }
            if dp[i][j] == l2 {
                return i-l2+1, i
            }
        }
    }
    return -1, -1
}
```

##### 11. 编辑距离

**题目：** 给定两个字符串，找出将一个字符串转换为另一个字符串所需要的最少编辑操作次数。编辑操作包括：插入、删除、替换。

**示例：**

```text
输入：word1 = "horse"，word2 = "ros"
输出：3
解释：可以通过以下步骤将 "horse" 更改为 "ros"：
horse -> rose (删除 'h')
rose -> ro (删除 'e')
ro -> ros (插入 's')
```

**解析：**

```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 0; i <= m; i++ {
        for j := 0; j <= n; j++ {
            if i == 0 {
                dp[i][j] = j
            } else if j == 0 {
                dp[i][j] = i
            } else if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
            }
        }
    }
    return dp[m][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

##### 12. 素数筛法

**题目：** 使用素数筛法找出小于 `n` 的所有素数。

**示例：**

```text
输入：n = 10
输出：[2, 3, 5, 7]
```

**解析：**

```go
func sieveOfEratosthenes(n int) []int {
    primes := []int{}
    isPrime := make([]bool, n+1)
    for i := 2; i <= n; i++ {
        isPrime[i] = true
    }
    for i := 2; i*i <= n; i++ {
        if isPrime[i] {
            for j := i * i; j <= n; j += i {
                isPrime[j] = false
            }
        }
    }
    for i := 2; i <= n; i++ {
        if isPrime[i] {
            primes = append(primes, i)
        }
    }
    return primes
}
```

##### 13. 快速幂算法

**题目：** 使用快速幂算法计算 `a` 的 `n` 次方。

**示例：**

```text
输入：a = 2，n = 10
输出：1024
```

**解析：**

```go
func quickPower(a int, n int) int {
    res := 1
    for n > 0 {
        if n&1 != 0 {
            res *= a
        }
        n >>= 1
        a *= a
    }
    return res
}
```

##### 14. 拓扑排序

**题目：** 使用拓扑排序对有向无环图（DAG）进行排序。

**示例：**

```text
输入：[2,1,3]，[3,2,4]，[4,3,5]，[1,4,6]，[1,6,5]
输出：[1,2,3,4,5,6]
```

**解析：**

```go
func topologicalSort(edges [][]int, n int) []int {
    indeg := make([]int, n)
    for _, edge := range edges {
        for _, v := range edge[1:] {
            indeg[v]++
        }
    }
    q := make([]int, 0, n)
    for i, v := range indeg {
        if v == 0 {
            q = append(q, i)
        }
    }
    res := []int{}
    for len(q) > 0 {
        v := q[0]
        q = q[1:]
        res = append(res, v)
        for _, w := range edges[v] {
            indeg[w]--
            if indeg[w] == 0 {
                q = append(q, w)
            }
        }
    }
    return res
}
```

##### 15. 最短路径算法

**题目：** 使用 Dijkstra 算法计算图中两点之间的最短路径。

**示例：**

```text
输入：graph = [[2,1,4],[1,2,5],[2,3,8],[1,3,7]], start = 0, target = 3
输出：4
解释：最短路径为 0→1→3→2，总权值为 4。
```

**解析：**

```go
type Node struct {
    Val    int
    Weight int
}

func dijkstra(graph [][]Node, start int, target int) int {
    n := len(graph)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0
    vis := make([]bool, n)
    for i := 0; i < n; i++ {
        u := -1
        for j := 0; j < n; j++ {
            if !vis[j] && (u == -1 || dist[j] < dist[u]) {
                u = j
            }
        }
        vis[u] = true
        for _, v := range graph[u].Val {
            dist[v] = min(dist[v], dist[u]+graph[u].Weight[v])
        }
    }
    return dist[target]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

##### 16. 翻转整数

**题目：** 实现一个函数，用来翻转一个整数的数字。

**示例：**

```text
输入：123
输出：321
输入：120
输出：21
```

**解析：**

```go
func reverse(x int) int {
    var res int
    for x > 0 {
        res = res*10 + x%10
        x /= 10
    }
    if res > math.MaxInt32 || res < math.MinInt32 {
        return 0
    }
    return res
}
```

##### 17. 逆波兰表达式求值

**题目：** 实现一个逆波兰表达式求值器。

**示例：**

```text
输入："2 1 + 3 * -@"
输出：-2
解释：先计算 "2 * 3"，得到 6，然后计算 "1 + 6"，得到 7，最后计算 "-1"，得到 "-2"。
```

**解析：**

```go
func evalRPN(tokens []string) int {
    var stack []int
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if b == 0 {
                return 0
            }
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    res := 0
    for _, c := range token {
        res = res*10 + int(c-'0')
    }
    return res * sign
}
```

##### 18. 岛屿数量

**题目：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算网格中岛屿的数量。

**示例：**

```text
输入：
11110
10000
11000
00000

输出：1
```

**解析：**

```go
func numIslands(grid [][]byte) int {
    var dfs func(x, y int)
    dfs = func(x, y int) {
        if x < 0 || x >= len(grid) || y < 0 || y >= len(grid[0]) || grid[x][y] != '1' {
            return
        }
        grid[x][y] = '0'
        dfs(x+1, y)
        dfs(x-1, y)
        dfs(x, y+1)
        dfs(x, y-1)
    }
    ans := 0
    for i := range grid {
        for j := range grid[0] {
            if grid[i][j] == '1' {
                dfs(i, j)
                ans++
            }
        }
    }
    return ans
}
```

