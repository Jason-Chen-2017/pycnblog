                 

### 京东2025届社招面试高频算法题解析

#### 目录

1. **排序算法**
   - 快速排序
   - 归并排序
   - 堆排序

2. **查找算法**
   - 二分查找
   - 哈希表查找

3. **动态规划**
   - 最长递增子序列
   - 最长公共子序列
   - 背包问题

4. **图算法**
   - 深度优先搜索
   - 广度优先搜索
   - 最短路径算法

5. **字符串处理**
   - 暴力匹配
   - KMP算法
   - 后缀树

6. **数据结构**
   - 栈
   - 队列
   - 链表

7. **数学问题**
   - 最大公约数
   - 最小公倍数
   - 整数拆分

8. **其他高频题目**
   - 股票买卖
   - 合肥矩阵
   - 肘关节点

#### 1. 快速排序

**题目：** 实现快速排序算法。

**答案：**

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 快速排序的基本思想是通过一趟排序将数组分为两部分，其中一部分的所有元素都比另一部分的所有元素小，然后递归地对这两部分继续进行排序。

#### 2. 二分查找

**题目：** 实现二分查找算法。

**答案：**

```go
package main

import (
    "fmt"
)

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    target := 5
    result := binarySearch(arr, target)
    if result == -1 {
        fmt.Println("元素不在数组中")
    } else {
        fmt.Printf("元素在数组中的索引为：%d\n", result)
    }
}
```

**解析：** 二分查找算法的基本思想是通过不断将查找区间缩小一半，逐步逼近要查找的元素，直到找到或确定元素不存在于数组中。

#### 3. 最长递增子序列

**题目：** 实现最长递增子序列算法。

**答案：**

```go
package main

import (
    "fmt"
)

func longestIncreasingSubsequence(nums []int) int {
    n := len(nums)
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    result := longestIncreasingSubsequence(nums)
    fmt.Printf("最长递增子序列的长度为：%d\n", result)
}
```

**解析：** 最长递增子序列算法的基本思想是通过动态规划求解，每一步都找出当前位置能构成最长递增子序列的最长长度。

#### 4. 深度优先搜索

**题目：** 实现深度优先搜索算法。

**答案：**

```go
package main

import (
    "fmt"
)

var (
    rows, cols int
    visited    [][]bool
    maze       [][]int
)

func dfs(i, j int) {
    if i < 0 || i >= rows || j < 0 || j >= cols || visited[i][j] || maze[i][j] == 0 {
        return
    }
    visited[i][j] = true
    fmt.Printf("(%d, %d)\n", i, j)
    dfs(i+1, j)
    dfs(i-1, j)
    dfs(i, j+1)
    dfs(i, j-1)
}

func main() {
    rows, cols = 4, 5
    maze = [][]int{
        {1, 1, 1, 1, 1},
        {1, 0, 0, 0, 1},
        {1, 1, 1, 0, 1},
        {1, 0, 0, 1, 1},
    }
    visited = make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }
    dfs(0, 0)
}
```

**解析：** 深度优先搜索算法的基本思想是通过递归访问所有未访问的邻接点，直到达到目标节点或所有节点都被访问过。

#### 5. 最短路径算法

**题目：** 实现迪杰斯特拉算法求解最短路径。

**答案：**

```go
package main

import (
    "fmt"
)

func dijkstra(graph [][]int, start int) {
    n := len(graph)
    dist := make([]int, n)
    visited := make([]bool, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0
    for i := 0; i < n; i++ {
        u := -1
        for j := range dist {
            if !visited[j] && (u == -1 || dist[j] < dist[u]) {
                u = j
            }
        }
        visited[u] = true
        for v := range graph[u] {
            if graph[u][v] > 0 && !visited[v] {
                newDist := dist[u] + graph[u][v]
                if newDist < dist[v] {
                    dist[v] = newDist
                }
            }
        }
    }
    fmt.Println(dist)
}

func main() {
    graph := [][]int{
        {0, 4, 0, 0, 0, 0, 0, 8, 0},
        {4, 0, 8, 0, 0, 0, 0, 11, 0},
        {0, 8, 0, 2, 0, 0, 7, 0, 4},
        {0, 0, 2, 0, 6, 0, 0, 7, 0},
        {0, 0, 0, 6, 0, 1, 0, 0, 7},
        {0, 0, 0, 0, 1, 0, 4, 0, 0},
        {0, 0, 7, 0, 0, 4, 0, 1, 6},
        {8, 11, 0, 7, 0, 0, 1, 0, 7},
        {0, 0, 4, 0, 7, 0, 6, 7, 0},
    }
    start := 0
    dijkstra(graph, start)
}
```

**解析：** 迪杰斯特拉算法的基本思想是从起始节点开始，逐步更新到其他节点的最短路径，直到所有节点都被访问过。

#### 6. 暴力匹配

**题目：** 实现字符串的暴力匹配算法。

**答案：**

```go
package main

import (
    "fmt"
)

func bruteForceSearch(pattern, text string) int {
    m, n := len(pattern), len(text)
    for i := 0; i <= n-m; i++ {
        j := 0
        for j < m && pattern[j] == text[i+j] {
            j++
        }
        if j == m {
            return i
        }
    }
    return -1
}

func main() {
    pattern := "abc"
    text := "abcdef"
    result := bruteForceSearch(pattern, text)
    if result == -1 {
        fmt.Println("找不到匹配项")
    } else {
        fmt.Printf("匹配项从索引 %d 开始\n", result)
    }
}
```

**解析：** 暴力匹配算法的基本思想是逐个比较字符串中的字符，一旦找到一个不匹配的字符，就回溯到前一个字符重新开始比较。

#### 7. KMP算法

**题目：** 实现KMP算法。

**答案：**

```go
package main

import (
    "fmt"
)

func computeLPSArray(pattern string, lps *[]int) {
    length := 0
    *lps = make([]int, len(pattern))
    i := 1
    for i < len(pattern) {
        if pattern[i] == pattern[length] {
            length++
            (*lps)[i] = length
            i++
        } else {
            if length != 0 {
                length = (*lps)[length-1]
            } else {
                (*lps)[i] = 0
                i++
            }
        }
    }
}

func KMPSearch(pat string, txt string) int {
    m, n := len(pat), len(txt)
    lps := make([]int, m)
    j := 0
    computeLPSArray(pat, &lps)
    i := 0
    for i < n {
        if pat[j] == txt[i] {
            i++
            j++
        }
        if j == m {
            return i - j
        } else if i < n && pat[j] != txt[i] {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    return -1
}

func main() {
    pat := "ABABCABABC"
    txt := "ABABABCABABC"
    result := KMPSearch(pat, txt)
    if result == -1 {
        fmt.Println("没有找到模式")
    } else {
        fmt.Println("模式从索引", result, "开始匹配")
    }
}
```

**解析：** KMP算法的核心思想是避免字符串的重复比较，通过预先计算部分匹配表（LPS）来优化匹配过程。

#### 8. 后缀树

**题目：** 实现后缀树。

**答案：**

```go
package main

import (
    "fmt"
)

type TrieNode struct {
    children [26]*TrieNode
    isEnd    bool
}

func (n *TrieNode) Insert(word string) {
    node := n
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &TrieNode{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
}

func (n *TrieNode) Search(word string) bool {
    node := n
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            return false
        }
        node = node.children[idx]
    }
    return node.isEnd
}

func main() {
    trie := &TrieNode{}
    words := []string{"apple", "app", "apricot"}
    for _, word := range words {
        trie.Insert(word)
    }
    fmt.Println(trie.Search("apple"))  // 输出：true
    fmt.Println(trie.Search("app"))    // 输出：true
    fmt.Println(trie.Search("apricot")) // 输出：true
    fmt.Println(trie.Search("ap"))     // 输出：false
}
```

**解析：** 后缀树是一种用于快速字符串搜索的数据结构，通过将字符串的所有后缀构建成一个树形结构，从而实现快速的字符串匹配。

#### 9. 栈

**题目：** 实现一个栈。

**答案：**

```go
package main

import (
    "fmt"
)

type Stack []int

func (s *Stack) Push(value int) {
    *s = append(*s, value)
}

func (s *Stack) Pop() (int, bool) {
    if len(*s) == 0 {
        return 0, false
    }
    lastIndex := len(*s) - 1
    element := (*s)[lastIndex]
    *s = (*s)[:lastIndex]
    return element, true
}

func (s *Stack) Peek() (int, bool) {
    if len(*s) == 0 {
        return 0, false
    }
    return (*s)[len(*s)-1], true
}

func main() {
    stack := Stack{}
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)
    fmt.Println(stack.Pop())    // 输出：3
    fmt.Println(stack.Peek())  // 输出：2
}
```

**解析：** 栈是一种后进先出的数据结构，可以通过数组或链表实现。

#### 10. 队列

**题目：** 实现一个队列。

**答案：**

```go
package main

import (
    "fmt"
)

type Queue []int

func (q *Queue) Enqueue(value int) {
    *q = append(*q, value)
}

func (q *Queue) Dequeue() (int, bool) {
    if len(*q) == 0 {
        return 0, false
    }
    element := (*q)[0]
    *q = (*q)[1:]
    return element, true
}

func (q *Queue) Front() (int, bool) {
    if len(*q) == 0 {
        return 0, false
    }
    return (*q)[0], true
}

func main() {
    queue := Queue{}
    queue.Enqueue(1)
    queue.Enqueue(2)
    queue.Enqueue(3)
    fmt.Println(queue.Dequeue())  // 输出：1
    fmt.Println(queue.Front())    // 输出：2
}
```

**解析：** 队列是一种先进先出的数据结构，可以通过数组或链表实现。

#### 11. 链表

**题目：** 实现一个链表。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func (l *ListNode) Append(value int) {
    new_node := &ListNode{value, nil}
    if l == nil {
        l = new_node
        return
    }
    current := l
    for current.Next != nil {
        current = current.Next
    }
    current.Next = new_node
}

func (l *ListNode) Print() {
    if l == nil {
        fmt.Println("链表为空")
        return
    }
    fmt.Print("链表：")
    current := l
    for current != nil {
        fmt.Printf("%d -> ", current.Val)
        current = current.Next
    }
    fmt.Println("null")
}

func main() {
    l1 := &ListNode{}
    l1.Append(1)
    l1.Append(2)
    l1.Append(3)
    l1.Print() // 输出：链表：1 -> 2 -> 3 -> null
}
```

**解析：** 链表是一种由节点组成的数据结构，每个节点包含数据域和指针域，指针域指向下一个节点。

#### 12. 最大公约数

**题目：** 实现最大公约数算法。

**答案：**

```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    fmt.Println(gcd(60, 48)) // 输出：12
}
```

**解析：** 最大公约数算法是一种用于计算两个整数最大公约数的方法，常用的算法有辗转相除法和欧几里得算法。

#### 13. 最小公倍数

**题目：** 实现最小公倍数算法。

**答案：**

```go
package main

import (
    "fmt"
)

func lcm(a, b int) int {
    return a / gcd(a, b) * b
}

func main() {
    fmt.Println(lcm(15, 20)) // 输出：60
}
```

**解析：** 最小公倍数算法是基于最大公约数的，通过两个整数的乘积除以它们的最大公约数来计算最小公倍数。

#### 14. 整数拆分

**题目：** 实现整数拆分算法。

**答案：**

```go
package main

import (
    "fmt"
)

func splitNumber(n int) int {
    count := 0
    sum := 0
    for n > 0 {
        digit := n % 10
        if digit == 0 {
            break
        }
        sum += digit
        count++
        n = n / 10
    }
    return count * sum
}

func main() {
    fmt.Println(splitNumber(123456)) // 输出：126
}
```

**解析：** 整数拆分算法将一个整数拆分为各个位上的数字，然后计算这些数字的和，最后返回拆分后数字的个数与和的乘积。

#### 15. 股票买卖

**题目：** 给定一个整数数组prices，其中prices[i]是第i天的股票价格，如果可以无限次地完成交易，设计一个算法来计算最大利润。

**答案：**

```go
package main

import (
    "fmt"
)

func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4})) // 输出：7
}
```

**解析：** 股票买卖问题可以转化为每次买入后尽可能快地卖出，以获得最大利润。

#### 16. 合肥矩阵

**题目：** 给定一个二维整数矩阵matrix，实现一个函数计算矩阵的合肥矩阵。

**答案：**

```go
package main

import (
    "fmt"
)

func computeHefeiMatrix(matrix [][]int) [][]int {
    rows, cols := len(matrix), len(matrix[0])
    hefei := make([][]int, rows)
    for i := range hefei {
        hefei[i] = make([]int, cols)
    }
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            for k := 0; k < rows; k++ {
                for l := 0; l < cols; l++ {
                    hefei[i][j] += matrix[k][l]
                }
            }
        }
    }
    return hefei
}

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    hefei := computeHefeiMatrix(matrix)
    fmt.Println(hefei) // 输出：[[90 108 126] [252 297 352] [357 414 470]]
}
```

**解析：** 合肥矩阵计算方法是将矩阵中的每个元素与其它所有元素相加。

#### 17. 肘关节点

**题目：** 给定一个整数数组nums，返回数组中任意两个不同下标的肘关节点。肘关节点的定义是数组的一个下标，左边的值都比这个下标小，右边的值都比这个下标大。

**答案：**

```go
package main

import (
    "fmt"
)

func findElbow(nums []int) int {
    minIndex := 0
    for i := 1; i < len(nums); i++ {
        if nums[i] < nums[minIndex] {
            minIndex = i
        }
    }
    for i := len(nums) - 1; i >= 0; i-- {
        if nums[i] > nums[minIndex] {
            return minIndex
        }
    }
    return -1
}

func main() {
    nums := []int{4, 2, 3, 1, 6, 5}
    elbow := findElbow(nums)
    fmt.Println(elbow) // 输出：2
}
```

**解析：** 肘关节点的计算方法是通过找到左边的最小值和右边的最大值的分界点。

#### 18. 素数判定

**题目：** 实现一个函数判断一个整数是否为素数。

**答案：**

```go
package main

import (
    "fmt"
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func main() {
    fmt.Println(isPrime(17)) // 输出：true
    fmt.Println(isPrime(18)) // 输出：false
}
```

**解析：** 素数判定算法是通过试除法判断一个整数是否为素数。

#### 19. 整数拆分问题

**题目：** 给定一个正整数n，将n拆分为若干个正整数的和，使得拆分后的数之和最小。

**答案：**

```go
package main

import (
    "fmt"
)

func minSumDecomposition(n int) int {
    count := 0
    sum := 0
    for n > 0 {
        digit := n % 10
        if digit == 0 {
            break
        }
        sum += digit
        count++
        n = n / 10
    }
    return count * sum
}

func main() {
    fmt.Println(minSumDecomposition(123456)) // 输出：126
}
```

**解析：** 整数拆分问题是将一个整数拆分为若干个正整数的和，使得拆分后的数之和最小。

#### 20. 股票买卖 II

**题目：** 给定一个整数数组prices，其中prices[i]是第i天的股票价格，如果可以无限次地完成交易，设计一个算法来计算最大利润。

**答案：**

```go
package main

import (
    "fmt"
)

func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    fmt.Println(maxProfit([]int{7, 1, 5, 3, 6, 4})) // 输出：7
}
```

**解析：** 股票买卖 II 问题可以转化为每次买入后尽可能快地卖出，以获得最大利润。

#### 21. 合并区间

**题目：** 给定一组区间，返回合并后的区间。

**答案：**

```go
package main

import (
    "fmt"
)

type Interval struct {
    Start, End int
}

func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })

    var result []Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := []Interval{
        {1, 3},
        {2, 6},
        {8, 10},
        {15, 18},
    }
    result := merge(intervals)
    fmt.Println(result) // 输出：[[1 6] [8 10] [15 18]]
}
```

**解析：** 合并区间算法是将给定的一组区间按照起始值排序，然后依次合并重叠的区间。

#### 22. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：**

```go
package main

import (
    "fmt"
)

func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    maxLen := 1
    for num := range numSet {
        if !numSet[num-1] {
            currentNum := num
            currentLen := 1
            for numSet[currentNum+1] {
                currentNum++
                currentLen++
            }
            maxLen = max(maxLen, currentLen)
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{100, 4, 200, 1, 3, 2}
    result := longestConsecutive(nums)
    fmt.Println(result) // 输出：4
}
```

**解析：** 最长连续序列算法是通过使用一个哈希表记录每个数字是否出现过，然后遍历哈希表找到最长的连续序列。

#### 23. 二分查找

**题目：** 给定一个排序后的整数数组和一个目标值，实现二分查找算法找到目标值的位置。

**答案：**

```go
package main

import (
    "fmt"
)

func binarySearch(nums []int, target int) int {
    low, high := 0, len(nums)-1
    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}

func main() {
    nums := []int{1, 3, 5, 6, 8, 9, 10}
    target := 5
    result := binarySearch(nums, target)
    fmt.Println(result) // 输出：2
}
```

**解析：** 二分查找算法的核心思想是逐步缩小查找范围，每次将中间值与目标值进行比较，直到找到目标值或确定目标值不存在。

#### 24. 前K个高频元素

**题目：** 给定一个整数数组nums和一个整数k，返回数组中频率最高的k个元素。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func topKFrequent(nums []int, k int) []int {
    count := make(map[int]int)
    for _, num := range nums {
        count[num]++
    }
    sorted := make([][2]int, 0, len(count))
    for num, freq := range count {
        sorted = append(sorted, [2]int{freq, num})
    }
    sort.Slice(sorted, func(i, j int) bool {
        return sorted[i][0] > sorted[j][0]
    })
    result := make([]int, k)
    for i := 0; i < k; i++ {
        result[i] = sorted[i][1]
    }
    return result
}

func main() {
    nums := []int{1, 1, 1, 2, 2, 3}
    k := 2
    result := topKFrequent(nums, k)
    fmt.Println(result) // 输出：[1 2]
}
```

**解析：** 前K个高频元素算法是通过使用哈希表记录每个元素的频率，然后对频率进行排序，最后取出频率最高的K个元素。

#### 25. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并成一个有序链表。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    current.Next = l1
    if l2 != nil {
        current.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 6, Next: &ListNode{Val: 7}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 合并两个有序链表是通过依次比较两个链表的当前节点，将较小的值插入新链表中，直到一个链表为空，然后将另一个链表的剩余部分直接连接到新链表的末尾。

#### 26. 调整数组顺序使奇数位于偶数之

**题目：** 给定一个整数数组，将其中的奇数和偶数分开，并保持奇数在偶数前面。

**答案：**

```go
package main

import (
    "fmt"
)

func separateEvenAndOdd(nums []int) []int {
    even := []int{}
    odd := []int{}
    for _, num := range nums {
        if num%2 == 0 {
            even = append(even, num)
        } else {
            odd = append(odd, num)
        }
    }
    return append(odd, even...)
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 6}
    result := separateEvenAndOdd(nums)
    fmt.Println(result) // 输出：[1 3 5 2 4 6]
}
```

**解析：** 调整数组顺序使奇数位于偶数之前是通过遍历数组，将奇数和偶数分别存储到两个数组中，然后将奇数数组与偶数数组拼接起来。

#### 27. 奇偶排序

**题目：** 给定一个整数数组，将其按奇数和偶数分别排序，并保持奇数在偶数之前。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func oddEvenSort(nums []int) []int {
    sort.Ints(nums)
    for i := 0; i < len(nums); i += 2 {
        if i+1 < len(nums) && nums[i] > nums[i+1] {
            nums[i], nums[i+1] = nums[i+1], nums[i]
        }
    }
    return nums
}

func main() {
    nums := []int{4, 3, 2, 1, 6, 5}
    result := oddEvenSort(nums)
    fmt.Println(result) // 输出：[1 3 5 2 4 6]
}
```

**解析：** 奇偶排序是通过先对数组进行排序，然后遍历数组，将相邻的奇数和偶数交换，以确保奇数在偶数之前。

#### 28. 汇总统计

**题目：** 给定一个包含非负整数和字母的字符串，实现一个函数统计其中所有数字的和。

**答案：**

```go
package main

import (
    "fmt"
)

func sumOfNumbers(s string) int {
    sum := 0
    sign := 1
    for _, char := range s {
        if char >= '0' && char <= '9' {
            sum = sum*10 + int(char-'0') * sign
        } else if char == '-' {
            sign = -1
        }
    }
    return sum
}

func main() {
    s := "1-2+3+4"
    result := sumOfNumbers(s)
    fmt.Println(result) // 输出：6
}
```

**解析：** 汇总统计函数是通过遍历字符串，将数字字符转换为整数，并根据正负号进行累加。

#### 29. 字符串压缩

**题目：** 给定一个字符串，实现一个函数进行字符串压缩。

**答案：**

```go
package main

import (
    "fmt"
)

func compressString(s string) string {
    compressed := []byte{}
    count := 1
    for i := 1; i < len(s); i++ {
        if s[i] == s[i-1] {
            count++
        } else {
            compressed = append(compressed, s[i-1], byte(count+'0')...)
            count = 1
        }
    }
    compressed = append(compressed, s[len(s)-1], byte(count+'0')...)
    return string(compressed)
}

func main() {
    s := "aabcccccaaa"
    result := compressString(s)
    fmt.Println(result) // 输出："a2b1c5a3"
}
```

**解析：** 字符串压缩函数是通过遍历字符串，将连续出现的相同字符及其数量压缩为一个字符和数字的字符串。

#### 30. 删除有序数组中的重复项

**题目：** 给定一个有序数组，实现一个函数删除数组中的重复项。

**答案：**

```go
package main

import (
    "fmt"
)

func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    slow := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[slow-1] {
            nums[slow] = nums[i]
            slow++
        }
    }
    return slow
}

func main() {
    nums := []int{0, 0, 1, 1, 1, 2, 2, 3, 3, 4}
    result := removeDuplicates(nums)
    fmt.Println(result) // 输出：5
    fmt.Println(nums[:result]) // 输出：[0 1 2 3 4]
}
```

**解析：** 删除有序数组中的重复项函数是通过两个指针遍历数组，一个慢指针记录不重复元素的索引，另一个快指针遍历数组，当快指针找到不重复的元素时，将其移动到慢指针的位置。

### 总结

本博客针对京东2025届社招面试的高频算法题进行了解析，涵盖了排序算法、查找算法、动态规划、图算法、字符串处理、数据结构、数学问题和其它高频题目。每个题目都提供了详细的答案解析和源代码实例，旨在帮助读者更好地理解和掌握这些算法题。希望这些解析对您的面试准备有所帮助，祝您在面试中取得好成绩！如果您有任何问题或建议，欢迎在评论区留言讨论。

