                 

### 2024拼多多多多买菜校招面试真题汇总及其解答

#### 一、编程题

**1. 求最长公共子序列**

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找出它们的 **最长公共子序列**。

**输入：**
```
s1 = "ABCD"
s2 = "ACDF"
```

**输出：**
```
"ACD"
```

**解答：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            result.append(s1[i - 1])
            i, j = i - 1, j - 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))
```

**2. 求最长公共子串**

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找出它们的 **最长公共子串**。

**输入：**
```
s1 = "ABCD"
s2 = "ACDF"
```

**输出：**
```
"ACD"
```

**解答：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_idx = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_idx = i
            else:
                dp[i][j] = 0

    return s1[end_idx - max_len: end_idx]

s1 = "ABCD"
s2 = "ACDF"
print(longest_common_substring(s1, s2))
```

**3. 合并两个有序链表**

**题目描述：** 给定两个有序链表 `l1` 和 `l2`，合并两个链表并返回一个新的有序链表。

**输入：**
```
l1 = [1, 3, 5]
l2 = [2, 4, 6]
```

**输出：**
```
[1, 2, 3, 4, 5, 6]
```

**解答：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1

    if l1.val < l2.val:
        result = l1
        result.next = merge_sorted_lists(l1.next, l2)
    else:
        result = l2
        result.next = merge_sorted_lists(l1, l2.next)

    return result

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
```

**4. 合并两个有序数组**

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，合并两个数组并返回一个新的有序数组。

**输入：**
```
nums1 = [1, 3, 5]
nums2 = [2, 4, 6]
```

**输出：**
```
[1, 2, 3, 4, 5, 6]
```

**解答：**

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j = m - 1, n - 1
    k = m + n - 1

    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1

    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1

    return nums1

nums1 = [1, 3, 5]
nums2 = [2, 4, 6]
print(merge_sorted_arrays(nums1, 3, nums2, 3))
```

#### 二、算法题

**1. 最小栈**

**题目描述：** 设计一个支持 `push`、`pop`、`top` 操作，并能在常数时间内检索到最小元素的最栈。

**输入：**
```
["MinStack", "push", "push", "push", "getMin", "pop", "top", "getMin"]
[[], [3], [2], [-2], [], [], [], []]
```

**输出：**
```
[null, null, null, null, -2, null, 2, -2]
```

**解答：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val < self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**2. 快乐数**

**题目描述：** 编写一个算法来判断一个数 `n` 是不是 **快乐数**。

**输入：**
```
n = 19
```

**输出：**
```
true
```

**解答：**

```python
def is_happy(n: int) -> bool:
    def get_next(num):
        total = 0
        while num:
            digit = num % 10
            total += digit ** 2
            num //= 10
        return total

    slow_runner, fast_runner = n, get_next(n)
    while fast_runner != 1 and slow_runner != fast_runner:
        slow_runner = get_next(slow_runner)
        fast_runner = get_next(get_next(fast_runner))

    return fast_runner == 1

n = 19
print(is_happy(n))
```

**3. 寻找峰值**

**题目描述：** 在一个整数数组的中，有一个元素比它两边相邻的元素都要大。请你找出这个峰值元素并返回其索引。

**输入：**
```
nums = [1, 2, 3, 1]
```

**输出：**
```
2
```

**解答：**

```python
def find_peak_element(nums):
    low, high = 0, len(nums) - 1

    while low < high:
        mid = (low + high) // 2
        if nums[mid] > nums[mid + 1]:
            high = mid
        else:
            low = mid + 1

    return low

nums = [1, 2, 3, 1]
print(find_peak_element(nums))
```

#### 三、系统设计题

**1. 设计LRU缓存**

**题目描述：** 设计一个LRU缓存系统。

**输入：**
```
["LRUCache", "get", "put"]
[[2], [1], [1, 4]]
```

**输出：**
```
[null, -1, null]
```

**解答：**

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.queue = deque()

    def get(self, key: int) -> int:
        if key in self.cache:
            self.queue.remove(key)
            self.queue.append(key)
            return self.cache[key]
        return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.queue.remove(key)
        elif len(self.cache) >= self.capacity:
            key_to_remove = self.queue.popleft()
            del self.cache[key_to_remove]
        self.cache[key] = value
        self.queue.append(key)
```

#### 四、计算机组成原理题

**1. 什么是缓存一致性？**

**答案：** 缓存一致性指的是保证多个处理器或系统中的缓存之间的数据一致性。当一个处理器修改了内存中的数据时，其他处理器中的缓存也需要相应地更新，以保持数据的一致性。缓存一致性协议（Cache Coherence Protocols）用于实现这一目的。

**2. 什么是内存屏障？**

**答案：** 内存屏障（Memory Barrier）是一组指令，用于控制多个处理器之间的内存访问顺序。它可以确保某些内存操作在特定顺序执行，并防止某些类型的内存操作重叠。内存屏障通常用于同步多核处理器上的内存访问。

#### 五、计算机网络题

**1. TCP 和 UDP 的区别是什么？**

**答案：** TCP（传输控制协议）和 UDP（用户数据报协议）是两种不同的传输层协议。

- **可靠性：** TCP 提供可靠的传输，保证数据不丢失、不重复、顺序正确；而 UDP 提供不可靠的传输，数据可能会丢失、重复或顺序不一致。
- **连接：** TCP 需要建立连接，通过三次握手建立；UDP 无需建立连接。
- **速度：** TCP 由于需要保证可靠性，传输速度相对较慢；UDP 无需保证可靠性，传输速度较快。
- **应用场景：** TCP 通常用于要求高可靠性、传输顺序严格的应用，如文件传输、网页浏览等；UDP 通常用于实时传输、对延迟敏感的应用，如在线游戏、视频会议等。

#### 六、数据库题

**1. 什么是事务？**

**答案：** 事务（Transaction）是数据库中的一个操作序列，这些操作要么全部执行，要么全部不执行。事务具有四个特性（ACID）：

- **原子性（Atomicity）：** 事务中的所有操作在数据库中要么全部被执行，要么全部不执行。
- **一致性（Consistency）：** 事务执行前后的数据库状态保持一致。
- **隔离性（Isolation）：** 事务在执行过程中对其他事务的隔离，确保每个事务看到的数据是一致的。
- **持久性（Durability）：** 一旦事务提交，其对数据库的修改将永久保存。

