                 

### 阿里巴巴2024校招算法编程题详解

#### 1. 二维数组中的查找

**题目描述：** 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**思路：** 从左下角开始，逐个比较元素值，如果小于目标值，向上移动；如果大于目标值，向右移动。

**答案：** 

```python
def find(matrix, target):
    if not matrix or len(matrix[0]) == 0:
        return False
    row, col = len(matrix) - 1, 0
    while row >= 0 and col < len(matrix[0]):
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col += 1
        else:
            row -= 1
    return False
```

#### 2. 剑指 Offer 05. 替换空格

**题目描述：** 请实现一个函数，将一个字符串中的空格替换成 "%20"。输入的是字符串（例如 "We are happy."），以及其长度。输出结果应该是替换空格后的字符串（例如 "We%20are%20happy。")。

**思路：** 统计字符串中空格的数量，然后对字符串进行两次遍历，先将空格替换为 "%20"，再将非空格字符后移。

**答案：**

```python
def replaceSpace(s, length):
    cnt = s.count(' ')
    new_len = length + cnt * 2
    s = list(s)
    i = length - 1
    t = new_len - 1
    while i >= 0:
        if s[i] == ' ':
            s[t] = '0'
            s[t - 1] = '2'
            s[t - 2] = '%'
            t -= 3
        else:
            s[t] = s[i]
            t -= 1
        i -= 1
    return ''.join(s[:t+1])
```

#### 3. 剑指 Offer 06. 从尾到头打印链表

**题目描述：** 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**思路：** 使用栈或递归的方法，逆序存储链表节点的值。

**答案：**

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def reversePrint(head):
    stack = []
    while head:
        stack.append(head.val)
        head = head.next
    return [x for x in reversed(stack)]
```

#### 4. 剑指 Offer 10- I. 斐波那契数列

**题目描述：** 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。

**思路：** 使用递归或迭代的方法计算斐波那契数列。

**答案：**

递归方法：

```python
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)
```

迭代方法：

```python
def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a
```

#### 5. 剑指 Offer 10- II. 饰甲的骑士

**题目描述：** 给定一个正整数阵 matrix，表示一块棋盘。棋盘上有一些棋子，棋子可以是骑士或士兵。士兵用数字 1 表示，骑士用数字 2 表示。一个 knight 竖直或水平方向上跳过最多 k 个士兵仍然可以站立。要求返回一个二维数组，其中第一个数组表示骑士所在的位置（行，列），第二个数组表示骑士可以到达的棋子（行，列）。

**思路：** 使用广度优先搜索（BFS）方法，从骑士的位置开始，逐层搜索可以到达的位置。

**答案：**

```python
def knightDance(knight, soldiers, k):
    rows, cols = len(soldiers), len(soldiers[0])
    vis = [[False] * cols for _ in range(rows)]
    vis[knight[0], knight[1]] = True
    dirs = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]
    ans = []
    q = deque([knight])
    step = 0
    while q and step < k:
        step += 1
        size = len(q)
        for _ in range(size):
            x, y = q.popleft()
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < rows and 0 <= ny < cols and not vis[nx][ny] and soldiers[nx][ny] != 2:
                    ans.append((nx, ny))
                    vis[nx][ny] = True
                    q.append((nx, ny))
    if not ans:
        ans.append((-1, -1))
    return [ans, []]
```

#### 6. 剑指 Offer 11. 旋转数组的最小数字

**题目描述：** 把一个数组最外层的数字顺时针旋转90度，例如，原数组为 `[1,2,3,4,5]`，旋转后为 `[5,1,2,3,4]`。

**思路：** 先将数组分为两个部分，上面部分为逆时针旋转，下面部分为顺时针旋转，然后将上下两部分交换。

**答案：**

```python
def rotateArray(nums):
    n = len(nums)
    mid = n // 2
    nums[:mid], nums[mid:] = nums[::-1], nums[:-mid]
    for i in range(0, n, 2):
        nums[i], nums[i + 1] = nums[i + 1], nums[i]
    return nums
```

#### 7. 剑指 Offer 12. 空间替换

**题目描述：** 给定一个整数数组，实现一个函数来替换数组中的每个元素，使其等于对应的下标（下标从 0 开始计数）。例如，如果数组是 `[1, 7, 9, 2, 10]`，替换后的数组应该是 `[0, 5, 8, 3, 4]`。

**思路：** 遍历数组，将每个元素替换为下标。

**答案：**

```python
def replaceNumbers(nums):
    for i in range(len(nums)):
        nums[i] = i
    return nums
```

#### 8. 剑指 Offer 13. 剪绳子

**题目描述：** 给定一个正整数 n，把 n 分成几个最小的因子（至少包含两个因子），使得乘积最大。

**思路：** 使用贪心算法，尽可能地使用 3 和 2 来分割数。

**答案：**

```python
def maxProductAfterCutting(n):
    if n < 2:
        return 0
    if n % 3 == 0:
        return n // 3 * 2
    if n % 3 == 1:
        return n // 3 * 2
    return n // 3 * 3
```

#### 9. 剑指 Offer 14. 剪绳子 II

**题目描述：** 给定一个正整数 n，将 n 分成若干个最小的因子（至少包含两个因子），使得乘积最大。返回最大的乘积。

**思路：** 使用动态规划，定义 f(n) 表示将 n 分割后的最大乘积，状态转移方程为：

```python
f(n) = max(f(n-1) * 1, f(n-2) * 2, f(n-3) * 3, ..., n * f(n-k))
```

**答案：**

```python
def cuttingRobot(n):
    if n < 2:
        return 0
    mod = 10**9 + 7
    f = [0] * (n + 1)
    f[1], f[2], f[3] = 1, 2, 3
    for i in range(4, n + 1):
        f[i] = (f[i - 1] * 1 + f[i - 2] * 2 + f[i - 3] * 3) % mod
    return f[n]
```

#### 10. 剑指 Offer 15. 二进制中 1 的个数

**题目描述：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**思路：** 使用位操作，通过循环判断二进制数中 1 的个数。

**答案：**

```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

#### 11. 剑指 Offer 16. 数值的整数次方

**题目描述：** 实现函数 `doublePower(x, n)`，计算 `x` 的 `n` 次方。如果 `n` 为负数，则实现 `1/x` 的 `|n|` 次方。

**思路：** 使用快速幂算法，将指数分解为二进制数的形式，递归计算幂次。

**答案：**

```python
def doublePower(x, n):
    if n == 0:
        return 1
    if n < 0:
        return 1 / doublePower(x, -n)
    half = doublePower(x, n // 2)
    if n % 2 == 0:
        return half * half
    else:
        return half * half * x
```

#### 12. 剑指 Offer 17. 数组的奇数倍数

**题目描述：** 给定一个整数数组 arr，将数组中的每个元素替换为该元素乘以它下标的两倍值。例如，给定数组 `[1, 2, 3, 4, 5]`，替换后的数组为 `[0, 4, 12, 32, 80]`。

**思路：** 遍历数组，根据下标和元素值计算替换后的值。

**答案：**

```python
def arrayMultiply(arr):
    n = len(arr)
    for i in range(n):
        arr[i] *= (2 * i + 1)
    return arr
```

#### 13. 剑指 Offer 18. 验证二叉树的前序遍历序列

**题目描述：** 给定一个二叉树的前序遍历序列，请判断它是否是二叉搜索树。

**思路：** 使用递归，遍历每个节点，判断其左右子树是否满足二叉搜索树的条件。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBST(root):
    def dfs(root, lower, upper):
        if not root:
            return True
        val = root.val
        if val <= lower or val >= upper:
            return False
        if not dfs(root.right, val, upper):
            return False
        if not dfs(root.left, lower, val):
            return False
        return True

    return dfs(root, float('-inf'), float('inf'))
```

#### 14. 剑指 Offer 19. 二叉树的镜像

**题目描述：** 请实现一个函数，输入一个二叉树，该函数输出它的镜像。

**思路：** 使用递归，交换每个节点的左右子树。

**答案：**

```python
def mirrorTree(root):
    if not root:
        return None
    root.left, root.right = mirrorTree(root.right), mirrorTree(root.left)
    return root
```

#### 15. 剑指 Offer 20. 调整数组顺序使奇数位于偶数前面

**题目描述：** 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于偶数之前，并保证奇数和奇数之间、偶数和偶数之间的相对位置不变。

**思路：** 使用两个指针，一个从前往后遍历，一个从后往前遍历，当奇数指针指向的数字大于偶数指针指向的数字时，交换两个数字。

**答案：**

```python
def exchange(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        while left < right and nums[left] % 2 == 1:
            left += 1
        while left < right and nums[right] % 2 == 0:
            right -= 1
        if left < right:
            nums[left], nums[right] = nums[right], nums[left]
            left += 1
            right -= 1
    return nums
```

#### 16. 剑指 Offer 21. 调整数组顺序使奇数位于偶数之前（优化的方法）

**题目描述：** 给定一个整数数组 nums 和一个整数 k。请你返回数组中第 k 个比当前元素大的元素。如果不存在，则返回 -1。

**思路：** 使用二分查找，在数组中查找第 k 个比当前元素大的元素。

**答案：**

```python
def findKthLargest(nums, k):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        count = 0
        for i in range(len(nums)):
            if nums[i] > nums[mid]:
                count += 1
        if count < k:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

#### 17. 剑指 Offer 22. 链表中倒数第 k 个节点

**题目描述：** 输入一个链表的头节点，输出该链表中倒数第 k 个节点。

**思路：** 使用快慢指针，快指针先走 k-1 步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针指向的节点就是倒数第 k 个节点。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head, k):
    fast = head
    slow = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    while fast:
        fast = fast.next
        slow = slow.next
    return slow
```

#### 18. 剑指 Offer 23. 合并 k 个排序链表

**题目描述：** 合并 k 个排序的单链表，其中链表的元素都是整数，并且 k 是正数。

**思路：** 使用优先队列（小根堆）维护当前所有链表的头部节点，每次取出最小值节点，将下一个节点放入优先队列，直到优先队列为空。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

import heapq

def mergeKLists(lists):
    heap = []
    for head in lists:
        if head:
            heapq.heappush(heap, (head.val, head))
    dummy = ListNode(0)
    curr = dummy
    while heap:
        _, node = heapq.heappop(heap)
        curr.next = node
        curr = curr.next
        if node.next:
            heapq.heappush(heap, (node.next.val, node.next))
    return dummy.next
```

#### 19. 剑指 Offer 24. 反转链表

**题目描述：** 输入一个链表，输出该链表中倒数第 k 个节点。

**思路：** 使用递归或迭代的方法，将链表反转。

**答案：**

递归方法：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    if not head or not head.next:
        return head
    p = reverseList(head.next)
    head.next.next = head
    head.next = None
    return p
```

迭代方法：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next = curr.next
        curr.next = prev
        prev = curr
        curr = next
    return prev
```

#### 20. 剑指 Offer 25. 合并两个排序的链表

**题目描述：** 输入两个递增排序的链表，合并这两个链表并返回链表排序后的结果。

**思路：** 遍历两个链表，比较当前节点值，将较小的节点添加到新链表中。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

#### 21. 剑指 Offer 26. 树的子结构

**题目描述：** 输入两棵二叉树 A 和 B，判断 B 是否为 A 的子结构。

**思路：** 遍历树 A 的每个节点，判断以该节点为根的子树是否与 B 相同。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSubStructure(A, B):
    if not B or not A:
        return False
    def dfs(A, B):
        if not B:
            return True
        if not A:
            return False
        if A.val == B.val:
            return dfs(A.left, B.left) and dfs(A.right, B.right)
        return False

    return any(dfs(A, B) for A in preorderTraversal(A))

def preorderTraversal(root):
    if not root:
        return []
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)
```

#### 22. 剑指 Offer 27. 二叉树的镜像

**题目描述：** 请实现一个函数，用来判断一棵二叉树是不是对称树。

**思路：** 使用递归，判断二叉树的左右子树是否互为镜像。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSymmetric(root):
    if not root:
        return True
    return dfs(root.left, root.right)

def dfs(p, q):
    if p is None and q is None:
        return True
    if p is None or q is None or p.val != q.val:
        return False
    return dfs(p.left, q.right) and dfs(p.right, q.left)
```

#### 23. 剑指 Offer 28. 对称的二叉树

**题目描述：** 请实现一个函数，用来判断一棵二叉树是不是对称树。

**思路：** 使用递归，判断二叉树的左右子树是否互为镜像。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSymmetric(root):
    if not root:
        return True
    return dfs(root.left, root.right)

def dfs(p, q):
    if p is None and q is None:
        return True
    if p is None or q is None or p.val != q.val:
        return False
    return dfs(p.left, q.right) and dfs(p.right, q.left)
```

#### 24. 剑指 Offer 29. 顺时针打印矩阵

**题目描述：** 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

**思路：** 设置边界条件，逐层打印矩阵。

**答案：**

```python
def spiralOrder(matrix):
    if not matrix or not matrix[0]:
        return []
    m, n = len(matrix), len(matrix[0])
    t, b, l, r = 0, m - 1, 0, n - 1
    ans = []
    while t <= b and l <= r:
        for i in range(l, r + 1):
            ans.append(matrix[t][i])
        t += 1
        for i in range(t, b + 1):
            ans.append(matrix[i][r])
        r -= 1
        if t <= b:
            for i in range(r, l - 1, -1):
                ans.append(matrix[b][i])
            b -= 1
        if l <= r:
            for i in range(b, t - 1, -1):
                ans.append(matrix[i][l])
            l += 1
    return ans
```

#### 25. 剑指 Offer 30. 最小栈

**题目描述：** 请定义一个栈，支持 push 、pop 、top 操作，同时还能查询栈的最小元素。

**思路：** 使用两个栈，一个用于存储元素，另一个用于存储当前栈中的最小值。

**答案：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

#### 26. 剑指 Offer 31. 栈的压入、弹出序列

**题目描述：** 输入两个整数序列，第一个序列表示栈的压入顺序，第二个序列为查询栈的最顶元素是否等于它，然后将该元素弹出。实现一个函数，输入两个序列，返回第二个序列中，需要至少插入几个元素才能得到第一个序列的结果。

**思路：** 遍历压栈序列，当栈顶元素等于当前元素时，弹出元素，否则将当前元素压入栈中。

**答案：**

```python
def validateStackSequences(pushed, popped):
    stack = []
    j = 0
    for num in pushed:
        stack.append(num)
        while stack and stack[-1] == popped[j]:
            stack.pop()
            j += 1
    return not stack
```

#### 27. 剑指 Offer 32 - I. 步骤数

**题目描述：** 一只青蛙想要过河。快

