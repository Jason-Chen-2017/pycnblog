                 

# 经典阅读清单：奠定认知根基

## 领域相关典型问题/面试题库

### 1. 如何评估一本书的阅读价值？

**题目：** 请简述评估一本书的阅读价值时需要考虑的几个因素。

**答案：**

评估一本书的阅读价值，可以从以下几个因素进行考虑：

1. **作者权威性：** 选择在特定领域内有较高影响力的作者所著的书籍。
2. **内容深度：** 内容是否深入探讨了你感兴趣的领域。
3. **实用性：** 书中的内容是否能够应用于实际工作和生活中。
4. **知识广度：** 是否涉及了你想要了解的其他相关领域。
5. **评价与推荐：** 查看读者评论和专业书评，了解他人的评价和推荐。
6. **出版时间：** 选择较为新的出版物，以确保内容的时效性。

### 2. 如何有效地进行阅读笔记整理？

**题目：** 在阅读过程中，如何有效地整理笔记？

**答案：**

有效的阅读笔记整理包括以下几个步骤：

1. **选择合适的笔记工具：** 可以选择传统的纸质笔记本或电子笔记软件，如Evernote、OneNote等。
2. **笔记分类：** 根据书籍内容和主题，将笔记分为不同的类别，便于后续查找和复习。
3. **做关键词摘录：** 对书中重要观点、结论、方法等做关键词摘录，便于快速回顾。
4. **写心得体会：** 记录阅读过程中的思考和体会，加深对书内容的理解和记忆。
5. **制作思维导图：** 使用思维导图工具，将书籍的核心内容、重要概念和观点进行图形化整理。
6. **定期复习：** 定期回顾笔记，巩固记忆，加深对书内容的理解和应用。

### 3. 阅读中如何提高注意力集中度？

**题目：** 请分享一些提高阅读集中度的技巧。

**答案：**

提高阅读集中度，可以尝试以下技巧：

1. **设定阅读目标：** 在阅读前设定明确的目标，如阅读时间、阅读页数等。
2. **创造良好的阅读环境：** 选择安静、舒适的环境，避免干扰因素。
3. **分段阅读：** 将阅读时间分为几个短时间段，每次集中注意力阅读一段时间，然后休息。
4. **限制使用电子设备：** 阅读时尽量减少使用手机、电脑等电子设备，避免分心。
5. **使用阅读工具：** 可以使用阅读软件中的番茄钟功能，帮助自己更好地管理阅读时间。
6. **专注训练：** 通过冥想、专注训练等技巧，提高自己的专注力。

### 4. 如何将阅读与实践相结合？

**题目：** 请简述如何将阅读与实践相结合，以提高学习效果。

**答案：**

将阅读与实践相结合，可以提高学习效果，具体方法如下：

1. **应用所学知识：** 在实际工作中或日常生活中，尝试应用书籍中学到的知识和技巧。
2. **案例分析和讨论：** 通过阅读相关案例，分析案例中的问题并提出解决方案，与他人进行讨论。
3. **项目实践：** 结合阅读内容，参与相关项目，将理论知识应用到实际项目中。
4. **写作和分享：** 通过写作和分享自己的学习心得，深化对知识的理解和应用。
5. **定期复习：** 定期回顾和实践所学知识，巩固记忆，提升应用能力。
6. **请教专业人士：** 向相关领域的专业人士请教，了解实战经验和应用技巧。

## 算法编程题库

### 1. 寻找两个有序数组的中位数

**题目：** 给定两个大小分别为 `m` 和 `n` 的有序数组 `nums1` 和 `nums2`，请找出这两个有序数组的中位数。

**答案：**

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        nums = sorted(nums1 + nums2)
        l = len(nums)
        if l % 2 == 0:
            return (nums[l//2 - 1] + nums[l//2]) / 2
        else:
            return nums[l//2]
```

**解析：** 先将两个数组合并并排序，然后根据数组的长度判断中位数是第几个元素。如果长度是偶数，则中位数是中间两个数的平均值；如果是奇数，则中位数是中间的数。

### 2. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for c in strs[0]:
            for s in strs:
                if c not in s:
                    return prefix
            prefix += c
        return prefix
```

**解析：** 遍历第一个字符串的每个字符，然后在其他字符串中检查这个字符是否出现。如果出现，则将其添加到前缀中；如果未出现，则返回当前前缀。

### 3. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i, v in enumerate(nums):
            complement = target - v
            if complement in hashmap:
                return [hashmap[complement], i]
            hashmap[v] = i
        return []
```

**解析：** 使用一个哈希表来存储数组中每个数字和其索引的映射。遍历数组，对于当前数字，计算其补数（目标值减去当前数字），检查补数是否在哈希表中。如果在，则返回当前数字的索引和补数的索引。

### 4. 最长回文子串

**题目：** 给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        start = 0
        end = 0
        for i in range(len(s)):
            len1 = self.expandAroundCenter(s, i, i)
            len2 = self.expandAroundCenter(s, i, i+1)
            maxLen = max(len1, len2)
            if maxLen > end - start:
                start = i - (maxLen - 1) // 2
                end = i + maxLen // 2
        return s[start:end+1]

    def expandAroundCenter(self, s: str, left: int, right: int) -> int:
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return right - left - 1
```

**解析：** 使用双指针法，一个指针指向中间，另一个指针向两边扩展，找到最长的回文子串。

### 5. 盛最多水的容器

**题目：** 给定一个长度为 `n` 的整数数组 `height` ，有 `n` 个竖直的线段，宽度为 1 。计算按这些线段放置所能容纳水的最大容量。

**答案：**

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0
        while left < right:
            max_area = max(max_area, min(height[left], height[right]) * (right - left))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return max_area
```

**解析：** 双指针法，一个指针指向左端，一个指针指向右端，计算两个指针所指向的高度较小的那个和它们之间的距离的乘积，更新最大面积。每次移动高度较小的指针。

### 6. 删除链表的节点

**题目：** 给定一个单链表的头节点 `head` 和一个整数 `val` ，删除链表中所有值为 `val` 的节点。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteNode(self, node: 'ListNode') -> None:
        node.val = node.next.val
        node.next = node.next.next
```

**解析：** 将待删除节点的值替换为下一个节点的值，然后将待删除节点指向下一个节点的下一个节点，从而删除该节点。

### 7. 旋转图像

**题目：** 给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

**答案：**

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n // 2):
            for j in range(i, n - i - 1):
                temp = matrix[i][j]
                matrix[i][j] = matrix[n - j - 1][i]
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
                matrix[j][n - i - 1] = temp
```

**解析：** 分四步进行旋转，每次旋转一个环，交换环上的四个点。

### 8. 找到旋转排序数组中的最小值

**题目：** 已知一个长度为 `n` 的数组，元素从 `0` 到 `n - 1` 旋转 `k` 次。请找出并返回数组中的最小元素。

**答案：**

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left < right:
            mid = (left + right) >> 1
            if nums[mid] > nums[right]:
                left = mid + 1
            else:
                right = mid
        return nums[left]
```

**解析：** 二分查找，当中间元素大于右侧元素时，最小值在右侧；当中间元素小于右侧元素时，最小值在左侧或中间。

### 9. 环形链表

**题目：** 给定一个链表的头节点 `head` ，判断链表是否为环形链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def hasCycle(self, head: 'Optional[ListNode]') -> bool:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

**解析：** 快慢指针法，当快指针追上慢指针时，表示链表存在环。

### 10. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: 'Optional[ListNode]', list2: 'Optional[ListNode]') -> 'Optional[ListNode]':
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

**解析：** 递归合并两个链表，每次比较头节点，选择较小的节点作为新的头节点，并递归合并剩余部分。

### 11. 盲插排序

**题目：** 实现一个 `insert` 函数，用来实现盲插排序算法。

**答案：**

```python
def insert(arr, val):
    arr.append(val)
    arr.sort()
    return arr

arr = [1, 3, 5, 7]
val = 4
print(insert(arr, val))
```

**解析：** 将待插入的值添加到数组末尾，然后对数组进行排序，返回排序后的数组。

### 12. 快速排序

**题目：** 实现一个 `quick_sort` 函数，用来实现快速排序算法。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))
```

**解析：** 选择中间值作为枢轴，将数组分为小于、等于和大于枢轴的三个部分，递归地对小于和大于枢轴的部分进行排序，最后合并。

### 13. 冒泡排序

**题目：** 实现一个 `bubble_sort` 函数，用来实现冒泡排序算法。

**答案：**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))
```

**解析：** 通过反复交换相邻的未排序元素，将数组中的最大元素逐渐“冒泡”到数组的末尾。

### 14. 选择排序

**题目：** 实现一个 `selection_sort` 函数，用来实现选择排序算法。

**答案：**

```python
def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

arr = [64, 34, 25, 12, 22, 11, 90]
print(selection_sort(arr))
```

**解析：** 在未排序部分中找到最小元素，并将其移动到已排序部分的末尾。

### 15. 计数排序

**题目：** 实现一个 `counting_sort` 函数，用来实现计数排序算法。

**答案：**

```python
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    output = [0] * len(arr)
    for num in arr:
        count[num] += 1
    for i in range(1, len(count)):
        count[i] += count[i - 1]
    for num in arr:
        output[count[num] - 1] = num
        count[num] -= 1
    return output

arr = [64, 34, 25, 12, 22, 11, 90]
print(counting_sort(arr))
```

**解析：** 利用计数数组统计每个元素的个数，然后根据计数数组来放置每个元素。

### 16. 希尔排序

**题目：** 实现一个 `shell_sort` 函数，用来实现希尔排序算法。

**答案：**

```python
def shell_sort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            temp = arr[i]
            j = i
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2
    return arr

arr = [64, 34, 25, 12, 22, 11, 90]
print(shell_sort(arr))
```

**解析：** 选择一个间隔序列（通常是序列长度的一半），将序列划分为间隔子序列，分别进行插入排序，逐渐减小间隔序列的大小。

### 17. 归并排序

**题目：** 实现一个 `merge_sort` 函数，用来实现归并排序算法。

**答案：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

arr = [64, 34, 25, 12, 22, 11, 90]
print(merge_sort(arr))
```

**解析：** 将数组划分为两个子数组，分别递归排序，然后合并两个有序子数组。

### 18. 暴力排列组合

**题目：** 实现一个函数，打印一个字符串的所有排列组合。

**答案：**

```python
def permutations(s):
    if len(s) <= 1:
        return [s]
    result = []
    for i, c in enumerate(s):
        for p in permutations(s[:i] + s[i+1:]):
            result.append(c + p)
    return result

s = "abc"
print(permutations(s))
```

**解析：** 使用递归方法，将字符串的第一个字符与其后的所有排列组合连接，生成新的排列。

### 19. 不重复排列组合

**题目：** 实现一个函数，打印一个字符串的所有不重复排列组合。

**答案：**

```python
def unique_permutations(s):
    if len(s) <= 1:
        return [s]
    result = []
    for i, c in enumerate(s):
        for p in unique_permutations(s[:i] + s[i+1:]):
            if c not in p:
                result.append(c + p)
    return result

s = "aabc"
print(unique_permutations(s))
```

**解析：** 同样使用递归方法，但在此过程中，避免重复字符出现在相同的位置。

### 20. 字符串全排列

**题目：** 实现一个函数，打印一个字符串的所有全排列。

**答案：**

```python
def string_permutations(s):
    if len(s) <= 1:
        return [s]
    result = []
    for i, c in enumerate(s):
        for p in string_permutations(s[:i] + s[i+1:]):
            result.append(c + p)
    return result

s = "abc"
print(string_permutations(s))
```

**解析：** 使用递归方法，将字符串的第一个字符与其后的所有全排列组合连接，生成新的全排列。

### 21. 前K个高频单词

**题目：** 给你一个字符串数组 `words` 和一个整数 `k` ，请返回 `words` 中出现频率最高的 `k` 个不同单词。你可以按 **任意顺序** 返回答案。

**答案：**

```python
from collections import Counter

def topKFrequent(words, k):
    cnt = Counter(words)
    return [w for w, _ in cnt.most_common(k)]

words = ["i", "love", "leetcode", "i", "love", "coding"]
k = 2
print(topKFrequent(words, k))
```

**解析：** 使用 `Counter` 计数器统计单词频率，然后使用 `most_common` 方法获取频率最高的 `k` 个单词。

### 22. 字符串中单词的数目

**题目：** 请你实现一个函数，用来计算一个给定字符串中的单词数目。

**答案：**

```python
def count_words(s):
    return len(s.strip().split())

s = "Hello, my name is John Doe."
print(count_words(s))
```

**解析：** 使用 `strip` 方法去除字符串两端的空白字符，然后使用 `split` 方法按空格分割字符串，最后返回分割后的元素数量。

### 23. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, v in enumerate(nums):
        complement = target - v
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[v] = i
    return []

nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))
```

**解析：** 使用哈希表存储数组中的元素和其索引，遍历数组的同时检查哈希表中是否存在当前元素的补数。

### 24. 三数之和

**题目：** 给定一个包含 `n` 个整数的数组 `nums` ，判断 `nums` 中是否存在三个元素 `a，b，c` ，使得 `a + b + c = 0`？请你找出所有满足条件且不重复的三元组。

**答案：**

```python
def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result

nums = [-1, 0, 1, 2, -1, -4]
print(three_sum(nums))
```

**解析：** 使用双指针法，对数组进行排序，然后遍历数组，使用两个指针分别指向 `i+1` 和 `len(nums)-1` ，根据三个数的和与0的关系调整指针。

### 25. 四数之和

**题目：** 给定一个包含 `n` 个整数的数组 `nums` 和一个目标值 `target` ，请你找出和为 `target` 的四个整数且不重复，并返回四个整数的组合。

**答案：**

```python
def four_sum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue
            left, right = j + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif total < target:
                    left += 1
                else:
                    right -= 1
    return result

nums = [1, 0, -1, 0, -2, 2]
target = 0
print(four_sum(nums, target))
```

**解析：** 使用双指针法，对数组进行排序，然后遍历数组，使用两个两层循环分别找到两个数，然后用双指针法找到另外两个数，确保结果不重复。

### 26. 搜索旋转排序数组

**题目：** 已知一个长度为 `n` 的数组，元素从 `0` 到 `n - 1` 旋转 `k` 次。请找出并返回数组中的最小元素。

**答案：**

```python
def search_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

nums = [4, 5, 6, 7, 0, 1, 2]
print(search_min(nums))
```

**解析：** 使用二分查找，当中间元素大于右侧元素时，最小值在右侧；当中间元素小于右侧元素时，最小值在左侧或中间。

### 27. 搜索旋转排序数组 II

**题目：** 已知一个长度为 `n` 的数组，元素从 `0` 到 `n - 1` 旋转 `k` 次。请找出并返回数组中的最小元素。

**答案：**

```python
def search_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == nums[right]:
            right -= 1
        elif nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

nums = [1, 3, 5]
print(search_min(nums))
```

**解析：** 同上题，但是处理重复元素，当中间元素等于右侧元素时，无法确定最小值的位置，所以将右侧元素索引减一。

### 28. 存在重复元素 II

**题目：** 给定一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个不同的索引 `i` 和 `j` ，使得 `nums[i] == nums[j]` 且 `|i - j| <= k` 。

**答案：**

```python
def containsNearbyDuplicate(nums, k):
    seen = {}
    for i, v in enumerate(nums):
        if v in seen and i - seen[v] <= k:
            return True
        seen[v] = i
    return False

nums = [1, 2, 3, 1, 2, 3]
k = 2
print(containsNearbyDuplicate(nums, k))
```

**解析：** 使用哈希表存储每个元素的最后一次出现的位置，遍历数组，检查当前元素是否在哈希表中，并且当前索引与上次出现位置的差值是否小于等于 `k` 。

### 29. 存在重复元素 III

**题目：** 给定一个整数数组 `nums` 和两个整数 `t` 和 `k` ，判断数组中是否存在两个不同的索引 `i` 和 `j` ，使得 `nums[i] == nums[j]` 且 `(|i - j| <= t)` 或 `abs(nums[i] - nums[j]) <= t` 。

**答案：**

```python
from sortedcontainers import SortedList

def containsNearbyAlmostDuplicate(nums, t, k):
    s = SortedList()
    for i, v in enumerate(nums):
        if i > k:
            s.remove(nums[i - k - 1])
        idx = s.bisect_left(v - t)
        if idx != len(s) and s[idx] >= v - t:
            return True
        idx = s.bisect_left(v + t)
        if idx != 0 and s[idx - 1] <= v + t:
            return True
        s.add(v)
    return False

nums = [1, 2, 3, 1]
t = 0
k = 0
print(containsNearbyAlmostDuplicate(nums, t, k))
```

**解析：** 使用有序集合（SortedSet）来维护最近 `k` 个元素，使用二分搜索找到符合条件的元素。

