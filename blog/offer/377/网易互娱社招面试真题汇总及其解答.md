                 

### 网易互娱社招面试真题及解答

以下是根据2024网易互娱社招面试真题汇总及其解答，精选出的典型问题及详细解析，包含算法题和数据结构题。

#### 1. 计算字符串中的最长回文子串

**题目描述：** 给定一个字符串，找到最长的回文子串。

**示例：** 输入："babad"，输出："bab" 或 "aba"。

**答案解析：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        len1, len2 := expandAroundCenter(s, i, i), expandAroundCenter(s, i, i+1)
        if len1 > maxLen {
            maxLen = len1
            start = i
        }
        if len2 > maxLen {
            maxLen = len2
            start = i
        }
    }
    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    n := len(s)
    for left >= 0 && right < n && s[left] == s[right] {
        left--
        right++
    }
    return right - left - 1
}
```

**解析：** 使用中心扩散法，对于每个字符，分别作为回文串的中心点进行左右扩展，找到最长的回文子串。

#### 2. 二分查找

**题目描述：** 实现一个二分查找算法，在有序数组中查找一个目标值。

**示例：** 输入：`[1, 3, 5, 6]`，`target = 5`，输出：`2`。

**答案解析：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**解析：** 使用二分查找算法，不断缩小搜索范围，直到找到目标值或确定目标值不存在。

#### 3. 判断二进制数中1的个数

**题目描述：** 写一个函数，计算一个无符号整数二进制表示中1的个数。

**示例：** 输入：`0xFFFFFFFF`，输出：`32`。

**答案解析：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 使用位操作，将二进制数不断右移，每次与1进行与操作，统计1的个数。

#### 4. 链表倒数第k个节点

**题目描述：** 输入一个链表和一个整数k，输出链表中倒数第k个节点。

**示例：** 输入：`[1, 2, 3, 4, 5]`，`k = 2`，输出：节点值为 `4`。

**答案解析：**

```go
func getKthFromTheEnd(head *ListNode, k int) *ListNode {
    fast, slow := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

**解析：** 使用快慢指针方法，先让快指针移动k个节点，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针即为倒数第k个节点。

#### 5. 合并两个有序链表

**题目描述：** 输入两个已经排序的单链表，将它们合并为一个新的有序单链表。

**示例：** 输入：`[1->3->5]`，`[2->4->6]`，输出：`[1->2->3->4->5->6]`。

**答案解析：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归合并两个有序链表，选择较小的节点作为新的头节点，并递归合并剩余的链表。

#### 6. 旋转数组

**题目描述：** 给定一个数组，将数组中的元素向右移动 k 个位置。

**示例：** 输入：`[1, 2, 3, 4, 5, 6, 7]`，`k = 3`，输出：`[5, 6, 7, 1, 2, 3, 4]`。

**答案解析：**

```go
func rotateArray(nums []int, k int) {
    k = k % len(nums)
    reverse(nums, 0, len(nums)-1)
    reverse(nums, 0, k-1)
    reverse(nums, k, len(nums)-1)
}

func reverse(nums []int, start, end int) {
    for i, j := start, end; i < j; i, j = i+1, j-1 {
        nums[i], nums[j] = nums[j], nums[i]
    }
}
```

**解析：** 使用反转方法，先整体反转数组，再反转前k个元素，最后反转剩余的元素。

#### 7. 快排

**题目描述：** 实现快速排序算法。

**示例：** 输入：`[3, 2, 1, 5, 6, 4]`，输出：`[1, 2, 3, 4, 5, 6]`。

**答案解析：**

```go
func quickSort(nums []int) {
    if len(nums) <= 1 {
        return
    }
    pivot := nums[len(nums)/2]
    left, right := 0, len(nums)-1
    for {
        for nums[left] < pivot {
            left++
        }
        for nums[right] > pivot {
            right--
        }
        if left >= right {
            break
        }
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
    quickSort(nums[:left])
    quickSort(nums[left:])
}
```

**解析：** 选择中间值为基准，将数组分为小于基准和大于基准的两部分，递归排序。

#### 8. 最大子序和

**题目描述：** 给定一个整数数组，找出其中最大子序和。

**示例：** 输入：`[-2, 1, -3, 4, -1, 2, 1, -5, 4]`，输出：`6`。

**答案解析：**

```go
func maxSubArray(nums []int) int {
    ans, sum := nums[0], 0
    for _, num := range nums {
        sum += num
        if sum > ans {
            ans = sum
        }
        if sum < 0 {
            sum = 0
        }
    }
    return ans
}
```

**解析：** 动态规划，用一个变量维护当前子序和，更新最大子序和，当当前子序和小于0时，重置为0。

#### 9. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的数组，找到目标值，并返回其索引。如果没有，返回-1。

**示例：** 输入：`[4,5,6,7,0,1,2]`，`target = 0`，输出：`4`。

**答案解析：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[right] && target <= nums[mid] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 模拟二分查找，考虑旋转数组的特殊情况，根据中间值和左右端点的关系调整查找范围。

#### 10. 两数之和

**题目描述：** 给定一个整数数组，找出两个数使得它们的和等于目标值。

**示例：** 输入：`[2, 7, 11, 15]`，`target = 9`，输出：`[0, 1]`。

**答案解析：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

**解析：** 使用哈希表记录每个数值的索引，通过计算补数并查找哈希表，找到两个数的索引。

#### 11. 拓扑排序

**题目描述：** 实现拓扑排序算法。

**示例：** 输入：`[2, 1, 3]`，输出：`[0, 2, 1, 3]`。

**答案解析：**

```go
func topologySort(edges [][]int) []int {
    inDegree := make([]int, len(edges))
    for _, edge := range edges {
        from := edge[0]
        to := edge[1]
        inDegree[to]++
    }
    queue := []int{}
    for i, degree := range inDegree {
        if degree == 0 {
            queue = append(queue, i)
        }
    }
    result := []int{}
    for len(queue) > 0 {
        top := queue[0]
        queue = queue[1:]
        result = append(result, top)
        for _, edge := range edges[top] {
            inDegree[edge]--
            if inDegree[edge] == 0 {
                queue = append(queue, edge)
            }
        }
    }
    return result
}
```

**解析：** 使用入度数组记录每个节点的入度，利用队列实现拓扑排序。

#### 12. 颜色分类

**题目描述：** 给定一个包含红色、白色和蓝色、共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。

**示例：** 输入：`[2, 0, 2, 1, 1, 0]`，输出：`[0, 0, 1, 1, 2, 2]`。

**答案解析：**

```go
func sortColors(nums []int) {
    zero, one, two := 0, 0, len(nums)
    for i := 0; i < two; i++ {
        if nums[i] == 0 {
            nums[zero], nums[i] = nums[i], nums[zero]
            zero++
        } else if nums[i] == 1 {
            nums[one], nums[i] = nums[i], nums[one]
            one++
        } else {
            nums[two-1], nums[i] = nums[i], nums[two-1]
            two--
            i--
        }
    }
}
```

**解析：** 使用三个指针分别维护0、1、2的位置，遍历数组，根据值的大小交换位置。

#### 13. 合并K个排序链表

**题目描述：** 合并K个已排序的链表，返回合并后的排序链表。

**示例：** 输入：`[ [1,4,5], [1,3,4], [2,6] ]`，输出：`[1,1,2,3,4,4,5,6]`。

**答案解析：**

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    for len(lists) > 1 {
        lists = mergeTwoLists(lists[0], lists[1])
        if len(lists) > 1 {
            lists = append(lists, lists[2])
        }
    }
    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) []*ListNode {
    dummy := &ListNode{}
    prev := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            prev.Next = l1
            l1 = l1.Next
        } else {
            prev.Next = l2
            l2 = l2.Next
        }
        prev = prev.Next
    }
    if l1 != nil {
        prev.Next = l1
    } else if l2 != nil {
        prev.Next = l2
    }
    return []*ListNode{dummy.Next}
}
```

**解析：** 使用合并两个有序链表的方法，递归合并K个有序链表。

#### 14. 设计循环队列

**题目描述：** 设计一个循环队列，支持以下操作：enQueue(R, x)，将一个元素插入到循环队列R的尾部；deQueue(R)，从循环队列R的前端删除一个元素；front(R)，获取循环队列R的前端元素；isEmpty(R)，判断循环队列R是否为空；isFull(R)，判断循环队列R是否已满。

**示例：** 输入：`enQueue(5, 1)`，`enQueue(5, 2)`，`enQueue(5, 3)`，`deQueue(5)`，`front(5)`，输出：`[true, true, true, true, 2]`。

**答案解析：**

```go
type CQueue struct {
    queue []int
    front int
    rear  int
    size  int
}

func Constructor(k int) CQueue {
    return CQueue{
        queue: make([]int, k),
        front: 0,
        rear:  0,
        size:  k,
    }
}

func (this *CQueue) enQueue(value int) bool {
    if this.isFull() {
        return false
    }
    this.queue[this.rear] = value
    this.rear = (this.rear + 1) % this.size
    return true
}

func (this *CQueue) deQueue() bool {
    if this.isEmpty() {
        return false
    }
    this.front = (this.front + 1) % this.size
    return true
}

func (this *CQueue) front() int {
    if this.isEmpty() {
        return -1
    }
    return this.queue[this.front]
}

func (this *CQueue) isEmpty() bool {
    return this.front == this.rear
}

func (this *CQueue) isFull() bool {
    return (this.rear+1)%this.size == this.front
}
```

**解析：** 使用数组实现循环队列，通过取模操作实现循环。

#### 15. 合并区间

**题目描述：** 给定一组区间，合并所有重叠的区间。

**示例：** 输入：`[ [1,3], [2,6], [8,10], [15,18] ]`，输出：`[ [1,6], [8,10], [15,18] ]`。

**答案解析：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 先对区间进行排序，然后遍历合并重叠的区间。

#### 16. 设计哈希表

**题目描述：** 设计一个哈希表，支持插入、删除和查找操作。

**示例：** 输入：`[ "put", "apple", "banana" ]`，`[ "get", "apple" ]`，`[ "delete", "banana" ]`，`[ "get", "banana" ]`，输出：`[ true, true, false, false ]`。

**答案解析：**

```go
type MyHashMap struct {
    buckets []*Bucket
    size    int
}

type Bucket struct {
    key   string
    value int
    next  *Bucket
}

func Constructor(size int) MyHashMap {
    return MyHashMap{
        buckets: make([]*Bucket, size),
        size:    size,
    }
}

func (this *MyHashMap) Put(key string, value int) {
    index := hash(key)
    bucket := this.buckets[index]
    if bucket == nil {
        this.buckets[index] = &Bucket{key, value, nil}
    } else {
        for bucket != nil {
            if bucket.key == key {
                bucket.value = value
                return
            }
            if bucket.next == nil {
                break
            }
            bucket = bucket.next
        }
        bucket.next = &Bucket{key, value, nil}
    }
}

func (this *MyHashMap) Get(key string) int {
    index := hash(key)
    bucket := this.buckets[index]
    if bucket == nil {
        return -1
    }
    for bucket != nil {
        if bucket.key == key {
            return bucket.value
        }
        bucket = bucket.next
    }
    return -1
}

func (this *MyHashMap) Delete(key string) {
    index := hash(key)
    bucket := this.buckets[index]
    if bucket == nil {
        return
    }
    if bucket.key == key {
        this.buckets[index] = bucket.next
        return
    }
    prev := bucket
    for bucket != nil {
        if bucket.key == key {
            prev.next = bucket.next
            return
        }
        prev = bucket
        bucket = bucket.next
    }
}

func hash(key string) int {
    hash := 0
    for i := 0; i < len(key); i++ {
        hash = hash*33 + int(key[i])
    }
    return hash % this.size
}
```

**解析：** 使用拉链法解决哈希冲突，每个桶为一个链表。

#### 17. 颜色混合

**题目描述：** 给定一个包含红色、绿色和蓝色值的列表，每个值代表一种颜色。你需要按顺序返回重构的彩色列表，使得相邻元素的颜色相等，或者它们在数组中的相对位置与原始数组相同。

**示例：** 输入：`[[1,2],[3,4]]`，输出：`[[1,1],[2,2],[3,3],[4,4]]`。

**答案解析：**

```go
func reconstruct(painting [][]int) [][]int {
    m, n := len(painting), len(painting[0])
    ans := make([][]int, m*n)
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            color := painting[i][j]
            ans[i*n+j] = []int{color, color}
        }
    }
    for i := 1; i < m; i++ {
        if ans[i][0] == ans[i-1][0] {
            ans[i][0] = 0
        }
    }
    for j := 1; j < n; j++ {
        if ans[j*n+(j-1)] == ans[j*n+(j-2)] {
            ans[j*n+(j-1)][1] = 0
        }
    }
    return ans
}
```

**解析：** 遍历数组，判断相邻元素的颜色是否相同，更新数组。

#### 18. 合并区间 II

**题目描述：** 给定一组区间，合并所有重叠的区间，并返回一个表示合并后区间的列表。

**示例：** 输入：`[ [1,4], [4,5] ]`，输出：`[ [1,5] ]`。

**答案解析：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return [][]int{}
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        last := ans[len(ans)-1]
        if last[1] >= intervals[i][0] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}
```

**解析：** 同合并区间，但需要考虑区间重叠的情况。

#### 19. 合并区间 III

**题目描述：** 给定一组区间，合并所有重叠的区间，并返回一个表示合并后区间的列表。

**示例：** 输入：`[ [1,4], [4,5] ]`，输出：`[ [1,5] ]`。

**答案解析：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return [][]int{}
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        last := ans[len(ans)-1]
        if last[1] >= intervals[i][0] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}
```

**解析：** 同合并区间，但需要考虑区间重叠的情况。

#### 20. 设计一个支持增量操作的栈

**题目描述：** 设计一个支持增量操作的栈，支持以下操作：push(x)，将一个元素插入到栈顶；pop()，删除栈顶元素；top()，获取栈顶元素；increment(k, val)，将距离栈顶 k 个元素的元素的值增加 val。

**示例：** 输入：`["StackIncrement", "push", "push", "increment", "top", "pop"]`，`[[], [1], [2], [1, 5], [], []]`，输出：`[null, null, null, null, 6, 2]`。

**答案解析：**

```go
type CustomStack struct {
    s     []int
    inc   []int
}

func Constructor(maxSize int) CustomStack {
    return CustomStack{
        s:     make([]int, 0, maxSize),
        inc:   make([]int, 0, maxSize),
    }
}

func (this *CustomStack) Push(x int) {
    if len(this.s) < cap(this.s) {
        this.s = append(this.s, x)
    }
}

func (this *CustomStack) Pop() int {
    if len(this.s) == 0 {
        return -1
    }
    v := this.s[len(this.s)-1]
    this.s = this.s[:len(this.s)-1]
    if len(this.inc) > 0 {
        this.inc = this.inc[:len(this.inc)-1]
    }
    return v
}

func (this *CustomStack) Increment(k int, val int) {
    if len(this.inc) > 0 {
        this.inc = this.inc[:len(this.inc)-1]
    }
    if k-1 < len(this.s) {
        this.inc = append(this.inc, val)
    }
}

func (this *CustomStack) Top() int {
    if len(this.s) == 0 {
        return -1
    }
    v := this.s[len(this.s)-1]
    if len(this.inc) > 0 {
        this.inc = this.inc[:len(this.inc)-1]
        v += this.inc[len(this.inc)]
    }
    return v
}
```

**解析：** 使用数组实现栈，同时维护一个增量数组，记录每个元素的增量。

### 总结

以上是2024网易互娱社招面试真题及其解答的部分示例，涵盖了算法和数据结构领域的经典问题。通过对这些题目的深入解析和代码实现，可以帮助面试者更好地理解和应用这些算法和数据结构，提高面试竞争力。建议读者在实际面试中多加练习，加强对算法和数据结构的掌握，以提高面试成功的机会。同时，也欢迎读者在评论区分享其他有趣的面试题和解答，共同学习和进步。

