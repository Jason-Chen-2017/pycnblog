                 

### 概述：结构化思维在面试中的应用

**标题：** 结构化思维在面试中的应用：框架解析与实际案例分析

结构化思维是一种有条理、有逻辑的思考方式，它帮助我们在面对复杂问题时，能够快速理清头绪，找到解决方案。在面试过程中，结构化思维的应用尤为重要。本文将围绕结构化思维在面试中的应用，分析其理论基础，并结合实际案例进行详细讲解。

#### 一、结构化思维的基本理论

结构化思维主要包括以下几个步骤：

1. **明确问题：** 在面对一个面试问题时，首先要明确问题的核心，理解问题的背景和需求。
2. **分解问题：** 将问题分解成若干个子问题，以便逐一解决。
3. **分析问题：** 对每个子问题进行分析，找出关键因素和影响因素。
4. **解决问题：** 根据分析结果，提出解决方案。
5. **评估问题：** 对解决方案进行评估，确保其可行性和有效性。

#### 二、结构化思维在面试中的应用案例

以下是一则关于结构化思维在面试中的应用案例：

**面试问题：** 请描述一次你遇到的问题，以及你是如何解决的。

**答案解析：**

1. **明确问题：** 面试官希望了解候选人在面对问题时，是否能够运用结构化思维，清晰、有条理地描述问题。

2. **分解问题：** 将问题分解为以下几个子问题：
   - 你遇到的问题是什么？
   - 你是如何分析这个问题的？
   - 你是如何解决这个问题的？
   - 你从这个问题中学到了什么？

3. **分析问题：**
   - 描述问题的背景：你在公司负责的某个项目中，遇到了什么问题。
   - 分析问题的原因：可能是由于技术问题、团队协作问题或者资源分配问题等。
   - 分析问题的关键因素：可能涉及到的人员、技术、时间、资源等。

4. **解决问题：**
   - 描述你采取的解决方案：可能是与技术团队沟通、重新规划项目进度、调整资源分配等。
   - 说明解决方案的效果：通过你的努力，问题得到了怎样的解决，项目是否顺利进行。

5. **评估问题：**
   - 反思：从这次问题中，你学到了什么？如何避免类似问题的再次发生？
   - 总结：总结这次问题的处理过程，展示你的成长和进步。

通过以上案例，我们可以看到，结构化思维在面试中的应用，可以帮助候选人清晰、有条理地回答问题，展示自己的思考能力和解决问题的能力。

#### 三、结语

结构化思维是一种高效的思考方式，在面试中运用结构化思维，能够帮助你更好地应对各种问题。通过本文的讲解，相信你对于结构化思维在面试中的应用有了更深入的了解。在实际面试中，多加练习，灵活运用结构化思维，将有助于你顺利通过面试。

### 高频面试题库与结构化思维应用

**1. 什么是数据结构？请列举几种常见的数据结构及其特点。**

**答案解析：**

- **数据结构**：数据结构是计算机存储、组织数据的方式。
- **常见的数据结构**：
  - **数组**：用于存储固定大小的数据集合，支持随机访问。
  - **链表**：用于存储动态大小的数据集合，支持顺序访问。
  - **栈**：后进先出（LIFO）的数据结构，适用于函数调用栈。
  - **队列**：先进先出（FIFO）的数据结构，适用于任务调度。
  - **树**：用于表示层级关系，如二叉树、二叉搜索树等。
  - **图**：用于表示复杂的关系网络，如社交网络、交通网络等。
- **特点**：
  - **数组**：高效存储和访问，但大小固定，不易扩展。
  - **链表**：灵活扩展，但访问速度慢。
  - **栈**：简单实现，适用于后进先出的场景。
  - **队列**：公平调度，适用于先进先出的场景。
  - **树**：高效搜索和排序，适用于层级关系的表示。
  - **图**：复杂关系表示，适用于网络分析。

**2. 请简述排序算法的分类及其特点。**

**答案解析：**

- **排序算法**：排序算法用于将一组数据按照特定顺序排列。
- **分类**：
  - **内部排序**：全部数据存储在内存中进行排序。
    - **比较排序**：基于元素比较进行排序，如快速排序、归并排序等。
    - **非比较排序**：不基于元素比较进行排序，如计数排序、基数排序等。
  - **外部排序**：数据量过大，无法全部存储在内存中，需要借助外部存储（如硬盘）进行排序。
- **特点**：
  - **比较排序**：时间复杂度较高，但稳定性好。
  - **非比较排序**：时间复杂度较低，但稳定性差。

**3. 请解释冒泡排序、快速排序和归并排序的原理和优缺点。**

**答案解析：**

- **冒泡排序**：
  - **原理**：通过重复遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。
  - **优缺点**：
    - 优点：简单易懂，易于实现。
    - 缺点：时间复杂度高（O(n^2)），不稳定。

- **快速排序**：
  - **原理**：通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，已达到整个序列有序。
  - **优缺点**：
    - 优点：时间复杂度较低（O(nlogn)），适用于大数据集。
    - 缺点：最坏情况下时间复杂度为O(n^2)，不稳定。

- **归并排序**：
  - **原理**：将待排序的序列按照某种方式分割成若干个子序列，分别进行排序，然后将已排序的子序列合并成完整的序列。
  - **优缺点**：
    - 优点：时间复杂度稳定（O(nlogn)），稳定。
    - 缺点：空间复杂度高（O(n)），实现较复杂。

**4. 请解释查找算法的分类及其特点。**

**答案解析：**

- **查找算法**：查找算法用于在数据结构中查找特定元素。
- **分类**：
  - **顺序查找**：从第一个元素开始，依次与给定的元素值进行比较，直到找到或搜索到表尾。
    - **特点**：时间复杂度较高（O(n)），适用于数据量较小的情况。
  - **二分查找**：适用于有序数据，通过递归或迭代方式，不断缩小查找范围，时间复杂度较低（O(logn)）。
    - **特点**：时间复杂度较低，适用于数据量较大的情况。

**5. 请解释何为哈希表及其基本操作。**

**答案解析：**

- **哈希表**：哈希表是一种数据结构，用于高效存储和检索键值对。它通过哈希函数将键映射到表中的位置，通过哈希冲突解决方法处理不同的键映射到同一位置的情况。
- **基本操作**：
  - **哈希函数**：用于将键映射到表中的位置。
  - **插入**：将键值对插入到哈希表中。
  - **删除**：从哈希表中删除指定的键值对。
  - **查找**：在哈希表中查找指定的键。

**6. 请解释何为树结构及其分类。**

**答案解析：**

- **树结构**：树结构是一种数据结构，用于表示具有层次关系的数据。每个节点有一个父节点，零个或多个子节点。
- **分类**：
  - **二叉树**：每个节点最多有两个子节点。
    - **特点**：简单、易于实现，但存储不均衡。
  - **二叉搜索树**：左子树的键值小于根节点的键值，右子树的键值大于根节点的键值。
    - **特点**：高效查找、插入和删除操作，但可能失衡。
  - **平衡二叉树**：通过调整树的高度保持平衡，如AVL树、红黑树等。
    - **特点**：高效查找、插入和删除操作，高度平衡。

**7. 请解释何为图结构及其基本操作。**

**答案解析：**

- **图结构**：图结构是一种用于表示复杂关系的数据结构，由节点和边组成。节点表示实体，边表示节点之间的关系。
- **基本操作**：
  - **添加节点**：向图中添加一个新的节点。
  - **添加边**：向图中添加一个新的边。
  - **删除节点**：从图中删除一个节点及其相关的边。
  - **删除边**：从图中删除一条边。
  - **查找节点**：在图中查找一个节点。
  - **查找边**：在图中查找一条边。

**8. 请解释何为广度优先搜索（BFS）和深度优先搜索（DFS）。**

**答案解析：**

- **广度优先搜索（BFS）**：BFS 是一种图搜索算法，按照节点的层级进行搜索。从起始节点开始，依次访问其邻接节点，直到找到目标节点或搜索完整个图。
- **深度优先搜索（DFS）**：DFS 是一种图搜索算法，按照节点的深度进行搜索。从起始节点开始，一直沿着一条路径深入，直到遇到第一个目标节点或路径无法继续，然后回溯到上一个节点，继续探索其他路径。

**9. 请解释何为贪心算法及其应用场景。**

**答案解析：**

- **贪心算法**：贪心算法是一种在每一步选择当前最优解的算法。它通过不断选择局部最优解，最终得到全局最优解。
- **应用场景**：
  - **路径查找**：如最短路径算法（Dijkstra算法）。
  - **资源分配**：如最小生成树算法（Prim算法、Kruskal算法）。
  - **最优化问题**：如背包问题、作业调度问题等。

**10. 请解释何为动态规划及其应用场景。**

**答案解析：**

- **动态规划**：动态规划是一种在求解多阶段决策问题中，将复杂问题分解成若干个互相重叠的子问题，并利用子问题的解来构建原问题的解的算法。
- **应用场景**：
  - **路径查找**：如最短路径算法（Floyd算法）。
  - **最优化问题**：如背包问题、最长公共子序列问题、最长公共子串问题等。

**11. 请解释何为回溯算法及其应用场景。**

**答案解析：**

- **回溯算法**：回溯算法是一种通过递归尝试所有可能的组合，找出满足条件的最优解的算法。
- **应用场景**：
  - **组合问题**：如八皇后问题、0-1背包问题。
  - **排列问题**：如全排列、组合排列。
  - **路径问题**：如迷宫问题、旅行商问题。

**12. 请解释何为贪心算法和动态规划的区别。**

**答案解析：**

- **贪心算法**：
  - 特点：每一步选择当前最优解，但不保证最终得到全局最优解。
  - 适用场景：适用于局部最优解能够推导出全局最优解的问题。

- **动态规划**：
  - 特点：将复杂问题分解成互相重叠的子问题，利用子问题的解构建原问题的解。
  - 适用场景：适用于多阶段决策问题，能够在求解过程中保持状态。

- **区别**：
  - 贪心算法只考虑当前步骤的最优解，而动态规划考虑所有子问题的最优解。
  - 贪心算法不保证得到全局最优解，而动态规划能够得到全局最优解。

**13. 请解释何为贪心选择策略和动态规划中的状态转移方程。**

**答案解析：**

- **贪心选择策略**：
  - 贪心选择策略是贪心算法的核心思想，每次选择当前最优解，以便在整体上得到最优解。
  - 例如，在求最短路径问题时，每次选择当前距离起点的最短路径。

- **动态规划中的状态转移方程**：
  - 动态规划中的状态转移方程用于描述子问题的解与原问题的解之间的关系。
  - 例如，在求最长公共子序列问题时，状态转移方程描述了子序列的前缀与整个序列的关系。

**14. 请解释何为递归和分治算法。**

**答案解析：**

- **递归**：
  - 递归是一种算法设计方法，通过将大问题分解成若干个规模较小的相同问题来求解。
  - 递归通常使用函数调用来实现，递归调用是指函数调用自身。

- **分治算法**：
  - 分治算法是一种将大问题分解成若干个规模较小的相同问题，独立解决后合并解的算法。
  - 分治算法通常包括分解、解决和合并三个步骤。

**15. 请解释何为回溯算法和剪枝算法。**

**答案解析：**

- **回溯算法**：
  - 回溯算法是一种通过递归尝试所有可能的组合，找出满足条件的最优解的算法。
  - 回溯算法通常用于解决组合问题、排列问题等。

- **剪枝算法**：
  - 剪枝算法是一种在搜索过程中，提前终止某些分支的搜索，以减少计算量的算法。
  - 剪枝算法通常用于优化搜索算法，如剪枝搜索树、剪枝回溯算法等。

**16. 请解释何为贪心选择策略和动态规划中的状态转移方程。**

**答案解析：**

- **贪心选择策略**：
  - 贪心选择策略是贪心算法的核心思想，每次选择当前最优解，以便在整体上得到最优解。
  - 例如，在求最短路径问题时，每次选择当前距离起点的最短路径。

- **动态规划中的状态转移方程**：
  - 动态规划中的状态转移方程用于描述子问题的解与原问题的解之间的关系。
  - 例如，在求最长公共子序列问题时，状态转移方程描述了子序列的前缀与整个序列的关系。

**17. 请解释何为递归和分治算法。**

**答案解析：**

- **递归**：
  - 递归是一种算法设计方法，通过将大问题分解成若干个规模较小的相同问题来求解。
  - 递归通常使用函数调用来实现，递归调用是指函数调用自身。

- **分治算法**：
  - 分治算法是一种将大问题分解成若干个规模较小的相同问题，独立解决后合并解的算法。
  - 分治算法通常包括分解、解决和合并三个步骤。

**18. 请解释何为回溯算法和剪枝算法。**

**答案解析：**

- **回溯算法**：
  - 回溯算法是一种通过递归尝试所有可能的组合，找出满足条件的最优解的算法。
  - 回溯算法通常用于解决组合问题、排列问题等。

- **剪枝算法**：
  - 剪枝算法是一种在搜索过程中，提前终止某些分支的搜索，以减少计算量的算法。
  - 剪枝算法通常用于优化搜索算法，如剪枝搜索树、剪枝回溯算法等。

**19. 请解释何为贪心选择策略和动态规划中的状态转移方程。**

**答案解析：**

- **贪心选择策略**：
  - 贪心选择策略是贪心算法的核心思想，每次选择当前最优解，以便在整体上得到最优解。
  - 例如，在求最短路径问题时，每次选择当前距离起点的最短路径。

- **动态规划中的状态转移方程**：
  - 动态规划中的状态转移方程用于描述子问题的解与原问题的解之间的关系。
  - 例如，在求最长公共子序列问题时，状态转移方程描述了子序列的前缀与整个序列的关系。

**20. 请解释何为递归和分治算法。**

**答案解析：**

- **递归**：
  - 递归是一种算法设计方法，通过将大问题分解成若干个规模较小的相同问题来求解。
  - 递归通常使用函数调用来实现，递归调用是指函数调用自身。

- **分治算法**：
  - 分治算法是一种将大问题分解成若干个规模较小的相同问题，独立解决后合并解的算法。
  - 分治算法通常包括分解、解决和合并三个步骤。


### 算法编程题库与答案解析

#### 1. 打印从1到最大的n位数

**题目描述**：

输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则依次打印出1、2、3直到最大的3位数999。

**示例**：

输入：n = 3
输出：[1, 2, 3, ..., 999]

**答案解析**：

```python
class Solution:
    def printNumbers(self, n: int) -> List[int]:
        return [i for i in range(1, 10**n)]
```

#### 2. 整数转换中文大写表示

**题目描述**：

将一个整数值转换为中文大写表示。

**示例**：

输入：26354895
输出："二亿六千三百五十四万八千九百五十五"

**答案解析**：

```python
class Solution:
    def intToChinese(self, num: int) -> str:
        units = ["", "一", "二", "三", "四", "五", "六", "七", "八", "九"]
        units2 = ["", "十", "百", "千", "万", "亿"]
        s = []
        if num < 10:
            s.append(units[num])
        else:
            s.append(units[num // 10])
            s.append(units2[num % 10])
            if num // 10 == 0:
                s = s[1:]
        return ''.join(s)
```

#### 3. 剑指 Offer 04. 替换空格

**题目描述**：

请实现一个函数，将一个字符串中的空格替换为%20。示例：

输入："We are happy." 输出："We%20are%20happy."

**答案解析**：

```python
class Solution:
    def replaceSpace(self, s: str) -> str:
        return s.replace(' ', '%20')
```

#### 4. 二维数组中的查找

**题目描述**：

在一个二维数组中（每个数组的行和列都已排序，且每个数组的第一个数大于第二个数，每个数组的最后一个数小于前一个数），给定一个数字，请找出该数字是否在数组中。

**示例**：

输入：matrix = [[1,4,7,11,15], [2,5,8,12,19], [3,6,9,16,22], [10,13,14,17,24], [18,21,23,26,30]], target = 5 输出：true

**答案解析**：

```python
class Solution:
    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:
        if not matrix or not matrix[0]:
            return False
        row, col = len(matrix), len(matrix[0])
        i, j = 0, col - 1
        while i < row and j >= 0:
            if matrix[i][j] == target:
                return True
            elif matrix[i][j] < target:
                i += 1
            else:
                j -= 1
        return False
```

#### 5. 剑指 Offer 27. 二叉树的镜像

**题目描述**：

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

**示例**：

输入：

``` 
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

``` 
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**答案解析**：

```python
class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        if root:
            root.left, root.right = self.mirrorTree(root.right), self.mirrorTree(root.left)
        return root
```

#### 6. 剑指 Offer 28. 对称的二叉树

**题目描述**：

请实现一个函数，用来判断一棵二叉树是不是对称的。

**示例**：

输入：

``` 
     1
   /   \
  2     2
 / \   / \
3   4 4   3
```

输出：true

**答案解析**：

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if root is None:
            return True
        return self.isMirror(root.left, root.right)

    def isMirror(self, left, right):
        if left is None and right is None:
            return True
        if left is None or right is None:
            return False
        if left.val != right.val:
            return False
        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)
```

#### 7. 剑指 Offer 36. 二叉搜索树与双向链表

**题目描述**：

输入一棵二叉搜索树，将该二叉搜索树转换为双向链表。要求不能创建任何新的节点，只能调整树节点中的指针。

**示例**：

输入：

``` 
    4
   / \
  2   5
 / \   \
1   3   6
```

输出：

``` 
    4->2->5->6
         ^     |
         |     v
         1     3
```

**答案解析**：

```python
class Solution:
    def treeToDoublyList(self, root: TreeNode) -> Node:
        if root is None:
            return None
        
        # 中序遍历二叉搜索树
        def inorderTraversal(node):
            if node is None:
                return
            inorderTraversal(node.left)
            if cur:
                cur.right = node
                node.left = cur
            cur = node
            inorderTraversal(node.right)
        
        # 初始化当前节点和链表头节点
        cur = None
        head = None
        
        inorderTraversal(root)
        
        # 将链表首尾相连
        p = cur
        while p.left:
            p = p.left
        p.left = head
        head.right = p
        
        return cur
```

#### 8. 剑指 Offer 35. 复杂链表的复制

**题目描述**：

请实现复制复杂链表的功能。复杂链表结点类表示如下：

```python
class Node:
    def __init__(self, val: int, next: 'Node' = None, random: 'Node' = None):
        self.val = val
        self.next = next
        self.random = random
```

**示例**：

输入：

```python
{ "head": {
     "val": 1,
     "next": {
         "val": 2,
         "next": {
             "val": 3,
             "next": {
                 "val": 4,
                 "next": null,
                 "random": null
             },
             "random": null
         },
         "random": {
             "val": 5,
             "next": null,
             "random": null
         }
     },
     "random": {
         "val": 6,
         "next": null,
         "random": null
     }
 } }
```

输出：

```python
{ "head": {
     "val": 1,
     "next": {
         "val": 2,
         "next": {
             "val": 3,
             "next": {
                 "val": 4,
                 "next": null,
                 "random": null
             },
             "random": {
                 "val": 5,
                 "next": null,
                 "random": null
             }
         },
         "random": {
             "val": 6,
             "next": null,
             "random": null
         }
     },
     "random": {
         "val": 1,
         "next": null,
         "random": {
             "val": 2,
             "next": null,
             "random": null
         }
     }
 } }
```

**答案解析**：

```python
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if not head:
            return None
        
        # 第一步：创建克隆节点，插入到原节点后面
        cur = head
        while cur:
            new_node = Node(cur.val, cur.next, None)
            cur.next = new_node
            cur = new_node.next
        
        # 第二步：设置克隆节点的random指针
        cur = head
        while cur:
            if cur.random:
                cur.next.random = cur.random.next
            cur = cur.next.next
        
        # 第三步：分离原链表和克隆链表
        cur = head
        new_head = head.next
        while cur:
            cur.next = cur.next.next
            cur = cur.next
        if new_head:
            new_head.next = None
        
        return new_head
```

#### 9. 剑指 Offer 39. 数组中出现次数超过一半的数字

**题目描述**：

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

**示例**：

输入：[1, 2, 3, 2, 2, 2, 5, 4] 输出：2

**答案解析**：

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candidate = None
        count = 0
        for num in nums:
            if count == 0:
                candidate = num
            count += (1 if num == candidate else -1)
        return candidate
```

#### 10. 剑指 Offer 52. 两个链表的第一个公共节点

**题目描述**：

给定两个链表，找出它们的第一个公共节点。

**示例**：

输入：headA = [4,1,8,4,5], headB = [5,0,1,8,4,5] 输出：Node 8，该节点值为 8，节点值为 8 的地址为 [xxxx,xxxx]

**答案解析**：

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        pA, pB = headA, headB
        while pA != pB:
            pA = pA.next if pA else headB
            pB = pB.next if pB else headA
        return pA
```

#### 11. 剑指 Offer 53 - I. 整数中一位数的数字之和

**题目描述**：

给定一个非负整数 num，计算并返回其各位数字的累加之和。

**示例**：

输入：num = 342 输出：9（3 + 4 + 2 = 9）

**答案解析**：

```python
class Solution:
    def sumNums(self, num: int) -> int:
        return num if num < 10 else num % 10 + self.sumNums(num // 10)
```

#### 12. 剑指 Offer 54. 二叉搜索树的第k大节点

**题目描述**：

给定一个二叉搜索树的根节点 root 和一个整数 k，请找出该二叉搜索树中第 k 大的节点。

**示例**：

输入：root = [3,1,4,null,2], k = 1 输出：4（4是第1大的节点）

**答案解析**：

```python
class Solution:
    def kthLargest(self, root: TreeNode, k: int) -> int:
        def dfs(root):
            nonlocal k, ans
            if root:
                dfs(root.right)
                k -= 1
                if k == 0:
                    ans = root.val
                dfs(root.left)
        
        ans = None
        dfs(root)
        return ans
```

#### 13. 剑指 Offer 55 - II. 平衡二叉树

**题目描述**：

给定一个二叉树 root，判断它是否是平衡的二叉树。

**示例**：

输入：root = [3,9,20,null,null,15,7] 输出：true

**答案解析**：

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def dfs(root):
            if root is None:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            if abs(left - right) > 1:
                return -1
            return max(left, right) + 1
        
        return dfs(root) >= 0
```

#### 14. 剑指 Offer 55 - III. 最深叶子节点的和

**题目描述**：

给定一个二叉树的根节点 root，返回其最深（即最低）普遍子节点的和。

**示例**：

输入：root = [1,7,0,7,-8,null,null] 输出：-8（-8是最深叶子节点，值为-8）

**答案解析**：

```python
class Solution:
    def deepestLeavesSum(self, root: TreeNode) -> int:
        def dfs(root, depth):
            nonlocal ans
            if root:
                dfs(root.left, depth + 1)
                dfs(root.right, depth + 1)
                if depth == max_depth:
                    ans += root.val
        
        ans, max_depth = 0, 0
        dfs(root, 0)
        return ans
```

#### 15. 剑指 Offer 56 - I. 数组中数字出现的次数

**题目描述**：

一个整数数组 nums，其中 exactly two elements appear exactly two times and all the other elements appear exactly once。请找到所有出现两次的元素和所有只出现一次的元素。你可以按任意顺序返回答案。

**示例**：

输入：nums = [9,1,7,9,7,9,7] 输出：[9,7], [1]

**答案解析**：

```python
class Solution:
    def singleEvenNumber(self, nums: List[int]) -> List[int]:
        ans = [0, 0, 0]
        for num in nums:
            ans[0] ^= num
        for num in nums:
            ans[num & 1] ^= num
        return [ans[1], ans[2]]
```

#### 16. 剑指 Offer 57. 和为s的连续正数序列

**题目描述**：

输入一个正数数组，找出和为s的连续正数序列。要求从最小的序列开始输出，最大的序列最后输出。如果不存在，则输出空序列。

**示例**：

输入：[1, 2, 3, 4] 输出：[[1, 2, 3, 4]]

**答案解析**：

```python
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        ans = []
        low, high = 1, target
        while low < high:
            sum = (low + high) * (high - low + 1) // 2
            if sum == target:
                ans.append(list(range(low, high + 1)))
                low += 1
            elif sum < target:
                low += 1
            else:
                high -= 1
        return ans
```

#### 17. 剑指 Offer 60. n个节点中有几个节点

**题目描述**：

给定一个有n个节点的树，其中节点编号为0~n-1，所有节点都满足parent[i] != i。请你计算有多少个节点，其父节点数量超过树的平均父节点数量。

**示例**：

输入：nodes = [2,2,3,-1] 输出：3（节点0、节点1和节点3的父节点数量超过平均数）

**答案解析**：

```python
class Solution:
    def checkPARENTS(self, n: int, parent: List[int]) -> int:
        avg = sum(parent) / n
        return sum(1 for p in parent if p > avg)
```

#### 18. 剑指 Offer 61. 和为s的连续正数序列（两个集合）

**题目描述**：

输入一个正数数组，找出所有和为s的连续正数序列。要求从小的开始输出，如果不存在，则输出空序列。

**示例**：

输入：[1, 2, 3, 4] 输出：[[1, 2, 3], [1, 3, 4], [2, 3, 4]]

**答案解析**：

```python
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        ans = []
        low, high = 1, target
        while low < high:
            sum = (low + high) * (high - low + 1) // 2
            if sum == target:
                ans.append(list(range(low, high + 1)))
                low += 1
            elif sum < target:
                low += 1
            else:
                high -= 1
        return ans
```

#### 19. 剑指 Offer 67. 把字符串转换成整数

**题目描述**：

编写一个函数 StrToInt，实现基本数据类型 string 到整数类型的转换，不能使用字符串转换为整数相关的库函数。

**示例**：

输入："123" 输出：123

**答案解析**：

```python
class Solution:
    def strToInt(self, strval: str) -> int:
        if not strval:
            return 0
        sign = -1 if strval[0] == '-' else 1
        i = 0
        if strval[0] == '+' or strval[0] == '-':
            i += 1
        num = 0
        for c in strval[i:]:
            if c not in '0123456789':
                break
            num = num * 10 + ord(c) - ord('0')
        return sign * num
```

#### 20. 剑指 Offer 68 - I. 二叉搜索树的第一个错误节点

**题目描述**：

给定一个二叉搜索树 root，请你找出该树中两个错误节点的值。错节点是一个叶子节点，其树中的每一个节点都有一个值。这两个值的和等于给定的错误值 errorSum。

**示例**：

输入：root = [6,3,4,-1,8,7], errorSum = 11 输出：[3, -1]

**答案解析**：

```python
class Solution:
    def findErrorNums(self, root: TreeNode, errorSum: int) -> List[int]:
        def dfs(root):
            if root:
                nonlocal miss, extra
                dfs(root.left)
                if root.val != sum:
                    miss = root.val
                sum += root.val
                if sum - root.val != sum - extra:
                    extra = root.val
                dfs(root.right)
        
        sum = 0
        miss = extra = -1
        dfs(root)
        return [extra, miss]
```

