                 

### 《2025年京东校招算法面试题库及答案》博客

#### 简介

随着科技的发展，算法已成为计算机科学的核心领域之一。各大互联网公司对算法工程师的需求日益增加，特别是头部一线大厂，如京东。本文将详细介绍2025年京东校招算法面试题库及答案，帮助您更好地应对面试挑战。

#### 面试题库

##### 1. 数据结构与算法

**题目：** 请实现一个堆排序算法。

**答案：** 

堆排序算法的基本思想是：将待排序的序列构造成一个大根堆（或小根堆），然后逐步减小堆顶元素，使其从最高位开始排序。以下是堆排序算法的 Python 实现：

```python
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2
 
    if l < n and arr[i] < arr[l]:
        largest = l
 
    if r < n and arr[largest] < arr[r]:
        largest = r
 
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
 
def heap_sort(arr):
    n = len(arr)
 
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)
 
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
 
arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("Sorted array is:", arr)
```

**解析：** 

堆排序算法的时间复杂度为 O(nlogn)，适用于大规模数据的排序。

##### 2. 算法设计与分析

**题目：** 请实现一个广度优先搜索（BFS）算法，用于求解二叉树的最短路径问题。

**答案：**

```python
from collections import deque

def breadth_first_search(root, target):
    if root is None:
        return None
 
    queue = deque([root])
    visited = set()
 
    while queue:
        node = queue.popleft()
        visited.add(node.val)
 
        if node.val == target:
            return node
 
        for neighbor in node.neighbors:
            if neighbor not in visited:
                queue.append(neighbor)
 
    return None
```

**解析：**

广度优先搜索算法可以找到二叉树的最短路径，时间复杂度为 O(n)，空间复杂度为 O(n)。

##### 3. 数学与逻辑

**题目：** 请实现一个函数，判断一个整数是否是回文数。

**答案：**

```python
def is_palindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    
    reversed_num = 0
    while x > reversed_num:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
        
    return x == reversed_num or x == reversed_num // 10
```

**解析：**

回文数的判断需要考虑整数的负数情况，以及整数的个位数是否为零。通过不断反转整数并比较原整数和反转后的整数，可以判断一个整数是否是回文数。

##### 4. 字符串处理

**题目：** 请实现一个函数，找出最长的公共前缀。

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    
    return prefix
```

**解析：**

最长的公共前缀可以通过遍历字符串数组中的每个字符串，比较前缀的长度，逐渐缩短前缀，直到找到最长的公共前缀。

##### 5. 图算法

**题目：** 请实现一个深度优先搜索（DFS）算法，用于求解图的连通分量。

**答案：**

```python
def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

def find_connected_components(graph):
    visited = set()
    components = []
 
    for node in graph:
        if node not in visited:
            component = set()
            dfs(graph, node, component)
            components.append(component)
 
    return components
```

**解析：**

深度优先搜索可以用于求解图的连通分量，通过递归遍历图中的节点，将连通分量存储在集合中。

#### 算法编程题库

##### 1. 最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]
 
    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
 
    return dp[m][n]
```

**解析：**

最长公共子序列问题可以使用动态规划求解，时间复杂度为 O(mn)，空间复杂度为 O(mn)。

##### 2. 单源最短路径

**题目：** 请使用 Dijkstra 算法求解单源最短路径。

**答案：**

```python
import heapq

def dijkstra(graph, start):
    m = len(graph)
    dist = [float('inf')] * m
    dist[start] = 0
    priority_queue = [(0, start)]
 
    while priority_queue:
        current_dist, current_vertex = heapq.heappop(priority_queue)
 
        if current_dist > dist[current_vertex]:
            continue
 
        for neighbor, weight in graph[current_vertex].items():
            distance = current_dist + weight
            if distance < dist[neighbor]:
                dist[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
 
    return dist
```

**解析：**

Dijkstra 算法用于求解单源最短路径问题，时间复杂度为 O((V+E)logV)，其中 V 是顶点数，E 是边数。

##### 3. 最长连续序列

**题目：** 给定一个未排序的整数数组，找到最长的连续序列的长度。

**答案：**

```python
def longest_consecutive_sequence(nums):
    if not nums:
        return 0
    
    nums_set = set(nums)
    max_length = 0
    
    for num in nums:
        if num - 1 not in nums_set:
            current_length = 1
            while num + 1 in nums_set:
                num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    
    return max_length
```

**解析：**

通过遍历数组，判断当前数字的前一个数字是否在数组中，如果在，则继续判断下一个数字是否在数组中，直到找到一个不在数组中的数字，此时计算连续序列的长度，并更新最大长度。

##### 4. 染色体分组

**题目：** 给定一个染色体序列，将其分成若干组，使得每组内任意两个染色体的交叉概率都相等。

**答案：**

```python
def chromosome_grouping(chromosomes):
    if not chromosomes:
        return []
    
    groups = []
    for i, c1 in enumerate(chromosomes):
        current_group = [c1]
        for j, c2 in enumerate(chromosomes[i+1:], start=i+1):
            if is_compatible(c1, c2):
                current_group.append(c2)
        groups.append(current_group)
    
    return groups

def is_compatible(c1, c2):
    # 判断 c1 和 c2 是否兼容
    return True  # 这里需要实现兼容性判断逻辑
```

**解析：**

通过遍历染色体序列，将每个染色体与其后的染色体进行兼容性判断，如果兼容则将两个染色体放入同一组。遍历结束后，返回所有分组。

#### 答案解析说明与源代码实例

本文针对京东校招算法面试题库及答案，提供了详细的解析说明和源代码实例。通过这些示例，您可以更好地理解各个问题的解题思路和实现方法。在实际面试中，熟悉这些算法和数据结构的基本原理，对于应对各种复杂问题具有重要意义。

#### 总结

算法面试在技术面试中占据重要地位，掌握常见的算法和数据结构，能够帮助您在面试中脱颖而出。本文提供了京东校招算法面试题库及答案，希望对您的面试准备有所帮助。在面试过程中，注意理解问题背后的原理，灵活运用所学知识，相信您一定能取得优异的成绩。祝您面试顺利！<|vq_11816|>### 6. 动态规划

**题目：** 请实现一个函数，计算斐波那契数列的第 n 项。

**答案：**

```python
def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]
```

**解析：**

斐波那契数列可以通过动态规划求解，时间复杂度为 O(n)，空间复杂度为 O(n)。动态规划的核心思想是：将大问题分解为小问题，并存储已解决的小问题的解，避免重复计算。

**进阶：** 可以使用常量空间优化动态规划，将空间复杂度降低至 O(1)：

```python
def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    
    prev, curr = 0, 1
    
    for _ in range(2, n + 1):
        prev, curr = curr, prev + curr
    
    return curr
```

### 7. 字符串匹配算法

**题目：** 请实现一个函数，使用 KMP 算法进行字符串匹配。

**答案：**

```python
def compute_lps_array(pattern):
    lps = [0] * len(pattern)
    length = 0
    i = 1

    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1

    return lps

def kmp_search(text, pattern):
    lps = compute_lps_array(pattern)
    i = j = 0

    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1

        if j == len(pattern):
            return i - j  # 匹配成功，返回匹配起点

        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return -1  # 匹配失败
```

**解析：**

KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法，时间复杂度为 O(n + m)，其中 n 是文本长度，m 是模式长度。KMP 算法的核心思想是：避免重复比较已匹配的部分，通过计算最长公共前后缀（LPS）数组来实现。

### 8. 树与图

**题目：** 请实现一个二叉搜索树（BST）的插入、删除和查找功能。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        self.root = self._insert(self.root, val)

    def _insert(self, node, val):
        if node is None:
            return TreeNode(val)

        if val < node.val:
            node.left = self._insert(node.left, val)
        elif val > node.val:
            node.right = self._insert(node.right, val)

        return node

    def delete(self, val):
        self.root = self._delete(self.root, val)

    def _delete(self, node, val):
        if node is None:
            return node

        if val < node.val:
            node.left = self._delete(node.left, val)
        elif val > node.val:
            node.right = self._delete(node.right, val)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                min_larger = self._find_min(node.right)
                node.val = min_larger.val
                node.right = self._delete(node.right, min_larger.val)

        return node

    def find(self, val):
        return self._find(self.root, val)

    def _find(self, node, val):
        if node is None:
            return False

        if val == node.val:
            return True
        elif val < node.val:
            return self._find(node.left, val)
        else:
            return self._find(node.right, val)

    def _find_min(self, node):
        while node.left is not None:
            node = node.left
        return node
```

**解析：**

二叉搜索树（BST）是一种特殊的二叉树，左子树的所有值小于根节点的值，右子树的所有值大于根节点的值。BST 提供了高效的插入、删除和查找操作，时间复杂度为 O(logn)，其中 n 是树中节点的数量。

### 9. 并查集

**题目：** 请实现一个并查集（Union-Find）算法，用于求解连通分量问题。

**答案：**

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)

        if rootP != rootQ:
            if self.size[rootP] < self.size[rootQ]:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]
            else:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
```

**解析：**

并查集（Union-Find）算法用于求解连通分量问题，时间复杂度为 O(logn)，其中 n 是元素的数量。并查集主要包含两个操作：查找（find）和合并（union）。通过路径压缩（path compression）和按秩合并（union by rank），可以提高算法的效率。

### 10. 贪心算法

**题目：** 请实现一个函数，使用贪心算法求解背包问题。

**答案：**

```python
def knapsack(values, weights, capacity):
    n = len(values)
    items = sorted(zip(values, weights), key=lambda x: x[0] / x[1], reverse=True)

    total_value, total_weight = 0, 0

    for value, weight in items:
        if total_weight + weight <= capacity:
            total_value += value
            total_weight += weight
        else:
            fraction = (capacity - total_weight) / weight
            total_value += value * fraction
            break

    return total_value
```

**解析：**

背包问题是一个经典的贪心算法问题。通过将物品按价值与重量的比例降序排序，并依次选取物品，直到背包容量用完或没有合适的物品为止，可以得到最大价值。

### 11. 回溯算法

**题目：** 请实现一个函数，使用回溯算法求解全排列问题。

**答案：**

```python
def permute(nums):
    def backtrack(start):
        if start == len(nums) - 1:
            result.append(nums[:])
            return
        
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    result = []
    backtrack(0)
    return result
```

**解析：**

回溯算法通过递归尝试所有可能的组合，找到所有满足条件的解。在求解全排列问题时，每次从当前位置开始交换元素，递归遍历剩余元素，直到到达最后一个元素。

### 12. 贪心算法（活动选择问题）

**题目：** 请实现一个函数，使用贪心算法求解活动选择问题。

**答案：**

```python
def activity_selection(activities):
    n = len(activities)
    if n <= 1:
        return n

    activities.sort(key=lambda x: x[1])

    count = 1
    last_end = activities[0][1]

    for i in range(1, n):
        if activities[i][0] >= last_end:
            count += 1
            last_end = activities[i][1]

    return count
```

**解析：**

活动选择问题是一个经典的贪心算法问题。通过将活动按结束时间排序，并依次选取下一个开始时间早于或等于上一个活动结束时间的活动，可以得到最多的活动数量。

### 13. 背包问题（01背包）

**题目：** 请实现一个函数，使用动态规划求解 01 背包问题。

**答案：**

```python
def knapsack01(values, weights, capacity):
    n = len(values)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i - 1] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]

    return dp[n][capacity]
```

**解析：**

01 背包问题是一个经典的动态规划问题。通过构建一个二维数组 dp，其中 dp[i][w] 表示前 i 个物品放入容量为 w 的背包中的最大价值，可以得到最优解。

### 14. 二分查找

**题目：** 请实现一个函数，使用二分查找算法在有序数组中查找目标值。

**答案：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1
```

**解析：**

二分查找算法通过不断缩小查找范围，逐步逼近目标值。时间复杂度为 O(logn)，适用于有序数组。

### 15. 前缀和

**题目：** 请实现一个函数，使用前缀和算法求解连续子数组的和。

**答案：**

```python
def prefix_sum(arr):
    n = len(arr)
    presum = [0] * (n + 1)

    for i in range(1, n + 1):
        presum[i] = presum[i - 1] + arr[i - 1]

    return presum
```

**解析：**

前缀和算法通过计算每个位置的前缀和，可以快速求解连续子数组的和。时间复杂度为 O(n)，适用于求数组的连续子数组和。

### 16. 快速排序

**题目：** 请实现一个函数，使用快速排序算法对数组进行排序。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)
```

**解析：**

快速排序算法通过选择一个基准元素，将数组划分为小于基准元素和大于基准元素的两部分，递归地对两部分进行排序，最终得到有序数组。时间复杂度为 O(nlogn)，适用于大规模数组的排序。

### 17. 合并两个有序数组

**题目：** 请实现一个函数，将两个有序数组合并为一个有序数组。

**答案：**

```python
def merge_sorted_arrays(arr1, arr2):
    n1, n2 = len(arr1), len(arr2)
    merged = [0] * (n1 + n2)

    i, j, k = 0, 0, 0

    while i < n1 and j < n2:
        if arr1[i] < arr2[j]:
            merged[k] = arr1[i]
            i += 1
        else:
            merged[k] = arr2[j]
            j += 1
        k += 1

    while i < n1:
        merged[k] = arr1[i]
        i += 1
        k += 1

    while j < n2:
        merged[k] = arr2[j]
        j += 1
        k += 1

    return merged
```

**解析：**

合并两个有序数组可以通过遍历两个数组，将较小的元素依次放入新的数组中，直到其中一个数组结束。时间复杂度为 O(m + n)，其中 m 和 n 分别是两个数组的长度。

### 18. 哈希表

**题目：** 请实现一个函数，使用哈希表求解两个数组的交集。

**答案：**

```python
def intersection(nums1, nums2):
    nums1_set = set(nums1)
    intersection = []

    for num in nums2:
        if num in nums1_set:
            intersection.append(num)

    return intersection
```

**解析：**

哈希表可以快速查找元素是否存在。通过将一个数组转换为哈希表，遍历另一个数组，判断元素是否在哈希表中，可以求解两个数组的交集。时间复杂度为 O(m + n)，其中 m 和 n 分别是两个数组的长度。

### 19. 优先队列

**题目：** 请实现一个函数，使用优先队列求解最接近目标的数。

**答案：**

```python
import heapq

def findClosestNumber(nums, target):
    nums = sorted(nums)
    result = nums[0]
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if abs(nums[mid] - target) < abs(result - target):
            result = nums[mid]
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result
```

**解析：**

优先队列可以用来快速找到最接近目标值的元素。通过二分查找和优先队列相结合，可以求解最接近目标的数。时间复杂度为 O(logn)，其中 n 是数组长度。

### 20. 数学问题

**题目：** 请实现一个函数，判断一个整数是否是素数。

**答案：**

```python
def is_prime(n):
    if n <= 1:
        return False

    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False

    return True
```

**解析：**

判断一个整数是否是素数可以通过遍历 2 到该数的平方根，判断是否存在能整除它的数。时间复杂度为 O(sqrt(n))，适用于判断较小整数的素性。

### 21. 双指针

**题目：** 请实现一个函数，使用双指针求解两个有序数组的交集。

**答案：**

```python
def intersect(nums1, nums2):
    i, j = 0, 0
    result = []

    while i < len(nums1) and j < len(nums2):
        if nums1[i] == nums2[j]:
            result.append(nums1[i])
            i += 1
            j += 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1

    return result
```

**解析：**

双指针算法可以通过遍历两个有序数组，比较当前指针指向的元素，移动较小的元素的指针，直到找到交集。时间复杂度为 O(m + n)，其中 m 和 n 分别是两个数组的长度。

### 22. 滑动窗口

**题目：** 请实现一个函数，使用滑动窗口求解最大子序列和。

**答案：**

```python
def max_subarray_sum(nums, k):
    max_sum = current_sum = sum(nums[:k])
    n = len(nums)

    for i in range(k, n):
        current_sum += nums[i] - nums[i - k]
        max_sum = max(max_sum, current_sum)

    return max_sum
```

**解析：**

滑动窗口算法可以通过维护一个固定大小的窗口，计算窗口内元素的和，并不断滑动窗口，更新最大和。时间复杂度为 O(n)，其中 n 是数组的长度。

### 23. 递归

**题目：** 请实现一个函数，使用递归求解汉诺塔问题。

**答案：**

```python
def hanoi(n, from_peg, to_peg, aux_peg):
    if n == 1:
        print(f"Move disk 1 from peg {from_peg} to peg {to_peg}")
        return

    hanoi(n - 1, from_peg, aux_peg, to_peg)
    print(f"Move disk {n} from peg {from_peg} to peg {to_peg}")
    hanoi(n - 1, aux_peg, to_peg, from_peg)
```

**解析：**

递归算法可以通过分治思想，将大问题分解为小问题，逐步解决。汉诺塔问题可以通过递归实现，时间复杂度为 O(2^n)，其中 n 是盘数。

### 24. 位操作

**题目：** 请实现一个函数，使用位操作求解两个整数的最大公约数。

**答案：**

```python
def gcd(x, y):
    while y:
        x, y = y, x % y
    return x
```

**解析：**

位操作可以通过移位和取余操作，实现辗转相除法求解最大公约数。时间复杂度为 O(logmax(x, y))，其中 x 和 y 是两个整数。

### 25. 排序算法

**题目：** 请实现一个函数，使用冒泡排序算法对数组进行排序。

**答案：**

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

**解析：**

冒泡排序算法通过不断比较相邻元素，将较大的元素移动到数组的末尾，逐步实现排序。时间复杂度为 O(n^2)，适用于小规模数据的排序。

### 26. 并发编程

**题目：** 请实现一个函数，使用协程和线程并行计算两个数组的和。

**答案：**

```python
import asyncio
import threading

async def compute_sum(nums1, nums2):
    return sum(nums1) + sum(nums2)

def run_coroutines(nums1, nums2):
    loop = asyncio.get_event_loop()
    result = loop.run_until_complete(compute_sum(nums1, nums2))
    loop.close()
    return result

def run_threads(nums1, nums2):
    def compute_sum_thread(nums1, nums2):
        return sum(nums1) + sum(nums2)

    thread = threading.Thread(target=compute_sum_thread, args=(nums1, nums2))
    thread.start()
    thread.join()
    return thread.result
```

**解析：**

并发编程可以通过协程和线程实现并行计算。协程可以通过 asyncio 模块实现，线程可以通过 threading 模块实现。协程适用于 I/O 密集型任务，线程适用于计算密集型任务。

### 27. 数学问题

**题目：** 请实现一个函数，求解斐波那契数列的第 n 项。

**答案：**

```python
def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    
    return b
```

**解析：**

斐波那契数列可以通过递归或动态规划求解。递归的时间复杂度为 O(2^n)，动态规划的时间复杂度为 O(n)。动态规划可以通过将前两个数相加得到下一个数，逐步计算斐波那契数列。

### 28. 字符串处理

**题目：** 请实现一个函数，求解两个字符串的编辑距离。

**答案：**

```python
def edit_distance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])

    return dp[m][n]
```

**解析：**

编辑距离可以通过动态规划求解。动态规划的核心思想是：将问题分解为较小的子问题，并利用子问题的解来求解原问题。时间复杂度为 O(mn)，其中 m 和 n 分别是两个字符串的长度。

### 29. 图算法

**题目：** 请实现一个函数，求解图的最短路径。

**答案：**

```python
import heapq

def dijkstra(graph, start):
    n = len(graph)
    dist = [float('inf')] * n
    dist[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_dist, current_vertex = heapq.heappop(priority_queue)

        if current_dist > dist[current_vertex]:
            continue

        for neighbor, weight in graph[current_vertex].items():
            distance = current_dist + weight
            if distance < dist[neighbor]:
                dist[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return dist
```

**解析：**

Dijkstra 算法是一种经典的单源最短路径算法。算法通过维护一个优先队列，每次选择当前距离最小的节点，更新其邻居节点的距离。时间复杂度为 O((V+E)logV)，其中 V 是顶点数，E 是边数。

### 30. 网络问题

**题目：** 请实现一个函数，判断网络是否连通。

**答案：**

```python
from collections import defaultdict

def is_connected(graph):
    visited = set()

    def dfs(node):
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                dfs(neighbor)

    dfs(list(graph.keys())[0])

    return len(visited) == len(graph)
```

**解析：**

判断网络是否连通可以通过深度优先搜索（DFS）或广度优先搜索（BFS）实现。算法从任意节点开始，遍历所有可达节点，如果遍历到的节点数量等于图的节点数量，则网络是连通的。时间复杂度为 O(V+E)，其中 V 是顶点数，E 是边数。

