                 

### 小米2025届校招算法工程师面试真题解密

#### 1. 二分查找算法实现

**题目：** 实现一个二分查找算法，查找一个给定整数数组中的特定值。

**代码示例：**

```go
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    
    for left <= right {
        mid := left + (right - left) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    
    return -1
}
```

**答案解析：**

该函数通过二分查找算法在给定的整数数组 `arr` 中查找目标值 `target`。算法的核心思想是通过不断缩小查找范围，直到找到目标值或确定目标值不存在。

- 初始化 `left` 和 `right` 指针，分别指向数组的第一个和最后一个元素。
- 在循环中，计算中间位置 `mid`，并与目标值进行比较。
- 根据比较结果，调整 `left` 或 `right` 指针，继续缩小查找范围。
- 如果找到目标值，返回其索引；否则返回 `-1`。

#### 2. 判断字符串是否为回文

**题目：** 实现一个函数，判断一个给定的字符串是否为回文。

**代码示例：**

```go
func isPalindrome(s string) bool {
    chars := []rune(s)
    left, right := 0, len(chars)-1
    
    for left < right {
        if chars[left] != chars[right] {
            return false
        }
        left++
        right--
    }
    
    return true
}
```

**答案解析：**

该函数通过比较字符串两端的字符，判断字符串是否为回文。回文是指从前往后和从后往前读都相同的字符串。

- 将字符串转换为字符数组 `chars`。
- 初始化 `left` 和 `right` 指针，分别指向字符串的第一个和最后一个字符。
- 在循环中，比较 `left` 和 `right` 指针指向的字符，如果相同，继续移动指针；如果不同，返回 `false`。
- 如果循环结束时，没有发现不相等的字符，返回 `true`。

#### 3. 最长公共前缀

**题目：** 找出给定字符串数组中的最长公共前缀。

**代码示例：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    
    return prefix
}
```

**答案解析：**

该函数通过比较字符串数组中的前缀，找出最长公共前缀。算法的核心思想是从第一个字符串开始，逐步缩小公共前缀的长度。

- 初始化 `prefix` 为第一个字符串。
- 对于数组中的每个字符串，从前往后比较字符，一旦发现不相等的字符，就缩小 `prefix` 的长度。
- 循环结束后，`prefix` 就是数组中的最长公共前缀。

#### 4. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 `n` 阶才能到达楼顶，每次你可以爬 1 或 2 个台阶。请计算有多少种不同的方法可以爬到楼顶。

**代码示例：**

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    
    dp := make([]int, n)
    dp[0], dp[1] = 1, 2
    
    for i := 2; i < n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    return dp[n-1]
}
```

**答案解析：**

该函数使用动态规划算法计算爬楼梯的不同方法数。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化 `dp` 数组，其中 `dp[0]` 和 `dp[1]` 分别表示爬 1 阶和 2 阶的方法数。
- 对于每个 `i`（`i > 1`），计算 `dp[i]` 的值为 `dp[i-1] + dp[i-2]`。
- 循环结束后，`dp[n-1]` 就是爬到楼顶的方法数。

#### 5. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。技术规范要求链表中的节点应该按照升序排列。

**代码示例：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}
```

**答案解析：**

该函数通过迭代方式合并两个有序链表。算法的核心思想是遍历两个链表，每次比较两个链表当前节点的值，选择较小的值作为下一个节点。

- 创建一个哑节点 `dummy` 作为合并链表的头节点。
- 初始化 `curr` 指向哑节点。
- 在循环中，比较 `l1` 和 `l2` 的当前节点值，选择较小的值作为 `curr` 的下一个节点，并移动相应的链表指针。
- 循环结束后，将剩余的链表连接到合并链表的末尾。
- 返回合并链表的头节点，即 `dummy.Next`。

#### 6. 有效的括号

**题目：** 给定一个包含 `'('`、`')'`、`'{'`、`'}'`、`'['` 和 `']'` 的字符串，判断字符串是否有效。

**代码示例：**

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{'(': ')', '{': '}', '[': ']'}
    
    for _, c := range s {
        if _, ok := pairs[c]; ok {
            stack = append(stack, c)
        } else if len(stack) == 0 || pairs[stack[len(stack)-1]] != c {
            return false
        } else {
            stack = stack[:len(stack)-1]
        }
    }
    
    return len(stack) == 0
}
```

**答案解析：**

该函数使用栈实现有效的括号判断。算法的核心思想是将遇到的开括号压入栈，遇到闭括号时，判断其对应的开括号是否在栈顶。

- 初始化一个空栈 `stack` 和一个括号配对表 `pairs`。
- 遍历字符串 `s` 中的每个字符：
  - 如果字符是开括号，将其压入栈。
  - 如果字符是闭括号：
    - 如果栈为空，或栈顶元素不是对应的开括号，返回 `false`。
    - 如果栈顶元素是开括号，将其弹出栈。
- 遍历结束后，如果栈为空，则字符串有效；否则无效。

#### 7. 有效的数字

**题目：** 给定一个字符串，判断是否是有效的数字。

**代码示例：**

```go
func isNumber(s string) bool {
    // 判断字符串是否为空
    if s == "" {
        return false
    }

    // 判断字符串是否只包含空格
    if s == " " {
        return false
    }

    // 判断字符串是否包含数字
    hasDigit := false

    for _, c := range s {
        if c >= '0' && c <= '9' {
            hasDigit = true
        }
    }

    if !hasDigit {
        return false
    }

    // 判断字符串是否包含非法字符
    illegalChars := []rune{'e', 'E', '+', '-', '.'}

    for _, c := range s {
        if (c >= '0' && c <= '9') || c == '+' || c == '-' || c == '.' {
            continue
        } else if c == ' ' {
            if strings.ContainsRune(s[:len(s)-1], '.') {
                return false
            }
            if strings.ContainsRune(s[:len(s)-1], 'e') || strings.ContainsRune(s[:len(s)-1], 'E') {
                return false
            }
        } else if c == '.' {
            if strings.ContainsRune(s[:len(s)-1], '.') || strings.ContainsRune(s[:len(s)-1], 'e') || strings.ContainsRune(s[:len(s)-1], 'E') {
                return false
            }
        } else if c == 'e' || c == 'E' {
            if strings.ContainsRune(s[:len(s)-1], 'e') || strings.ContainsRune(s[:len(s)-1], 'E') || strings.ContainsRune(s[:len(s)-1], '.') {
                return false
            }
        } else {
            return false
        }
    }

    // 判断字符串是否包含有效的指数部分
    hasExponent := false

    for i := 0; i < len(s)-1; i++ {
        if s[i] == 'e' || s[i] == 'E' {
            hasExponent = true
            if s[i+1] < '0' || s[i+1] > '9' {
                return false
            }
        }
    }

    if !hasExponent {
        return true
    }

    // 判断字符串是否包含有效的整数部分和小数部分
    hasDecimal := false

    for i := 0; i < len(s)-1; i++ {
        if s[i] == '+' || s[i] == '-' {
            if s[i+1] == 'e' || s[i+1] == 'E' {
                return false
            }
        } else if s[i] == '.' {
            hasDecimal = true
            if s[i+1] == 'e' || s[i+1] == 'E' {
                return false
            }
        }
    }

    return true
}
```

**答案解析：**

该函数通过判断字符串是否包含数字、非法字符以及有效的整数部分和小数部分，来判断字符串是否为有效的数字。算法的核心思想是遍历字符串，检查每个字符是否符合数字的规则。

- 判断字符串是否为空或只包含空格，如果是，返回 `false`。
- 判断字符串是否包含数字，如果不存在数字，返回 `false`。
- 判断字符串是否包含非法字符（除了数字、加号、减号和小数点之外的字符），如果存在，返回 `false`。
- 判断字符串是否包含有效的指数部分，如果存在指数部分，且指数部分不符合规则（如 `e+` 或 `e-`），返回 `false`。
- 判断字符串是否包含有效的整数部分和小数部分，如果不存在整数部分或小数部分不符合规则（如 `+e` 或 `-e`），返回 `false`。
- 如果以上条件都满足，返回 `true`。

#### 8. 字符串转换整数 (atoi)

**题目：** 实现一个函数，将字符串转换成整数。函数应返回一个整数，表示字符串表示的整数的值。如果字符串不是有效的整数表示，则返回 0。

**代码示例：**

```go
func myAtoi(s string) int {
    const (
        INT_MAX = 1 << 31 - 1
        INT_MIN = -1 << 31
    )

    sign := 1
    i := 0
    ans := 0

    // 跳过前面的空格
    for i < len(s) && s[i] == ' ' {
        i++
    }

    // 判断符号
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        if s[i] == '-' {
            sign = -1
        }
        i++
    }

    // 检查数字部分
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        if ans > (INT_MAX - int(s[i]-'0'))/10 {
            return INT_MAX
        }
        if ans < (INT_MIN + int(s[i]-'0'))/10 && sign == -1 {
            return INT_MIN
        }
        ans = ans*10 + int(s[i]-'0')
        i++
    }

    // 应用符号
    return ans * sign
}
```

**答案解析：**

该函数通过扫描字符串，处理符号、跳过空格，并检查数字的有效性，实现字符串到整数的转换。算法的核心思想是处理字符串中的每个字符，并维护当前的数字值。

- 初始化 `sign` 为 1，表示正数。
- 初始化 `i` 和 `ans`，`i` 表示当前扫描的索引，`ans` 表示当前的数字值。
- 跳过字符串开头的空格。
- 判断字符串的第一个字符是否为符号（`+` 或 `-`），并设置 `sign`。
- 检查字符串的每个字符是否为数字，并计算 `ans`。
- 如果在计算过程中，`ans` 超出整数的范围，则返回 `INT_MAX` 或 `INT_MIN`。
- 返回 `ans` 乘以 `sign`。

#### 9. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**代码示例：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return []int{-1, -1}
}
```

**答案解析：**

该函数使用哈希表实现两数之和问题。算法的核心思想是在遍历数组的过程中，使用哈希表存储已遍历的数字及其索引，并查找与当前数字相加等于目标值的数字。

- 初始化一个哈希表 `m`。
- 遍历数组 `nums`，计算当前数字的补数 `complement`。
- 如果补数在哈希表中，返回当前数字的索引和补数的索引。
- 如果不在哈希表中，将当前数字及其索引存入哈希表。
- 如果遍历结束仍未找到结果，返回 `[-1, -1]`。

#### 10. 搜索旋转排序数组

**题目：** 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 的某个旋转调 整（例如，原数组 `0,1,2,4,5,6,7` 可能变为 `4,5,6,7,0,1,2`）。

请找出并返回数组中的旋转下标 `k`。`k` 的值是固定的，`0 ≤ k ≤ n-1`。你可以假设数组总是存在有效的 k。

**代码示例：**

```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n - 1

    for left <= right {
        mid := left + (right - left) / 2

        if nums[mid] == target {
            return mid
        }

        // 左侧升序
        if nums[left] < nums[mid] {
            // 目标在左侧升序部分
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            // 右侧升序
            if nums[mid] <= target && target < nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }

    return -1
}
```

**答案解析：**

该函数使用二分查找算法在旋转排序的数组中查找目标值。算法的核心思想是确定数组旋转的位置，并选择正确的半区进行二分查找。

- 初始化 `left` 和 `right` 指针，分别指向数组的第一个和最后一个元素。
- 在循环中，计算中间位置 `mid`，并与目标值进行比较。
- 如果 `nums[mid]` 等于目标值，返回 `mid`。
- 如果左侧升序，判断目标值是否在左侧升序部分，如果是，更新 `right` 指针；否则，更新 `left` 指针。
- 如果右侧升序，判断目标值是否在右侧升序部分，如果是，更新 `left` 指针；否则，更新 `right` 指针。
- 如果循环结束仍未找到目标值，返回 `-1`。

#### 11. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找出两个字符串的最长公共子序列。

**代码示例：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**答案解析：**

该函数使用动态规划算法求解最长公共子序列。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。
- 遍历 `text1` 和 `text2` 的每个字符：
  - 如果字符相同，`dp[i][j] = dp[i-1][j-1] + 1`。
  - 如果字符不同，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
- 返回 `dp[m][n]`，即 `text1` 和 `text2` 的最长公共子序列的长度。

#### 12. 最长回文子串

**题目：** 给定一个字符串 `s`，找到其在字符串中的最长回文子串。

**代码示例：**

```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }

    start, maxLen := 0, 1

    for i := 0; i < len(s); i++ {
        // 暴力法查找以s[i]为中心的回文子串
        len1 := expandAroundCenter(s, i, i)
        // 暴力法查找以s[i]和s[i+1]为中心的回文子串
        len2 := expandAroundCenter(s, i, i+1)

        // 取两个结果中的最大值
        len := max(len1, len2)

        if len > maxLen {
            start = i - (len - 1) / 2
            maxLen = len
        }
    }

    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return right - left - 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**答案解析：**

该函数使用暴力法求解最长回文子串。算法的核心思想是通过遍历字符串，以每个字符为中心，向两边扩展，查找回文子串。

- 初始化 `start` 和 `maxLen`，分别表示最长回文子串的起始索引和长度。
- 遍历字符串的每个字符 `i`：
  - 查找以 `i` 为中心（奇数长度回文）的回文子串长度 `len1`。
  - 查找以 `i` 和 `i+1` 为中心（偶数长度回文）的回文子串长度 `len2`。
  - 取两个结果中的最大值，更新 `start` 和 `maxLen`。
- 返回最长回文子串。

#### 13. 粉刷房子 II

**题目：** 在一个由街道组成的网格上，有一些街道被涂上了红色、蓝色和绿色。现在需要尽可能快地粉刷这些街道，使其看起来尽可能一致。每次粉刷需要花费一定的费用，粉刷相邻的街道会更便宜。你需要粉刷所有街道，并且不能粉刷成同一颜色。求粉刷所有街道的最小总费用。

**代码示例：**

```go
func minCostII(costs [][]int, m int, n int) int {
    // dp[i][j] 表示前 i 行中，第 j 列的最小费用
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    // 第一行初始化
    min1, min2 := costs[0][0], costs[0][1]
    for j := 1; j < n; j++ {
        if costs[0][j] < min1 {
            min2 = min1
            min1 = costs[0][j]
        } else if costs[0][j] < min2 {
            min2 = costs[0][j]
        }
        dp[0][j] = dp[0][j-1] + costs[0][j]
    }

    // 后续行更新
    for i := 1; i < m; i++ {
        min1, min2 = costs[i][0], costs[i][1]
        for j := 1; j < n; j++ {
            if costs[i][j] < min1 {
                min2 = min1
                min1 = costs[i][j]
            } else if costs[i][j] < min2 {
                min2 = costs[i][j]
            }
            dp[i][j] = min(dp[i-1][j]+costs[i][j], dp[i-1][j-1]+min1)
        }
    }

    return dp[m-1][n-1]
}
```

**答案解析：**

该函数使用动态规划算法求解粉刷房子 II 问题。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示前 `i` 行中，第 `j` 列的最小费用。
- 第一行初始化：计算第一行中每个列的最小费用，并更新 `dp`。
- 后续行更新：对于每一行，计算当前行中每个列的最小费用，并更新 `dp`。
- 返回 `dp[m-1][n-1]`，即粉刷所有街道的最小总费用。

#### 14. 最长公共子串

**题目：** 给定两个字符串 `text1` 和 `text2`，找出两个字符串的最长公共子串。

**代码示例：**

```go
func longestCommonSubstring(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    maxLen, endIndex := 0, 0

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - 1
                }
            } else {
                dp[i][j] = 0
            }
        }
    }

    return text1[endIndex-maxLen+1 : endIndex+1]
}
```

**答案解析：**

该函数使用动态规划算法求解最长公共子串。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子串的长度。
- 遍历 `text1` 和 `text2` 的每个字符：
  - 如果字符相同，`dp[i][j] = dp[i-1][j-1] + 1`。
  - 如果字符不同，`dp[i][j] = 0`。
- 记录最长公共子串的长度 `maxLen` 和结束索引 `endIndex`。
- 返回最长公共子串。

#### 15. 单调栈

**题目：** 使用单调栈求解下一个更大元素 I。

**代码示例：**

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    result := make([]int, len(nums1), len(nums1))
    for i := 0; i < len(nums2); i++ {
        for len(stack) > 0 && nums2[i] > stack[len(stack)-1] {
            result[stack[len(stack)-1]] = nums2[i]
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, nums2[i])
    }

    for len(stack) > 0 {
        result[stack[len(stack)-1]] = -1
        stack = stack[:len(stack)-1]
    }

    return result
}
```

**答案解析：**

该函数使用单调栈求解下一个更大元素。算法的核心思想是通过遍历 `nums2`，维护一个单调递减的栈，找出每个元素在 `nums2` 中的下一个更大元素。

- 初始化一个空栈 `stack` 和一个结果数组 `result`。
- 遍历 `nums2`，对于每个元素 `nums2[i]`：
  - 如果栈不为空且 `nums2[i]` 大于栈顶元素，则说明 `nums2[i]` 是栈顶元素的下一个更大元素。更新 `result` 并弹出栈顶元素。
  - 将 `nums2[i]` 入栈。
- 遍历结束后，栈中剩余的元素没有下一个更大元素，设为 `-1`。
- 返回 `result`。

#### 16. 单调队列

**题目：** 使用单调队列求解下一个更大元素 II。

**代码示例：**

```go
func nextGreaterElement(nums []int) []int {
    stack := &monotonicQueue{}
    result := make([]int, len(nums), len(nums))

    for _, num := range nums {
        stack.push(num)
    }

    for _, num := range nums {
        for stack.size() > 0 && stack.front() <= num {
            stack.pop()
        }

        if stack.size() > 0 {
            result = append(result, stack.front())
        } else {
            result = append(result, -1)
        }
        stack.push(num)
    }

    return result
}

type monotonicQueue struct {
    data []int
}

func (m *monotonicQueue) push(val int) {
    for len(m.data) > 0 && m.data[len(m.data)-1] <= val {
        m.data = m.data[:len(m.data)-1]
    }
    m.data = append(m.data, val)
}

func (m *monotonicQueue) pop() {
    m.data = m.data[:len(m.data)-1]
}

func (m *monotonicQueue) front() int {
    return m.data[0]
}

func (m *monotonicQueue) size() int {
    return len(m.data)
}
```

**答案解析：**

该函数使用单调队列求解下一个更大元素。算法的核心思想是通过维护一个单调递减的队列，找出每个元素在数组中的下一个更大元素。

- 初始化一个单调队列 `monotonicQueue` 和一个结果数组 `result`。
- 遍历 `nums`，将每个元素入队列。
- 遍历 `nums`，对于每个元素 `num`：
  - 从队列头部开始，依次弹出队列中的元素，直到找到大于 `num` 的元素或队列为空。
  - 如果队列不为空，则当前元素在数组中的下一个更大元素为队列头部元素；否则为 `-1`。
- 将当前元素入队列。
- 返回 `result`。

#### 17. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。技术规范要求链表中的节点应该按照升序排列。

**代码示例：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}
```

**答案解析：**

该函数通过迭代方式合并两个有序链表。算法的核心思想是遍历两个链表，每次比较两个链表当前节点的值，选择较小的值作为下一个节点。

- 创建一个哑节点 `dummy` 作为合并链表的头节点。
- 初始化 `curr` 指向哑节点。
- 在循环中，比较 `l1` 和 `l2` 的当前节点值，选择较小的值作为 `curr` 的下一个节点，并移动相应的链表指针。
- 循环结束后，将剩余的链表连接到合并链表的末尾。
- 返回合并链表的头节点，即 `dummy.Next`。

#### 18. 合并K个升序链表

**题目：** 合并 `k` 个升序链表。技术规范要求合并后的链表应该按照升序排列。

**代码示例：**

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    for len(lists) > 1 {
        temp := []*ListNode{}
        for i := 0; i < len(lists); i += 2 {
            if i+1 < len(lists) {
                lists[i] = mergeTwoLists(lists[i], lists[i+1])
            }
            temp = append(temp, lists[i])
        }
        if len(lists)%2 == 1 {
            temp = append(temp, lists[len(lists)-1])
        }
        lists = temp
    }

    return lists[0]
}
```

**答案解析：**

该函数使用分治策略合并 `k` 个升序链表。算法的核心思想是将链表分组，每次合并两组链表，直到合并成一个链表。

- 如果链表组为空，返回 `nil`。
- 在每次循环中，合并相邻的两组链表。
- 将合并后的链表组成新的链表组。
- 循环结束后，返回合并后的链表。

#### 19. 最长递增子序列

**题目：** 给定一个无序数组，找出该数组的 longest increasing subsequence。

**代码示例：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }

    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }

    return max(dp...)
}
```

**答案解析：**

该函数使用动态规划求解最长递增子序列。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
- 遍历数组 `nums`，对于每个元素 `nums[i]`：
  - 遍历数组 `nums` 的前 `i` 个元素，如果 `nums[i]` 大于 `nums[j]`，更新 `dp[i]` 的值。
- 返回 `dp` 数组中的最大值。

#### 20. 盛最多水的容器

**题目：** 给定一个二维矩阵，找出矩阵中的最大积水面积。

**代码示例：**

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0

    for left < right {
        minHeight := min(height[left], height[right])
        maxArea = max(maxArea, minHeight*(right-left))

        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }

    return maxArea
}
```

**答案解析：**

该函数通过双指针法求解最大积水面积。算法的核心思想是通过两个指针从两边向中间移动，计算每个位置可以容纳的最大积水面积。

- 初始化 `left` 和 `right` 指针，分别指向数组的第一个和最后一个元素。
- 在循环中，计算当前位置可以容纳的最大积水面积，更新最大面积。
- 如果左侧高度小于右侧高度，移动 `left` 指针；否则，移动 `right` 指针。
- 返回最大积水面积。

#### 21. 买卖股票的最佳时机 IV

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。假设你最多只能完成 `k` 笼子（每次交易的完整交易包含买入和卖出股票）交易，设计一个算法来计算你所能获取的最大利润。

**代码示例：**

```go
func maxProfit(prices []int, k int) int {
    dp := make([][][]int, k+1)
    for i := range dp {
        dp[i] = make([][]int, len(prices))
        for j := range dp[i] {
            dp[i][j] = [2]int{0, -prices[j]}
        }
    }

    for i := 1; i <= k; i++ {
        maxDiff := -prices[0]
        for j := 1; j < len(prices); j++ {
            dp[i][j][0] = max(dp[i][j-1][0], dp[i-1][j-1][1]+prices[j])
            dp[i][j][1] = max(dp[i][j-1][1], maxDiff-prices[j])
            maxDiff = max(maxDiff, dp[i-1][j][0]-prices[j])
        }
    }

    return dp[k][len(prices)-1][0]
}
```

**答案解析：**

该函数使用动态规划求解买卖股票的最佳时机。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个四维数组 `dp`，其中 `dp[i][j][0]` 表示第 `i` 笼子到第 `j` 天的最大利润，`dp[i][j][1]` 表示第 `i` �笼子到第 `j` 天的最大亏损。
- 遍历每个笼子 `i` 和每个交易日 `j`：
  - 计算 `dp[i][j][0]` 和 `dp[i][j][1]` 的值。
- 返回 `dp[k][len(prices)-1][0]`，即完成 `k` 笼子后的最大利润。

#### 22. 买卖股票的最佳时机 III

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。假设你最多只能完成两笔交易，设计一个算法来计算你所能获取的最大利润。

**代码示例：**

```go
func maxProfit(prices []int) int {
    dp := [4]int{0, -prices[0], 0, -prices[0]}
    for i := 1; i < len(prices); i++ {
        dp[0] = max(dp[0], dp[2])
        dp[1] = max(dp[1], dp[3]+prices[i])
        dp[2] = max(dp[2], dp[0]-prices[i])
        dp[3] = max(dp[3], dp[1]-prices[i])
    }
    return dp[3]
}
```

**答案解析：**

该函数使用动态规划求解买卖股票的最佳时机。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个四维数组 `dp`，其中 `dp[0]` 和 `dp[2]` 分别表示第 `i` 天第一次买入和第二次买入后的最大利润，`dp[1]` 和 `dp[3]` 分别表示第 `i` 天第一次卖出和第二次卖出后的最大利润。
- 遍历每个交易日 `i`：
  - 计算 `dp[0]`、`dp[1]`、`dp[2]` 和 `dp[3]` 的值。
- 返回 `dp[3]`，即完成两笔交易后的最大利润。

#### 23. 买卖股票的最佳时机 IV（变种）

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。假设你最多只能完成两笔交易，但第三笔交易必须在第一笔交易结束后才能进行。设计一个算法来计算你所能获取的最大利润。

**代码示例：**

```go
func maxProfit(prices []int) int {
    dp := [4]int{0, -prices[0], 0, -prices[0]}
    for i := 1; i < len(prices); i++ {
        dp[0] = max(dp[0], dp[2])
        dp[1] = max(dp[1], dp[3]+prices[i])
        dp[2] = max(dp[2], dp[0]-prices[i])
        dp[3] = max(dp[3], dp[1]-prices[i])
    }
    return dp[3]
}
```

**答案解析：**

该函数使用动态规划求解买卖股票的最佳时机。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化一个四维数组 `dp`，其中 `dp[0]` 和 `dp[2]` 分别表示第 `i` 天第一次买入和第二次买入后的最大利润，`dp[1]` 和 `dp[3]` 分别表示第 `i` 天第一次卖出和第二次卖出后的最大利润。
- 遍历每个交易日 `i`：
  - 计算 `dp[0]`、`dp[1]`、`dp[2]` 和 `dp[3]` 的值。
- 返回 `dp[3]`，即完成两笔交易后的最大利润。

#### 24. 合并区间

**题目：** 给定一组区间，请合并所有重叠的区间。

**代码示例：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }
    return result
}
```

**答案解析：**

该函数使用排序和合并区间的方法求解合并区间。算法的核心思想是将区间按起始位置排序，然后遍历区间，合并重叠的区间。

- 将区间按起始位置排序。
- 初始化一个空数组 `result`。
- 遍历区间：
  - 如果当前区间与 `result` 中的最后一个区间不重叠，将当前区间添加到 `result` 中。
  - 如果当前区间与 `result` 中的最后一个区间重叠，合并区间。
- 返回 `result`。

#### 25. 三数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出三个数，使得它们的和与 `target` 相等。要求按顺序返回这三个数。

**代码示例：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var result [][]int
    n := len(nums)

    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }

    return result
}
```

**答案解析：**

该函数使用排序和双指针法求解三数之和。算法的核心思想是将数组排序，然后使用两个指针分别指向 `nums[i]` 的左右两边，逐步逼近目标值。

- 将数组 `nums` 排序。
- 初始化一个空数组 `result`。
- 遍历数组 `nums`，对于每个元素 `nums[i]`：
  - 如果当前元素与前面的元素相同，跳过。
  - 初始化两个指针 `left` 和 `right`，分别指向 `nums[i]` 的左右两边。
  - 在循环中，根据三个数的和与目标值的关系，移动 `left` 和 `right` 指针。
- 返回 `result`。

#### 26. 四数之和

**题目：** 给定一个数组 `nums` 和一个目标值 `target`，找出四个数，使得它们的和与 `target` 相等。要求按顺序返回这四个数。

**代码示例：**

```go
func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    var result [][]int
    n := len(nums)

    for i := 0; i < n-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        for j := i + 1; j < n-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            left, right := j + 1, n - 1
            for left < right {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum == target {
                    result = append(result, []int{nums[i], nums[j], nums[left], nums[right]})
                    for left < right && nums[left] == nums[left+1] {
                        left++
                    }
                    for left < right && nums[right] == nums[right-1] {
                        right--
                    }
                    left++
                    right--
                } else if sum < target {
                    left++
                } else {
                    right--
                }
            }
        }
    }

    return result
}
```

**答案解析：**

该函数使用排序和双指针法求解四数之和。算法的核心思想是将数组排序，然后使用两个两层循环和两个指针分别指向 `nums[i]` 和 `nums[j]` 的左右两边，逐步逼近目标值。

- 将数组 `nums` 排序。
- 初始化一个空数组 `result`。
- 遍历数组 `nums`，对于每个元素 `nums[i]`：
  - 如果当前元素与前面的元素相同，跳过。
  - 初始化两个指针 `left` 和 `right`，分别指向 `nums[i]` 的左右两边。
  - 在两层循环中，根据四个数的和与目标值的关系，移动 `left` 和 `right` 指针。
- 返回 `result`。

#### 27. 寻找旋转排序数组中的最小值

**题目：** 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 的某个旋转调 整（例如，原数组 `0,1,2,4,5,6,7` 可能变为 `4,5,6,7,0,1,2`）。请找出并返回数组中的最小元素。

**代码示例：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1

    for left < right {
        mid := left + (right - left) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }

    return nums[left]
}
```

**答案解析：**

该函数使用二分查找算法在旋转排序的数组中找到最小元素。算法的核心思想是确定旋转点，然后根据旋转点的位置确定最小元素。

- 初始化 `left` 和 `right` 指针，分别指向数组的第一个和最后一个元素。
- 在循环中，计算中间位置 `mid`，并比较 `nums[mid]` 和 `nums[right]`。
- 如果 `nums[mid]` 大于 `nums[right]`，说明旋转点在 `mid` 的右侧，更新 `left` 指针。
- 否则，旋转点在 `mid` 的左侧或等于 `mid`，更新 `right` 指针。
- 循环结束后，`left` 就是旋转点的位置，返回 `nums[left]`。

#### 28. 两数相加

**题目：** 给出两个非空链表表示两个非负的整数。链表中的每个节点包含一个数字。将这两个数相加，并以链表形式返回结果。

**代码示例：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }

    return dummy.Next
}
```

**答案解析：**

该函数通过迭代方式求解两数相加。算法的核心思想是使用一个哑节点 `dummy`，并遍历两个链表，逐位相加。

- 初始化哑节点 `dummy` 和当前节点 `curr`，以及进位 `carry`。
- 在循环中，计算当前位上的数字 `val1` 和 `val2`，以及它们的和 `sum`。
- 更新进位 `carry` 和当前位上的值。
- 将当前位上的值添加到链表中。
- 返回哑节点的下一个节点，即链表的头节点。

#### 29. 搜索旋转排序数组 II

**题目：** 已知一个长度为 `n` 的数组，其中包含数字 `0` 到 `n-1`，某些数字可能重复。对数组进行旋转，找出并返回旋转后的数组中的最小元素。

**代码示例：**

```go
func searchMin(nums []int) int {
    left, right := 0, len(nums)-1

    for left < right {
        mid := left + (right - left) / 2
        if nums[mid] == nums[right] {
            right--
        } else if nums[mid] < nums[right] {
            right = mid
        } else {
            left = mid + 1
        }
    }

    return nums[left]
}
```

**答案解析：**

该函数通过二分查找算法在旋转排序的数组中找到最小元素。算法的核心思想是确定旋转点的位置，然后根据旋转点的位置确定最小元素。

- 初始化 `left` 和 `right` 指针，分别指向数组的第一个和最后一个元素。
- 在循环中，计算中间位置 `mid`，并比较 `nums[mid]` 和 `nums[right]`。
- 如果 `nums[mid]` 等于 `nums[right]`，说明旋转点可能在 `mid` 的左侧或等于 `mid`，将 `right` 指针左移。
- 如果 `nums[mid]` 小于 `nums[right]`，说明旋转点在 `mid` 的左侧，将 `right` 指针更新为 `mid`。
- 否则，旋转点在 `mid` 的右侧，将 `left` 指针更新为 `mid + 1`。
- 循环结束后，`left` 就是旋转点的位置，返回 `nums[left]`。

#### 30. 股票买卖交易

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。假设投资者可以完成无限次买卖，每次买卖都需要付手续费 `fee`。设计一个算法来计算投资者可以获得的最大利润。

**代码示例：**

```go
func maxProfit(prices []int, fee int) int {
    sell, buy := 0, -prices[0]

    for i := 1; i < len(prices); i++ {
        sell = max(sell, buy+prices[i]-fee)
        buy = max(buy, sell-prices[i])
    }

    return sell
}
```

**答案解析：**

该函数使用动态规划求解股票买卖交易的最大利润。动态规划的核心思想是将问题分解为较小的子问题，并利用子问题的解来求解原问题。

- 初始化 `sell` 和 `buy`，其中 `sell` 表示第 `i` 天卖出股票后的利润，`buy` 表示第 `i` 天买入股票后的利润。
- 遍历数组 `prices`，对于每个元素 `prices[i]`：
  - 更新 `sell` 和 `buy` 的值。
- 返回 `sell`，即最大利润。

### 小米2025届校招算法工程师面试真题总结

本文详细解析了小米2025届校招算法工程师面试真题中的20~30道典型问题，涵盖了数组、链表、字符串、动态规划、二分查找、回溯、贪心等算法和数据结构。每个问题都提供了详细的代码示例和解析，帮助读者更好地理解和掌握解题方法。通过这些面试题的练习，可以提升算法编程能力和面试技巧，为未来的技术面试做好充分准备。希望本文对您有所帮助！

