                 

### 市场调研方法：创业者必备的技能

#### 一、市场调研的重要性和常见方法

市场调研是创业者成功的关键一步。通过市场调研，创业者可以了解目标市场的需求、竞争对手情况、行业趋势等，从而制定更有效的商业策略。常见市场调研方法包括：

1. **问卷调查**
2. **深度访谈**
3. **焦点小组讨论**
4. **观察法**
5. **二手资料分析**

#### 二、高频面试题及答案解析

**1. 市场调研的主要目的是什么？**

**答案：** 市场调研的主要目的是了解目标市场的需求、竞争对手情况、行业趋势等，从而帮助企业制定更有效的商业策略。

**2. 请列举三种常见的市场调研方法。**

**答案：** 三种常见的市场调研方法包括问卷调查、深度访谈和焦点小组讨论。

**3. 什么是市场细分？**

**答案：** 市场细分是指将整个市场划分为若干个具有相似需求和特征的子市场，以便企业更好地满足不同客户群体的需求。

**4. 请简要介绍SWOT分析。**

**答案：** SWOT分析是一种常用的战略规划工具，用于评估企业的优势（Strengths）、劣势（Weaknesses）、机会（Opportunities）和威胁（Threats）。通过SWOT分析，企业可以制定更有针对性的战略。

**5. 什么是市场渗透策略？**

**答案：** 市场渗透策略是指企业通过提高市场份额，扩大现有产品或服务的销售范围，从而实现业务增长。

**6. 市场调研中的数据收集方法有哪些？**

**答案：** 数据收集方法包括问卷调查、深度访谈、焦点小组讨论、观察法、二手资料分析等。

**7. 请解释什么是市场容量？**

**答案：** 市场容量是指在一定时间内，市场上所有潜在购买者对该产品或服务的需求总量。

**8. 什么是市场占有率？**

**答案：** 市场占有率是指企业产品或服务在市场中所占的份额，通常以百分比表示。

**9. 什么是目标市场选择策略？**

**答案：** 目标市场选择策略是指企业根据市场细分和自身资源，选择最具有盈利潜力的市场进行针对性营销。

**10. 什么是产品生命周期？**

**答案：** 产品生命周期是指产品从研发、上市、成长、成熟到衰退的整个过程。

**11. 请简要介绍市场细分的过程。**

**答案：** 市场细分的过程包括：确定市场细分变量、选择市场细分变量、评估细分市场、选择目标市场。

**12. 什么是市场定位？**

**答案：** 市场定位是指企业根据目标市场的需求、竞争对手情况等，为产品或服务确定一个独特的市场地位。

**13. 市场调研中的数据分析方法有哪些？**

**答案：** 数据分析方法包括描述性统计分析、比较分析、趋势分析、相关性分析等。

**14. 什么是市场细分中的地理细分？**

**答案：** 地理细分是指根据地理位置、气候、人口密度等因素，将市场划分为不同的地理区域。

**15. 请解释什么是市场机会。**

**答案：** 市场机会是指市场上尚未被满足的需求或潜在的盈利机会。

**16. 什么是竞争分析？**

**答案：** 竞争分析是指对企业竞争对手的产品、市场份额、营销策略等进行分析，以便企业制定更有竞争力的策略。

**17. 市场调研中的数据分析有哪些步骤？**

**答案：** 数据分析的步骤包括：数据清洗、数据整理、数据可视化、数据分析、数据报告。

**18. 什么是市场调研中的深度访谈？**

**答案：** 深度访谈是一种市场调研方法，通过面对面或电话等方式，与目标受访者进行深入交流，以获取详细的信息。

**19. 什么是市场调研中的问卷调查？**

**答案：** 问卷调查是一种市场调研方法，通过设计问卷，向目标受访者收集相关信息，以了解市场需求和消费者行为。

**20. 市场调研中的数据分析有哪些常用工具？**

**答案：** 常用的数据分析工具包括Excel、SPSS、R、Python等。

#### 三、高频算法编程题及答案解析

**1. 寻找两个数字之和为特定值的数组。**

**题目描述：** 给定一个整数数组和一个目标值，找出数组中两数之和等于目标值的两个数，并返回他们的索引。

**示例：**

```
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] == 9
```

**答案：**

```python
def twoSum(nums, target):
    for i, num in enumerate(nums):
        complement = target - num
        if complement in nums[i+1:]:
            return [i, nums.index(complement)]
```

**2. 最长公共前缀。**

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
    return prefix
```

**3. 合并两个有序链表。**

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。链表节点包含整数值。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        p = dummy
        while l1 and l2:
            if l1.val < l2.val:
                p.next = l1
                l1 = l1.next
            else:
                p.next = l2
                l2 = l2.next
            p = p.next
        p.next = l1 if l1 else l2
        return dummy.next
```

**4. 两数相加。**

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的。

**示例：**

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,7]
```

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        p = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            p.next = ListNode(total % 10)
            p = p.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

**5. 盛最多水的容器。**

**题目描述：** 给定一个数组 `height`，其中 `height[i]` 表示第 `i` 个容器的身高。

**示例：**

```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：最长容器的高为 8，宽为 7。
```

**答案：**

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**6. 两数组的交集。**

**题目描述：** 给定两个数组 `nums1` 和 `nums2` ，返回它们交集的最小集合。

**示例：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

**答案：**

```python
def intersection(nums1, nums2):
    return list(set(nums1) & set(nums2))
```

**7. 两数之和。**

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9
```

**答案：**

```python
def twoSum(nums, target):
    nums_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in nums_dict:
            return [nums_dict[complement], i]
        nums_dict[num] = i
```

**8. 最长公共子序列。**

**题目描述：** 给定两个字符串 `text1` 和 `text2` ，返回这两个字符串的最长公共子序列的长度。

**示例：**

```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace" ，它的长度为 3。
```

**答案：**

```python
def longestCommonSubsequence(text1, text2):
    dp = [[0] * (len(text2) + 1) for _ in range(len(text1) + 1)]
    for i in range(1, len(text1) + 1):
        for j in range(1, len(text2) + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**9. 字符串转换整数 (atoi)。**

**题目描述：** 实现一个我的atoi函数，它将字符串转换为整数。

**示例：**

```
输入：text = "42"
输出：42
```

**答案：**

```python
def myAtoi(text):
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    i, sign, result = 0, 1, 0
    while i < len(text) and text[i] == ' ':
        i += 1
    if i >= len(text):
        return 0
    if text[i] == '+':
        sign = 1
        i += 1
    elif text[i] == '-':
        sign = -1
        i += 1
    for j in range(i, len(text)):
        if text[j].isdigit():
            result = result * 10 + int(text[j])
            if result * sign > INT_MAX:
                return INT_MAX if sign > 0 else INT_MIN
        else:
            break
    return result * sign
```

**10. 盗贼分组。**

**题目描述：** 有一个数组 `nums`，其中有一个元素是出现两次的，其余元素均为唯一。请找出这个重复的元素。

**示例：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：2 或 3
```

**答案：**

```python
def findDuplicate(nums):
    n = len(nums)
    for i in range(n):
        while nums[i] != i + 1:
            if nums[i] == nums[nums[i] - 1]:
                return nums[i]
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    return -1
```

**11. 最小生成树。**

**题目描述：** 给定一个无向图和图中的边权，找出连接这些顶点的最小生成树。

**示例：**

```
输入：edges = [[0,1,10],[0,2,1],[1,2,2]]
输出：3
解释：最小生成树的边权和为 3，可以选择边 [0,1,10]、[0,2,1] 和 [1,2,2]。
```

**答案：**

```python
def minTree(edges, n):
    parent = list(range(n))
    rank = [1] * n
    for u, v, w in edges:
        pu, pv = find(u), find(v)
        if pu != pv:
            if rank[pu] > rank[pv]:
                parent[pv] = pu
                rank[pu] += rank[pv]
            else:
                parent[pu] = pv
                rank[pv] += rank[pu]
    return sum(w for u, v, w in edges if find(u) == find(v))
```

**12. 奇偶锁。**

**题目描述：** 实现一个奇偶锁，支持 `lock`、`unlock` 和 `try` 操作。

**示例：**

```
输入：["OddLock", "lock", "unlock", "tryLock", "tryLock", "unlock", "tryLock", "tryLock"]
输出：[null, true, false, true, false, false, true, false]
```

**答案：**

```python
class OddLock:

    def __init__(self):
        self.flag = True

    def lock(self):
        while not self.flag:
            pass
        self.flag = False

    def unlock(self):
        self.flag = True

    def tryLock(self):
        if self.flag:
            self.flag = False
            return True
        return False
```

**13. 设计哈希集合。**

**题目描述：** 设计哈希集合，支持 `add`、`remove` 和 `contains` 操作。

**示例：**

```
输入：["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
输出：[null, null, null, true, true, null, false, null, true]
```

**答案：**

```python
class MyHashSet:

    def __init__(self):
        self.size = 1000000
        self.buckets = [0] * self.size

    def hash(self, key):
        return key % self.size

    def add(self, key):
        index = self.hash(key)
        if self.buckets[index] == 0:
            self.buckets[index] = key
        else:
            while self.buckets[index] != 0 and self.buckets[index] != key:
                index = (index + 1) % self.size
            if self.buckets[index] == 0:
                self.buckets[index] = key

    def remove(self, key):
        index = self.hash(key)
        if self.buckets[index] == 0:
            return
        else:
            while self.buckets[index] != 0 and self.buckets[index] != key:
                index = (index + 1) % self.size
            if self.buckets[index] == key:
                self.buckets[index] = 0

    def contains(self, key):
        index = self.hash(key)
        if self.buckets[index] == 0:
            return False
        else:
            while self.buckets[index] != 0 and self.buckets[index] != key:
                index = (index + 1) % self.size
            return self.buckets[index] == key
```

**14. 设计有限阻塞队列。**

**题目描述：** 设计一个有限阻塞队列，支持 `enqueue`、`dequeue` 和 `isEmpty` 操作。

**示例：**

```
输入：["MyQueue", "enqueue", "enqueue", "enqueue", "enqueue", "enqueue", "enqueue", "dequeue", "dequeue", "dequeue", "dequeue", "dequeue", "dequeue", "enqueue"]
输出：[null, true, true, true, true, true, true, 1, 2, 3, 4, 5, 6, true]
```

**答案：**

```python
from threading import Condition

class MyQueue:

    def __init__(self, capacity: int):
        self.queue = []
        self.capacity = capacity
        self.cond = Condition()

    def enqueue(self, val: int) -> bool:
        with self.cond:
            if len(self.queue) == self.capacity:
                return False
            self.queue.append(val)
            self.cond.notify()
            return True

    def dequeue(self) -> int:
        with self.cond:
            while len(self.queue) == 0:
                self.cond.wait()
            return self.queue.pop(0)

    def isEmpty(self) -> bool:
        return len(self.queue) == 0
```

**15. 设计固定时间缓存。**

**题目描述：** 设计一个固定时间缓存，支持 `put`、`get` 和 `delete` 操作。

**示例：**

```
输入：["FixedTimeCache", "put", "get", "delete", "get"]
输出：[null, true, -1, true, 3]
```

**答案：**

```python
from collections import OrderedDict
from datetime import datetime, timedelta

class FixedTimeCache:

    def __init__(self, duration: int):
        self.duration = timedelta(seconds=duration)
        self.cache = OrderedDict()

    def put(self, key: int, value: int) -> None:
        self.cache[key] = value

    def get(self, key: int) -> int:
        if key in self.cache:
            return self.cache[key]
        return -1

    def delete(self, key: int) -> None:
        if key in self.cache:
            del self.cache[key]

    def tick(self):
        now = datetime.now()
        keys_to_delete = [key for key, value in self.cache.items() if now - value["time"] > self.duration]
        for key in keys_to_delete:
            del self.cache[key]
```

**16. 设计前缀树。**

**题目描述：** 设计一个前缀树，支持 `insert`、`search` 和 `startsWith` 操作。

**示例：**

```
输入：["Tree", "insert", "search", "search", "startsWith", "insert", "search"]
输出：[null, null, true, false, true, null, true]
```

**答案：**

```python
class Trie:

    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, word: str) -> None:
        node = self
        for char in word:
            index = ord(char) - ord('a')
            if node.children[index] is None:
                node.children[index] = Trie()
            node = node.children[index]
        node.is_end = True

    def search(self, word: str) -> bool:
        node = self
        for char in word:
            index = ord(char) - ord('a')
            if node.children[index] is None:
                return False
            node = node.children[index]
        return node.is_end

    def startsWith(self, prefix: str) -> bool:
        node = self
        for char in prefix:
            index = ord(char) - ord('a')
            if node.children[index] is None:
                return False
            node = node.children[index]
        return True
```

**17. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 3]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**18. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**19. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**20. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**21. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**22. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**23. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**24. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**25. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**26. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**27. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**28. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**29. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**30. 设计LRU缓存。**

**题目描述：** 设计一个LRU缓存，支持 `get`、`put` 操作。

**示例：**

```
输入：["LRUCache", "put", "put", "get", "put", "get"]
输出：[null, null, null, -1, null, 2]
```

**答案：**

```python
from collections import OrderedDict

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            del self.cache[key]
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

