                 

### 百度2025届校招算法工程师面试真题解密

#### 1. 实现一个LRU缓存

**题目：** 实现一个LRU（Least Recently Used）缓存，缓存容量为`capacity`，当缓存满时，删除最近最少使用的数据。

**答案：** 使用双向链表和哈希表结合实现。

```go
type LRUCache struct {
    capacity int
    keys     map[int]*Node
    head, tail *Node
}

type Node struct {
    key, value int
    prev, next *Node
}

func Constructor(capacity int) LRUCache {
    cache := LRUCache{
        capacity: capacity,
        keys:     make(map[int]*Node),
        head:     &Node{},
        tail:     &Node{},
    }
    cache.head.next = cache.tail
    cache.tail.prev = cache.head
    return cache
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.keys[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.keys[key]; ok {
        node.value = value
        this.moveToHead(node)
    } else {
        if len(this.keys) == this.capacity {
            this.removeTail()
        }
        newNode := &Node{key, value}
        this.insertToHead(newNode)
        this.keys[key] = newNode
    }
}

func (this *LRUCache) moveToHead(node *Node) {
    this.removeNode(node)
    this.insertToHead(node)
}

func (this *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) insertToHead(node *Node) {
    node.next = this.head.next
    node.prev = this.head
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeTail() {
    node := this.tail.prev
    this.removeNode(node)
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * obj := Constructor(capacity);
 * param_1 := obj.Get(key);
 * obj.Put(key,value);
 */
```

**解析：** 使用一个双向链表来记录最近最少使用的节点，同时使用哈希表来快速访问节点。当访问某个节点时，将其移动到双向链表的头部；当缓存容量满时，删除双向链表的尾部节点。

#### 2. 单词搜索 II

**题目：** 给定一个二维网格和一个单词列表，返回所有在该网格中出现的单词。单词应该以字母顺序返回。

**答案：** 使用回溯算法。

```go
var res = []string{}
var board [][]byte

func findWords(board [][]byte, words []string) []string {
    m, n := len(board), len(board[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            dfs(i, j, &board)
        }
    }
    sort.Strings(res)
    return res
}

func dfs(i, j int) {
    if outOfBound(i, j) || board[i][j] != ch {
        return
    }
    board[i][j] = '0'
    for _, dir := range dirs {
        nextI, nextJ := i+dir[0], j+dir[1]
        dfs(nextI, nextJ)
    }
    board[i][j] = ch
}

func dfs(i, j int) {
    if outOfBound(i, j) || board[i][j] != ch {
        return
    }
    board[i][j] = '0'
    for _, dir := range dirs {
        nextI, nextJ := i+dir[0], j+dir[1]
        if exists && strings.Contains(word, string(board[i][j])) {
            res = append(res, word)
            word = word[1:]
        }
        dfs(nextI, nextJ)
    }
    board[i][j] = ch
}
```

**解析：** 使用回溯算法搜索所有可能的路径，当找到一个路径与单词列表中的单词匹配时，将其添加到结果中。最后对结果进行排序。

#### 3. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 从第一个字符串开始，逐个字符比较，直到找到不同的字符或到达字符串的结尾。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, ch := 0, strs[0][0]; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || ch != strs[j][i] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

**解析：** 遍历第一个字符串的每个字符，与其他字符串的对应位置进行比较。一旦找到不同的字符，返回当前公共前缀。

#### 4. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈模拟计算过程。

```go
func evalRPN(tokens []string) int {
    var stack []int
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

**解析：** 遍历逆波兰表达式，根据运算符和操作数进行相应的计算，并将结果存入栈中。最后返回栈顶元素作为结果。

#### 5. 字符串转换大写字母

**题目：** 将一个字符串转换成大写形式。

**答案：** 使用字符串的`ToUpper`方法。

```go
func toLowerCase(s string) string {
    return strings.ToUpper(s)
}
```

**解析：** 直接调用`ToUpper`方法将字符串转换为全部大写形式。

#### 6. 二进制求和

**题目：** 给定两个二进制字符串，返回他们的和（用二进制表示）。

**答案：** 使用位运算。

```go
func addBinary(a string, b string) string {
    maxLen := max(len(a), len(b))
    a = padLeft(a, maxLen, '0')
    b = padLeft(b, maxLen, '0')

    carry := 0
    res := []byte{}
    for i := maxLen - 1; i >= 0; i-- {
        sum := (a[i] - '0') + (b[i] - '0') + carry
        carry = sum / 2
        res = append(res, byte((sum%2) + '0'))
    }

    if carry > 0 {
        res = append(res, byte(carry+'0'))
    }

    return reverseBytes(res)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func padLeft(s string, length int, ch byte) string {
    if len(s) >= length {
        return s
    }
    return strings.Repeat(string(ch), length-len(s)) + s
}

func reverseBytes(s []byte) string {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
    return string(s)
}
```

**解析：** 对两个二进制字符串进行逐位相加，并处理进位。最后将结果转换为字符串并反转。

#### 7. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：** 使用递归。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 将两个有序链表递归地进行合并，直到其中一个链表为空。然后将非空链表的剩余部分直接返回。

#### 8. 螺旋矩阵

**题目：** 给定一个 `m x n` 的二维矩阵 `matrix` ，返回矩阵的螺旋顺序。

**答案：** 使用模拟。

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    m, n := len(matrix), len(matrix[0])
    vis := make([][]bool, m)
    for i := range vis {
        vis[i] = make([]bool, n)
    }
    res := []int{}
    t, l, r, b := 0, 0, n-1, m-1
    for len(res) < m*n {
        for j := l; j <= r && len(res) < m*n; j++ {
            res = append(res, matrix[t][j])
            vis[t][j] = true
        }
        t++
        for i := t; i <= b && len(res) < m*n; i++ {
            res = append(res, matrix[i][r])
            vis[i][r] = true
        }
        r--
        for j := r; j >= l && len(res) < m*n; j-- {
            res = append(res, matrix[b][j])
            vis[b][j] = true
        }
        b--
        for i := b; i >= t && len(res) < m*n; i-- {
            res = append(res, matrix[i][l])
            vis[i][l] = true
        }
        l++
    }
    return res
}
```

**解析：** 按照螺旋顺序遍历矩阵，将遍历到的元素添加到结果中。

#### 9. 数据流中的中位数

**题目：** 设计一个算法来查找数据流中的中位数。

**答案：** 使用大根堆和小根堆。

```go
type MedianFinder struct {
    maxHeap *heap.MaxHeap
    minHeap *heap.MinHeap
}

func Constructor() MedianFinder {
    return MedianFinder{
        maxHeap: heap.NewMaxHeap(),
        minHeap: heap.NewMinHeap(),
    }
}

func (this *MedianFinder) AddNum(num int) {
    this.maxHeap Offer(num)
    this.minHeap Offer(-this.maxHeap.poll())
    if this.maxHeap.size() < this.minHeap.size() {
        this.maxHeap Offer(-this.minHeap.poll())
        this.minHeap Offer(this.maxHeap.poll())
    }
}

func (this *MedianFinder) FindMedian() float64 {
    if this.maxHeap.size() == this.minHeap.size() {
        return float64(this.maxHeap.poll() - this.minHeap.poll()) / 2
    }
    return float64(this.maxHeap.poll())
}
```

**解析：** 大根堆存储较小的一半数据，小根堆存储较大的一半数据。当两个堆的大小不相等时，中位数是大根堆的堆顶元素。

#### 10. 合并K个排序链表

**题目：** 合并 `k` 个排序链表，返回合并后的排序链表。

**答案：** 使用优先队列。

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    d := &Dummy{}
    q := &PriorityQueue{}
    for _, list := range lists {
        if list != nil {
            q.Enqueue(list)
        }
    }
    for !q.IsEmpty() {
        node := q.Dequeue()
        d.Next = node
        d = d.Next
        if node.Next != nil {
            q.Enqueue(node.Next)
        }
    }
    return d.Next
}

type PriorityQueue struct {
    heap []*ListNode
}

func (q *PriorityQueue) Enqueue(node *ListNode) {
    q.heap = append(q.heap, node)
    q.heapSort()
}

func (q *PriorityQueue) Dequeue() *ListNode {
    if q.IsEmpty() {
        return nil
    }
    node := q.heap[0]
    q.heap[0] = q.heap[len(q.heap)-1]
    q.heap = q.heap[:len(q.heap)-1]
    q.heapSort()
    return node
}

func (q *PriorityQueue) IsEmpty() bool {
    return len(q.heap) == 0
}

func (q *PriorityQueue) heapSort() {
    n := len(q.heap)
    for i := n/2 - 1; i >= 0; i-- {
        q.heapify(i, n)
    }
    for i := n - 1; i > 0; i-- {
        q.heapSwap(0, i)
        q.heapify(0, i)
    }
}

func (q *PriorityQueue) heapify(i, n int) {
    l := leftChild(i)
    r := rightChild(i)
    min := i
    if l < n && q.heap[l].Val < q.heap[min].Val {
        min = l
    }
    if r < n && q.heap[r].Val < q.heap[min].Val {
        min = r
    }
    if min != i {
        q.heapSwap(i, min)
        q.heapify(min, n)
    }
}

func (q *PriorityQueue) heapSwap(i, j int) {
    q.heap[i], q.heap[j] = q.heap[j], q.heap[i]
}

func leftChild(i int) int {
    return 2*i + 1
}

func rightChild(i int) int {
    return 2*i + 2
}
```

**解析：** 使用优先队列来存储链表节点，按照节点值进行排序。每次从优先队列中取出最小的节点，并将其添加到结果链表中。

#### 11. 反转链表

**题目：** 反转一个单链表。

**答案：** 使用递归。

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

**解析：** 递归地反转链表的下一个节点，然后将其指向当前节点。最后将当前节点的下一个节点设置为`nil`。

#### 12. 合并两个有序数组

**题目：** 给定两个已排序的数组，将两个数组合并为一个排序后的数组。

**答案：** 使用双指针。

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    t := m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[t] = nums1[p1]
            p1--
        } else {
            nums1[t] = nums2[p2]
            p2--
        }
        t--
    }
    for p2 >= 0 {
        nums1[t] = nums2[p2]
        p2--
        t--
    }
}
```

**解析：** 从两个数组的尾部开始比较，将较大的值放入合并后的数组尾部。最后处理剩余的数组。

#### 13. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**答案：** 使用动态规划。

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    curSum := nums[0]
    for i := 1; i < len(nums); i++ {
        curSum = max(nums[i], curSum+nums[i])
        maxSum = max(maxSum, curSum)
    }
    return maxSum
}
```

**解析：** 动态规划中的状态转移方程为 `curSum = max(nums[i], curSum+nums[i])`。遍历数组，更新当前子序列和和最大子序列和。

#### 14. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它应该被按顺序插入的位置。

**答案：** 使用二分查找。

```go
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}
```

**解析：** 二分查找的基本实现，当找到目标值时返回其索引，否则返回应该插入的位置。

#### 15. 两数相加

**题目：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的。如果位数不同，则较长链表位数多出部分到链表尾端由 0 组成。将两数相加，返回 和 的链表 。

**答案：** 使用模拟。

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    d := & Dummy{}
    t := d
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        v1 := 0
        if l1 != nil {
            v1 = l1.Val
            l1 = l1.Next
        }
        v2 := 0
        if l2 != nil {
            v2 = l2.Val
            l2 = l2.Next
        }
        sum := v1 + v2 + carry
        carry = sum / 10
        t.Next = & ListNode{ Val: sum % 10}
        t = t.Next
    }
    return d.Next
}
```

**解析：** 模拟两数相加的过程，处理进位。

#### 16. 汉明重量

**题目：** 计算两个整数 `x` 和 `y` 的汉明重量。

**答案：** 使用位运算。

```go
func hammingWeight(x uint32) int {
    count := 0
    for x > 0 {
        count += int(x & 1)
        x >>= 1
    }
    return count
}
```

**解析：** 位运算中的按位与操作`x & 1`用于获取最低位的值，然后通过右移操作`x >>= 1`将位数向右移动。

#### 17. 汇总区间

**题目：** 给定一个整数数组 `nums`，返回 `nums` 中所有出现过的数字的集合。

**答案：** 使用哈希表。

```go
func summaryRanges(nums []int) []string {
    sort.Ints(nums)
    res := []string{}
    if len(nums) == 0 {
        return res
    }
    start := nums[0]
    end := nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] == end+1 {
            end = nums[i]
        } else {
            res = append(res, joinInts(start, end))
            start = nums[i]
            end = nums[i]
        }
    }
    res = append(res, joinInts(start, end))
    return res
}

func joinInts(a, b int) string {
    if a == b {
        return strconv.Itoa(a)
    }
    return strconv.Itoa(a) + "->" + strconv.Itoa(b)
}
```

**解析：** 首先对数组进行排序，然后遍历数组，找到连续的区间，将它们转换为字符串并添加到结果中。

#### 18. 接近目标值的最小代价数组

**题目：** 给定一个整数数组 `cost` 和一个目标值 `target`，请你在成本 `cost` 之间选择一些整数，将这些整数插入到数组中，并使得所有整数之和恰好等于目标值 `target`。要求最小化总成本。

**答案：** 使用动态规划。

```go
func minCost(cost []int, target int) int {
    n := len(cost)
    dp := make([]int, target+1)
    for i := 1; i <= target; i++ {
        dp[i] = math.MaxInt32
        for j := 0; j < n; j++ {
            if i >= cost[j] && dp[i-cost[j]]+cost[j] < dp[i] {
                dp[i] = dp[i-cost[j]] + cost[j]
            }
        }
    }
    return dp[target]
}
```

**解析：** 动态规划中的状态转移方程为 `dp[i] = min(dp[i], dp[i-cost[j]]+cost[j])`，遍历数组，更新动态规划数组。

#### 19. 删除链表的节点

**题目：** 给定一个单链表的节点，在该节点之前删除该节点，同时保持链表的完整性。

**答案：** 使用模拟。

```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**解析：** 直接覆盖待删除节点的值，然后跳过待删除节点。

#### 20. 链表中的节点每 `k` 个一组反向

**题目：** 给定一个单链表，每 `k` 个节点进行一组反转。例如，如果链表中节点数为 `n`，则第 `1`、`2`、`3`、`...`、`k` 个节点组成一组进行反转。

**答案：** 使用递归。

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    if head == nil || k <= 1 {
        return head
    }
    cur := head
    cnt := 0
    while cnt < k && cur != nil:
        cnt += 1
        cur = cur.next
    if cnt == k:
        cur = reverseKGroup(cur, k)
        while cnt > 0:
            cnt -= 1
            prev.next.next = cur
            prev = head
            head = cur
            cur = prev.next
        prev.next = nil
    return head
}

def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    while True:
        count = 0
        cur = prev.next
        while count < k and cur:
            count += 1
            cur = cur.next
        if count == k:
            tail = cur
            for _ in range(k):
                prev.next = tail.next
                tail.next = prev.next.next
                prev.next.next = prev.next
                prev.next = tail
                tail = prev.next
        else:
            break
    return dummy.next
```

**解析：** 使用递归或循环遍历链表，每 `k` 个节点进行反转。首先找到第 `k` 个节点，然后将其与前一个节点断开连接，接着将当前节点反转并重新连接。

#### 21. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**答案：** 使用动态规划。

```go
def longestCommonSubsequence(self, text1: str, text2: str) -> str:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    i, j = m, n
    res = []
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            res.append(text1[i - 1])
            i, j = i - 1, j - 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return ''.join(res[::-1])
```

**解析：** 动态规划中的状态转移方程为 `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`，当两个字符相等时，`dp[i][j] = dp[i - 1][j - 1] + 1`。最后从动态规划数组中还原最长公共子序列。

#### 22. 最小栈

**题目：** 设计一个支持 `push` 、 `pop` 、 `top` 操作，并能在常数时间内检索到最小元素的栈。

**答案：** 使用两个栈。

```go
type MinStack struct {
    s1, s2 *Stack
}

func Constructor() MinStack {
    return MinStack{
        s1: &Stack{},
        s2: &Stack{},
    }
}

func (this *MinStack) Push(x int) {
    this.s1.Push(x)
    if this.s2.IsEmpty() || x <= this.s2.Peek() {
        this.s2.Push(x)
    }
}

func (this *MinStack) Pop() {
    if this.s1.Peek() != this.s2.Peek() {
        this.s2.Pop()
    }
    this.s1.Pop()
}

func (this *MinStack) Top() int {
    return this.s1.Peek()
}

func (this *MinStack) Min() int {
    return this.s2.Peek()
}

type Stack struct {
    arr []int
}

func (s *Stack) Push(x int) {
    s.arr = append(s.arr, x)
}

func (s *Stack) Pop() {
    if len(s.arr) > 0 {
        s.arr = s.arr[:len(s.arr)-1]
    }
}

func (s *Stack) Peek() int {
    if len(s.arr) > 0 {
        return s.arr[len(s.arr)-1]
    }
    return -1
}

func (s *Stack) IsEmpty() bool {
    return len(s.arr) == 0
}
```

**解析：** 使用两个栈，一个用于存储所有元素，另一个用于存储当前最小值。每次 `push` 时，如果新元素小于当前最小值，将其添加到第二个栈中。每次 `pop` 时，如果第一个栈顶元素等于第二个栈顶元素，将第二个栈顶元素也弹出。

#### 23. 单调栈

**题目：** 使用单调栈实现下一个更大元素 I。

**答案：** 使用栈。

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    res := make([]int, len(nums1), len(nums2))
    for _, num := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] <= num {
            stack = stack[:len(stack)-1]
        }
        if len(stack) > 0 {
            res = append(res, stack[len(stack)-1])
        } else {
            res = append(res, -1)
        }
        stack = append(stack, num)
    }
    for i, _ := range res {
        if res[i] == -1 {
            res = append(res[:i], res[i+1:]...)
            break
        }
    }
    return res
}
```

**解析：** 遍历 `nums2`，使用栈记录下一个更大的元素。对于每个元素，弹出栈中小于当前元素的值，并将当前元素作为下一个更大元素。如果栈为空，则结果为 `-1`。

#### 24. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈。

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

**解析：** 遍历逆波兰表达式，根据运算符和操作数进行相应的计算，并将结果存入栈中。最后返回栈顶元素作为结果。

#### 25. 最小栈

**题目：** 设计一个支持 `push` 、 `pop` 、 `top` 操作，并能在常数时间内检索到最小元素的栈。

**答案：** 使用两个栈。

```go
type MinStack struct {
    s1, s2 *Stack
}

func Constructor() MinStack {
    return MinStack{
        s1: &Stack{},
        s2: &Stack{},
    }
}

func (this *MinStack) Push(x int) {
    this.s1.Push(x)
    if this.s2.IsEmpty() || x <= this.s2.Peek() {
        this.s2.Push(x)
    }
}

func (this *MinStack) Pop() {
    if this.s1.Peek() != this.s2.Peek() {
        this.s2.Pop()
    }
    this.s1.Pop()
}

func (this *MinStack) Top() int {
    return this.s1.Peek()
}

func (this *MinStack) Min() int {
    return this.s2.Peek()
}

type Stack struct {
    arr []int
}

func (s *Stack) Push(x int) {
    s.arr = append(s.arr, x)
}

func (s *Stack) Pop() {
    if len(s.arr) > 0 {
        s.arr = s.arr[:len(s.arr)-1]
    }
}

func (s *Stack) Peek() int {
    if len(s.arr) > 0 {
        return s.arr[len(s.arr)-1]
    }
    return -1
}

func (s *Stack) IsEmpty() bool {
    return len(s.arr) == 0
}
```

**解析：** 使用两个栈，一个用于存储所有元素，另一个用于存储当前最小值。每次 `push` 时，如果新元素小于当前最小值，将其添加到第二个栈中。每次 `pop` 时，如果第一个栈顶元素等于第二个栈顶元素，将第二个栈顶元素也弹出。

#### 26. 单调栈

**题目：** 使用单调栈实现下一个更大元素 I。

**答案：** 使用栈。

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    res := make([]int, len(nums1), len(nums2))
    for _, num := range nums2 {
        for len(stack) > 0 && stack[len(stack)-1] <= num {
            stack = stack[:len(stack)-1]
        }
        if len(stack) > 0 {
            res = append(res, stack[len(stack)-1])
        } else {
            res = append(res, -1)
        }
        stack = append(stack, num)
    }
    for i, _ := range res {
        if res[i] == -1 {
            res = append(res[:i], res[i+1:]...)
            break
        }
    }
    return res
}
```

**解析：** 遍历 `nums2`，使用栈记录下一个更大的元素。对于每个元素，弹出栈中小于当前元素的值，并将当前元素作为下一个更大元素。如果栈为空，则结果为 `-1`。

#### 27. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈。

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

**解析：** 遍历逆波兰表达式，根据运算符和操作数进行相应的计算，并将结果存入栈中。最后返回栈顶元素作为结果。

#### 28. 两数之和 II - 输入有序数组

**题目：** 给定一个已按照升序排列的有序数组 `numbers` ，和一个目标值 `target` ，请你在数组中找出两个数，使得它们的和等于 `target` 。返回这两个下标的值 `indices` ，其中 `indices = [index1, index2]` 。`index1` 必须小于 `index2` 。

**答案：** 使用双指针。

```go
def twoSum(numbers: List[int], target: int) -> List[int]:
    left, right = 0, len(numbers) - 1
    while left < right:
        if numbers[left] + numbers[right] == target:
            return [left + 1, right + 1]
        elif numbers[left] + numbers[right] < target:
            left += 1
        else:
            right -= 1
    return []
```

**解析：** 使用双指针从两端遍历数组，当两数之和小于目标值时，移动左指针；当两数之和大于目标值时，移动右指针。找到满足条件的两个数时，返回它们的索引。

#### 29. 多数元素

**题目：** 给定一个整数数组 `nums`，在这个数组中，除了一个元素只出现一次以外，其他元素都出现了两次。请找出这个只出现一次的元素。

**答案：** 使用哈希表。

```go
def singleNumber(nums: List[int]) -> int:
    counts = Counter(nums)
    for num, count in counts.items():
        if count == 1:
            return num
    return -1
```

**解析：** 使用哈希表统计数组中每个元素的频次，然后遍历哈希表，返回出现一次的元素。

#### 30. 岛屿数量

**题目：** 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

**答案：** 使用深度优先搜索。

```go
def numIslands(grid: List[List[str]]) -> int:
    def dfs(i, j):
        grid[i][j] = '0'
        for x, y in neighbors:
            if 0 <= i + x < m and 0 <= j + y < n and grid[i + x][j + y] == '1':
                dfs(i + x, j + y)

    m, n = len(grid), len(grid[0])
    ans = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                ans += 1
                dfs(i, j)
    return ans

def neighbors():
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    for dx, dy in directions:
        yield dx, dy
```

**解析：** 使用深度优先搜索遍历岛屿，并计数。每次遍历到 `'1'` 时，递归地遍历其相邻的 `'1'`。最后返回岛屿的数量。

