                 

### 1. 链表问题：单链表中的环路检测

**题目：** 给定一个单链表的头节点，判断链表中是否有环路。

**示例：**

```text
输入：head = [3, 2, 0, -4]
输出：true
解释：链表中有一个环路，其路径为 3 -> 2 -> 0 -> -4。
```

**答案：** 使用哈希表或快慢指针法可以检测链表中是否有环路。

**哈希表法：**

```go
func hasCycle(head *ListNode) bool {
    visited := map[*ListNode]bool{}
    for node := head; node != nil; node = node.Next {
        if visited[node] {
            return true
        }
        visited[node] = true
    }
    return false
}
```

**快慢指针法：**

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 哈希表法通过记录每个节点是否已被访问来检测环路。快慢指针法通过两个指针的不同速度移动来检测环路。当快指针追上慢指针时，链表中存在环路。

### 2. 树问题：二叉搜索树中的查找

**题目：** 给定一个二叉搜索树（BST）和目标值，判断树中是否存在该值。

**示例：**

```text
输入：root = [4, 2, 7, 1, 3], val = 2
输出：true
```

**答案：** 使用递归或迭代遍历二叉搜索树，判断树中是否存在目标值。

**递归法：**

```go
func searchBST(root *TreeNode, val int) bool {
    if root == nil || root.Val == val {
        return root != nil
    }
    if val < root.Val {
        return searchBST(root.Left, val)
    }
    return searchBST(root.Right, val)
}
```

**迭代法：**

```go
func searchBST(root *TreeNode, val int) bool {
    for root != nil {
        if root.Val == val {
            return true
        }
        if val < root.Val {
            root = root.Left
        } else {
            root = root.Right
        }
    }
    return false
}
```

**解析：** 递归法通过不断递归遍历来查找目标值。迭代法通过循环遍历二叉搜索树，根据当前节点的值来决定遍历的左右子树。

### 3. 动态规划：最长递增子序列

**题目：** 给定一个整数数组，找出最长递增子序列的长度。

**示例：**

```text
输入：nums = [10, 9, 2, 5, 3, 7, 101, 18]
输出：4
解释：最长递增子序列是 [2, 3, 7, 101]，其长度为 4。
```

**答案：** 使用动态规划求解最长递增子序列的长度。

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

**解析：** 动态规划通过维护一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。遍历数组，更新每个位置的 `dp` 值。

### 4. 二分查找：搜索旋转排序数组

**题目：** 给定一个旋转排序的整数数组，找到给定目标值的位置。

**示例：**

```text
输入：nums = [4, 5, 6, 7, 0, 1, 2], target = 0
输出：4
```

**答案：** 使用二分查找的方法寻找目标值的位置。

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 二分查找通过将问题分为左右两个子数组来解决。当中间值大于左端值时，问题在左子数组中；否则在右子数组中。

### 5. 贪心算法：背包问题

**题目：** 给定一个背包容量和若干物品的重量和价值，求解最多能装入背包的最大价值。

**示例：**

```text
输入：capacity = 50, weights = [1, 2, 3, 4, 5], values = [1, 6, 10, 16, 20]
输出：60
解释：选择物品 1、3 和 5，总价值为 1 + 10 + 20 = 31，小于容量 50。
```

**答案：** 使用贪心算法求解背包问题。

```go
func knapsack(capacity int, weights []int, values []int) int {
    n := len(values)
    items := make([]Item, n)
    for i := 0; i < n; i++ {
        items[i] = Item{weights[i], values[i], float64(values[i]) / float64(weights[i])}
    }
    sort.Slice(items, func(i, j int) bool {
        return items[i].Ratio > items[j].Ratio
    })
    totalValue := 0
    for _, item := range items {
        if capacity >= item.Weight {
            totalValue += item.Value
            capacity -= item.Weight
        } else {
            totalValue += int(float64(item.Value) * float64(capacity) / float64(item.Weight))
            break
        }
    }
    return totalValue
}

type Item struct {
    Weight  int
    Value   int
    Ratio   float64
}
```

**解析：** 贪心算法通过选择单位重量价值最大的物品来填充背包，直到背包填满或无物品可加。

### 6. 图算法：拓扑排序

**题目：** 给定一个有向无环图（DAG），进行拓扑排序。

**示例：**

```text
输入：edges = [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3]]
输出：[2, 0, 1, 3]
```

**答案：** 使用深度优先搜索（DFS）进行拓扑排序。

```go
func topologicalSort(edges [][]int) []int {
    graph := make([][]int, len(edges))
    indegrees := make([]int, len(edges))
    for _, edge := range edges {
        from := edge[0]
        to := edge[1]
        graph[from] = append(graph[from], to)
        indegrees[to]++
    }
    var stack []int
    var visited = make([]bool, len(edges))
    for i, degree := range indegrees {
        if degree == 0 {
            stack = append(stack, i)
            visited[i] = true
        }
    }
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        for _, child := range graph[node] {
            indegrees[child]--
            if indegrees[child] == 0 && !visited[child] {
                stack = append(stack, child)
                visited[child] = true
            }
        }
    }
    return stack
}
```

**解析：** 拓扑排序通过计算每个节点的入度，使用DFS遍历无环图，将每个节点添加到结果栈中。

### 7. 数学问题：求最大子序和

**题目：** 给定一个整数数组，求最大子序和。

**示例：**

```text
输入：nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
输出：6
解释：最大子序和为 6，即 [4, -1, 2, 1]。
```

**答案：** 使用动态规划求解最大子序和。

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}
```

**解析：** 动态规划通过维护当前子序列和 `currentSum`，选择当前元素或当前元素加上前一个子序列和中的最大值，更新最大子序和 `maxSum`。

### 8. 回溯算法：全排列

**题目：** 给定一个整数数组，输出数组所有可能的排列。

**示例：**

```text
输入：nums = [1, 2, 3]
输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

**答案：** 使用回溯算法生成所有排列。

```go
var result [][]int
var path []int

func permute(nums []int) [][]int {
    result = [][]int{}
    path = []int{}
    backtracking(nums)
    return result
}

func backtracking(nums []int) {
    if len(path) == len(nums) {
        result = append(result, append([]int{}, path...))
        return
    }
    for _, num := range nums {
        if contains(path, num) {
            continue
        }
        path = append(path, num)
        backtracking(nums)
        path = path[:len(path)-1]
    }
}

func contains(slice []int, value int) bool {
    for _, v := range slice {
        if v == value {
            return true
        }
    }
    return false
}
```

**解析：** 回溯算法通过递归生成所有可能的排列，并使用一个 `path` 数组来存储当前的排列。

### 9. 栈和队列：模拟栈的队列

**题目：** 使用队列实现栈的数据结构。

**示例：**

```text
输入：["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：[null, null, null, 2, 2, false]
```

**答案：** 使用两个队列实现栈。

```go
type MyStack struct {
    queue1 []int
    queue2 []int
}

func Constructor() MyStack {
    return MyStack{queue1: []int{}, queue2: []int{}}
}

func (this *MyStack) Push(x int) {
    this.queue2 = append(this.queue2, x)
}

func (this *MyStack) Pop() int {
    for len(this.queue2) > 1 {
        this.queue1 = append(this.queue1, this.queue2[0])
        this.queue2 = this.queue2[1:]
    }
    res := this.queue2[0]
    this.queue2 = this.queue1
    this.queue1 = []int{}
    return res
}

func (this *MyStack) Top() int {
    for len(this.queue2) > 1 {
        this.queue1 = append(this.queue1, this.queue2[0])
        this.queue2 = this.queue2[1:]
    }
    res := this.queue2[0]
    this.queue2 = this.queue1
    this.queue1 = []int{}
    return res
}

func (this *MyStack) Empty() bool {
    return len(this.queue2) == 0
}
```

**解析：** 使用两个队列交替存放元素，实现栈的入栈、出栈和获取栈顶元素的操作。

### 10. 前缀树：单词搜索

**题目：** 给定一个二维字符网格和一个单词，判断单词是否存在于网格中。

**示例：**

```text
输入：board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]], word = "ABCCED"
输出：true
```

**答案：** 使用前缀树和深度优先搜索（DFS）判断单词是否存在于网格中。

```go
func exist(board [][]byte, word string) bool {
    var dfs func(i, j int, index int) bool
    dfs = func(i, j, index int) bool {
        if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] != word[index] {
            return false
        }
        if index == len(word)-1 {
            return true
        }
        temp := board[i][j]
        board[i][j] = 0
        res := dfs(i+1, j, index+1) || dfs(i-1, j, index+1) || dfs(i, j+1, index+1) || dfs(i, j-1, index+1)
        board[i][j] = temp
        return res
    }
    for i := 0; i < len(board); i++ {
        for j := 0; j < len(board[0]); j++ {
            if dfs(i, j, 0) {
                return true
            }
        }
    }
    return false
}
```

**解析：** 使用DFS遍历网格，找到与单词前缀匹配的起点，并递归搜索后续字符。使用临时变量保存当前字符，防止路径回溯时影响其他路径。

### 11. 设计模式：单例模式

**题目：** 实现单例模式，确保一个类只有一个实例，并提供一个全局访问点。

**示例：**

```text
输入： getInstance()
输出： 单例对象
```

**答案：** 使用懒汉式和饿汉式两种实现单例模式。

**懒汉式：**

```go
var instance *Singleton

func GetInstance() *Singleton {
    if instance == nil {
        instance = &Singleton{}
    }
    return instance
}
```

**饿汉式：**

```go
type Singleton struct {
    // 成员变量
}

var instance = &Singleton{}

func GetInstance() *Singleton {
    return instance
}
```

**解析：** 懒汉式在首次请求时创建单例对象，而饿汉式在程序启动时创建单例对象。两者都确保单例对象的全局唯一性。

### 12. 线程池：并发下载多个文件

**题目：** 使用线程池并发下载多个文件。

**示例：**

```text
输入：urls = ["http://example.com/file1", "http://example.com/file2", ...]
输出：[文件1，文件2，...]
```

**答案：** 使用Golang的`sync.Pool`实现线程池。

```go
type ThreadPool struct {
    jobs   chan func()
    workers int
}

func NewThreadPool(workers int) *ThreadPool {
    pool := &ThreadPool{
        jobs:   make(chan func(), 100),
        workers: workers,
    }
    for i := 0; i < workers; i++ {
        pool.startWorker()
    }
    return pool
}

func (pool *ThreadPool) Download(url string) {
    go func() {
        <-pool.jobs
        fmt.Println("开始下载", url)
        // 下载文件逻辑
        fmt.Println("完成下载", url)
        done()
    }()
}

func (pool *ThreadPool) startWorker() {
    for job := range pool.jobs {
        job()
    }
}

func done() {
    select {
    case job := <-jobs:
        job()
    default:
    }
}
```

**解析：** 使用一个工作队列和一个固定数量的工作线程。每个工作线程从队列中获取任务并执行，完成后重新放入队列等待下一个任务。

### 13. 字符串处理：最长公共前缀

**题目：** 给定一个字符串数组，找出最长公共前缀。

**示例：**

```text
输入：strs = ["flower", "flow", "flight"]
输出："fl"
```

**答案：** 使用分治策略找出最长公共前缀。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    return lcp(strs, 0, len(strs)-1)
}

func lcp(strs []string, left, right int) string {
    if left == right {
        return strs[left]
    }
    mid := (left + right) / 2
    lclp := lcp(strs, left, mid)
    lcrp := lcp(strs, mid+1, right)
    return minPrefix(lclp, lcrp)
}

func minPrefix(a, b string) string {
    minLen := min(len(a), len(b))
    for i := 0; i < minLen; i++ {
        if a[i] != b[i] {
            return a[:i]
        }
    }
    return a[:minLen]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 分治策略将问题分为左右两部分，递归找出最长公共前缀。最小公共前缀通过比较左右两部分的公共前缀来计算。

### 14. 排序算法：快速排序

**题目：** 实现快速排序算法。

**示例：**

```text
输入：arr = [3, 2, 1]
输出：[1, 2, 3]
```

**答案：** 快速排序通过分治策略将数组划分为两部分。

```go
func quickSort(arr []int, left, right int) {
    if left >= right {
        return
    }
    pivot := partition(arr, left, right)
    quickSort(arr, left, pivot-1)
    quickSort(arr, pivot+1, right)
}

func partition(arr []int, left, right int) int {
    pivot := arr[right]
    i := left
    for j := left; j < right; j++ {
        if arr[j] <= pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[right] = arr[right], arr[i]
    return i
}
```

**解析：** 快速排序通过选择一个基准元素（pivot），将数组划分为两部分，小于等于基准元素的放在左边，大于基准元素的放在右边。然后递归排序左右两部分。

### 15. 数学问题：求最大公约数

**题目：** 求两个整数的最大公约数。

**示例：**

```text
输入：a = 12, b = 18
输出：6
```

**答案：** 使用辗转相除法求最大公约数。

```go
func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

**解析：** 辗转相除法通过反复取余数，直到余数为0，此时的被除数即为最大公约数。

### 16. 设计模式：工厂模式

**题目：** 实现工厂模式，创建不同类型的对象。

**示例：**

```text
输入：type = "Car"
输出：Car对象
```

**答案：** 定义一个接口和具体实现。

```go
type Animal interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}
func (c Cat) Speak() string {
    return "Meow!"
}

type AnimalFactory struct{}

func (f *AnimalFactory) CreateAnimal(type string) Animal {
    switch type {
    case "Dog":
        return Dog{}
    case "Cat":
        return Cat{}
    default:
        return nil
    }
}
```

**解析：** 工厂模式通过定义一个创建对象的接口，将对象的创建委托给具体的工厂类，从而实现对象的创建和管理的解耦。

### 17. 网络编程：TCP客户端

**题目：** 使用Golang实现TCP客户端。

**示例：**

```text
输入：serverAddress = "localhost:8080"
输出：客户端与服务器通信的结果
```

**答案：**

```go
package main

import (
    "bytes"
    "fmt"
    "net"
)

func main() {
    serverAddress := "localhost:8080"
    conn, err := net.Dial("tcp", serverAddress)
    if err != nil {
        fmt.Println("连接失败：", err)
        return
    }
    defer conn.Close()

    message := "Hello, server!"
    _, err = conn.Write([]byte(message))
    if err != nil {
        fmt.Println("发送消息失败：", err)
        return
    }

    buffer := make([]byte, 1024)
    bytesRead, err := conn.Read(buffer)
    if err != nil {
        fmt.Println("读取消息失败：", err)
        return
    }

    response := string(buffer[:bytesRead])
    fmt.Println("服务器响应：", response)
}
```

**解析：** TCP客户端通过`net.Dial`函数建立连接，使用`conn.Write`发送消息，并通过`conn.Read`读取服务器响应。

### 18. 网络编程：HTTP服务器

**题目：** 使用Golang实现HTTP服务器。

**示例：**

```text
输入：请求地址为 "http://localhost:8080/"
输出：返回HTTP响应
```

**答案：**

```go
package main

import (
    "fmt"
    "net/http"
)

func homePage(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    http.HandleFunc("/", homePage)
    http.ListenAndServe(":8080", nil)
}
```

**解析：** HTTP服务器通过`http.HandleFunc`注册处理函数，并使用`http.ListenAndServe`监听并处理HTTP请求。

### 19. 集合：哈希表

**题目：** 实现一个简单的哈希表。

**示例：**

```text
输入：{"apple", "banana", "orange"}
输出：哈希表结构
```

**答案：**

```go
package main

import "fmt"

type HashTable struct {
    size int
    table []map[int]interface{}
}

func NewHashTable(size int) *HashTable {
    return &HashTable{
        size: size,
        table: make([]map[int]interface{}, size),
    }
}

func (h *HashTable) Put(key int, value interface{}) {
    index := hash(key, h.size)
    if h.table[index] == nil {
        h.table[index] = make(map[int]interface{})
    }
    h.table[index][key] = value
}

func (h *HashTable) Get(key int) (interface{}, bool) {
    index := hash(key, h.size)
    if h.table[index] == nil {
        return nil, false
    }
    value, exists := h.table[index][key]
    return value, exists
}

func hash(key int, size int) int {
    return key % size
}

func main() {
    hashTable := NewHashTable(10)
    hashTable.Put(1, "apple")
    hashTable.Put(2, "banana")
    hashTable.Put(3, "orange")

    fmt.Println(hashTable.Get(1))
    fmt.Println(hashTable.Get(2))
    fmt.Println(hashTable.Get(3))
}
```

**解析：** 哈希表通过哈希函数将键映射到数组索引，使用数组存储键值对。`Put` 方法插入键值对，`Get` 方法获取键对应的值。

### 20. 设计模式：策略模式

**题目：** 使用策略模式实现不同计价策略。

**示例：**

```text
输入：订购商品数量
输出：根据计价策略计算的总价
```

**答案：**

```go
package main

import "fmt"

type Strategy interface {
    CalculatePrice(count int) float64
}

type FixedPriceStrategy struct {
    price float64
}

func (f *FixedPriceStrategy) CalculatePrice(count int) float64 {
    return f.price * float64(count)
}

type DiscountPriceStrategy struct {
    price float64
    discount float64
}

func (d *DiscountPriceStrategy) CalculatePrice(count int) float64 {
    return f.price * float64(count) * (1 - d.discount)
}

func main() {
    fixedPrice := &FixedPriceStrategy{price: 10.0}
    discountPrice := &DiscountPriceStrategy{price: 10.0, discount: 0.1}

    fmt.Println(fixedPrice.CalculatePrice(2))
    fmt.Println(discountPrice.CalculatePrice(2))
}
```

**解析：** 策略模式通过定义一个接口和具体实现，将不同的计价策略抽象出来，可以在运行时动态切换计价策略。

### 21. 图算法：最短路径

**题目：** 使用Dijkstra算法求单源最短路径。

**示例：**

```text
输入：graph = [[0, 4, 0, 0, 0], [4, 0, 8, 0, 0], [0, 8, 0, 2, 6], [0, 0, 2, 0, 3], [0, 0, 6, 3, 0]]
输出：[0, 4, 8, 2, 3]
```

**答案：**

```go
package main

import (
    "fmt"
)

func dijkstra(graph [][]int, start int) []int {
    n := len(graph)
    distances := make([]int, n)
    for i := range distances {
        distances[i] = math.MaxInt64
    }
    distances[start] = 0
    visited := make([]bool, n)

    for i := 0; i < n; i++ {
        minDistance := math.MaxInt64
        minIndex := -1

        for j, dist := range distances {
            if !visited[j] && dist < minDistance {
                minDistance = dist
                minIndex = j
            }
        }

        if minIndex == -1 {
            break
        }

        visited[minIndex] = true

        for j := 0; j < n; j++ {
            if !visited[j] {
                alt := distances[minIndex] + graph[minIndex][j]
                if alt < distances[j] {
                    distances[j] = alt
                }
            }
        }
    }

    return distances
}

func main() {
    graph := [][]int{
        {0, 4, 0, 0, 0},
        {4, 0, 8, 0, 0},
        {0, 8, 0, 2, 6},
        {0, 0, 2, 0, 3},
        {0, 0, 6, 3, 0},
    }

    distances := dijkstra(graph, 0)
    fmt.Println(distances)
}
```

**解析：** Dijkstra算法通过优先队列选出未访问节点中距离最短的节点，更新其他节点的距离。算法结束后，得到从起始点到其他所有节点的最短路径。

### 22. 算法与数据结构：堆排序

**题目：** 实现堆排序算法。

**示例：**

```text
输入：arr = [3, 2, 1, 4, 5]
输出：[1, 2, 3, 4, 5]
```

**答案：**

```go
package main

import (
    "fmt"
)

func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func heapSort(arr []int) {
    n := len(arr)

    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func main() {
    arr := []int{3, 2, 1, 4, 5}
    heapSort(arr)
    fmt.Println(arr)
}
```

**解析：** 堆排序通过构建最大堆，将堆顶元素（最大值）交换到数组末尾，然后对剩余部分重新构建最大堆，重复此过程直到整个数组有序。

### 23. 字符串处理：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**示例：**

```text
输入：text1 = "ABCD", text2 = "ACDF"
输出："ACD"
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    result := make([]byte, dp[m][n])
    index := dp[m][n]
    for i := m; i > 0 && index > 0; i-- {
        for j := n; j > 0 && index > 0; j-- {
            if text1[i-1] == text2[j-1] {
                result[index-1] = text1[i-1]
                index--
                i--
                j--
            } else if dp[i-1][j] > dp[i][j-1] {
                i--
            } else {
                j--
            }
        }
    }

    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    fmt.Println(longestCommonSubsequence(text1, text2))
}
```

**解析：** 动态规划通过构建一个二维数组 `dp`，计算两个字符串的最长公共子序列长度。然后通过回溯找到最长公共子序列。

### 24. 设计模式：观察者模式

**题目：** 使用观察者模式实现股票价格监控系统。

**示例：**

```text
输入：股票代码 "AAPL"
输出：股票价格变动通知
```

**答案：**

```go
package main

import (
    "fmt"
)

type StockSubject struct {
    observers map[string]func(string, float64)
}

func NewStockSubject() *StockSubject {
    return &StockSubject{
        observers: make(map[string]func(string, float64)),
    }
}

func (s *StockSubject) Register(observer string, handler func(string, float64)) {
    s.observers[observer] = handler
}

func (s *StockSubject) Notify(code string, price float64) {
    if handler, exists := s.observers[code]; exists {
        handler(code, price)
    }
}

type StockObserver struct {
    name string
}

func (s *StockObserver) Update(code string, price float64) {
    fmt.Printf("%s: Stock price of %s is %f\n", s.name, code, price)
}

func NewStockObserver(name string) *StockObserver {
    return &StockObserver{
        name: name,
    }
}

func main() {
    stockSubject := NewStockSubject()
    appleObserver := NewStockObserver("Apple Observer")
    stockSubject.Register("AAPL", appleObserver.Update)

    stockSubject.Notify("AAPL", 150.0)
}
```

**解析：** 观察者模式通过 `StockSubject` 类维护一个观察者列表，当股票价格发生变化时，通知所有注册的观察者。

### 25. 数学问题：逆波兰表达式求值

**题目：** 计算逆波兰表达式的值。

**示例：**

```text
输入：tokens = ["2", "1", "+", "3", "*"]
输出：9
```

**答案：**

```go
package main

import (
    "fmt"
)

func evaluateRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/b)
        default:
            stack = append(stack, convertToInt(token))
        }
    }
    return stack[0]
}

func convertToInt(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    result := 0
    for _, digit := range token {
        result = result*10 + int(digit-'0')
    }
    return result * sign
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    fmt.Println(evaluateRPN(tokens))
}
```

**解析：** 逆波兰表达式求值通过使用栈，按照运算符的优先级进行计算。

### 26. 算法与数据结构：并查集

**题目：** 使用并查集实现连通分量。

**示例：**

```text
输入：edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 0], [1, 4]]
输出：5
```

**答案：**

```go
package main

import (
    "fmt"
)

type UnionFind struct {
    parent []int
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    for i := range parent {
        parent[i] = i
    }
    return &UnionFind{parent}
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) {
    rootX := uf.Find(x)
    rootY := uf.Find(y)
    if rootX != rootY {
        uf.parent[rootX] = rootY
    }
}

func countComponents(n int, edges [][]int) int {
    uf := NewUnionFind(n)
    for _, edge := range edges {
        uf.Union(edge[0], edge[1])
    }
    visited := make(map[int]bool)
    count := 0
    for i := 0; i < n; i++ {
        if !visited[uf.Find(i)] {
            visited[uf.Find(i)] = true
            count++
        }
    }
    return count
}

func main() {
    edges := [][]int{{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 0}, {1, 4}}
    fmt.Println(countComponents(5, edges))
}
```

**解析：** 并查集通过合并和查找操作，将连通分量中的元素合并到同一集合中。

### 27. 算法与数据结构：平衡二叉树

**题目：** 判断一棵二叉树是否为平衡二叉树。

**示例：**

```text
输入：root = [3, 9, 20, null, null, 15, 7]
输出：true
```

**答案：**

```go
package main

import (
    "fmt"
)

func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    leftHeight, rightHeight := getHeight(root.Left), getHeight(root.Right)
    if abs(leftHeight-rightHeight) > 1 {
        return false
    }
    return isBalanced(root.Left) && isBalanced(root.Right)
}

func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    leftHeight, rightHeight := getHeight(node.Left), getHeight(node.Right)
    return max(leftHeight, rightHeight) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func main() {
    root := &TreeNode{Val: 3}
    root.Left = &TreeNode{Val: 9}
    root.Right = &TreeNode{Val: 20}
    root.Right.Left = &TreeNode{Val: 15}
    root.Right.Right = &TreeNode{Val: 7}
    fmt.Println(isBalanced(root))
}
```

**解析：** 平衡二叉树通过递归计算每个节点的左右子树高度差，判断是否大于1。

### 28. 字符串处理：最长公共前缀

**题目：** 给定多个字符串，找出它们的最长公共前缀。

**示例：**

```text
输入：strs = ["flower", "flow", "flight"]
输出："fl"
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs))
}
```

**解析：** 最长公共前缀通过逐个比较字符串的前缀，直到找到不同字符。

### 29. 算法与数据结构：堆

**题目：** 实现一个小顶堆。

**示例：**

```text
输入：arr = [3, 2, 1, 4, 5]
输出：[1, 2, 3, 4, 5]
```

**答案：**

```go
package main

import (
    "fmt"
)

func siftDown(arr []int, i, n int) {
    min := i
    l := 2*i + 1
    r := 2*i + 2

    if l < n && arr[l] < arr[min] {
        min = l
    }

    if r < n && arr[r] < arr[min] {
        min = r
    }

    if min != i {
        arr[i], arr[min] = arr[min], arr[i]
        siftDown(arr, min, n)
    }
}

func buildHeap(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i >= 0; i-- {
        siftDown(arr, i, n)
    }
}

func main() {
    arr := []int{3, 2, 1, 4, 5}
    buildHeap(arr)
    fmt.Println(arr)
}
```

**解析：** 堆通过 siftDown 函数保持堆的性质，buildHeap 函数构建一个小顶堆。

### 30. 算法与数据结构：队列

**题目：** 使用链表实现队列。

**示例：**

```text
输入：["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：[null, null, null, 1, 2, false]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    Val  int
    Next *Node
}

type MyQueue struct {
    front *Node
    rear  *Node
}

func Constructor() MyQueue {
    return MyQueue{}
}

func (q *MyQueue) Push(x int) {
    node := &Node{Val: x}
    if q.rear == nil {
        q.front = node
    } else {
        q.rear.Next = node
    }
    q.rear = node
}

func (q *MyQueue) Pop() int {
    if q.front == nil {
        return -1
    }
    val := q.front.Val
    q.front = q.front.Next
    if q.front == nil {
        q.rear = nil
    }
    return val
}

func (q *MyQueue) Peek() int {
    if q.front == nil {
        return -1
    }
    return q.front.Val
}

func (q *MyQueue) Empty() bool {
    return q.front == nil
}

func main() {
    q := Constructor()
    q.Push(1)
    q.Push(2)
    fmt.Println(q.Peek())
    fmt.Println(q.Pop())
    fmt.Println(q.Empty())
}
```

**解析：** 队列通过链表实现，使用 `front` 和 `rear` 指针分别指向队列的头和尾。

### 31. 字符串处理：最长重复子串

**题目：** 给定一个字符串，找出最长重复子串。

**示例：**

```text
输入：s = "banana"
输出："ana"
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestRepeatingSubstring(s string) string {
    n := len(s)
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    maxLen, endIndex := 0, 0
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            if s[i] == s[j] && (j-i == 1 || dp[i][j-1] > 0) {
                dp[i][j] = dp[i][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = j
                }
            }
        }
    }
    return s[endIndex-maxLen+1 : endIndex+1]
}

func main() {
    s := "banana"
    fmt.Println(longestRepeatingSubstring(s))
}
```

**解析：** 使用动态规划计算最长重复子串的长度，然后通过索引找到最长重复子串。

### 32. 算法与数据结构：哈希表

**题目：** 实现一个哈希表。

**示例：**

```text
输入：["MyHashMap", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[], [1, 1], [2, 4], [1], [3, 6], [3], [4, 7], [4], [9], [9]]
输出：[null, null, null, 1, null, 6, null, 7, -1, -1]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    key   int
    value int
    next  *Node
}

type MyHashMap struct {
    buckets []*Node
    size    int
}

func Constructor() MyHashMap {
    return MyHashMap{
        buckets: make([]*Node, 1000),
        size:    0,
    }
}

func (m *MyHashMap) hash(key int) int {
    return key % 1000
}

func (m *MyHashMap) put(key int, value int) {
    index := m.hash(key)
    node := &Node{key: key, value: value}
    if m.buckets[index] == nil {
        m.buckets[index] = node
        m.size++
    } else {
        prev, curr := m.buckets[index], m.buckets[index]
        for curr != nil && curr.key != key {
            prev = curr
            curr = curr.next
        }
        if curr != nil {
            curr.value = value
        } else {
            prev.next = node
            m.size++
        }
    }
}

func (m *MyHashMap) get(key int) int {
    index := m.hash(key)
    curr := m.buckets[index]
    for curr != nil && curr.key != key {
        curr = curr.next
    }
    if curr != nil {
        return curr.value
    }
    return -1
}

func main() {
    m := Constructor()
    m.put(1, 1)
    m.put(2, 4)
    fmt.Println(m.get(1))
    m.put(3, 6)
    fmt.Println(m.get(3))
    m.put(4, 7)
    fmt.Println(m.get(4))
    fmt.Println(m.get(9))
}
```

**解析：** 哈希表通过数组实现，使用哈希函数将键映射到数组索引，使用链表处理冲突。

### 33. 算法与数据结构：双向链表

**题目：** 使用双向链表实现迭代器和反转迭代器。

**示例：**

```text
输入：["MyDoubleLinkedList", "addAtHead", "addAtTail", "addAtIndex", "deleteAtIndex", "get", "reverse"]
[[], [7], [], [3, 2], [], [5, 6], [], [], [], [], 2, []]
输出：[null, null, null, null, null, 3, 6, 5]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    Val  int
    Prev *Node
    Next *Node
}

type MyDoubleLinkedList struct {
    head *Node
    tail *Node
}

func Constructor() MyDoubleLinkedList {
    return MyDoubleLinkedList{head: &Node{}, tail: &Node{}}
}

func (l *MyDoubleLinkedList) addAtHead(val int) {
    node := &Node{Val: val, Next: l.head.Next}
    l.head.Next = node
    if l.tail == l.head {
        l.tail = node
    }
}

func (l *MyDoubleLinkedList) addAtTail(val int) {
    node := &Node{Val: val, Prev: l.tail.Prev}
    l.tail.Prev = node
    if l.head == l.tail {
        l.head = node
    }
}

func (l *MyDoubleLinkedList) addAtIndex(index int, val int) {
    if index < 0 {
        l.addAtHead(val)
        return
    }
    if index == len(l.toList()) {
        l.addAtTail(val)
        return
    }
    node := &Node{Val: val}
    prev := l.head
    for i := 0; i < index; i++ {
        prev = prev.Next
    }
    next := prev.Next
    prev.Next = node
    node.Prev = prev
    node.Next = next
    if next != nil {
        next.Prev = node
    }
}

func (l *MyDoubleLinkedList) deleteAtIndex(index int) {
    if index < 0 || index >= len(l.toList()) {
        return
    }
    prev := l.head
    for i := 0; i < index; i++ {
        prev = prev.Next
    }
    next := prev.Next
    if next == nil {
        l.tail = prev
    } else {
        next.Prev = prev
    }
    prev.Next = next
}

func (l *MyDoubleLinkedList) get(index int) int {
    if index < 0 || index >= len(l.toList()) {
        return -1
    }
    node := l.head
    for i := 0; i < index; i++ {
        node = node.Next
    }
    return node.Val
}

func (l *MyDoubleLinkedList) toList() []int {
    result := []int{}
    node := l.head.Next
    for node != nil {
        result = append(result, node.Val)
        node = node.Next
    }
    return result
}

func main() {
    l := Constructor()
    l.addAtHead(7)
    l.addAtTail(2)
    l.addAtIndex(3, 1)
    l.deleteAtIndex(2)
    fmt.Println(l.get(0))
    l.reverse()
    fmt.Println(l.get(0))
}
```

**解析：** 双向链表通过维护头节点和尾节点，支持在任意位置添加和删除节点。反转迭代器通过改变节点的 `Prev` 和 `Next` 指针来实现。

### 34. 算法与数据结构：并查集

**题目：** 使用并查集实现并查集操作。

**示例：**

```text
输入：["UnionFind", "find", "isConnected", "unionElements", "find", "connectedComponents"]
[[], [5], [], [2, 3], [], [2, 3, 4], [], [], []]
输出：[null, 0, true, null, 1, [2, 3, 4]]
```

**答案：**

```go
package main

import (
    "fmt"
)

type UnionFind struct {
    parent []int
    size   []int
}

func Constructor(n int) UnionFind {
    parent := make([]int, n)
    size := make([]int, n)
    for i := range parent {
        parent[i] = i
        size[i] = 1
    }
    return UnionFind{parent, size}
}

func (uf *UnionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) isConnected(x int, y int) bool {
    return uf.find(x) == uf.find(y)
}

func (uf *UnionFind) unionElements(x int, y int) {
    rootX := uf.find(x)
    rootY := uf.find(y)
    if rootX != rootY {
        if uf.size[rootX] < uf.size[rootY] {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        } else {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        }
    }
}

func (uf *UnionFind) connectedComponents(n int, edges [][]int) [][]int {
    uf.unionElements(edges[0][0], edges[0][1])
    uf.unionElements(edges[1][0], edges[1][1])
    uf.unionElements(edges[2][0], edges[2][1])
    result := make([][]int, 0)
    for i := 0; i < n; i++ {
        root := uf.find(i)
        found := false
        for j := 0; j < len(result); j++ {
            if root == result[j][0] {
                result[j] = append(result[j], i)
                found = true
                break
            }
        }
        if !found {
            result = append(result, []int{root, i})
        }
    }
    return result
}

func main() {
    uf := Constructor(5)
    fmt.Println(uf.find(0))
    fmt.Println(uf.isConnected(0, 1))
    uf.unionElements(0, 1)
    fmt.Println(uf.connectedComponents(5, [][]int{{0, 1}, {0, 2}, {0, 3}}))
}
```

**解析：** 并查集通过查找和合并操作实现连通性判断。`find` 方法递归查找根节点，`unionElements` 方法合并两个连通分量。

### 35. 算法与数据结构：堆

**题目：** 使用堆实现优先队列。

**示例：**

```text
输入：["PQ", "enqueue", "enqueue", "enqueue", "dequeue", "dequeue", "dequeue"]
[[], [4], [2], [3], [], [], []]
输出：[null, null, null, null, 1, 2, 3]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    Val  int
    Index int
}

type MyPriorityQueue struct {
    heap []*Node
    size int
}

func Constructor() MyPriorityQueue {
    return MyPriorityQueue{heap: make([]*Node, 1)}
}

func (pq *MyPriorityQueue) enqueue(val int) {
    node := &Node{Val: val, Index: pq.size}
    pq.heap = append(pq.heap, node)
    pq.size++
    siftUp(pq)
}

func (pq *MyPriorityQueue) dequeue() int {
    if pq.size == 0 {
        return -1
    }
    result := pq.heap[1].Val
    pq.heap[1] = pq.heap[pq.size-1]
    pq.heap[pq.size-1] = nil
    pq.size--
    siftDown(pq)
    return result
}

func (pq *MyPriorityQueue) siftUp() {
    i := pq.size - 1
    node := pq.heap[i]
    for i > 0 && node.Val < pq.heap[(i-1)/2].Val {
        pq.heap[i], pq.heap[(i-1)/2] = pq.heap[(i-1)/2], pq.heap[i]
        i = (i - 1) / 2
    }
}

func (pq *MyPriorityQueue) siftDown() {
    i := 1
    node := pq.heap[i]
    for {
        left := 2*i
        right := 2*i + 1
        if left >= pq.size {
            break
        }
        largest := left
        if right < pq.size && pq.heap[right].Val < pq.heap[largest].Val {
            largest = right
        }
        if node.Val < pq.heap[largest].Val {
            break
        }
        pq.heap[i], pq.heap[largest] = pq.heap[largest], pq.heap[i]
        i = largest
    }
}

func main() {
    pq := Constructor()
    pq.enqueue(4)
    pq.enqueue(2)
    pq.enqueue(3)
    fmt.Println(pq.dequeue())
    fmt.Println(pq.dequeue())
    fmt.Println(pq.dequeue())
}
```

**解析：** 优先队列使用小顶堆实现，通过 siftUp 和 siftDown 保持堆的性质。

### 36. 字符串处理：最长公共前缀

**题目：** 给定多个字符串，找出它们的最长公共前缀。

**示例：**

```text
输入：strs = ["flower", "flow", "flight"]
输出："fl"
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs))
}
```

**解析：** 最长公共前缀通过比较字符串的前缀，找到最长公共前缀。

### 37. 设计模式：观察者模式

**题目：** 实现一个天气系统，使用观察者模式。

**示例：**

```text
输入：["WeatherData", "registerObserver", "registerObserver", "changeTemperature", "getTemperature"]
[[], ["TemperatureObserver", 1], ["RainObserver", 2], [2], []]
输出：[null, null, null, 2, 2]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Observer interface {
    Update(data float64)
}

type Subject struct {
    observers map[Observer]struct{}
    value     float64
}

func NewSubject() *Subject {
    return &Subject{
        observers: make(map[Observer]struct{}),
    }
}

func (s *Subject) Register(observer Observer) {
    s.observers[observer] = struct{}{}
}

func (s *Subject) Unregister(observer Observer) {
    delete(s.observers, observer)
}

func (s *Subject) Notify() {
    for observer := range s.observers {
        observer.Update(s.value)
    }
}

func (s *Subject) SetTemperature(value float64) {
    s.value = value
    s.Notify()
}

type TemperatureObserver struct {
    id int
}

func (t *TemperatureObserver) Update(data float64) {
    fmt.Printf("TemperatureObserver %d: %f\n", t.id, data)
}

func NewTemperatureObserver(id int) *TemperatureObserver {
    return &TemperatureObserver{id: id}
}

type RainObserver struct {
    id int
}

func (r *RainObserver) Update(data float64) {
    fmt.Printf("RainObserver %d: %f\n", r.id, data)
}

func NewRainObserver(id int) *RainObserver {
    return &RainObserver{id: id}
}

func main() {
    subject := NewSubject()
    observer1 := NewTemperatureObserver(1)
    observer2 := NewRainObserver(2)
    subject.Register(observer1)
    subject.Register(observer2)
    subject.SetTemperature(2)
}
```

**解析：** 观察者模式通过 Subject 维护观察者列表，当状态变化时通知所有观察者。

### 38. 字符串处理：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**示例：**

```text
输入：text1 = "ABCD", text2 = "ACDF"
输出："ACD"
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    result := make([]byte, dp[m][n])
    index := dp[m][n]
    for i := m; i > 0 && index > 0; i-- {
        for j := n; j > 0 && index > 0; j-- {
            if text1[i-1] == text2[j-1] {
                result[index-1] = text1[i-1]
                index--
                i--
                j--
            } else if dp[i-1][j] > dp[i][j-1] {
                i--
            } else {
                j--
            }
        }
    }

    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    fmt.Println(longestCommonSubsequence(text1, text2))
}
```

**解析：** 最长公共子序列使用动态规划计算两个字符串的子序列长度，然后通过回溯找到最长公共子序列。

### 39. 设计模式：工厂模式

**题目：** 实现工厂模式，根据参数创建不同类型的对象。

**示例：**

```text
输入：type = "Car"
输出：Car对象
```

**答案：**

```go
package main

import (
    "fmt"
)

type Animal interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}
func (c Cat) Speak() string {
    return "Meow!"
}

type AnimalFactory struct {
    animal Animal
}

func NewAnimalFactory(type string) *AnimalFactory {
    switch type {
    case "Dog":
        return &AnimalFactory{animal: Dog{}}
    case "Cat":
        return &AnimalFactory{animal: Cat{}}
    default:
        return nil
    }
}

func (f *AnimalFactory) GetAnimal() Animal {
    return f.animal
}

func main() {
    factory := NewAnimalFactory("Dog")
    animal := factory.GetAnimal()
    fmt.Println(animal.Speak())
}
```

**解析：** 工厂模式通过定义接口和具体实现，使用工厂类创建对象，实现对象创建的解耦。

### 40. 算法与数据结构：优先队列

**题目：** 使用优先队列实现最小堆。

**示例：**

```text
输入：["PQ", "enqueue", "enqueue", "enqueue", "dequeue", "dequeue", "dequeue"]
[[], [4], [2], [3], [], [], []]
输出：[null, null, null, null, 2, 3, 4]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    Val  int
    Index int
}

type MyPQ struct {
    heap []*Node
    size int
}

func Constructor() MyPQ {
    return MyPQ{heap: make([]*Node, 1)}
}

func (pq *MyPQ) enqueue(val int) {
    node := &Node{Val: val, Index: pq.size}
    pq.heap = append(pq.heap, node)
    pq.size++
    siftUp(pq)
}

func (pq *MyPQ) dequeue() int {
    if pq.size == 0 {
        return -1
    }
    result := pq.heap[1].Val
    pq.heap[1] = pq.heap[pq.size-1]
    pq.heap[pq.size-1] = nil
    pq.size--
    siftDown(pq)
    return result
}

func (pq *MyPQ) siftUp() {
    i := pq.size - 1
    node := pq.heap[i]
    for i > 0 && node.Val < pq.heap[(i-1)/2].Val {
        pq.heap[i], pq.heap[(i-1)/2] = pq.heap[(i-1)/2], pq.heap[i]
        i = (i - 1) / 2
    }
}

func (pq *MyPQ) siftDown() {
    i := 1
    node := pq.heap[i]
    for {
        left := 2 * i
        right := 2 * i + 1
        if left >= pq.size {
            break
        }
        largest := left
        if right < pq.size && pq.heap[right].Val < pq.heap[largest].Val {
            largest = right
        }
        if node.Val < pq.heap[largest].Val {
            break
        }
        pq.heap[i], pq.heap[largest] = pq.heap[largest], pq.heap[i]
        i = largest
    }
}

func main() {
    pq := Constructor()
    pq.enqueue(4)
    pq.enqueue(2)
    pq.enqueue(3)
    fmt.Println(pq.dequeue())
    fmt.Println(pq.dequeue())
    fmt.Println(pq.dequeue())
}
```

**解析：** 最小堆通过 siftUp 和 siftDown 函数保持堆的性质，enqueue 向堆中添加元素，dequeue 移除堆顶元素。

### 41. 设计模式：策略模式

**题目：** 实现策略模式，根据策略计算总价。

**示例：**

```text
输入：items = [{item: "apple", price: 0.5}, {item: "banana", price: 0.6}, {item: "orange", price: 0.4}]
输出：3.5
```

**答案：**

```go
package main

import (
    "fmt"
)

type DiscountStrategy interface {
    CalculateTotal(items []Item) float64
}

type FixedDiscountStrategy struct {
    discount float64
}

func (f *FixedDiscountStrategy) CalculateTotal(items []Item) float64 {
    total := 0.0
    for _, item := range items {
        total += item.price
    }
    return total * f.discount
}

type PercentageDiscountStrategy struct {
    discount float64
}

func (p *PercentageDiscountStrategy) CalculateTotal(items []Item) float64 {
    total := 0.0
    for _, item := range items {
        total += item.price
    }
    return total - (total * p.discount/100)
}

type Item struct {
    item   string
    price  float64
}

func main() {
    items := []Item{
        {item: "apple", price: 0.5},
        {item: "banana", price: 0.6},
        {item: "orange", price: 0.4},
    }

    strategy1 := &FixedDiscountStrategy{discount: 0.1}
    strategy2 := &PercentageDiscountStrategy{discount: 10}

    fmt.Println(strategy1.CalculateTotal(items))
    fmt.Println(strategy2.CalculateTotal(items))
}
```

**解析：** 策略模式定义了策略接口和具体策略实现，根据策略计算总价。

### 42. 算法与数据结构：堆

**题目：** 使用堆实现排序。

**示例：**

```text
输入：arr = [3, 2, 1, 4, 5]
输出：[1, 2, 3, 4, 5]
```

**答案：**

```go
package main

import (
    "fmt"
)

func heapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func buildHeap(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }
}

func heapSort(arr []int) {
    n := len(arr)
    buildHeap(arr)
    for i := n - 1; i >= 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func main() {
    arr := []int{3, 2, 1, 4, 5}
    heapSort(arr)
    fmt.Println(arr)
}
```

**解析：** 堆排序通过构建最大堆，将堆顶元素交换到数组末尾，然后对剩余部分重新构建最大堆。

### 43. 字符串处理：实现字符串查找算法

**题目：** 给定一个字符串 `txt` 和一个子串 `pat`，实现字符串查找算法。

**示例：**

```text
输入：txt = "abcabcdabc", pat = "abcd"
输出：[0, 3]
```

**答案：**

```go
package main

import (
    "fmt"
)

func search(txt, pat string) []int {
    n, m := len(txt), len(pat)
    results := []int{}
    for i := 0; i <= n-m; i++ {
        j := 0
        for j < m {
            if txt[i+j] != pat[j] {
                break
            }
            j++
        }
        if j == m {
            results = append(results, i)
        }
    }
    return results
}

func main() {
    txt := "abcabcdabc"
    pat := "abcd"
    fmt.Println(search(txt, pat))
}
```

**解析：** 字符串查找算法通过遍历字符串 `txt`，对于每个位置检查子串 `pat` 是否匹配。

### 44. 算法与数据结构：并查集

**题目：** 使用并查集实现连通性判断。

**示例：**

```text
输入：["UnionFind", "find", "isConnected", "unionElements", "find", "connectedComponents"]
[[], [5], [], [2, 3], [], [2, 3, 4], [], [], []]
输出：[null, 0, true, null, 1, [2, 3, 4]]
```

**答案：**

```go
package main

import (
    "fmt"
)

type UnionFind struct {
    parent []int
    size   []int
}

func Constructor(n int) UnionFind {
    parent := make([]int, n)
    size := make([]int, n)
    for i := range parent {
        parent[i] = i
        size[i] = 1
    }
    return UnionFind{parent, size}
}

func (uf *UnionFind) find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) isConnected(x int, y int) bool {
    return uf.find(x) == uf.find(y)
}

func (uf *UnionFind) unionElements(x int, y int) {
    rootX := uf.find(x)
    rootY := uf.find(y)
    if rootX != rootY {
        if uf.size[rootX] < uf.size[rootY] {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        } else {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        }
    }
}

func (uf *UnionFind) connectedComponents(n int, edges [][]int) [][]int {
    uf.unionElements(edges[0][0], edges[0][1])
    uf.unionElements(edges[1][0], edges[1][1])
    uf.unionElements(edges[2][0], edges[2][1])
    result := make([][]int, 0)
    for i := 0; i < n; i++ {
        root := uf.find(i)
        found := false
        for j := 0; j < len(result); j++ {
            if root == result[j][0] {
                result[j] = append(result[j], i)
                found = true
                break
            }
        }
        if !found {
            result = append(result, []int{root, i})
        }
    }
    return result
}

func main() {
    uf := Constructor(5)
    fmt.Println(uf.find(0))
    fmt.Println(uf.isConnected(0, 1))
    uf.unionElements(0, 1)
    fmt.Println(uf.connectedComponents(5, [][]int{{0, 1}, {0, 2}, {0, 3}}))
}
```

**解析：** 并查集通过查找和合并操作实现连通性判断，`find` 方法递归查找根节点，`unionElements` 方法合并两个连通分量。

### 45. 算法与数据结构：双向链表

**题目：** 使用双向链表实现双向循环队列。

**示例：**

```text
输入：["MyCircularDeque", "insertFront", "insertLast", "deleteFront", "deleteLast", "getFront", "getRear"]
[[], [3, 1], [2, 2], [], [], [], []]
输出：[null, true, true, true, false, 1, 2]
```

**答案：**

```go
package main

import (
    "fmt"
)

type Node struct {
    Val  int
    Prev *Node
    Next *Node
}

type MyCircularDeque struct {
    head *Node
    tail *Node
    size int
    capacity int
}

func Constructor(k int) MyCircularDeque {
    return MyCircularDeque{
        head: &Node{},
        tail: &Node{},
        size: 0,
        capacity: k,
    }
}

func (deque *MyCircularDeque) insertFront(value int) bool {
    if deque.size == deque.capacity {
        return false
    }
    node := &Node{Val: value}
    node.Prev = deque.tail
    node.Next = deque.head
    deque.head.Prev = node
    deque.tail.Next = node
    deque.head = node
    deque.size++
    return true
}

func (deque *MyCircularDeque) insertLast(value int) bool {
    if deque.size == deque.capacity {
        return false
    }
    node := &Node{Val: value}
    node.Prev = deque.tail.Prev
    node.Next = deque.tail
    deque.tail.Prev.Next = node
    deque.tail.Prev = node
    deque.tail = node
    deque.size++
    return true
}

func (deque *MyCircularDeque) deleteFront() bool {
    if deque.size == 0 {
        return false
    }
    deque.head = deque.head.Next
    deque.head.Prev = deque.tail
    deque.size--
    return true
}

func (deque *MyCircularDeque) deleteLast() bool {
    if deque.size == 0 {
        return false
    }
    deque.tail = deque.tail.Prev
    deque.tail.Next = deque.head
    deque.size--
    return true
}

func (deque *MyCircularDeque) getFront() int {
    if deque.size == 0 {
        return -1
    }
    return deque.head.Val
}

func (deque *MyCircularDeque) getRear() int {
    if deque.size == 0 {
        return -1
    }
    return deque.tail.Val
}

func main() {
    deque := Constructor(3)
    fmt.Println(deque.insertFront(1))
    fmt.Println(deque.insertLast(2))
    fmt.Println(deque.deleteFront())
    fmt.Println(deque.deleteLast())
    fmt.Println(deque.getFront())
    fmt.Println(deque.getRear())
}
```

**解析：** 双向循环队列通过双向链表实现，使用头节点和尾节点维护队首和队尾。

### 46. 设计模式：工厂方法模式

**题目：** 使用工厂方法模式创建不同类型的对象。

**示例：**

```text
输入：type = "Car"
输出：Car对象
```

**答案：**

```go
package main

import (
    "fmt"
)

type Animal interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}
func (c Cat) Speak() string {
    return "Meow!"
}

type AnimalFactory struct {
    factoryMap map[string]func() Animal
}

func NewAnimalFactory() *AnimalFactory {
    factory := &AnimalFactory{
        factoryMap: make(map[string]func() Animal),
    }
    factory.factoryMap["Dog"] = func() Animal { return Dog{} }
    factory.factoryMap["Cat"] = func() Animal { return Cat{} }
    return factory
}

func (f *AnimalFactory) CreateAnimal(type string) Animal {
    if creator, exists := f.factoryMap[type]; exists {
        return creator()
    }
    return nil
}

func main() {
    factory := NewAnimalFactory()
    animal := factory.CreateAnimal("Dog")
    fmt.Println(animal.Speak())
}
```

**解析：** 工厂方法模式通过定义接口和具体实现，使用工厂类创建对象，实现对象创建的解耦。

### 47. 字符串处理：最长公共前缀

**题目：** 给定多个字符串，找出它们的最长公共前缀。

**示例：**

```text
输入：strs = ["flower", "flow", "flight"]
输出："fl"
```

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs))
}
```

**解析：** 最长公共前缀通过比较字符串的前缀，找到最长公共前缀。

### 48. 设计模式：策略模式

**题目：** 使用策略模式实现不同的排序策略。

**示例：**

```text
输入：data = [3, 2, 1]
输出：[1, 2, 3]
```

**答案：**

```go
package main

import (
    "fmt"
)

type SortStrategy interface {
    Sort(data []int)
}

type BubbleSort struct{}

func (b *BubbleSort) Sort(data []int) {
    n := len(data)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if data[j] > data[j+1] {
                data[j], data[j+1] = data[j+1], data[j]
            }
        }
    }
}

type QuickSort struct{}

func (q *QuickSort) Sort(data []int) {
    quickSort(data, 0, len(data)-1)
}

func quickSort(data []int, low, high int) {
    if low < high {
        pi := partition(data, low, high)
        quickSort(data, low, pi-1)
        quickSort(data, pi+1, high)
    }
}

func partition(data []int, low, high int) int {
    pivot := data[high]
    i := low
    for j := low; j < high; j++ {
        if data[j] < pivot {
            data[i], data[j] = data[j], data[i]
            i++
        }
    }
    data[i], data[high] = data[high], data[i]
    return i
}

func main() {
    data := []int{3, 2, 1}
    sorter := &BubbleSort{}
    sorter.Sort(data)
    fmt.Println(data)

    data = []int{3, 2, 1}
    sorter = &QuickSort{}
    sorter.Sort(data)
    fmt.Println(data)
}
```

**解析：** 策略模式定义了排序策略接口和具体实现，根据策略实现不同的排序算法。

### 49. 算法与数据结构：二叉树

**题目：** 给定一棵二叉树，求其最大深度。

**示例：**

```text
输入：root = [3, 9, 20, null, null, 15, 7]
输出：3
```

**答案：**

```go
package main

import (
    "fmt"
)

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return max(leftDepth, rightDepth) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func main() {
    root := &TreeNode{Val: 3}
    root.Left = &TreeNode{Val: 9}
    root.Right = &TreeNode{Val: 20}
    root.Right.Left = &TreeNode{Val: 15}
    root.Right.Right = &TreeNode{Val: 7}
    fmt.Println(maxDepth(root))
}
```

**解析：** 二叉树的最大深度通过递归计算左右子树的最大深度，取最大值再加1。

### 50. 算法与数据结构：哈希表

**题目：** 给定一个整数数组，找出其中两个数的和等于目标值。

**示例：**

```text
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9，返回 [0, 1]。
```

**答案：**

```go
package main

import (
    "fmt"
)

func twoSum(nums []int, target int) []int {
    map := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, exists := map[complement]; exists {
            return []int{j, i}
        }
        map[num] = i
    }
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    fmt.Println(twoSum(nums, target))
}
```

**解析：** 哈希表通过存储每个元素的索引，快速查找是否存在与当前元素相加等于目标值的另一个元素。

