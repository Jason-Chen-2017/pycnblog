                 

### 递归原理在算法中的应用

#### 1. 斐波那契数列

斐波那契数列是数学中一个经典的递归问题，其定义如下：

\[ F(n) = \begin{cases} 
0 & \text{if } n = 0 \\
1 & \text{if } n = 1 \\
F(n-1) + F(n-2) & \text{otherwise} 
\end{cases} \]

**面试题：** 实现一个函数，计算斐波那契数列的第 n 项。

**答案：**

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}
```

**解析：** 该函数直接遵循斐波那契数列的定义，使用递归来计算第 n 项。然而，这种实现方式效率较低，因为存在大量的重复计算。

**优化：** 动态规划

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }
    return b
}
```

**解析：** 通过动态规划，将已计算的值存储起来，避免重复计算。

#### 2. 汉诺塔问题

汉诺塔问题是一个经典的递归问题，其规则如下：

有 3 根柱子 A、B、C，初始时 A 柱上从下到上按从大到小的顺序堆放着 n 个大小不同的圆盘。要求将 A 柱上的圆盘移到 C 柱，在移动过程中，任何时候，在某一根柱子上的圆盘都必须按照从大到小的顺序堆放，且每次只能移动一个圆盘。

**面试题：** 实现一个函数，打印出将 n 个圆盘从 A 柱移到 C 柱的步骤。

**答案：**

```go
func hanota(n int) {
    if n == 1 {
        fmt.Println("Move disk 1 from A to C")
        return
    }
    hanota(n-1)
    fmt.Println("Move disk", n, "from A to B")
    hanota(n-1)
    fmt.Println("Move disk", n, "from B to C")
}
```

**解析：** 该函数使用递归，先将前 n-1 个圆盘从 A 柱移到 B 柱，然后将第 n 个圆盘从 A 柱移到 C 柱，最后将前 n-1 个圆盘从 B 柱移到 C 柱。

#### 3. 求最大子序列和

给定一个整数数组，求出其中最大子序列和。

**面试题：** 实现一个函数，返回给定整数数组中的最大子序列和。

**答案：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }
    return maxSum
}
```

**解析：** 该函数使用递归，每次迭代计算当前最大子序列和，同时更新全局最大子序列和。

#### 4. 合并区间

给定一组区间，合并所有重叠的区间，并按区间起始位置排序。

**面试题：** 实现一个函数，合并给定的一组区间，并按区间起始位置排序。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var merged [][]int
    for _, interval := range intervals {
        if len(merged) == 0 || merged[len(merged)-1][1] < interval[0] {
            merged = append(merged, interval)
        } else {
            merged[len(merged)-1][1] = max(merged[len(merged)-1][1], interval[1])
        }
    }
    return merged
}
```

**解析：** 该函数首先对区间进行排序，然后遍历所有区间，合并重叠的区间。

#### 5. 寻找旋转排序数组中的最小值

给定一个旋转排序的数组，找出其最小元素。

**面试题：** 实现一个函数，寻找给定旋转排序数组中的最小值。

**答案：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 该函数使用二分查找，当找到中间值大于右侧值时，说明最小值在右侧；否则，最小值在左侧或中间。

#### 6. 最长公共子序列

给定两个字符串，找出它们的最长公共子序列。

**面试题：** 实现一个函数，计算给定两个字符串的最长公共子序列长度。

**答案：**

```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 该函数使用动态规划，创建一个二维数组 dp，其中 dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列长度。

#### 7. 股票买卖

给定一个整数数组 prices，其中 prices[i] 是第 i 天股票的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一只股票）。

**面试题：** 实现一个函数，返回给定股票价格数组中的最大利润。

**答案：**

```go
func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}
```

**解析：** 该函数遍历股票价格数组，每次当价格上升时，计算并累加利润。

#### 8. 合并两个有序链表

给定两个有序链表，合并它们为一个新的有序链表并返回。

**面试题：** 实现一个函数，合并给定两个有序链表，并返回新的有序链表。

**答案：**

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    }
    list2.Next = mergeTwoLists(list1, list2.Next)
    return list2
}
```

**解析：** 该函数递归地比较两个链表的当前节点，选择较小值的节点作为新链表的当前节点，并递归地处理剩余链表。

#### 9. 单词梯

单词梯是指一系列的单词，每个单词比前一个单词多一个字母，最后一个单词比第一个单词少一个字母。给定两个单词，找出连接它们的单词梯。

**面试题：** 实现一个函数，返回给定两个单词之间的单词梯。

**答案：**

```go
func findLadders(beginWord, endWord string, wordList []string) [][]string {
    // 使用 BFS 寻找单词梯
    // 省略具体实现，主要思路如下：
    // 1. 构建一个单词图
    // 2. 从 beginWord 开始，使用 BFS 遍历单词图
    // 3. 在每次遍历中，记录每个单词到 beginWord 的距离
    // 4. 当遇到 endWord 时，回溯并构建单词梯
    // 5. 返回单词梯
}
```

**解析：** 该函数使用广度优先搜索（BFS）来寻找单词梯，构建一个单词图，并通过回溯构建单词梯。

#### 10. 最长有效括号

给定一个字符串，找出其中最长的有效括号子串。

**面试题：** 实现一个函数，返回给定字符串中的最长有效括号子串。

**答案：**

```go
func longestValidParentheses(s string) int {
    // 使用动态规划
    // 省略具体实现，主要思路如下：
    // 1. 初始化一个数组 dp，用于记录每个位置处最长有效括号长度
    // 2. 遍历字符串，使用动态规划更新 dp 数组
    // 3. 返回 dp 中最大值
}
```

**解析：** 该函数使用动态规划来计算每个位置处最长有效括号长度，遍历字符串并更新 dp 数组，最终返回 dp 中的最大值。

#### 11. 搜索旋转排序数组

给定一个旋转排序的数组，实现一个函数查找给定的目标值，并返回它的索引。如果目标值不存在，则返回 -1。

**面试题：** 实现一个函数，返回给定旋转排序数组中的目标值的索引。

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 该函数使用二分查找，判断中间值与左右端点的关系，确定搜索区间。

#### 12. 环形链表

给定一个链表，判断链表中是否有环。

**面试题：** 实现一个函数，判断给定链表是否有环。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 该函数使用快慢指针，当快指针追上慢指针时，表示链表中存在环。

#### 13. 汇总邮件

给定一个包含邮差的邮戳，计算将所有邮件送达指定位置的最短时间。

**面试题：** 实现一个函数，计算给定邮差的邮戳下，将所有邮件送达指定位置的最短时间。

**答案：**

```go
func minTimeToDeliver包裹 [][int] int, streets [][int] int) int {
    // 使用 Dijkstra 算法
    // 省略具体实现，主要思路如下：
    // 1. 构建图，将包裹视为边，邮差视为顶点
    // 2. 使用 Dijkstra 算法计算从邮差到每个包裹的最短路径
    // 3. 计算总时间，减去邮差从起点到第一个包裹的时间
    // 4. 返回总时间
}
```

**解析：** 该函数使用 Dijkstra 算法计算邮差到每个包裹的最短路径，然后计算总时间。

#### 14. 合并两个有序链表

给定两个有序链表，合并它们为一个新的有序链表并返回。

**面试题：** 实现一个函数，合并给定两个有序链表，并返回新的有序链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该函数递归地比较两个链表的当前节点，选择较小值的节点作为新链表的当前节点，并递归地处理剩余链表。

#### 15. 快速排序

给定一个整数数组，使用快速排序算法对其进行排序。

**面试题：** 实现一个函数，使用快速排序算法对给定整数数组进行排序。

**答案：**

```go
func quickSort(nums []int) {
    if len(nums) <= 1 {
        return
    }
    pivot := nums[len(nums)/2]
    left := []int{}
    middle := []int{}
    right := []int{}
    for _, num := range nums {
        if num < pivot {
            left = append(left, num)
        } else if num == pivot {
            middle = append(middle, num)
        } else {
            right = append(right, num)
        }
    }
    quickSort(left)
    quickSort(right)
    nums = append(append(left, middle...), right...)
}
```

**解析：** 该函数使用快速排序算法，选择一个基准值，将数组划分为小于、等于和大于基准值的三部分，然后递归地对小于和大于基准值的子数组进行排序，最后合并结果。

#### 16. 单词搜索

给定一个二维字符网格和一个单词，判断该单词是否可以在网格中找到。

**面试题：** 实现一个函数，判断给定单词是否可以在二维字符网格中找到。

**答案：**

```go
func exist(board [][]char, word string) bool {
    rows, cols := len(board), len(board[0])
    visited := make([][]bool, rows)
    for i := 0; i < rows; i++ {
        visited[i] = make([]bool, cols)
    }
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if dfs(board, i, j, word, 0, visited) {
                return true
            }
        }
    }
    return false
}

func dfs(board [][]char, i int, j int, word string, index int, visited [][]bool) bool {
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || visited[i][j] || board[i][j] != word[index] {
        return false
    }
    if index == len(word)-1 {
        return true
    }
    visited[i][j] = true
    left := dfs(board, i-1, j, word, index+1, visited)
    right := dfs(board, i+1, j, word, index+1, visited)
    up := dfs(board, i, j-1, word, index+1, visited)
    down := dfs(board, i, j+1, word, index+1, visited)
    visited[i][j] = false
    return left || right || up || down
}
```

**解析：** 该函数使用深度优先搜索（DFS）算法，从每个起始位置尝试找到单词。函数 `dfs` 递归地检查上下左右四个方向，如果找到单词，则返回 `true`。

#### 17. 有效的括号

给定一个字符串，判断其是否为有效的括号序列。

**面试题：** 实现一个函数，判断给定字符串是否为有效的括号序列。

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || rune(stack[len(stack)-1]) != char {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

**解析：** 该函数使用栈来判断括号是否匹配，遍历字符串，将左括号压入栈，遇到右括号时，判断是否与栈顶元素匹配，如果不匹配，则返回 `false`。

#### 18. 接雨水

给定一个由整数组成的非空数组 heights，表示地面高度图，计算按此高度图从不下雨的平地上空垂直降水，可以接有多少个立方体水。

**面试题：** 实现一个函数，计算给定高度图中可以接多少个立方体水。

**答案：**

```go
func trap(heights []int) int {
    leftMax := make([]int, len(heights))
    rightMax := make([]int, len(heights))
    water := 0
    for i := 1; i < len(heights); i++ {
        leftMax[i] = max(leftMax[i-1], heights[i-1])
    }
    for i := len(heights) - 2; i >= 0; i-- {
        rightMax[i] = max(rightMax[i+1], heights[i+1])
    }
    for i := 0; i < len(heights); i++ {
        water += min(leftMax[i], rightMax[i]) - heights[i]
    }
    return water
}
```

**解析：** 该函数使用前缀最大值和后缀最大值，计算可以接水的面积。

#### 19. 合并区间

给定一组区间，合并所有重叠的区间。

**面试题：** 实现一个函数，合并给定的一组区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return [][]int{}
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }
    return result
}
```

**解析：** 该函数对区间进行排序，然后合并重叠的区间。

#### 20. 计数二进制子串

给定一个字符串 s，计算具有相同数量的 0 和 1 的非空（连续）子字符串的数量，并返回总数。

**面试题：** 实现一个函数，计算给定字符串中具有相同数量的 0 和 1 的非空（连续）子字符串的数量。

**答案：**

```go
func countBinarySubstrings(s string) int {
    count0 := 0
    count1 := 0
    result := 0
    for _, char := range s {
        if char == '0' {
            result += min(count0, count1)
            count0++
        } else {
            result += min(count0, count1)
            count1++
        }
    }
    return result
}
```

**解析：** 该函数通过遍历字符串，计算连续的 0 和 1 的数量，然后计算具有相同数量的 0 和 1 的子字符串数量。

#### 21. 搜索旋转排序数组

给定一个旋转排序的数组，实现一个函数，查找给定的目标值，并返回它的索引。如果目标值不存在，则返回 -1。

**面试题：** 实现一个函数，返回给定旋转排序数组中的目标值的索引。

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 该函数使用二分查找，根据中间值与左右端点的关系，确定搜索区间。

#### 22. 环形链表

给定一个链表，判断链表中是否有环。

**面试题：** 实现一个函数，判断给定链表是否有环。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 该函数使用快慢指针，当快指针追上慢指针时，表示链表中存在环。

#### 23. 合并两个有序链表

给定两个有序链表，合并它们为一个新的有序链表并返回。

**面试题：** 实现一个函数，合并给定两个有序链表，并返回新的有序链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该函数递归地比较两个链表的当前节点，选择较小值的节点作为新链表的当前节点，并递归地处理剩余链表。

#### 24. 删除链表的节点

给定一个链表和一个节点值，删除链表中所有值为该值的节点。

**面试题：** 实现一个函数，删除给定链表中所有值为该值的节点。

**答案：**

```go
func deleteNode(head *ListNode, val int) *ListNode {
    dummy := &ListNode{0, head}
    prev := dummy
    curr := head
    for curr != nil {
        if curr.Val == val {
            prev.Next = curr.Next
        } else {
            prev = curr
        }
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：** 该函数使用哑节点，遍历链表，删除所有值为给定值的节点。

#### 25. 打家劫舍

给定一个非负整数数组，每个元素代表某个房子里的现金，计算最多能偷窃多少现金。

**面试题：** 实现一个函数，计算给定数组中最多能偷窃多少现金。

**答案：**

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    return max(rob(nums[:len(nums)-1]), rob(nums[1:]))
}
```

**解析：** 该函数使用动态规划，计算前 n-1 个元素和前 n-2 个元素的最大值，然后取最大值。

#### 26. 找出第 k 小的元素

给定一个整数数组和一个整数 k，找出数组中第 k 小的元素。

**面试题：** 实现一个函数，返回给定整数数组中第 k 小的元素。

**答案：**

```go
func findKthLargest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[len(nums)-k]
}
```

**解析：** 该函数使用排序算法，返回数组中第 k 小的元素。

#### 27. 搜索二维矩阵

给定一个二维矩阵，每个元素都是排序的，编写一个查找函数，查找给定目标值是否在矩阵中。

**面试题：** 实现一个函数，判断给定目标值是否在给定排序二维矩阵中。

**答案：**

```go
func searchMatrix(matrix [][]int, target int) bool {
    rows, cols := len(matrix), len(matrix[0])
    row, col := 0, cols-1
    for row < rows && col >= 0 {
        if matrix[row][col] == target {
            return true
        }
        if matrix[row][col] < target {
            row++
        } else {
            col--
        }
    }
    return false
}
```

**解析：** 该函数使用二分查找，从右上角开始搜索，根据目标值与当前元素的关系，更新行或列。

#### 28. 删除有序数组中的重复项

给定一个有序数组，编写一个函数来删除重复项，使每个元素只出现一次，返回删除后数组的新长度。

**面试题：** 实现一个函数，删除给定有序数组中的重复项，并返回新长度。

**答案：**

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    slow := 0
    for fast := 1; fast < len(nums); fast++ {
        if nums[slow] != nums[fast] {
            slow++
            nums[slow] = nums[fast]
        }
    }
    return slow + 1
}
```

**解析：** 该函数使用双指针，遍历数组，将不重复的元素移动到前半部分，然后返回新长度。

#### 29. 分割等和子集

给定一个非负整数数组，判断是否存在两个子集，使得它们的和相等。

**面试题：** 实现一个函数，判断给定数组是否存在两个子集，使得它们的和相等。

**答案：**

```go
func canPartition(nums []int) bool {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    if totalSum%2 != 0 {
        return false
    }
    target := totalSum / 2
    dp := make([]bool, target+1)
    dp[0] = true
    for _, num := range nums {
        for j := target; j >= num; j-- {
            dp[j] = dp[j] || dp[j-num]
        }
    }
    return dp[target]
}
```

**解析：** 该函数使用动态规划，计算是否存在一个子集，使得其和等于总和大的一半。

#### 30. 字符串压缩

给定一个字符串，实现一个函数，判断是否可以压缩字符串，并返回压缩后的字符串长度。

**面试题：** 实现一个函数，判断给定字符串是否可以压缩，并返回压缩后的字符串长度。

**答案：**

```go
func compressString(s string) int {
    n := len(s)
    if n < 2 {
        return n
    }
    compressed := []byte{}
    count := 1
    for i := 1; i < n; i++ {
        if s[i] == s[i-1] {
            count++
        } else {
            compressed = append(compressed, s[i-1])
            if count > 1 {
                compressed = append(compressed, strconv.Itoa(count))
            }
            count = 1
        }
    }
    compressed = append(compressed, s[n-1])
    if count > 1 {
        compressed = append(compressed, strconv.Itoa(count))
    }
    return len(compressed)
}
```

**解析：** 该函数遍历字符串，统计相同字符的连续出现次数，将字符及其出现次数压缩为一个字符串。最后返回压缩后的字符串长度。

