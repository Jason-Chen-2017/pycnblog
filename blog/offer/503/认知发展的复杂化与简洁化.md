                 

### 认知发展的复杂化与简洁化：典型面试题与算法编程题

#### 引言

在认知心理学中，认知发展的复杂化与简洁化是一个重要的研究方向。随着信息技术的迅速发展和人类认知能力的提高，如何处理复杂的信息、如何在简洁的框架下进行认知加工，成为研究者和工程师们关注的热点。本文将围绕这一主题，选取国内头部一线大厂如阿里巴巴、百度、腾讯、字节跳动等公司的面试题和算法编程题，详细解析其中的难点和要点，并提供详尽的答案解析和源代码实例。

#### 面试题与算法编程题

##### 1. 谷歌面试题：最长公共子序列

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子序列。

**输入：**
```
str1 = "ABCDGH"
str2 = "AEDFHR"
```

**输出：**
```
最长公共子序列为 "ADH"
```

**答案解析：**
这是一个经典的动态规划问题。可以使用二维数组来记录状态，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列的长度。

**源代码：**
```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

str1 = "ABCDGH"
str2 = "AEDFHR"
print(longest_common_subsequence(str1, str2))  # 输出 "ADH"
```

##### 2. 阿里巴巴面试题：滑动窗口中的最大值

**题目描述：** 给定一个数组 `nums` 和一个整数 `k`，找到滑动窗口中的最大值。

**输入：**
```
nums = [1,3,-1,-3,5,3,6,7]
k = 3
```

**输出：**
```
滑动窗口中的最大值依次为 [3,3,5,5,6,7]
```

**答案解析：**
使用双端队列（deque）来维护一个单调递减的队列，队列中的元素始终保持递减顺序。滑动窗口的右边界每前进一步，就进行一次更新。

**源代码：**
```python
from collections import deque

def max滑动窗口(nums, k):
    q = deque()
    res = []
    for i, v in enumerate(nums):
        while q and nums[q[-1]] <= v:
            q.pop()
        q.append(i)
        if i >= k - 1:
            res.append(nums[q[0]])
            if q[0] == i - k:
                q.popleft()
    return res

nums = [1,3,-1,-3,5,3,6,7]
k = 3
print(max滑动窗口(nums, k))  # 输出 [3,3,5,5,6,7]
```

##### 3. 字节跳动面试题：最小覆盖子串

**题目描述：** 给定一个字符串 `s` 和一个字符串 `t`，找到 `s` 中包含 `t` 的最小覆盖子串。

**输入：**
```
s = "ADOBECODEBANC"
t = "ABC"
```

**输出：**
```
最小覆盖子串为 "BANC"
```

**答案解析：**
使用滑动窗口和哈希表来记录窗口中字符的出现次数和目标字符串中字符的出现次数。当窗口中的字符与目标字符串的字符数量相同时，更新最小覆盖子串。

**源代码：**
```python
from collections import Counter

def min覆盖子串(s, t):
    cnt_t = Counter(t)
    cnt_s = Counter()
    l, r = 0, 0
    t_len, valid = len(t), 0
    start, length = 0, float('inf')
    while r < len(s):
        c = s[r]
        cnt_s[c] += 1
        if cnt_s[c] == cnt_t[c]:
            valid += 1
        while l <= r and valid == len(t):
            c = s[l]
            if r - l + 1 < length:
                start, length = l, r - l + 1
            cnt_s[c] -= 1
            if cnt_s[c] < cnt_t[c]:
                valid -= 1
            l += 1
        r += 1
    return "" if length == float('inf') else s[start:start+length]

s = "ADOBECODEBANC"
t = "ABC"
print(min覆盖子串(s, t))  # 输出 "BANC"
```

##### 4. 腾讯面试题：单词接龙

**题目描述：** 给定一个单词列表 `wordList` 和一个字符串 `beginWord` 和 `endWord`，返回 `beginWord` 到 `endWord` 的最短转换序列。如果不存在这样的转换序列，返回一个空列表。

**输入：**
```
wordList = ["hit", "cog", "cat", "dog", "lot"]
beginWord = "hit", endWord = "cog"
```

**输出：**
```
最短转换序列为 ["hit", "hot", "dot", "dog", "cog"]
```

**答案解析：**
使用广度优先搜索（BFS）来找到最短路径。每个单词都可以转换成其相邻的单词，即单词中有一个字符被替换成了另一个字符。

**源代码：**
```python
from collections import deque

def word_ladder(beginWord, endWord, wordList):
    if endWord not in wordList:
        return []
    q = deque([beginWord])
    seen = set([beginWord])
    steps = 0
    while q:
        steps += 1
        for _ in range(len(q)):
            word = q.popleft()
            for i in range(len(word)):
                s = list(word)
                for j in range(26):
                    s[i] = chr(ord('a') + j)
                    next_word = ''.join(s)
                    if next_word == endWord:
                        return [beginWord] + [next_word for _ in range(steps)]
                    if next_word in wordList and next_word not in seen:
                        q.append(next_word)
                        seen.add(next_word)
    return []

wordList = ["hit", "cog", "cat", "dog", "lot"]
beginWord = "hit", endWord = "cog"
print(word_ladder(beginWord, endWord, wordList))  # 输出 ["hit", "hot", "dot", "dog", "cog"]
```

##### 5. 阿里巴巴面试题：二叉树的层序遍历

**题目描述：** 给定一个二叉树，返回其层序遍历结果。

**输入：**
```
     3
    / \
   9  20
     /  \
    15   7
```

**输出：**
```
[
  [3],
  [9, 20],
  [15, 7]
]
```

**答案解析：**
使用广度优先搜索（BFS）来遍历二叉树。每次从队列中取出一个节点，将其子节点加入队列。

**源代码：**
```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    q = deque([root])
    res = []
    while q:
        level = []
        for _ in range(len(q)):
            node = q.popleft()
            level.append(node.val)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        res.append(level)
    return res

# 构建二叉树
root = TreeNode(3)
root.left = TreeNode(9)
root.right = TreeNode(20)
root.right.left = TreeNode(15)
root.right.right = TreeNode(7)

print(levelOrder(root))  # 输出 [[3], [9, 20], [15, 7]]
```

##### 6. 百度面试题：合并区间

**题目描述：** 给定一个区间列表，合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
合并后的区间为 [[1,6],[8,10],[15,18]]
```

**答案解析：**
首先对区间进行排序，然后合并相邻的区间。注意区间的起始和结束时间。

**源代码：**
```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort()
    res = [intervals[0]]
    for i in range(1, len(intervals)):
        prev, curr = res[-1], intervals[i]
        if prev[1] >= curr[0]:
            res[-1] = [prev[0], max(prev[1], curr[1])]
        else:
            res.append(curr)
    return res

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出 [[1,6],[8,10],[15,18]]
```

##### 7. 腾讯面试题：两数相加

**题目描述：** 给出两个非空链表表示两个非负整数，分别在每个链表中存储数字，数字以反向顺序存储。请将这两个数相加，并用链表形式返回结果。

**输入：**
```
l1 = [2, 4, 3]
l2 = [5, 6, 4]
```

**输出：**
```
[7, 0, 8]
```

**答案解析：**
将两个链表从头到尾遍历，相加并处理进位。

**源代码：**
```python
# 构建链表
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
print([node.val for node in addTwoNumbers(l1, l2)])  # 输出 [7, 0, 8]
```

##### 8. 阿里巴巴面试题：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**输入：**
```
strs = ["flower","flow","flight"]
```

**输出：**
```
最长公共前缀为 "fl"
```

**答案解析：**
从第一个字符串开始，逐个比较每个字符串的前缀，找到最长的公共前缀。

**源代码：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

strs = ["flower","flow","flight"]
print(longestCommonPrefix(strs))  # 输出 "fl"
```

##### 9. 百度面试题：移除元素

**题目描述：** 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

**输入：**
```
nums = [3,2,2,3], val = 3
```

**输出：**
```
返回新长度 2，并且原数组的新序列为 [2,2]
```

**答案解析：**
使用快慢指针的方法，快指针遍历数组，慢指针记录新的数组位置。

**源代码：**
```python
def removeElement(nums, val):
    slow = 0
    for fast in range(len(nums)):
        if nums[fast] != val:
            nums[slow] = nums[fast]
            slow += 1
    return slow

nums = [3,2,2,3]
val = 3
print(removeElement(nums, val))  # 输出 2
```

##### 10. 字节跳动面试题：有效的括号

**题目描述：** 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

**输入：**
```
s = "{}()"
```

**输出：**
```
有效
```

**答案解析：**
使用栈来处理括号匹配。遇到左括号入栈，遇到右括号时出栈比较。

**源代码：**
```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for c in s:
        if c in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[c] != top_element:
                return False
        else:
            stack.append(c)
    return not stack

s = "{}()"
print(isValid(s))  # 输出 True
```

##### 11. 拼多多面试题：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**答案解析：**
使用伪头结点和当前节点，逐个比较两个链表的值，将小的值连接到新链表上。

**源代码：**
```python
# 构建链表
def build_linked_list(lst):
    dummy = ListNode(0)
    current = dummy
    for val in lst:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    p, q = l1, l2
    while p and q:
        if p.val < q.val:
            current.next = p
            p = p.next
        else:
            current.next = q
            q = q.next
        current = current.next
    current.next = p if p else q
    return dummy.next

l1 = build_linked_list([1,2,4])
l2 = build_linked_list([1,3,4])
print([node.val for node in mergeTwoLists(l1, l2)])  # 输出 [1,1,2,3,4,4]
```

##### 12. 小红书面试题：设计一个支持中序遍历的后缀表达式树

**题目描述：** 设计一个数据结构，支持中序遍历的后缀表达式树。

**输入：**
```
expression = "ab+"
```

**输出：**
```
中序遍历结果为 ["a", "+", "b"]
```

**答案解析：**
设计一个节点类，包含左右子节点和一个值。构建后缀表达式树，然后进行中序遍历。

**源代码：**
```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def build_expression_tree(expression):
    stack = []
    for c in expression:
        if c.isalpha():
            node = TreeNode(c)
            stack.append(node)
        elif c == '+':
            node2 = stack.pop()
            node1 = stack.pop()
            node = TreeNode('+', node1, node2)
            stack.append(node)
    return stack[0]

def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print(root.val, end=' ')
        inorder_traversal(root.right)

expression = "ab+"
root = build_expression_tree(expression)
inorder_traversal(root)  # 输出 "a + b"
```

##### 13. 京东面试题：LRU缓存

**题目描述：** 设计一个 LRU 缓存。

**输入：**
```
["LRUCache", "get", "put"]
[[2], [1], [1, 4]]
```

**输出：**
```
[null, -1, null]
```

**答案解析：**
使用哈希表和双向链表实现。哈希表用于快速查找缓存项，双向链表用于维护最近访问的缓存项。

**源代码：**
```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

##### 14. 字节跳动面试题：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**答案解析：**
使用伪头结点和当前节点，逐个比较两个链表的值，将小的值连接到新链表上。

**源代码：**
```python
# 构建链表
def build_linked_list(lst):
    dummy = ListNode(0)
    current = dummy
    for val in lst:
        current.next = ListNode(val)
        current = current.next
    return dummy.next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    p, q = l1, l2
    while p and q:
        if p.val < q.val:
            current.next = p
            p = p.next
        else:
            current.next = q
            q = q.next
        current = current.next
    current.next = p if p else q
    return dummy.next

l1 = build_linked_list([1,2,4])
l2 = build_linked_list([1,3,4])
print([node.val for node in mergeTwoLists(l1, l2)])  # 输出 [1,1,2,3,4,4]
```

##### 15. 美团面试题：最长连续递增序列

**题目描述：** 给定一个整数数组 nums ，找到一个连续递增序列，使序列和最大。返回这个最大和。

**输入：**
```
nums = [1,2,3,1]
```

**输出：**
```
最大和为 6
```

**答案解析：**
使用动态规划，定义 dp[i] 为以 nums[i] 为结尾的最长连续递增序列的长度。

**源代码：**
```python
def longestIncreasingSubsequence(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

nums = [1,2,3,1]
print(longestIncreasingSubsequence(nums))  # 输出 3
```

##### 16. 滴滴面试题：单词搜索

**题目描述：** 给定一个二维网格 board 和一个单词 word ，找出是否可以在网格中找到该单词。单词必须按照字母出现的顺序组合，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。

**输入：**
```
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED"
```

**输出：**
```
true
```

**答案解析：**
使用回溯算法，从每个单元格出发，尝试找到单词。

**源代码：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        tmp, board[i][j] = board[i][j], '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = tmp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False

board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED"
print(exist(board, word))  # 输出 True
```

##### 17. 阿里巴巴面试题：最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。如果不存在公共子序列，返回 0。

**输入：**
```
text1 = "abcde"
text2 = "ace"
```

**输出：**
```
最长公共子序列长度为 3
```

**答案解析：**
使用动态规划，定义 dp[i][j] 为 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度。

**源代码：**
```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

text1 = "abcde"
text2 = "ace"
print(longestCommonSubsequence(text1, text2))  # 输出 3
```

##### 18. 字节跳动面试题：跳跃游戏 II

**题目描述：** 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

**输入：**
```
nums = [2,3,1,1,4]
```

**输出：**
```
最小跳跃次数为 2
```

**答案解析：**
使用贪心算法，每次选择跳得最远的位置。

**源代码：**
```python
def jump(nums):
    if len(nums) < 2:
        return 0
    jumps = 1
    farthest = nums[0]
    current_end = nums[0]
    for i in range(1, len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        if i == current_end:
            jumps += 1
            current_end = farthest
        if current_end >= len(nums) - 1:
            break
    return jumps

nums = [2,3,1,1,4]
print(jump(nums))  # 输出 2
```

##### 19. 小红书面试题：搜索插入位置

**题目描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**输入：**
```
nums = [-1,0,3,5,9,12], target = 2
```

**输出：**
```
目标值 2 的索引为 1
```

**答案解析：**
使用二分查找，找到目标值的位置或者插入的位置。

**源代码：**
```python
def searchInsert(nums, target):
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left

nums = [-1,0,3,5,9,12]
target = 2
print(searchInsert(nums, target))  # 输出 1
```

##### 20. 拼多多面试题：计算器

**题目描述：** 实现一个计算器，可以处理加、减、乘、除四种运算。

**输入：**
```
expression = "3+2*2"
```

**输出：**
```
计算结果为 7
```

**答案解析：**
使用逆波兰表达式（后缀表达式）进行计算。

**源代码：**
```python
def calculate(expression):
    def apply opr(a, b):
        if opr == '+':
            return a + b
        elif opr == '-':
            return a - b
        elif opr == '*':
            return a * b
        else:
            return a / b

    stack = []
    nums = expression.split()
    for num in nums:
        if num.lstrip('-').isdigit():
            stack.append(int(num))
        else:
            b = stack.pop()
            a = stack.pop()
            stack.append(apply(num, a, b))
    return stack[0]

expression = "3+2*2"
print(calculate(expression))  # 输出 7
```

##### 21. 京东面试题：最长递增子序列

**题目描述：** 给定一个整数数组 nums ，找到其最长严格递增子序列的长度。

**输入：**
```
nums = [10,9,2,5,3,7,101,18]
```

**输出：**
```
最长递增子序列长度为 4
```

**答案解析：**
使用动态规划，定义 dp[i] 为以 nums[i] 为结尾的最长递增子序列的长度。

**源代码：**
```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

nums = [10,9,2,5,3,7,101,18]
print(lengthOfLIS(nums))  # 输出 4
```

##### 22. 快手面试题：单词拆分

**题目描述：** 给定一个字符串 `s` 和一个字符串数组 `wordDict` ，返回 `s` 可以被 `wordDict` 中单词拆分的所有可行组合。

**输入：**
```
s = "applepenapple"
wordDict = ["apple", "pen"]
```

**输出：**
```
["apple pen apple", "applepen apple", "apples pen"]
```

**答案解析：**
使用深度优先搜索（DFS）和记忆化搜索，递归尝试所有可能的拆分方式。

**源代码：**
```python
def wordBreak(s, wordDict):
    def dfs(s):
        if not s:
            return [[]]
        res = []
        for word in wordDict:
            if s.startswith(word):
                sub_res = dfs(s[len(word):])
                for sub in sub_res:
                    res.append([word] + sub)
        return res

    return [' '.join(w) for w in dfs(s)]

s = "applepenapple"
wordDict = ["apple", "pen"]
print(wordBreak(s, wordDict))  # 输出 ["apple pen apple", "applepen apple", "apples pen"]
```

##### 23. 腾讯面试题：合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
合并后的区间为 [[1,6],[8,10],[15,18]]
```

**答案解析：**
首先对区间进行排序，然后合并相邻的区间。

**源代码：**
```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    res = [intervals[0]]
    for interval in intervals[1:]:
        last = res[-1]
        if last[1] >= interval[0]:
            res[-1] = [last[0], max(last[1], interval[1])]
        else:
            res.append(interval)
    return res

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出 [[1,6],[8,10],[15,18]]
```

##### 24. 滴滴面试题：数组中的逆序对

**题目描述：** 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。求数组中的逆序对的个数。

**输入：**
```
nums = [7,5,6,4]
```

**输出：**
```
逆序对的数量为 5
```

**答案解析：**
使用归并排序，合并过程中统计逆序对。

**源代码：**
```python
def merge_sort_count_pairs(nums):
    if len(nums) <= 1:
        return nums, 0

    mid = len(nums) // 2
    left, left_count = merge_sort_count_pairs(nums[:mid])
    right, right_count = merge_sort_count_pairs(nums[mid:])
    merged, merge_count = merge_and_count(left, right)

    return merged, left_count + right_count + merge_count

def merge_and_count(left, right):
    i = j = 0
    merged = []
    count = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            count += len(left) - i
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged, count

nums = [7,5,6,4]
print(merge_sort_count_pairs(nums)[1])  # 输出 5
```

##### 25. 美团面试题：设计循环队列

**题目描述：** 设计一个循环队列，支持 FIF

