                 

### 2025腾讯校招面试算法题库大全

#### 一、基础算法题

##### 1. 两数之和
**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：** 可以使用哈希表来解决这个问题。遍历数组，对每个元素，检查哈希表中是否存在 `target - 当前元素`。

```go
func twoSum(nums []int, target int) []int {
    var result []int
    var map1 = make(map[int]int)
    for k, v := range nums {
        if p, ok := map1[target-v]; ok {
            result = []int{p, k}
        }
        map1[v] = k
    }
    return result
}
```

##### 2. 合并两个有序链表
**题目：** 将两个升序链表合并为一个新的升序链表并返回。链表节点包含 `val` 和下一个节点 `next`。

**答案：** 创建一个新的头结点，然后遍历两个链表，比较当前节点的值，将较小的节点添加到新链表中，并指向下一个节点。

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy = &ListNode{0, nil}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    curr.Next = l1 != nil ? l1 : l2
    return dummy.Next
}
```

##### 3. 三数之和
**题目：** 给定一个整数数组 `nums`，返回所有三个数字的和为 `0` 的整数组合。

**答案：** 使用排序后的双指针法。首先对数组进行排序，然后遍历每个元素，对于每个元素，使用两个指针从该元素的下一个元素开始，一个向前，一个向后，寻找和为目标值的两个数。

```go
func threeSum(nums []int) [][]int {
    var result = [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return result
}
```

#### 二、动态规划题

##### 4. 最长递增子序列
**题目：** 给定一个无序的整数数组，找出最长递增子序列的长度。

**答案：** 使用动态规划。初始化一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。遍历数组，对于每个元素，遍历前面的元素，如果前面的元素小于当前元素，则更新 `dp[i]` 的值。

```go
func lengthOfLIS(nums []int) int {
    var dp = make([]int, len(nums))
    var length = 0
    for i := range nums {
        dp[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        length = max(length, dp[i])
    }
    return length
}
```

##### 5. 背包问题
**题目：** 给定一个物品数组 `weights` 和其对应的值数组 `values`，以及一个背包容量 `W`，求在不超过背包容量的情况下，能装入物品的最大总价值。

**答案：** 使用动态规划。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示前 `i` 个物品放入容量为 `j` 的背包可以获得的最大价值。遍历物品和背包容量，更新 `dp` 数组。

```go
func knapsack(weights []int, values []int, W int) int {
    var dp = make([][]int, len(weights)+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }
    for i := 1; i <= len(weights); i++ {
        for j := 1; j <= W; j++ {
            if weights[i-1] <= j {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i-1]]+values[i-1])
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[len(weights)][W]
}
```

#### 三、图论题

##### 6. 单源最短路径
**题目：** 给定一个加权无向图和一个源点 `src`，求从 `src` 到图中每个点的最短路径。

**答案：** 使用 Dijkstra 算法。初始化一个距离数组 `dist`，其中 `dist[i]` 表示从 `src` 到点 `i` 的最短距离。遍历所有边，更新距离数组。每次更新后，选择最小距离的顶点作为下一次迭代的起点。

```go
func dijkstra(edges [][]int, src int) []int {
    var n = len(edges)
    var dist = make([]int, n)
    var INF = 1e9
    for i := range dist {
        dist[i] = INF
    }
    dist[src] = 0
    var priorityQueue = make(PriorityQueue, 0)
    priorityQueue = append(priorityQueue, &Node{Val: src, Weight: 0})
    for len(priorityQueue) > 0 {
        var node = priorityQueue[0]
        priorityQueue = priorityQueue[1:]
        for _, edge := range edges[node.Val] {
            var nextNode = edge.Node
            var nextWeight = edge.Weight + node.Weight
            if nextWeight < dist[nextNode] {
                dist[nextNode] = nextWeight
                var newNode = &Node{Val: nextNode, Weight: nextWeight}
                priorityQueue = append(priorityQueue, newNode)
                heap.Sort(priorityQueue)
            }
        }
    }
    return dist
}
```

##### 7. 图的拓扑排序
**题目：** 给定一个有向无环图，对其进行拓扑排序。

**答案：** 使用 Kahn 算法。初始化一个入度数组 `indegree`，其中 `indegree[i]` 表示点 `i` 的入度。遍历所有点，将入度为 0 的点加入队列。从队列中依次取出点，将其所有的相邻点入度减 1，如果相邻点的入度为 0，则将其加入队列。

```go
func topologicalSort(vertices []int, edges [][]int) []int {
    var indegree = make([]int, len(vertices))
    for _, edge := range edges {
        indegree[edge[1]]++
    }
    var queue = make([]int, 0)
    for i, degree := range indegree {
        if degree == 0 {
            queue = append(queue, i)
        }
    }
    var sorted = make([]int, 0)
    for len(queue) > 0 {
        var vertex = queue[0]
        queue = queue[1:]
        sorted = append(sorted, vertex)
        for _, neighbor := range edges[vertex] {
            indegree[neighbor]--
            if indegree[neighbor] == 0 {
                queue = append(queue, neighbor)
            }
        }
    }
    return sorted
}
```

#### 四、其他

##### 8. 爬楼梯
**题目：** 一个楼梯有 `n` 阶台阶，每次可以上一阶或两阶，求有多少种上楼梯的方法。

**答案：** 使用动态规划。初始化一个数组 `dp`，其中 `dp[i]` 表示上到第 `i` 阶的方法数。根据状态转移方程 `dp[i] = dp[i-1] + dp[i-2]`，依次计算每个台阶的方法数。

```go
func climbStairs(n int) int {
    var dp = make([]int, n+1)
    dp[0] = 1
    if n > 0 {
        dp[1] = 1
    }
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

##### 9. 最长公共子序列
**题目：** 给定两个字符串 `text1` 和 `text2`，求它们的最长公共子序列。

**答案：** 使用动态规划。初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。根据状态转移方程 `dp[i][j] = dp[i-1][j-1] + 1`（如果 `text1[i-1] == text2[j-1]`），或者 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（如果 `text1[i-1] != text2[j-1]`），计算每个位置的最长公共子序列长度。

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    var dp = make([][]int, len(text1)+1)
    for i := range dp {
        dp[i] = make([]int, len(text2)+1)
    }
    for i := 1; i <= len(text1); i++ {
        for j := 1; j <= len(text2); j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[len(text1)][len(text2)]
}
```

##### 10. 逆波兰表达式求值
**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈。遍历表达式，对于操作数，将其入栈；对于运算符，弹出两个操作数，进行运算，并将结果入栈。

```go
func evalRPN(tokens []string) int {
    var stack = make([]int, 0)
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if b == 0 {
                panic("Division by zero")
            }
            stack = append(stack, a/b)
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}
```

##### 11. 合并区间
**题目：** 给定一组区间，合并所有重叠的区间。

**答案：** 将区间按照起始位置排序，然后遍历区间，对于当前区间，如果与前一个区间不重叠，则直接添加到结果中；如果重叠，则合并区间，并更新结果。

```go
type Interval struct {
    Start int
    End   int
}

func merge(intervals []Interval) []Interval {
    var sorted = make([]Interval, len(intervals))
    copy(sorted, intervals)
    sort.Slice(sorted, func(i, j int) bool {
        return sorted[i].Start < sorted[j].Start
    })
    var result = make([]Interval, 0)
    for _, interval := range sorted {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}
```

##### 12. 有效的括号
**题目：** 给定一个字符串，判断是否为有效的括号。

**答案：** 使用栈。遍历字符串，对于左括号，将其入栈；对于右括号，检查是否与栈顶元素匹配，如果匹配，则出栈。最后检查栈是否为空。

```go
func isValid(s string) bool {
    var stack = make([]byte, 0)
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '[':
            stack = append(stack, ']')
        case '{':
            stack = append(stack, '}')
        default:
            if len(stack) == 0 || stack[len(stack)-1] != char {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

##### 13. 搜索旋转排序数组
**题目：** 搜索一个旋转排序的数组。

**答案：** 使用二分查找。初始化两个指针，一个指向数组的起始位置，一个指向数组的结束位置。在每次迭代中，比较中间元素和目标值，如果中间元素大于起始位置元素，说明左半部分有序，将右指针移动到中间位置的左侧；否则，右半部分有序，将左指针移动到中间位置的右侧。

```go
func search(nums []int, target int) int {
    var left, right = 0, len(nums)-1
    for left <= right {
        var mid = (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > nums[left] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[right] || target <= nums[mid] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

##### 14. 最长公共前缀
**题目：** 找出字符串数组中的最长公共前缀。

**答案：** 逐个字符比较，如果所有字符串的前缀都相同，则继续比较下一个字符；否则，返回已经比较的字符组成的字符串。

```go
func longestCommonPrefix(strs []string) string {
    var prefix = ""
    if len(strs) == 0 {
        return prefix
    }
    for i := 0; i < len(strs[0]); i++ {
        var char = strs[0][i]
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || char != strs[j][i] {
                return prefix
            }
        }
        prefix += string(char)
    }
    return prefix
}
```

##### 15. 计数排序
**题目：** 实现计数排序。

**答案：** 首先找出数组中的最大值和最小值，然后创建一个计数数组，其中每个元素表示对应数字在原数组中出现的次数。遍历原数组，将每个元素放入正确的位置。最后返回排序后的数组。

```go
func countingSort(nums []int) []int {
    var max, min = math.MinInt, math.MaxInt
    for _, num := range nums {
        if num > max {
            max = num
        }
        if num < min {
            min = num
        }
    }
    var count = make([]int, max-min+1)
    for _, num := range nums {
        count[num-min]++
    }
    var sorted = make([]int, 0)
    for i, v := range count {
        for j := 0; j < v; j++ {
            sorted = append(sorted, i+min)
        }
    }
    return sorted
}
```

##### 16. 快乐数
**题目：** 编写一个算法来判断一个数是不是“快乐数”。

**答案：** 快乐数的定义是：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但终会变为 1。如果这个过程最后能够变为 1，那么这个数就是快乐数。

```go
func isHappy(n int) bool {
    var slow, fast = n, n
    for {
        slow = squareSum(slow)
        fast = squareSum(squareSum(fast))
        if slow == fast {
            break
        }
    }
    return slow == 1
}

func squareSum(n int) int {
    var sum = 0
    for n > 0 {
        sum += (n % 10) * (n % 10)
        n /= 10
    }
    return sum
}
```

##### 17. 最接近的三数之和
**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。

**答案：** 使用双指针。首先对数组进行排序，然后遍历数组，对于每个元素，使用两个指针指向当前元素的下一个元素和最后一个元素，根据三数之和与目标值的比较，移动左右指针。

```go
func threeSumClosest(nums []int, target int) int {
    sort.Ints(nums)
    var closest = nums[0] + nums[1] + nums[2]
    for i := 0; i < len(nums)-2; i++ {
        var left, right = i+1, len(nums)-1
        for left < right {
            var sum = nums[i] + nums[left] + nums[right]
            if sum == target {
                return sum
            } else if sum < target {
                left++
            } else {
                right--
            }
            if abs(target-sum) < abs(target-closest) {
                closest = sum
            }
        }
    }
    return closest
}
```

##### 18. 最小路径和
**题目：** 给定一个包含非负整数的 `m x n` 网格，找出一条从左上角到右下角的路径，使得路径上的数字总和为最小值。

**答案：** 使用动态规划。初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示从左上角到点 `(i, j)` 的最小路径和。遍历网格，根据状态转移方程 `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`，计算每个点的最小路径和。

```go
func minPathSum(grid [][]int) int {
    var dp = make([][]int, len(grid))
    for i := range dp {
        dp[i] = make([]int, len(grid[0]))
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < len(grid); i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < len(grid[0]); j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < len(grid); i++ {
        for j := 1; j < len(grid[0]); j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[len(grid)-1][len(grid[0])-1]
}
```

##### 19. 合并两个有序链表
**题目：** 将两个升序链表合并为一个新的升序链表并返回。链表节点包含 `val` 和下一个节点 `next`。

**答案：** 创建一个新的头结点，然后遍历两个链表，比较当前节点的值，将较小的节点添加到新链表中，并指向下一个节点。

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy = &ListNode{0, nil}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    curr.Next = l1 != nil ? l1 : l2
    return dummy.Next
}
```

##### 20. 有效的括号
**题目：** 给定一个字符串，判断是否为有效的括号。

**答案：** 使用栈。遍历字符串，对于左括号，将其入栈；对于右括号，检查是否与栈顶元素匹配，如果匹配，则出栈。最后检查栈是否为空。

```go
func isValid(s string) bool {
    var stack = make([]byte, 0)
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '[':
            stack = append(stack, ']')
        case '{':
            stack = append(stack, '}')
        default:
            if len(stack) == 0 || stack[len(stack)-1] != char {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

##### 21. 最大子序和
**题目：** 给定一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**答案：** 使用动态规划。初始化一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长严格递增子序列的长度。遍历数组，对于每个元素，遍历前面的元素，如果前面的元素小于当前元素，则更新 `dp[i]` 的值。

```go
func lengthOfLIS(nums []int) int {
    var dp = make([]int, len(nums))
    var length = 0
    for i := range nums {
        dp[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        length = max(length, dp[i])
    }
    return length
}
```

##### 22. 最长公共子串
**题目：** 给定两个字符串 `s` 和 `t`，返回 `s` 和 `t` 的最长公共子串。

**答案：** 使用动态规划。初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s` 的前 `i` 个字符和 `t` 的前 `j` 个字符的最长公共子串的长度。根据状态转移方程 `dp[i][j] = dp[i-1][j-1] + 1`（如果 `s[i-1] == t[j-1]`），或者 `dp[i][j] = 0`（如果 `s[i-1] != t[j-1]`），计算每个位置的最长公共子串长度。

```go
func longestCommonSubstr(s, t string) int {
    var dp = make([][]int, len(s)+1)
    for i := range dp {
        dp[i] = make([]int, len(t)+1)
    }
    var maxLen = 0
    for i := 1; i <= len(s); i++ {
        for j := 1; j <= len(t); j++ {
            if s[i-1] == t[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                maxLen = max(maxLen, dp[i][j])
            } else {
                dp[i][j] = 0
            }
        }
    }
    return maxLen
}
```

##### 23. 最小栈
**题目：** 设计一个支持 `push` 、`pop` 、`top` 操作和获取最小元素的栈。

**答案：** 使用两个栈，一个用于存储正常元素，一个用于存储当前最小元素。每次 `push` 时，将元素同时推入两个栈；每次 `pop` 时，如果 `minStack` 的栈顶元素等于 `stack` 的栈顶元素，则同时弹出两个栈的栈顶元素；每次 `push` 或 `pop` 后，更新 `minStack` 的栈顶元素为当前元素和栈顶元素中的最小值。

```go
type MinStack struct {
    stack  []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack:  make([]int, 0),
        minStack: make([]int, 0),
    }
}

func (this *MinStack) Push(x int) {
    this.stack = append(this.stack, x)
    if len(this.minStack) == 0 || x <= this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, x)
    }
}

func (this *MinStack) Pop() {
    if this.stack[len(this.stack)-1] == this.minStack[len(this.minStack)-1] {
        this.minStack = this.minStack[:len(this.minStack)-1]
    }
    this.stack = this.stack[:len(this.stack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

##### 24. 翻转链表
**题目：** 反转一个单链表。

**答案：** 使用迭代法。初始化三个指针，分别指向当前节点、前一个节点和后一个节点。遍历链表，每次迭代中，将当前节点的 `next` 指针指向前一个节点，然后更新三个指针。

```go
func reverseList(head *ListNode) *ListNode {
    var prev, curr = nil, head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

##### 25. 最小差值
**题目：** 给定一个整数数组 `nums`，找到 `nums` 中两个不同索引的 `i` 和 `j`，使得 `nums[i] - nums[j]` 的绝对值最小。

**答案：** 使用双指针。初始化两个指针，一个指向数组的起始位置，一个指向数组的结束位置。在每次迭代中，比较两个指针指向的元素的差值的绝对值，如果差值大于零，将较小值的一侧的指针向中间移动。

```go
func minimumAbsDifference(nums []int) int {
    sort.Ints(nums)
    var minDiff = math.MaxInt64
    for i := 1; i < len(nums); i++ {
        if diff := abs(nums[i-1] - nums[i]); diff < minDiff {
            minDiff = diff
        }
    }
    return minDiff
}
```

##### 26. 环形链表
**题目：** 给定一个链表，判断链表中是否有环。

**答案：** 使用快慢指针。初始化两个指针，一个快指针每次移动两个节点，一个慢指针每次移动一个节点。如果链表中存在环，快指针最终会追上慢指针。

```go
func hasCycle(head *ListNode) bool {
    var slow, fast = head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

##### 27. 最小移动次数
**题目：** 给定一个整数数组 `nums`，找到使其和等于 `zero` 的最小移动次数。

**答案：** 使用前缀和。初始化一个哈希表，存储每个前缀和出现的次数。遍历数组，对于每个元素，计算当前前缀和，如果当前前缀和等于零，或者当前前缀和与零的差值在哈希表中出现，则返回移动次数。

```go
func minMoves(nums []int) int {
    var preSum = make(map[int]int)
    var count, sum = 0, 0
    preSum[0] = 1
    for _, num := range nums {
        sum += num
        count += preSum[sum] 
        preSum[sum]++
    }
    return sum - count
}
```

##### 28. 加密字符串
**题目：** 给定一个字符串 `s` ，按照字母表中任意字符出现的频率顺序将所有字符重新排列。

**答案：** 使用哈希表和排序。首先统计每个字符出现的频率，然后使用一个优先队列（小根堆）按照字符频率排序。遍历字符串，从优先队列中依次取出字符，并将字符频率减一，重新放入优先队列。

```go
func freqAlphabet(s string) string {
    var freq = make(map[rune]int)
    for _, char := range s {
        freq[char]++
    }
    var pq = make(PriorityQueue, 0)
    for char, count := range freq {
        pq = append(pq, &Node{Val: char, Weight: count})
    }
    heap.Init(pq)
    var result = make([]rune, 0, len(s))
    for pq.Len() > 0 {
        var node = heap.Pop(&pq).(*Node)
        result = append(result, node.Val)
        if node.Weight > 1 {
            heap.Push(&pq, &Node{Val: node.Val, Weight: node.Weight - 1})
        }
    }
    return string(result)
}
```

##### 29. 汇总区间
**题目：** 给定一个整数数组 `nums`，返回连续数字组合的所有区间的并集。

**答案：** 使用哈希表。遍历数组，对于每个元素，判断其前一个元素和当前元素是否相邻，如果相邻，则更新当前区间的结束位置；如果不相邻，则将当前区间添加到结果中，并初始化新的区间。

```go
func mergeIntervals(intervals [][]int) [][]int {
    var result = make([][]int, 0)
    var last = -1
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    for _, interval := range intervals {
        if last == -1 || interval[0] > result[last][1] {
            result = append(result, interval)
            last = interval[1]
        } else {
            result[last][1] = max(result[last][1], interval[1])
        }
    }
    return result
}
```

##### 30. 二进制表示中1的个数
**题目：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**答案：** 使用位操作。通过不断地将整数右移，每次右移一位，检查最低位是否为 1，如果是，则计数器加一。

```go
func hammingWeight(num uint32) int {
    var count = 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

#### 五、拓展题目

##### 31. 翻转二叉树
**题目：** 翻转一棵二叉树。

**答案：** 使用递归。交换当前节点的左右子树，然后递归翻转左右子树。

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

##### 32. 合并二叉树
**题目：** 给定两个二叉树，合并它们为一个新的二叉树。构造的树中应该直接使用给定树中的节点，不要创建任何新的二叉树节点。

**答案：** 使用递归。遍历两个树的节点，如果两个节点都不为空，则将它们的值相加，并递归合并左右子树；如果其中一个节点为空，则使用另一个节点的子树。

```go
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}
```

##### 33. 树的直径
**题目：** 给定一棵二叉树，求树的直径。

**答案：** 使用递归。遍历每个节点，计算以当前节点为根的子树的最大深度，然后计算直径为左右子树的最大深度之和。

```go
func treeDiameter(root *TreeNode) int {
    var diameter int
    var depth func(*TreeNode) int
    depth = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        left := depth(node.Left)
        right := depth(node.Right)
        diameter = max(diameter, left+right)
        return 1 + max(left, right)
    }
    depth(root)
    return diameter
}
```

##### 34. 最长递增子序列 II
**题目：** 给定一个整数数组，返回它的最长递增子序列的长度。

**答案：** 使用动态规划。初始化两个数组 `dp` 和 `len`，分别存储以当前元素为结尾的最长递增子序列的长度和当前元素对应的最长递增子序列。遍历数组，对于每个元素，遍历前面的元素，更新 `dp` 和 `len` 数组。

```go
func lengthOfLIS(nums []int) int {
    var dp = make([]int, len(nums))
    var len = make([]int, len(nums))
    for i := range nums {
        dp[i] = 1
        len[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                if dp[i] < dp[j]+1 {
                    dp[i] = dp[j] + 1
                }
                if len[i] < len[j]+1 {
                    len[i] = len[j] + 1
                }
            }
        }
    }
    return max(dp...)
}
```

##### 35. 合并K个排序链表
**题目：** 给定K个排序后的链表，请你合并它们为一个新的排序链表。

**答案：** 使用优先队列。初始化一个优先队列，将每个链表的头节点加入优先队列。每次从优先队列中取出最小节点，将其添加到结果链表中，并将该节点的下一个节点加入优先队列。

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    var dummy = &ListNode{0, nil}
    var curr = dummy
    var pq = make(PriorityQueue, 0)
    for _, list := range lists {
        if list != nil {
            pq = append(pq, &Node{Val: list.Val, Next: list.Next})
        }
    }
    heap.Init(pq)
    for pq.Len() > 0 {
        var node = heap.Pop(&pq).(*Node)
        curr.Next = &ListNode{Val: node.Val}
        curr = curr.Next
        if node.Next != nil {
            pq = append(pq, &Node{Val: node.Next.Val, Next: node.Next.Next})
        }
    }
    return dummy.Next
}
```

##### 36. 合并两个有序链表
**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**答案：** 使用递归。创建一个新的头节点，然后递归比较两个链表的当前节点，将较小的节点添加到新链表中，并递归处理该节点的下一个节点。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

##### 37. 前K个高频元素
**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，返回数组中频率最高的 `k` 个数字。

**答案：** 使用优先队列。初始化一个优先队列，将数组中的每个元素加入优先队列，如果优先队列的大小超过 `k`，则弹出队首元素。遍历完数组后，优先队列中剩余的元素即为频率最高的 `k` 个数字。

```go
func topKFrequent(nums []int, k int) []int {
    var pq = make(PriorityQueue, 0)
    var count = make(map[int]int)
    for _, num := range nums {
        count[num]++
    }
    for num, count := range count {
        pq = append(pq, &Node{Val: num, Weight: count})
    }
    heap.Init(pq)
    for pq.Len() > k {
        heap.Pop(&pq)
    }
    var result = make([]int, k)
    for i := range result {
        result[i] = pq[i].Val
    }
    return result
}
```

##### 38. 搜索二维矩阵
**题目：** 给定一个排序后的二维数组，编写一个算法，查找一个给定的目标值，并返回它的索引。你可以假设每个元素是唯一的。

**答案：** 使用二分查找。将二维数组视为一维数组，然后使用二分查找。找到中间行，然后在中间行中使用二分查找。

```go
func searchMatrix(matrix [][]int, target int) bool {
    var left, right = 0, len(matrix)-1
    for left <= right {
        var mid = (left + right) / 2
        if matrix[mid][0] <= target && matrix[mid][len(matrix[mid])-1] >= target {
            return binarySearch(matrix[mid], target)
        } else if matrix[mid][0] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return false
}

func binarySearch(nums []int, target int) bool {
    var left, right = 0, len(nums)-1
    for left <= right {
        var mid = (left + right) / 2
        if nums[mid] == target {
            return true
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return false
}
```

##### 39. 最长公共子序列
**题目：** 给定两个字符串，找到它们的最长公共子序列。

**答案：** 使用动态规划。创建一个二维数组，其中 `dp[i][j]` 表示字符串 `s1` 的前 `i` 个字符和字符串 `s2` 的前 `j` 个字符的最长公共子序列的长度。根据状态转移方程 `dp[i][j] = dp[i-1][j-1] + 1`（如果 `s1[i-1] == s2[j-1]`），或者 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（如果 `s1[i-1] != s2[j-1]`），计算每个位置的最长公共子序列长度。

```go
func longestCommonSubsequence(s1, s2 string) string {
    var dp = make([][]int, len(s1)+1)
    for i := range dp {
        dp[i] = make([]int, len(s2)+1)
    }
    for i := 1; i <= len(s1); i++ {
        for j := 1; j <= len(s2); j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var result = make([]rune, dp[len(s1)][len(s2)])
    var i, j = len(s1), len(s2)
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            result = append(result, s1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(result)
}
```

##### 40. 拼接最大数
**题目：** 给定一个长度为 `n` 的整数数组 `nums`，找到一个由 `nums` 中的两个长度相同的非空子数组，使得它们的和最大化。返回这两个子数组作为数组形式的答案。返回的数组形式的答案中，第一个元素是第一个子数组的长度，第二个元素是第二个子数组的长度。

**答案：** 使用动态规划。初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示前 `i` 个元素组成的子数组和前 `j` 个元素组成的子数组的和的最大值。根据状态转移方程 `dp[i][j] = max(dp[i-1][j-1]+nums[i-1], dp[i][j-1])`，计算每个位置的最大和。遍历 `dp` 数组，找到最大值对应的位置，计算出两个子数组的长度。

```go
func maxTwoSortedArrays(nums1 []int, nums2 []int) []int {
    var dp = make([][]int, len(nums1)+1)
    for i := range dp {
        dp[i] = make([]int, len(nums2)+1)
    }
    for i := 1; i <= len(nums1); i++ {
        for j := 1; j <= len(nums2); j++ {
            dp[i][j] = max(dp[i-1][j-1]+nums1[i-1], dp[i][j-1])
        }
    }
    var maxSum = 0
    var i, j = len(nums1), len(nums2)
    for i > 0 && j > 0 {
        if dp[i][j] > maxSum {
            maxSum = dp[i][j]
            if dp[i][j] == dp[i-1][j-1]+nums1[i-1] {
                i--
                j--
            } else {
                j--
            }
        } else {
            j--
        }
    }
    var result = make([]int, 2)
    result[0] = i
    result[1] = j
    return result
}
```

##### 41. 丢失的数字
**题目：** 给定一个包含 `0` 到 `n` 中 `n` 个数的数组 `nums` ，找出 `nums` 中的两个数，使得它们的和最小。如果有多个这样的数对，则返回所有可能的最小和。

**答案：** 使用动态规划。初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示前 `i` 个元素和前 `j` 个元素的最小和。根据状态转移方程 `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + nums[i-1]`，计算每个位置的最小和。遍历 `dp` 数组，找到最小值对应的位置，计算出最小和。

```go
func missingNumberPair(nums []int) []int {
    var dp = make([][]int, len(nums)+1)
    for i := range dp {
        dp[i] = make([]int, len(nums)+1)
    }
    for i := 1; i <= len(nums); i++ {
        for j := 1; j <= len(nums); j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + nums[i-1]
        }
    }
    var minSum = math.MaxInt64
    var i, j = len(nums), len(nums)
    for i > 0 && j > 0 {
        if dp[i][j] < minSum {
            minSum = dp[i][j]
            if dp[i][j] == dp[i-1][j] {
                i--
            } else {
                j--
            }
        } else {
            j--
        }
    }
    var result = make([]int, 2)
    result[0] = nums[i-1]
    result[1] = nums[j-1]
    return result
}
```

##### 42. 单调栈
**题目：** 给定一个数组 `nums`，返回两个元素，使得它们的乘积最小。

**答案：** 使用单调栈。遍历数组，对于每个元素，使用单调栈找到其左侧和右侧的第一个比它小的元素，计算乘积。更新最小乘积。

```go
func minProduct(nums []int) int {
    var stack = make([]int, 0)
    var minProduct = math.MaxInt64
    for _, num := range nums {
        for len(stack) > 0 && nums[stack[len(stack)-1]] >= num {
            stack = stack[:len(stack)-1]
        }
        var left = 0
        if len(stack) > 0 {
            left = nums[stack[len(stack)-1]]
        }
        for len(stack) > 0 && nums[stack[len(stack)-1]] <= num {
            stack = stack[:len(stack)-1]
        }
        var right = 0
        if len(stack) > 0 {
            right = nums[stack[len(stack)-1]]
        }
        var product = num * left * right
        if product < minProduct {
            minProduct = product
        }
        stack = append(stack, num)
    }
    return minProduct
}
```

##### 43. 最小差值 II
**题目：** 给定一个整数数组 `nums`，返回 `nums` 中两个数的最小差值。

**答案：** 使用排序和双指针。首先对数组进行排序，然后初始化两个指针，一个指向数组的起始位置，一个指向数组的第二个位置。在每次迭代中，比较两个指针指向的元素的差值，如果差值大于等于零，将起始位置的指针向右移动；否则，将第二个位置的指针向右移动。

```go
func minDifference(nums []int) int {
    sort.Ints(nums)
    var minDiff = math.MaxInt64
    for i := 1; i < len(nums); i++ {
        var diff = nums[i] - nums[i-1]
        if diff < minDiff {
            minDiff = diff
        }
    }
    return minDiff
}
```

##### 44. 合并数组
**题目：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使 `nums1` 也被排序。

**答案：** 使用双指针。初始化两个指针，一个指向 `nums1` 的最后一个元素，一个指向 `nums2` 的最后一个元素。在每次迭代中，比较两个指针指向的元素，将较大的元素放到 `nums1` 的起始位置，并更新指针。

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    var index1, index2 = m-1, n-1
    var index = m + n - 1
    for index1 >= 0 && index2 >= 0 {
        if nums1[index1] > nums2[index2] {
            nums1[index] = nums1[index1]
            index1--
        } else {
            nums1[index] = nums2[index2]
            index2--
        }
        index--
    }
    for index2 >= 0 {
        nums1[index] = nums2[index2]
        index2--
        index--
    }
}
```

##### 45. 搜索旋转排序数组
**题目：** 给定一个旋转后升序的数组，请返回它最小元素的下标。

**答案：** 使用二分查找。初始化两个指针，一个指向数组的起始位置，一个指向数组的结束位置。在每次迭代中，比较中间元素和起始元素的大小关系，如果中间元素大于起始元素，说明最小元素在右侧，将左指针移动到中间位置的右侧；否则，最小元素在左侧或中间，将右指针移动到中间位置的左侧。

```go
func search(nums []int) int {
    var left, right = 0, len(nums)-1
    for left < right {
        var mid = (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}
```

##### 46. 搜索旋转排序数组 II
**题目：** 给定一个可能包含重复元素的旋转数组，并给定一个目标值，判断是否存在有效的搜索旋转排序数组。

**答案：** 使用二分查找。初始化两个指针，一个指向数组的起始位置，一个指向数组的结束位置。在每次迭代中，比较中间元素和起始元素的大小关系，如果中间元素大于起始元素，说明最小元素在右侧，将左指针移动到中间位置的右侧；否则，最小元素在左侧或中间，将右指针移动到中间位置的左侧。如果中间元素等于起始元素，将左指针向右移动一位。

```go
func search(nums []int, target int) bool {
    var left, right = 0, len(nums)-1
    for left < right {
        var mid = (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
        if nums[mid] == nums[left] {
            left++
        }
    }
    var start := left
    if nums[start] <= target && nums[start] >= nums[right] {
        return binarySearch(nums, target, start, right)
    } else {
        return binarySearch(nums, target, left, len(nums)-1)
    }
}

func binarySearch(nums []int, target int, left int, right int) bool {
    for left <= right {
        var mid = (left + right) / 2
        if nums[mid] == target {
            return true
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return false
}
```

##### 47. 搜索旋转矩阵
**题目：** 给定一个包含 `m` x `n` 个元素的矩阵 `(matrix)` 和一个目标值 `target`，判断矩阵中是否含有这个目标值。包含或搜索矩阵是搜索二维矩阵的变体，矩阵中的每个元素都处于从左到右、从上到下的顺时针旋转 `90` 度的状态。

**答案：** 使用双指针。初始化四个指针，分别指向矩阵的左上角、右上角、右下角和左下角。在每次迭代中，比较当前指针指向的元素和目标值，如果当前指针指向的元素等于目标值，返回 `true`；如果当前指针指向的元素大于目标值，则移动右上角和左下角的指针；如果当前指针指向的元素小于目标值，则移动左上角和右下角的指针。

```go
func searchMatrix(matrix [][]int, target int) bool {
    var leftTop, rightTop, rightBottom, leftBottom = 0, 0, len(matrix)-1, len(matrix)-1
    for leftTop <= rightTop && rightBottom >= leftBottom {
        var top := matrix[leftTop][rightTop]
        var bottom := matrix[leftBottom][rightBottom]
        if top == target || bottom == target {
            return true
        }
        if top < bottom {
            if target > top && target < matrix[leftTop+1][rightTop] {
                rightTop++
            } else {
                leftTop++
            }
        } else {
            if target > bottom && target < matrix[leftBottom][rightBottom-1] {
                rightBottom--
            } else {
                leftBottom--
            }
        }
    }
    return false
}
```

##### 48. 有效的完全平方数
**题目：** 给定一个正整数 `num`，编写一个函数，如果 `num` 是一个完全平方数，则返回 `true`，否则返回 `false`。

**答案：** 使用二分查找。初始化两个指针，一个指向 `1`，一个指向 `num`。在每次迭代中，比较中间元素和目标值的关系，如果中间元素等于目标值，返回 `true`；如果中间元素大于目标值，将右指针移动到中间位置的左侧；如果中间元素小于目标值，将左指针移动到中间位置的右侧。

```go
func isPerfectSquare(num int) bool {
    var left, right = 1, num
    for left <= right {
        var mid = (left + right) / 2
        var square = mid * mid
        if square == num {
            return true
        } else if square > num {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return false
}
```

##### 49. 两数相加
**题目：** 给出两个非空的非负整数数组 `nums1` 和 `nums2`，请计算它们的和。

**答案：** 使用链表。初始化两个指针，分别指向 `nums1` 和 `nums2` 的末尾。在每次迭代中，将两个指针指向的元素相加，如果和大于等于 `10`，则进位 `1`，否则不进位。将和的个位数添加到结果链表中，并将指针向前移动。如果其中一个数组已经遍历完毕，则使用零填充剩余的位数。

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy = &ListNode{0, nil}
    var curr = dummy
    var carry = 0
    for l1 != nil || l2 != nil || carry != 0 {
        var val1 = 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        var val2 = 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        var sum = val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

##### 50. 合并有序数组
**题目：** 给定两个有序数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**答案：** 使用双指针。初始化两个指针，分别指向 `nums1` 和 `nums2` 的末尾。在每次迭代中，将较大的元素添加到 `nums1` 的起始位置，并更新指针。如果其中一个数组已经遍历完毕，则将另一个数组的剩余元素添加到 `nums1`。

```go
func mergeSortedArray(nums1 []int, m int, nums2 []int, n int) {
    var i, j = m-1, n-1
    var k = m + n - 1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

