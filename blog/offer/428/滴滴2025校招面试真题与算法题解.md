                 

### 滴滴2025校招面试真题与算法题解

#### 简介

本文汇集了滴滴出行2025校招的面试真题与算法题解，涵盖数据结构、算法、系统设计等多个领域。我们将逐题解析这些题目，并提供详细的答案解析和源代码实例，帮助广大求职者更好地备战校招面试。

#### 典型面试题与算法题解

1. **单例模式**

**题目描述：** 实现一个单例模式，确保类在一个程序中只有一个实例。

**答案：**

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**解析：** 以上代码通过静态变量和同步代码块实现了单例模式。双重检查锁（Double-Check Locking）模式保证了在多线程环境下单例的正确创建。

2. **快速排序**

**题目描述：** 实现一个快速排序算法。

**答案：**

```java
public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivot = partition(arr, low, high);
            quickSort(arr, low, pivot - 1);
            quickSort(arr, pivot + 1, high);
        }
    }

    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return i + 1;
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**解析：** 以上代码实现了快速排序算法，通过选择一个基准元素，将数组分成两部分，然后递归排序两部分。

3. **最小生成树**

**题目描述：** 实现一个最小生成树算法，以给定边权和顶点数构造最小生成树。

**答案：**

```java
public class KruskalMST {
    private static final int MAX = 10010;
    private static int[] parent = new int[MAX];
    private static int[] rank = new int[MAX];
    private static int edgeCount = 0;
    private static int[] edges;
    private static int[] weights;

    public static void kruskal(int n, int e) {
        initUnionFind(n);
        edges = new int[e];
        weights = new int[e];
        // 边按权值排序
        Arrays.sort(edges, 0, e);
        Arrays.sort(weights, 0, e);
        for (int i = 0; i < e; i++) {
            int u = edges[i];
            int v = find(u);
            if (v != u) {
                union(u, v);
                edgeCount++;
                if (edgeCount == n - 1) {
                    break;
                }
            }
        }
    }

    private static void initUnionFind(int n) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    private static int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    private static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP != rootQ) {
            if (rank[rootP] > rank[rootQ]) {
                parent[rootQ] = rootP;
            } else if (rank[rootP] < rank[rootQ]) {
                parent[rootP] = rootQ;
            } else {
                parent[rootQ] = rootP;
                rank[rootP]++;
            }
        }
    }
}
```

**解析：** 以上代码实现了Kruskal算法，通过构建并查集，以贪心策略选取最小权值边，直到生成最小生成树。

4. **二叉树遍历**

**题目描述：** 实现二叉树的先序、中序和后序遍历。

**答案：**

```java
public class BinaryTreeTraversal {
    public static void preOrder(TreeNode root) {
        if (root != null) {
            System.out.print(root.val + " ");
            preOrder(root.left);
            preOrder(root.right);
        }
    }

    public static void inOrder(TreeNode root) {
        if (root != null) {
            inOrder(root.left);
            System.out.print(root.val + " ");
            inOrder(root.right);
        }
    }

    public static void postOrder(TreeNode root) {
        if (root != null) {
            postOrder(root.left);
            postOrder(root.right);
            System.out.print(root.val + " ");
        }
    }
}
```

**解析：** 以上代码实现了二叉树的先序、中序和后序遍历。先序遍历首先访问根节点，然后递归遍历左子树和右子树；中序遍历首先递归遍历左子树，然后访问根节点，最后递归遍历右子树；后序遍历首先递归遍历左子树，然后递归遍历右子树，最后访问根节点。

5. **最长公共子序列**

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```java
public class LongestCommonSubsequence {
    public static String lcs(String a, String b) {
        int m = a.length();
        int n = b.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (a.charAt(i - 1) == b.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        StringBuilder result = new StringBuilder();
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (a.charAt(i - 1) == b.charAt(j - 1)) {
                result.insert(0, a.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }

        return result.toString();
    }
}
```

**解析：** 以上代码实现了最长公共子序列算法。通过动态规划，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `a` 的前 `i` 个字符和字符串 `b` 的前 `j` 个字符的最长公共子序列的长度。最后，通过回溯找到最长公共子序列。

6. **图的最短路径**

**题目描述：** 给定一个图和两个顶点，求它们之间的最短路径。

**答案：**

```java
public class Dijkstra {
    public static int shortestPath(int[][] graph, int start, int end) {
        int n = graph.length;
        int[] dist = new int[n];
        boolean[] visited = new boolean[n];

        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;

        for (int i = 0; i < n - 1; i++) {
            int minDist = Integer.MAX_VALUE;
            int minIndex = -1;

            for (int j = 0; j < n; j++) {
                if (!visited[j] && dist[j] < minDist) {
                    minDist = dist[j];
                    minIndex = j;
                }
            }

            visited[minIndex] = true;

            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    dist[j] = Math.min(dist[j], dist[minIndex] + graph[minIndex][j]);
                }
            }
        }

        return dist[end];
    }
}
```

**解析：** 以上代码实现了Dijkstra算法，用于求单源最短路径。初始化一个距离数组 `dist` 和一个已访问数组 `visited`。每次迭代找到未访问节点中距离源点最近的节点，更新其他节点的距离。

7. **字符串匹配算法**

**题目描述：** 实现KMP字符串匹配算法。

**答案：**

```java
public class KMP {
    public static int[] computeLPS(String pattern) {
        int len = pattern.length();
        int[] lps = new int[len];
        int lenPattern = 0;
        int i = 1;

        while (i < len) {
            if (pattern.charAt(i) == pattern.charAt(lenPattern)) {
                lenPattern++;
                lps[i] = lenPattern;
                i++;
            } else {
                if (lenPattern != 0) {
                    lenPattern = lps[lenPattern - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    public static int search(String text, String pattern) {
        int[] lps = computeLPS(pattern);
        int i = 0; // index for text
        int j = 0; // index for pattern
        while (i < text.length()) {
            if (pattern.charAt(j) == text.charAt(i)) {
                i++;
                j++;
            }
            if (j == pattern.length()) {
                return i - j;
            } else if (i < text.length() && pattern.charAt(j) != text.charAt(i)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i = i + 1;
                }
            }
        }
        return -1;
    }
}
```

**解析：** 以上代码实现了KMP算法，用于字符串匹配。计算LPS数组，用于避免回溯。当匹配失败时，根据LPS数组跳到下一个可能的匹配位置。

8. **斐波那契数列**

**题目描述：** 实现斐波那契数列。

**答案：**

```java
public class Fibonacci {
    public static int fib(int n) {
        if (n <= 1) {
            return n;
        }
        int a = 0, b = 1, sum = 0;
        for (int i = 2; i <= n; i++) {
            sum = a + b;
            a = b;
            b = sum;
        }
        return b;
    }
}
```

**解析：** 以上代码实现了斐波那契数列。使用循环迭代求解，时间复杂度为O(n)。

9. **二分查找**

**题目描述：** 实现二分查找算法。

**答案：**

```java
public class BinarySearch {
    public static int search(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

**解析：** 以上代码实现了二分查找算法。通过不断缩小区间，直到找到目标元素或确定元素不存在。

10. **合并区间**

**题目描述：** 给定一组区间，合并重叠的区间。

**答案：**

```java
public class MergeIntervals {
    public static int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][0];
        }
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        List<int[]> result = new ArrayList<>();
        result.add(intervals[0]);

        for (int i = 1; i < intervals.length; i++) {
            int[] prev = result.get(result.size() - 1);
            int[] curr = intervals[i];
            if (curr[0] <= prev[1]) {
                prev[1] = Math.max(prev[1], curr[1]);
            } else {
                result.add(curr);
            }
        }
        return result.toArray(new int[0][0]);
    }
}
```

**解析：** 以上代码实现了合并区间算法。首先对区间进行排序，然后遍历区间，合并重叠的部分。

11. **环形缓冲区**

**题目描述：** 实现一个环形缓冲区。

**答案：**

```java
public class CircularBuffer {
    private int[] buffer;
    private int head;
    private int tail;
    private int capacity;

    public CircularBuffer(int capacity) {
        this.buffer = new int[capacity];
        this.head = 0;
        this.tail = 0;
        this.capacity = capacity;
    }

    public void enqueue(int item) {
        buffer[tail] = item;
        tail = (tail + 1) % capacity;
        if (tail == head) {
            head = (head + 1) % capacity;
        }
    }

    public int dequeue() {
        if (head == tail) {
            throw new NoSuchElementException();
        }
        int item = buffer[head];
        head = (head + 1) % capacity;
        return item;
    }

    public int size() {
        return (tail - head + capacity) % capacity;
    }
}
```

**解析：** 以上代码实现了环形缓冲区。使用一个循环数组来存储元素，通过 head 和 tail 指针来管理缓冲区。

12. **快速幂**

**题目描述：** 实现快速幂算法。

**答案：**

```java
public class QuickPower {
    public static int power(int x, int n) {
        if (n == 0) {
            return 1;
        }
        if (n < 0) {
            x = 1 / x;
            n = -n;
        }
        int result = 1;
        while (n > 0) {
            if ((n & 1) == 1) {
                result *= x;
            }
            x *= x;
            n >>= 1;
        }
        return result;
    }
}
```

**解析：** 以上代码实现了快速幂算法。通过将指数分解为2的幂次，避免重复计算。

13. **最大子序和**

**题目描述：** 给定一个整数数组，找出最大子序和。

**答案：**

```java
public class MaxSubarraySum {
    public static int maxSubarraySum(int[] nums) {
        int maxSum = nums[0];
        int currentSum = nums[0];
        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }
        return maxSum;
    }
}
```

**解析：** 以上代码实现了最大子序和算法。通过维护当前子序列和，更新最大子序列和。

14. **最长公共前缀**

**题目描述：** 给定一个字符串数组，找出最长公共前缀。

**答案：**

```java
public class LongestCommonPrefix {
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return "";
                }
            }
        }
        return prefix;
    }
}
```

**解析：** 以上代码实现了最长公共前缀算法。通过逐个比较字符串，不断缩短公共前缀。

15. **两数相加**

**题目描述：** 给定两个非空链表，表示两个非负整数，每个节点包含一个数字。返回这两个数字相加的结果，以链表形式返回。

**答案：**

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public class AddTwoNumbers {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p = l1, q = l2, curr = dummyHead;
        int carry = 0;
        while (p != null || q != null) {
            int x = (p != null) ? p.val : 0;
            int y = (q != null) ? q.val : 0;
            int sum = carry + x + y;
            carry = sum / 10;
            curr.next = new ListNode(sum % 10);
            curr = curr.next;
            if (p != null) p = p.next;
            if (q != null) q = q.next;
        }
        if (carry > 0) {
            curr.next = new ListNode(carry);
        }
        return dummyHead.next;
    }
}
```

**解析：** 以上代码实现了两数相加的算法。通过模拟加法过程，处理进位，构建结果链表。

16. **合并两个有序链表**

**题目描述：** 给定两个已排序的链表，将它们合并成一个有序链表。

**答案：**

```java
public class MergeTwoSortedLists {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        curr.next = l1 == null ? l2 : l1;
        return dummy.next;
    }
}
```

**解析：** 以上代码实现了合并两个有序链表的算法。通过遍历两个链表，按顺序合并节点。

17. **反转链表**

**题目描述：** 实现一个函数，用于反转单链表。

**答案：**

```java
public class ReverseLinkedList {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
}
```

**解析：** 以上代码实现了反转链表的算法。通过遍历链表，逐个反转每个节点的指向。

18. **最大连续1的个数**

**题目描述：** 给定一个二进制数组，找出其中最长连续1的个数。

**答案：**

```java
public class MaxConsecutiveOnes {
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0, count = 0;
        for (int num : nums) {
            if (num == 1) {
                count++;
                max = Math.max(max, count);
            } else {
                count = 0;
            }
        }
        return max;
    }
}
```

**解析：** 以上代码实现了最大连续1的个数的算法。通过遍历数组，记录连续1的个数，更新最大值。

19. **三数之和**

**题目描述：** 给定一个整数数组，找出三个元素的和等于0的元素。

**答案：**

```java
public class ThreeSum {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int j = i + 1, k = nums.length - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                    while (j < k && nums[j] == nums[j + 1]) j++;
                    while (j < k && nums[k] == nums[k - 1]) k--;
                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }
        return result;
    }
}
```

**解析：** 以上代码实现了三数之和的算法。首先对数组进行排序，然后使用双指针遍历数组，找出三个元素的和等于0的元素。

20. **最长公共子串**

**题目描述：** 给定两个字符串，找出它们的最长公共子串。

**答案：**

```java
public class LongestCommonSubstring {
    public String longestCommonSubstring(String str1, String str2) {
        int[][] dp = new int[str1.length() + 1][str2.length() + 1];
        int maxLen = 0;
        int endIndex = 0;
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    if (dp[i][j] > maxLen) {
                        maxLen = dp[i][j];
                        endIndex = i - 1;
                    }
                }
            }
        }
        return str1.substring(endIndex - maxLen + 1, endIndex + 1);
    }
}
```

**解析：** 以上代码实现了最长公共子串的算法。使用动态规划构建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `str1` 的前 `i` 个字符和字符串 `str2` 的前 `j` 个字符的最长公共子串的长度。最后，通过回溯找到最长公共子串。

21. **二叉树的层序遍历**

**题目描述：** 实现二叉树的层序遍历。

**答案：**

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class BinaryTreeLevelOrderTraversal {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> currentLevel = new ArrayList<>();
            int levelSize = queue.size();
            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();
                currentLevel.add(currentNode.val);
                if (currentNode.left != null) {
                    queue.offer(currentNode.left);
                }
                if (currentNode.right != null) {
                    queue.offer(currentNode.right);
                }
            }
            result.add(currentLevel);
        }
        return result;
    }
}
```

**解析：** 以上代码实现了二叉树的层序遍历。使用广度优先搜索（BFS）遍历二叉树的每一层，并将每层的元素放入结果列表中。

22. **零钱兑换**

**题目描述：** 给定一个数组 coins 表示硬币的面额，和一个整数 amount 表示总金额。计算最少需要多少枚硬币组合出给定的金额 amount。

**答案：**

```java
public class CoinChange {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

**解析：** 以上代码实现了零钱兑换的算法。使用动态规划，构建一个一维数组 `dp`，其中 `dp[i]` 表示最少需要多少枚硬币组合出金额 `i`。通过遍历每个硬币，更新 `dp` 数组的值。

23. **打家劫舍**

**题目描述：** 你是一个盗贼，要偷窃一排房屋。但是，相邻的房屋装有相互连通的防盗系统，如果你同时窃取两所房屋，会自动报警。计算你最多可以偷窃多少金额。

**答案：**

```java
public class HouseRobber {
    public int rob(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.length - 1];
    }
}
```

**解析：** 以上代码实现了打家劫舍的算法。使用动态规划，构建一个一维数组 `dp`，其中 `dp[i]` 表示前 `i` 所房屋可以偷窃的最大金额。通过遍历每个房屋，更新 `dp` 数组的值。

24. **合并两个有序链表**

**题目描述：** 给定两个已排序的链表，将它们合并成一个有序链表。

**答案：**

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public class MergeTwoSortedLists {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        if (l1 != null) {
            curr.next = l1;
        } else if (l2 != null) {
            curr.next = l2;
        }
        return dummy.next;
    }
}
```

**解析：** 以上代码实现了合并两个有序链表的算法。通过遍历两个链表，按顺序合并节点。

25. **最长公共子序列**

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```java
public class LongestCommonSubsequence {
    public String longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        StringBuilder result = new StringBuilder();
        int i = m, j = n;
        while (i > 0 && j > 0) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                result.append(text1.charAt(i - 1));
                i--;
                j--;
            } else if (dp[i - 1][j] > dp[i][j - 1]) {
                i--;
            } else {
                j--;
            }
        }
        return result.reverse().toString();
    }
}
```

**解析：** 以上代码实现了最长公共子序列的算法。使用动态规划构建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 的前 `i` 个字符和字符串 `text2` 的前 `j` 个字符的最长公共子序列的长度。最后，通过回溯找到最长公共子序列。

26. **LRU缓存**

**题目描述：** 设计一个LRU（最近最少使用）缓存。

**答案：**

```java
import java.util.HashMap;
import java.util.Map;

public class LRUCache {
    private int capacity;
    private Map<Integer, Node> cache;
    private Node head;
    private Node tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>(capacity);
        head = new Node(-1, -1);
        tail = new Node(-1, -1);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        Node node = cache.get(key);
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            moveToHead(node);
        } else {
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            if (cache.size() > capacity) {
                Node lastNode = tail.prev;
                removeNode(lastNode);
                cache.remove(lastNode.key);
            }
        }
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addNode(node);
    }

    private void addNode(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private static class Node {
        int key;
        int value;
        Node prev;
        Node next;

        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
}
```

**解析：** 以上代码实现了LRU缓存。使用双向链表和哈希表，确保在常数时间内完成插入、删除和查找操作。

27. **栈和队列**

**题目描述：** 实现栈和队列。

**答案：**

```java
import java.util.LinkedList;
import java.util.Queue;

public class StackQueue {
    private LinkedList<Integer> stack;
    private Queue<Integer> queue;

    public StackQueue() {
        stack = new LinkedList<>();
        queue = new LinkedList<>();
    }

    public void push(int x) {
        stack.push(x);
    }

    public void enqueue(int x) {
        queue.offer(x);
    }

    public int pop() {
        return stack.pop();
    }

    public int dequeue() {
        return queue.poll();
    }
}
```

**解析：** 以上代码分别实现了栈和队列。栈使用链表实现，队列使用链表实现。

28. **快速幂**

**题目描述：** 实现快速幂算法。

**答案：**

```java
public class QuickPower {
    public int quickPower(int x, int n) {
        if (n == 0) {
            return 1;
        }
        if (n < 0) {
            x = 1 / x;
            n = -n;
        }
        int result = 1;
        while (n > 0) {
            if ((n & 1) == 1) {
                result *= x;
            }
            x *= x;
            n >>= 1;
        }
        return result;
    }
}
```

**解析：** 以上代码实现了快速幂算法。通过将指数分解为2的幂次，避免重复计算。

29. **最长公共前缀**

**题目描述：** 实现最长公共前缀。

**答案：**

```java
public class LongestCommonPrefix {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        String prefix = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return "";
                }
            }
        }
        return prefix;
    }
}
```

**解析：** 以上代码实现了最长公共前缀的算法。通过逐个比较字符串，不断缩短公共前缀。

30. **三数之和**

**题目描述：** 实现三数之和。

**答案：**

```java
public class ThreeSum {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int j = i + 1, k = nums.length - 1;
            while (j < k) {
                int sum = nums[i] + nums[j] + nums[k];
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                    while (j < k && nums[j] == nums[j + 1]) j++;
                    while (j < k && nums[k] == nums[k - 1]) k--;
                    j++;
                    k--;
                } else if (sum < 0) {
                    j++;
                } else {
                    k--;
                }
            }
        }
        return result;
    }
}
```

**解析：** 以上代码实现了三数之和的算法。首先对数组进行排序，然后使用双指针遍历数组，找出三个元素的和等于0的元素。通过跳过重复的元素，优化搜索过程。

### 总结

以上是滴滴出行2025校招的面试真题与算法题解，涵盖多个领域和算法。通过详细解析和源代码实例，希望对求职者备战校招面试有所帮助。在面试中，不仅要掌握算法本身，还要了解其背后的原理和应用场景。祝大家在面试中取得好成绩！

