                 

### 字节跳动校招编程面试题精选与解答

#### 1. 字符串反转

**题目描述：**
编写一个函数，实现字符串反转。

**示例：**
输入："abcdef"，输出："fedcba"

**答案：**
```go
func reverseString(s string) string {
    runes := []rune(s)
    left, right := 0, len(runes)-1
    for left < right {
        runes[left], runes[right] = runes[right], runes[left]
        left++
        right--
    }
    return string(runes)
}

// 调用示例
fmt.Println(reverseString("abcdef")) // 输出：fedcba
```

**解析：**
使用字符数组来存储字符串，然后利用双指针法，将字符串两端的字符进行交换，直到中间位置。最后将字符数组转换回字符串返回。

#### 2. 回文数

**题目描述：**
判断一个整数是否是回文数。

**示例：**
输入：121，输出：true；输入：-121，输出：false。

**答案：**
```go
func isPalindrome(x int) bool {
    if x < 0 || (x != 0 && x%10 == 0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x /= 10
    }
    return x == reversed || x == reversed/10
}

// 调用示例
fmt.Println(isPalindrome(121)) // 输出：true
fmt.Println(isPalindrome(-121)) // 输出：false
```

**解析：**
通过不断取余和整除来构造回文数的后半部分，然后与原数进行比较。需要注意处理负数和尾数为0的情况。

#### 3. 合并两个有序链表

**题目描述：**
将两个有序链表合并为一个新的有序链表并返回。链表节点定义如下：

```go
type ListNode struct {
    Val int
    Next *ListNode
}
```

**示例：**
输入：l1 = [1,2,4], l2 = [1,3,4]，输出：[1,1,2,3,4,4]。

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    prev := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            prev.Next = l1
            l1 = l1.Next
        } else {
            prev.Next = l2
            l2 = l2.Next
        }
        prev = prev.Next
    }
    if l1 != nil {
        prev.Next = l1
    } else if l2 != nil {
        prev.Next = l2
    }
    return dummy.Next
}

// 调用示例
// 定义链表节点
var n1, n2, n3, n4 = &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: nil}}},
    &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
// 合并链表
mergedHead := mergeTwoLists(n1, n2)
// 输出合并后的链表
for mergedHead != nil {
    fmt.Println(mergedHead.Val)
    mergedHead = mergedHead.Next
}
```

**解析：**
使用哑节点（dummy）简化操作，遍历两个链表，每次选择较小值的节点，连接到 prev 指针。最后将剩余的链表连接到合并后的链表末尾。

#### 4. 两数相加

**题目描述：**
不使用 + 或 - 运算符，实现两个整数相加。

**示例：**
输入：2, 3，输出：5；输入：-2, 1，输出：-1。

**答案：**
```go
func add(a int, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}

// 调用示例
fmt.Println(add(2, 3)) // 输出：5
fmt.Println(add(-2, 1)) // 输出：-1
```

**解析：**
利用异或运算（^）进行加法，利用与运算（&）进行进位处理。循环直到没有进位，即 b 变为 0。

#### 5. 二进制求和

**题目描述：**
给定两个二进制字符串，返回他们的和（用二进制表示）。

**示例：**
输入："11"，"1"，输出："100"；输入："1010"，"1011"，输出："10101"。

**答案：**
```go
func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    ans := []byte{}
    for i >= 0 || j >= 0 || carry != 0 {
        x, y := 0, 0
        if i >= 0 {
            x = int(a[i] - '0')
            i--
        }
        if j >= 0 {
            y = int(b[j] - '0')
            j--
        }
        sum := x + y + carry
        ans = append([]byte{byte(sum%2 + '0')}, ans...)
        carry = sum / 2
    }
    return string(ans)
}

// 调用示例
fmt.Println(addBinary("11", "1")) // 输出："100"
fmt.Println(addBinary("1010", "1011")) // 输出："10101"
```

**解析：**
从低位开始相加，记录进位，最后将结果转换成二进制字符串。

#### 6. 爬楼梯

**题目描述：**
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**
输入：3，输出：3。

**答案：**
```go
func climbStairs(n int) int {
    if n == 1 || n == 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}

// 调用示例
fmt.Println(climbStairs(3)) // 输出：3
```

**解析：**
利用动态规划，上一级的方法数等于前两级的方法数之和。

#### 7. 罗马数字转整数

**题目描述：**
罗马数字包含以下七种字符:I，V，X，L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

例如，2 需要写成 II，9 需要写成 IX。罗马数字中，I 只能放在 V 和 X 的左边，X 只能放在 L 和 C 的左边，C 只能放在 D 和 M 的左边。

```
示例 1:
输入: "III"
输出: 3
```

```
示例 2:
输入: "IV"
输出: 4
```

```
示例 3:
输入: "IX"
输出: 9
```

```
示例 4:
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

```
示例 5:
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

**答案：**
```go
func romanToInteger(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    ans := 0
    for i := 0; i < len(s); i++ {
        v := m[s[i]]
        if i+1 < len(s) && v < m[s[i+1]] {
            ans -= v
        } else {
            ans += v
        }
    }
    return ans
}

// 调用示例
fmt.Println(romanToInteger("III")) // 输出：3
fmt.Println(romanToInteger("IV")) // 输出：4
fmt.Println(romanToInteger("IX")) // 输出：9
fmt.Println(romanToInteger("LVIII")) // 输出：58
fmt.Println(romanToInteger("MCMXCIV")) // 输出：1994
```

**解析：**
遍历字符串，将当前字符对应的值加入结果。如果当前字符的值小于下一个字符的值，则减去当前字符的值，否则加上。

#### 8. 等差数列划分

**题目描述：**
给定一个整数数组 nums，判断是否存在长度为 3 的子数组，使其和等于 0。

**示例：**
输入：nums = [-3, 1, 2, -3, 4]，输出：true；输入：nums = [0, 0, 0]，输出：true。

**答案：**
```go
func checkZeroSubarray(nums []int) bool {
    s := 0
    m := map[int]bool{0: true}
    for _, num := range nums {
        s += num
        if _, ok := m[s]; ok {
            return true
        }
        m[s] = true
    }
    return false
}

// 调用示例
fmt.Println(checkZeroSubarray([]int{-3, 1, 2, -3, 4})) // 输出：true
fmt.Println(checkZeroSubarray([]int{0, 0, 0})) // 输出：true
```

**解析：**
利用前缀和和哈希表，判断是否存在前缀和相同的子数组。如果存在，则说明子数组的和为 0。

#### 9. 合并区间

**题目描述：**
以数组 intervals 表示若干个区间的合并，其中 intervals[i] = [starti, endi] 。返回一个数组，该数组表示重合区间后形成的所有区间的起始端点和终止端点。

**示例：**
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]，输出：[[1,6],[8,10],[15,18]]；输入：intervals = [[1,4],[4,5]]，输出：[[1,5]]。

**答案：**
```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

// 调用示例
fmt.Println(merge([][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}})) // 输出：[[1,6],[8,10],[15,18]]
fmt.Println(merge([][]int{{1, 4}, {4, 5}})) // 输出：[[1,5]]
```

**解析：**
首先对数组进行排序，然后遍历数组，合并重叠的区间。

#### 10. 有效的数独

**题目描述：**
判断一个 9x9 数组是否为有效的数独。

**示例：**
输入：board = [["5", "3", ".", ".", "7", ".", ".", ".", "."], [".", "6", ".", "1", "9", "5", ".", ".", "."], [".", "9", "8", ".", ".", ".", ".", "6", "."], ["8", ".", ".", "8", ".", ".", "7", "9", "."], ["7", "1", ".", "5", ".", ".", ".", "3", "6"], [".", "8", ".", ".", "6", ".", ".", "1", "3"], [".", "6", ".", "1", "5", "9", "8", ".", "."], ["2", "7", ".", "4", "8", "3", ".", "6", "."], ["9", "5", ".", "6", "1", "7", "4", "2", "8"]]，输出：true；输入：board = [["8", "3", ".", ".", "7", ".", ".", ".", "."], [".", "6", ".", "1", "9", "5", ".", ".", "."], [".", "9", "8", ".", ".", ".", "6", "."], ["8", ".", ".", "8", ".", ".", "7", "9", "."], ["7", "1", ".", "5", ".", ".", ".", "3", "6"], [".", "8", ".", ".", "6", ".", ".", "1", "3"], [".", "6", ".", "1", "5", "9", "8", ".", "."], ["2", "7", ".", "4", "8", "3", ".", "6", "."], ["9", "5", ".", "6", "1", "7", "4", "2", "8"]]，输出：false。

**答案：**
```go
func isValidSudoku(board [][]byte) bool {
    rows := [9]bool{}
    cols := [9]bool{}
    boxes := [9]bool{}
    for i, row := range board {
        for j, v := range row {
            if v == '.' {
                continue
            }
            idx := i/3*3 + j/3
            if rows[i] || cols[j] || boxes[idx] {
                return false
            }
            rows[i] = true
            cols[j] = true
            boxes[idx] = true
        }
    }
    return true
}

// 调用示例
fmt.Println(isValidSudoku([][]byte{{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
                                   {'.', '6', '.', '1', '9', '5', '.', '.', '.'},
                                   {'.', '9', '8', '.', '.', '.', '6', '.', '.'},
                                   {'8', '.', '.', '8', '.', '.', '7', '9', '.'},
                                   {'7', '1', '.', '5', '.', '.', '.', '3', '6'},
                                   {'.', '8', '.', '.', '6', '.', '.', '1', '3'},
                                   {'.', '6', '.', '1', '5', '9', '8', '.', '.'},
                                   {'2', '7', '.', '4', '8', '3', '.', '6', '.'},
                                   {'9', '5', '.', '6', '1', '7', '4', '2', '8'}})) // 输出：true
fmt.Println(isValidSudoku([][]byte{{'8', '3', '.', '.', '7', '.', '.', '.', '.'},
                                   {'.', '6', '.', '1', '9', '5', '.', '.', '.'},
                                   {'.', '9', '8', '.', '.', '.', '6', '.', '.'},
                                   {'8', '.', '.', '8', '.', '.', '7', '9', '.'},
                                   {'7', '1', '.', '5', '.', '.', '.', '3', '6'},
                                   {'.', '8', '.', '.', '6', '.', '.', '1', '3'},
                                   {'.', '6', '.', '1', '5', '9', '8', '.', '.'},
                                   {'2', '7', '.', '4', '8', '3', '.', '6', '.'},
                                   {'9', '5', '.', '6', '1', '7', '4', '2', '8'}})) // 输出：false
```

**解析：**
遍历数组，使用三个布尔数组记录行、列和块是否已包含当前数字。如果已包含，则返回 false。

#### 11. 两数之和

**题目描述：**
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**
输入：nums = [2, 7, 11, 15], target = 9，输出：[0, 1]，输入：nums = [3, 2, 4], target = 6，输出：[1, 2]。

**答案：**
```go
func twoSum(nums []int, target int) []int {
    m := map[int]int{}
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}

// 调用示例
fmt.Println(twoSum([]int{2, 7, 11, 15}, 9)) // 输出：[0, 1]
fmt.Println(twoSum([]int{3, 2, 4}, 6)) // 输出：[1, 2]
```

**解析：**
利用哈希表，遍历数组，计算当前数字的补数，如果补数存在于哈希表中，则返回当前下标和补数对应的下标。

#### 12. 最长公共前缀

**题目描述：**
编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
输入：strs = ["flower", "flow", "flight"]，输出："fl"；输入：strs = ["dog", "racecar", "car"]，输出：""

**答案：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, s := range strs[1:] {
        for i := 0; i < len(prefix) && i < len(s); i++ {
            if prefix[i] != s[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}

// 调用示例
fmt.Println(longestCommonPrefix([]string{"flower", "flow", "flight"})) // 输出："fl"
fmt.Println(longestCommonPrefix([]string{"dog", "racecar", "car"})) // 输出：""
```

**解析：**
遍历字符串数组，从第一个字符串开始，逐步缩小公共前缀。

#### 13. 二进制中1的个数

**题目描述：**
编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**示例：**
输入：00000000000000000000000000001011，输出：3；输入：11111111111111111111111111111101，输出：31。

**答案：**
```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}

// 调用示例
fmt.Println(hammingWeight(uint32(0b00000000000000000000000000001011))) // 输出：3
fmt.Println(hammingWeight(uint32(0b11111111111111111111111111111101))) // 输出：31
```

**解析：**
利用位运算，不断将数右移并判断最低位是否为 1，累计计数。

#### 14. 寻找两个正序数组的中位数

**题目描述：**
给定两个大小为 m 和 n 的正序数组 nums1 和 nums2，请从这两个数组中各选择一个数字，计算出它们的 中位数。

**示例：**
输入：nums1 = [1, 3]，nums2 = [2]，输出：2；输入：nums1 = [1, 2]，nums2 = [3, 4]，输出：2.5。

**答案：**
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i < m {
                minOfRight = nums1[i]
            } else {
                minOfRight = nums2[j]
            }
            return float64(maxOfLeft+minOfRight) / 2
        }
    }
    return 0
}

// 调用示例
fmt.Println(findMedianSortedArrays([]int{1, 3}, []int{2})) // 输出：2
fmt.Println(findMedianSortedArrays([]int{1, 2}, []int{3, 4})) // 输出：2.5
```

**解析：**
利用二分查找，在两个有序数组中寻找中位数。通过调整 i 和 j 的值，确保最大左边的数小于或等于最小右边的数。

#### 15. 反转链表

**题目描述：**
定义一个函数，实现单链表的反转。

**示例：**
输入：1->2->3->4->5，输出：5->4->3->2->1。

**答案：**
```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head
    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}

// 调用示例
func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

n1 := &ListNode{Val: 1}
n2 := &ListNode{Val: 2}
n3 := &ListNode{Val: 3}
n4 := &ListNode{Val: 4}
n5 := &ListNode{Val: 5}
n1.Next = n2
n2.Next = n3
n3.Next = n4
n4.Next = n5

printList(reverseList(n1))
```

**解析：**
利用递归或循环，逐个将链表的每个节点指向前一个节点，实现链表反转。

#### 16. 螺旋矩阵

**题目描述：**
给定一个包含 m x n 个元素的矩阵（m 行、n 列），按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例：**
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]，输出：[1,2,3,6,9,8,7,4,5]。

**答案：**
```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    ans := []int{}
    r1, r2, c1, c2 := 0, len(matrix), 0, len(matrix[0])
    for len(ans) < len(matrix)*len(matrix[0]) {
        for c2 > c1 {
            ans = append(ans, matrix[r1][c1])
            c1++
        }
        for r2 > r1 {
            ans = append(ans, matrix[r2][c2-1])
            r2--
        }
        if r1 < r2 {
            for c2 > c1 {
                ans = append(ans, matrix[r1][c2-1])
                c2--
            }
        }
        if c1 < c2 {
            for r2 > r1 {
                ans = append(ans, matrix[r2][c1])
                r1++
            }
        }
    }
    return ans
}

// 调用示例
fmt.Println(spiralOrder([][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}})) // 输出：[1,2,3,6,9,8,7,4,5]
```

**解析：**
按照螺旋的顺序，逐步填充答案数组。每次循环处理矩阵的一圈，分别处理上、右、下、左边界。

#### 17. 合并两个有序链表

**题目描述：**
将两个有序链表合并为一个新的有序链表并返回。链表节点定义如下：

```go
type ListNode struct {
    Val int
    Next *ListNode
}
```

**示例：**
输入：l1 = [1,2,4]，l2 = [1,3,4]，输出：[1,1,2,3,4,4]。

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

// 调用示例
// 定义链表节点
var n1, n2, n3, n4 = &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: nil}}},
    &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
// 合并链表
mergedHead := mergeTwoLists(n1, n2)
// 输出合并后的链表
for mergedHead != nil {
    fmt.Println(mergedHead.Val)
    mergedHead = mergedHead.Next
}
```

**解析：**
递归合并两个有序链表。比较当前节点的值，选择较小的节点作为新的头节点，并递归合并下一个节点。

#### 18. 合并两个有序数组

**题目描述：**
给你两个整数数组 nums1 和 nums2 ，按升序整理数组 nums1 和 nums2 ，并将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

**示例：**
输入：nums1 = [1,2,3,0,0,0]，nums2 = [2,5,6]，输出：[1,2,2,3,5,6]。

**答案：**
```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}

// 调用示例
nums1 := []int{1, 2, 3, 0, 0, 0}
nums2 := []int{2, 5, 6}
merge(nums1, 3, nums2, 3)
fmt.Println(nums1) // 输出：[1, 2, 2, 3, 5, 6]
```

**解析：**
从后向前比较两个数组中的元素，将较大的元素放在 nums1 的末尾，最后将剩余的 nums2 元素填充到 nums1 中。

#### 19. 最小路径和

**题目描述：**
给定一个包含非负整数的 m x n 网格 grid ，找出一条从左上角到右下角的最小路径和。

**示例：**
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]，输出：7。

**答案：**
```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i > 0 && j > 0 {
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])
            } else if i > 0 {
                grid[i][j] += grid[i-1][j]
            } else if j > 0 {
                grid[i][j] += grid[i][j-1]
            }
        }
    }
    return grid[m-1][n-1]
}

// 调用示例
grid := [][]int{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}}
fmt.Println(minPathSum(grid)) // 输出：7
```

**解析：**
动态规划，从左上角开始，每个元素都是其上方和左方元素之和加上自身。

#### 20. 盗贼无法拿到的最大价值

**题目描述：**
你是一个专业的窃贼，计划偷窃沿街的房屋。每间房屋装有报警系统，会自动报警如果相邻的两间房屋在同一晚上被小偷闯入。相邻的房屋内放置了相等价值的财物。给定一个代表每个房屋价值的整数数组，计算你能在不引起警报的情况下偷窃的最大价值。

**示例：**
输入：nums = [2,7,9,3,1]，输出：12。

**答案：**
```go
func rob(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    return max(rob(nums[:len(nums)-1]), rob(nums[1:]))
}

// 调用示例
nums := []int{2, 7, 9, 3, 1}
fmt.Println(rob(nums)) // 输出：12
```

**解析：**
递归，每次只能选择相邻的房屋或者跳过一个房屋。利用分治思想，计算每个子问题的最大价值。

#### 21. 合并区间

**题目描述：**
以数组 intervals 表示若干个区间的合并，其中 intervals[i] = [starti, endi] 。返回一个数组，该数组表示重合区间后形成的所有区间的起始端点和终止端点。

**示例：**
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]，输出：[[1,6],[8,10],[15,18]]；输入：intervals = [[1,4],[4,5]]，输出：[[1,5]]。

**答案：**
```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

// 调用示例
fmt.Println(merge([][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}})) // 输出：[[1,6],[8,10],[15,18]]
fmt.Println(merge([][]int{{1, 4}, {4, 5}})) // 输出：[[1,5]]
```

**解析：**
首先对数组进行排序，然后遍历数组，合并重叠的区间。

#### 22. 验证二叉搜索树

**题目描述：**
给定一个二叉树，判断其是否是合法的二叉搜索树。

**示例：**
输入：[2,1,3]，输出：false；输入：[2,1,3,4]，输出：true。

**答案：**
```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isValidBST(root *TreeNode) bool {
    return helper(root, math.MinInt64, math.MaxInt64)
}

func helper(root *TreeNode, min, max int) bool {
    if root == nil {
        return true
    }
    if root.Val <= min || root.Val >= max {
        return false
    }
    return helper(root.Left, min, root.Val) && helper(root.Right, root.Val, max)
}

// 调用示例
root1 := &TreeNode{Val: 2, Left: &TreeNode{Val: 1, Left: nil, Right: nil}, Right: &TreeNode{Val: 3, Left: nil, Right: nil}}
root2 := &TreeNode{Val: 2, Left: &TreeNode{Val: 1, Left: nil, Right: nil}, Right: &TreeNode{Val: 4, Left: nil, Right: nil}}
fmt.Println(isValidBST(root1)) // 输出：false
fmt.Println(isValidBST(root2)) // 输出：true
```

**解析：**
递归遍历二叉树，检查每个节点是否在允许的范围内。

#### 23. 打家劫舍

**题目描述：**
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**示例：**
输入：[1,2,3,1]，输出：4；输入：[2,7,9,3,1]，输出：12。

**答案：**
```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    return max(rob(nums[:len(nums)-1]), rob(nums[1:]))
}

// 调用示例
nums := []int{1, 2, 3, 1}
fmt.Println(rob(nums)) // 输出：4
nums = []int{2, 7, 9, 3, 1}
fmt.Println(rob(nums)) // 输出：12
```

**解析：**
递归，每次只能选择相邻的房屋或者跳过一个房屋。利用分治思想，计算每个子问题的最大价值。

#### 24. 打家劫舍 II

**题目描述：**
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。由于房屋排列呈环状，所以第一个房屋和最后一个房屋是相邻的。

**示例：**
输入：[2,3,2]，输出：3；输入：[1,2,3,1]，输出：4。

**答案：**
```go
func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }
    if n == 2 {
        return max(nums[0], nums[1])
    }
    return max(rob(nums[:n-1]), rob(nums[1:]))
}

// 调用示例
nums := []int{2, 3, 2}
fmt.Println(rob(nums)) // 输出：3
nums = []int{1, 2, 3, 1}
fmt.Println(rob(nums)) // 输出：4
```

**解析：**
对于环形数组，可以将问题分为两段，分别计算最大值，然后取较大者。

#### 25. 排序数组的中位数

**题目描述：**
给定两个大小为 m 和 n 的正序数组 nums1 和 nums2，请从这两个数组中各选择一个数字，计算出它们的 中位数。

**示例：**
输入：nums1 = [1, 3]，nums2 = [2]，输出：2；输入：nums1 = [1, 2]，nums2 = [3, 4]，输出：2.5。

**答案：**
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i < m {
                minOfRight = nums1[i]
            } else {
                minOfRight = nums2[j]
            }
            return float64(maxOfLeft+minOfRight) / 2
        }
    }
    return 0
}

// 调用示例
nums1 := []int{1, 3}
nums2 := []int{2}
fmt.Println(findMedianSortedArrays(nums1, nums2)) // 输出：2
nums1 = []int{1, 2}
nums2 = []int{3, 4}
fmt.Println(findMedianSortedArrays(nums1, nums2)) // 输出：2.5
```

**解析：**
利用二分查找，在两个有序数组中寻找中位数。通过调整 i 和 j 的值，确保最大左边的数小于或等于最小右边的数。

#### 26. 最长公共子序列

**题目描述：**
给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。如果不存在共同的子序列，返回 0。

**示例：**
输入：text1 = "abcde"，text2 = "ace"，输出：3；输入：text1 = "abc"，text2 = "abc"，输出：3。

**答案：**
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

// 调用示例
fmt.Println(longestCommonSubsequence("abcde", "ace")) // 输出：3
fmt.Println(longestCommonSubsequence("abc", "abc")) // 输出：3
```

**解析：**
动态规划，创建一个二维数组 dp，其中 dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列长度。通过比较字符，更新 dp 数组。

#### 27. 三数之和

**题目描述：**
给定一个包含 n 个整数的数组 nums，判断是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**示例：**
输入：nums = [-1, 0, 1, 2, -1, -4]，输出：[[-1, -1, 2], [-1, 0, 1]]。

**答案：**
```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            total := nums[i] + nums[left] + nums[right]
            if total == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if total < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}

// 调用示例
nums := []int{-1, 0, 1, 2, -1, -4}
fmt.Println(threeSum(nums)) // 输出：[[-1, -1, 2], [-1, 0, 1]]
```

**解析：**
首先对数组进行排序，然后利用双指针法，固定第一个数，分别向左右两侧移动，寻找满足条件的两个数。避免重复解。

#### 28. 顺时针遍历矩阵

**题目描述：**
给定一个包含元素的全二维矩阵 matrix（矩阵有奇数个元素），按顺时针螺旋顺序返回矩阵中的所有元素。

**示例：**
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]，输出：[1,2,3,6,9,8,7,4,5]。

**答案：**
```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    ans := []int{}
    r1, r2, c1, c2 := 0, len(matrix), 0, len(matrix[0])
    for len(ans) < len(matrix)*len(matrix[0]) {
        for c2 > c1 {
            ans = append(ans, matrix[r1][c1])
            c1++
        }
        for r2 > r1 {
            ans = append(ans, matrix[r2][c2-1])
            r2--
        }
        if r1 < r2 {
            for c2 > c1 {
                ans = append(ans, matrix[r1][c2-1])
                c2--
            }
        }
        if c1 < c2 {
            for r2 > r1 {
                ans = append(ans, matrix[r2][c1])
                r1++
            }
        }
    }
    return ans
}

// 调用示例
fmt.Println(spiralOrder([][]int{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}})) // 输出：[1,2,3,6,9,8,7,4,5]
```

**解析：**
按照螺旋的顺序，逐步填充答案数组。每次循环处理矩阵的一圈，分别处理上、右、下、左边界。

#### 29. 最大子序和

**题目描述：**
给定一个整数数组 nums ，找到其中最长严格递增子序列的长度。

**示例：**
输入：nums = [-10, -10, 5, 2, 2]，输出：3；输入：nums = [10, 9, 2, 5, 3, 7, 101, 18]，输出：4。

**答案：**
```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

// 调用示例
nums := []int{-10, -10, 5, 2, 2}
fmt.Println(lengthOfLIS(nums)) // 输出：3
nums = []int{10, 9, 2, 5, 3, 7, 101, 18}
fmt.Println(lengthOfLIS(nums)) // 输出：4
```

**解析：**
动态规划，dp[i] 表示以 nums[i] 为结尾的最长递增子序列的长度。遍历数组，更新 dp 数组。

#### 30. 缀点成线

**题目描述：**
在二维坐标系中，有一些点，如何判断是否存在一条直线，使得这些点都位于这条直线的同一侧。

**示例：**
输入：points = [[1, 1], [2, 2], [3, 3]]，输出：true；输入：points = [[1, 1], [3, 2], [5, 3], [4, 4], [7, 5]]，输出：false。

**答案：**
```go
func checkStraightLine(points [][]int) bool {
    xdiff := points[1][0] - points[0][0]
    ydiff := points[1][1] - points[0][1]
    if xdiff == 0 {
        xdiff = 1
    }
    for i := 2; i < len(points); i++ {
        nextxdiff := points[i][0] - points[0][0]
        nextydiff := points[i][1] - points[0][1]
        if nextxdiff*ydffinx == nextydiff*xdiff {
            return false
        }
    }
    return true
}

// 调用示例
points := [][]int{{1, 1}, {2, 2}, {3, 3}}
fmt.Println(checkStraightLine(points)) // 输出：true
points = [][]int{{1, 1}, {3, 2}, {5, 3}, {4, 4}, {7, 5}}
fmt.Println(checkStraightLine(points)) // 输出：false
```

**解析：**
计算两点之间的斜率，然后遍历其他点，检查它们是否具有相同的斜率。如果存在斜率不一致的点，则返回 false。

### 总结

字节跳动校招编程面试题涉及了多种题型，包括数据结构与算法、数学、逻辑思维等。通过以上示例，我们了解了如何解决这些常见的问题。掌握这些题型的解题方法，有助于在字节跳动的面试中取得好成绩。祝大家面试顺利！

