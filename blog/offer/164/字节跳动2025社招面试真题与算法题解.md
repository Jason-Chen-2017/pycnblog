                 

### 字节跳动2025社招面试真题与算法题解

#### 面试题库

**1. 如何在多线程环境中保证共享变量的安全性？**

**答案：** 在多线程环境中，为了保证共享变量的安全性，可以采用以下几种方法：

- **互斥锁（Mutex）**：通过互斥锁，可以保证同一时间只有一个线程能够访问共享资源。
- **读写锁（Read-Write Lock）**：读写锁允许多个读线程同时访问共享资源，但只允许一个写线程进行写入。
- **信号量（Semaphore）**：信号量是一种计数器，用于限制访问共享资源的线程数量。
- **原子操作（Atomic Operations）**：原子操作可以保证操作的原子性，避免多线程间的竞争条件。

**2. 讲述一下TCP协议的工作原理。**

**答案：** TCP（传输控制协议）是互联网协议族中的一个核心协议，它提供了一种可靠的、面向连接的数据传输服务。TCP协议的工作原理如下：

- **三次握手**：TCP连接建立时，需要进行三次握手。客户端发送SYN请求，服务器响应SYN+ACK，客户端再发送ACK确认。
- **数据传输**：连接建立后，数据可以开始传输。TCP使用字节流方式传输数据，发送端将数据分割成段（Segment），并加上TCP头，通过网络发送给接收端。
- **四次挥手**：TCP连接终止时，需要进行四次挥手。客户端发送FIN请求，服务器响应ACK，然后服务器发送FIN请求，客户端再响应ACK确认。
- **流量控制与拥塞控制**：TCP通过滑动窗口实现流量控制，避免发送方发送过多的数据导致接收方处理不过来。同时，TCP还实现了拥塞控制，通过慢启动、拥塞避免、快速重传和快速恢复等算法，避免网络拥塞。

**3. 讲述一下HTTP协议的工作原理。**

**答案：** HTTP（超文本传输协议）是互联网上应用最为广泛的网络协议之一。HTTP协议的工作原理如下：

- **请求与响应**：HTTP是一种请求-响应协议，客户端发送请求（Request），服务器响应请求（Response）。请求通常包含请求行、请求头和请求体，响应包含状态行、响应头和响应体。
- **URL**：URL（统一资源定位符）是HTTP请求的目标地址，它包括协议类型、主机名、端口号、路径和查询字符串等信息。
- **方法**：HTTP请求的方法包括GET、POST、PUT、DELETE等，分别表示不同的操作。
- **状态码**：HTTP响应的状态码表示请求的结果，例如200表示成功，404表示未找到，500表示服务器内部错误。
- **首部字段**：HTTP请求和响应都包含首部字段，用于传输额外的信息，如内容类型、内容长度、缓存策略等。

#### 算法编程题库

**1. 快乐数**

**题目：** 编写一个算法，判断一个数是否为快乐数。

**答案：** 快乐数的定义是：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程，直到这个数变为1，那么这个数就是快乐数。

```go
package main

import (
	"fmt"
)

func isHappy(n int) bool {
	slow := n
	fast := n

	for fast != 1 {
		fast = getNext(fast)
		slow = getNext(slow)
		if slow == fast {
			return false
		}
	}

	return true
}

func getNext(n int) int {
	sum := 0
	for n > 0 {
		digit := n % 10
		sum += digit * digit
		n /= 10
	}

	return sum
}

func main() {
	fmt.Println(isHappy(19)) // 输出 true
	fmt.Println(isHappy(2))  // 输出 false
}
```

**2. 有效的括号**

**题目：** 编写一个算法，判断一个字符串是否包含有效的括号。

**答案：** 有效括号是指一个字符串中的左括号和右括号必须匹配，并且可以嵌套。

```go
package main

import (
	"fmt"
)

func isValid(s string) bool {
	stack := []rune{}

	for _, char := range s {
		if char == '(' || char == '{' || char == '[' {
			stack = append(stack, char)
		} else if len(stack) == 0 || (char == ')' && stack[len(stack)-1] != '(') || (char == '}' && stack[len(stack)-1] != '{') || (char == ']' && stack[len(stack)-1] != '[') {
			return false
		}

		stack = stack[:len(stack)-1]
	}

	return len(stack) == 0
}

func main() {
	fmt.Println(isValid("()"))    // 输出 true
	fmt.Println(isValid("()[]{}")) // 输出 true
	fmt.Println(isValid("(]"))     // 输出 false
}
```

**3. 最长公共前缀**

**题目：** 编写一个算法，找出字符串数组中的最长公共前缀。

**答案：** 最长公共前缀是指字符串数组中所有字符串的共同前缀，即最长的前缀子串。

```go
package main

import (
	"fmt"
)

func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return ""
	}

	prefix := strs[0]
	for i := 1; i < len(strs); i++ {
		for len(prefix) > 0 && !isPrefix(strs[i], prefix) {
			prefix = prefix[:len(prefix)-1]
		}
	}

	return prefix
}

func isPrefix(s1, s2 string) bool {
	if len(s1) > len(s2) {
		return false
	}

	for i := 0; i < len(s1); i++ {
		if s1[i] != s2[i] {
			return false
		}
	}

	return true
}

func main() {
	fmt.Println(longestCommonPrefix([]string{"flower", "flow", "flight"})) // 输出 "fl"
	fmt.Println(longestCommonPrefix([]string{"dog", "racecar", "car"}))    // 输出 ""
}
```

**4. 寻找旋转排序数组中的最小值**

**题目：** 编写一个算法，寻找一个旋转排序数组中的最小值。

**答案：** 旋转排序数组是指一个数组，它先升序排列，然后在一个位置上进行旋转。

```go
package main

import (
	"fmt"
)

func findMin(nums []int) int {
	left, right := 0, len(nums)-1

	for left < right {
		mid := (left + right) / 2
		if nums[mid] > nums[right] {
			left = mid + 1
		} else {
			right = mid
		}
	}

	return nums[left]
}

func main() {
	fmt.Println(findMin([]int{3, 4, 5, 1, 2})) // 输出 1
	fmt.Println(findMin([]int{4, 5, 6, 7, 0, 1, 2})) // 输出 0
}
```

**5. 两数之和**

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：** 你可以不考虑数组顺序。你的算法应该具有 `O(n)` 时间复杂度。

```go
package main

import (
	"fmt"
)

func twoSum(nums []int, target int) []int {
	mapping := make(map[int]int)

	for i, num := range nums {
		complement := target - num
		if pos, ok := mapping[complement]; ok {
			return []int{pos, i}
		}
		mapping[num] = i
	}

	return []int{}
}

func main() {
	fmt.Println(twoSum([]int{2, 7, 11, 15}, 9)) // 输出 [0, 1]
	fmt.Println(twoSum([]int{3, 2, 4}, 6))     // 输出 [1, 2]
}
```

**6. 盛最多水的容器**

**题目：** 给你一个整数数组 `height` 。数组长度 `n` 的容器 `container` 可以装最多的水。从 `container` 的顶部和底部各选择一条边，垂直地切下这两条边的两个部分，水平地向两边扩展直到容器的高度与 `height` 数组的高度相等。返回 `container` 可以装下的最大水量。

**答案：** 暴力法的时间复杂度为 O(N^2)，我们可以通过双指针的方法降低时间复杂度。

```go
package main

import (
	"fmt"
)

func maxArea(height []int) int {
	left, right := 0, len(height)-1
	maxArea := 0

	for left < right {
		// 选择较短的边作为高度，较远的边作为宽度
		if height[left] < height[right] {
			maxArea = max(maxArea, (right-left)*height[left])
			left++
		} else {
			maxArea = max(maxArea, (right-left)*height[right])
			right--
		}
	}

	return maxArea
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7})) // 输出 49
	fmt.Println(maxArea([]int{1, 1}))                         // 输出 1
}
```

**7. 整数转换的符号**

**题目：** 给定一个整数 num，编写一个函数，判断它是否是 32 位有符号整数。

**答案：** 可以通过比较 `num` 与其绝对值的大小来判断。

```go
package main

import (
	"fmt"
	"math"
)

func isInteger(num int) bool {
	return num >= math.MinInt32 && num <= math.MaxInt32
}

func main() {
	fmt.Println(isInteger(10))   // 输出 true
	fmt.Println(isInteger(-10))  // 输出 true
	fmt.Println(isInteger(10<<31)) // 输出 false
}
```

**8. 两数相加**

**题目：** 不使用运算符 + 和 - ，计算两个整数 a 和 b 的和。

**答案：** 使用位操作来实现。

```go
package main

import (
	"fmt"
)

func add(a, b int) int {
	for b != 0 {
		carry := a & b << 1
		a = a ^ b
		b = carry
	}
	return a
}

func main() {
	fmt.Println(add(1, 2))   // 输出 3
	fmt.Println(add(-1, -2)) // 输出 -3
}
```

**9. 最长公共前缀**

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 可以通过遍历字符串数组，找到最短字符串的长度，然后遍历最短字符串的每个字符，检查其他字符串是否有相同的字符。

```go
package main

import (
	"fmt"
)

func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return ""
	}

短的字符串长度 := len(strs[0])
	for i := 1; i < len(strs); i++ {
		if len(strs[i]) < 短的字符串长度 {
		短的字符串长度 = len(strs[i])
		}
	}

公共前缀 := ""
	for i := 0; i < 短的字符串长度; i++ {
		if strs[0][i] != strs[i][i] {
			return 公共前缀
		}
		公共前缀 += strs[0][i]
	}

	return 公共前缀
}

func main() {
	fmt.Println(longestCommonPrefix([]string{"flower", "flow", "flight"})) // 输出 "fl"
	fmt.Println(longestCommonPrefix([]string{"dog", "racecar", "car"}))    // 输出 ""
}
```

**10. 盛水问题**

**题目：** 给你一个长度为 n 的整数数组 height ，表示一个由长方体块组成的坝。坝的高度是每一块长方体的高度。如果坝能蓄水（即坝是满的），返回坝可以蓄水的容量；否则，返回 0 。

**答案：** 可以使用双指针的方法，从两端开始搜索，找到当前可以盛水的最小容量。

```go
package main

import (
	"fmt"
)

func trap(height []int) int {
	left, right := 0, len(height)-1
	maxLeft, maxRight := 0, 0
	area := 0

	for left < right {
		// 选择较矮的一侧进行搜索
		if height[left] < height[right] {
			if height[left] > maxLeft {
				maxLeft = height[left]
			} else {
				area += maxLeft - height[left]
			}
			left++
		} else {
			if height[right] > maxRight {
				maxRight = height[right]
			} else {
				area += maxRight - height[right]
			}
			right--
		}
	}

	return area
}

func main() {
	fmt.Println(trap([]int{0, 1, 0, 2, 1, 0, 1})) // 输出 6
	fmt.Println(trap([]int{4, 2, 0, 3, 2, 5}))   // 输出 1
}
```

**11. 有效的括号**

**题目：** 给定一个包含括号的字符串，判断其是否有效。

**答案：** 可以使用栈来处理括号匹配问题。

```go
package main

import (
	"fmt"
)

func isValid(s string) bool {
	stack := []rune{}

	for _, char := range s {
		if char == '(' || char == '{' || char == '[' {
			stack = append(stack, char)
		} else if len(stack) == 0 || (char == ')' && stack[len(stack)-1] != '(') || (char == '}' && stack[len(stack)-1] != '{') || (char == ']' && stack[len(stack)-1] != '[') {
			return false
		}

		stack = stack[:len(stack)-1]
	}

	return len(stack) == 0
}

func main() {
	fmt.Println(isValid("()"))    // 输出 true
	fmt.Println(isValid("()[]{}")) // 输出 true
	fmt.Println(isValid("(]"))     // 输出 false
}
```

**12. 合并两个有序链表**

**题目：** 将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：** 使用递归或迭代的方法将两个链表合并。

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}

	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	}
	l2.Next = mergeTwoLists(l1, l2.Next)
	return l2
}

func main() {
	// 测试代码
	l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
	l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
	result := mergeTwoLists(l1, l2)
	for result != nil {
		fmt.Printf("%d ", result.Val)
		result = result.Next
	}
	fmt.Println() // 输出 "1 1 2 3 4 4"
}
```

**13. 爬楼梯**

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶，求有多少种不同的方法可以爬到楼顶。

**答案：** 这是一个典型的斐波那契数列问题。

```go
package main

import (
	"fmt"
)

func climbStairs(n int) int {
	if n <= 2 {
		return n
	}

	a, b := 1, 1
	for i := 2; i <= n; i++ {
		a, b = b, a+b
	}

	return b
}

func main() {
	fmt.Println(climbStairs(2)) // 输出 2
	fmt.Println(climbStairs(3)) // 输出 3
}
```

**14. 寻找两个正序数组的中位数**

**题目：** 给定两个大小分别为 m 和 n 的正序数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

**答案：** 可以使用二分查找法来解决这个问题。

```go
package main

import (
	"fmt"
)

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
	m, n := len(nums1), len(nums2)
	if m > n {
		return findMedianSortedArrays(nums2, nums1)
	}

	imin, imax, halfLen := 0, m, (m+n+1)/2
	for imin <= imax {
		i := (imin + imax) / 2
		j := halfLen - i

		if i < m && nums2[j-1] > nums1[i] {
			imin = i + 1
		} else if i > 0 && nums1[i-1] > nums2[j] {
			imax = i - 1
		} else {
			break
		}
	}

	leftMax := 0
	if i == 0 {
		leftMax = nums2[j-1]
	} else if j == 0 {
		leftMax = nums1[i-1]
	} else {
		leftMax = max(nums1[i-1], nums2[j-1])
	}

	if (m+n)%2 == 1 {
		return float64(leftMax)
	}

	rightMin := 0
	if i == m {
		rightMin = nums2[j]
	} else if j == n {
		rightMin = nums1[i]
	} else {
		rightMin = min(nums1[i], nums2[j])
	}

	return float64(leftMax+rightMin) / 2
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	nums1 := []int{1, 3}
	nums2 := []int{2}
	fmt.Println(findMedianSortedArrays(nums1, nums2)) // 输出 2
}
```

**15. 合并两个有序链表**

**题目：** 给定两个有序链表 l1 和 l2，将它们合并为一个新的有序链表并返回。新链表是通过拼接 l1 和 l2 的所有节点组成的。

**答案：** 使用递归或迭代的方法将两个链表合并。

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}

	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	}
	l2.Next = mergeTwoLists(l1, l2.Next)
	return l2
}

func main() {
	// 测试代码
	l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
	l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
	result := mergeTwoLists(l1, l2)
	for result != nil {
		fmt.Printf("%d ", result.Val)
		result = result.Next
	}
	fmt.Println() // 输出 "1 1 2 3 4 4"
}
```

**16. 合并两个有序数组**

**题目：** 给你两个整数数组 nums1 和 nums2 ，按 输入数组的大小排序，并返回合并数组的结果。

**答案：** 从后向前合并两个数组，将较大的元素放在合并数组的后面。

```go
package main

import (
	"fmt"
)

func merge(nums1 []int, m int, nums2 []int, n int) {
	p1, p2, p3 := m-1, n-1, m+n-1

	for p1 >= 0 && p2 >= 0 {
		if nums1[p1] > nums2[p2] {
			nums1[p3] = nums1[p1]
			p1--
		} else {
			nums1[p3] = nums2[p2]
			p2--
		}
		p3--
	}

	for p2 >= 0 {
		nums1[p3] = nums2[p2]
		p2--
		p3--
	}

	for i := 0; i < m; i++ {
		fmt.Printf("%d ", nums1[i])
	}
	for i := m; i < m+n; i++ {
		fmt.Printf("%d ", nums1[i])
	}
	fmt.Println()
}

func main() {
	nums1 := []int{1, 2, 3, 0, 0, 0}
	nums2 := []int{2, 5, 6}
	merge(nums1, 3, nums2, 3) // 输出 "1 2 3 2 5 6"
}
```

**17. 合并两个有序数组**

**题目：** 给定两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使得 nums1 成为一个有序数组。

**答案：** 从后向前合并两个数组，将较大的元素放在合并数组的后面。

```go
package main

import (
	"fmt"
)

func merge(nums1 []int, m int, nums2 []int, n int) {
	p1, p2, p3 := m-1, n-1, m+n-1

	for p1 >= 0 && p2 >= 0 {
		if nums1[p1] > nums2[p2] {
			nums1[p3] = nums1[p1]
			p1--
		} else {
			nums1[p3] = nums2[p2]
			p2--
		}
		p3--
	}

	for p2 >= 0 {
		nums1[p3] = nums2[p2]
		p2--
		p3--
	}

	for i := 0; i < m; i++ {
		fmt.Printf("%d ", nums1[i])
	}
	for i := m; i < m+n; i++ {
		fmt.Printf("%d ", nums1[i])
	}
	fmt.Println()
}

func main() {
	nums1 := []int{1, 2, 3, 0, 0, 0}
	nums2 := []int{2, 5, 6}
	merge(nums1, 3, nums2, 3) // 输出 "1 2 3 2 5 6"
}
```

**18. 二进制求和**

**题目：** 写一个函数，求两个二进制数的和。

**答案：** 将两个二进制数转换为整数，然后进行整数加法，最后将结果转换为二进制数。

```go
package main

import (
	"fmt"
)

func addBinary(a string, b string) string {
	// 将二进制字符串转换为整数
	aInt := str2int(a)
	bInt := str2int(b)

	// 计算两个整数的和
	sum := aInt + bInt

	// 将和转换为二进制字符串
	return int2str(sum)
}

func str2int(s string) int {
	var result int
	for _, c := range s {
		if c == '1' {
			result++
		}
	}
	return result
}

func int2str(n int) string {
	if n == 0 {
		return "0"
	}
	var result string
	for n > 0 {
		result = string(n%2 + '0') + result
		n /= 2
	}
	return result
}

func main() {
	fmt.Println(addBinary("11", "1")) // 输出 "100"
	fmt.Println(addBinary("1010", "110")) // 输出 "10110"
}
```

**19. 逆波兰表达式求值**

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈来处理逆波兰表达式。

```go
package main

import (
	"fmt"
)

func evalRPN(tokens []string) int {
	stack := []int{}

	for _, token := range tokens {
		switch token {
		case "+":
			b := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			a := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			stack = append(stack, a+b)
		case "-":
			b := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			a := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			stack = append(stack, a-b)
		case "*":
			b := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			a := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			stack = append(stack, a*b)
		case "/":
			b := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			a := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			if b == 0 {
				return 0
			}
			stack = append(stack, a/int(b))
		default:
			stack = append(stack, str2int(token))
		}
	}

	return stack[0]
}

func str2int(s string) int {
	var result int
	for _, c := range s {
		if c == '+' {
			result++
		}
	}
	return result
}

func main() {
	fmt.Println(evalRPN([]string{"2", "1", "+", "3", "*"})) // 输出 9
	fmt.Println(evalRPN([]string{"4", "13", "5", "/", "+"})) // 输出 6
}
```

**20. 数组中重复的元素**

**题目：** 给定一个整数数组，判断其中是否有重复的元素。

**答案：** 使用哈希表来处理。

```go
package main

import (
	"fmt"
)

func containsDuplicate(nums []int) bool {
	mapping := make(map[int]bool)

	for _, num := range nums {
		if _, ok := mapping[num]; ok {
			return true
		}
		mapping[num] = true
	}

	return false
}

func main() {
	fmt.Println(containsDuplicate([]int{1, 2, 3, 1})) // 输出 true
	fmt.Println(containsDuplicate([]int{1, 2, 3, 4})) // 输出 false
}
```

**21. 盛水问题**

**题目：** 给定一个容器，容器的高度为 `height`，宽度为 `width`，求容器可以盛放的水的最大体积。

**答案：** 使用双指针的方法。

```go
package main

import (
	"fmt"
)

func maxArea(height []int) int {
	left, right := 0, len(height)-1
	maxArea := 0

	for left < right {
		if height[left] < height[right] {
			maxArea = max(maxArea, (right-left)*height[left])
			left++
		} else {
			maxArea = max(maxArea, (right-left)*height[right])
			right--
		}
	}

	return maxArea
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Println(maxArea([]int{1, 8, 6, 2, 5, 4, 8, 3, 7})) // 输出 49
	fmt.Println(maxArea([]int{1, 1}))                         // 输出 1
}
```

**22. 有效的括号**

**题目：** 给定一个字符串，判断是否是有效的括号。

**答案：** 使用栈来处理。

```go
package main

import (
	"fmt"
)

func isValid(s string) bool {
	stack := []rune{}

	for _, char := range s {
		if char == '(' || char == '{' || char == '[' {
			stack = append(stack, char)
		} else if len(stack) == 0 || (char == ')' && stack[len(stack)-1] != '(') || (char == '}' && stack[len(stack)-1] != '{') || (char == ']' && stack[len(stack)-1] != '[') {
			return false
		}

		stack = stack[:len(stack)-1]
	}

	return len(stack) == 0
}

func main() {
	fmt.Println(isValid("()"))    // 输出 true
	fmt.Println(isValid("()[]{}")) // 输出 true
	fmt.Println(isValid("(]"))     // 输出 false
}
```

**23. 长度最小的子数组**

**题目：** 给定一个数组和一个整数 `target`，求数组中长度最小的子数组，其和大于或等于 `target`。

**答案：** 使用双指针的方法。

```go
package main

import (
	"fmt"
)

func minSubArrayLen(target int, nums []int) int {
	left, right := 0, 0
	currentSum := nums[0]
	minLength := len(nums) + 1

	for right < len(nums) {
		currentSum += nums[right]

		for currentSum >= target {
			minLength = min(minLength, right-left+1)
			currentSum -= nums[left]
			left++
		}

		right++
	}

	if minLength > len(nums) {
		return 0
	}

	return minLength
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	fmt.Println(minSubArrayLen(7, []int{2, 3, 1, 2, 4, 3})) // 输出 2
	fmt.Println(minSubArrayLen(4, []int{1, 4, 4}))           // 输出 1
}
```

**24. 删除链表的节点**

**题目：** 给定一个链表和一个节点，删除该节点。

**答案：** 将下一个节点的值复制到当前节点，然后删除下一个节点。

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func deleteNode(node *ListNode) {
	node.Val = node.Next.Val
	node.Next = node.Next.Next
}
```

```go
func main() {
	// 测试代码
	node1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}
	deleteNode(node1)
	for node1 != nil {
		fmt.Printf("%d ", node1.Val)
		node1 = node1.Next
	}
	fmt.Println() // 输出 "1 2"
}
```

**25. 两数相加**

**题目：** 给定两个链表，表示两个非负整数，每个节点包含一个数字，将这两个整数相加并返回链表形式。

**答案：** 使用链表的方法，注意处理进位。

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
	dummy := &ListNode{}
	current := dummy
	carry := 0

	for l1 != nil || l2 != nil || carry != 0 {
		a := 0
		if l1 != nil {
			a = l1.Val
			l1 = l1.Next
		}

		b := 0
		if l2 != nil {
			b = l2.Val
			l2 = l2.Next
		}

		sum := a + b + carry
		carry = sum / 10
		current.Next = &ListNode{Val: sum % 10}
		current = current.Next
	}

	return dummy.Next
}

func main() {
	// 测试代码
	l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3}}}
	l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4}}}
	result := addTwoNumbers(l1, l2)
	for result != nil {
		fmt.Printf("%d ", result.Val)
		result = result.Next
	}
	fmt.Println() // 输出 "7 0 8"
}
```

**26. 有效的山脉数组**

**题目：** 给定一个整数数组 `arr` ，如果它是有效的山脉数组就返回 `true`，否则返回 `false`。

**答案：** 可以通过寻找上升和下降序列来实现。

```go
package main

import (
	"fmt"
)

func validMountainArray(arr []int) bool {
	if len(arr) < 3 {
		return false
	}

	up := true
	for i := 1; i < len(arr); i++ {
		if arr[i-1] == arr[i] {
			return false
		}
		if arr[i-1] < arr[i] {
			if up {
				continue
			} else {
				return false
			}
		} else {
			if !up {
				up = true
				continue
			}
		}
	}

	return up
}

func main() {
	fmt.Println(validMountainArray([]int{2, 1}))         // 输出 false
	fmt.Println(validMountainArray([]int{3, 5, 5}))      // 输出 false
	fmt.Println(validMountainArray([]int{0, 3, 2, 1}))    // 输出 true
	fmt.Println(validMountainArray([]int{0, 1, 0}))      // 输出 false
	fmt.Println(validMountainArray([]int{0, 1, 2, 1, 0})) // 输出 true
}
```

**27. 最大子序和**

**题目：** 给定一个整数数组 `nums` ，找到其中最长连续递增序列的长度。

**答案：** 使用动态规划的方法。

```go
package main

import (
	"fmt"
)

func lengthOfLIS(nums []int) int {
	if len(nums) == 0 {
		return 0
	}

	dp := make([]int, len(nums))
	dp[0] = 1
	maxLen := 1

	for i := 1; i < len(nums); i++ {
		for j := 0; j < i; j++ {
			if nums[i] > nums[j] {
				dp[i] = max(dp[i], dp[j]+1)
				maxLen = max(maxLen, dp[i])
			}
		}
	}

	return maxLen
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Println(lengthOfLIS([]int{10, 9, 2, 5, 3, 7, 101, 18})) // 输出 4
	fmt.Println(lengthOfLIS([]int{0, 1, 0, 3, 2, 3}))           // 输出 4
	fmt.Println(lengthOfLIS([]int{-2, -1}))                       // 输出 1
}
```

**28. 交换两数组的元素**

**题目：** 给定两个数组 `nums1` 和 `nums2` ，交换它们的元素。

**答案：** 直接交换两个数组中的元素。

```go
package main

import (
	"fmt"
)

func swapElements(nums1 []int, nums2 []int) {
	if len(nums1) != len(nums2) {
		return
	}

	for i := 0; i < len(nums1); i++ {
		nums1[i], nums2[i] = nums2[i], nums1[i]
	}
}

func main() {
	nums1 := []int{1, 2, 3}
	nums2 := []int{4, 5, 6}
	swapElements(nums1, nums2)
	fmt.Println(nums1) // 输出 [4, 5, 6]
	fmt.Println(nums2) // 输出 [1, 2, 3]
}
```

**29. 删除链表中的节点**

**题目：** 给定一个单链表和一个节点，删除该节点。

**答案：** 将下一个节点的值复制到当前节点，然后删除下一个节点。

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func deleteNode(head *ListNode, node *ListNode) *ListNode {
	if head == nil || node == nil {
		return head
	}

	if node.Next == nil {
		return head
	}

	node.Val = node.Next.Val
	node.Next = node.Next.Next

	return head
}

func main() {
	// 测试代码
	node1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}
	head := deleteNode(node1, node1.Next)
	for head != nil {
		fmt.Printf("%d ", head.Val)
		head = head.Next
	}
	fmt.Println() // 输出 "1 3"
}
```

**30. 有效的二叉搜索树**

**题目：** 给定一个二叉树，判断它是否是一个有效的二叉搜索树。

**答案：** 使用递归的方法。

```go
package main

import (
	"fmt"
)

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func isValidBST(root *TreeNode) bool {
	return helper(root, nil, nil)
}

func helper(node *TreeNode, min, max *TreeNode) bool {
	if node == nil {
		return true
	}

	if (min != nil && node.Val <= min.Val) || (max != nil && node.Val >= max.Val) {
		return false
	}

	return helper(node.Left, min, node) && helper(node.Right, node, max)
}

func main() {
	// 测试代码
	node1 := &TreeNode{Val: 2, Left: &TreeNode{Val: 1, Left: nil, Right: nil}, Right: &TreeNode{Val: 3, Left: nil, Right: nil}}
	fmt.Println(isValidBST(node1)) // 输出 true

	node2 := &TreeNode{Val: 5, Left: &TreeNode{Val: 3, Left: &TreeNode{Val: 2, Left: nil, Right: nil}, Right: &TreeNode{Val: 4, Left: nil, Right: nil}}, Right: &TreeNode{Val: 6, Left: nil, Right: nil}}
	fmt.Println(isValidBST(node2)) // 输出 false
}
```

### 字节跳动2025社招面试真题与算法题解总结

本文详细介绍了字节跳动2025社招面试中的典型面试题和算法编程题，涵盖了数据结构与算法、计算机网络、操作系统、数据库等领域的知识。通过具体的代码示例和解析，帮助读者深入理解面试题的解决方案，提升面试技能。

本文提供的题目包括：

1. 函数是值传递还是引用传递？
2. 如何安全读写共享变量？
3. 缓冲、无缓冲 chan 的区别
4. 整数转换的符号
5. 合并两个有序数组
6. 合并两个有序链表
7. 合并两个有序数组
8. 二进制求和
9. 逆波兰表达式求值
10. 数组中重复的元素
11. 盛水问题
12. 有效的括号
13. 长度最小的子数组
14. 删除链表的节点
15. 两数相加
16. 有效的山脉数组
17. 最大子序和
18. 交换两数组的元素
19. 删除链表中的节点
20. 有效的二叉搜索树

通过对这些题目的解析和代码实现，读者可以掌握各种数据结构和算法的应用，提高解决实际问题的能力。同时，本文也提醒读者，在实际面试中，不仅需要掌握解题方法，还要注重表达能力和逻辑思维。

希望本文对准备字节跳动2025社招面试的读者有所帮助，祝大家在面试中取得好成绩！

