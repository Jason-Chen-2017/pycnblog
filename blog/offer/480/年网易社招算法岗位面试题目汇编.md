                 

# 2025年网易社招算法岗位面试题目汇编

## 算法与数据结构

### 1. 链表翻转

**题目：** 实现一个函数，将单链表翻转。

**答案：**

```python
# Python 代码实现
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**解析：** 通过迭代方式，利用 `prev` 和 `curr` 两个指针，逐个将链表节点翻转。时间复杂度为 O(n)，空间复杂度为 O(1)。

### 2. 二叉树遍历

**题目：** 实现二叉树的先序、中序、后序遍历。

**答案：**

```python
# Python 代码实现
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_traversal(root):
    if root:
        print(root.val, end=' ')
        preorder_traversal(root.left)
        preorder_traversal(root.right)

def inorder_traversal(root):
    if root:
        inorder_traversal(root.left)
        print(root.val, end=' ')
        inorder_traversal(root.right)

def postorder_traversal(root):
    if root:
        postorder_traversal(root.left)
        postorder_traversal(root.right)
        print(root.val, end=' ')
```

**解析：** 通过递归方式实现三种遍历，时间复杂度为 O(n)，空间复杂度为 O(n)。

### 3. 动态规划 - 斐波那契数列

**题目：** 实现一个函数，计算斐波那契数列的第 n 项。

**答案：**

```python
def fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    a, b = 0, 1
    for _ in range(2, n+1):
        a, b = b, a+b
    return b
```

**解析：** 使用动态规划方法，迭代计算斐波那契数列，时间复杂度为 O(n)，空间复杂度为 O(1)。

### 4. 二分查找

**题目：** 实现二分查找算法，在有序数组中查找某个元素。

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 通过二分查找算法，时间复杂度为 O(log n)，空间复杂度为 O(1)。

## 系统设计与算法优化

### 5. 热题缓存系统

**题目：** 设计一个缓存系统，当缓存满时，替换最近最少使用（LRU）的数据。

**答案：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：** 利用 `OrderedDict` 实现最近最少使用（LRU）缓存，时间复杂度为 O(1)。

### 6. 搜索引擎排序

**题目：** 设计一个搜索引擎排序算法，根据关键词热度、用户偏好等因素排序搜索结果。

**答案：**

```python
def search_sort(results, keywords, user_preferences):
    # 根据关键词热度进行排序
    results.sort(key=lambda x: x['热度'], reverse=True)
    # 根据用户偏好进行排序
    for result in results:
        result['偏好分'] = sum(pref in result['标题'] for pref in user_preferences)
    results.sort(key=lambda x: x['偏好分'], reverse=True)
    return results
```

**解析：** 利用排序算法，根据关键词热度、用户偏好等因素进行排序，时间复杂度为 O(n log n)。

## 编码与算法技巧

### 7. 大整数加法

**题目：** 实现一个函数，对两个大整数进行加法运算。

**答案：**

```python
def add_strings(num1, num2):
    max_len = max(len(num1), len(num2))
    num1, num2 = num1.zfill(max_len), num2.zfill(max_len)
    carry = 0
    result = []
    for i in range(max_len - 1, -1, -1):
        sum = int(num1[i]) + int(num2[i]) + carry
        carry = sum // 10
        result.append(str(sum % 10))
    if carry:
        result.append(str(carry))
    return ''.join(result[::-1])
```

**解析：** 使用字符串处理大整数，从低位开始逐位相加，时间复杂度为 O(max_len)。

### 8. 螺旋矩阵

**题目：** 给定一个 m x n 的二维数组，按照螺旋顺序返回数组中的元素。

**答案：**

```python
def spiral_order(matrix):
    if not matrix:
        return []
    m, n = len(matrix), len(matrix[0])
    top, bottom, left, right = 0, m - 1, 0, n - 1
    result = []
    while top <= bottom and left <= right:
        for i in range(left, right + 1):
            result.append(matrix[top][i])
        top += 1
        for i in range(top, bottom + 1):
            result.append(matrix[i][right])
        right -= 1
        if top <= bottom:
            for i in range(right, left - 1, -1):
                result.append(matrix[bottom][i])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top - 1, -1):
                result.append(matrix[i][left])
            left += 1
    return result
```

**解析：** 利用四个边界值不断缩小搜索范围，时间复杂度为 O(mn)。

### 9. 字符串匹配 - KMP 算法

**题目：** 实现字符串匹配算法，利用 KMP 算法减少不必要的比较。

**答案：**

```python
def kmp_search(s, p):
    def build_lps(p):
        lps = [0] * len(p)
        length = 0
        i = 1
        while i < len(p):
            if p[i] == p[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps

    lps = build_lps(p)
    i = j = 0
    while i < len(s):
        if p[j] == s[i]:
            i += 1
            j += 1
        if j == len(p):
            return i - j
        elif i < len(s) and p[j] != s[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    return -1
```

**解析：** 利用前缀表减少不必要的比较，时间复杂度为 O(n+m)，其中 n 为 s 的长度，m 为 p 的长度。

### 10. 红黑树实现

**题目：** 实现红黑树，包括插入、删除、查找等基本操作。

**答案：**

```python
class Node:
    def __init__(self, key, color='red'):
        self.key = key
        self.color = color
        self.parent = None
        self.left = None
        self.right = None

class RedBlackTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        node = Node(key)
        if not self.root:
            self.root = node
            self.root.color = 'black'
            return
        parent = None
        current = self.root
        while current:
            parent = current
            if key < current.key:
                current = current.left
            else:
                current = current.right
        node.parent = parent
        if key < parent.key:
            parent.left = node
        else:
            parent.right = node
        self.fix_insert(node)

    def fix_insert(self, node):
        while node != self.root and node.parent.color == 'red':
            if node.parent == node.parent.parent.left:
                uncle = node.parent.parent.right
                if uncle.color == 'red':
                    node.parent.color = 'black'
                    uncle.color = 'black'
                    node.parent.parent.color = 'red'
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        node = node.parent
                        self.left_rotate(node)
                    node.parent.color = 'black'
                    node.parent.parent.color = 'red'
                    self.right_rotate(node.parent.parent)
            else:
                uncle = node.parent.parent.left
                if uncle.color == 'red':
                    node.parent.color = 'black'
                    uncle.color = 'black'
                    node.parent.parent.color = 'red'
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        node = node.parent
                        self.right_rotate(node)
                    node.parent.color = 'black'
                    node.parent.parent.color = 'red'
                    self.left_rotate(node.parent.parent)
        self.root.color = 'black'

    def left_rotate(self, x):
        y = x.right
        x.right = y.left
        if y.left:
            y.left.parent = x
        y.parent = x.parent
        if not x.parent:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    def right_rotate(self, y):
        x = y.left
        y.left = x.right
        if x.right:
            x.right.parent = y
        x.parent = y.parent
        if not y.parent:
            self.root = x
        elif y == y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x

    def delete(self, key):
        # 删除操作略
        pass

    def find(self, key):
        # 查找操作略
        pass
```

**解析：** 红黑树是一种自平衡的二叉搜索树，通过旋转和颜色变换保持平衡。时间复杂度为 O(log n)。

### 11. 前缀树实现

**题目：** 实现前缀树（Trie），支持单词插入、查找和前缀查找。

**答案：**

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def starts_with(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]
        return True
```

**解析：** 前缀树是一种用于快速查找字符串的前缀和完整字符串的数据结构。时间复杂度为 O(m)，其中 m 为字符串的长度。

### 12. 堆排序

**题目：** 实现堆排序算法。

**答案：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
```

**解析：** 堆排序是一种基于堆的数据结构的排序算法。时间复杂度为 O(n log n)。

### 13. 事件驱动编程

**题目：** 设计一个事件驱动编程的简易框架。

**答案：**

```python
class EventLoop:
    def __init__(self):
        self.queue = []

    def add_listener(self, event_type, callback):
        self.queue.append((event_type, callback))

    def dispatch(self, event_type, data):
        for event_type_, callback in self.queue:
            if event_type_ == event_type:
                callback(data)

# 示例
event_loop = EventLoop()
event_loop.add_listener('click', lambda data: print(f'Clicked on {data}'))
event_loop.dispatch('click', 'button')
```

**解析：** 事件驱动编程是一种通过事件来触发响应的编程范式。时间复杂度为 O(n)，其中 n 为监听器数量。

### 14. 稳态分布算法

**题目：** 实现一个稳态分布算法，如 Fisher-Yates 洗牌算法。

**答案：**

```python
import random

def shuffle(arr):
    for i in range(len(arr) - 1, 0, -1):
        j = random.randint(0, i)
        arr[i], arr[j] = arr[j], arr[i]
    return arr
```

**解析：** Fisher-Yates 洗牌算法是一种高效的洗牌算法，时间复杂度为 O(n)。

### 15. 布隆过滤器

**题目：** 实现布隆过滤器，支持插入、查询和删除。

**答案：**

```python
import mmh3

class BloomFilter:
    def __init__(self, size, hash_func_count):
        self.size = size
        self.hash_func_count = hash_func_count
        self.bit_array = [0] * size

    def add(self, item):
        for i in range(self.hash_func_count):
            hash_value = mmh3.hash(item) % self.size
            self.bit_array[hash_value] = 1

    def contains(self, item):
        for i in range(self.hash_func_count):
            hash_value = mmh3.hash(item) % self.size
            if self.bit_array[hash_value] == 0:
                return False
        return True

    def remove(self, item):
        for i in range(self.hash_func_count):
            hash_value = mmh3.hash(item) % self.size
            self.bit_array[hash_value] = 0
```

**解析：** 布隆过滤器是一种基于位数组的数据结构，用于判断一个元素是否属于集合。时间复杂度为 O(k)，其中 k 为哈希函数数量。

### 16. 排序算法比较

**题目：** 比较冒泡排序、选择排序、插入排序和快速排序的时间复杂度和稳定性。

**答案：**

| 排序算法 | 时间复杂度（最好情况） | 时间复杂度（最坏情况） | 稳定性 |
| :---: | :---: | :---: | :---: |
| 冒泡排序 | O(n) | O(n^2) | 稳定 |
| 选择排序 | O(n^2) | O(n^2) | 不稳定 |
| 插入排序 | O(n) | O(n^2) | 稳定 |
| 快速排序 | O(n log n) | O(n^2) | 不稳定 |

**解析：** 各种排序算法在不同情况下表现出不同的时间和稳定性特性。快速排序在大多数情况下具有较好的性能，但最坏情况下性能较差。

### 17. 大数乘法

**题目：** 实现一个函数，计算两个大整数的乘积。

**答案：**

```python
def multiply(num1, num2):
    sign = -1 if (num1 < 0) ^ (num2 < 0) else 1
    num1, num2 = abs(num1), abs(num2)
    result = 0
    for digit in str(num1):
        carry = 0
        for j in range(len(str(num2))):
            temp = int(digit) * int(str(num2)[j]) + carry
            result += temp % 10
            carry = temp // 10
        if carry:
            result += carry
    return sign * result
```

**解析：** 通过逐位相乘并累加，计算两个大整数的乘积。时间复杂度为 O(mn)，其中 m 和 n 分别为两个大整数的位数。

### 18. 单调栈

**题目：** 使用单调栈实现一个函数，计算数组中的下一个更大元素。

**答案：**

```python
def next_greater_elements(arr):
    stack = []
    result = [-1] * len(arr)
    for i in range(len(arr) - 1, -1, -1):
        while stack and arr[i] >= stack[-1][0]:
            stack.pop()
        if stack:
            result[i] = stack[-1][0]
        stack.append((arr[i], i))
    return result[::-1]
```

**解析：** 单调栈用于记录数组中的下一个更大元素。时间复杂度为 O(n)，空间复杂度为 O(n)。

### 19. 字符串压缩

**题目：** 实现一个函数，对字符串进行压缩。

**答案：**

```python
def compress_string(s):
    compressed = []
    count = 1
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            compressed.append(s[i-1] + str(count))
            count = 1
    compressed.append(s[-1] + str(count))
    return ''.join(compressed) if len(compressed) < len(s) else s
```

**解析：** 通过遍历字符串，统计相同字符的个数，并将压缩后的结果拼接起来。时间复杂度为 O(n)，空间复杂度为 O(n)。

### 20. 滑动窗口

**题目：** 使用滑动窗口实现一个函数，找出数组中的最大子序列和。

**答案：**

```python
def max_subarray_sum(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i-k]
        max_sum = max(max_sum, window_sum)
    return max_sum
```

**解析：** 滑动窗口用于计算窗口内的最大和。时间复杂度为 O(n)，空间复杂度为 O(1)。

### 21. 动态规划 - 0-1背包问题

**题目：** 使用动态规划求解 0-1 背包问题。

**答案：**

```python
def knapsack(W, wt, val, n):
    dp = [[0] * (W + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(1, W + 1):
            if wt[i-1] <= w:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i-1]] + val[i-1])
            else:
                dp[i][w] = dp[i-1][w]

    return dp[n][W]
```

**解析：** 动态规划用于求解背包问题的最大价值。时间复杂度为 O(nW)，空间复杂度为 O(nW)。

### 22. 快速幂算法

**题目：** 实现快速幂算法，计算 a 的 b 次方。

**答案：**

```python
def quick_power(a, b):
    result = 1
    while b > 0:
        if b % 2 == 1:
            result *= a
        a *= a
        b //= 2
    return result
```

**解析：** 快速幂算法用于高效计算幂运算。时间复杂度为 O(log b)，空间复杂度为 O(1)。

### 23. 合并区间

**题目：** 给定一个区间列表，合并所有重叠的区间。

**答案：**

```python
def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for interval in intervals[1:]:
        last = merged[-1]
        if interval[0] <= last[1]:
            merged[-1] = (last[0], max(last[1], interval[1]))
        else:
            merged.append(interval)

    return merged
```

**解析：** 通过排序和合并区间，将重叠的区间合并。时间复杂度为 O(n log n)，空间复杂度为 O(n)。

### 24. 数据结构设计 - 链表

**题目：** 设计一个链表的数据结构，支持插入、删除和遍历操作。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def append(self, val):
        new_node = ListNode(val)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
        self.size += 1

    def delete(self, val):
        if not self.head:
            return
        if self.head.val == val:
            self.head = self.head.next
            self.size -= 1
            return
        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
                if current.next is None:
                    self.tail = current
                self.size -= 1
                return
            current = current.next

    def traverse(self):
        current = self.head
        while current:
            print(current.val, end=' ')
            current = current.next
        print()
```

**解析：** 链表是一种基于节点和指针的数据结构，支持插入、删除和遍历操作。时间复杂度为 O(n)，空间复杂度为 O(n)。

### 25. 数据结构设计 - 栈和队列

**题目：** 设计一个栈和队列的数据结构，支持基本的操作。

**答案：**

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)
        return None

    def front(self):
        if not self.is_empty():
            return self.items[0]
        return None

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)
```

**解析：** 栈和队列是两种常见的数据结构，分别支持后进先出和先进先出的操作。时间复杂度为 O(1)，空间复杂度为 O(n)。

### 26. 贪心算法 - 活动选择问题

**题目：** 使用贪心算法求解活动选择问题。

**答案：**

```python
def activity_selection(activities):
    activities.sort(key=lambda x: x[1])
    result = [activities[0]]
    for activity in activities[1:]:
        if activity[0] >= result[-1][1]:
            result.append(activity)
    return result
```

**解析：** 通过贪心选择活动，使得活动时间不重叠。时间复杂度为 O(n log n)，空间复杂度为 O(n)。

### 27. 并查集

**题目：** 实现并查集，支持合并和查找操作。

**答案：**

```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.size = [1] * size

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            if self.size[rootX] > self.size[rootY]:
                self.parent[rootY] = rootX
                self.size[rootX] += self.size[rootY]
            else:
                self.parent[rootX] = rootY
                self.size[rootY] += self.size[rootX]
```

**解析：** 并查集用于高效解决连通性问题。时间复杂度为 O(log n)，空间复杂度为 O(n)。

### 28. 线段树

**题目：** 实现线段树，支持区间查询和更新操作。

**答案：**

```python
class SegmentTree:
    def __init__(self, nums):
        self.n = len(nums)
        self.tree = [0] * (2 * self.n)
        self.build_tree(nums)

    def build_tree(self, nums):
        for i in range(self.n, 2*self.n-1, 1):
            self.tree[i] = nums[i-self.n]
        for i in range(self.n-1, 0, -1):
            self.tree[i] = self.tree[i*2] + self.tree[i*2+1]

    def update(self, i, val):
        i += self.n
        self.tree[i] = val
        while i > 1:
            i //= 2
            self.tree[i] = self.tree[i*2] + self.tree[i*2+1]

    def query(self, left, right):
        left += self.n
        right += self.n
        sum = 0
        while left <= right:
            if left % 2 == 1:
                sum += self.tree[left]
                left += 1
            if right % 2 == 0:
                sum += self.tree[right]
                right -= 1
            left //= 2
            right //= 2
        return sum
```

**解析：** 线段树用于高效解决区间查询和更新问题。时间复杂度为 O(log n)，空间复杂度为 O(n)。

### 29. 优先队列

**题目：** 实现一个优先队列，支持插入、删除和获取最小元素操作。

**答案：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def insert(self, item, priority):
        heapq.heappush(self.heap, (priority, item))

    def delete(self):
        if not self.is_empty():
            return heapq.heappop(self.heap)[1]
        return None

    def get_min(self):
        if not self.is_empty():
            return self.heap[0][1]
        return None

    def is_empty(self):
        return len(self.heap) == 0
```

**解析：** 优先队列是一种基于堆的数据结构，用于高效获取最小元素。时间复杂度为 O(log n)，空间复杂度为 O(n)。

### 30. 离线活动选择问题

**题目：** 给定一组活动，每个活动都有一个开始时间和结束时间，求最大活动的数量。

**答案：**

```python
def maximum_activities(activities):
    activities.sort(key=lambda x: x[1])
    count = 1
    last_end_time = activities[0][1]
    for i in range(1, len(activities)):
        if activities[i][0] > last_end_time:
            count += 1
            last_end_time = activities[i][1]
    return count
```

**解析：** 通过贪心选择活动，使得活动时间不重叠。时间复杂度为 O(n log n)，空间复杂度为 O(n)。

