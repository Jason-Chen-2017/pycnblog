                 

### 2025华为社招编程面试题精选与解答

#### 1. 算法问题

**题目：** 实现一个函数，找出无序数组中的第 k 个最大元素。

**答案：** 使用快速选择算法（Quickselect）。

**代码示例：**

```python
def findKthLargest(nums, k):
    def quickselect(left, right, k):
        if left == right:
            return nums[left]
        pivotIndex = partition(left, right)
        if k == pivotIndex:
            return nums[k]
        elif k < pivotIndex:
            return quickselect(left, pivotIndex - 1, k)
        else:
            return quickselect(pivotIndex + 1, right, k)

    def partition(left, right):
        pivot = nums[right]
        i = left
        for j in range(left, right):
            if nums[j] > pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[right] = nums[right], nums[i]
        return i

    return quickselect(0, len(nums) - 1, len(nums) - k)
```

**解析：** 快速选择算法的时间复杂度平均为 O(n)，最坏情况下为 O(n^2)。这个算法类似于快速排序，但只在一侧进行递归。

#### 2. 数据结构

**题目：** 实现一个设计模式中的单例模式。

**答案：** 使用静态变量实现。

**代码示例：**

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
```

**解析：** Python 的单例模式通常使用 `__new__` 方法实现，确保类只被实例化一次。

#### 3. 系统设计

**题目：** 设计一个缓存系统，支持添加和获取数据，并在缓存达到最大容量时淘汰最早的数据。

**答案：** 使用双向链表和哈希表实现。

**代码示例：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key):
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key, value):
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：** 这个设计使用了 Python 的 `OrderedDict` 类来模拟一个双向链表，同时使用哈希表来实现 O(1) 的获取和添加操作。

#### 4. 计算题

**题目：** 计算字符串中两数之和的最小绝对差。

**答案：** 使用排序和二分查找。

**代码示例：**

```python
def minimumAbsDifference(nums1, nums2):
    nums1.sort()
    nums2.sort()
    min_diff = float('inf')
    for num1 in nums1:
        for num2 in nums2:
            diff = abs(num1 - num2)
            min_diff = min(min_diff, diff)
    return min_diff
```

**解析：** 这个算法首先对两个列表进行排序，然后遍历其中一个列表，使用二分查找在另一个列表中找到与当前元素差值最小的元素。

#### 5. 算法与数据结构

**题目：** 实现一个堆排序算法。

**答案：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

    return arr
```

**解析：** 这个堆排序算法首先通过 `heapify` 函数将数组转换为最大堆，然后反复将堆顶元素（最大元素）移到数组末尾，并重新调整堆。

#### 6. 算法与数学

**题目：** 判断一个整数是否是回文数。

**答案：**

```python
def isPalindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reversed_half = 0
    while x > reversed_half:
        reversed_half += x % 10
        x //= 10
    return x == reversed_half or x == reversed_half // 10
```

**解析：** 这个算法首先排除负数和以 0 结尾的数，然后通过反向计算一半的数，最后比较原数和反向数是否相等。

#### 7. 算法与逻辑

**题目：** 设计一个函数，计算链表的中间节点。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def middleNode(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow
```

**解析：** 这个算法使用快慢指针方法，快指针每次前进两步，慢指针每次前进一步，当快指针到达链表末尾时，慢指针正好在中间。

#### 8. 算法与搜索

**题目：** 实现一个广度优先搜索（BFS）算法。

**答案：**

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])

    while queue:
        node = queue.popleft()
        visited.add(node)

        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append(neighbor)

    return visited
```

**解析：** 这个算法使用队列来存储待访问的节点，每次从队列中取出节点，并将其邻居加入队列。

#### 9. 算法与排序

**题目：** 实现一个快速排序算法。

**答案：**

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quicksort(left) + middle + quicksort(right)
```

**解析：** 这个算法选择一个中间值作为基准，将数组分为小于、等于和大于基准值的三部分，然后递归地对小于和大于基准值的部分进行排序。

#### 10. 算法与图

**题目：** 设计一个函数，判断两个图是否是同构的。

**答案：**

```python
def isIsomorphic(graph1, graph2):
    if len(graph1) != len(graph2):
        return False

    for node1, neighbors1 in graph1.items():
        node2 = neighbors1[0]
        neighbors2 = graph2[node2]
        
        if len(neighbors1) != len(neighbors2):
            return False

        for neighbor1, neighbor2 in zip(neighbors1, neighbors2):
            if neighbor1 not in graph2 or neighbor2 not in graph1:
                return False
            if graph2[neighbor1] != neighbor2 or graph1[neighbor2] != neighbor1:
                return False

    return True
```

**解析：** 这个算法通过检查两个图的节点和邻居之间的关系，判断它们是否同构。

#### 11. 算法与动态规划

**题目：** 计算最长公共子序列（LCS）。

**答案：**

```python
def longestCommonSubsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

**解析：** 这个算法使用动态规划来计算最长公共子序列，时间复杂度为 O(m*n)。

#### 12. 算法与贪心算法

**题目：** 设计一个函数，找到无序数组中的多数元素。

**答案：**

```python
def majorityElement(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)

    return candidate
```

**解析：** 这个算法使用 Boyer-Moore 投票算法，时间复杂度为 O(n)，在 O(1) 空间内找到多数元素。

#### 13. 算法与位操作

**题目：** 设计一个函数，找出两个数的按位异或的结果。

**答案：**

```python
def bitXor(a, b):
    return a ^ b
```

**解析：** 这个算法直接使用位操作符 `^` 来计算两个数的按位异或。

#### 14. 算法与字符串

**题目：** 设计一个函数，判断字符串是否是回文。

**答案：**

```python
def isPalindrome(s):
    return s == s[::-1]
```

**解析：** 这个算法使用字符串切片来反转字符串，然后比较原字符串和反转后的字符串。

#### 15. 算法与树

**题目：** 设计一个函数，计算二叉树的深度。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def maxDepth(root):
    if not root:
        return 0

    return 1 + max(maxDepth(root.left), maxDepth(root.right))
```

**解析：** 这个算法使用递归来计算二叉树的深度，时间复杂度为 O(n)。

#### 16. 算法与树

**题目：** 设计一个函数，判断二叉树是否是平衡树。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isBalanced(root):
    def checkDepth(node):
        if not node:
            return 0

        leftDepth = checkDepth(node.left)
        rightDepth = checkDepth(node.right)

        if abs(leftDepth - rightDepth) > 1:
            return -1

        return 1 + max(leftDepth, rightDepth)

    return checkDepth(root) != -1
```

**解析：** 这个算法通过计算每个节点的深度来判断二叉树是否平衡，时间复杂度为 O(n)。

#### 17. 算法与图

**题目：** 设计一个函数，判断图中的两个节点是否可达。

**答案：**

```python
from collections import defaultdict

def isReachable(graph, start, end):
    visited = set()

    def dfs(node):
        if node == end:
            return True
        if node in visited:
            return False
        visited.add(node)

        for neighbor in graph[node]:
            if dfs(neighbor):
                return True

        return False

    return dfs(start)
```

**解析：** 这个算法使用深度优先搜索（DFS）来检查图中的两个节点是否可达。

#### 18. 算法与搜索

**题目：** 设计一个函数，实现 A* 搜索算法。

**答案：**

```python
import heapq

def astar(graph, start, end, heuristic):
    frontier = [(heuristic(start, end), start)]
    came_from = {}
    cost_so_far = {}

    frontier = []

    while frontier:
        current = heapq.heappop(frontier)
        if current == end:
            return reconstruct_path(came_from, end)

        for neighbor in graph[current]:
            new_cost = cost_so_far[current] + graph[current][neighbor]
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                priority = new_cost + heuristic(neighbor, end)
                heapq.heappush(frontier, (priority, neighbor))

    return None

def reconstruct_path(came_from, current):
    path = []
    while current in came_from:
        path.append(current)
        current = came_from[current]
    path.reverse()
    return path
```

**解析：** 这个算法结合了 Dijkstra 算法和贪心选择，使用优先级队列来选择下一个节点。

#### 19. 算法与数学

**题目：** 设计一个函数，计算给定数字的阶乘。

**答案：**

```python
def factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result
```

**解析：** 这个算法使用循环来计算阶乘，时间复杂度为 O(n)。

#### 20. 算法与动态规划

**题目：** 设计一个函数，计算斐波那契数列的第 n 项。

**答案：**

```python
def fibonacci(n):
    if n <= 1:
        return n

    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b

    return b
```

**解析：** 这个算法使用动态规划来计算斐波那契数列，时间复杂度为 O(n)。

