                 

### 2024华为社招面试算法题库大全

#### 一、排序算法

**1. 冒泡排序（Bubble Sort）**

**题目：** 实现一个冒泡排序算法，对数组进行升序排列。

**答案：** 

```go
package main

import "fmt"

func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    bubbleSort(arr)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 冒泡排序是一种简单的排序算法，通过重复遍历数组，比较相邻的两个元素，若它们的顺序错误就交换它们，直到整个数组有序。

**2. 快速排序（Quick Sort）**

**题目：** 实现一个快速排序算法，对数组进行升序排列。

**答案：**

```go
package main

import "fmt"

func quickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    n := len(arr)
    quickSort(arr, 0, n-1)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 快速排序是一种高效的排序算法，采用分治策略，将数组划分为两个子数组，然后递归地排序子数组。

**3. 归并排序（Merge Sort）**

**题目：** 实现一个归并排序算法，对数组进行升序排列。

**答案：**

```go
package main

import "fmt"

func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left []int, right []int) []int {
    result := []int{}
    i := 0
    j := 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    sortedArr := mergeSort(arr)
    fmt.Println("Sorted array:", sortedArr)
}
```

**解析：** 归并排序是一种稳定的排序算法，通过将数组分为两个子数组，然后递归地排序子数组，最后将子数组合并为一个有序数组。

#### 二、链表算法

**1. 单链表插入操作**

**题目：** 实现一个单链表的插入操作，在指定位置插入新节点。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func insertNode(head *ListNode, val int, position int) *ListNode {
    newNode := &ListNode{Val: val}
    if position == 0 {
        newNode.Next = head
        return newNode
    }
    current := head
    for i := 0; current != nil && i < position-1; i++ {
        current = current.Next
    }
    if current == nil {
        return head
    }
    newNode.Next = current.Next
    current.Next = newNode
    return head
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}

    head = insertNode(head, 4, 2)
    fmt.Println("Linked List:", head)
}
```

**解析：** 在单链表中插入节点时，需要找到指定位置的前一个节点，然后更新前一个节点的 `Next` 指针。

**2. 单链表删除操作**

**题目：** 实现一个单链表的删除操作，删除指定位置的节点。

**答案：**

```go
package main

import "fmt"

func deleteNode(head *ListNode, position int) *ListNode {
    if position < 0 {
        return head
    }
    if position == 0 {
        return head.Next
    }
    current := head
    for i := 0; current != nil && i < position-1; i++ {
        current = current.Next
    }
    if current == nil || current.Next == nil {
        return head
    }
    current.Next = current.Next.Next
    return head
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}

    head = deleteNode(head, 2)
    fmt.Println("Linked List:", head)
}
```

**解析：** 在单链表中删除节点时，需要找到指定位置的前一个节点，然后更新前一个节点的 `Next` 指针。

**3. 单链表反转**

**题目：** 实现一个单链表的反转操作。

**答案：**

```go
package main

import "fmt"

func reverseLinkedList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    var current *ListNode = head
    var next *ListNode

    for current != nil {
        next = current.Next
        current.Next = prev
        prev = current
        current = next
    }
    return prev
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}

    head = reverseLinkedList(head)
    fmt.Println("Reversed Linked List:", head)
}
```

**解析：** 单链表反转的思路是，遍历链表，将当前节点的 `Next` 指针指向前一个节点，实现反转。

#### 三、树形结构算法

**1. 二叉树的前序遍历**

**题目：** 实现二叉树的前序遍历。

**答案：**

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func preOrderTraversal(root *TreeNode) {
    if root == nil {
        return
    }
    fmt.Println(root.Val)
    preOrderTraversal(root.Left)
    preOrderTraversal(root.Right)
}

func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}

    preOrderTraversal(root)
}
```

**解析：** 前序遍历的顺序是：根节点、左子树、右子树。可以通过递归实现。

**2. 二叉树的中序遍历**

**题目：** 实现二叉树的中序遍历。

**答案：**

```go
package main

import "fmt"

func inOrderTraversal(root *TreeNode) {
    if root == nil {
        return
    }
    inOrderTraversal(root.Left)
    fmt.Println(root.Val)
    inOrderTraversal(root.Right)
}

func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}

    inOrderTraversal(root)
}
```

**解析：** 中序遍历的顺序是：左子树、根节点、右子树。可以通过递归实现。

**3. 二叉树的后序遍历**

**题目：** 实现二叉树的后序遍历。

**答案：**

```go
package main

import "fmt"

func postOrderTraversal(root *TreeNode) {
    if root == nil {
        return
    }
    postOrderTraversal(root.Left)
    postOrderTraversal(root.Right)
    fmt.Println(root.Val)
}

func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}

    postOrderTraversal(root)
}
```

**解析：** 后序遍历的顺序是：左子树、右子树、根节点。可以通过递归实现。

#### 四、动态规划

**1. 最长上升子序列（Longest Increasing Subsequence）**

**题目：** 给定一个无序整数数组，找出最长上升子序列的长度。

**答案：**

```go
package main

import "fmt"

func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = 1
    maxLen := 1
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
                maxLen = max(maxLen, dp[i])
            }
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    fmt.Println("Length of Longest Increasing Subsequence:", lengthOfLIS(nums))
}
```

**解析：** 动态规划的思想是，通过保存子问题的最优解，来解决原问题。在这个例子中，使用一个数组 `dp` 保存以每个位置为结尾的最长上升子序列的长度。

**2. 最长公共子序列（Longest Common Subsequence）**

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```go
package main

import "fmt"

func longestCommonSubsequence(text1, text2 string) string {
    text1Bytes := []byte(text1)
    text2Bytes := []byte(text2)
    m, n := len(text1Bytes), len(text2Bytes)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1Bytes[i-1] == text2Bytes[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    result := make([]byte, dp[m][n])
    k := dp[m][n]
    i, j := m, n
    for k > 0 {
        if text1Bytes[i-1] == text2Bytes[j-1] {
            result[k-1] = text1Bytes[i-1]
            i--
            j--
            k--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    fmt.Println("Longest Common Subsequence:", longestCommonSubsequence(text1, text2))
}
```

**解析：** 长度 `dp[i][j]` 表示文本1的前 `i` 个字符和文本2的前 `j` 个字符的最长公共子序列的长度。通过动态规划求解，然后回溯得到最长公共子序列。

#### 五、图论算法

**1. 拓扑排序（Topological Sort）**

**题目：** 给定一个有向图，实现一个拓扑排序算法。

**答案：**

```go
package main

import (
    "fmt"
    "container/heap"
)

type Edge struct {
    From int
    To   int
}

type Graph struct {
    Edges [][]*Edge
}

func (g *Graph) AddEdge(from int, to int) {
    edge := &Edge{From: from, To: to}
    g.Edges[from] = append(g.Edges[from], edge)
}

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func topologicalSort(g *Graph) []int {
    inDegree := make([]int, len(g.Edges))
    for _, edges := range g.Edges {
        for _, edge := range edges {
            inDegree[edge.To]++
        }
    }
    var heap IntHeap
    for i, degree := range inDegree {
        if degree == 0 {
            heap = append(heap, i)
        }
    }
    heap.Init()
    sorted := []int{}
    for heap.Len() > 0 {
        index := heap.Pop().(int)
        sorted = append(sorted, index)
        for _, edge := range g.Edges[index] {
            inDegree[edge.To]--
            if inDegree[edge.To] == 0 {
                heap.Push(&heap, edge.To)
            }
        }
    }
    return sorted
}

func main() {
    g := &Graph{}
    g.AddEdge(0, 1)
    g.AddEdge(0, 2)
    g.AddEdge(1, 3)
    g.AddEdge(1, 4)
    g.AddEdge(2, 3)
    sorted := topologicalSort(g)
    fmt.Println("Topological Sort:", sorted)
}
```

**解析：** 拓扑排序的思想是，从入度为0的节点开始，依次加入排序结果，并将这些节点的邻接节点的入度减1。如果某个邻接节点的入度为0，则将其加入堆中。

**2. 最短路径算法（Dijkstra算法）**

**题目：** 给定一个加权无向图和两个顶点，求它们之间的最短路径。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

type Edge struct {
    From   int
    To     int
    Weight int
}

type Graph struct {
    Edges map[int][]*Edge
}

func (g *Graph) AddEdge(from int, to int, weight int) {
    edge := &Edge{From: from, To: to, Weight: weight}
    g.Edges[from] = append(g.Edges[from], edge)
    edge = &Edge{From: to, To: from, Weight: weight}
    g.Edges[to] = append(g.Edges[to], edge)
}

func dijkstra(g *Graph, start int) []int {
    distances := make([]int, len(g.Edges))
    distances[start] = 0
    visited := make([]bool, len(g.Edges))
    for i := range visited {
        visited[i] = false
    }
    for !allVisited(visited) {
        minDistance := math.MaxInt32
        minIndex := -1
        for i, v := range visited {
            if !v && distances[i] < minDistance {
                minDistance = distances[i]
                minIndex = i
            }
        }
        visited[minIndex] = true
        for _, edge := range g.Edges[minIndex] {
            if !visited[edge.To] && distances[minIndex]+edge.Weight < distances[edge.To] {
                distances[edge.To] = distances[minIndex] + edge.Weight
            }
        }
    }
    return distances
}

func allVisited(visited []bool) bool {
    for _, v := range visited {
        if !v {
            return false
        }
    }
    return true
}

func main() {
    g := &Graph{}
    g.AddEdge(0, 1, 4)
    g.AddEdge(0, 7, 8)
    g.AddEdge(1, 2, 8)
    g.AddEdge(1, 7, 11)
    g.AddEdge(2, 3, 7)
    g.AddEdge(2, 8, 2)
    g.AddEdge(3, 4, 9)
    g.AddEdge(3, 5, 14)
    g.AddEdge(4, 5, 10)
    g.AddEdge(5, 6, 2)
    g.AddEdge(6, 7, 1)
    distances := dijkstra(g, 0)
    fmt.Println("Shortest Path:", distances)
}
```

**解析：** Dijkstra算法是一种单源最短路径算法，通过维护一个最小堆，每次选择未访问过的顶点，更新其邻接顶点的最短路径长度。

#### 六、字符串算法

**1. KMP算法（Knuth-Morris-Pratt）**

**题目：** 实现KMP算法，在字符串中查找一个子字符串。

**答案：**

```go
package main

import (
    "fmt"
)

func buildNext(s string) []int {
    next := make([]int, len(s))
    j := 0
    for i := 1; i < len(s); i++ {
        for j > 0 && s[i] != s[j] {
            j = next[j-1]
        }
        if s[i] == s[j] {
            j++
        }
        next[i] = j
    }
    return next
}

func KMP(s, p string) int {
    next := buildNext(p)
    j := 0
    for i := 0; i < len(s); i++ {
        for j > 0 && s[i] != p[j] {
            j = next[j-1]
        }
        if s[i] == p[j] {
            j++
        }
        if j == len(p) {
            return i - j + 1
        }
    }
    return -1
}

func main() {
    s := "ababcabcab"
    p := "abc"
    result := KMP(s, p)
    if result != -1 {
        fmt.Printf("Substring found at index %d\n", result)
    } else {
        fmt.Println("Substring not found")
    }
}
```

**解析：** KMP算法通过预处理模式串 `p`，构建一个最长公共前后缀数组 `next`，用于避免重复匹配。

**2. 最长公共前缀（Longest Common Prefix）**

**题目：** 给定一个字符串数组，找出它们的最长公共前缀。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("Longest Common Prefix:", result)
}
```

**解析：** 遍历字符串数组，依次比较每个字符串的前缀，找到最长的公共前缀。

#### 七、其他算法

**1. 快速幂算法（Fast Power）**

**题目：** 实现快速幂算法，计算 `a` 的 `n` 次方。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func quickPower(a, n int) int {
    if n == 0 {
        return 1
    }
    if n < 0 {
        return int(math.Pow(float64(a), float64(-n)))
    }
    result := 1
    base := a
    for n > 0 {
        if n%2 == 1 {
            result *= base
        }
        base *= base
        n /= 2
    }
    return result
}

func main() {
    a := 2
    n := 10
    result := quickPower(a, n)
    fmt.Println(a, "^", n, " =", result)
}
```

**解析：** 快速幂算法通过将指数分解为2的幂次，减少乘法次数，提高计算效率。

**2. 堆排序（Heap Sort）**

**题目：** 实现堆排序算法，对数组进行升序排列。

**答案：**

```go
package main

import (
    "fmt"
)

func maxHeapify(arr []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2

    if left < n && arr[left] > arr[largest] {
        largest = left
    }

    if right < n && arr[right] > arr[largest] {
        largest = right
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        maxHeapify(arr, n, largest)
    }
}

func heapSort(arr []int) {
    n := len(arr)

    for i := n/2 - 1; i >= 0; i-- {
        maxHeapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        maxHeapify(arr, i, 0)
    }
}

func main() {
    arr := []int{12, 11, 13, 5, 6, 7}
    heapSort(arr)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 堆排序通过构建最大堆，将堆顶元素（最大值）交换到数组末尾，然后对剩余部分进行堆调整，重复此过程，直到整个数组有序。

