                 

### 华为2025届社招面试高频算法题解析

#### 1. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```plaintext
输入：["flower","flow","flight"]
输出："fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    // 以第一个字符串作为前缀进行比较
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        // 从前缀尾部开始缩短
        for j := len(prefix) - 1; j >= 0; j-- {
            if strs[i][j] != prefix[j] {
                // 如果字符不匹配，截取前缀
                prefix = prefix[:j]
                break
            }
        }
        // 如果前缀为空，直接返回
        if prefix == "" {
            return ""
        }
    }
    return prefix
}
```

**解析：** 该函数首先检查字符串数组是否为空。然后选择第一个字符串作为初始前缀，并依次与后续的字符串进行比较。如果发现不匹配的字符，则截取不匹配部分之前的前缀，继续比较。最终返回最长的公共前缀。

#### 2. 两数相加

**题目：** 不使用 + 或 - 运算符，实现两个整数的加法。

**示例：**

```plaintext
输入：2, 3
输出：5

输入：-2, 3
输出：1
```

**答案：**

```go
func add(a int, b int) int {
    for b != 0 {
        // 计算进位
        carry := a & b
        // 相加并去除进位影响
        a = a ^ b
        // 进位左移一位
        b = carry << 1
    }
    return a
}
```

**解析：** 该函数使用位运算来实现加法。`a ^ b` 表示按位异或，可以计算出不包含进位的和。`a & b` 表示按位与，可以计算进位。将进位左移一位，再与不包含进位的和进行下一次计算，直到没有进位为止。

#### 3. 二维数组和集合交集

**题目：** 给定两个二维数组，找出它们的交集。

**示例：**

```plaintext
输入：[[1,2,3], [2,5,6]]
输出：[2]

输入：[[1,2,3], [3,4,5]]
输出：[3]
```

**答案：**

```go
func intersection(nums1 [][]int, nums2 [][]int) []int {
    var res []int
    m, n := len(nums1), len(nums2)
    // 遍历第一个数组
    for i := 0; i < m; i++ {
        // 遍历第二个数组
        for j := 0; j < n; j++ {
            // 如果元素相等，添加到结果中
            if nums1[i][0] == nums2[j][0] {
                res = append(res, nums1[i][0])
                break
            }
        }
    }
    return res
}
```

**解析：** 该函数使用两层循环遍历两个二维数组，比较每个元素是否相等。如果相等，将元素添加到结果数组中。这种方法的时间复杂度为 O(m*n)，其中 m 和 n 分别是两个二维数组的长度。

#### 4. 删除链表的节点

**题目：** 删除链表中的一个节点，给定节点非头节点且非尾节点。

**示例：**

```plaintext
输入：[1,2,3,4]
输出：[1,2,4]
```

**答案：**

```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**解析：** 该函数直接将当前节点的值替换为其下一个节点的值，然后将当前节点的下一个节点指向下一个下一个节点，从而删除了当前节点。

#### 5. 翻转链表

**题目：** 翻转一个单链表。

**示例：**

```plaintext
输入：1->2->3->4->5
输出：5->4->3->2->1
```

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    for head != nil {
        next := head.Next
        head.Next = prev
        prev = head
        head = next
    }
    return prev
}
```

**解析：** 该函数使用迭代法，从头部开始遍历链表，每次都将当前节点的下一个节点指向前一个节点，直到遍历完整个链表。最后，前一个节点即为翻转后的链表头部。

#### 6. 最小栈

**题目：** 设计一个最小栈，支持 push、pop 和 getMin 操作。

**示例：**

```plaintext
push(1)
pop()
push(2)
push(3)
getMin() -> 2
pop()
getMin() -> 1
```

**答案：**

```go
type MinStack struct {
    arr []int
    min []int
}

func Constructor() MinStack {
    return MinStack{arr: []int{}, min: []int{}}
}

func (this *MinStack) Push(val int) {
    this.arr = append(this.arr, val)
    if len(this.min) == 0 || val <= this.min[len(this.min)-1] {
        this.min = append(this.min, val)
    }
}

func (this *MinStack) Pop() {
    if this.arr[len(this.arr)-1] == this.min[len(this.min)-1] {
        this.min = this.min[:len(this.min)-1]
    }
    this.arr = this.arr[:len(this.arr)-1]
}

func (this *MinStack) Top() int {
    return this.arr[len(this.arr)-1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min)-1]
}
```

**解析：** 该实现使用两个数组，一个存储栈元素，另一个存储当前栈中的最小值。在 push 时，如果元素小于等于当前最小值，则将其添加到最小值数组中。在 pop 时，如果弹出的是当前最小值，则同时弹出最小值数组中的对应元素。

#### 7. 合并区间

**题目：** 合并一系列区间。

**示例：**

```plaintext
输入：[[1,3], [2,6], [8,10], [15,18]]
输出：[[1,6], [8,10], [15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    // 按照区间的开始时间排序
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var res [][]int
    // 合并区间
    for _, interval := range intervals {
        if len(res) == 0 || res[len(res)-1][1] < interval[0] {
            res = append(res, interval)
        } else {
            res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数首先对区间按照开始时间排序，然后依次合并相邻的区间。如果当前区间的开始时间大于前一个区间的结束时间，则将其添加到结果中。否则，将当前区间的结束时间与前一个区间的结束时间取最大值，从而合并两个区间。

#### 8. 拼接最大数组

**题目：** 给定一个整数数组，将数组分成多个子数组，每个子数组中相邻元素的最大差值大于或等于 d，求最大子数组的拼接数量。

**示例：**

```plaintext
输入：[1,2,3,4,5] d=1
输出：3
```

**答案：**

```go
func maxChunksToSorted(arr []int, d int) int {
    cnt := 0
    left := 0
    right := 0
    n := len(arr)
    for i := 1; i < n; i++ {
        right = max(right, arr[i])
        if right-left >= d {
            cnt++
            left = arr[i]
        }
    }
    return cnt
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用双指针遍历数组，右指针用于找到当前区间的最大值，左指针用于找到下一个区间的开始位置。当最大差值大于等于 d 时，将计数器加一，并更新左指针。

#### 9. 寻找旋转排序数组中的最小值

**题目：** 给定一个旋转排序的数组，找出并返回数组中的最小元素。

**示例：**

```plaintext
输入：[3,4,5,1,2]
输出：1

输入：[4,5,6,7,0,1,2]
输出：0
```

**答案：**

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        m := (l + r) / 2
        if nums[m] > nums[r] {
            l = m + 1
        } else {
            r = m
        }
    }
    return nums[l]
}
```

**解析：** 该函数使用二分查找的方法找到旋转点的位置，旋转点之后的部分即为最小值。

#### 10. 最长递增子序列

**题目：** 给定一个无序数组，找出并返回最长递增子序列的长度。

**示例：**

```plaintext
输入：[10,9,2,5,3,7,101,18]
输出：4
```

**答案：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用动态规划求解最长递增子序列。定义一个数组 `dp` 存储以每个位置为结尾的最长递增子序列的长度。遍历数组，对于每个元素，遍历之前的所有元素，如果当前元素大于前一个元素，则更新 `dp` 数组。

#### 11. 二进制求和

**题目：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**

```plaintext
输入：a = "11", b = "1"
输出："100"

输入：a = "1010", b = "1011"
输出："10101"
```

**答案：**

```go
func addBinary(a string, b string) string {
    ans := []byte{}
    pa, pb := len(a)-1, len(b)-1
    carry := 0
    // 从低位开始相加
    for pa >= 0 || pb >= 0 || carry > 0 {
        x, y := 0, 0
        if pa >= 0 {
            x = int(a[pa] - '0')
            pa--
        }
        if pb >= 0 {
            y = int(b[pb] - '0')
            pb--
        }
        sum := x + y + carry
        carry = sum / 2
        ans = append(ans, byte(sum%2+'0'))
    }
    // 反转结果
    for i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {
        ans[i], ans[j] = ans[j], ans[i]
    }
    return string(ans)
}
```

**解析：** 该函数使用两个指针 `pa` 和 `pb` 从低位开始遍历两个二进制字符串，计算每位上的和以及进位。将和的个位数添加到结果中，并将十位数作为下一个循环的进位。最后，反转结果字符串。

#### 12. 剑指 Offer 48. 最长序列

**题目：** 给定一个未排序的整数数组，找出最长序列中元素的总和。

**示例：**

```plaintext
输入：[1,2,3,4,5]
输出：15
```

**答案：**

```go
func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    m := make(map[int]bool)
    for _, num := range nums {
        m[num] = true
    }
    ans := 0
    for num := range m {
        if !m[num-1] {
            curr := num
            sum := 0
            for m[curr] {
                sum += curr
                curr++
            }
            ans = max(ans, sum)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用哈希表 `m` 存储数组中的每个元素。然后遍历哈希表，对于每个元素，如果它是序列的起点（即 `m[num-1]` 不存在），则计算以该元素为起点的最长序列的总和，并更新答案。

#### 13. 二进制中 1 的个数

**题目：** 给定一个整数，返回其二进制表示中 1 的个数。

**示例：**

```plaintext
输入：4
输出：2

输入：5
输出：3
```

**答案：**

```go
func hammingWeight(num uint32) int {
    ans := 0
    for num > 0 {
        ans += int(num & 1)
        num >>= 1
    }
    return ans
}
```

**解析：** 该函数使用位操作逐位判断整数中 1 的个数。通过不断将整数右移，并将最低位与 1 进行按位与操作，如果结果为 1，则累加答案。

#### 14. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该函数使用递归合并两个有序链表。如果第一个链表的头节点值小于第二个链表的头节点值，则将第一个链表的下一个节点与第二个链表合并，否则将第二个链表的下一个节点与第一个链表合并。

#### 15. 最长公共子序列

**题目：** 给定两个字符串，找出最长的公共子序列。

**示例：**

```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"

输入：text1 = "abc", text2 = "abc"
输出："abc"
```

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用动态规划求解最长公共子序列。定义一个二维数组 `dp` 存储以 `text1[i]` 和 `text2[j]` 结尾的最长公共子序列的长度。如果当前字符相等，则将 `dp[i][j]` 设置为 `dp[i-1][j-1] + 1`；否则，设置为 `dp[i-1][j]` 和 `dp[i][j-1]` 中的最大值。

#### 16. 最小路径和

**题目：** 给定一个包含非负整数的二维网格，找出从左上角到右下角的最小路径和。

**示例：**

```plaintext
输入：
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出：7

解释：因为路径 1→3→1→1→1 的总和最小。

输入：
[
  [1,2,3],
  [4,5,6]
]
输出：12
```

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 1; i < m; i++ {
        grid[i][0] += grid[i-1][0]
    }
    for j := 1; j < n; j++ {
        grid[0][j] += grid[0][j-1]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        }
    }
    return grid[m-1][n-1]
}
```

**解析：** 该函数从左上角开始遍历网格，更新每一行的第一个元素和每一列的第一个元素为它们上方和左方元素的最小路径和。然后，从左上角开始遍历网格的其余元素，将每个元素更新为它上方和左方元素的最小路径和加上当前元素值。最终，网格的右下角元素即为最小路径和。

#### 17. 岛屿的最大面积

**题目：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的最大面积。每个岛屿都是四个方向（水平或垂直）相连的 1 形成的一个组。

**示例：**

```plaintext
输入：
11110
10000
10000
11010
00000
输出：6

解释：上图中有 4 个岛屿，其中第三个岛屿的面积是最大的，面积为 6。

输入：
11000
11000
00100
00011
输出：4
```

**答案：**

```go
func maxAreaOfIsland(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    var dfs func(i, j int) int
    dfs = func(i, j int) int {
        if i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 {
            return 0
        }
        grid[i][j] = 0 // 标记已访问
        area := 1
        area += dfs(i+1, j)
        area += dfs(i-1, j)
        area += dfs(i, j+1)
        area += dfs(i, j-1)
        return area
    }
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == 1 {
                ans = max(ans, dfs(i, j))
            }
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用深度优先搜索（DFS）遍历每个岛屿，计算岛屿的面积。在遍历过程中，将已访问的陆地标记为 0，以避免重复计算。最终，返回所有岛屿中面积最大的岛屿。

#### 18. 盛水最多的容器

**题目：** 给定一个二维矩阵，找出其中两个对角线上的点构成的最小矩形面积。

**示例：**

```plaintext
输入：matrix = [[1,0,1,0,0], [0,1,1,1,0], [1,0,1,1,1], [0,0,0,1,0]]
输出：1
```

**答案：**

```go
func minAreaFreeRect(points [][]int) float64 {
    m := len(points)
    var ans float64 = 1e9
    mp := make(map[int]map[int]int)
    for i := 0; i < m; i++ {
        for j := i + 1; j < m; j++ {
            dx := points[i][0] - points[j][0]
            dy := points[i][1] - points[j][1]
            // 计算斜率的相反数
            key := -dx*1000 - dy
            if mx, ok := mp[key]; ok {
                for y := range mx {
                    dist := dx*dx + dy*dy
                    // 计算两个点之间的距离
                    area := float64(dist) * float64(mx[y] - j)
                    ans = min(ans, area)
                }
            }
            // 记录斜率
            if mx, ok := mp[dy*1000+dx]; ok {
                mp[dy*1000+dx][i] = j
            } else {
                mp[dy*1000+dx] = map[int]int{i: j}
            }
        }
    }
    return ans
}

func min(a, b float64) float64 {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 该函数首先计算每对点的斜率，并将其存储在哈希表中。然后，对于每对点，计算它们之间的距离，并计算以这两个点为对角线的矩形的面积。最后，返回所有矩形面积中的最小值。

#### 19. 最小差值 I

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，返回数组中任意两个不同元素之间的最小绝对差值。

**示例：**

```plaintext
输入：nums = [4,2,1,3], k = 1
输出：1

解释：最小绝对差值是 1，它出现在 nums[0] 和 nums[2] 或 nums[1] 和 nums[3] 中。

输入：nums = [1,3,6,10,15], k = 2
输出：1

解释：最小绝对差值是 1，它出现在 nums[0] 和 nums[4] 中。
```

**答案：**

```go
func smallestIntegerDifference(nums []int, k int) int {
    sort.Ints(nums)
    n := len(nums)
    for i := 0; i < n-1; i++ {
        if nums[i+1]-nums[i] > k {
            return nums[i] + k
        }
    }
    return nums[n-1] + k
}
```

**解析：** 该函数首先对数组进行排序，然后遍历数组，检查相邻元素之间的差值是否大于 `k`。如果发现差值大于 `k`，则返回当前元素加上 `k`。否则，返回数组的最后一个元素加上 `k`。

#### 20. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数首先对区间按照开始时间排序，然后遍历区间，合并重叠的区间。如果当前区间的开始时间大于前一个区间的结束时间，则将其添加到结果中。否则，将当前区间的结束时间与前一个区间的结束时间取最大值，从而合并两个区间。

#### 21. 三数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出三个数，使得它们的和与 `target` 最接近。

**示例：**

```plaintext
输入：nums = [-1,2,1,-4], target = 1
输出：[-1,2,1]
解释：和为最接近 1 的三个数是 -1, 2, 1 。
```

**答案：**

```go
func threeSumClosest(nums []int, target int) int {
    sort.Ints(nums)
    ans := nums[0] + nums[1] + nums[2]
    for i := 0; i < len(nums)-2; i++ {
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                return target
            }
            if abs(sum-target) < abs(ans-target) {
                ans = sum
            }
            if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

**解析：** 该函数首先对数组进行排序，然后使用双指针遍历数组。对于每个元素，分别移动左右指针，计算三个元素的和，并根据和与目标值的差值更新答案。如果和等于目标值，则直接返回目标值。如果和小于目标值，则将左指针右移；如果和大于目标值，则将右指针左移。

#### 22. 字符串的排列组合

**题目：** 给定一个字符串，找出它的所有排列组合。

**示例：**

```plaintext
输入："abc"
输出：["abc", "acb", "bac", "bca", "cab", "cba"]

输入："aab"
输出：["aab", "aba", "baa"]
```

**答案：**

```go
func permute(s string) []string {
    var dfs func(int)
    res := []string{}
    dfs = func(start int) {
        if start == len(s) {
            res = append(res, string(s))
            return
        }
        m := make(map[rune]bool)
        for i := start; i < len(s); i++ {
            if !m[s[i]] {
                m[s[i]] = true
                s = swap(s, start, i)
                dfs(start + 1)
                s = swap(s, start, i)
            }
        }
    }
    dfs(0)
    return res
}

func swap(s string, i, j int) string {
    arr := []rune(s)
    arr[i], arr[j] = arr[j], arr[i]
    return string(arr)
}
```

**解析：** 该函数使用深度优先搜索（DFS）加剪枝的方法生成字符串的所有排列组合。对于每个未固定的字符，将其与后续的未访问字符交换，然后递归生成排列组合。剪枝操作避免了重复生成相同的排列。

#### 23. 翻转二叉树

**题目：** 给定一个二叉树，将其反转。

**示例：**

```plaintext
输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**答案：**

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    left, right := invertTree(root.Left), invertTree(root.Right)
    root.Left, root.Right = right, left
    return root
}
```

**解析：** 该函数使用递归反转二叉树。首先递归反转左子树和右子树，然后交换左右子树。最后返回当前节点。

#### 24. 翻转二叉树

**题目：** 给定一个二叉搜索树（BST），将其转换为排序的双向链表。要求节点间不允许使用临时变量。

**示例：**

```plaintext
输入：
    4
   / \
  2   5
 / \ / \
1  3 6  7

输出：
    1 --> 2 --> 3 --> 4 --> 5 --> 6 --> 7
```

**答案：**

```go
func treeToDoublyList(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    var prev *TreeNode
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        if prev != nil {
            prev.Right = node
            node.Left = prev
        }
        prev = node
        dfs(node.Right)
    }
    dfs(root)
    mid := findMid(root)
    mid.Left = nil
    root = mid
    for root.Left != nil {
        root = root.Left
    }
    return root
}

func findMid(node *TreeNode) *TreeNode {
    slow, fast := node, node.Right
    for fast != nil && fast.Right != nil {
        slow = slow.Right
        fast = fast.Right.Right
    }
    return slow
}
```

**解析：** 该函数首先使用 DFS 遍历二叉树，将节点按照中序遍历的顺序连接起来，形成双向链表。然后，找到链表的中间节点，将其作为新的头节点，并断开其左指针。最后，将链表的头节点返回。

#### 25. 股票价格跨度

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 是第 `i` 天的股票价格。如果有一天在接下来的 `k` 天内的股价上涨，则称这一天为一个上升日。返回一个数组，包含每天的上升日。

**示例：**

```plaintext
输入：prices = [3,2,6,5,0,3], k = 2
输出：[2,5]
解释：第 2 天和第 5 天是上升日。

输入：prices = [1,2,3,4], k = 4
输出：[]
解释：没有任何一天是上升日。
```

**答案：**

```go
func getPricesuíshàngrì(prices []int, k int) []int {
    var ans []int
    for i := 0; i < len(prices)-k; i++ {
        if prices[i+1] > prices[i] {
            ans = append(ans, i+1)
        }
    }
    return ans
}
```

**解析：** 该函数遍历数组，对于每个元素，检查它后面的 `k` 个元素是否大于当前元素。如果大于，则将当前元素的下标加一（表示是上升日）添加到结果数组中。

#### 26. 最小化数组差

**题目：** 给定一个整数数组 `nums`，和一个整数 `k`。我们需要将数组中所有元素的值增加至少 `k`，然后尽可能使每个元素相等。返回可以采用的最低次数。

**示例：**

```plaintext
输入：nums = [3,6,0,1], k = 2
输出：3
解释：增加数组中所有元素的最小值需要 3 次操作：
- 增加 0，nums = [5,6,2,3]
- 增加 2，nums = [5,6,4,5]
- 增加 4，nums = [5,6,6,7]
```

**答案：**

```go
func minChanges(nums []int, k int) int {
    sort.Ints(nums)
    ans := 0
    for i := 1; i < len(nums); i++ {
        if nums[i]-nums[i-1] >= k {
            ans += (nums[i]-nums[i-1]-k+1) / k
        }
    }
    return ans
}
```

**解析：** 该函数首先对数组进行排序，然后遍历数组，对于每个元素，如果当前元素与上一元素的差值大于 `k`，则需要增加的次数为 `(nums[i]-nums[i-1]-k+1) / k`。累加这些次数，即为最终答案。

#### 27. 二进制表示中 1 的数量

**题目：** 给定一个整数 `n`，返回其二进制表示形式中 1 的个数。

**示例：**

```plaintext
输入：n = 00000000000000000000000000001011
输出：3
解释：二进制表示中，有三位为 '1'。

输入：n = 11111111111111111111111111111101
输出：31
解释：二进制表示中，有 31 位为 '1'。
```

**答案：**

```go
func hammingWeight(num uint32) int {
    ans := 0
    for num > 0 {
        ans += int(num & 1)
        num >>= 1
    }
    return ans
}
```

**解析：** 该函数使用位操作，逐位检查整数中 1 的数量。通过不断将整数右移，并将最低位与 1 进行按位与操作，如果结果为 1，则累加答案。

#### 28. 跳跃游戏 II

**题目：** 给定一个非负整数数组 `nums`，你可以跳转到任意 `nums[i]` 的索引。构建一个数组，数组中的每个元素是从索引 0 到索引 `nums.length - 1` 的最小跳跃次数。

**示例：**

```plaintext
输入：[2,3,1,1,4]
输出：[2,2,1,1,0]

解释：
跳跃 1 个单位，从 `nums[0]` 到 `nums[1]`。
跳跃 2 个单位，从 `nums[1]` 到 `nums[2]`。
跳跃 1 个单位，从 `nums[2]` 到 `nums[3]`。
跳跃 1 个单位，从 `nums[3]` 到 `nums[4]`。
总共有 5 个步骤，因此返回 [2,2,1,1,0]。

输入：[2,3,0,1,4]
输出：[2,1,0,1,0]

解释：
跳跃 1 个单位，从 `nums[0]` 到 `nums[1]`。
由于 `nums[2]` 是零，你从 `nums[1]` 留在原处。
跳跃 1 个单位，从 `nums[1]` 到 `nums[2]`。
跳跃 1 个单位，从 `nums[2]` 到 `nums[3]`。
跳跃 1 个单位，从 `nums[3]` 到 `nums[4]`。
总共有 5 个步骤，因此返回 [2,1,0,1,0]。

输入：[2,5,0,0]
输出：[0,2,1]

解释：
进入数组的唯一方法是跳跃 2 个单位到 `nums[1]`，因此返回 [0, 2, 1]。
```

**答案：**

```go
func jump(nums []int) []int {
    ans := make([]int, len(nums))
    ans[0] = 0
    maxReach := 0
    farthest := 0
    for i := 1; i < len(nums); i++ {
        if i > maxReach {
            // 无法到达当前元素，返回 -1
            return nil
        }
        maxReach = max(maxReach, i+nums[i])
        farthest = max(farthest, maxReach)
        ans[i] = 1 + ans[farthest]
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用贪心算法，从前往后遍历数组。在遍历过程中，记录当前能到达的最远位置 `maxReach` 和当前遍历到的最远位置 `farthest`。如果当前元素的下标大于 `maxReach`，则返回 `nil`。否则，更新 `maxReach` 和 `farthest`，并计算到达当前元素的最小跳跃次数。最后返回结果数组。

#### 29. 数据流中的中位数

**题目：** 设计一个数据流，可以添加一个整数，并返回当前数据流的中位数。

**示例：**

```plaintext
[["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]]
[[],[1],[2],[],[3],[]]
返回：[null,null,null,1.50000,null,2.00000]
```

**答案：**

```go
type MedianFinder struct {
    left, right *sort.IntSlice
}

func Constructor() MedianFinder {
    return MedianFinder{
        left: sort.IntSlice{},
        right: &sort.IntSlice{
            0,
        },
    }
}

func (this *MedianFinder) addNum(num int) {
    if this.right.Len() == 0 || num <= this.right.Get(0) {
        this.left = append(this.left, num)
        sort.Ints(this.left)
    } else {
        this.right = append(this.right, num)
        sort.Ints(this.right)
    }
    if this.left.Len() > this.right.Len() {
        this.right = append(this.right, this.left[len(this.left)-1])
        this.left = this.left[:len(this.left)-1]
        sort.Ints(this.right)
    }
}

func (this *MedianFinder) findMedian() float64 {
    if this.left.Len() == this.right.Len() {
        return float64(this.left[len(this.left)-1]+this.right[len(this.right)-1]) / 2
    }
    return float64(this.right[len(this.right)-1])
}
```

**解析：** 该结构体使用两个有序切片 `left` 和 `right` 来维护数据的中间值。`left` 存放较小的一半，`right` 存放较大的一半。当新数据小于或等于 `right` 的第一个元素时，将其添加到 `left`；否则，将其添加到 `right`。如果 `left` 的长度大于 `right`，则需要将 `left` 的最后一个元素移动到 `right`，以保证 `right` 的大小。最终，根据 `left` 和 `right` 的长度计算中位数。

#### 30. 最大子序列和

**题目：** 给定一个整数数组 `nums`，找到一个连续子数组，其和最大，返回该子数组的和。

**示例：**

```plaintext
输入：[1,-3,2,1]
输出：3
解释：子数组 [1,2] 的和最大，为 3。

输入：[1,-2,3,10]
输出：12
解释：子数组 [3,10] 的和最大，为 12。
```

**答案：**

```go
func maxSubArray(nums []int) int {
    ans, currSum := nums[0], 0
    for _, num := range nums {
        currSum = max(num, currSum+num)
        ans = max(ans, currSum)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用前缀和的方法求解最大子序列和。定义 `ans` 和 `currSum` 两个变量，分别存储当前子序列和的最大值和当前子序列和。遍历数组，对于每个元素，计算当前子序列和，取当前元素和当前子序列和加上当前元素的最大值，更新 `currSum`。同时，更新 `ans`，保存当前最大子序列和。最后返回 `ans`。

#### 31. 最小覆盖子串

**题目：** 给定一个字符串 S 和一个字符串 T，找到 S 中最短的子串，使得 T 中所有字符都在这个子串中出现。

**示例：**

```plaintext
输入：S = "ADOBECODEBABE", T = "ABC"
输出："BCE"
解释：最短覆盖子串为 "BCE"，因为 "BC
```

**答案：**

```go
func minWindow(s string, t string) string {
    cnt := [128]int{}
    for i := 0; i < len(t); i++ {
        cnt[t[i]]++
    }
    need := len(t)
    left, right := 0, 0
    start, ansLen := 0, len(s)+1
    for right < len(s) {
        c := s[right]
        cnt[c]--
        if cnt[c] >= 0 {
            need--
        }
        for need == 0 {
            if right-left+1 < ansLen {
                start = left
                ansLen = right - left + 1
            }
            d := s[left]
            cnt[d]++
            if cnt[d] > 0 {
                need++
            }
            left++
        }
        right++
    }
    if ansLen == len(s)+1 {
        return ""
    }
    return s[start : start+ansLen]
}
```

**解析：** 该函数使用双指针方法，定义左右指针 `left` 和 `right`，分别表示当前子串的起始和结束位置。使用一个数组 `cnt` 记录字符串 `t` 中每个字符的数量。当 `right` 指针移动时，更新 `cnt` 数组，如果当前子串满足条件，则移动 `left` 指针，继续寻找更短的子串。最后返回最短覆盖子串。

#### 32. 设计哈希映射

**题目：** 不使用任何内建的哈希表库设计一个哈希映射（HashMap）。

**示例：**

```plaintext
["MyHashMap","put","put","get","put","get","remove","get"]
[[],[1,1],[2,2],[1],[],[2],[],[2]]
返回：[null,null,null,1,null,2,false,true]
```

**答案：**

```go
type MyHashMap struct {
    capacity int
    slots     [][]int
}

func Constructor() MyHashMap {
    return MyHashMap{
        capacity: 16,
        slots:     make([][]int, 16),
    }
}

func (this *MyHashMap) put(key int, value int) {
    index := hash(key)
    slot := this.slots[index]
    for _, v := range slot {
        if v[0] == key {
            v[1] = value
            return
        }
    }
    slot = append(slot, []int{key, value})
    this.slots[index] = slot
}

func (this *MyHashMap) get(key int) int {
    index := hash(key)
    slot := this.slots[index]
    for _, v := range slot {
        if v[0] == key {
            return v[1]
        }
    }
    return -1
}

func (this *MyHashMap) remove(key int) {
    index := hash(key)
    slot := this.slots[index]
    for i, v := range slot {
        if v[0] == key {
            slot = append(slot[:i], slot[i+1:]...)
            this.slots[index] = slot
            return
        }
    }
}

func hash(key int) int {
    return key % 16
}
```

**解析：** 该函数使用数组加链表的方式实现哈希映射。定义一个数组 `slots`，用于存储每个槽位中的键值对列表。`put` 方法通过哈希函数将键映射到数组的一个槽位，并在该槽位中插入键值对。`get` 方法根据键查找对应的值。`remove` 方法删除键值对。

#### 33. 剪绳子

**题目：** 给定一个正整数 `n`，将其剪成最多 `k` 次正整数，使得这些正整数的乘积最大。

**示例：**

```plaintext
输入：n = 10, k = 2
输出：36
解释：10 = 3 * 3 * 4，此时乘积最大，为 36。

输入：n = 2, k = 1
输出：2
解释：2 = 2 * 1，此时乘积最大，为 2。
```

**答案：**

```go
func maxmumProductDividedByK(n int, k int) int {
    mod := 1e9 + 7
    ans := 1
    for n > 1 {
        for i := 2; i <= n; i++ {
            if n%i == 0 {
                ans = (ans * int(math.Pow(float64(i), float64(k-1)))) % int64(mod)
                n /= i
                break
            }
        }
    }
    return ans
}
```

**解析：** 该函数使用递归剪绳子算法。首先，从大到小遍历所有可能的因数，直到剪完为止。在每次剪绳子时，将乘积对 `1e9 + 7` 取模，以防止溢出。

#### 34. 检查字符串的有效性

**题目：** 给定字符串 `s`，检查是否可以通过交换相邻字符的方式，使 `s` 变为回文序列。

**示例：**

```plaintext
输入："abca"
输出：true
解释：你可以交换 s[2] 和 s[3]，得到回文串 "aabc"。

输入："abcd"
输出：false
解释：s 无法通过交换字符得到回文序列。
```

**答案：**

```go
func checkPalindromeByReplace(s string) bool {
    cnt := [26]int{}
    odd := 0
    for _, c := range s {
        cnt[c-'a']++
        if cnt[c-'a']%2 == 1 {
            odd++
        }
    }
    return odd <= 1
}
```

**解析：** 该函数使用计数器 `cnt` 统计每个字符的出现次数，并记录奇数次数的字符数量 `odd`。如果 `odd` 大于 1，则无法通过交换字符得到回文序列。

#### 35. 求最大公约数

**题目：** 给定两个整数 a 和 b，找出它们的最大公约数。

**示例：**

```plaintext
输入：a = 12, b = 8
输出：4

输入：a = 4, b = 6
输出：2
```

**答案：**

```go
func gcd(a int, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

**解析：** 该函数使用辗转相除法求最大公约数。不断用较大数除以较小数，并用余数替换较大数，直到余数为 0，此时较大数即为最大公约数。

#### 36. 检查数字是否为整数倍

**题目：** 给定一个整数 `n`，判断它是否为 `2` 的整数次幂。

**示例：**

```plaintext
输入：n = 8
输出：true
解释：8 是 2 的 3 次幂。

输入：n = 7
输出：false
解释：7 不是 2 的整数次幂。
```

**答案：**

```go
func isPowerOfTwo(n int) bool {
    return n > 0 && (n&(n-1)) == 0
}
```

**解析：** 该函数使用位操作判断一个整数是否为 `2` 的整数次幂。如果一个数是 `2` 的幂，则其二进制表示中只有一位为 1，且该位是最高位。通过按位与操作，可以判断一个数是否为 `2` 的整数次幂。

#### 37. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var res [][]int
    for _, interval := range intervals {
        if len(res) == 0 || res[len(res)-1][1] < interval[0] {
            res = append(res, interval)
        } else {
            res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数首先对区间按照开始时间排序，然后遍历区间，合并重叠的区间。如果当前区间的开始时间大于前一个区间的结束时间，则将其添加到结果中。否则，将当前区间的结束时间与前一个区间的结束时间取最大值，从而合并两个区间。

#### 38. 最小路径和

**题目：** 给定一个包含非负整数的二维网格，找出从左上角到右下角的最小路径和。

**示例：**

```plaintext
输入：
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出：7

解释：因为路径 1→3→1→1→1 的总和最小。

输入：
[
  [1,2,3],
  [4,5,6]
]
输出：12
```

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 1; i < m; i++ {
        grid[i][0] += grid[i-1][0]
    }
    for j := 1; j < n; j++ {
        grid[0][j] += grid[0][j-1]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        }
    }
    return grid[m-1][n-1]
}
```

**解析：** 该函数从左上角开始遍历网格，更新每一行的第一个元素和每一列的第一个元素为它们上方和左方元素的最小路径和。然后，从左上角开始遍历网格的其余元素，将每个元素更新为它上方和左方元素的最小路径和加上当前元素值。最终，网格的右下角元素即为最小路径和。

#### 39. 最小公倍数

**题目：** 给定两个整数 `a` 和 `b`，找出它们的最小公倍数。

**示例：**

```plaintext
输入：a = 15, b = 20
输出：60

输入：a = 2, b = 3
输出：6
```

**答案：**

```go
func gcd(a int, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func lcm(a int, b int) int {
    return a / gcd(a, b) * b
}
```

**解析：** 该函数使用辗转相除法求最大公约数，然后根据最小公倍数等于两数乘积除以最大公约数的关系，计算最小公倍数。

#### 40. 判断是否为同一三角形的顶点

**题目：** 给定三个点，判断它们是否构成同一三角形的顶点。

**示例：**

```plaintext
输入：p1 = [1,0], p2 = [2,3], p3 = [3,0]
输出：true

输入：p1 = [1,0], p2 = [-1,-1], p3 = [0,1]
输出：false
```

**答案：**

```go
func isSameTriangle(p1, p2, p3 []int) bool {
    a := dist(p1, p2)
    b := dist(p1, p3)
    c := dist(p2, p3)
    return (a == b+c) || (b == a+c) || (c == a+b)
}

func dist(p1, p2 []int) int {
    return (p1[0]-p2[0])*(p1[0]-p2[0]) + (p1[1]-p2[1])*(p1[1]-p2[1])
}
```

**解析：** 该函数计算三个点之间的距离，并判断它们是否构成直角三角形。如果三个点构成直角三角形，则它们是同一三角形的顶点。

#### 41. 检查二分查找树是否合法

**题目：** 给定一个二叉搜索树，检查它是否合法。

**示例：**

```plaintext
输入：root = [5,3,7,2,4,6,8]
输出：true

输入：root = [5,3,7,2,4,6,10]
输出：false
```

**答案：**

```go
func isValidBST(root *TreeNode) bool {
    var dfs func(*TreeNode, int, int) bool
    dfs = func(root *TreeNode, min, max int) bool {
        if root == nil {
            return true
        }
        if root.Val <= min || root.Val >= max {
            return false
        }
        return dfs(root.Left, min, root.Val) && dfs(root.Right, root.Val, max)
    }
    return dfs(root, -1, 1)
}
```

**解析：** 该函数使用递归检查二叉搜索树是否合法。对于每个节点，检查它的值是否在 [min, max] 范围内，如果不在，则返回 false。递归调用左右子树，确保整棵树符合二叉搜索树的性质。

#### 42. 最小生成树

**题目：** 给定一个无向图，找出其中最小生成树。

**示例：**

```plaintext
输入：edges = [[1,0,1],[1,2,3],[1,4,1],[3,2,3],[3,4,4],[4,5,6]]
输出：[1,4,5]

输入：edges = [[0,1,1],[1,2,2],[2,0,1]]
输出：[0,1,2]
```

**答案：**

```go
func findMinMST(edges [][]int) []int {
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] < edges[j][2]
    })
    ans := []int{}
    uf := NewUnionFind(len(edges))
    for _, edge := range edges {
        if uf.Union(edge[0], edge[1]) {
            ans = append(ans, edge[2])
        }
    }
    return ans
}

type UnionFind struct {
    p     []int
    size  []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        p:     make([]int, n),
        size:  make([]int, n),
    }
    for i := 0; i < n; i++ {
        uf.p[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.p[x] != x {
        uf.p[x] = uf.Find(uf.p[x])
    }
    return uf.p[x]
}

func (uf *UnionFind) Union(a int, b int) bool {
    rootA := uf.Find(a)
    rootB := uf.Find(b)
    if rootA == rootB {
        return false
    }
    if uf.size[rootA] > uf.size[rootB] {
        uf.p[rootB] = rootA
        uf.size[rootA] += uf.size[rootB]
    } else {
        uf.p[rootA] = rootB
        uf.size[rootB] += uf.size[rootA]
    }
    return true
}
```

**解析：** 该函数使用 Kruskal 算法求解最小生成树。首先对边按照权重排序，然后使用并查集（Union-Find）判断边是否能够加入到最小生成树中。如果能够加入，则更新结果数组。

#### 43. 判断是否为二叉搜索树

**题目：** 给定一棵二叉树，判断它是否为二叉搜索树。

**示例：**

```plaintext
输入：root = [2,1,3]
输出：true

输入：root = [5,4,6,3,2,1]
输出：false
```

**答案：**

```go
func isValidBST(root *TreeNode) bool {
    var dfs func(*TreeNode, int, int) bool
    dfs = func(root *TreeNode, min, max int) bool {
        if root == nil {
            return true
        }
        if root.Val <= min || root.Val >= max {
            return false
        }
        return dfs(root.Left, min, root.Val) && dfs(root.Right, root.Val, max)
    }
    return dfs(root, -1, 1)
}
```

**解析：** 该函数使用递归检查二叉搜索树是否合法。对于每个节点，检查它的值是否在 [min, max] 范围内，如果不在，则返回 false。递归调用左右子树，确保整棵树符合二叉搜索树的性质。

#### 44. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表并返回。

**示例：**

```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该函数使用递归合并两个有序链表。如果第一个链表的头节点值小于第二个链表的头节点值，则将第一个链表的下一个节点与第二个链表合并，否则将第二个链表的下一个节点与第一个链表合并。

#### 45. 判断是否存在平衡二叉树

**题目：** 给定一棵二叉树，判断它是否为平衡二叉树。

**示例：**

```plaintext
输入：root = [3,9,20,null,null,15,7]
输出：true

输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**答案：**

```go
func isBalanced(root *TreeNode) bool {
    var dfs func(*TreeNode) int
    dfs = func(root *TreeNode) int {
        if root == nil {
            return 0
        }
        leftHeight := dfs(root.Left)
        if leftHeight == -1 {
            return -1
        }
        rightHeight := dfs(root.Right)
        if rightHeight == -1 {
            return -1
        }
        if abs(leftHeight-rightHeight) > 1 {
            return -1
        }
        return max(leftHeight, rightHeight) + 1
    }
    return dfs(root) != -1
}
```

**解析：** 该函数使用递归检查二叉树是否平衡。对于每个节点，计算其左右子树的高度，并判断它们是否相差不超过 1。如果发现不平衡，返回 -1。否则，返回左右子树高度中的较大值加 1。最后，检查根节点的平衡状态。

#### 46. 找到最接近的三元组

**题目：** 给定一个整数数组 `nums`，找出和为目标值 `target` 的任意三个整数，并返回这三个数的和。不要求这三个数位于数组中的位置顺序。

**示例：**

```plaintext
输入：nums = [-1, 2, 1, -4], target = 1
输出：[-1, 2, 1]
解释：下面三个元组都符合题意，返回其中任意一个。
  [-1, 2, 1]
  [-1, -1, 2]
  [1, -1, -1]

输入：nums = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], target = 0
输出：[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

**答案：**

```go
func threeSumClosest(nums []int, target int) []int {
    sort.Ints(nums)
    ans := nums[0] + nums[1] + nums[2]
    for i := 0; i < len(nums)-2; i++ {
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                return []int{nums[i], nums[left], nums[right]}
            }
            if abs(sum-target) < abs(ans-target) {
                ans = sum
            }
            if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return []int{ans}
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

**解析：** 该函数使用排序后的数组，通过双指针遍历数组。对于每个元素，使用两个指针分别指向其后的第一个和最后一个元素，计算三数之和，并根据和与目标值的差值更新答案。如果和小于目标值，则将左指针右移；如果和大于目标值，则将右指针左移。

#### 47. 最小的绝对差值

**题目：** 给定一个整数数组 `nums`，返回数组中任意两个元素之间的最小绝对差值。

**示例：**

```plaintext
输入：nums = [1,3,1]
输出：2

解释：所有可能的两数差的绝对值为：
|1-1| = 0
|1-3| = 2
|3-1| = 2

输入：nums = [3,2,5,3,2]
输出：0

解释：所有可能的两数差的绝对值为：
|3-3| = 0
|2-2| = 0
|5-3| = 2
|3-3| = 0
|3-2| = 1
|2-2| = 0
对于所有的 `i < j`，都有 `0 <= |nums[i]-nums[j]| <= 2`。
```

**答案：**

```go
func minAbsDifference(nums []int) int {
    sort.Ints(nums)
    ans := math.MaxInt64
    for i := 1; i < len(nums); i++ {
        ans = min(ans, nums[i]-nums[i-1])
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 该函数首先对数组进行排序，然后遍历数组，计算相邻元素之间的差值，并更新最小差值。最后返回最小差值。

#### 48. 有效的数独

**题目：** 判断一个 `9x9` 数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效。

- 数字 `1-9` 在每一行只能出现一次。
- 数字 `1-9` 在每一列只能出现一次。
- 数字 `1-9` 在每个以粗实线分隔的 `3x3` 子网格内只能出现一次。

**注意：**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效。
- 给定数独序列只包含数字 `1-9` 和字符 `.`，表示空格。

**示例：**

```plaintext
输入：board =
  [["5","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
输出：true

输入：board =
  [["8","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：第二行中的 “6” 应该在第三列（在 “8” 下面）而不是第二列。
```

**答案：**

```go
func isValidSudoku(board [][]byte) bool {
    row, col := [9][9]bool{}, [9][9]bool{}
    box := [9][9]bool{}
    for i := 0; i < 9; i++ {
        for j := 0; j < 9; j++ {
            if board[i][j] != '.' {
                idx := board[i][j] - '1'
                if row[i][idx] || col[j][idx] || box[i/3*3+j/3][idx] {
                    return false
                }
                row[i][idx] = col[j][idx] = box[i/3*3+j/3][idx] = true
            }
        }
    }
    return true
}
```

**解析：** 该函数使用三个二维数组 `row`, `col` 和 `box` 分别表示行、列和 3x3 子网格中是否已经填入了某个数字。遍历数组，对于每个非空单元格，检查该数字是否已经在当前行、当前列或当前 3x3 子网格中填入。如果已经填入，则返回 false。否则，更新数组状态并继续遍历。最后，如果遍历结束没有返回 false，则返回 true。

#### 49. 最长递增子序列 II

**题目：** 给定一个整数数组 `nums`，找到长度尽可能长的严格递增子序列的长度。

**示例：**

```plaintext
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长的严格递增子序列是 [2,3,7,101]，因此长度为 4。

输入：nums = [1,2,3,4,5]
输出：5
解释：整个数组均为严格递增序列，因此长度为 5。
```

**答案：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用动态规划求解最长递增子序列的长度。定义一个数组 `dp` 存储以每个位置为结尾的最长递增子序列的长度。遍历数组，对于每个元素，遍历之前的所有元素，如果当前元素大于前一个元素，则更新 `dp` 数组。最后返回 `dp` 数组中的最大值。

#### 50. 翻转整数

**题目：** 给定一个 32 位有符号整数 `num`，将整数中的数字进行反转。

**示例：**

```plaintext
输入：123
输出：321
解释：123 反转后得到 321。

输入：120
输出：21
解释：120 反转后得到 21。

输入：-123
输出：-321
解释：-123 反转后得到 -321。

输入：-120
输出：-21
解释：-120 反转后得到 -21。

输入：0
输出：0
解释：0 反转后仍为 0。
```

**答案：**

```go
func reverse(x int) int {
    if x == 0 {
        return x
    }
    ans := 0
    for x != 0 {
        ans = ans*10 + x%10
        x /= 10
        if ans > 2<<31-1 || ans < -2<<31 {
            return 0
        }
    }
    return ans
}
```

**解析：** 该函数使用循环反转整数。每次循环将当前整数的最低位添加到结果中，并将整数除以 10，去除最低位。同时，检查结果是否超出 32 位整数的范围，如果超出，则返回 0。

### 总结

本篇博客详细解析了华为2025届社招面试中高频出现的20道算法题，包括基础算法题如最长公共前缀、两数相加，到高级算法题如合并两个有序链表、合并区间、最小生成树等。通过给出详尽的答案解析和源代码实例，帮助读者更好地理解和掌握这些算法题的解题思路和方法。在面试准备过程中，读者可以根据自己的实际情况选择合适的题目进行练习，不断提高自己的算法能力和面试技巧。祝大家面试顺利，取得理想的成绩！

