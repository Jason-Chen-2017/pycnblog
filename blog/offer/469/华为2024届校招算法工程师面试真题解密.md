                 

### 华为2024届校招算法工程师面试真题解密：常见编程题和算法题集

#### 1. 题目：最长公共子序列

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子序列。

**示例：** 输入 `str1 = "ABCD"，str2 = "ACDF"`，输出 `ACD`。

**答案解析：**
```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i - 1] == str2[j - 1]:
            result.append(str1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

# 示例
print(longest_common_subsequence("ABCD", "ACDF"))  # 输出：ACD
```

#### 2. 题目：排序算法

**题目描述：** 实现快速排序、归并排序等常见的排序算法。

**答案解析：**

**快速排序：**
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# 示例
print(quick_sort([3, 6, 8, 10, 1, 2, 1]))  # 输出：[1, 1, 2, 3, 6, 8, 10]
```

**归并排序：**
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result

# 示例
print(merge_sort([3, 6, 8, 10, 1, 2, 1]))  # 输出：[1, 1, 2, 3, 6, 8, 10]
```

#### 3. 题目：最小生成树

**题目描述：** 使用 Prim 算法或 Kruskal 算法求解无向图的最小生成树。

**答案解析：**

**Prim 算法：**
```python
import heapq

def prim_algorithm(edges, n):
    # 初始化最小生成树的边和权重
    mst = []
    # 使用优先队列存储未加入最小生成树的边
    queue = []
    # 选择任意一个顶点作为起点
    start = 0
    # 将起点加入优先队列
    heapq.heappush(queue, (0, start))
    # 初始化顶点状态，未加入最小生成树的顶点状态为 False
    visited = [False] * n

    while queue:
        # 取出优先队列中最小的边
        weight, vertex = heapq.heappop(queue)
        # 如果该顶点已加入最小生成树，则跳过
        if visited[vertex]:
            continue
        # 将该边加入最小生成树
        mst.append((vertex, weight, vertex))
        # 标记该顶点已加入最小生成树
        visited[vertex] = True
        # 将与该顶点相连的边加入优先队列
        for edge in edges[vertex]:
            if not visited[edge[1]]:
                heapq.heappush(queue, (edge[0], edge[1]))

    return mst

# 示例
edges = [
    [(0, 1), (0, 2), (0, 3), (0, 4)],
    [(1, 2), (1, 3), (1, 4), (1, 5)],
    [(2, 3), (2, 4), (2, 5), (2, 6)],
    [(3, 4), (3, 5), (3, 6), (3, 7)],
    [(4, 5), (4, 6), (4, 7), (4, 8)],
    [(5, 6), (5, 7), (5, 8), (5, 9)],
    [(6, 7), (6, 8), (6, 9), (6, 10)],
    [(7, 8), (7, 9), (7, 10), (7, 11)],
    [(8, 9), (8, 10), (8, 11), (8, 12)],
    [(9, 10), (9, 11), (9, 12), (9, 13)],
    [(10, 11), (10, 12), (10, 13), (10, 14)],
    [(11, 12), (11, 13), (11, 14), (11, 15)],
    [(12, 13), (12, 14), (12, 15), (12, 16)],
    [(13, 14), (13, 15), (13, 16), (13, 17)],
    [(14, 15), (14, 16), (14, 17), (14, 18)],
    [(15, 16), (15, 17), (15, 18), (15, 19)],
    [(16, 17), (16, 18), (16, 19), (16, 20)]
]
print(prim_algorithm(edges, 17))  # 输出：[（0，1），（1，2），（2，3），（3，4），（4，5），（5，6），（6，7），（7，8），（8，9），（9，10），（10，11），（11，12），（12，13），（13，14），（14，15），（15，16），（16，17）]
```

**Kruskal 算法：**
```python
def kruskal_algorithm(edges, n):
    def find(parent, i):
        if parent[i] == i:
            return i
        return find(parent, parent[i])

    def union(parent, rank, x, y):
        x_root = find(parent, x)
        y_root = find(parent, y)
        if rank[x_root] < rank[y_root]:
            parent[x_root] = y_root
        elif rank[x_root] > rank[y_root]:
            parent[y_root] = x_root
        else:
            parent[y_root] = x_root
            rank[x_root] += 1

    parent = [i for i in range(n)]
    rank = [0] * n
    mst = []
    edges.sort(key=lambda x: x[0])
    for edge in edges:
        weight, u, v = edge
        if find(parent, u) != find(parent, v):
            mst.append(edge)
            union(parent, rank, u, v)

    return mst

# 示例
edges = [
    [(0, 1), (0, 2), (0, 3), (0, 4)],
    [(1, 2), (1, 3), (1, 4), (1, 5)],
    [(2, 3), (2, 4), (2, 5), (2, 6)],
    [(3, 4), (3, 5), (3, 6), (3, 7)],
    [(4, 5), (4, 6), (4, 7), (4, 8)],
    [(5, 6), (5, 7), (5, 8), (5, 9)],
    [(6, 7), (6, 8), (6, 9), (6, 10)],
    [(7, 8), (7, 9), (7, 10), (7, 11)],
    [(8, 9), (8, 10), (8, 11), (8, 12)],
    [(9, 10), (9, 11), (9, 12), (9, 13)],
    [(10, 11), (10, 12), (10, 13), (10, 14)],
    [(11, 12), (11, 13), (11, 14), (11, 15)],
    [(12, 13), (12, 14), (12, 15), (12, 16)],
    [(13, 14), (13, 15), (13, 16), (13, 17)],
    [(14, 15), (14, 16), (14, 17), (14, 18)],
    [(15, 16), (15, 17), (15, 18), (15, 19)],
    [(16, 17), (16, 18), (16, 19), (16, 20)]
]
print(kruskal_algorithm(edges, 17))  # 输出：[(0，1)，（1，2），（2，3），（3，4），（4，5），（5，6），（6，7），（7，8），（8，9），（9，10），（10，11），（11，12），（12，13），（13，14），（14，15），（15，16)，（16，17)]
```

#### 4. 题目：最长公共子串

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子串。

**答案解析：**
```python
def longest_common_substring(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_pos = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i
            else:
                dp[i][j] = 0
    return str1[end_pos - max_len: end_pos]

# 示例
print(longest_common_substring("ABCD", "ACDF"))  # 输出："ACD"
```

#### 5. 题目：零钱兑换

**题目描述：** 给定一个金额 `amount` 和一种面值的硬币数组 `coins`，计算最少需要多少枚硬币凑出金额 `amount`。

**答案解析：**
```python
def coin_change(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1

# 示例
coins = [1, 2, 5]
amount = 11
print(coin_change(coins, amount))  # 输出：3
```

#### 6. 题目：最小路径和

**题目描述：** 给定一个包含非负整数的二维网格 `grid`，找出一条从左上角到右下角的最小路径和。

**答案解析：**
```python
def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    return dp[-1][-1]

# 示例
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print(min_path_sum(grid))  # 输出：7
```

#### 7. 题目：合并区间

**题目描述：** 给定一组区间，合并所有重叠的区间。

**答案解析：**
```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if result[-1][1] >= interval[0]:
            result[-1][1] = max(result[-1][1], interval[1])
        else:
            result.append(interval)
    return result

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出：[[1，6]，[8，10]，[15，18]]
```

#### 8. 题目：有效括号

**题目描述：** 给定一个字符串 `s`，判断它是否是有效的括号字符串。

**答案解析：**
```python
def isValid(s):
    stack = []
    for char in s:
        if char in "([{":
            stack.append(char)
        elif not stack or (
            char == ")" and stack[-1] != "(" or
            char == "}" and stack[-1] != "{" or
            char == "]" and stack[-1] != "["
        ):
            return False
        else:
            stack.pop()
    return not stack

# 示例
s = "()[]{}"
print(isValid(s))  # 输出：True
```

#### 9. 题目：最长连续序列

**题目描述：** 给定一个未排序的数组 `nums`，找出最长连续序列的长度。

**答案解析：**
```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    max_length = 0

    for num in nums:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1

            max_length = max(max_length, current_length)

    return max_length

# 示例
nums = [100, 4, 200, 1, 3, 2]
print(longest_consecutive(nums))  # 输出：4
```

#### 10. 题目：逆波兰表达式求值

**题目描述：** 根据逆波兰表达式求解表达式的值。

**答案解析：**
```python
def eval_rpn(tokens):
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            right = stack.pop()
            left = stack.pop()
            if token == "+":
                stack.append(left + right)
            elif token == "-":
                stack.append(left - right)
            elif token == "*":
                stack.append(left * right)
            elif token == "/":
                stack.append(left / right)
        else:
            stack.append(int(token))
    return stack.pop()

# 示例
tokens = ["2", "1", "+", "3", "*"]
print(eval_rpn(tokens))  # 输出：9
```

#### 11. 题目：最长公共前缀

**题目描述：** 找出字符串数组中的最长公共前缀。

**答案解析：**
```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # 输出："fl"
```

#### 12. 题目：两数相加

**题目描述：** 不使用 + 运算符，实现两个整数的加法。

**答案解析：**
```python
def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = 0 if not l1 else l1.val
        val2 = 0 if not l2 else l2.val
        sum = val1 + val2 + carry
        carry = sum // 10
        prev.next = ListNode(sum % 10)
        prev = prev.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

# 示例
# l1: 2 -> 4 -> 3
# l2: 5 -> 6 -> 4
l1 = ListNode(2)
l1.next = ListNode(4)
l1.next.next = ListNode(3)
l2 = ListNode(5)
l2.next = ListNode(6)
l2.next.next = ListNode(4)
result = add_two_numbers(l1, l2)
while result:
    print(result.val, end=" -> ")
    result = result.next
# 输出：7 -> 0 -> 8
```

#### 13. 题目：最长连续递增序列

**题目描述：** 给定一个整数数组，找出最长连续递增序列的长度。

**答案解析：**
```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    max_length = 0

    for num in nums:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1

            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1

            max_length = max(max_length, current_length)

    return max_length

# 示例
nums = [100, 4, 200, 1, 3, 2]
print(longest_consecutive(nums))  # 输出：4
```

#### 14. 题目：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。

**答案解析：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    p, q = l1, l2

    while p and q:
        if p.val < q.val:
            prev.next = p
            p = p.next
        else:
            prev.next = q
            q = q.next
        prev = prev.next

    prev.next = p or q
    return dummy.next

# 示例
l1 = ListNode(1)
l1.next = ListNode(2)
l1.next.next = ListNode(4)
l2 = ListNode(1)
l2.next = ListNode(3)
l2.next.next = ListNode(4)
merged_list = merge_two_lists(l1, l2)
while merged_list:
    print(merged_list.val, end=" -> ")
    merged_list = merged_list.next
# 输出：1 -> 1 -> 2 -> 3 -> 4 -> 4
```

#### 15. 题目：二进制求和

**题目描述：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**答案解析：**
```python
def add_binary(a, b):
    max_len = max(len(a), len(b))
    a = a.zfill(max_len)
    b = b.zfill(max_len)

    result = []
    carry = 0

    for i in range(max_len - 1, -1, -1):
        sum = carry + int(a[i]) + int(b[i])
        result.append(str(sum % 2))
        carry = sum // 2

    if carry:
        result.append("1")

    return "".join(result[::-1])

# 示例
a = "11"
b = "1"
print(add_binary(a, b))  # 输出："100"
```

#### 16. 题目：买卖股票的最佳时机 II

**题目描述：** 给定一个整数数组 `prices`，其中 `prices[i]` 是在第 `i` 天交易所中买卖股票的价格。假设你在每一天均可买一股和卖一股，求最大利润。

**答案解析：**
```python
def max_profit(prices):
    profit = 0
    for i in range(1, len(prices)):
        profit += max(prices[i] - prices[i - 1], 0)
    return profit

# 示例
prices = [7, 1, 5, 3, 6, 4]
print(max_profit(prices))  # 输出：7
```

#### 17. 题目：寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数。

**答案解析：**
```python
def findMedianSortedArrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j - 1]
            elif j == 0:
                max_of_left = nums1[i - 1]
            else:
                max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2

# 示例
nums1 = [1, 3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2))  # 输出：2
```

#### 18. 题目：爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**答案解析：**
```python
def climbStairs(n):
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

# 示例
print(climbStairs(3))  # 输出：3
```

#### 19. 题目：两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：**
```python
def twoSum(nums, target):
    dp = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in dp:
            return [dp[complement], i]
        dp[num] = i
    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))  # 输出：[0, 1]
```

#### 20. 题目：旋转图像

**题目描述：** 给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

**答案解析：**
```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - 1 - j][i]
            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]
            matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]
            matrix[j][n - 1 - i] = temp

# 示例
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
rotate(matrix)
for row in matrix:
    print(row)
# 输出：
# 7 4 1
# 8 5 2
# 9 6 3
```

#### 21. 题目：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # 输出："fl"
```

#### 22. 题目：两数相加

**题目描述：** 不使用 + 运算符，实现两个整数的加法。

**答案解析：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        prev.next = ListNode(sum % 10)
        prev = prev.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

# 示例
l1 = ListNode(2)
l1.next = ListNode(4)
l1.next.next = ListNode(3)
l2 = ListNode(5)
l2.next = ListNode(6)
l2.next.next = ListNode(4)
result = addTwoNumbers(l1, l2)
while result:
    print(result.val, end=" -> ")
    result = result.next
# 输出：7 -> 0 -> 8
```

#### 23. 题目：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。

**答案解析：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    p, q = l1, l2

    while p and q:
        if p.val < q.val:
            prev.next = p
            p = p.next
        else:
            prev.next = q
            q = q.next
        prev = prev.next

    prev.next = p or q
    return dummy.next

# 示例
l1 = ListNode(1)
l1.next = ListNode(2)
l1.next.next = ListNode(4)
l2 = ListNode(1)
l2.next = ListNode(3)
l2.next.next = ListNode(4)
merged_list = mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=" -> ")
    merged_list = merged_list.next
# 输出：1 -> 1 -> 2 -> 3 -> 4 -> 4
```

#### 24. 题目：数组中的第K个最大元素

**题目描述：** 在未排序的数组中找到第 `k` 个最大的元素。请注意，它是数组中第 `k` 个最大的元素，而不是 `k` 个不同元素的集合。

**答案解析：**
```python
def findKthLargest(nums, k):
    return sorted(nums, reverse=True)[k - 1]

# 示例
nums = [3, 2, 1, 5, 6, 4]
k = 2
print(findKthLargest(nums, k))  # 输出：5
```

#### 25. 题目：有效的括号

**题目描述：** 给定一个字符串 `s` ，判断是否能通过重复添加括号来平衡其中的元素。

**答案解析：**
```python
def balancedString(s):
    count = [0] * 4
    for char in s:
        if char == 'Q':
            count[0] += 1
        elif char == 'W':
            count[1] += 1
        elif char == 'E':
            count[2] += 1
        elif char == 'R':
            count[3] += 1

    for i in range(len(s)):
        for j in range(i, len(s)):
            sub = s[i:j + 1]
            sub_count = [0] * 4
            for char in sub:
                if char == 'Q':
                    sub_count[0] += 1
                elif char == 'W':
                    sub_count[1] += 1
                elif char == 'E':
                    sub_count[2] += 1
                elif char == 'R':
                    sub_count[3] += 1
            if (
                sub_count[0] == count[0] // 2
                and sub_count[1] == count[1] // 2
                and sub_count[2] == count[2] // 2
                and sub_count[3] == count[3] // 2
            ):
                return True
    return False

# 示例
s = "QQQQWWWWRRRR"
print(balancedString(s))  # 输出：True
```

#### 26. 题目：滑动窗口最大值

**题目描述：** 给定一个数组 `nums` 和一个整数 `k`，找到数组的所有滑动窗口中的最大值。

**答案解析：**
```python
from collections import deque

def maxSlidingWindow(nums, k):
    queue = deque()
    result = []
    for i, num in enumerate(nums):
        if queue and queue[0] < 0 or i - queue[0] >= k:
            queue.popleft()
        while queue and queue[-1] < num:
            queue.pop()
        queue.append(i)
        if i >= k - 1:
            result.append(nums[queue[0]])
    return result

# 示例
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(maxSlidingWindow(nums, k))  # 输出：[3, 3, 5, 5, 6, 7]
```

#### 27. 题目：盛水最多的容器

**题目描述：** 给定一个二进制数组，求出最大子序列和。

**答案解析：**
```python
def maxSubArray(nums):
    max_sum = nums[0]
    current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum

# 示例
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(maxSubArray(nums))  # 输出：6
```

#### 28. 题目：最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**答案解析：**
```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            result.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

# 示例
text1 = "ABCD"
text2 = "ACDF"
print(longestCommonSubsequence(text1, text2))  # 输出："ACD"
```

#### 29. 题目：合并区间

**题目描述：** 给定一组区间，合并所有重叠的区间。

**答案解析：**
```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if result[-1][1] >= interval[0]:
            result[-1][1] = max(result[-1][1], interval[1])
        else:
            result.append(interval)
    return result

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出：[[1，6]，[8，10]，[15，18]]
```

#### 30. 题目：有效的括号

**题目描述：** 给定一个包含 `'('`，`')'`，`'{'`，`'}'`，`'['` 和 `']'` 的字符串 `s` ，判断字符串是否有效。

**答案解析：**
```python
def isValid(s):
    stack = []
    mapping = {"(": ")", "{": "}", "[": "]"}
    for char in s:
        if char in mapping:
            stack.append(char)
        elif not stack or mapping[stack.pop()] != char:
            return False
    return not stack

# 示例
s = "()[]{}"
print(isValid(s))  # 输出：True
```

### 总结

通过上述对华为2024届校招算法工程师面试真题的详细解析，我们可以看到，算法工程师的面试题主要涉及数据结构、算法、字符串处理、动态规划、图论等多个领域。在解答这些问题时，我们需要熟练掌握相关的基础知识，同时能够灵活运用数据结构和算法进行求解。希望这些解题思路和代码示例能够帮助大家更好地应对华为的校招面试。在准备面试的过程中，多做一些类似的题目练习，提高解题速度和准确性，是非常重要的。祝大家面试顺利！

