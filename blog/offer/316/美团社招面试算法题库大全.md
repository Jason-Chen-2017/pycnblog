                 

### 2025美团社招面试算法题库大全

#### 1. 如何实现一个LRU缓存算法？

**题目：** 实现一个Least Recently Used（LRU）缓存算法。

**答案：**

```go
type LRUCache struct {
    cache    map[int]* DoublyLinkedListNode
    capacity int
    head     *DoublyLinkedListNode
    tail     *DoublyLinkedListNode
}

type DoublyLinkedListNode struct {
    key   int
    value int
    prev  *DoublyLinkedListNode
    next  *DoublyLinkedListNode
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        cache:    make(map[int]*DoublyLinkedListNode),
        capacity: capacity,
    }
    lru.head = &DoublyLinkedListNode{}
    lru.tail = &DoublyLinkedListNode{}
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
    } else {
        if len(this.cache) == this.capacity {
            oldest := this.tail.prev
            delete(this.cache, oldest.key)
            this.removeNode(oldest)
        }
        newNode := &DoublyLinkedListNode{key: key, value: value}
        this.addNodeToHead(newNode)
        this.cache[key] = newNode
    }
}

func (this *LRUCache) moveToHead(node *DoublyLinkedListNode) {
    this.removeNode(node)
    this.addNodeToHead(node)
}

func (this *LRUCache) addNodeToHead(node *DoublyLinkedListNode) {
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
    node.prev = this.head
}

func (this *LRUCache) removeNode(node *DoublyLinkedListNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}
```

**解析：** LRU 缓存算法利用双向链表和哈希表实现。当访问缓存中的数据时，将其移动到链表头部；当缓存容量达到上限时，删除链表末尾的数据。这样，最近访问的数据会被优先保留，从而实现 LRU 缓存效果。

#### 2. 如何实现一个快排算法？

**题目：** 实现一个快速排序算法。

**答案：**

```go
func quickSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }
    pivot := nums[len(nums)/2]
    left, right := 0, len(nums)-1
    for {
        for nums[left] < pivot {
            left++
        }
        for nums[right] > pivot {
            right--
        }
        if left >= right {
            break
        }
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
    quickSort(nums[:left])
    quickSort(nums[left:])
    return nums
}
```

**解析：** 快速排序算法选择一个基准元素（pivot），将数组分成两部分，一部分元素小于基准元素，另一部分元素大于基准元素。然后递归地对这两部分进行快速排序，最终得到有序数组。选择基准元素的方式会影响算法性能，一种常见的做法是选择中间元素作为基准。

#### 3. 如何实现一个二分查找算法？

**题目：** 实现一个二分查找算法。

**答案：**

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**解析：** 二分查找算法基于有序数组，通过不断缩小查找范围，逐步逼近目标元素。算法的时间复杂度为 O(log n)，非常适合处理大数据量查找问题。

#### 4. 如何实现一个拓扑排序算法？

**题目：** 实现一个拓扑排序算法。

**答案：**

```go
func topologicalSort(edges [][]int) []int {
    indegrees := make([]int, len(edges))
    for _, edge := range edges {
        indegrees[edge[1]]++
    }
    var result []int
    queue := make([]int, 0)
    for i, degree := range indegrees {
        if degree == 0 {
            queue = append(queue, i)
        }
    }
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        result = append(result, node)
        for _, next := range edges[node] {
            indegrees[next]--
            if indegrees[next] == 0 {
                queue = append(queue, next)
            }
        }
    }
    return result
}
```

**解析：** 拓扑排序算法利用邻接表表示有向无环图（DAG），通过计算每个节点的入度，并将入度为 0 的节点加入队列。然后依次从队列中取出节点，将其加入结果数组，并将与其有依赖关系的节点的入度减 1。当队列空时，拓扑排序完成。

#### 5. 如何实现一个堆排序算法？

**题目：** 实现一个堆排序算法。

**答案：**

```go
func heapify(nums []int, n, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2
    if left < n && nums[left] > nums[largest] {
        largest = left
    }
    if right < n && nums[right] > nums[largest] {
        largest = right
    }
    if largest != i {
        nums[i], nums[largest] = nums[largest], nums[i]
        heapify(nums, n, largest)
    }
}

func heapSort(nums []int) {
    n := len(nums)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(nums, n, i)
    }
    for i := n - 1; i > 0; i-- {
        nums[0], nums[i] = nums[i], nums[0]
        heapify(nums, i, 0)
    }
}
```

**解析：** 堆排序算法利用最大堆（Max Heap）实现。首先将数组构造成最大堆，然后依次将堆顶元素（最大值）交换到数组末尾，并调整剩余元素构成的堆。这样，数组最终被排序。

#### 6. 如何实现一个希尔排序算法？

**题目：** 实现一个希尔排序算法。

**答案：**

```go
func shellSort(nums []int) {
    n := len(nums)
    gap := n / 2
    for gap > 0 {
        for i := gap; i < n; i++ {
            temp := nums[i]
            j := i
            for j >= gap && nums[j-gap] > temp {
                nums[j] = nums[j-gap]
                j -= gap
            }
            nums[j] = temp
        }
        gap /= 2
    }
}
```

**解析：** 希尔排序算法是一种基于插入排序的改进排序算法。首先选择一个合适的增量（gap），将数组分成若干个子序列进行插入排序。然后逐步减小增量，直到增量为 1，此时算法退化为普通的插入排序。

#### 7. 如何实现一个冒泡排序算法？

**题目：** 实现一个冒泡排序算法。

**答案：**

```go
func bubbleSort(nums []int) {
    n := len(nums)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if nums[j] > nums[j+1] {
                nums[j], nums[j+1] = nums[j+1], nums[j]
            }
        }
    }
}
```

**解析：** 冒泡排序算法通过反复比较和交换相邻元素，将数组中的元素按照从小到大（或从大到小）的顺序排列。算法的时间复杂度为 O(n^2)，适合处理小规模数据排序问题。

#### 8. 如何实现一个归并排序算法？

**题目：** 实现一个归并排序算法。

**答案：**

```go
func mergeSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }
    mid := len(nums) / 2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

**解析：** 归并排序算法采用分治思想，将数组分为若干个子数组，分别对子数组进行排序，然后合并子数组。算法的时间复杂度为 O(n log n)，适合处理大规模数据排序问题。

#### 9. 如何实现一个计数排序算法？

**题目：** 实现一个计数排序算法。

**答案：**

```go
func countingSort(nums []int) []int {
    min, max := math.MinInt64, math.MaxInt64
    for _, num := range nums {
        if num < min {
            min = num
        }
        if num > max {
            max = num
        }
    }
    count := make([]int, max-min+1)
    for _, num := range nums {
        count[num-min]++
    }
    result := make([]int, 0, len(nums))
    for i, cnt := range count {
        for cnt > 0 {
            result = append(result, i+min)
            cnt--
        }
    }
    return result
}
```

**解析：** 计数排序算法通过统计原数组中每个元素出现的次数，然后将每个元素按照出现的次数依次放入排序后的数组中。算法的时间复杂度为 O(n + k)，其中 k 为数组中最大值和最小值的差。适合处理整数范围较小的问题。

#### 10. 如何实现一个基数排序算法？

**题目：** 实现一个基数排序算法。

**答案：**

```go
func countingSortByDigit(arr []int, exp1 int) {
    n := len(arr)
    output := make([]int, n)
    count := make([]int, 10)

    for i := 0; i < n; i++ {
        index := (arr[i] / exp1)
        count[index%10]++
    }

    for i := 1; i < 10; i++ {
        count[i] += count[i-1]
    }

    i = n - 1
    for i >= 0 {
        index := (arr[i] / exp1)
        output[count[index%10]-1] = arr[i]
        count[index%10]--
        i--
    }

    for i := 0; i < n; i++ {
        arr[i] = output[i]
    }
}

func radixSort(arr []int) {
    max := arr[0]
    n := len(arr)
    for i := 1; i < n; i++ {
        if arr[i] > max {
            max = arr[i]
        }
    }
    exp := 1
    for max/exp > 0 {
        countingSortByDigit(arr, exp)
        exp *= 10
    }
}
```

**解析：** 基数排序算法是一种非比较型整数排序算法，其核心思想是将整数按位数切割成不同的数字，然后按每个位数进行比较排序。算法的时间复杂度为 O(d*(n+k))，其中 d 为位数，k 为基数（通常为 10）。适合处理整数范围较小的问题。

#### 11. 如何实现一个字符串匹配算法？

**题目：** 实现一个字符串匹配算法。

**答案：**

```go
func kmpStrStr(s string, p string) int {
    n, m := len(s), len(p)
    lps := make([]int, m)
    j := -1
    i := 0
    for i < n {
        if p[j] == s[i] {
            i++
            j++
        }
        if j == m {
            return i - j
        }
        if j < 0 || s[i] != p[j] {
            if j >= 0 {
                j = lps[j - 1]
            } else {
                i++
            }
        }
    }
    return -1
}
```

**解析：** KMP（Knuth-Morris-Pratt）算法是一种高效的字符串匹配算法。算法的核心思想是避免重复匹配，通过计算一个部分匹配表（LPS）来优化匹配过程。算法的时间复杂度为 O(n+m)，其中 n 为主串长度，m 为模式串长度。适合处理字符串匹配问题。

#### 12. 如何实现一个排序算法？

**题目：** 实现一个排序算法。

**答案：**

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

**解析：** 冒泡排序算法是一种简单的排序算法，其基本思想是通过重复地交换相邻的未按顺序排列元素，使得未排序元素从小到大或从大到小排列。算法的时间复杂度为 O(n^2)，适合处理小规模数据排序问题。

#### 13. 如何实现一个插入排序算法？

**题目：** 实现一个插入排序算法。

**答案：**

```go
func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j + 1] = arr[j]
            j--
        }
        arr[j + 1] = key
    }
}
```

**解析：** 插入排序算法是一种简单的排序算法，其基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增加1的有序表。算法的时间复杂度为 O(n^2)，适合处理小规模数据排序问题。

#### 14. 如何实现一个选择排序算法？

**题目：** 实现一个选择排序算法。

**答案：**

```go
func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[minIndex], arr[i] = arr[i], arr[minIndex]
    }
}
```

**解析：** 选择排序算法是一种简单的排序算法，其基本思想是在第 i 次迭代中找到未排序部分的最小元素，将其与第 i 个元素交换，从而将未排序部分划分为已排序部分和未排序部分。算法的时间复杂度为 O(n^2)，适合处理小规模数据排序问题。

#### 15. 如何实现一个冒泡排序算法？

**题目：** 实现一个冒泡排序算法。

**答案：**

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

**解析：** 冒泡排序算法是一种简单的排序算法，其基本思想是通过重复地交换相邻的未按顺序排列元素，使得未排序元素从小到大或从大到小排列。算法的时间复杂度为 O(n^2)，适合处理小规模数据排序问题。

#### 16. 如何实现一个快速排序算法？

**题目：** 实现一个快速排序算法。

**答案：**

```go
func quickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi - 1)
        quickSort(arr, pi + 1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

**解析：** 快速排序算法是一种高效的排序算法，其基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。算法的时间复杂度为 O(n log n)，适合处理大规模数据排序问题。

#### 17. 如何实现一个归并排序算法？

**题目：** 实现一个归并排序算法。

**答案：**

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left []int, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

**解析：** 归并排序算法是一种高效的排序算法，其基本思想是将待排序的序列不断划分为子序列，直到每个子序列只有一个元素，然后将子序列两两合并，得到有序序列。算法的时间复杂度为 O(n log n)，适合处理大规模数据排序问题。

#### 18. 如何实现一个计数排序算法？

**题目：** 实现一个计数排序算法。

**答案：**

```go
func countingSort(arr []int) []int {
    maxVal := 0
    for _, v := range arr {
        if v > maxVal {
            maxVal = v
        }
    }
    count := make([]int, maxVal+1)
    for _, v := range arr {
        count[v]++
    }
    output := make([]int, 0, len(arr))
    for i, v := range count {
        for j := 0; j < v; j++ {
            output = append(output, i)
        }
    }
    return output
}
```

**解析：** 计数排序算法是一种非比较型整数排序算法，其基本思想是统计原数组中每个元素出现的次数，然后按照出现的次数将元素放入排序后的数组中。算法的时间复杂度为 O(n+k)，其中 k 为数组中最大值和最小值的差，适合处理整数范围较小的问题。

#### 19. 如何实现一个桶排序算法？

**题目：** 实现一个桶排序算法。

**答案：**

```go
func bucketSort(arr []int) []int {
    min, max := minMax(arr)
    bucketNum := (max-min)/len(arr) + 1
    buckets := make([][]int, bucketNum)
    for i := range buckets {
        buckets[i] = make([]int, 0)
    }
    for _, v := range arr {
        buckets[v-min] = append(buckets[v-min], v)
    }
    output := make([]int, 0, len(arr))
    for _, bucket := range buckets {
        insertionSort(bucket)
        output = append(output, bucket...)
    }
    return output
}

func minMax(arr []int) (int, int) {
    min := arr[0]
    max := arr[0]
    for _, v := range arr {
        if v < min {
            min = v
        }
        if v > max {
            max = v
        }
    }
    return min, max
}

func insertionSort(arr []int) {
    for i := 1; i < len(arr); i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j + 1] = arr[j]
            j--
        }
        arr[j + 1] = key
    }
}
```

**解析：** 桶排序算法是一种基于比较排序和非比较排序的排序算法，其基本思想是将原数组划分为若干个桶，然后将每个桶内的元素进行排序，最后将各个桶的元素合并。算法的时间复杂度为 O(n+k)，其中 k 为桶的数量，适合处理整数范围较小的问题。

#### 20. 如何实现一个基数排序算法？

**题目：** 实现一个基数排序算法。

**答案：**

```go
func countingSortByDigit(arr []int, exp int) {
    n := len(arr)
    output := make([]int, n)
    count := make([]int, 10)

    for i := 0; i < n; i++ {
        index := (arr[i] / exp) % 10
        count[index]++
    }

    for i := 1; i < 10; i++ {
        count[i] += count[i-1]
    }

    for i := n - 1; i >= 0; i-- {
        index := (arr[i] / exp) % 10
        output[count[index]-1] = arr[i]
        count[index]--
    }

    for i := range output {
        arr[i] = output[i]
    }
}

func radixSort(arr []int) {
    max := 0
    for _, v := range arr {
        if v > max {
            max = v
        }
    }
    exp := 1
    for max/exp > 0 {
        countingSortByDigit(arr, exp)
        exp *= 10
    }
}
```

**解析：** 基数排序算法是一种基于比较排序和非比较排序的排序算法，其基本思想是按低位先排序，然后收集；再按高位排序，然后再收集；依次类推，直到最高位。算法的时间复杂度为 O(d*(n+k))，其中 d 为位数，k 为基数（通常为 10），适合处理整数范围较小的问题。

