                 

### 《2025网易社招编程面试题精选与解答》——算法与数据结构篇

在每年的程序员招聘季，各大互联网公司都会发布一系列的编程面试题，以考察应聘者的技术能力和解决问题的能力。本文精选了2025年网易社招中的一些典型编程面试题，并给出详细的答案解析和算法思路，帮助大家更好地应对编程面试。

#### 面试题 1：最长公共子序列（LCS）

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到最长的公共子序列。最长公共子序列（Longest Common Subsequence，LCS）是在两个序列中同时出现的最长子序列。

**示例：**
```
s1 = "AGGTAB"
s2 = "GXTXAYB"
```
**答案：**
```
LCS: "GTAB"
```
**解析：**
该问题可以使用动态规划算法来解决。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列的长度。

状态转移方程如下：
```
if s1[i - 1] == s2[j - 1]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```
**代码实现：**
```go
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 面试题 2：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个升序链表。

**示例：**
```
l1: 1->3->4
l2: 1->2->4
```
**答案：**
```
合并后的链表：1->1->2->3->4->4
```
**解析：**
可以使用迭代法或递归法来合并两个链表。这里使用迭代法进行合并。

定义一个虚拟头节点，然后遍历两个链表，比较当前节点的值，将较小的节点连接到新链表中。

**代码实现：**
```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p, q := l1, l2
    for p != nil && q != nil {
        if p.Val < q.Val {
            curr.Next = p
            p = p.Next
        } else {
            curr.Next = q
            q = q.Next
        }
        curr = curr.Next
    }
    curr.Next = p // 剩余的链表直接连接到新链表末尾
    if p == nil {
        curr.Next = q
    }
    return dummy.Next
}
```

#### 面试题 3：反转整数

**题目描述：** 给你一个 32 位的有符号整数 `x`，返回将 `x` 中的数字部分反转后的结果。

**示例：**
```
输入：x = 123
输出：321
输入：x = -123
输出：-321
输入：x = 120
输出：21
```
**解析：**
可以按照以下步骤进行：
1. 判断整数是否为负数。
2. 逐位取余，反转整数。
3. 判断反转后的整数是否超出 32 位整数的范围。

**代码实现：**
```go
func reverse(x int) int {
    const INT_MAX = int32(1 << 31) - 1
    const INT_MIN = int32(-1 << 31)
    ans := 0
    for x != 0 {
        if ans < INT_MIN/(int32(x%10)<<31) {
            return 0
        }
        if ans > INT_MAX/(int32(x%10)<<31) {
            return 0
        }
        ans = ans*10 + x%10
        x /= 10
    }
    if ans < INT_MIN || ans > INT_MAX {
        return 0
    }
    return ans
}
```

#### 面试题 4：两数相加

**题目描述：** 给出两个 **非空** 的链表用来表示两个非负的整数，其中，它们各自的位数是按照 **逆序** 的方式存储的，并且每个节点只能存储一位数字。

**示例：**
```
输入：l1 = [2, 4, 3], l2 = [5, 6, 4]
输出：[7, 0, 8]
解释：342 + 465 = 807.
输入：l1 = [0], l2 = [0]
输出：[0]
解释：0 + 0 = 0.
输入：l1 = [9, 9, 9, 9, 9, 9, 9], l2 = [9, 9, 9, 9]
输出：[8, 9, 9, 9, 0, 0, 0, 1]
解释：99999999 + 9999 = 100000000.
```
**解析：**
可以使用循环链表的形式，遍历两个链表，相加后存储在新的链表中。注意处理进位的情况。

**代码实现：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var (
        dummy *ListNode
        p, q  *ListNode
        carry int
    )
    dummy = &ListNode{-1, nil}
    p = l1
    q = l2
    for p != nil || q != nil {
        sum := carry
        if p != nil {
            sum += p.Val
            p = p.Next
        }
        if q != nil {
            sum += q.Val
            q = q.Next
        }
        node := &ListNode{sum % 10, nil}
        carry = sum / 10
        if dummy.Next == nil {
            dummy.Next = node
        } else {
            last := dummy.Next
            for last.Next != nil {
                last = last.Next
            }
            last.Next = node
        }
    }
    if carry > 0 {
        node := &ListNode{carry, nil}
        last := dummy.Next
        for last.Next != nil {
            last = last.Next
        }
        last.Next = node
    }
    return dummy.Next
}
```

#### 面试题 5：移除链表元素

**题目描述：** 给你一个链表的头节点 `head` 和一个整数 `val` ，请删除链表中所有值为 `val` 的节点。

**示例：**
```
输入：head = [1, 2, 6, 3, 4, 5, 6], val = 6
输出：[1, 2, 3, 4, 5]
```
**解析：**
可以使用虚拟头节点，先判断头节点是否需要删除，然后遍历链表，删除所有值为 `val` 的节点。

**代码实现：**
```go
func removeElements(head *ListNode, val int) *ListNode {
    dummy := &ListNode{0, head}
    p := dummy
    for p != nil && p.Next != nil {
        if p.Next.Val == val {
            p.Next = p.Next.Next
        } else {
            p = p.Next
        }
    }
    return dummy.Next
}
```

#### 面试题 6：环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**
```
输入：head = [3, 2, 0, -4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```
**解析：**
使用快慢指针法，快指针每次走两步，慢指针每次走一步。如果链表中存在环，那么快指针最终会追上慢指针。

**代码实现：**
```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

#### 面试题 7：设计哈希表

**题目描述：** 设计一个哈希算法，实现哈希表。

**示例：**
```
我的哈希表：
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [], [2]]
```
```
输出：
[null, null, null, true, false, null, true, false, null]
```
**解析：**
可以使用哈希表来实现，其中数组长度为 `10001`，每个数组元素为一个链表。

**代码实现：**
```go
type MyHashSet struct {
    m map[int]bool
}

func Constructor() MyHashSet {
    return MyHashSet{m: make(map[int]bool)}
}

func (this *MyHashSet) Add(key int) {
    this.m[key] = true
}

func (this *MyHashSet) Remove(key int) {
    delete(this.m, key)
}

func (this *MyHashSet) Contains(key int) bool {
    _, ok := this.m[key]
    return ok
}
```

#### 面试题 8：设计循环缓冲区

**题目描述：** 设计一个循环缓冲区，支持插入、删除和查询操作。

**示例：**
```
MyCircularBuffer obj = new MyCircularBuffer(3);
obj.InsertLast(1);  // 返回 true
obj.InsertLast(2);  // 返回 true
obj.InsertFront(3); // 返回 true
obj.InsertFront(4); // 返回 false
obj.Get MainAxisAlignment.ERROR
```

