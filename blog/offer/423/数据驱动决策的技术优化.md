                 

### 数据驱动决策的技术优化

#### 一、典型问题/面试题库

**1. 数据分析中常用的统计指标有哪些？**

**答案：** 数据分析中常用的统计指标包括：

* **均值（Mean）：** 数据的平均值。
* **中位数（Median）：** 数据排序后位于中间的值。
* **众数（Mode）：** 数据中出现次数最多的值。
* **方差（Variance）：** 数据离均值的平方差的平均值。
* **标准差（Standard Deviation）：** 方差的平方根，用于描述数据的离散程度。
* **最大值（Maximum）和最小值（Minimum）：** 数据中的最大值和最小值。
* **百分位数（Percentile）：** 数据中某个百分比的值，如第 25 百分位数和第 75 百分位数。

**2. 如何处理缺失值？**

**答案：** 处理缺失值的方法包括：

* **删除缺失值：** 如果缺失值较多，可以考虑删除含有缺失值的样本或特征。
* **填充缺失值：** 常见的填充方法有：
  * **平均值填充：** 用特征的均值填充缺失值。
  * **中位数填充：** 用特征的中位数填充缺失值。
  * **众数填充：** 用特征的众数填充缺失值。
  * **插值法：** 利用已有的数据点进行插值，得到缺失值。
  * **K 近邻法：** 利用 K 近邻算法预测缺失值。

**3. 如何进行特征选择？**

**答案：** 特征选择的方法包括：

* **过滤式方法：** 根据特征的相关性、方差、缺失值等指标，筛选出重要的特征。
* **包装式方法：** 利用机器学习算法对特征进行筛选，常用的算法有随机森林、LASSO 等。
* **嵌入式方法：** 在模型训练过程中自动选择特征，如 LASSO、岭回归等。

**4. 如何进行数据预处理？**

**答案：** 数据预处理包括以下步骤：

* **数据清洗：** 去除重复数据、处理缺失值、处理异常值等。
* **数据归一化/标准化：** 将不同量纲的特征转换为相同量纲，如 min-max 标准化、z-score 标准化等。
* **数据变换：** 对数据进行幂变换、对数变换等，以改善模型性能。
* **特征工程：** 创建新的特征，如交叉特征、交互特征等。

**5. 如何进行模型选择？**

**答案：** 模型选择的方法包括：

* **交叉验证：** 利用训练集和验证集，多次训练和验证模型，以评估模型性能。
* **网格搜索：** 根据预设的参数范围，遍历所有可能的参数组合，选择最佳参数。
* **贝叶斯优化：** 利用贝叶斯统计方法，寻找最优参数。

**6. 如何进行模型评估？**

**答案：** 常见的模型评估指标包括：

* **准确率（Accuracy）：** 分类正确的样本数占总样本数的比例。
* **精确率（Precision）：** 精确率是指预测为正类的样本中，实际为正类的比例。
* **召回率（Recall）：** 召回率是指实际为正类的样本中，预测为正类的比例。
* **F1 值（F1 Score）：** 精确率和召回率的调和平均值。
* **ROC 曲线：** 受害者操作特性曲线，用于评估分类器的性能。
* **AUC 值（AUC Area Under Curve）：** ROC 曲线下面的面积，用于评估分类器的性能。

**7. 如何进行模型调优？**

**答案：** 模型调优的方法包括：

* **调参：** 修改模型参数，以改善模型性能。
* **集成学习：** 将多个模型组合成一个更强大的模型，如随机森林、梯度提升树等。
* **增强学习：** 利用机器学习算法优化决策过程，以实现最佳效果。

#### 二、算法编程题库

**1. 寻找两个正数的最小乘积**

**题目描述：** 给定一个整数数组，找到其中两个正数的最小乘积。

**示例：**

```plaintext
输入：[1, -2, -3, 4]
输出：-12
```

**答案：**

```python
def min_product(nums):
    min1 = float('inf')
    min2 = float('inf')
    for num in nums:
        if num < min1:
            min2 = min1
            min1 = num
        elif num < min2:
            min2 = num
    return min1 * min2

nums = [1, -2, -3, 4]
print(min_product(nums))
```

**2. 单调递增的三元组**

**题目描述：** 给定一个整数数组，找到所有单调递增的三元组。

**示例：**

```plaintext
输入：[1, 2, 3, 4, 5]
输出：[[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]
```

**答案：**

```python
def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result

nums = [1, 2, 3, 4, 5]
print(three_sum(nums))
```

**3. 求和减去最大连续子数组**

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，返回数组中任意连续子数组的最大和减去 `k` 的结果。

**示例：**

```plaintext
输入：nums = [1, -1, 5, -2, 3], k = 3
输出：8
解释：最大和的连续子数组是 [5, -2, 3]，和为 6，减去 k = 3，结果为 3。
```

**答案：**

```python
from typing import List
from sortedcontainers import SortedList

def maxSubarraySum(nums: List[int], k: int) -> int:
    ans = cur = 0
    q = SortedList()
    for i, v in enumerate(nums):
        cur += v
        q.add(cur)
        if i >= k:
            cur -= q.remove(nums[i - k])
        ans = max(ans, cur)
    return ans

nums = [1, -1, 5, -2, 3]
k = 3
print(maxSubarraySum(nums, k))
```

**4. 找出数组中的重复元素**

**题目描述：** 给定一个整数数组 `nums`，其中每个元素都在 `1` 到 `n`（其中 `n == nums.length`）的范围内。请找出并返回数组中任意一个重复的元素。如果数组中没有重复元素，则返回 `-1`。

**示例：**

```plaintext
输入：nums = [2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
```

**答案：**

```python
def findDuplicate(nums):
    n = len(nums)
    for i in range(n):
        while nums[i] != i:
            if nums[i] == nums[nums[i]]:
                return nums[i]
            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]
    return -1

nums = [2, 3, 1, 0, 2, 5, 3]
print(findDuplicate(nums))
```

**5. 最小差值**

**题目描述：** 给定一个整数数组 `nums`，返回数组中任意两个元素的最小绝对差。如果数组中只有一个元素，返回 `0`。

**示例：**

```plaintext
输入：nums = [1, 3, 6, 10, 15]
输出：2
解释：数组中任意两个元素的最小绝对差是 2（6 - 4 = 2）。
```

**答案：**

```python
def minimumAbsDifference(nums):
    nums.sort()
    ans = float('inf')
    for i in range(1, len(nums)):
        ans = min(ans, nums[i] - nums[i - 1])
    return ans

nums = [1, 3, 6, 10, 15]
print(minimumAbsDifference(nums))
```

**6. 累加数**

**题目描述：** 给定一个整数数组 `nums`，返回数组中所有累加序列的长短。如果一个序列满足：序列中的每一个元素都在前一个元素的基础上累加，那么该序列为累加序列。

**示例：**

```plaintext
输入：nums = [1, 1, 1, 1, 1]
输出：[[1, 1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1], [1, 1], [1]]
```

**答案：**

```python
def FindsSEQUENCEs(nums):
    def dfs(seq):
        if not seq:
            sequences.append(seq)
            return
        if seq[-1] + nums[i] == target:
            dfs(seq + [nums[i]])
        elif seq[-1] + nums[i] < target:
            dfs(seq + [nums[i]])

    target = sum(nums) // 2
    sequences = []
    dfs([])
    return sequences

nums = [1, 1, 1, 1, 1]
print(FindsSEQUENCEs(nums))
```

**7. 反转数字**

**题目描述：** 给定一个整数 `num`，返回其反转后的数字。

**示例：**

```plaintext
输入：num = 123
输出：321
```

**答案：**

```python
def reverse(num):
    ans = 0
    while num:
        ans = ans * 10 + num % 10
        num //= 10
    return ans

num = 123
print(reverse(num))
```

**8. 有效的括号**

**题目描述：** 给定一个包含大写字母和小写字母的字符串 `s`，返回 `s` 是否是平衡括号字符串。

**示例：**

```plaintext
输入：s = "())()"
输出：false
```

**答案：**

```python
def balancedString(s):
    balance = 0
    for c in s:
        if c == '(':
            balance += 1
        else:
            balance -= 1
        if balance == 0:
            s = s[:s.index(c, 1)] + s[s.index(c, 1) + 1:]
            return True
    return False

s = "())()"
print(balancedString(s))
```

**9. 螺旋矩阵**

**题目描述：** 给定一个 `m x n` 的二维矩阵，按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例：**

```plaintext
输入：matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
输出：[1, 2, 3, 6, 9, 8, 7, 4, 5]
```

**答案：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    ans = []
    m, n = len(matrix), len(matrix[0])
    top, bottom, left, right = 0, m - 1, 0, n - 1
    while top <= bottom and left <= right:
        for i in range(left, right + 1):
            ans.append(matrix[top][i])
        top += 1
        for i in range(top, bottom + 1):
            ans.append(matrix[i][right])
        right -= 1
        if top <= bottom:
            for i in range(right, left - 1, -1):
                ans.append(matrix[bottom][i])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top - 1, -1):
                ans.append(matrix[i][left])
            left += 1
    return ans

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(spiralOrder(matrix))
```

**10. 单调栈**

**题目描述：** 给定一个数组 `nums`，返回一个数组，其中 `res[i]` 表示 `nums[i]` 左边的第一个比它大的元素。如果不存在这样的元素，则相应的 `res[i]` 为 `-1`。

**示例：**

```plaintext
输入：nums = [2, 1, 2, 3, 4]
输出：[-1, 2, -1, 3, 4]
```

**答案：**

```python
from collections import deque

def nextGreaterElement(nums1, nums2):
    stack = deque()
    ans = [-1] * len(nums1)
    for num in nums2:
        while stack and stack[-1] < num:
            ans[stack.pop()] = num
        stack.append(num)
    return ans

nums1 = [2, 1, 2, 3, 4]
nums2 = [2, 6, 4, 8, 3, 7, 9, 1, 2, 5, 10, 9, 7, 8, 9, 1, 6]
print(nextGreaterElement(nums1, nums2))
```

**11. 快慢指针**

**题目描述：** 给定一个链表 `head`，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

**示例：**

```plaintext
输入：head = [3, 2, 0, -4], pos = 1
输出：[3, 2, 0, -4]
解释：链表中有一个环，环的起点位于节点索引 1，即节点 2。
```

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def detectCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    if fast is None or fast.next is None:
        return None
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    return slow

head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
pos = ListNode(1)
head.next.next.next = pos
print(detectCycle(head))
```

**12. 扩展有序数组的平方**

**题目描述：** 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置。

**示例：**

```plaintext
输入：nums = [-1, -100, 3, 99], k = 2
输出：[3, 99, -1, -100]
```

**答案：**

```python
def rotate(nums, k):
    k %= len(nums)
    nums[:k], nums[k:] = nums[-k:], nums[:-k]

nums = [-1, -100, 3, 99]
k = 2
rotate(nums, k)
print(nums)
```

**13. 逆序对**

**题目描述：** 给定一个整数数组 `nums`，返回数组中逆序对的数量。

**示例：**

```plaintext
输入：nums = [2, 7, 3, 4, 1, 8, 5]
输出：6
解释：(2, 1), (7, 1), (7, 3), (7, 4), (8, 1), (8, 3)
```

**答案：**

```python
def mergeSortCount(nums):
    if len(nums) < 2:
        return nums, 0
    mid = len(nums) // 2
    left, left_count = mergeSortCount(nums[:mid])
    right, right_count = mergeSortCount(nums[mid:])
    merged, merge_count = merge(left, right)
    return merged, left_count + right_count + merge_count

def merge(left, right):
    ans = []
    count = 0
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            ans.append(left[i])
            i += 1
        else:
            ans.append(right[j])
            j += 1
            count += len(left) - i
    ans.extend(left[i:])
    ans.extend(right[j:])
    return ans, count

nums = [2, 7, 3, 4, 1, 8, 5]
print(mergeSortCount(nums)[1])
```

**14. 求最小覆盖区间**

**题目描述：** 给定一个区间列表 `intervals`，每个区间的起始端点和结束端点都在 `1` 到 `10^6` 之间，且 `intervals[i] = [starti, endi]`。返回最小的覆盖所有给定区间的区间。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[1, 18]
解释：区间 [1, 18] 覆盖了所有给定的区间。
```

**答案：**

```python
def merge(intervals):
    intervals.sort(key=lambda x: x[0])
    merged = []
    for interval in intervals:
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            merged[-1][1] = max(merged[-1][1], interval[1])
    return merged

def smallestRange(intervals):
    left, right = min(i[0] for i in intervals), max(i[1] for i in intervals)
    while left < right:
        mid = (left + right) // 2
        if sum(1 for i in intervals if i[0] <= mid < i[1]) < 1000:
            right = mid
        else:
            left = mid + 1
    return [left, right]

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(smallestRange(intervals))
```

**15. 求最长公共子序列**

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的**最长公共子序列**（LCS）。

**示例：**

```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"
```

**答案：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    i, j = m, n
    ans = []
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            ans.append(text1[i - 1])
            i, j = i - 1, j - 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return ''.join(ans[::-1])

text1 = "abcde"
text2 = "ace"
print(longestCommonSubsequence(text1, text2))
```

**16. 求最长公共子串**

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的**最长公共子串**（LCS）。

**示例：**

```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"
```

**答案：**

```python
def longestCommonSubstring(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end = i - 1
            else:
                dp[i][j] = 0
    return text1[end - max_len + 1: end + 1]

text1 = "abcde"
text2 = "ace"
print(longestCommonSubstring(text1, text2))
```

**17. 求最长公共前缀**

**题目描述：** 给定一个字符串数组 `strs`，返回 `strs` 的最长公共前缀。

**示例：**

```plaintext
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))
```

**18. 求最长连续序列**

**题目描述：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**示例：**

```plaintext
输入：nums = [100, 4, 200, 1, 3, 2]
输出：4
解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**答案：**

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums = sorted(set(nums))
    ans = 1
    cur = 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i - 1] + 1:
            cur += 1
            ans = max(ans, cur)
        else:
            cur = 1
    return ans

nums = [100, 4, 200, 1, 3, 2]
print(longestConsecutive(nums))
```

**19. 最小覆盖数组**

**题目描述：** 给定一个整数数组 `nums` 和一个正整数 `k`，返回一个长度为 `k` 的数组，该数组中的数字是从 `nums` 中挑选出来的最小的 `k` 个数。

**示例：**

```plaintext
输入：nums = [4, 5, 1, 6], k = 2
输出：[1, 4]
解释：数组中最小的两个数字是 1 和 4。
```

**答案：**

```python
from heapq import nlargest

def smallestK(nums, k):
    return nlargest(k, nums)

nums = [4, 5, 1, 6]
k = 2
print(smallestK(nums, k))
```

**20. 前K大元素**

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，返回数组中前 `k` 大的元素。

**示例：**

```plaintext
输入：nums = [3, 2, 1, 5, 6, 4], k = 2
输出：[5, 6], 或 [5, 6], 或 [4, 5]
```

**答案：**

```python
def topKFrequent(nums, k):
    count = Counter(nums)
    return heapq.nlargest(k, count.keys())

nums = [3, 2, 1, 5, 6, 4]
k = 2
print(topKFrequent(nums, k))
```

**21. 寻找重复的子数组**

**题目描述：** 给定一个长度为 `n` 的整数数组 `nums` 和一个整数 `k`，返回数组中所有重复的子数组的长度。你可以按任何顺序返回答案。

**示例：**

```plaintext
输入：nums = [1,2,3,1,2,3], k = 2
输出：[2,3]
解释：
长度为 2 的子数组 ["1","2"] 出现了两次。
长度为 3 的子数组 ["1","2","3"] 也出现了两次。
```

**答案：**

```python
def findDuplicateSubarray(nums, k):
    n = len(nums)
    mod = 2**31 - 1
    for i in range(1, n):
        nums[i] = nums[i] * i % mod
    cnt = Counter(nums)
    return [x for x, c in cnt.items() if c > 1 and x < k]

nums = [1, 2, 3, 1, 2, 3]
k = 2
print(findDuplicateSubarray(nums, k))
```

**22. 最小覆盖数组**

**题目描述：** 给定一个整数数组 `nums` 和一个正整数 `k`，返回一个长度为 `k` 的数组，该数组中的数字是从 `nums` 中挑选出来的最小的 `k` 个数。

**示例：**

```plaintext
输入：nums = [4, 5, 1, 6], k = 2
输出：[1, 4]
解释：数组中最小的两个数字是 1 和 4。
```

**答案：**

```python
def smallestK(nums, k):
    return heapq.nsmallest(k, nums)

nums = [4, 5, 1, 6]
k = 2
print(smallestK(nums, k))
```

**23. 查找所有数组中的排序子数组**

**题目描述：** 给定一个整数数组 `nums`，返回所有长度为 3 的排序子数组的个数。

**示例：**

```plaintext
输入：nums = [1, 3, 3, 2, 1, 4]
输出：3
解释：三个长度为 3 的排序子数组为 [1, 3, 3], [3, 3, 2] 和 [3, 2, 1]。
```

**答案：**

```python
def subarraysorted(nums):
    ans = 0
    n = len(nums)
    for i in range(n - 2):
        if nums[i] <= nums[i + 1] <= nums[i + 2]:
            ans += 1
    return ans

nums = [1, 3, 3, 2, 1, 4]
print(subarraysorted(nums))
```

**24. 寻找两个正数的最小乘积**

**题目描述：** 给定一个整数数组，找到其中两个正数的最小乘积。

**示例：**

```plaintext
输入：[1, -2, -3, 4]
输出：-12
```

**答案：**

```python
def min_product(nums):
    min1 = float('inf')
    min2 = float('inf')
    for num in nums:
        if num < min1:
            min2 = min1
            min1 = num
        elif num < min2:
            min2 = num
    return min1 * min2

nums = [1, -2, -3, 4]
print(min_product(nums))
```

**25. 单调递增的三元组**

**题目描述：** 给定一个整数数组，找到所有单调递增的三元组。

**示例：**

```plaintext
输入：[1, 2, 3, 4, 5]
输出：[[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]
```

**答案：**

```python
def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == 0:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < 0:
                left += 1
            else:
                right -= 1
    return result

nums = [1, 2, 3, 4, 5]
print(three_sum(nums))
```

**26. 求和减去最大连续子数组**

**题目描述：** 给定一个整数数组，返回一个数组，其中每个元素是原数组中任意连续子数组的和减去该子数组中的最大元素的值。

**示例：**

```plaintext
输入：nums = [1, -1, 5, -2, 3]
输出：[8, 6, 2, -4, 4]
```

**答案：**

```python
def maxSubarraySum(nums, k):
    d = deque()
    ans = [0] * len(nums)
    for i, x in enumerate(nums):
        while d and d[0] < i - k:
            d.popleft()
        while d and nums[d[-1]] < x:
            d.pop()
        d.append(i)
        ans[i] = i - k + 1 - nums[d[0]]
    return ans

nums = [1, -1, 5, -2, 3]
k = 3
print(maxSubarraySum(nums, k))
```

**27. 累加数**

**题目描述：** 给定一个整数数组，返回数组中所有累加序列的长短。如果一个序列满足：序列中的每一个元素都在前一个元素的基础上累加，那么该序列为累加序列。

**示例：**

```plaintext
输入：nums = [1, 1, 1, 1, 1]
输出：[[1, 1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1], [1, 1], [1]]
```

**答案：**

```python
def findsSEQUENCEs(nums):
    def dfs(seq):
        if not seq:
            sequences.append(seq)
            return
        if seq[-1] + nums[i] == target:
            dfs(seq + [nums[i]])
        elif seq[-1] + nums[i] < target:
            dfs(seq + [nums[i]])

    target = sum(nums) // 2
    sequences = []
    dfs([])
    return sequences

nums = [1, 1, 1, 1, 1]
print(findsSEQUENCEs(nums))
```

**28. 接雨水**

**题目描述：** 给定一个由整数数组 `height` 表示的柱状图，返回在这一次雨后可以接多少雨水。

**示例：**

```plaintext
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：最终的水量为 (1 + 3 + 2 + 1) + (5 + 1 + 2) + (1) = 6。
```

**答案：**

```python
def trap(height):
    n = len(height)
    ans = 0
    left, right = 0, n - 1
    max_left, max_right = 0, 0
    while left < right:
        if height[left] < height[right]:
            if height[left] > max_left:
                max_left = height[left]
            else:
                ans += max_left - height[left]
            left += 1
        else:
            if height[right] > max_right:
                max_right = height[right]
            else:
                ans += max_right - height[right]
            right -= 1
    return ans

height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
print(trap(height))
```

**29. 求最小覆盖区间**

**题目描述：** 给定一个区间列表 `intervals`，每个区间的起始端点和结束端点都在 `1` 到 `10^6` 之间，且 `intervals[i] = [starti, endi]`。返回最小的覆盖所有给定区间的区间。

**示例：**

```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[1, 18]
解释：区间 [1, 18] 覆盖了所有给定的区间。
```

**答案：**

```python
def merge(intervals):
    intervals.sort(key=lambda x: x[0])
    merged = []
    for interval in intervals:
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            merged[-1][1] = max(merged[-1][1], interval[1])
    return merged

def smallestRange(intervals):
    left, right = min(i[0] for i in intervals), max(i[1] for i in intervals)
    while left < right:
        mid = (left + right) // 2
        if sum(1 for i in intervals if i[0] <= mid < i[1]) < 1000:
            right = mid
        else:
            left = mid + 1
    return [left, right]

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(smallestRange(intervals))
```

**30. 最长公共子序列**

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的**最长公共子序列**（LCS）。

**示例：**

```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"
```

**答案：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    i, j = m, n
    ans = []
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            ans.append(text1[i - 1])
            i, j = i - 1, j - 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    return ''.join(ans[::-1])

text1 = "abcde"
text2 = "ace"
print(longestCommonSubsequence(text1, text2))
```

#### 三、答案解析说明

**1. 寻找两个正数的最小乘积**

在这个问题中，我们需要找到数组中的两个正数，使得它们的乘积最小。首先，我们可以遍历数组，找到最小的两个正数，然后计算它们的乘积。为了简化问题，我们可以分别找到最小值和第二小值，这样就可以确保找到最小的乘积。

**2. 单调递增的三元组**

我们需要找到数组中所有单调递增的三元组。首先，我们可以对数组进行排序，这样就可以保证每个三元组都是单调递增的。然后，我们可以遍历排序后的数组，检查每个相邻的元素，如果当前元素大于前一个元素，则可以继续添加到三元组中。

**3. 求和减去最大连续子数组**

这个问题中，我们需要找到数组中任意连续子数组的和，然后减去该子数组中的最大元素的值。为了解决这个问题，我们可以使用双端队列（deque）来存储当前子数组中的最小和最大值，然后遍历数组，更新队列并计算结果。

**4. 累加数**

我们需要找到数组中的所有累加序列。我们可以使用深度优先搜索（DFS）的方法，从每个元素开始，递归地构建累加序列。为了简化问题，我们可以从后往前遍历数组，每次递归时都尝试加上当前元素。

**5. 反转数字**

我们需要反转一个整数的数字。为了解决这个问题，我们可以使用循环和除法取余的方法。具体来说，我们可以不断将数字除以 10，然后将余数加到结果上，直到数字变为 0。

**6. 有效的括号**

我们需要判断一个字符串是否是平衡括号字符串。我们可以使用栈来解决这个问题。具体来说，我们可以遍历字符串，如果遇到左括号，则将其入栈；如果遇到右括号，则判断栈顶元素是否与之匹配，如果匹配，则出栈。最后，如果栈为空，则字符串是平衡括号字符串。

**7. 螺旋矩阵**

我们需要按照顺时针螺旋顺序返回矩阵中的所有元素。为了解决这个问题，我们可以定义四个边界，然后按照螺旋顺序遍历矩阵。具体来说，我们从左上角开始，先向右遍历，然后向下，然后向左，最后向上，然后缩小边界，重复这个过程，直到遍历完整个矩阵。

**8. 单调栈**

我们需要找到数组中每个元素左边的第一个比它大的元素。我们可以使用单调栈的方法。具体来说，我们可以遍历数组，使用栈来存储元素的下标。对于当前遍历到的元素，我们从栈顶开始弹出元素，如果栈顶元素对应的值小于当前元素，则说明找到了左边的第一个比它大的元素。

**9. 快慢指针**

我们需要找到链表中开始入环的第一个节点。为了解决这个问题，我们可以使用快慢指针的方法。具体来说，我们先初始化两个指针，一个快指针每次移动两个节点，一个慢指针每次移动一个节点。如果链表中有环，则快指针最终会追上慢指针。然后，我们可以同时将快指针和慢指针移回到链表的开头，每次同时移动一个节点，当它们相遇时，慢指针所在的节点就是开始入环的第一个节点。

**10. 逆序对**

我们需要计算数组中逆序对的数量。为了解决这个问题，我们可以使用归并排序的方法。具体来说，我们可以将数组分成两半，然后分别对两半进行排序，并计算逆序对的数量。在合并两个有序数组时，我们可以根据两个数组中当前元素的大小来计算逆序对的数量。

**11. 求最小覆盖区间**

我们需要找到最小的覆盖所有给定区间的区间。为了解决这个问题，我们可以使用二分查找的方法。具体来说，我们可以定义一个左边界和一个右边界，然后使用二分查找的方法来缩小区间。如果当前区间的长度小于等于 1000，则说明右边界可能是最小的覆盖区间，否则说明左边界可能更小。

**12. 求最长公共子序列**

我们需要找到两个字符串的最长公共子序列。为了解决这个问题，我们可以使用动态规划的方法。具体来说，我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。然后，我们可以通过递归的方式填写这个数组，并最终得到最长公共子序列。

**13. 求最长公共子串**

我们需要找到两个字符串的最长公共子串。为了解决这个问题，我们可以使用动态规划的方法。具体来说，我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子串的长度。然后，我们可以通过递归的方式填写这个数组，并最终得到最长公共子串。

**14. 求最长公共前缀**

我们需要找到字符串数组中的最长公共前缀。为了解决这个问题，我们可以使用横向扫描的方法。具体来说，我们可以从第一个字符串开始，逐个比较每个字符串的字符，直到找到不同的字符为止。这样，我们就可以得到最长公共前缀。

**15. 求最长连续序列**

我们需要找到整数数组中的最长连续序列。为了解决这个问题，我们可以使用排序和二分查找的方法。具体来说，我们可以先将数组排序，然后使用二分查找的方法来查找连续序列的长度。

**16. 查找所有数组中的排序子数组**

我们需要找到整数数组中的所有排序子数组。为了解决这个问题，我们可以使用双指针的方法。具体来说，我们可以使用两个指针 `i` 和 `j` 来遍历数组，当找到不满足排序关系的元素时，将 `i` 移动到 `j` 的下一个位置，然后从 `i` 开始检查是否有排序子数组。

**17. 前K大元素**

我们需要找到整数数组中的前 `k` 大元素。为了解决这个问题，我们可以使用快速选择算法。具体来说，我们可以从数组的最后一个元素开始，将数组分成两部分，然后选择一个基准元素，将数组中小于基准元素的放到左边，大于基准元素的放到右边，然后递归地选择左边的部分或右边的部分。

**18. 寻找重复的子数组**

我们需要找到整数数组中重复的子数组。为了解决这个问题，我们可以使用哈希表的方法。具体来说，我们可以遍历数组，对于每个元素，我们将其乘以其下标，然后将其作为哈希表的键，如果哈希表中已经存在这个键，则说明数组中有重复的子数组。

**19. 求最小覆盖数组**

我们需要找到整数数组中最小的 `k` 个数。为了解决这个问题，我们可以使用堆的方法。具体来说，我们可以使用一个最大堆来存储数组中的前 `k` 大元素，然后遍历数组，如果数组中的元素大于堆顶元素，则将堆顶元素弹出，然后将当前元素加入堆中。

**20. 单调递增的三元组**

我们需要找到整数数组中的所有单调递增的三元组。为了解决这个问题，我们可以使用双指针的方法。具体来说，我们可以使用两个指针 `i` 和 `j` 来遍历数组，当 `j` 大于 `i + 1` 时，我们尝试找到一个单调递增的三元组。

**21. 求和减去最大连续子数组**

我们需要找到整数数组中任意连续子数组的和减去该子数组中的最大元素的值。为了解决这个问题，我们可以使用双端队列的方法。具体来说，我们可以使用两个双端队列来存储当前子数组中的最小和最大元素，然后遍历数组，更新队列并计算结果。

**22. 累加数**

我们需要找到整数数组中的所有累加序列。为了解决这个问题，我们可以使用深度优先搜索的方法。具体来说，我们可以使用递归的方式，从每个元素开始，递归地构建累加序列。

**23. 接雨水**

我们需要计算柱状图中可以接多少雨水。为了解决这个问题，我们可以使用双指针的方法。具体来说，我们可以使用两个指针 `left` 和 `right` 来遍历数组，同时维护当前最大高度 `max_height`，然后根据当前高度和最大高度计算可以接的雨水。

**24. 求最小覆盖区间**

我们需要找到最小覆盖所有给定区间的区间。为了解决这个问题，我们可以使用二分查找的方法。具体来说，我们可以定义一个左边界和一个右边界，然后使用二分查找的方法来缩小区间。

**25. 求最长公共子序列**

我们需要找到两个字符串的最长公共子序列。为了解决这个问题，我们可以使用动态规划的方法。具体来说，我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。

**26. 求最长公共子串**

我们需要找到两个字符串的最长公共子串。为了解决这个问题，我们可以使用动态规划的方法。具体来说，我们可以定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子串的长度。

**27. 最长公共前缀**

我们需要找到字符串数组中的最长公共前缀。为了解决这个问题，我们可以使用横向扫描的方法。具体来说，我们可以从第一个字符串开始，逐个比较每个字符串的字符，直到找到不同的字符为止。

**28. 最长连续序列**

我们需要找到整数数组中的最长连续序列。为了解决这个问题，我们可以使用排序和二分查找的方法。具体来说，我们可以先将数组排序，然后使用二分查找的方法来查找连续序列的长度。

**29. 查找所有数组中的排序子数组**

我们需要找到整数数组中的所有排序子数组。为了解决这个问题，我们可以使用双指针的方法。具体来说，我们可以使用两个指针 `i` 和 `j` 来遍历数组，当找到不满足排序关系的元素时，将 `i` 移动到 `j` 的下一个位置，然后从 `i` 开始检查是否有排序子数组。

**30. 前K大元素**

我们需要找到整数数组中的前 `k` 大元素。为了解决这个问题，我们可以使用快速选择算法。具体来说，我们可以从数组的最后一个元素开始，将数组分成两部分，然后选择一个基准元素，将数组中小于基准元素的放到左边，大于基准元素的放到右边，然后递归地选择左边的部分或右边的部分。

