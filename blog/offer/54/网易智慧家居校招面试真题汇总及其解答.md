                 

# 2024网易智慧家居校招面试真题汇总及其解答

## 简介

本文将对2024年网易智慧家居校招面试真题进行汇总，并针对每一道真题提供详细的解题思路和答案解析，帮助准备校招的同学们更好地应对面试挑战。

## 面试题库与解析

### 1. 判断一个字符串是否是回文

**题目描述：** 判断一个字符串是否是回文。

**解题思路：** 可以通过将字符串反转，然后与原字符串比较，如果相同，则说明是回文。

**代码示例：**

```python
def is_palindrome(s):
    return s == s[::-1]

s = "level"
print(is_palindrome(s))  # 输出 True
```

### 2. 计算数组中两个元素的最大和

**题目描述：** 给定一个整数数组，找到两个元素的最大和。

**解题思路：** 可以通过遍历数组，找出最大的两个元素，然后计算它们的和。

**代码示例：**

```python
def max_sum_of_two(nums):
    max1, max2 = float('-inf'), float('-inf')
    for num in nums:
        if num > max1:
            max2 = max1
            max1 = num
        elif num > max2:
            max2 = num
    return max1 + max2

nums = [1, 3, 5, 2, 4]
print(max_sum_of_two(nums))  # 输出 9
```

### 3. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**解题思路：** 可以通过比较两个链表的头节点，将较小的节点连接到结果链表中，然后移动较小节点的链表指针。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_two_lists(l1, l2)
```

### 4. 寻找旋转排序数组中的最小值

**题目描述：** 寻找旋转排序数组中的最小值。

**解题思路：** 可以使用二分查找的方法，通过比较中间元素和左右端点元素，确定最小值所在的范围。

**代码示例：**

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

nums = [4, 5, 6, 7, 0, 1, 2]
print(find_min(nums))  # 输出 0
```

### 5. 求最长公共前缀

**题目描述：** 求字符串数组中的最长公共前缀。

**解题思路：** 可以使用横向比较的方法，逐个字符比较，直到出现不同的字符。

**代码示例：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

### 6. 反转链表

**题目描述：** 反转一个单链表。

**解题思路：** 可以使用递归或迭代的方法，遍历链表，将当前节点的指针指向前一个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev

# 构建链表
l1 = ListNode(1)
l1.next = ListNode(2)
l1.next.next = ListNode(3)
l1.next.next.next = ListNode(4)
l1.next.next.next.next = ListNode(5)

# 反转链表
reversed_list = reverse_list(l1)
```

### 7. 计数质数

**题目描述：** 计算一个数小于或等于n的所有质数的数量。

**解题思路：** 可以使用埃拉托斯特尼筛法（Sieve of Eratosthenes）。

**代码示例：**

```python
def count_primes(n):
    if n < 2:
        return 0
    is_prime = [True] * n
    is_prime[0], is_prime[1] = False, False
    for i in range(2, int(n ** 0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n, i):
                is_prime[j] = False
    return sum(is_prime)

n = 10
print(count_primes(n))  # 输出 4
```

### 8. 爬楼梯

**题目描述：** 假设你正在爬楼梯，每次可以爬1个或2个台阶，请计算有多少种不同的方法可以爬到楼顶。

**解题思路：** 可以使用动态规划的方法。

**代码示例：**

```python
def climb_stairs(n):
    if n < 2:
        return n
    a, b = 0, 1
    for _ in range(n - 1):
        a, b = b, a + b
    return b

n = 3
print(climb_stairs(n))  # 输出 3
```

### 9. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**解题思路：** 可以使用递归或迭代的方法，比较两个链表的头节点，将较小的节点连接到结果链表中。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = merge_two_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_two_lists(l1, l2.next)
        return l2

l1 = ListNode(1)
l1.next = ListNode(3)
l1.next.next = ListNode(5)

l2 = ListNode(2)
l2.next = ListNode(4)
l2.next.next = ListNode(6)

merged_list = merge_two_lists(l1, l2)
```

### 10. 删除链表的节点

**题目描述：** 删除链表中的某个节点。

**解题思路：** 可以将待删除节点的下一个节点的值赋给待删除节点，然后删除下一个节点。

**代码示例：**

```python
def delete_node(node):
    if node.next is None:
        node = None
    else:
        node.val = node.next.val
        temp = node.next
        node.next = node.next.next
        temp = None

# 构建链表
l1 = ListNode(1)
l1.next = ListNode(2)
l1.next.next = ListNode(3)
l1.next.next.next = ListNode(4)
l1.next.next.next.next = ListNode(5)

# 删除节点
delete_node(l1.next.next)
```

### 11. 二进制中1的个数

**题目描述：** 计算一个无符号整数二进制表示中1的个数。

**解题思路：** 可以使用位操作，将整数与1进行位与操作，然后右移，循环直到整数变为0。

**代码示例：**

```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

n = 00000000000000000000000000001011
print(hammingWeight(n))  # 输出 3
```

### 12. 二叉搜索树的第k个结点

**题目描述：** 给定一个二叉搜索树，请找出其第k小的结点。

**解题思路：** 可以通过中序遍历二叉搜索树，找到第k个节点。

**代码示例：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        def dfs(root):
            if root is None:
                return
            dfs(root.left)
            self.res.append(root.val)
            dfs(root.right)

        self.res = []
        dfs(root)
        return self.res[k - 1]
```

### 13. 最小栈

**题目描述：** 实现一个最小栈，支持push、pop和getMin操作。

**解题思路：** 可以使用两个栈，一个用于存储所有元素，另一个用于存储最小值。

**代码示例：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

### 14. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序数组中的目标值。

**解题思路：** 可以使用二分查找的方法，确定目标值所在的范围。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 15. 链表中倒数第k个节点

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**解题思路：** 可以使用快慢指针的方法，先让快指针移动k步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针所指的节点即为倒数第k个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head: ListNode, k: int) -> ListNode:
    fast = slow = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    while fast:
        fast = fast.next
        slow = slow.next
    return slow
```

### 16. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**解题思路：** 可以使用递归或迭代的方法，比较两个链表的头节点，将较小的节点连接到结果链表中。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

### 17. 设计一个支持Twitter的最近十条推文

**题目描述：** 设计一个支持Twitter的最近十条推文的数据结构。

**解题思路：** 可以使用双向链表和哈希表，双向链表存储最近的十条推文，哈希表用于存储推文和对应的节点。

**代码示例：**

```python
class Twitter:
    def __init__(self):
        self.follows = defaultdict(list)
        self.tweets = []  # 存储最近十条推文

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets.append((userId, tweetId))
        if len(self.tweets) > 10:
            self.tweets.pop(0)

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = []
        for user in self.follows[userId]:
            for tweet in self.tweets:
                if tweet[0] == user:
                    feed.append(tweet[1])
        return feed

    def follow(self, followerId: int, followeeId: int) -> None:
        self.follows[followerId].append(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
```

### 18. 反转链表

**题目描述：** 反转一个单链表。

**解题思路：** 可以使用递归或迭代的方法，遍历链表，将当前节点的指针指向前一个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

### 19. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序数组中的目标值。

**解题思路：** 可以使用二分查找的方法，确定目标值所在的范围。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 20. 链表中倒数第k个节点

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**解题思路：** 可以使用快慢指针的方法，先让快指针移动k步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针所指的节点即为倒数第k个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head: ListNode, k: int) -> ListNode:
    fast = slow = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    while fast:
        fast = fast.next
        slow = slow.next
    return slow
```

### 21. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**解题思路：** 可以使用递归或迭代的方法，比较两个链表的头节点，将较小的节点连接到结果链表中。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

### 22. 设计一个支持Twitter的最近十条推文

**题目描述：** 设计一个支持Twitter的最近十条推文的数据结构。

**解题思路：** 可以使用双向链表和哈希表，双向链表存储最近的十条推文，哈希表用于存储推文和对应的节点。

**代码示例：**

```python
class Twitter:
    def __init__(self):
        self.follows = defaultdict(list)
        self.tweets = []  # 存储最近十条推文

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets.append((userId, tweetId))
        if len(self.tweets) > 10:
            self.tweets.pop(0)

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = []
        for user in self.follows[userId]:
            for tweet in self.tweets:
                if tweet[0] == user:
                    feed.append(tweet[1])
        return feed

    def follow(self, followerId: int, followeeId: int) -> None:
        self.follows[followerId].append(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
```

### 23. 反转链表

**题目描述：** 反转一个单链表。

**解题思路：** 可以使用递归或迭代的方法，遍历链表，将当前节点的指针指向前一个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

### 24. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序数组中的目标值。

**解题思路：** 可以使用二分查找的方法，确定目标值所在的范围。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 25. 链表中倒数第k个节点

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**解题思路：** 可以使用快慢指针的方法，先让快指针移动k步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针所指的节点即为倒数第k个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head: ListNode, k: int) -> ListNode:
    fast = slow = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    while fast:
        fast = fast.next
        slow = slow.next
    return slow
```

### 26. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**解题思路：** 可以使用递归或迭代的方法，比较两个链表的头节点，将较小的节点连接到结果链表中。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

### 27. 设计一个支持Twitter的最近十条推文

**题目描述：** 设计一个支持Twitter的最近十条推文的数据结构。

**解题思路：** 可以使用双向链表和哈希表，双向链表存储最近的十条推文，哈希表用于存储推文和对应的节点。

**代码示例：**

```python
class Twitter:
    def __init__(self):
        self.follows = defaultdict(list)
        self.tweets = []  # 存储最近十条推文

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets.append((userId, tweetId))
        if len(self.tweets) > 10:
            self.tweets.pop(0)

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = []
        for user in self.follows[userId]:
            for tweet in self.tweets:
                if tweet[0] == user:
                    feed.append(tweet[1])
        return feed

    def follow(self, followerId: int, followeeId: int) -> None:
        self.follows[followerId].append(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        if followeeId in self.follows[followerId]:
            self.follows[followerId].remove(followeeId)
```

### 28. 反转链表

**题目描述：** 反转一个单链表。

**解题思路：** 可以使用递归或迭代的方法，遍历链表，将当前节点的指针指向前一个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

### 29. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序数组中的目标值。

**解题思路：** 可以使用二分查找的方法，确定目标值所在的范围。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 30. 链表中倒数第k个节点

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**解题思路：** 可以使用快慢指针的方法，先让快指针移动k步，然后快慢指针同时移动，当快指针到达链表末尾时，慢指针所指的节点即为倒数第k个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head: ListNode, k: int) -> ListNode:
    fast = slow = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    while fast:
        fast = fast.next
        slow = slow.next
    return slow
```

## 总结

本文汇总了2024年网易智慧家居校招的典型面试题和算法编程题，并给出了详细的解题思路和代码示例。希望这些题目和解答能够帮助大家更好地准备面试，取得优异的成绩。同时，也提醒大家在面试中注意逻辑清晰、代码规范，以及解题思路的简洁性。祝大家面试顺利！
<|less|>

