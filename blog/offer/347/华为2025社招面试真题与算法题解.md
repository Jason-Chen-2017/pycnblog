                 

### 华为2025社招面试真题与算法题解：典型面试题及算法题库

#### 题目一：最长公共子序列（LCS）

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找出它们的最长公共子序列。最长公共子序列是指两个序列中都出现，且同时出现的子序列长度最长。

**示例：**  
`s1 = "AGGTAB"`  
`s2 = "GXTXAYB"`  
最长公共子序列为 "GTAB"。

**解答：**

```go
func longestCommonSubsequence(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    result := ""
    i, j := m, n
    for dp[i][j] != 0 {
        if s1[i-1] == s2[j-1] {
            result += string(s1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return reverse(result)
}

func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 题目二：二分查找

**题目描述：** 在一个有序数组中找到目标值的位置，如果没有找到则返回 -1。

**示例：**  
`nums = [1, 3, 5, 6, 9]`  
`target = 5`  
返回 `2`。

**解答：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

#### 题目三：链表反转

**题目描述：** 反转一个单链表。

**示例：**  
输入链表：1 -> 2 -> 3 -> 4 -> 5  
输出链表：5 -> 4 -> 3 -> 2 -> 1

**解答：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    current := head
    for current != nil {
        next := current.Next
        current.Next = prev
        prev = current
        current = next
    }
    return prev
}

type ListNode struct {
    Val  int
    Next *ListNode
}
```

#### 题目四：最小堆

**题目描述：** 设计一个最小堆（Min Heap）数据结构，支持插入和提取最小元素操作。

**示例：**  
插入元素：5, 3, 7, 1, 9  
提取最小元素：1, 3, 7, 5, 9

**解答：**

```go
type MinHeap struct {
    heap []int
}

func NewMinHeap() *MinHeap {
    return &MinHeap{
        heap: []int{},
    }
}

func (m *MinHeap) Insert(value int) {
    m.heap = append(m.heap, value)
    m.heapifyUp(len(m.heap)-1)
}

func (m *MinHeap) Extract() int {
    if len(m.heap) == 0 {
        return -1
    }
    if len(m.heap) == 1 {
        result := m.heap[0]
        m.heap = m.heap[:0]
        return result
    }
    result := m.heap[0]
    m.heap[0] = m.heap[len(m.heap)-1]
    m.heap = m.heap[:len(m.heap)-1]
    m.heapifyDown(0)
    return result
}

func (m *MinHeap) heapifyUp(index int) {
    parent := (index - 1) / 2
    if m.heap[parent] > m.heap[index] {
        m.heap[parent], m.heap[index] = m.heap[index], m.heap[parent]
        m.heapifyUp(parent)
    }
}

func (m *MinHeap) heapifyDown(index int) {
    left := index*2 + 1
    right := index*2 + 2
    smallest := index
    if left < len(m.heap) && m.heap[left] < m.heap[smallest] {
        smallest = left
    }
    if right < len(m.heap) && m.heap[right] < m.heap[smallest] {
        smallest = right
    }
    if smallest != index {
        m.heap[smallest], m.heap[index] = m.heap[index], m.heap[smallest]
        m.heapifyDown(smallest)
    }
}
```

#### 题目五：双指针

**题目描述：** 使用双指针解决以下问题：

1. 寻找两个有序数组的中位数
2. 判断一个链表中是否有环
3. 删除链表中的节点

**解答：**

1. 寻找两个有序数组的中位数：

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i == m {
                minOfRight = nums2[j]
            } else if j == n {
                minOfRight = nums1[i]
            } else {
                minOfRight = min(nums1[i], nums2[j])
            }
            return (maxOfLeft + minOfRight) / 2.0
        }
    }
    return 0
}
```

2. 判断一个链表中是否有环：

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

3. 删除链表中的节点：

```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

#### 题目六：快速排序

**题目描述：** 实现快速排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)
    for _, num := range arr {
        if num < pivot {
            left = append(left, num)
        } else if num == pivot {
            middle = append(middle, num)
        } else {
            right = append(right, num)
        }
    }
    return append(quickSort(left), append(middle, quickSort(right)...)...)
}
```

#### 题目七：广度优先搜索（BFS）

**题目描述：** 实现一个广度优先搜索算法，用于求解迷宫问题。

**示例：**  
输入迷宫：

```
[[1, 0, 1, 1, 1],
 [1, 1, 0, 0, 1],
 [1, 1, 1, 1, 1],
 [0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1]]
```

起点为 `(0, 0)`，终点为 `(4, 4)`。

输出：路径为 `[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4]`。

**解答：**

```go
func findPath(maze [][]int, start, end [2]int) []int {
    rows, cols := len(maze), len(maze[0])
    q := []pair{
        {start[0], start[1]},
    }
    visited := make(map[string]bool)
    steps := make(map[string]int)
    steps[fmt.Sprintf("%d-%d", start[0], start[1])] = 0
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        row, col := cur.first, cur.second
        if row == end[0] && col == end[1] {
            path := []int{}
            for {
                path = append(path, cur)
                if cur == start {
                    break
                }
                cur = prev[cur]
            }
            reverse(path)
            return path
        }
        neighbors := []pair{
            {row - 1, col},
            {row + 1, col},
            {row, col - 1},
            {row, col + 1},
        }
        for _, neighbor := range neighbors {
            key := fmt.Sprintf("%d-%d", neighbor.first, neighbor.second)
            if !visited[key] && maze[neighbor.first][neighbor.second] == 0 {
                q = append(q, neighbor)
                visited[key] = true
                steps[key] = steps[cur] + 1
            }
        }
    }
    return nil
}

type pair struct {
    first int
    second int
}

func reverse(arr []pair) {
    for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {
        arr[i], arr[j] = arr[j], arr[i]
    }
}
```

#### 题目八：深度优先搜索（DFS）

**题目描述：** 实现一个深度优先搜索算法，用于求解迷宫问题。

**示例：**  
输入迷宫：

```
[[1, 0, 1, 1, 1],
 [1, 1, 0, 0, 1],
 [1, 1, 1, 1, 1],
 [0, 0, 0, 0, 0],
 [1, 1, 1, 1, 1]]
```

起点为 `(0, 0)`，终点为 `(4, 4)`。

输出：路径为 `[0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4]`。

**解答：**

```go
func findPath(maze [][]int, start, end [2]int) []int {
    rows, cols := len(maze), len(maze[0])
    visited := make(map[string]bool)
    path := []int{}
    dfs(0, 0, &path, maze, visited, start, end)
    if len(path) == 0 {
        return nil
    }
    reverse(path)
    return path
}

func dfs(row, col int, path *[]int, maze [][]int, visited map[string]bool, start, end [2]int) bool {
    if row == end[0] && col == end[1] {
        return true
    }
    if row < 0 || row >= len(maze) || col < 0 || col >= len(maze[0]) || maze[row][col] == 1 || visited[fmt.Sprintf("%d-%d", row, col)] {
        return false
    }
    visited[fmt.Sprintf("%d-%d", row, col)] = true
    *path = append(*path, [2]int{row, col})
    if dfs(row-1, col, path, maze, visited, start, end) {
        return true
    }
    if dfs(row+1, col, path, maze, visited, start, end) {
        return true
    }
    if dfs(row, col-1, path, maze, visited, start, end) {
        return true
    }
    if dfs(row, col+1, path, maze, visited, start, end) {
        return true
    }
    *path = (*path)[:len(*path)-1]
    return false
}

func reverse(arr []int) {
    for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {
        arr[i], arr[j] = arr[j], arr[i]
    }
}
```

#### 题目九：冒泡排序

**题目描述：** 实现冒泡排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

#### 题目十：插入排序

**题目描述：** 实现插入排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}
```

#### 题目十一：选择排序

**题目描述：** 实现选择排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}
```

#### 题目十二：归并排序

**题目描述：** 实现归并排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := []int{}
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

#### 题目十三：二分查找

**题目描述：** 在一个有序数组中查找一个目标值，如果找到则返回其索引，否则返回 -1。

**示例：**  
输入数组：`[1, 3, 5, 6, 9]`  
目标值：`5`  
输出：索引 `2`

**解答：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

#### 题目十四：KMP 算法

**题目描述：** 实现 KMP 算法，用于在一个字符串中查找子串。

**示例：**  
主串：`"ABABDABACDABABCABAB"`  
子串：`"ABABCABAB"`  
输出：起始索引 `2`

**解答：**

```go
func KMP(s, p string) int {
    n, m := len(s), len(p)
    lps := make([]int, m)
    j := -1
    i := 0
    for i < n {
        if s[i] == p[j+1] {
            j++
            i++
        }
        if j == m-1 {
            return i - j - 1
        } else if i < n && s[i] != p[j+1] {
            if j != -1 {
                j = lps[j]
            } else {
                i++
            }
        }
    }
    return -1
}
```

#### 题目十五：哈希表

**题目描述：** 使用哈希表实现一个字典。

**示例：**  
插入键值对：`{"name": "John", "age": 30, "city": "New York"}`  
查询键 `"age"`：返回 `30`

**解答：**

```go
func createMap() map[string]int {
    return make(map[string]int)
}

func putKey(map map[string]int, key string, value int) {
    map[key] = value
}

func getValue(map map[string]int, key string) int {
    return map[key]
}

func main() {
    map := createMap()
    putKey(map, "name", "John")
    putKey(map, "age", 30)
    putKey(map, "city", "New York")
    age := getValue(map, "age")
    fmt.Println(age) // 输出 30
}
```

#### 题目十六：斐波那契数列

**题目描述：** 使用动态规划实现斐波那契数列。

**示例：**  
输入：`5`  
输出：`5`

**解答：**

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }
    return b
}
```

#### 题目十七：二叉树遍历

**题目描述：** 实现二叉树的前序、中序和后序遍历。

**示例：**  
输入二叉树：

```
     1
    / \
   2   3
  / \
 4   5
```

输出：

```
前序遍历：1 2 4 5 3
中序遍历：4 2 5 1 3
后序遍历：4 5 2 3 1
```

**解答：**

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func preorderTraversal(root *TreeNode) []int {
    result := []int{}
    if root != nil {
        result = append(result, root.Val)
        result = append(result, preorderTraversal(root.Left)...)
        result = append(result, preorderTraversal(root.Right)...)
    }
    return result
}

func inorderTraversal(root *TreeNode) []int {
    result := []int{}
    if root != nil {
        result = append(result, inorderTraversal(root.Left)...)
        result = append(result, root.Val)
        result = append(result, inorderTraversal(root.Right)...)
    }
    return result
}

func postorderTraversal(root *TreeNode) []int {
    result := []int{}
    if root != nil {
        result = append(result, postorderTraversal(root.Left)...)
        result = append(result, postorderTraversal(root.Right)...)
        result = append(result, root.Val)
    }
    return result
}
```

#### 题目十八：图遍历

**题目描述：** 实现图的广度优先搜索（BFS）和深度优先搜索（DFS）。

**示例：**  
输入图：

```
0 --- 1 --- 2
|   |   |
3 --- 4 --- 5
```

输出：

```
广度优先搜索：0 1 2 3 4 5
深度优先搜索：0 1 2 4 3 5
```

**解答：**

```go
type Node struct {
    Val   int
    Neighbors []*Node
}

func BFS(graph *Node) []int {
    result := []int{}
    visited := make(map[int]bool)
    q := []int{graph.Val}
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        if !visited[node] {
            result = append(result, node)
            visited[node] = true
            for _, neighbor := range graph.Neighbors {
                q = append(q, neighbor.Val)
            }
        }
    }
    return result
}

func DFS(graph *Node) []int {
    result := []int{}
    visited := make(map[int]bool)
    dfs(graph, &result, visited)
    return result
}

func dfs(graph *Node, result *[]int, visited map[int]bool) {
    if graph != nil && !visited[graph.Val] {
        (*result) = append((*result), graph.Val)
        visited[graph.Val] = true
        for _, neighbor := range graph.Neighbors {
            dfs(neighbor, result, visited)
        }
    }
}
```

#### 题目十九：二叉搜索树

**题目描述：** 实现一个二叉搜索树（BST），支持插入、删除、查找等操作。

**示例：**  
插入节点：`20 10 30 5 15 25 35`  
删除节点：`20`  
查找节点：`15`

```
输入：5
输出：true
输入：10
输出：true
输入：15
输出：true
输入：20
输出：false
输入：25
输出：true
输入：30
输出：true
输入：35
输出：true
```

**解答：**

```go
type BST struct {
    Root *TreeNode
}

func (bst *BST) Insert(value int) {
    bst.Root = insert(bst.Root, value)
}

func (bst *BST) Delete(value int) {
    bst.Root = delete(bst.Root, value)
}

func (bst *BST) Find(value int) bool {
    return find(bst.Root, value)
}

func insert(node *TreeNode, value int) *TreeNode {
    if node == nil {
        return &TreeNode{Val: value}
    }
    if value < node.Val {
        node.Left = insert(node.Left, value)
    } else if value > node.Val {
        node.Right = insert(node.Right, value)
    }
    return node
}

func delete(node *TreeNode, value int) *TreeNode {
    if node == nil {
        return node
    }
    if value < node.Val {
        node.Left = delete(node.Left, value)
    } else if value > node.Val {
        node.Right = delete(node.Right, value)
    } else {
        if node.Left == nil && node.Right == nil {
            node = nil
        } else if node.Left == nil {
            node = node.Right
        } else if node.Right == nil {
            node = node.Left
        } else {
            minNode := findMin(node.Right)
            node.Val = minNode.Val
            node.Right = delete(node.Right, minNode.Val)
        }
    }
    return node
}

func findMin(node *TreeNode) *TreeNode {
    if node.Left == nil {
        return node
    }
    return findMin(node.Left)
}

func find(node *TreeNode, value int) bool {
    if node == nil {
        return false
    }
    if value < node.Val {
        return find(node.Left, value)
    } else if value > node.Val {
        return find(node.Right, value)
    }
    return true
}
```

#### 题目二十：快速幂

**题目描述：** 实现一个快速幂算法，用于计算 `a` 的 `n` 次方。

**示例：**  
输入：`a = 2, n = 10`  
输出：`1024`

**解答：**

```go
func quickPower(a, n int) int {
    result := 1
    for n > 0 {
        if n&1 == 1 {
            result *= a
        }
        a *= a
        n >>= 1
    }
    return result
}
```

#### 题目二十一：链表反转

**题目描述：** 反转一个单链表。

**示例：**  
输入链表：`1 -> 2 -> 3 -> 4 -> 5`  
输出链表：`5 -> 4 -> 3 -> 2 -> 1`

**解答：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    current := head
    for current != nil {
        next := current.Next
        current.Next = prev
        prev = current
        current = next
    }
    return prev
}
```

#### 题目二十二：最长公共前缀

**题目描述：** 找出多个字符串的最长公共前缀。

**示例：**  
输入字符串数组：`["hello", "he", "her", "here"]`  
输出：`"he"`

**解答：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, str := range strs[1:] {
        for i, v := range str {
            if i < len(prefix) && v != prefix[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}
```

#### 题目二十三：删除链表的节点

**题目描述：** 删除链表中某个节点。

**示例：**  
输入链表：`1 -> 2 -> 3 -> 4 -> 5`  
删除节点：`3`  
输出链表：`1 -> 2 -> 4 -> 5`

**解答：**

```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

#### 题目二十四：最小栈

**题目描述：** 设计一个最小栈，支持入栈、出栈和获取最小元素操作。

**示例：**  
入栈：`5 3 4 2 1`  
出栈：`1 2 4 3 5`  
获取最小元素：`3 2 4 4`

**解答：**

```go
type MinStack struct {
    Stack []int
    MinStack []int
}

func Constructor() MinStack {
    return MinStack{
        Stack: []int{},
        MinStack: []int{},
    }
}

func (this *MinStack) Push(x int) {
    this.Stack = append(this.Stack, x)
    if len(this.MinStack) == 0 || x <= this.MinStack[len(this.MinStack)-1] {
        this.MinStack = append(this.MinStack, x)
    }
}

func (this *MinStack) Pop() {
    if this.Stack[len(this.Stack)-1] == this.MinStack[len(this.MinStack)-1] {
        this.MinStack = this.MinStack[:len(this.MinStack)-1]
    }
    this.Stack = this.Stack[:len(this.Stack)-1]
}

func (this *MinStack) Top() int {
    return this.Stack[len(this.Stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.MinStack[len(this.MinStack)-1]
}
```

#### 题目二十五：快速排序

**题目描述：** 实现快速排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    right := make([]int, 0)
    middle := make([]int, 0)
    for _, num := range arr {
        if num < pivot {
            left = append(left, num)
        } else if num == pivot {
            middle = append(middle, num)
        } else {
            right = append(right, num)
        }
    }
    return append(quickSort(left), append(middle, quickSort(right)...)...)
}
```

#### 题目二十六：归并排序

**题目描述：** 实现归并排序算法。

**示例：**  
输入数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5]`  
输出排序后的数组：`[1, 1, 2, 3, 4, 5, 5, 6, 9]`

**解答：**

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := []int{}
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

#### 题目二十七：合并两个有序链表

**题目描述：** 合并两个有序链表。

**示例：**  
输入链表1：`1 -> 2 -> 4`  
输入链表2：`1 -> 3 -> 4`  
输出链表：`1 -> 1 -> 2 -> 3 -> 4 -> 4`

**解答：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

#### 题目二十八：LRU 缓存

**题目描述：** 实现一个 LRU（Least Recently Used）缓存。

**示例：**  
初始化缓存容量：`2`  
操作：`["LRUCache", "get", "put", "get", "put", "get"]`, `[[2], [1], [1, 4], [1], [2, 6], [1]]`  
输出：`[null, -1, null, 4, null, 6]`

**解答：**

```go
type LRUCache struct {
    capacity int
    cache map[int]*Node
    head, tail *Node
}

func Constructor(capacity int) LRUCache {
    cache := make(map[int]*Node)
    head, tail := &Node{}, &Node{}
    head.Next = tail
    tail.Next = head
    return LRUCache{capacity: capacity, cache: cache, head: head, tail: tail}
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.Val
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.Val = value
        this.moveToHead(node)
    } else {
        newNode := &Node{key, value}
        this.cache[key] = newNode
        this.addToHead(newNode)
        if len(this.cache) > this.capacity {
            oldest := this.tail.Next
            delete(this.cache, oldest.key)
            this.removeNode(oldest)
        }
    }
}

func (this *LRUCache) moveToHead(node *Node) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeNode(node *Node) {
    nodePrev := node.Prev
    nodeNext := node.Next
    nodePrev.Next = nodeNext
    nodeNext.Prev = nodePrev
}

func (this *LRUCache) addToHead(node *Node) {
    node.Prev = this.head
    node.Next = this.head.Next
    this.head.Next.Prev = node
    this.head.Next = node
}

type Node struct {
    key, Val int
    Prev, Next *Node
}
```

#### 题目二十九：最长公共子序列

**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**示例：**  
字符串1：`"AGGTAB"`  
字符串2：`"GXTXAYB"`  
输出：`"GTAB"`

**解答：**

```go
func longestCommonSubsequence(s1, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    result := ""
    i, j := m, n
    for dp[i][j] != 0 {
        if s1[i-1] == s2[j-1] {
            result += string(s1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return reverse(result)
}

func reverse(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 题目三十：打家劫舍

**题目描述：** 你是一个小偷，面对一排房屋，你需要选择一些房屋进行盗窃，但不能连续盗窃。求你能盗窃到的最大金额。

**示例：**  
输入：`[1, 2, 3, 1]`  
输出：`4`

**解答：**

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}
```

### 总结

以上我们详细解析了华为2025社招面试真题与算法题解中的30个典型面试题和算法题，包括数组、链表、字符串、栈、队列、排序、查找、图、二叉树等常见数据结构和算法。每一道题目都给出了详细的解析和代码示例，希望能帮助大家更好地理解和掌握面试题和解题思路。在备战面试的过程中，多刷题、多总结、多思考是非常重要的，希望这些题目的解析能为大家的面试之路提供帮助。祝大家面试顺利，成功拿到心仪的offer！

