                 

### 2024 华为智能工业控制校招面试真题汇总及其解答

#### 1. 算法编程题：二分查找

**题目：** 给定一个排序数组和一个目标值，找出数组中目标值的索引。如果没有找到，返回-1。

```python
def search(nums: List[int], target: int) -> int:
    ...
```

**答案：** 可以使用二分查找算法来解决该问题。

```python
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是数组的长度。通过不断将搜索范围缩小一半，可以在较短时间内找到目标值。

#### 2. 算法编程题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

```python
def longestCommonSubsequence(s1: str, s2: str) -> str:
    ...
```

**答案：** 可以使用动态规划来求解最长公共子序列。

```python
def longestCommonSubsequence(s1: str, s2: str) -> str:
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return ''.join([s1[i - 1] for i, j in enumerate(dp[-1]) if dp[-1][j] == dp[-1][j - 1]])
```

**解析：** 该算法的时间复杂度为O(mn)，其中m和n分别是两个字符串的长度。通过构建一个动态规划表格，可以找出最长公共子序列。

#### 3. 算法编程题：环形数组的最小元素

**题目：** 给定一个循环旋转的数组，找到其最小元素。

```python
def findMin(nums: List[int]) -> int:
    ...
```

**答案：** 可以使用二分查找算法来解决这个问题。

```python
def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是数组的长度。通过不断将搜索范围缩小一半，可以在较短时间内找到最小元素。

#### 4. 数据结构与算法题：并查集

**题目：** 使用并查集实现合并操作，并判断两个元素是否在同一集合中。

```python
class UnionFind:
    def __init__(self, n: int):
        ...

    def find(self, x: int) -> int:
        ...

    def union(self, a: int, b: int) -> None:
        ...
```

**答案：** 使用路径压缩和按秩合并的方法来优化并查集。

```python
class UnionFind:
    def __init__(self, n: int):
        self.p = list(range(n))

    def find(self, x: int) -> int:
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a: int, b: int) -> None:
        pa, pb = self.find(a), self.find(b)
        if pa != pb:
            if len(self.p[pa]) < len(self.p[pb]):
                self.p[pa] = pb
            else:
                self.p[pb] = pa
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是元素的数量。通过路径压缩和按秩合并，可以有效地减少查找和合并操作的时间。

#### 5. 算法编程题：最长连续序列

**题目：** 给定一个整数数组，找出最长连续序列的长度。

```python
def longestConsecutive(nums: List[int]) -> int:
    ...
```

**答案：** 可以使用哈希表来存储每个元素的前驱和后继，从而找到最长连续序列。

```python
def longestConsecutive(nums: List[int]) -> int:
    if not nums:
        return 0
    nums_set = set(nums)
    max_len = 1
    for num in nums:
        if num - 1 not in nums_set:
            curr_len = 1
            while num + 1 in nums_set:
                num += 1
                curr_len += 1
            max_len = max(max_len, curr_len)
    return max_len
```

**解析：** 该算法的时间复杂度为O(n)，其中n是数组的长度。通过哈希表存储元素的前驱和后继，可以快速地找到最长连续序列。

#### 6. 算法编程题：最长公共前缀

**题目：** 给定一个字符串数组，找出它们的公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    ...
```

**答案：** 可以通过依次比较字符串的前缀来找到最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if not s.startswith(prefix):
                return prefix
        prefix += c
    return prefix
```

**解析：** 该算法的时间复杂度为O(mn)，其中m是字符串的长度，n是字符串的数量。通过依次比较字符串的前缀，可以找到最长公共前缀。

#### 7. 算法编程题：两数之和

**题目：** 给定一个整数数组和一个目标值，找出两个数使得它们的和等于目标值。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    ...
```

**答案：** 可以使用哈希表来存储已遍历过的元素和其索引，从而找到两个数之和等于目标值的元素。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    nums_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in nums_map:
            return [nums_map[complement], i]
        nums_map[num] = i
    return []
```

**解析：** 该算法的时间复杂度为O(n)，其中n是数组的长度。通过哈希表存储已遍历过的元素和其索引，可以快速找到两个数之和等于目标值的元素。

#### 8. 算法编程题：有效的括号

**题目：** 给定一个字符串，判断它是否是有效的括号。

```python
def isValid(s: str) -> bool:
    ...
```

**答案：** 可以使用栈来模拟括号的匹配。

```python
def isValid(s: str) -> bool:
    stack = []
    for c in s:
        if c == '(' or c == '{' or c == '[':
            stack.append(c)
        elif c == ')' or c == '}' or c == ']':
            if not stack:
                return False
            top = stack.pop()
            if (c == ')' and top != '(') or (c == '}' and top != '{') or (c == ']' and top != '['):
                return False
    return not stack
```

**解析：** 该算法的时间复杂度为O(n)，其中n是字符串的长度。通过使用栈来模拟括号的匹配，可以判断字符串是否是有效的括号。

#### 9. 算法编程题：旋转图像

**题目：** 给定一个二维数组，旋转90度。

```python
def rotate(matrix: List[List[int]]) -> None:
    ...
```

**答案：** 可以通过原地旋转来减少空间复杂度。

```python
def rotate(matrix: List[List[int]]) -> None:
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```

**解析：** 该算法的时间复杂度为O(n^2)，其中n是二维数组的长度。通过依次旋转数组的四个角，可以原地旋转二维数组。

#### 10. 算法编程题：合并两个有序链表

**题目：** 给定两个有序链表，合并它们为一个新的有序链表。

```python
def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    ...
```

**答案：** 可以使用递归或迭代的方法来合并两个有序链表。

递归方法：

```python
def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

迭代方法：

```python
def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 该算法的时间复杂度为O(n)，其中n是两个链表的长度。通过比较两个链表的元素，可以将它们合并为一个有序链表。

#### 11. 算法编程题：爬楼梯

**题目：** 给定一个正整数n，一个人每次可以爬1个或2个台阶，求有多少种不同的方法可以爬上n个台阶。

```python
def climbStairs(n: int) -> int:
    ...
```

**答案：** 可以使用动态规划的方法来求解。

```python
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

**解析：** 该算法的时间复杂度为O(n)，其中n是楼梯的数量。通过动态规划表格，可以计算出爬楼梯的不同方法数量。

#### 12. 算法编程题：斐波那契数列

**题目：** 给定一个正整数n，求斐波那契数列的第n项。

```python
def fib(n: int) -> int:
    ...
```

**答案：** 可以使用递归或迭代的方法来求解斐波那契数列。

递归方法：

```python
def fib(n: int) -> int:
    if n <= 2:
        return 1
    return fib(n - 1) + fib(n - 2)
```

迭代方法：

```python
def fib(n: int) -> int:
    a, b = 0, 1
    for _ in range(n - 1):
        a, b = b, a + b
    return b
```

**解析：** 该算法的时间复杂度为O(n)，其中n是斐波那契数列的项数。通过递归或迭代，可以计算出斐波那契数列的第n项。

#### 13. 算法编程题：最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

```python
def longestCommonSubstring(s1: str, s2: str) -> str:
    ...
```

**答案：** 可以使用动态规划的方法来求解最长公共子串。

```python
def longestCommonSubstring(s1: str, s2: str) -> str:
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_idx = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_idx = i
            else:
                dp[i][j] = 0
    return s1[end_idx - max_len: end_idx]
```

**解析：** 该算法的时间复杂度为O(mn)，其中m和n分别是两个字符串的长度。通过构建一个动态规划表格，可以找出最长公共子串。

#### 14. 算法编程题：合并两个有序数组

**题目：** 给定两个有序数组，合并它们为一个有序数组。

```python
def mergeSortedArray(nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    ...
```

**答案：** 可以使用双指针的方法来合并两个有序数组。

```python
def mergeSortedArray(nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    p1, p2 = m - 1, n - 1
    p = m + n - 1
    while p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[p] = nums1[p1]
            p1 -= 1
        else:
            nums1[p] = nums2[p2]
            p2 -= 1
        p -= 1
    while p2 >= 0:
        nums1[p] = nums2[p2]
        p2 -= 1
        p -= 1
```

**解析：** 该算法的时间复杂度为O(m + n)，其中m和n分别是两个数组的长度。通过双指针的方法，可以合并两个有序数组。

#### 15. 算法编程题：最长公共前缀

**题目：** 给定一个字符串数组，找出它们的最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    ...
```

**答案：** 可以使用垂直扫描的方法来找出最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix
```

**解析：** 该算法的时间复杂度为O(n * m)，其中n是字符串的数量，m是字符串的平均长度。通过垂直扫描的方法，可以找出最长公共前缀。

#### 16. 算法编程题：最长连续序列

**题目：** 给定一个整数数组，找出最长连续序列的长度。

```python
def longestConsecutive(nums: List[int]) -> int:
    ...
```

**答案：** 可以使用哈希表的方法来求解最长连续序列。

```python
def longestConsecutive(nums: List[int]) -> int:
    if not nums:
        return 0
    nums_set = set(nums)
    max_len = 1
    for num in nums:
        if num - 1 not in nums_set:
            curr_len = 1
            while num + 1 in nums_set:
                num += 1
                curr_len += 1
            max_len = max(max_len, curr_len)
    return max_len
```

**解析：** 该算法的时间复杂度为O(n)，其中n是数组的长度。通过哈希表存储元素，可以快速找到最长连续序列。

#### 17. 算法编程题：环形数组的最小元素

**题目：** 给定一个循环旋转的数组，找出其最小元素。

```python
def findMin(nums: List[int]) -> int:
    ...
```

**答案：** 可以使用二分查找的方法来找出环形数组的最小元素。

```python
def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是数组的长度。通过二分查找，可以快速找到环形数组的最小元素。

#### 18. 算法编程题：有效的括号

**题目：** 给定一个字符串，判断它是否是有效的括号。

```python
def isValid(s: str) -> bool:
    ...
```

**答案：** 可以使用栈的方法来模拟括号的匹配。

```python
def isValid(s: str) -> bool:
    stack = []
    for c in s:
        if c in '({[':
            stack.append(c)
        elif not stack:
            return False
        elif c == ')' and stack[-1] != '(':
            return False
        elif c == '}' and stack[-1] != '{':
            return False
        elif c == ']' and stack[-1] != '[':
            return False
        else:
            stack.pop()
    return not stack
```

**解析：** 该算法的时间复杂度为O(n)，其中n是字符串的长度。通过使用栈来模拟括号的匹配，可以判断字符串是否是有效的括号。

#### 19. 算法编程题：最大子序和

**题目：** 给定一个整数数组，找出连续子序列的最大和。

```python
def maxSubArray(nums: List[int]) -> int:
    ...
```

**答案：** 可以使用动态规划的方法来求解最大子序和。

```python
def maxSubArray(nums: List[int]) -> int:
    max_sum = nums[0]
    curr_sum = nums[0]
    for num in nums[1:]:
        curr_sum = max(num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)
    return max_sum
```

**解析：** 该算法的时间复杂度为O(n)，其中n是数组的长度。通过动态规划，可以求解最大子序和。

#### 20. 算法编程题：两数之和

**题目：** 给定一个整数数组和一个目标值，找出两个数使得它们的和等于目标值。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    ...
```

**答案：** 可以使用哈希表的方法来求解两数之和。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    nums_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in nums_map:
            return [nums_map[complement], i]
        nums_map[num] = i
    return []
```

**解析：** 该算法的时间复杂度为O(n)，其中n是数组的长度。通过哈希表存储已遍历过的元素和其索引，可以快速找到两个数之和等于目标值的元素。

#### 21. 算法编程题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

```python
def longestCommonSubsequence(s1: str, s2: str) -> str:
    ...
```

**答案：** 可以使用动态规划的方法来求解最长公共子序列。

```python
def longestCommonSubsequence(s1: str, s2: str) -> str:
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return ''.join([s1[i - 1] for i, j in enumerate(dp[-1]) if dp[-1][j] == dp[-1][j - 1]])
```

**解析：** 该算法的时间复杂度为O(mn)，其中m和n分别是两个字符串的长度。通过构建一个动态规划表格，可以找出最长公共子序列。

#### 22. 算法编程题：合并两个有序链表

**题目：** 给定两个有序链表，合并它们为一个新的有序链表。

```python
def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    ...
```

**答案：** 可以使用递归或迭代的方法来合并两个有序链表。

递归方法：

```python
def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

迭代方法：

```python
def mergeTwoLists(l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 该算法的时间复杂度为O(n)，其中n是两个链表的长度。通过比较两个链表的元素，可以将它们合并为一个有序链表。

#### 23. 算法编程题：环形链表

**题目：** 给定一个链表，判断它是否是环形链表。

```python
def hasCycle(head: Optional[ListNode]) -> bool:
    ...
```

**答案：** 可以使用快慢指针的方法来判断链表是否是环形链表。

```python
def hasCycle(head: Optional[ListNode]) -> bool:
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**解析：** 该算法的时间复杂度为O(n)，其中n是链表的长度。通过快慢指针的方法，可以判断链表是否是环形链表。

#### 24. 算法编程题：排序链表

**题目：** 给定一个链表，将其按升序排序。

```python
def sortList(head: Optional[ListNode]) -> Optional[ListNode]:
    ...
```

**答案：** 可以使用归并排序的方法来排序链表。

```python
def sortList(head: Optional[ListNode]) -> Optional[ListNode]:
    if not head or not head.next:
        return head
    mid = getMid(head)
    next_to_mid = mid.next
    mid.next = None
    left = sortList(head)
    right = sortList(next_to_mid)
    return merge(left, right)
```

**解析：** 该算法的时间复杂度为O(nlogn)，其中n是链表的长度。通过归并排序，可以排序链表。

#### 25. 算法编程题：逆序数

**题目：** 给定一个数组，计算数组中的逆序对数量。

```python
def reversePairs(nums: List[int]) -> int:
    ...
```

**答案：** 可以使用归并排序的方法来计算逆序对数量。

```python
def reversePairs(nums: List[int]) -> int:
    def merge(left: List[int], right: List[int]) -> List[int]:
        i, j = 0, 0
        res = []
        cnt = 0
        while i < len(left) and j < len(right):
            if left[i] > right[j]:
                cnt += len(right) - j
                res.append(right[j])
                j += 1
            else:
                res.append(left[i])
                i += 1
        res.extend(left[i:])
        res.extend(right[j:])
        return res

    def merge_sort(nums: List[int]) -> List[int]:
        if len(nums) <= 1:
            return nums
        mid = len(nums) // 2
        left = merge_sort(nums[:mid])
        right = merge_sort(nums[mid:])
        return merge(left, right)

    return merge_sort(nums)

```

**解析：** 该算法的时间复杂度为O(nlogn)，其中n是数组的长度。通过归并排序，可以计算逆序对数量。

#### 26. 算法编程题：二进制表示中质数个数

**题目：** 给定一个正整数，计算其二进制表示中质数位数的个数。

```python
def countPrimeSetBits(num: int) -> int:
    ...
```

**答案：** 可以使用质数判定和位运算的方法来计算二进制表示中质数位数的个数。

```python
def countPrimeSetBits(num: int) -> int:
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    count = 0
    while num > 0:
        bit = num & 1
        if bit in primes:
            count += 1
        num >>= 1
    return count
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是输入的正整数。通过位运算和质数判定，可以计算二进制表示中质数位数的个数。

#### 27. 算法编程题：二进制表示中质数个数 II

**题目：** 给定一个正整数，计算其二进制表示中质数位数的个数。

```python
def countPrimeSetBits2(num: int) -> int:
    ...
```

**答案：** 可以使用位运算和质数判定来优化二进制表示中质数位数的计算。

```python
def countPrimeSetBits2(num: int) -> int:
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
    count = 0
    while num > 0:
        bit = num & 1
        if bit in primes:
            count += 1
        num >>= 1
    return count
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是输入的正整数。通过位运算和质数判定，可以计算二进制表示中质数位数的个数。这里使用了质数列表，避免了重复的质数判定。

#### 28. 算法编程题：最长公共前缀

**题目：** 给定一个字符串数组，找出它们的最长公共前缀。

```python
def longestCommonPrefix strs: List[str]) -> str:
    ...
```

**答案：** 可以使用垂直扫描的方法来找出最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        char = strs[0][i]
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return prefix
        prefix += char
    return prefix
```

**解析：** 该算法的时间复杂度为O(n * m)，其中n是字符串的数量，m是字符串的平均长度。通过垂直扫描的方法，可以找出最长公共前缀。

#### 29. 算法编程题：合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

```python
def merge(intervals: List[List[int]]) -> List[List[int]]:
    ...
```

**答案：** 可以使用排序和合并区间的方法来合并所有重叠的区间。

```python
def merge(intervals: List[List[int]]) -> List[List[int]]:
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        if ans[-1][1] >= interval[0]:
            ans[-1][1] = max(ans[-1][1], interval[1])
        else:
            ans.append(interval)
    return ans
```

**解析：** 该算法的时间复杂度为O(nlogn)，其中n是区间的数量。通过排序和合并区间，可以合并所有重叠的区间。

#### 30. 算法编程题：搜索旋转排序数组

**题目：** 给定一个旋转排序的数组和一个目标值，找出数组中的目标值，并返回其索引。

```python
def search(nums: List[int], target: int) -> int:
    ...
```

**答案：** 可以使用二分查找的方法来搜索旋转排序数组中的目标值。

```python
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[left] <= nums[mid]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 该算法的时间复杂度为O(log n)，其中n是数组的长度。通过二分查找，可以搜索旋转排序数组中的目标值。

