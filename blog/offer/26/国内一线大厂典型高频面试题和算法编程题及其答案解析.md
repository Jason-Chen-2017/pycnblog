
以下是根据您的要求整理的20道国内一线大厂典型高频面试题和算法编程题及其答案解析：

## 1. 阿里巴巴 - 数据结构与算法

### 1.1 如何在排序数组中查找元素的第一个和最后一个位置？

**题目：** 在排序数组中查找一个元素的第一和最后一个位置。

**答案：** 

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        first_pos, last_pos = -1, -1
        
        # 查找第一个位置
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                first_pos = mid
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        # 查找最后一个位置
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                last_pos = mid
                left = mid + 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1

        return [first_pos, last_pos]
```

**解析：** 使用二分查找法分别查找第一个和最后一个位置。在找到目标元素时，向左或向右继续查找以确保找到第一个和最后一个位置。

## 2. 百度 - 算法与数据结构

### 2.1 设计一个LRU缓存机制

**题目：** 设计一个LRU（Least Recently Used）缓存机制。

**答案：** 

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**解析：** 使用OrderedDict来实现LRU缓存。当获取或插入元素时，将其移动到字典末尾以表示最近使用。当缓存大小超过容量时，删除字典中的第一个元素。

## 3. 腾讯 - 算法与编程

### 3.1 判断字符串是否有效的括号序列

**题目：** 判断一个字符串是否为有效的括号序列。

**答案：** 

```python
from collections import Counter

def isValid(s: str) -> bool:
    count = Counter(s)
    if count['{'] != count['}'] or count['('] != count[')'] or count['['] != count[']']:
        return False
    return True
```

**解析：** 使用计数器统计各类括号的数量，如果数量不相等，则返回False。否则，返回True。

## 4. 字节跳动 - 算法与数据结构

### 4.1 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：** 

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 创建一个虚拟头节点，然后逐个比较两个链表的节点，将较小的节点添加到新链表中。

## 5. 拼多多 - 算法与编程

### 5.1 实现字符串中的第一个唯一字符

**题目：** 实现一个函数，返回字符串中的第一个唯一字符。

**答案：** 

```python
def firstUniqChar(s: str) -> int:
    count = Counter(s)
    for i, c in enumerate(s):
        if count[c] == 1:
            return i
    return -1
```

**解析：** 使用计数器统计字符串中每个字符的出现次数，然后遍历字符串，找到第一个出现次数为1的字符。

## 6. 京东 - 算法与数据结构

### 6.1 判断二叉树是否是平衡二叉树

**题目：** 判断一个二叉树是否是平衡二叉树。

**答案：** 

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(root):
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            if abs(left - right) > 1:
                return -1
            return max(left, right) + 1

        return dfs(root) != -1
```

**解析：** 使用递归遍历二叉树，计算每个子树的高度，并检查是否平衡。

## 7. 美团 - 算法与数据结构

### 7.1 设计一个具有最小时间复杂度的LRU缓存

**题目：** 设计一个时间复杂度尽可能低的LRU缓存。

**答案：** 

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**解析：** 使用OrderedDict实现LRU缓存。获取或插入元素时，将其移动到字典末尾。

## 8. 快手 - 算法与编程

### 8.1 判断一个数是否是回文数

**题目：** 判断一个整数是否是回文数。

**答案：** 

```python
def isPalindrome(x: int) -> bool:
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    reversed_num = 0
    while x > reversed_num:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
    return x == reversed_num or x == reversed_num // 10
```

**解析：** 将整数反转并与原始整数进行比较。注意处理负数和末尾为0的整数。

## 9. 滴滴 - 算法与数据结构

### 9.1 设计一个带有速率限制的类

**题目：** 设计一个类，实现一个带速率限制的函数。

**答案：** 

```python
class RateLimiter:
    def __init__(self, rate: int):
        self.rate = rate
        self.tokens = rate
        self.last_updated = time.time()

    def acquire(self):
        now = time.time()
        elapsed_time = now - self.last_updated
        self.tokens += int(elapsed_time / 1)  # 时间窗口内增加token
        self.last_updated = now
        if self.tokens < 1:
            return False
        self.tokens -= 1
        return True
```

**解析：** 使用令牌桶算法实现速率限制。每秒增加指定数量的令牌，消耗一个令牌。

## 10. 小红书 - 算法与数据结构

### 10.1 设计一个堆

**题目：** 设计一个最大堆。

**答案：**

```python
class MaxHeap:
    def __init__(self):
        self.heap = []

    def parent(self, i):
        return (i - 1) // 2

    def left_child(self, i):
        return 2 * i + 1

    def right_child(self, i):
        return 2 * i + 2

    def heapify(self, i):
        l = self.left_child(i)
        r = self.right_child(i)
        largest = i
        if l < len(self.heap) and self.heap[l] > self.heap[i]:
            largest = l
        if r < len(self.heap) and self.heap[r] > self.heap[largest]:
            largest = r
        if largest != i:
            self.heap[i], self.heap[largest] = self.heap[largest], self.heap[i]
            self.heapify(largest)

    def insert(self, key):
        self.heap.append(key)
        i = len(self.heap) - 1
        while i != 0 and self.heap[self.parent(i)] < self.heap[i]:
            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]
            i = self.parent(i)

    def extract_max(self):
        if len(self.heap) == 0:
            return None
        root = self.heap[0]
        self.heap[0] = self.heap.pop()
        self.heapify(0)
        return root
```

**解析：** 使用数组实现最大堆。插入元素时，从底部开始向上调整；提取最大元素时，从顶部开始向下调整。

## 11. 蚂蚁支付宝 - 算法与编程

### 11.1 判断二进制数是否是回文

**题目：** 判断一个二进制数是否是回文数。

**答案：**

```python
def is_palindrome(n: int) -> bool:
    original = n
    reversed_n = 0
    while n:
        reversed_n = reversed_n * 2 + n % 2
        n //= 2
    return original == reversed_n or original == reversed_n // 10
```

**解析：** 将二进制数反转，并与原始数进行比较。注意处理特殊情况。

## 12. 阿里巴巴 - 算法与数据结构

### 12.1 设计一个双向链表

**题目：** 设计一个双向链表。

**答案：**

```python
class Node:
    def __init__(self, val=0, prev=None, next=None):
        self.val = val
        self.prev = prev
        self.next = next

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, val):
        new_node = Node(val)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def delete(self, val):
        current = self.head
        while current:
            if current.val == val:
                if current.prev:
                    current.prev.next = current.next
                if current.next:
                    current.next.prev = current.prev
                if current == self.head:
                    self.head = current.next
                if current == self.tail:
                    self.tail = current.prev
                return
            current = current.next

    def display(self):
        current = self.head
        while current:
            print(current.val, end=' ')
            current = current.next
        print()
```

**解析：** 设计一个双向链表，包括插入、删除和显示操作。

## 13. 百度 - 算法与编程

### 13.1 实现一个快速排序算法

**题目：** 实现快速排序算法。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))
```

**解析：** 快速排序是一种分治算法，选择一个基准元素，将数组划分为小于和大于基准元素的子数组，然后递归地对子数组进行排序。

## 14. 腾讯 - 数据结构与算法

### 14.1 实现一个二分查找算法

**题目：** 实现一个二分查找算法。

**答案：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
print(binary_search(arr, target))
```

**解析：** 二分查找是一种在有序数组中查找特定元素的算法。通过不断将查找范围缩小一半，提高查找效率。

## 15. 字节跳动 - 算法与编程

### 15.1 实现一个堆排序算法

**题目：** 实现堆排序算法。

**答案：**

```python
def heapify(arr, n, i):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[i] < arr[l]:
        largest = l

    if r < n and arr[largest] < arr[r]:
        largest = r

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("Sorted array is:", arr)
```

**解析：** 堆排序是一种基于堆的数据结构排序算法。首先将数组转换为最大堆，然后交换堆顶元素与最后一个元素，调整堆结构，重复此过程。

## 16. 拼多多 - 算法与编程

### 16.1 实现一个快速幂算法

**题目：** 实现一个快速幂算法。

**答案：**

```python
def quick_power(x, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        return quick_power(x * x, n // 2)
    return x * quick_power(x * x, n // 2)

x = 2
n = 8
print(quick_power(x, n))
```

**解析：** 快速幂算法利用了指数的二进制表示，将指数递减为0，通过递归计算底数的幂。

## 17. 京东 - 数据结构与算法

### 17.1 实现一个散列表

**题目：** 实现一个散列表。

**答案：**

```python
class HashTable:
    def __init__(self, size=100):
        self.size = size
        self.table = [None] * size

    def _hash(self, key):
        return key % self.size

    def put(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (k, _) in enumerate(self.table[index]):
                if k == key:
                    self.table[index][i] = (key, value)
                    return
            self.table[index].append((key, value))

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

# Example usage
hash_table = HashTable()
hash_table.put("apple", 1)
hash_table.put("banana", 2)
hash_table.put("orange", 3)
print(hash_table.get("apple"))  # Output: 1
print(hash_table.get("banana"))  # Output: 2
print(hash_table.get("orange"))  # Output: 3
```

**解析：** 使用数组实现散列表，通过哈希函数计算索引，处理冲突。`put` 方法用于插入键值对，`get` 方法用于根据键获取值。

## 18. 美团 - 数据结构与算法

### 18.1 实现一个队列

**题目：** 使用链表实现一个队列。

**答案：**

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None

    def is_empty(self):
        return self.front is None

    def enqueue(self, value):
        new_node = Node(value)
        if self.is_empty():
            self.front = self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node

    def dequeue(self):
        if self.is_empty():
            return None
        temp = self.front
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return temp.value

# Example usage
queue = Queue()
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue.dequeue())  # Output: 1
print(queue.dequeue())  # Output: 2
print(queue.dequeue())  # Output: 3
```

**解析：** 使用链表实现队列。`enqueue` 方法在队列末尾添加元素，`dequeue` 方法删除队列头部的元素。

## 19. 快手 - 数据结构与算法

### 19.1 实现一个栈

**题目：** 使用链表实现一个栈。

**答案：**

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class Stack:
    def __init__(self):
        self.top = None

    def is_empty(self):
        return self.top is None

    def push(self, value):
        new_node = Node(value)
        new_node.next = self.top
        self.top = new_node

    def pop(self):
        if self.is_empty():
            return None
        temp = self.top
        self.top = self.top.next
        return temp.value

# Example usage
stack = Stack()
stack.push(1)
stack.push(2)
stack.push(3)
print(stack.pop())  # Output: 3
print(stack.pop())  # Output: 2
print(stack.pop())  # Output: 1
```

**解析：** 使用链表实现栈。`push` 方法在栈顶添加元素，`pop` 方法删除栈顶的元素。

## 20. 滴滴 - 数据结构与算法

### 20.1 实现一个优先队列

**题目：** 使用堆实现一个优先队列。

**答案：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def is_empty(self):
        return len(self.heap) == 0

    def push(self, item, priority):
        heapq.heappush(self.heap, (priority, item))

    def pop(self):
        if self.is_empty():
            return None
        return heapq.heappop(self.heap)[1]

# Example usage
priority_queue = PriorityQueue()
priority_queue.push("task1", 1)
priority_queue.push("task2", 2)
priority_queue.push("task3", 3)
print(priority_queue.pop())  # Output: task1
print(priority_queue.pop())  # Output: task2
print(priority_queue.pop())  # Output: task3
```

**解析：** 使用堆实现优先队列。`push` 方法插入元素，`pop` 方法根据优先级删除元素。

## 21. 蚂蚁支付宝 - 数据结构与算法

### 21.1 实现一个并查集

**题目：** 实现一个并查集。

**答案：**

```python
class UnionFind:
    def __init__(self, size):
        self.parent = list(range(size))
        self.size = [1] * size

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]
```

**解析：** 并查集是一种用于处理连接性问题的数据结构。`find` 方法用于找到元素所在集合的代表元素，`union` 方法用于合并两个集合。

## 22. 阿里巴巴 - 算法与编程

### 22.1 求两个数组的交集

**题目：** 给定两个整数数组 nums1 和 nums2 ，返回 演算法它们的交集 。每个元素最多出现在结果数组中两次。

**答案：**

```python
def intersection(nums1, nums2):
    counts = Counter(nums1)
    ans = []
    for x in nums2:
        if counts[x] > 0:
            ans.append(x)
            counts[x] -= 1
    return ans

# Example usage
nums1 = [1, 2, 2, 1]
nums2 = [2, 2]
print(intersection(nums1, nums2))  # Output: [2, 2]
```

**解析：** 使用哈希表统计第一个数组中每个元素的出现次数，然后遍历第二个数组，检查元素是否存在于哈希表中，并添加到结果数组中。

## 23. 百度 - 算法与编程

### 23.1 实现一个有序链表

**题目：** 实现一个有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class SortedLinkedList:
    def __init__(self):
        self.head = None

    def insert(self, val):
        new_node = ListNode(val)
        if not self.head or val < self.head.val:
            new_node.next = self.head
            self.head = new_node
        else:
            current = self.head
            while current.next and val > current.next.val:
                current = current.next
            new_node.next = current.next
            current.next = new_node

    def display(self):
        current = self.head
        while current:
            print(current.val, end=' ')
            current = current.next
        print()

# Example usage
sll = SortedLinkedList()
sll.insert(4)
sll.insert(2)
sll.insert(1)
sll.insert(3)
sll.display()  # Output: 1 2 3 4
```

**解析：** 在有序链表中插入新节点时，查找合适的插入位置，以保持链表的有序性。

## 24. 腾讯 - 数据结构与算法

### 24.1 实现一个二叉搜索树

**题目：** 实现一个二叉搜索树。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        else:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)

    def search(self, val):
        return self._search(self.root, val)

    def _search(self, node, val):
        if node is None:
            return False
        if node.val == val:
            return True
        elif val < node.val:
            return self._search(node.left, val)
        else:
            return self._search(node.right, val)

# Example usage
bst = BinarySearchTree()
bst.insert(5)
bst.insert(3)
bst.insert(7)
print(bst.search(3))  # Output: True
print(bst.search(4))  # Output: False
```

**解析：** 在二叉搜索树中插入节点时，根据值的大小关系递归地查找插入位置。搜索节点时，同样递归地查找。

## 25. 字节跳动 - 数据结构与算法

### 25.1 实现一个哈希表

**题目：** 实现一个哈希表。

**答案：**

```python
class HashTable:
    def __init__(self, size=1000):
        self.size = size
        self.table = [[] for _ in range(size)]

    def _hash(self, key):
        return hash(key) % self.size

    def put(self, key, value):
        index = self._hash(key)
        bucket = self.table[index]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)
                return
        bucket.append((key, value))

    def get(self, key):
        index = self._hash(key)
        bucket = self.table[index]
        for k, v in bucket:
            if k == key:
                return v
        return None

# Example usage
hash_table = HashTable()
hash_table.put("name", "Alice")
hash_table.put("age", 25)
print(hash_table.get("name"))  # Output: Alice
print(hash_table.get("age"))  # Output: 25
```

**解析：** 使用数组实现哈希表，通过哈希函数计算索引，处理冲突。

## 26. 拼多多 - 算法与编程

### 26.1 实现一个栈

**题目：** 实现一个栈。

**答案：**

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, x):
        self.stack.append(x)

    def pop(self):
        if not self.stack:
            return None
        return self.stack.pop()

    def top(self):
        if not self.stack:
            return None
        return self.stack[-1]

    def empty(self):
        return len(self.stack) == 0

# Example usage
s = Stack()
s.push(1)
s.push(2)
s.push(3)
print(s.top())  # Output: 3
print(s.pop())  # Output: 3
print(s.top())  # Output: 2
print(s.empty())  # Output: False
```

**解析：** 使用列表实现栈的基本操作，包括压栈、出栈、获取栈顶元素和检查栈是否为空。

## 27. 京东 - 数据结构与算法

### 27.1 实现一个队列

**题目：** 实现一个队列。

**答案：**

```python
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, x):
        self.queue.append(x)

    def dequeue(self):
        if not self.queue:
            return None
        return self.queue.pop(0)

    def front(self):
        if not self.queue:
            return None
        return self.queue[0]

    def empty(self):
        return len(self.queue) == 0

# Example usage
q = Queue()
q.enqueue(1)
q.enqueue(2)
q.enqueue(3)
print(q.front())  # Output: 1
print(q.dequeue())  # Output: 1
print(q.front())  # Output: 2
print(q.empty())  # Output: False
```

**解析：** 使用列表实现队列的基本操作，包括入队、出队、获取队首元素和检查队列是否为空。

## 28. 美团 - 数据结构与算法

### 28.1 实现一个优先队列

**题目：** 使用小根堆实现一个优先队列。

**答案：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def is_empty(self):
        return len(self.heap) == 0

    def enqueue(self, item, priority):
        heapq.heappush(self.heap, (priority, item))

    def dequeue(self):
        if self.is_empty():
            return None
        return heapq.heappop(self.heap)[1]

    def empty(self):
        return len(self.heap) == 0

# Example usage
pq = PriorityQueue()
pq.enqueue("task1", 2)
pq.enqueue("task2", 1)
pq.enqueue("task3", 3)
print(pq.dequeue())  # Output: task2
print(pq.dequeue())  # Output: task1
print(pq.dequeue())  # Output: task3
```

**解析：** 使用小根堆实现优先队列。`enqueue` 方法将元素插入堆中，`dequeue` 方法根据优先级删除元素。

## 29. 快手 - 数据结构与算法

### 29.1 实现一个双向链表

**题目：** 实现一个双向链表。

**答案：**

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, value):
        new_node = Node(value)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def display(self):
        current = self.head
        while current:
            print(current.value, end=' ')
            current = current.next
        print()

# Example usage
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.display()  # Output: 1 2 3
```

**解析：** 实现一个双向链表，支持尾插操作。每个节点包含前驱和后继指针。

## 30. 滴滴 - 算法与编程

### 30.1 实现一个二叉树的前序遍历

**题目：** 实现一个函数，用于对二叉树进行前序遍历。

**答案：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def dfs(node):
            if node:
                result.append(node.val)
                dfs(node.left)
                dfs(node.right)

        result = []
        dfs(root)
        return result

# Example usage
# Construct a binary tree:
#     1
#    / \
#   2   3
#  / \
# 4   5
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)
solution = Solution()
print(solution.preorderTraversal(root))  # Output: [1, 2, 4, 5, 3]
```

**解析：** 使用递归实现二叉树的前序遍历。首先访问根节点，然后递归地遍历左子树和右子树。

