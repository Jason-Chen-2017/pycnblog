                 

### 小米2024校招IoT开发工程师算法题汇总

#### 1. 快排C++实现

**题目描述：** 请用C++实现快速排序算法，并给出时间复杂度分析。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    int n = arr.size();
    
    quickSort(arr, 0, n - 1);
    
    cout << "Sorted array: \n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    
    return 0;
}
```

**解析：** 快速排序是一种基于分治思想的排序算法。其时间复杂度平均情况下为O(nlogn)，最坏情况下为O(n^2)，但实际中通常接近O(nlogn)。

#### 2. KMP算法C++实现

**题目描述：** 请用C++实现KMP算法，并给出时间复杂度分析。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<int> computeLPS(string pat) {
    int M = pat.length();
    vector<int> lps(M, 0);
    int len = 0;
    int i = 1;
    
    while (i < M) {
        if (pat[i] == pat[len]) {
            lps[i] = len + 1;
            len++;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}

int KMPSearch(string pat, string txt) {
    int M = pat.length();
    int N = txt.length();
    
    vector<int> lps = computeLPS(pat);
    int i = 0; // index for txt[]
    int j = 0; // index for pat[]
    
    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }
        
        if (j == M) {
            return (i - j);
            j = lps[j - 1];
        }
        
        else if (i < N && pat[j] != txt[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i = i + 1;
            }
        }
    }
    
    return -1;
}

int main() {
    string txt = "ABABDABACD";
    string pat = "ABABCABAB";
    
    int result = KMPSearch(pat, txt);
    if (result == -1)
        cout << "Not found";
    else
        cout << "Found at index " << result;
    
    return 0;
}
```

**解析：** KMP算法是一种高效的字符串匹配算法，其时间复杂度为O(n)，其中n为文本字符串的长度。

#### 3. 动态规划Fibonacci数列

**题目描述：** 请用动态规划方法实现计算Fibonacci数列。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int fibonacci(int n) {
    vector<int> dp(n + 1, 0);
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

int main() {
    int n = 10;
    cout << "Fibonacci(" << n << ") = " << fibonacci(n) << endl;
    
    return 0;
}
```

**解析：** 动态规划是一种优化递归的方法，通过保存已计算的子问题的解，避免重复计算，从而提高效率。此方法计算Fibonacci数列的时间复杂度为O(n)。

#### 4. 数据结构-堆的实现

**题目描述：** 请用C++实现一个最小堆。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

void heapify(vector<int>& arr, int n, int i) {
    int smallest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] < arr[smallest]) {
        smallest = left;
    }

    if (right < n && arr[right] < arr[smallest]) {
        smallest = right;
    }

    if (smallest != i) {
        swap(arr[i], arr[smallest]);
        heapify(arr, n, smallest);
    }
}

void buildHeap(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
}

int extractMin(vector<int>& arr) {
    int n = arr.size();
    int root = arr[0];
    arr[0] = arr[n - 1];
    arr.pop_back();
    heapify(arr, n - 1, 0);
    return root;
}

int main() {
    vector<int> arr = {4, 10, 3, 5, 1};
    buildHeap(arr);

    cout << "Heap: ";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    cout << "Extract min: " << extractMin(arr) << endl;

    return 0;
}
```

**解析：** 堆是一种特殊的数据结构，满足堆性质（父节点小于或大于子节点）。最小堆的堆顶元素始终是最小的元素。此实现的时间复杂度为O(logn)。

#### 5. 线性表实现

**题目描述：** 请用C++实现一个线性表。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

class LinearTable {
public:
    vector<int> data;
    
    LinearTable() {
        data = vector<int>();
    }
    
    void append(int x) {
        data.push_back(x);
    }
    
    void insert(int i, int x) {
        data.insert(data.begin() + i, x);
    }
    
    void remove(int i) {
        data.erase(data.begin() + i);
    }
    
    int get(int i) {
        return data[i];
    }
    
    int size() {
        return data.size();
    }
};

int main() {
    LinearTable table;
    
    table.append(1);
    table.append(2);
    table.append(3);
    
    cout << "Size: " << table.size() << endl;
    cout << "Get 1: " << table.get(0) << endl;
    
    table.insert(1, 4);
    
    cout << "Size: " << table.size() << endl;
    cout << "Get 1: " << table.get(1) << endl;
    
    table.remove(1);
    
    cout << "Size: " << table.size() << endl;
    
    return 0;
}
```

**解析：** 线性表是一种数据结构，用于存储一系列元素。此实现使用了C++的vector来实现线性表，时间复杂度为O(1)或O(n)。

#### 6. 二分查找

**题目描述：** 请用C++实现二分查找算法。

**答案：**

```cpp
#include <iostream>

using namespace std;

int binarySearch(vector<int>& arr, int target) {
    int low = 0;
    int high = arr.size() - 1;
    
    while (low <= high) {
        int mid = low + (high - low) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    
    return -1;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int target = 5;
    
    int result = binarySearch(arr, target);
    
    if (result == -1) {
        cout << "Element not found in array" << endl;
    } else {
        cout << "Element found at index " << result << endl;
    }
    
    return 0;
}
```

**解析：** 二分查找是一种高效的查找算法，适用于有序数组。其时间复杂度为O(logn)。

#### 7. 数据结构-队列的实现

**题目描述：** 请用C++实现一个队列。

**答案：**

```cpp
#include <iostream>
#include <queue>

using namespace std;

int main() {
    queue<int> q;
    
    q.push(1);
    q.push(2);
    q.push(3);
    
    cout << "Front element: " << q.front() << endl;
    cout << "Back element: " << q.back() << endl;

    cout << "Queue elements: ";
    while (!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    cout << endl;
    
    return 0;
}
```

**解析：** 队列是一种先进先出（FIFO）的数据结构。此实现使用了C++的queue来实现队列，时间复杂度为O(1)。

#### 8. BFS实现图遍历

**题目描述：** 请用C++实现广度优先搜索（BFS）算法，实现图的遍历。

**答案：**

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

void BFS(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);
    queue<int> q;

    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                q.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

int main() {
    vector<vector<int>> graph = {
        {1, 2},
        {0, 3, 4},
        {0, 5},
        {1, 6},
        {2, 7},
        {2, 8},
        {3, 9},
        {4, 10},
        {5, 11},
        {6, 12}
    };

    cout << "BFS traversal from node 0: ";
    BFS(graph, 0);

    return 0;
}
```

**解析：** 广度优先搜索（BFS）是一种图遍历算法，按层次遍历图的所有节点。此实现的时间复杂度为O(V+E)，其中V是节点数，E是边数。

#### 9. DFS实现图遍历

**题目描述：** 请用C++实现深度优先搜索（DFS）算法，实现图的遍历。

**答案：**

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

void DFS(vector<vector<int>>& graph, int start) {
    int n = graph.size();
    vector<bool> visited(n, false);

    stack<int> s;
    s.push(start);
    visited[start] = true;

    while (!s.empty()) {
        int node = s.top();
        s.pop();
        cout << node << " ";

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                s.push(neighbor);
                visited[neighbor] = true;
            }
        }
    }
}

int main() {
    vector<vector<int>> graph = {
        {1, 2},
        {0, 3, 4},
        {0, 5},
        {1, 6},
        {2, 7},
        {2, 8},
        {3, 9},
        {4, 10},
        {5, 11},
        {6, 12}
    };

    cout << "DFS traversal from node 0: ";
    DFS(graph, 0);

    return 0;
}
```

**解析：** 深度优先搜索（DFS）是一种图遍历算法，从起点开始，沿着一个路径一直走到底，然后回溯。此实现的时间复杂度为O(V+E)。

#### 10. 冒泡排序C++实现

**题目描述：** 请用C++实现冒泡排序算法，并给出时间复杂度分析。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};
    bubbleSort(arr);
    
    cout << "Sorted array: \n";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    
    return 0;
}
```

**解析：** 冒泡排序是一种简单的排序算法，通过重复遍历待排序的列表，比较相邻的元素并交换它们，使得较大的元素逐渐向数组的末尾移动。时间复杂度为O(n^2)。

#### 11. 选择排序C++实现

**题目描述：** 请用C++实现选择排序算法，并给出时间复杂度分析。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

void selectionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        swap(arr[i], arr[min_idx]);
    }
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};
    selectionSort(arr);
    
    cout << "Sorted array: \n";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    
    return 0;
}
```

**解析：** 选择排序是一种简单的排序算法，首先找到未排序部分的最小元素，然后将其与未排序部分的第一位交换，以此类推。时间复杂度为O(n^2)。

#### 12. 插入排序C++实现

**题目描述：** 请用C++实现插入排序算法，并给出时间复杂度分析。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

int main() {
    vector<int> arr = {64, 25, 12, 22, 11};
    insertionSort(arr);
    
    cout << "Sorted array: \n";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i] << " ";
    }
    
    return 0;
}
```

**解析：** 插入排序是一种简单的排序算法，将未排序元素插入到已排序部分的正确位置。时间复杂度为O(n^2)。

#### 13. 栈实现队列

**题目描述：** 请使用两个栈实现一个队列。

**答案：**

```cpp
#include <iostream>
#include <stack>

using namespace std;

class MyQueue {
private:
    stack<int> stack1;
    stack<int> stack2;

public:
    MyQueue() {
    }

    void push(int x) {
        stack1.push(x);
    }

    int pop() {
        if (stack2.empty()) {
            while (!stack1.empty()) {
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int top = stack2.top();
        stack2.pop();
        return top;
    }

    bool empty() {
        return stack1.empty() && stack2.empty();
    }
};

int main() {
    MyQueue q;
    q.push(1);
    q.push(2);
    q.push(3);

    cout << q.pop() << " " << q.pop() << " " << q.pop() << endl;
    
    return 0;
}
```

**解析：** 使用两个栈实现队列，一个栈用于入队，另一个栈用于出队。出队时，如果辅助栈为空，将主栈的所有元素倒入辅助栈，然后从辅助栈出队。时间复杂度为O(1)。

#### 14. 链表反转

**题目描述：** 实现一个函数，反转单链表。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

void reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    
    while (curr != nullptr) {
        ListNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    head = prev;
}

int main() {
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    
    reverseList(head);
    
    ListNode* temp = head;
    while (temp != nullptr) {
        cout << temp->val << " ";
        temp = temp->next;
    }
    
    return 0;
}
```

**解析：** 通过遍历链表，将当前节点的next指针指向前一个节点，从而实现链表的反转。时间复杂度为O(n)。

#### 15. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode* dummy = new ListNode(0);
    ListNode* curr = dummy;
    
    while (l1 && l2) {
        if (l1->val < l2->val) {
            curr->next = l1;
            l1 = l1->next;
        } else {
            curr->next = l2;
            l2 = l2->next;
        }
        curr = curr->next;
    }
    
    curr->next = l1 ? l1 : l2;
    return dummy->next;
}

int main() {
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(3);
    l1->next->next = new ListNode(5);
    
    ListNode* l2 = new ListNode(2);
    l2->next = new ListNode(4);
    l2->next->next = new ListNode(6);
    
    ListNode* result = mergeTwoLists(l1, l2);
    
    ListNode* temp = result;
    while (temp != nullptr) {
        cout << temp->val << " ";
        temp = temp->next;
    }
    
    return 0;
}
```

**解析：** 通过比较两个链表的当前节点值，将较小的节点添加到结果链表中，并移动相应的链表指针。时间复杂度为O(n+m)，其中n和m分别为两个链表的长度。

#### 16. 回文链表

**题目描述：** 判断一个链表是否为回文。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool isPalindrome(ListNode* head) {
    ListNode* fast = head;
    ListNode* slow = head;
    ListNode* prevMid = nullptr;
    
    while (fast != nullptr && fast->next != nullptr) {
        fast = fast->next->next;
        prevMid = slow;
        slow = slow->next;
    }
    
    if (fast != nullptr) {
        slow = prevMid->next;
    }
    
    ListNode* secondHalf = reverseList(slow);
    ListNode* p1 = head;
    ListNode* p2 = secondHalf;
    
    while (p1 != nullptr && p2 != nullptr) {
        if (p1->val != p2->val) {
            return false;
        }
        p1 = p1->next;
        p2 = p2->next;
    }
    
    return true;
}

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    
    while (curr != nullptr) {
        ListNode* nextTemp = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}

int main() {
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(2);
    l1->next->next = new ListNode(2);
    l1->next->next->next = new ListNode(1);
    
    cout << (isPalindrome(l1) ? "回文" : "非回文") << endl;
    
    return 0;
}
```

**解析：** 通过快慢指针找到链表的中点，然后反转后半部分链表，最后比较前半部分和反转后的后半部分链表。时间复杂度为O(n)。

#### 17. 打家劫舍

**题目描述：** 打家劫舍问题。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int rob(vector<int>& nums) {
    if (nums.empty()) return 0;
    int n = nums.size();
    vector<int> dp(n, 0);
    
    if (n >= 1) dp[0] = nums[0];
    if (n >= 2) dp[1] = max(nums[0], nums[1]);
    
    for (int i = 2; i < n; i++) {
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    }
    
    return dp[n - 1];
}

int main() {
    vector<int> nums = {1, 2, 3, 1};
    cout << "最大值：" << rob(nums) << endl;
    
    return 0;
}
```

**解析：** 动态规划问题，使用一个数组dp存储到每个位置可以得到的最大金额。状态转移方程为dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])。时间复杂度为O(n)。

#### 18. 最小路径和

**题目描述：** 给定一个包含非负数的 m x n 网格，找到从左上角到右下角的最小路径和。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n, 0));
    
    dp[0][0] = grid[0][0];
    
    for (int i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    
    for (int j = 1; j < n; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
    }
    
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    
    return dp[m - 1][n - 1];
}

int main() {
    vector<vector<int>> grid = {
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1}
    };
    cout << "最小路径和：" << minPathSum(grid) << endl;
    
    return 0;
}
```

**解析：** 动态规划问题，使用一个二维数组dp存储到达每个位置的最小路径和。状态转移方程为dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]。时间复杂度为O(m*n)。

#### 19. 合并两个有序链表

**题目描述：** 合并两个有序链表。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode* dummy = new ListNode(0);
    ListNode* curr = dummy;
    
    while (l1 && l2) {
        if (l1->val < l2->val) {
            curr->next = l1;
            l1 = l1->next;
        } else {
            curr->next = l2;
            l2 = l2->next;
        }
        curr = curr->next;
    }
    
    curr->next = l1 ? l1 : l2;
    return dummy->next;
}

int main() {
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(2);
    l1->next->next = new ListNode(4);
    
    ListNode* l2 = new ListNode(1);
    l2->next = new ListNode(3);
    l2->next->next = new ListNode(4);
    
    ListNode* result = mergeTwoLists(l1, l2);
    
    ListNode* temp = result;
    while (temp != nullptr) {
        cout << temp->val << " ";
        temp = temp->next;
    }
    
    return 0;
}
```

**解析：** 通过比较两个链表的当前节点值，将较小的节点添加到结果链表中，并移动相应的链表指针。时间复杂度为O(n+m)，其中n和m分别为两个链表的长度。

#### 20. 旋转链表

**题目描述：** 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置。

**答案：**

```cpp
#include <iostream>
#include <vector>

using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

void rotateRight(ListNode* head, int k) {
    if (!head || k == 0) return;
    
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* fast = dummy;
    ListNode* slow = dummy;
    int len = 0;

    while (fast->next) {
        fast = fast->next;
        len++;
    }

    k = k % len;
    if (k == 0) return;

    fast = dummy;
    for (int i = 0; i < len - k; i++) {
        fast = fast->next;
    }

    slow = fast->next;
    fast->next = nullptr;
    fast = slow;

    while (fast->next) {
        fast = fast->next;
    }

    fast->next = head;
    head = slow;
}

int main() {
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    rotateRight(head, 2);

    ListNode* temp = head;
    while (temp != nullptr) {
        cout << temp->val << " ";
        temp = temp->next;
    }
    
    return 0;
}
```

**解析：** 通过快慢指针找到链表的尾部，然后将尾部连接到头部的前k个节点，最后将新的头部连接到尾部。时间复杂度为O(n)。

