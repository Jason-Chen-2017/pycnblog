                 

### 携程2024校招面试真题汇总及其解答

#### 1. TCP和UDP的区别

**题目：** 请解释TCP和UDP的区别。

**答案：**
TCP（传输控制协议）和UDP（用户数据报协议）都是网络传输层常用的协议，但它们在数据传输方面存在一些关键区别。

**1. 连接性：**
- TCP是面向连接的协议，数据传输前需要建立连接。
- UDP是无连接的协议，不需要预先建立连接。

**2. 可靠性：**
- TCP提供可靠的数据传输，确保数据完整、有序到达。
- UDP不保证数据的可靠性，数据可能会丢失或重复。

**3. 流量控制：**
- TCP具有流量控制机制，可根据网络状况调整发送速率。
- UDP没有流量控制，发送速率取决于网络和应用程序。

**4. 速度：**
- TCP由于可靠性高，传输速度相对较慢。
- UDP速度快，适用于实时应用，如在线游戏、视频通话等。

**5. 用途：**
- TCP常用于需要保证数据完整性和传输顺序的应用，如HTTP、FTP。
- UDP常用于对实时性要求高的应用，如DNS、VoIP。

**解析：** TCP和UDP在网络传输中各有优势。TCP适用于需要可靠传输的场景，而UDP则适用于对速度和实时性要求较高的场景。

#### 2. 算法面试题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**示例：** 字符串1："ABCD"，字符串2："ACDF"，最长公共子序列为："ACD"。

**答案：**
使用动态规划算法可以有效地求解最长公共子序列。

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))
```

**解析：** 通过构建一个二维数组dp，其中dp[i][j]表示s1的前i个字符和s2的前j个字符的最长公共子序列的长度。通过遍历两个字符串的字符，更新dp数组，最终得到最长公共子序列的长度。

#### 3. 算法面试题：排序算法比较

**题目：** 请简述冒泡排序、快速排序和归并排序的区别和适用场景。

**答案：**
冒泡排序、快速排序和归并排序都是常用的排序算法，它们在时间复杂度和空间复杂度上有所不同，适用于不同的场景。

**1. 冒泡排序：**
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 适用于数据量较小的场景，或作为其他排序算法的优化基础。

**2. 快速排序：**
- 时间复杂度：平均O(n*log(n))，最坏O(n^2)
- 空间复杂度：O(log(n))
- 适用于数据量较大的场景，是一种高效的排序算法。

**3. 归并排序：**
- 时间复杂度：O(n*log(n))
- 空间复杂度：O(n)
- 适用于数据量较大的场景，具有稳定的性能。

**解析：** 冒泡排序是最简单的排序算法之一，但效率较低；快速排序是一种高效的排序算法，但最坏情况下性能较差；归并排序具有稳定的性能，但需要额外的空间来存储中间结果。

#### 4. 数据结构与算法：哈希表

**题目：** 请解释哈希表的工作原理和优缺点。

**答案：**
哈希表是一种基于哈希函数的数据结构，用于快速查找、插入和删除元素。

**工作原理：**
- 哈希表由一个数组（哈希桶）和哈希函数组成。
- 将元素的键通过哈希函数计算得到哈希值，哈希值用于确定元素在哈希表中的存储位置。
- 如果多个元素的哈希值相同（哈希冲突），则采用链地址法或开放地址法解决。

**优缺点：**
- 优点：平均时间复杂度为O(1)，查找、插入和删除操作非常高效。
- 缺点：可能存在哈希冲突，需要额外的处理逻辑；哈希函数的设计对性能有重要影响。

**解析：** 哈希表通过哈希函数将键映射到数组中的位置，实现快速的查找、插入和删除操作。但哈希冲突可能导致性能下降，因此需要合理的哈希函数设计和冲突解决策略。

#### 5. 算法面试题：矩阵乘法

**题目：** 请设计一个算法计算两个矩阵的乘积。

**答案：**
可以使用分治算法（Strassen算法）或朴素算法计算两个矩阵的乘积。

**分治算法（Strassen算法）：**

```python
def strassen_matrix_multiply(A, B):
    n = len(A)
    if n == 1:
        return [[A[0][0] * B[0][0]]]

    # 分割矩阵
    mid = n // 2
    A11, A12, A21, A22 = split_matrix(A)
    B11, B12, B21, B22 = split_matrix(B)

    # 计算中间结果
    S1 = strassen_matrix_multiply(A11 + A22, B11 + B22)
    S2 = strassen_matrix_multiply(A21 + A22, B11)
    S3 = strassen_matrix_multiply(A11, B12 - B22)
    S4 = strassen_matrix_multiply(A22, B21 - B11)
    S5 = strassen_matrix_multiply(A11 + A12, B22)
    S6 = strassen_matrix_multiply(A21 - A11, B11 + B12)
    S7 = strassen_matrix_multiply(A12 - A22, B21 + B22)

    # 合并结果
    C11 = S1 + S4 - S5 + S7
    C12 = S3 + S5
    C21 = S2 + S4
    C22 = S1 - S2 + S3 + S6

    return merge_matrix(C11, C12, C21, C22)

# 辅助函数
def split_matrix(matrix):
    mid = len(matrix) // 2
    return [
        matrix[i][j: j + mid] for i in range(mid)
    ] + [
        matrix[i][j + mid:] for i in range(mid)
    ]

def merge_matrix(C11, C12, C21, C22):
    n = len(C11)
    result = [[0] * 2 * n for _ in range(2 * n)]
    for i in range(2 * n):
        for j in range(2 * n):
            if i < n and j < n:
                result[i][j] = C11[i][j]
            elif i < n and j >= n:
                result[i][j] = C12[i][j - n]
            elif i >= n and j < n:
                result[i][j] = C21[i - n][j]
            else:
                result[i][j] = C22[i - n][j - n]
    return result

A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]
print(strassen_matrix_multiply(A, B))
```

**解析：** Strassen算法通过将矩阵分解为更小的矩阵，减少了矩阵乘法的操作次数，从而提高了计算效率。在数据量较大时，Strassen算法的性能优于朴素算法。

**朴素算法：**

```python
def naive_matrix_multiply(A, B):
    n = len(A)
    C = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
    return C

A = [[1, 2], [3, 4]]
B = [[5, 6], [7, 8]]
print(naive_matrix_multiply(A, B))
```

**解析：** 朴素算法通过三层嵌套循环计算矩阵乘积，适用于数据量较小的情况。在数据量较大时，朴素算法的时间复杂度为O(n^3)，性能较差。

#### 6. 算法面试题：贪心算法

**题目：** 请解释贪心算法的基本思想及其应用场景。

**答案：**
贪心算法是一种在每一步选择中都采取当前最好或最优的选择，从而希望导致结果是全局最好或最优的算法。

**基本思想：**
- 在每一步选择中，贪心算法选择一个局部最优解，并期望通过这种方式得到全局最优解。
- 贪心算法通常不保证得到全局最优解，但在某些情况下可以。

**应用场景：**
- 背包问题：选择物品的组合，使总价值最大。
- 最短路径问题：在Dijkstra算法中，选择距离最短的顶点进行扩展。
- 资源分配：选择最小或最大的资源进行分配。

**解析：** 贪心算法通过在每一步选择局部最优解，期望得到全局最优解。虽然贪心算法不保证总是得到最优解，但在某些问题中，如背包问题和最短路径问题，它是一种有效的求解方法。

#### 7. 算法面试题：二分查找

**题目：** 请实现一个二分查找算法，并分析其时间复杂度和空间复杂度。

**答案：**
二分查找算法是一种高效的查找算法，用于在有序数组中查找目标元素。

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

arr = [1, 3, 5, 7, 9]
target = 5
print(binary_search(arr, target))
```

**时间复杂度：** O(log(n))，其中n为数组长度。

**空间复杂度：** O(1)，不需要额外空间。

**解析：** 二分查找算法通过不断缩小查找范围，将问题规模减少一半，从而实现了高效的查找。在有序数组中，二分查找的时间复杂度为O(log(n))，空间复杂度为O(1)。

#### 8. 数据结构与算法：堆

**题目：** 请解释堆的数据结构及其在算法中的应用。

**答案：**
堆（Heap）是一种特殊的树形数据结构，用于实现优先队列。堆可以分为最大堆和最小堆。

**数据结构：**
- 堆是一个完全二叉树。
- 对于最大堆，父节点的值大于或等于子节点的值；对于最小堆，父节点的值小于或等于子节点的值。

**应用：**
- 贪心算法中的选择最小或最大元素。
- 最大堆用于实现优先队列，优先级高的元素先被处理。
- 最小堆用于实现快速选择算法，用于求解第k小元素问题。

**解析：** 堆通过完全二叉树实现，具有高效的插入和删除操作。最大堆和最小堆在贪心算法中应用广泛，用于选择最大或最小元素，实现优先队列和快速选择算法。

#### 9. 算法面试题：斐波那契数列

**题目：** 请实现一个递归和非递归的斐波那契数列算法，并分析其时间复杂度和空间复杂度。

**递归算法：**

```python
def fibonacci_recursive(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

n = 10
print(fibonacci_recursive(n))
```

**时间复杂度：** O(2^n)，空间复杂度：O(n)。

**非递归算法：**

```python
def fibonacci_iterative(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

n = 10
print(fibonacci_iterative(n))
```

**时间复杂度：** O(n)，空间复杂度：O(1)。

**解析：** 递归算法的时间复杂度较高，因为存在大量重复计算。非递归算法通过迭代的方式减少了重复计算，时间复杂度和空间复杂度都较低。

#### 10. 算法面试题：矩阵转置

**题目：** 请实现一个矩阵转置的算法，并分析其时间复杂度和空间复杂度。

```python
def transpose_matrix(A):
    n = len(A)
    B = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            B[i][j] = A[j][i]
    return B

A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(transpose_matrix(A))
```

**时间复杂度：** O(n^2)，空间复杂度：O(n^2)。

**解析：** 矩阵转置的算法通过遍历矩阵元素，将其交换到新的矩阵位置。时间复杂度和空间复杂度都与矩阵大小成正比。

#### 11. 数据结构与算法：双向链表

**题目：** 请实现一个双向链表的数据结构，并实现添加、删除、遍历等基本操作。

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def append(self, value):
        new_node = Node(value)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def delete(self, node):
        if node is None:
            return
        if node == self.head:
            self.head = node.next
        if node == self.tail:
            self.tail = node.prev
        if node.next:
            node.next.prev = node.prev
        if node.prev:
            node.prev.next = node.next

    def traverse(self):
        current = self.head
        while current:
            print(current.value, end=" ")
            current = current.next
        print()

dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.traverse()
dll.delete(dll.head.next)
dll.traverse()
```

**解析：** 双向链表通过在每个节点中存储前驱和后继节点的引用，实现了在链表中的快速添加、删除和遍历操作。

#### 12. 算法面试题：最长公共前缀

**题目：** 给定一个字符串数组，找出最长公共前缀。

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if s.find(c) != 0:
                return prefix
        prefix += c
    return prefix

strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))
```

**解析：** 通过遍历第一个字符串的字符，检查其他字符串是否以该字符开头，找到最长公共前缀。

#### 13. 数据结构与算法：栈

**题目：** 请实现一个栈的数据结构，并实现基本操作（入栈、出栈、遍历）。

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

    def traverse(self):
        for item in self.items:
            print(item, end=" ")
        print()

s = Stack()
s.push(1)
s.push(2)
s.push(3)
s.traverse()
s.pop()
s.traverse()
```

**解析：** 栈通过数组实现，支持快速入栈、出栈和遍历操作。

#### 14. 算法面试题：两数相加

**题目：** 给定两个非空链表表示的两个非负整数，每个节点包含一个数字。计算两个数字的和，并以链表形式返回结果。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            sum = val1 + val2 + carry
            carry = sum // 10
            curr.next = ListNode(sum % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

**解析：** 通过模拟加法运算，将结果链表返回。

#### 15. 数据结构与算法：队列

**题目：** 请实现一个队列的数据结构，并实现基本操作（入队、出队、遍历）。

```python
class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.append(item)

    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)
        return None

    def peek(self):
        if not self.is_empty():
            return self.items[0]
        return None

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)

    def traverse(self):
        for item in self.items:
            print(item, end=" ")
        print()

q = Queue()
q.enqueue(1)
q.enqueue(2)
q.enqueue(3)
q.traverse()
q.dequeue()
q.traverse()
```

**解析：** 队列通过列表实现，支持快速入队、出队和遍历操作。

#### 16. 算法面试题：旋转图像

**题目：** 给定一个n x n的二维矩阵matrix表示一个图像，请你将图像顺时针旋转90度。

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n // 2):
            for j in range(i, n - i - 1):
                temp = matrix[i][j]
                matrix[i][j] = matrix[n - j - 1][i]
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
                matrix[j][n - i - 1] = temp
```

**解析：** 通过四次交换矩阵的相邻元素，实现图像的顺时针旋转。

#### 17. 数据结构与算法：树

**题目：** 请实现一个二叉树的数据结构，并实现基本操作（插入、删除、遍历）。

```python
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right

class BinaryTree:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)

    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left:
                self._insert_recursive(node.left, value)
            else:
                node.left = TreeNode(value)
        else:
            if node.right:
                self._insert_recursive(node.right, value)
            else:
                node.right = TreeNode(value)

    def delete(self, value):
        self.root = self._delete_recursive(self.root, value)

    def _delete_recursive(self, node, value):
        if node is None:
            return None
        if value < node.value:
            node.left = self._delete_recursive(node.left, value)
        elif value > node.value:
            node.right = self._delete_recursive(node.right, value)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            temp = self._find_min(node.right)
            node.value = temp.value
            node.right = self._delete_recursive(node.right, temp.value)
        return node

    def _find_min(self, node):
        while node.left:
            node = node.left
        return node

    def traverse_inorder(self):
        self._traverse_inorder_recursive(self.root)
        print()

    def _traverse_inorder_recursive(self, node):
        if node:
            self._traverse_inorder_recursive(node.left)
            print(node.value, end=" ")
            self._traverse_inorder_recursive(node.right)

tree = BinaryTree()
tree.insert(5)
tree.insert(3)
tree.insert(7)
tree.insert(2)
tree.insert(4)
tree.insert(6)
tree.insert(8)
tree.traverse_inorder()
tree.delete(5)
tree.traverse_inorder()
```

**解析：** 二叉树通过递归实现插入、删除和遍历操作。

#### 18. 算法面试题：搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个搜索函数，查找给定的目标值，如果数组中存在，则返回它的索引，否则返回-1。

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[right] and target <= nums[mid]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
print(search(nums, target))
```

**解析：** 通过二分查找的方式，在旋转排序的数组中搜索目标值。

#### 19. 算法面试题：合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if list1 is None:
            return list2
        if list2 is None:
            return list1
        if list1.val < list2.val:
            result = list1
            result.next = self.mergeTwoLists(list1.next, list2)
        else:
            result = list2
            result.next = self.mergeTwoLists(list1, list2.next)
        return result
```

**解析：** 通过递归合并两个有序链表。

#### 20. 算法面试题：移除重复节点

**题目：** 给定一个单链表的头节点head，请删除链表中重复的节点，使每个元素只出现一次。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return head
        cur = head
        while cur and cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
```

**解析：** 通过遍历链表，删除重复节点。

#### 21. 数据结构与算法：图

**题目：** 请实现一个图的数据结构，并实现基本操作（添加节点、添加边、遍历）。

```python
class Graph:
    def __init__(self):
        self.vertices = {}

    def add_vertex(self, vertex):
        if vertex not in self.vertices:
            self.vertices[vertex] = []

    def add_edge(self, v1, v2):
        if v1 not in self.vertices:
            self.add_vertex(v1)
        if v2 not in self.vertices:
            self.add_vertex(v2)
        self.vertices[v1].append(v2)
        self.vertices[v2].append(v1)

    def traverse(self):
        for vertex, edges in self.vertices.items():
            print(vertex, ":", edges)

g = Graph()
g.add_vertex("A")
g.add_vertex("B")
g.add_vertex("C")
g.add_edge("A", "B")
g.add_edge("B", "C")
g.traverse()
```

**解析：** 图通过字典实现，支持添加节点、添加边和遍历操作。

#### 22. 算法面试题：求两个数组的交集

**题目：** 给定两个整数数组 nums1 和 nums2 ，返回 按升序排列 的 nums1 和 nums2 的交集。

```python
def intersection(nums1, nums2):
    set1 = set(nums1)
    set2 = set(nums2)
    result = []
    for num in set1.intersection(set2):
        result.append(num)
    return result

nums1 = [1, 2, 2, 1]
nums2 = [2, 2]
print(intersection(nums1, nums2))
```

**解析：** 通过集合操作求两个数组的交集，并按升序排列。

#### 23. 算法面试题：最小栈

**题目：** 设计一个支持 push ，pop ，top 操作的栈，同时还能查询栈的最小元素。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**解析：** 通过辅助栈记录最小元素，实现最小栈的功能。

#### 24. 算法面试题：两数之和

**题目：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

```python
def two_sum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))
```

**解析：** 通过哈希表实现两数之和的查找。

#### 25. 数据结构与算法：堆排序

**题目：** 请实现堆排序算法，并分析其时间复杂度和空间复杂度。

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

arr = [12, 11, 13, 5, 6, 7]
heap_sort(arr)
print("Sorted array is:", arr)
```

**时间复杂度：** O(n*log(n))，空间复杂度：O(1)。

**解析：** 堆排序通过构造最大堆或最小堆，依次取出堆顶元素，重新调整堆，实现排序。

#### 26. 算法面试题：LRU缓存

**题目：** 请实现一个LRU（Least Recently Used）缓存算法，支持插入、删除和查询操作。

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        else:
            self.cache.move_to_end(key)
            return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**解析：** 通过OrderedDict实现LRU缓存，支持插入、删除和查询操作。

#### 27. 算法面试题：字符串匹配

**题目：** 给定一个字符串（s）和一个字符（t），请实现一个算法，计算出字符串s中包含字符t的子串数量。

```python
def strStrCount(s, t):
    count = 0
    start = 0
    while start < len(s):
        index = s.find(t, start)
        if index == -1:
            break
        count += 1
        start = index + 1
    return count

s = "abracadabra"
t = "abra"
print(strStrCount(s, t))
```

**解析：** 通过遍历字符串，查找包含目标字符的子串数量。

#### 28. 算法面试题：反转链表

**题目：** 请实现一个函数，用于反转单链表。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        curr = head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev
```

**解析：** 通过迭代反转链表。

#### 29. 数据结构与算法：字典树

**题目：** 请实现一个字典树（Trie）的数据结构，并支持插入、删除和搜索操作。

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end_of_word

    def delete(self, word):
        def _delete(node, word, index):
            if index == len(word):
                if not node.is_end_of_word:
                    return False
                node.is_end_of_word = False
                return len(node.children) == 0
            char = word[index]
            if char not in node.children:
                return False
            if _delete(node.children[char], word, index + 1):
                del node.children[char]
                return len(node.children) == 0
            return False

        return _delete(self.root, word, 0)

trie = Trie()
trie.insert("apple")
trie.insert("banana")
print(trie.search("apple"))  # True
print(trie.search("banana"))  # True
trie.delete("apple")
print(trie.search("apple"))  # False
```

**解析：** 通过字典树实现单词的插入、删除和搜索操作。

#### 30. 算法面试题：寻找旋转排序数组中的最小值

**题目：** 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，变为一个升序循环数组。例如，若原数组为 [0,1,2,4,5,6,7]，则可能变为 [4,5,6,7,0,1,2] 或者 [0,1,2,4,5,6,7]。编写一个函数来找出并返回数组中的最小元素。

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

nums = [3, 4, 5, 1, 2]
print(find_min(nums))
```

**解析：** 通过二分查找的方式，找到旋转排序数组中的最小值。

