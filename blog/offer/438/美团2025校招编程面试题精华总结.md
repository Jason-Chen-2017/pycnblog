                 

## 美团2025校招编程面试题精华总结

### 1. 平衡二叉树判断

**题目：** 实现一个函数，判断一个二叉树是否为平衡二叉树。

**答案：**

```go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    leftHeight := getHeight(root.Left)
    rightHeight := getHeight(root.Right)
    if abs(leftHeight-rightHeight) > 1 {
        return false
    }
    return isBalanced(root.Left) && isBalanced(root.Right)
}

func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    return max(getHeight(node.Left), getHeight(node.Right)) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数首先判断根节点是否为空，如果为空，则返回 true。接着分别获取左右子树的深度，如果两个子树的深度差大于1，则说明不是平衡二叉树。最后递归判断左右子树是否为平衡二叉树。

### 2. 单词搜索

**题目：** 给定一个二维网格和一个单词，判断该单词是否可以在网格中找到。

**答案：**

```go
var visited = make([][]bool, 0)
func exist(board [][]byte, word string) bool {
    m, n := len(board), len(board[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if search(board, word, i, j, 0) {
                return true
            }
        }
    }
    return false
}

func search(board [][]byte, word string, i, j, k int) bool {
    if k == len(word) {
        return true
    }
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] != word[k] || visited[i][j] {
        return false
    }
    visited[i][j] = true
    if search(board, word, i+1, j, k+1) ||
        search(board, word, i-1, j, k+1) ||
        search(board, word, i, j+1, k+1) ||
        search(board, word, i, j-1, k+1) {
        return true
    }
    visited[i][j] = false
    return false
}
```

**解析：** 该函数首先遍历网格的每个位置，然后使用深度优先搜索（DFS）来尝试从当前位置找到目标单词。`search` 函数用于实现 DFS，并在找到单词的下一个字符时递归调用自己。在递归调用后，需要回溯并重置当前节点的访问状态。

### 3. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, v := 0, strs[0]; i < len(strs) && strs[i] == v; i++ {
        v = strs[i]
    }
    return v[:i]
}
```

**解析：** 该函数首先检查字符串数组是否为空。如果为空，则返回空字符串。然后从第一个字符串开始，逐个比较后续字符串，直到找到一个不同的字符串为止。返回相同的前缀部分。

### 4. 两数相加

**题目：** 不使用 + 或 - 运算符，实现两个整数的相加。

**答案：**

```go
func add(a, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}
```

**解析：** 该函数使用位运算来实现加法。首先计算两个数的按位与，得到进位。然后计算两个数的按位异或，得到无进位的和。最后将进位移到下一个位上，继续计算，直到没有进位为止。

### 5. 两数相减

**题目：** 不使用 + 或 - 运算符，实现两个整数的相减。

**答案：**

```go
func subtract(a, b int) int {
    for b != 0 {
        borrow := ((^a) & b)
        a = (a ^ b) + borrow
        b = (borrow << 1)
    }
    return a
}
```

**解析：** 该函数使用位运算来实现减法。首先计算两个数的按位取反与，得到借位。然后计算两个数的按位异或，得到无借位的差。最后将借位移到下一个位上，继续计算，直到没有借位为止。

### 6. 字符串转换整数 (atoi)

**题目：** 实现一个函数，将字符串转换为整数。

**答案：**

```go
func myAtoi(s string) int {
    i, sign, ans := 0, 1, 0
    for i < len(s) && (s[i] == ' ' || s[i] == '+' || s[i] == '-') {
        if s[i] == '-' {
            sign = -1
        }
        i++
    }
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        if ans > (1<<31-1)/10 || (ans == (1<<31-1)/10 && s[i] > '7') {
            return sign == 1 ? 1<<31-1 : -1<<31
        }
        ans = ans*10 + int(s[i]-'0')
        i++
    }
    return sign * ans
}
```

**解析：** 该函数首先处理字符串中的空格、正负号，然后逐个字符判断是否为数字。在处理数字时，需要考虑整数的溢出问题，避免结果超出范围。

### 7. 最长公共子序列

**题目：** 给定两个字符串，找出它们的 longest common subsequence。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var ans []byte
    i, j := m, n
    for dp[i][j] != 0 {
        if text1[i-1] == text2[j-1] {
            ans = append(ans, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(ans)
    return string(ans)
}

func reverse(s []byte) {
    n := len(s)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用动态规划（DP）的方法求解最长公共子序列。首先初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 和 `text2` 的前 `i` 个字符和前 `j` 个字符的最长公共子序列的长度。最后，通过回溯得到最长公共子序列。

### 8. 字符串相乘

**题目：** 实现一个函数，将两个字符串表示的整数相乘。

**答案：**

```go
func multiply(num1 string, num2 string) string {
    sign := 1
    if num1[0] == '-' && num2[0] == '-' {
        sign = 1
        num1 = num1[1:]
        num2 = num2[1:]
    } else if num1[0] == '-' {
        sign = -1
        num1 = num1[1:]
    } else if num2[0] == '-' {
        sign = -1
        num2 = num2[1:]
    }
    m, n := len(num1), len(num2)
    var ans = make([]int, m+n)
    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            ans[i+j+1] += (int(num1[i]-'0')) * (int(num2[j]-'0'))
            ans[i+j] += ans[i+j+1] / 10
            ans[i+j+1] %= 10
        }
    }
    var res []byte
    if sign == -1 {
        res = append(res, '-')
    }
    for i := 0; i < m+n; i++ {
        if i == 0 && ans[i] == 0 {
            continue
        }
        res = append(res, byte(ans[i]+'0'))
    }
    return string(res)
}
```

**解析：** 该函数首先处理字符串中的正负号。然后使用两个嵌套循环，分别从两个字符串的末尾开始，将对应的数字相乘并累加到结果数组 `ans` 中。最后将 `ans` 数组转换为字符串返回。

### 9. 股票买卖

**题目：** 给定一个数组，该数组表示每天的股票价格，编写一个函数，计算购买股票可以获得的利润。

**答案：**

```go
func maxProfit(prices []int) int {
    max_profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            max_profit += prices[i] - prices[i-1]
        }
    }
    return max_profit
}
```

**解析：** 该函数使用一个循环遍历数组，每次检查当前元素是否大于前一个元素。如果是，则将差值累加到 `max_profit` 变量中。最后返回 `max_profit`。

### 10. 简化路径

**题目：** 给定一个字符串，该字符串表示一个文件路径，编写一个函数，将其简化。

**答案：**

```go
func simplifyPath(path string) string {
    stk := []string{}
    for _, v := range strings.Split(path, "/") {
        switch v {
        case ".", "":
        case "..":
            if len(stk) > 0 {
                stk = stk[:len(stk)-1]
            }
        default:
            stk = append(stk, v)
        }
    }
    return "/" + strings.Join(stk, "/")
}
```

**解析：** 该函数使用一个栈来处理路径。遍历字符串中的每个元素，根据元素的不同进行相应的操作。如果元素是 `.` 或为空，则忽略；如果元素是 `..`，则从栈中弹出元素；如果元素是目录名，则将其压入栈中。最后将栈中的元素拼接成简化后的路径。

### 11. 盛最多水的容器

**题目：** 给定一个由若干 0 和 1 组成的二维数组，找出数组中最大的子矩形，计算其填充 1 的数量。

**答案：**

```go
func maxArea(height []int) int {
    ans := 0
    n := len(height)
    for i, h := range height {
        left, right := 0, n-i-1
        for left < right {
            mid := (left + right) / 2
            if h <= height[mid] {
                right = mid
            } else {
                left = mid + 1
            }
        }
        area := (right - i) * h
        ans = max(ans, area)
    }
    return ans
}
```

**解析：** 该函数使用二分查找来优化处理。对于每个高度，使用二分查找找到与之对应的最远左右边界，计算子矩形面积，更新最大面积。

### 12. 最小栈

**题目：** 设计一个最小栈，支持 push、pop 和 getMin 操作。

**答案：**

```go
type MinStack struct {
    stk []int
    min []int
}

func Constructor() MinStack {
    return MinStack{[]int{}, []int{int(^uint(0) >> 1)}}
}

func (this *MinStack) Push(val int) {
    this.stk = append(this.stk, val)
    this.min = append(this.min, min(this.min[len(this.min)-1], val))
}

func (this *MinStack) Pop() {
    this.stk = this.stk[:len(this.stk)-1]
    this.min = this.min[:len(this.min)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) GetMin() int {
    return this.min[len(this.min)-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 该函数使用两个栈来记录元素值和最小值。`push` 操作将元素值和当前最小值压入栈；`pop` 操作弹出栈顶元素；`top` 操作返回栈顶元素；`getMin` 操作返回当前最小值。

### 13. 链表中的倒数第 k 个节点

**题目：** 给定一个链表，返回链表中的倒数第 k 个节点。

**答案：**

```go
func getKthFromEnd(head *ListNode, k int) *ListNode {
    fast, slow := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

**解析：** 该函数使用快慢指针的方法。快指针先走 k 步，然后快慢指针同时移动。当快指针到达链表末尾时，慢指针指向的即为倒数第 k 个节点。

### 14. 单调栈

**题目：** 使用单调栈实现下一个更大元素 II。

**答案：**

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    stk := []int{}
    ans := make([]int, n)
    for i := 0; i < 2*n-1; i++ {
        for stk != nil && nums[stk[len(stk)-1]] <= nums[i%n] {
            stk = stk[:len(stk)-1]
        }
        if stk == nil {
            ans[i%n] = -1
        } else {
            ans[i%n] = nums[stk[len(stk)-1]]
        }
        stk = append(stk, i%n)
    }
    return ans
}
```

**解析：** 该函数使用单调栈来处理。遍历数组，将当前元素与栈顶元素比较，更新栈。当栈不为空且当前元素小于等于栈顶元素时，弹出栈顶元素。最后将栈顶元素作为下一个更大元素。

### 15. 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该函数使用递归方法合并两个有序链表。首先比较当前节点的值，选择较小的节点作为新链表的头节点。然后递归合并剩余的链表。

### 16. 链表中的环

**题目：** 判断一个链表中是否存在环。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 该函数使用快慢指针方法判断链表中是否存在环。快指针每次移动两个节点，慢指针每次移动一个节点。如果快指针追上慢指针，则说明链表中存在环。

### 17. 最小生成树

**题目：** 使用 Prim 算法求最小生成树。

**答案：**

```go
func prim(nums [][]int) int {
    n := len(nums)
    ans := 0
    vis := make([]bool, n)
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            if nums[i][j] != 0 && !vis[j] {
                ans += nums[i][j]
                vis[j] = true
                break
            }
        }
    }
    return ans
}
```

**解析：** 该函数使用 Prim 算法来求最小生成树。首先初始化一个数组 `vis`，用于记录每个节点是否被访问。然后遍历每个节点，找到最小的边并将其加入到生成树中。最后返回生成树的总权重。

### 18. 股票买卖 II

**题目：** 给定一个数组，该数组表示每天的股票价格，编写一个函数，计算购买股票可以获得的利润。

**答案：**

```go
func maxProfit(prices []int) int {
    ans := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            ans += prices[i] - prices[i-1]
        }
    }
    return ans
}
```

**解析：** 该函数使用一个循环遍历数组，每次检查当前元素是否大于前一个元素。如果是，则将差值累加到 `ans` 变量中。最后返回 `ans`。

### 19. 双向链表

**题目：** 设计一个双向链表。

**答案：**

```go
type Node struct {
    Val  int
    Prev *Node
    Next *Node
}

type MyLinkedList struct {
    Head *Node
    Tail *Node
    Size int
}

func Constructor() MyLinkedList {
    return MyLinkedList{&Node{}, &Node{}, 0}
}

func (this *MyLinkedList) Get(index int) int {
    if index < 0 || index >= this.Size {
        return -1
    }
    node := this.Head
    for i := 0; i < index; i++ {
        node = node.Next
    }
    return node.Val
}

func (this *MyLinkedList) AddAtHead(val int) {
    newNode := &Node{Val: val, Next: this.Head}
    this.Head.Prev = newNode
    this.Head = newNode
    this.Size++
}

func (this *MyLinkedList) AddAtTail(val int) {
    newNode := &Node{Val: val}
    this.Tail.Next = newNode
    newNode.Prev = this.Tail
    this.Tail = newNode
    this.Size++
}

func (this *MyLinkedList) AddAtIndex(index int, val int) {
    if index < 0 || index > this.Size {
        return
    }
    if index == this.Size {
        this.AddAtTail(val)
    } else if index == 0 {
        this.AddAtHead(val)
    } else {
        node := this.Head
        for i := 0; i < index; i++ {
            node = node.Next
        }
        newNode := &Node{Val: val, Next: node, Prev: node.Prev}
        node.Prev.Next = newNode
        node.Prev = newNode
        this.Size++
    }
}

func (this *MyLinkedList) DeleteAtIndex(index int) {
    if index < 0 || index >= this.Size {
        return
    }
    node := this.Head
    for i := 0; i < index; i++ {
        node = node.Next
    }
    if node == this.Head {
        this.Head = this.Head.Next
    } else if node == this.Tail {
        this.Tail = this.Tail.Prev
    }
    node.Prev.Next = node.Next
    node.Next.Prev = node.Prev
    this.Size--
}
```

**解析：** 该函数设计了一个双向链表，支持插入和删除操作。`Get` 方法获取指定索引的值；`AddAtHead` 和 `AddAtTail` 分别在头部和尾部插入节点；`AddAtIndex` 在指定索引处插入节点；`DeleteAtIndex` 删除指定索引的节点。

### 20. 岛屿数量

**题目：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。

**答案：**

```go
func numIslands(grid [][]byte) int {
    ans := 0
    for i := 0; i < len(grid); i++ {
        for j := 0; j < len(grid[0]); j++ {
            if grid[i][j] == '1' {
                dfs(grid, i, j)
                ans++
            }
        }
    }
    return ans
}

func dfs(grid [][]byte, i, j int) {
    grid[i][j] = '0'
    if i+1 < len(grid) && grid[i+1][j] == '1' {
        dfs(grid, i+1, j)
    }
    if i-1 >= 0 && grid[i-1][j] == '1' {
        dfs(grid, i-1, j)
    }
    if j+1 < len(grid[0]) && grid[i][j+1] == '1' {
        dfs(grid, i, j+1)
    }
    if j-1 >= 0 && grid[i][j-1] == '1' {
        dfs(grid, i, j-1)
    }
}
```

**解析：** 该函数使用 DFS 算法遍历岛屿。首先遍历每个节点，如果节点值为 '1'，则调用 DFS 函数进行深度优先搜索，将岛屿中的所有节点标记为 '0'。每次找到一个新的岛屿，将答案累加。

### 21. 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该函数使用递归方法合并两个有序链表。首先比较当前节点的值，选择较小的节点作为新链表的头节点。然后递归合并剩余的链表。

### 22. 最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 该函数使用双指针方法找出最长公共前缀。首先选择第一个字符串作为前缀，然后逐个比较后续字符串，更新前缀。最后返回最长公共前缀。

### 23. 有效的括号

**题目：** 判断一个字符串是否是有效的括号。

**答案：**

```go
func isValid(s string) bool {
    stk := []byte{}
    for i := 0; i < len(s); i++ {
        if s[i] == '(' || s[i] == '[' || s[i] == '{' {
            stk = append(stk, s[i])
        } else {
            if len(stk) == 0 {
                return false
            }
            switch s[i] {
            case ')':
                if stk[len(stk)-1] != '(' {
                    return false
                }
                stk = stk[:len(stk)-1]
            case ']':
                if stk[len(stk)-1] != '[' {
                    return false
                }
                stk = stk[:len(stk)-1]
            case '}':
                if stk[len(stk)-1] != '{' {
                    return false
                }
                stk = stk[:len(stk)-1]
            }
        }
    }
    return len(stk) == 0
}
```

**解析：** 该函数使用栈来检查字符串中的括号是否匹配。遍历字符串，如果遇到左括号，则将其压入栈；如果遇到右括号，则与栈顶元素比较，如果匹配则弹出栈顶元素。最后检查栈是否为空，如果为空则字符串是有效的括号。

### 24. 计数二进制数中的 1

**题目：** 给定一个整数，计算其二进制表示中 1 的个数。

**答案：**

```go
func hammingWeight(num uint32) int {
    ans := 0
    for num != 0 {
        if num&1 == 1 {
            ans++
        }
        num >>= 1
    }
    return ans
}
```

**解析：** 该函数使用位运算来计算整数二进制表示中 1 的个数。首先将整数与 1 进行按位与操作，如果结果为 1，则累加计数器。然后将整数右移一位，继续进行操作，直到整数变为 0。

### 25. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它应该被插入的位置。

**答案：**

```go
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}
```

**解析：** 该函数使用二分查找算法在排序数组中查找目标值。首先确定左右边界，然后计算中间值。根据中间值与目标值的大小关系，更新左右边界，直到找到目标值或确定其应该被插入的位置。

### 26. 最长公共子序列

**题目：** 给定两个字符串，找出它们的 longest common subsequence。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var ans []byte
    i, j := m, n
    for dp[i][j] != 0 {
        if text1[i-1] == text2[j-1] {
            ans = append(ans, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(ans)
    return string(ans)
}

func reverse(s []byte) {
    n := len(s)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该函数使用动态规划（DP）的方法求解最长公共子序列。首先初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 和 `text2` 的前 `i` 个字符和前 `j` 个字符的最长公共子序列的长度。最后，通过回溯得到最长公共子序列。

### 27. 股票买卖

**题目：** 给定一个数组，该数组表示每天的股票价格，编写一个函数，计算购买股票可以获得的利润。

**答案：**

```go
func maxProfit(prices []int) int {
    max_profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            max_profit += prices[i] - prices[i-1]
        }
    }
    return max_profit
}
```

**解析：** 该函数使用一个循环遍历数组，每次检查当前元素是否大于前一个元素。如果是，则将差值累加到 `max_profit` 变量中。最后返回 `max_profit`。

### 28. 股票买卖 II

**题目：** 给定一个数组，该数组表示每天的股票价格，编写一个函数，计算购买股票可以获得的利润。

**答案：**

```go
func maxProfit(prices []int) int {
    ans := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            ans += prices[i] - prices[i-1]
        }
    }
    return ans
}
```

**解析：** 该函数使用一个循环遍历数组，每次检查当前元素是否大于前一个元素。如果是，则将差值累加到 `ans` 变量中。最后返回 `ans`。

### 29. 股票买卖 III

**题目：** 给定一个数组，该数组表示每天的股票价格，编写一个函数，计算购买股票可以获得的利润，最多只能完成两笔交易。

**答案：**

```go
func maxProfit(prices []int) int {
    firstBuy, secondBuy, firstSell := -prices[0], -prices[0], 0
    for i := 1; i < len(prices); i++ {
        firstBuy = max(firstBuy, -prices[i])
        firstSell = max(firstSell, firstBuy+prices[i])
        secondBuy = max(secondBuy, firstSell-prices[i])
    }
    return secondBuy
}
```

**解析：** 该函数使用动态规划（DP）的方法计算最大利润。首先初始化三个变量，分别表示第一次购买、第一次卖出和第二次卖出的利润。然后遍历数组，更新这三个变量的值。最后返回第二次卖出的利润。

### 30. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, v := range nums {
        t := target - v
        if p, ok := m[t]; ok {
            return []int{p, i}
        }
        m[v] = i
    }
    return nil
}
```

**解析：** 该函数使用哈希表（map）来查找两个数的和。遍历数组，对于每个元素，计算目标值与当前元素的差，并在哈希表中查找是否存在该差值。如果存在，则返回两个元素的下标。如果不存在，则将当前元素及其下标加入哈希表。最后返回结果。

### 总结

本文总结了美团2025校招编程面试题精华总结，包括以下30道典型面试题：

1. 平衡二叉树判断
2. 单词搜索
3. 最长公共前缀
4. 两数相加
5. 两数相减
6. 字符串转换整数 (atoi)
7. 最长公共子序列
8. 字符串相乘
9. 股票买卖
10. 简化路径
11. 盛最多水的容器
12. 最小栈
13. 链表中的倒数第 k 个节点
14. 单调栈
15. 合并两个有序链表
16. 链表中的环
17. 最小生成树
18. 股票买卖 II
19. 双向链表
20. 岛屿数量
21. 合并两个有序链表
22. 最长公共前缀
23. 有效的括号
24. 计数二进制数中的 1
25. 搜索插入位置
26. 最长公共子序列
27. 股票买卖
28. 股票买卖 II
29. 股票买卖 III
30. 两数之和

每道题都给出了详细的答案解析和源代码实例，旨在帮助读者更好地理解和掌握这些面试题。希望通过本文的总结，能够为准备美团2025校招的同学们提供有价值的参考和帮助。祝大家在面试中取得好成绩！

