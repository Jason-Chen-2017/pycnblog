                 

## 京东2024届社招面试高频算法题解析

### 题目 1：最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到 `nums` 的一个连续子数组，使该子数组内的元素之和最大。

**示例：**
```
输入：nums = [1,-3,2,1]
输出：3
解释：最大子序列和为 3，哪部分是 [2,1]。
```

**解答：**
```go
func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    currSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSoFar = max(maxSoFar, currSum)
    }
    return maxSoFar
}
```

**解析：** 采用动态规划的方法，当前元素的最大子序和要么是当前元素本身，要么是当前元素加上之前的最大子序和。遍历数组，更新当前最大子序和和全局最大子序和。

### 题目 2：两个数组的交集 II

**题目描述：** 给定两个整数数组 `nums1` 和 `nums2` ，返回 `nums1` 和 `nums2` 的交集。每个元素最多出现在结果数组中两次。

**示例：**
```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**解答：**
```go
func intersect(nums1 []int, nums2 []int) []int {
    m := make(map[int]int)
    ans := []int{}
    for _, v := range nums1 {
        m[v]++
    }
    for _, v := range nums2 {
        if m[v] > 0 {
            ans = append(ans, v)
            m[v]--
        }
    }
    return ans
}
```

**解析：** 使用哈希表存储数组 `nums1` 的元素及其出现次数，然后遍历数组 `nums2` ，将满足条件的元素加入结果数组，并更新哈希表。

### 题目 3：最长公共子串

**题目描述：** 给定两个字符串 `text1` 和 `text2` ，返回它们的公共最长子串。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出："ace"
```

**解答：**
```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    i, j := m, n
    ans := ""
    for dp[i][j] > 0 {
        if text1[i-1] == text2[j-1] {
            ans = string(text1[i-1]) + ans
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return ans
}
```

**解析：** 使用动态规划解决最长公共子序列问题，构建一个二维数组 `dp` ，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。最后从 `dp[m][n]` 反向构建出最长公共子串。

### 题目 4：有效的括号字符串

**题目描述：** 给定一个只包含 `'('` 、`')'` 和 `*` 的字符串 `s` ，判断字符串是否有效。

**示例：**
```
输入："(*)()"
输出：true
```

**解答：**
```go
func isValid(s string) bool {
    stars, balances := 0, 0
    for _, c := range s {
        if c == '(' {
            balances++
        } else if c == ')' {
            if balances == 0 {
                return false
            }
            balances--
        } else if c == '*' {
            if balances > 0 {
                stars++
            }
        }
        if balances < 0 {
            return false
        }
    }
    return stars >= balances
}
```

**解析：** 使用计数器 `balances` 跟踪左括号的数量，`stars` 记录星号的数量。当遇到 `*` 时，如果 `balances` 大于 0，则增加 `stars`。在遍历过程中，如果 `balances` 小于 0，说明右括号多于左括号，直接返回 `false`。

### 题目 5：买卖股票的最佳时机 III

**题目描述：** 给定一个数组 `prices` ，其中第 `i` 个元素代表了第 `i` 天的股票价格。最多只允许完成两笔交易，设计一个算法来找出最大利润。

**示例：**
```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，利润为 3。
    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，利润为 4。
```

**解答：**
```go
func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    firstBuy, secondBuy := -prices[0], 0
    firstSell, secondSell := 0, 0
    for i := 1; i < len(prices); i++ {
        firstBuy = max(firstBuy, -prices[i])
        firstSell = max(firstSell, firstBuy+prices[i])
        secondBuy = max(secondBuy, firstSell-prices[i])
        secondSell = max(secondSell, secondBuy+prices[i])
    }
    return secondSell
}
```

**解析：** 采用动态规划的方法，`firstBuy` 和 `secondBuy` 分别表示第一次买入和第二次买入后的最低成本，`firstSell` 和 `secondSell` 分别表示第一次卖出和第二次卖出后的最大利润。遍历数组，更新四个变量。

### 题目 6：翻转二叉树

**题目描述：** 翻转一棵二叉树。

**示例：**
```
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**解答：**
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

**解析：** 递归地翻转左右子树，然后交换左右子树。

### 题目 7：删除链表的节点

**题目描述：** 给定单向链表的头指针和一个节点要删除的节点，定义一个函数来删除该节点。

**示例：**
```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9。
```

**解答：**
```go
func deleteNode(node *ListNode) {
    if node == nil {
        return
    }
    next := node.Next
    if next == nil {
        node = nil
        return
    }
    node.Val = next.Val
    node.Next = next.Next
    next = nil
}
```

**解析：** 将待删除节点的下一个节点的值复制到待删除节点，然后删除下一个节点。

### 题目 8：二进制中1的个数

**题目描述：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**示例：**
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**解答：**
```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num = num >> 1
    }
    return count
}
```

**解析：** 利用位运算，每次判断最后一位是否为 1，然后右移一位，直到数变为 0。

### 题目 9：旋转图像

**题目描述：** 给定一个 n × n 的二维矩阵表示一个图像，旋转 90 度，是否能在原地旋转？

**示例：**
```
给定 matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转后的矩阵如下：

[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**解答：**
```go
func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := i; j < n-i-1; j++ {
            temp := matrix[i][j]
            matrix[i][j] = matrix[n-1-j][i]
            matrix[n-1-j][i] = matrix[n-1-i][n-1-j]
            matrix[n-1-i][n-1-j] = matrix[j][n-1-i]
            matrix[j][n-1-i] = temp
        }
    }
}
```

**解析：** 分层旋转，每次旋转一层，先沿对角线交换元素，然后沿行或列交换元素。

### 题目 10：两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是相同的，并且每个链表中的节点已经反序排列。编写一个函数来添加这两个数并返回链表形式的结果。

**示例：**
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

**解答：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        x := 0
        y := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：** 遍历两个链表，对每一位进行相加，考虑进位，然后构建新的链表。

### 题目 11：最小栈

**题目描述：** 设计一个支持 push ，pop ，top 操作的栈，并能在常数时间内检索到栈的最小元素。

**示例：**
```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin(); --> 返回 -2.
```

**解答：**
```go
type MinStack struct {
    Stack  []*ListNode
    MinStack []*ListNode
}

/** initialize your data structure here. */
func Constructor() MinStack {
    return MinStack{make([]*ListNode, 0), make([]*ListNode, 0)}
}

func (this *MinStack) Push(val int) {
    node := &ListNode{Val: val}
    this.Stack = append(this.Stack, node)
    if len(this.MinStack) == 0 || val <= this.MinStack[len(this.MinStack)-1].Val {
        this.MinStack = append(this.MinStack, node)
    }
}

func (this *MinStack) Pop() {
    if this.Stack[len(this.Stack)-1].Val == this.MinStack[len(this.MinStack)-1].Val {
        this.MinStack = this.MinStack[:len(this.MinStack)-1]
    }
    this.Stack = this.Stack[:len(this.Stack)-1]
}

func (this *MinStack) Top() int {
    return this.Stack[len(this.Stack)-1].Val
}

func (this *MinStack) GetMin() int {
    return this.MinStack[len(this.MinStack)-1].Val
}
```

**解析：** 使用两个栈，一个用于存储所有元素，另一个用于存储当前最小元素。在 `push` 时，如果元素小于当前最小值，则将其加入最小值栈。在 `pop` 时，如果弹出的是当前最小值，则从最小值栈中弹出。

### 题目 12：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**解答：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 采用递归的方法，比较两个链表的当前节点，将较小的节点连接到结果链表，并递归处理剩余的链表。

### 题目 13：合并区间

**题目描述：** 以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。你需要合并所有重叠的区间，并返回一个不重叠的区间数组。

**示例：**
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**解答：**
```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for _, interval := range intervals[1:] {
        last := ans[len(ans)-1]
        if last[1] >= interval[0] {
            ans = append(ans, [2]int{last[0], max(last[1], interval[1])})
        } else {
            ans = append(ans, interval)
        }
    }
    return ans
}
```

**解析：** 首先对区间数组进行排序，然后遍历每个区间，如果当前区间与前一个区间有重叠，则合并它们；否则，将当前区间加入结果数组。

### 题目 14：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**解答：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(ans) && j < len(strs[i]); j++ {
            if ans[j] != strs[i][j] {
                ans = ans[:j]
                break
            }
        }
    }
    return ans
}
```

**解析：** 从第一个字符串开始，逐个字符比较后续字符串，一旦出现不同，则截取当前公共前缀。

### 题目 15：三数之和

**题目描述：** 给定一个包含 n 个整数的数组 `nums` ，判断 `nums` 中是否含有三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**解答：**
```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, len(nums)-1
        for l < r {
            s := nums[i] + nums[l] + nums[r]
            if s == 0 {
                ans = append(ans, []int{nums[i], nums[l], nums[r]})
                l++
                r--
                for l < r && nums[l] == nums[l-1] {
                    l++
                }
                for l < r && nums[r] == nums[r+1] {
                    r--
                }
            } else if s < 0 {
                l++
            } else {
                r--
            }
        }
    }
    return ans
}
```

**解析：** 首先对数组进行排序，然后使用双指针法遍历数组，固定第一个元素，然后移动左右指针，寻找满足条件的三元组。

### 题目 16：最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回它们的公共最长子序列的长度。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

**解答：**
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 使用动态规划构建一个二维数组 `dp` ，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。

### 题目 17：打家劫舍

**题目描述：** 你是一个专业的盗贼，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

**示例：**
```
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     不偷窃 2 号房屋 (因为它位于 1 号房屋和 3 号房屋之间)。
```

**解答：**
```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}
```

**解析：** 动态规划，`dp[i]` 表示在前 `i` 个房屋中能偷到的最大金额，状态转移方程为 `dp[i] = max(dp[i-1], dp[i-2]+nums[i])`。

### 题目 18：打家劫舍 II

**题目描述：** 在你抢劫上一道题目的过程中同时又被报警系统发现了，因此你被禁止进入某些房屋，这些房屋会作为一个数组 `禁忌房屋` 给出。返回你在禁止进入某些房屋的情况下能偷到的最大金额。

**示例：**
```
输入：nums = [2,3,2], prohibition := [2]
输出：3
解释：你 cannot 打家劫舍房屋 2 ，因此你只打家劫舍房屋 1 和第 3 间。
```

**解答：**
```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    if n == 2 {
        return max(nums[0], nums[1])
    }
    if contains(prohibition, n-1) {
        return rob(nums[:n-1])
    }
    return max(rob(nums[:n-1]), rob(nums[1:]))
}

func contains(prohibition []int, index int) bool {
    for _, v := range prohibition {
        if v == index {
            return true
        }
    }
    return false
}
```

**解析：** 如果最后一间房在禁忌房屋中，则问题转化为没有最后一间房的打家劫舍问题；否则，问题转化为去掉第一间或最后一间房的打家劫舍问题。

### 题目 19：翻转二叉树

**题目描述：** 翻转一棵二叉树。

**示例：**
```
输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9

输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**解答：**
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

**解析：** 递归翻转左右子树，然后交换左右子树。

### 题目 20：设计循环队列

**题目描述：** 设计你的循环队列结构。

**示例：**
```
MyCircularQueue(k): 构建长度为 k 的循环队列
Front(): 返回元素的前端
Rear(): 返回元素的尾端
enQueue(value): 向循环队列中插入一个元素。如果返回 true，则插入成功。
deQueue(): 从循环队列中删除一个元素。如果返回 true，则删除成功。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。
```

**解答：**
```go
type MyCircularQueue struct {
    arr []int
    head, tail, size int
}

func Constructor(k int) MyCircularQueue {
    return MyCircularQueue{make([]int, k+1), 0, 0, 0}
}

func (this *MyCircularQueue) Front() int {
    if this.isEmpty() {
        return -1
    }
    return this.arr[this.head]
}

func (this *MyCircularQueue) Rear() int {
    if this.isEmpty() {
        return -1
    }
    return this.arr[(this.tail+1)%len(this.arr)]
}

func (this *MyCircularQueue) enQueue(value int) bool {
    if this.isFull() {
        return false
    }
    this.arr[this.tail] = value
    this.tail = (this.tail + 1) % len(this.arr)
    this.size++
    return true
}

func (this *MyCircularQueue) deQueue() bool {
    if this.isEmpty() {
        return false
    }
    this.head = (this.head + 1) % len(this.arr)
    this.size--
    return true
}

func (this *MyCircularQueue) isEmpty() bool {
    return this.size == 0
}

func (this *MyCircularQueue) isFull() bool {
    return this.size == len(this.arr)
}
```

**解析：** 使用数组模拟循环队列，`head` 和 `tail` 分别表示队列的头和尾，`size` 表示队列中元素的数量。

### 题目 21：有效的括号字符串

**题目描述：** 给定一个只包含 '('、')' 和 '*' 的字符串 `s` ，检验是否有效。

**示例：**
```
输入："(*)()"
输出：true
解释：可以是 "(()())" 或 "()(*)"。
```

**解答：**
```go
func checkValidString(s string) bool {
    opens := 0
    for _, c := range s {
        if c == '(' || c == '*' {
            opens++
        } else {
            opens--
            if opens < 0 {
                return false
            }
        }
    }
    return opens == 0
}
```

**解析：** 使用计数器 `opens` 跟踪有效括号的数量，当遇到 `*` 时，它可以代替一个左括号。如果 `opens` 变为负数，说明左括号的数量已经小于右括号，返回 `false`。

### 题目 22：实现 Trie (前缀树)

**题目描述：** 实现一个 Trie (前缀树)，用来查找字符串的前缀。

**示例：**
```
实现 Trie trie = new Trie();
trie.insert("apple");
trie.search("app") -> false
trie.search("apple") -> true
trie.startsWith("app") -> true
trie.insert("app");
trie.search("app") -> true
```

**解答：**
```go
type Trie struct {
    children [26]*Trie
    isEnd    bool
}

func Constructor() Trie {
    return Trie{}
}

func (this *Trie) Insert(word string) {
    node := this
    for _, ch := range word {
        idx := int(ch - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &Trie{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
}

func (this *Trie) Search(word string) bool {
    node := this
    for _, ch := range word {
        idx := int(ch - 'a')
        if node.children[idx] == nil {
            return false
        }
        node = node.children[idx]
    }
    return node.isEnd
}

func (this *Trie) StartsWith(prefix string) bool {
    node := this
    for _, ch := range prefix {
        idx := int(ch - 'a')
        if node.children[idx] == nil {
            return false
        }
        node = node.children[idx]
    }
    return true
}
```

**解析：** 前缀树由节点组成，每个节点包含 26 个子节点，分别对应字母表的 26 个字母。在插入和查找过程中，根据字符的 ASCII 码计算子节点的索引。

### 题目 23：单词搜索

**题目描述：** 给定一个二维网格和一个单词，找出该单词是否存在于网格中。

**示例：**
```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

word = "ABCCED"
```

```
输出:
true
```

**解答：**
```go
func exist(board [][]byte, word string) bool {
    rows, cols := len(board), len(board[0])
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if dfs(board, i, j, word) {
                return true
            }
        }
    }
    return false
}

func dfs(board [][]byte, i, j int, word string) bool {
    if len(word) == 0 {
        return true
    }
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] != word[0] {
        return false
    }
    board[i][j] = byte(0)
    res := dfs(board, i+1, j, word[1:]) ||
        dfs(board, i-1, j, word[1:]) ||
        dfs(board, i, j+1, word[1:]) ||
        dfs(board, i, j-1, word[1:])
    board[i][j] = word[0]
    return res
}
```

**解析：** 使用深度优先搜索，从每个未访问的格子开始搜索，如果找到一个匹配的路径，则返回 `true`。

### 题目 24：有效的山脉数组

**题目描述：** 给定一个整数数组 `arr` ，如果它是有效的山脉数组就返回 `true`。

**示例：**
```
输入：
[2,1]
输出：
false
解释：
这个不是有效的山脉数组。

输入：
[3,5,5]
输出：
true
解释：
这是有效的山脉数组。
```

**解答：**
```go
func validMountainArray(arr []int) bool {
    n := len(arr)
    if n < 3 {
        return false
    }
    inc, dec := 0, 0
    for i := 1; i < n; i++ {
        if arr[i] > arr[i-1] {
            dec = 0
            inc++
            if inc == 2 {
                return arr[n-1] > arr[n-2]
            }
        } else if arr[i] < arr[i-1] {
            if inc == 0 {
                return false
            }
            dec++
        } else {
            return false
        }
    }
    return false
}
```

**解析：** 数组应该先递增然后递减，最后回到顶部。使用两个计数器 `inc` 和 `dec` 分别记录递增和递减的次数。

### 题目 25：合并两个排序的链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**解答：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 采用递归的方法，比较两个链表的当前节点，将较小的节点连接到结果链表，并递归处理剩余的链表。

### 题目 26：无重复字符的最长子串

**题目描述：** 给定一个字符串 `s` ，找出其中不含有重复字符的最长子串 `T` 的长度。

**示例：**
```
输入：s = "abcabcbb"
输出：3
解释：因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**解答：**
```go
func lengthOfLongestSubstring(s string) int {
    ans, j := 0, 0
    m := map[rune]int{}
    for i := 0; i < len(s); i++ {
        if m[s[i]] != 0 {
            j = max(j, m[s[i]])
        }
        ans = max(ans, i-j+1)
        m[s[i]] = i + 1
    }
    return ans
}
```

**解析：** 使用滑动窗口和哈希表，维护一个当前无重复字符的最长子串，每次遇到重复字符时，更新窗口的左边界。

### 题目 27：设计循环双端队列

**题目描述：** 设计你的循环双端队列结构。

**示例：**
```
MyCircularDeque(k): 构建长度为 k 的循环双端队列
insertFront(value): 向双端队列的头部插入一个值。如果放不下，返回 false 。 
insertLast(value): 向双端队列的尾部插入一个值。如果放不下，返回 false 。
deleteFront(): 删除双端队列头部的一个元素。如果双端队列为空，返回 false 。 
deleteLast(): 删除双端队列尾部的一个元素。如果双端队列为空，返回 false 。
getFront(): 从双端队列头部获取一个元素。如果双端队列为空，返回 -1 。
getRear(): 获取双端队列尾部一个元素。如果双端队列为空，返回 -1 。
isFull(): 返回双端队列是否满。
isEmpty(): 返回双端队列是否空。
```

**解答：**
```go
type MyCircularDeque struct {
    arr []int
    head, tail, size, capacity int
}

func Constructor(k int) MyCircularDeque {
    return MyCircularDeque{make([]int, k+1), 0, 0, 0, k}
}

func (this *MyCircularDeque) InsertFront(value int) bool {
    if this.isFull() {
        return false
    }
    this.head = (this.head - 1 + this.capacity) % this.capacity
    this.arr[this.head] = value
    this.size++
    return true
}

func (this *MyCircularDeque) InsertLast(value int) bool {
    if this.isFull() {
        return false
    }
    this.arr[this.tail] = value
    this.tail = (this.tail + 1) % this.capacity
    this.size++
    return true
}

func (this *MyCircularDeque) DeleteFront() bool {
    if this.isEmpty() {
        return false
    }
    this.head = (this.head + 1) % this.capacity
    this.size--
    return true
}

func (this *MyCircularDeque) DeleteLast() bool {
    if this.isEmpty() {
        return false
    }
    this.tail = (this.tail - 1 + this.capacity) % this.capacity
    this.size--
    return true
}

func (this *MyCircularDeque) GetFront() int {
    if this.isEmpty() {
        return -1
    }
    return this.arr[this.head]
}

func (this *MyCircularDeque) GetRear() int {
    if this.isEmpty() {
        return -1
    }
    return this.arr[(this.tail-1+this.capacity)%this.capacity]
}

func (this *MyCircularDeque) IsFull() bool {
    return this.size == this.capacity
}

func (this *MyCircularDeque) IsEmpty() bool {
    return this.size == 0
}
```

**解析：** 使用数组模拟循环双端队列，`head` 和 `tail` 分别表示队列的头和尾，`size` 和 `capacity` 分别表示队列中元素的数量和容量。

### 题目 28：给字符串添加加粗标签

**题目描述：** 给定一个没有加粗和斜体的字符串，添加加粗和斜体标签。

**示例：**
```
输入：s = "ab*cd*ef"
输出："<b>ab</b><i>cd</i><b>ef</b>"
```

**解答：**
```go
func addBoldTag(s string) string {
    n := len(s)
    bold := make([]bool, n)
    for i := 0; i < n; i++ {
        if s[i] == '*' {
            bold[i] = true
            if i > 0 {
                bold[i-1] = true
            }
            if i < n-1 {
                bold[i+1] = true
            }
        }
    }
    ans := ""
    for i := 0; i < n; i++ {
        if bold[i] {
            if i == 0 || !bold[i-1] {
                ans += "<b>"
            }
            ans += string(s[i])
            if i == n-1 || !bold[i+1] {
                ans += "</b>"
            }
        } else {
            ans += string(s[i])
        }
    }
    return ans
}
```

**解析：** 使用数组 `bold` 记录每个字符是否需要加粗，然后根据 `bold` 数组添加加粗标签。

### 题目 29：最大括号分数

**题目描述：** 给定一个只包含 '(' 和 ')' 的字符串，找到最长的括号子串的分数。

**示例：**
```
输入："(()))"
输出：6
解释：子串为 "(" + ")" + "(" + ")" + ")"，共6分。
```

**解答：**
```go
func maxScore(string s string) int {
    ans := 0
    stack := []int{}
    for _, c := range s {
        if c == '(' {
            stack = append(stack, 0)
        } else {
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            ans += top * 2
            if len(stack) > 0 {
                ans += stack[len(stack)-1] + 1
            }
            stack = append(stack, 1)
        }
    }
    return ans
}
```

**解析：** 使用栈记录左括号的数量，当遇到右括号时，计算当前子串的分数，并将其加入答案。

