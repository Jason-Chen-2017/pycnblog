                 

### 1. 2024 百度社招面试算法题库大全

本文为您整理了 2024 年百度社招面试中的高频算法题目和解析，涵盖了数据结构、算法、计算机基础等各个方面，旨在帮助您更好地应对面试挑战。

**题目 1：数组中和为特定值的组合**

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中所有和为目标值的非空连续子数组。

**示例：** 输入：`nums = [1,0,-1,0,-2,2]`，`target = 0`；输出：`[ [0], [1], [1, 2], [1, 2, 4], [0, 1], [0, 1, 2], [0, 1, 2, 4], [0, -1, 0], [0, -1, 0, 1], [0, -1, 0, 1, 2], [0, -1, 0, 1, 2, 4], [1, 2], [1, 2, 4], [2], [2, 4] ]`

**答案解析：**

```go
func combinationSum(nums []int, target int) [][]int {
    var res [][]int
    var dfs func(int, []int)
    dfs := func(t int, path []int) {
        if t == target {
            res = append(res, append([]int{}, path...))
            return
        }
        if t > target {
            return
        }
        for _, v := range nums {
            dfs(t+v, append(path, v))
        }
    }
    dfs(0, []int{})
    return res
}
```

**解析：** 本题使用深度优先搜索（DFS）算法，遍历数组中的每个数字，并将其与已存在的子数组组合，直到找到目标值。

**题目 2：最长公共子序列**

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**示例：** 输入：`text1 = "abcde"`，`text2 = "ace"`；输出："ace"

**答案解析：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    t := dp[m][n]
    ans := make([]byte, t)
    i, j := m, n
    for t > 0 {
        if text1[i-1] == text2[j-1] {
            ans[t-1] = text1[i-1]
            i--
            j--
            t--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(ans)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 本题使用动态规划（DP）算法，通过构建一个二维数组 `dp` 来记录最长公共子序列的长度，然后回溯求解最长公共子序列。

**题目 3：无重复字符的最长子串**

**题目描述：** 给定一个字符串 `s` ，找出其中不含有重复字符的最长子串。

**示例：** 输入："abcabcbb"；输出："abc"

**答案解析：**

```go
func lengthOfLongestSubstring(s string) int {
    m := make(map[rune]int)
    ans, j := 0, 0
    for i := 0; i < len(s); i++ {
        if m[s[i]] != 0 {
            j = max(j, m[s[i]]+1)
        }
        ans = max(ans, i-j+1)
        m[s[i]] = i
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 本题使用哈希表（map）来记录每个字符的最后出现位置，遍历字符串时，更新哈希表并计算当前无重复字符的最长子串长度。

**题目 4：合并两个有序链表**

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** 输入：`list1 = [1,2,4]`，`list2 = [1,3,4]`；输出：`[1,1,2,3,4,4]`

**答案解析：**

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    }
    list2.Next = mergeTwoLists(list1, list2.Next)
    return list2
}
```

**解析：** 本题使用递归算法，依次比较两个链表的头节点，将较小的节点链接到结果链表，并递归地处理剩余部分。

**题目 5：两数相加**

**题目描述：** 给出两个 非空 的链表表示两个非负的整数，每位数字都按照 逆序 的方式存储在链表中，将这两个数相加并返回一个新的链表。

**示例：** 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)；输出：7 -> 8 -> 0 -> 7

**答案解析：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    p, q, carry := dummy, l1, l2, 0
    for p != nil && q != nil {
        sum := carry + (p.Val + q.Val)
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p, q = p.Next, q.Next
    }
    for p != nil {
        sum := carry + p.Val
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p = p.Next
    }
    if carry > 0 {
        p = &ListNode{Val: carry}
        dummy.Next = p
    }
    return dummy.Next
}
```

**解析：** 本题首先将两个链表的数字进行相加，并处理进位。然后将结果链表返回。

**题目 6：最小栈**

**题目描述：** 设计一个支持 push ，pop ，top 操作的栈。

- push(x) —— 将元素 x 推到栈顶。
- pop() —— 删除栈顶元素。
- top() —— 获取栈顶元素。
- empty() —— 返回栈是否为空。

**示例：** 输入：`["MinStack","push","push","push","getMin","pop","top","getMin"]`，`[[],[-2],[0],[-3],[],[],[],[]]`；输出：`[null,null,null,null,-2,null,0,-2]`

**答案解析：**

```go
type MinStack struct {
    stk    []int
    mink   []int
}

func Constructor() MinStack {
    return MinStack{
        stk:   []int{},
        mink: []int{int(^uint(0) >> 1)},
    }
}

func (this *MinStack) Push(x int) {
    this.stk = append(this.stk, x)
    if x < this.mink[len(this.mink)-1] {
        this.mink = append(this.mink, x)
    } else {
        this.mink = append(this.mink, this.mink[len(this.mink)-1])
    }
}

func (this *MinStack) Pop() {
    this.mink = this.mink[:len(this.mink)-1]
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) Empty() bool {
    return len(this.stk) == 0
}

func (this *MinStack) GetMin() int {
    return this.mink[len(this.mink)-1]
}
```

**解析：** 本题使用两个栈 `stk` 和 `mink`，分别记录所有元素和当前最小元素。在 `push` 操作中，如果新元素小于当前最小元素，则更新最小元素；在 `pop` 操作中，将栈顶元素弹出，并更新最小元素。

**题目 7：下一个更大节点**

**题目描述：** 给每根节点为 `node` 的二叉树添加一个 `next`指针，使每个节点指向下一个更大的节点。初始化时，所有 `next` 指针都设置为 `null`。

**示例：** 输入：`[1,2,3,4,5]`；输出：`[1,#,2,3,#,4,5]`

**答案解析：**

```go
func connect(root *Node) *Node {
    if root == nil {
        return root
    }
    dfs(root.Left, root.Right)
    return root
}

func dfs(p, q *Node) {
    if p == nil || q == nil {
        return
    }
    p.Next = q
    dfs(p.Left, p.Right)
    dfs(p.Right, q.Left)
    dfs(p.Right, q.Right)
}
```

**解析：** 本题使用深度优先搜索（DFS）算法，依次遍历每个节点，将其 `next` 指针指向下一个更大的节点。

**题目 8：二叉树的层序遍历**

**题目描述：** 给定一个二叉树，返回其层序遍历结果。

**示例：** 输入：`[3,9,20,null,null,15,7]`；输出：`[[3],[9,20],[15,7]]`

**答案解析：**

```go
func levelOrder(root *TreeNode) [][]int {
    var ans [][]int
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        var t [][]int
        for _, node := range q {
            t = append(t, node.Val)
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, t)
        q = q[1:]
    }
    return ans
}
```

**解析：** 本题使用广度优先搜索（BFS）算法，通过队列实现二叉树的层序遍历。

**题目 9：两数之和**

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：** 输入：`[2,7,11,15]`，`target = 9`；输出：`[0,1]`

**答案解析：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, v := range nums {
        t := target - v
        if p, ok := m[t]; ok {
            return []int{p, i}
        }
        m[v] = i
    }
    return nil
}
```

**解析：** 本题使用哈希表（map）实现，遍历数组，查找是否存在一个元素与当前元素之和等于目标值。

**题目 10：有效的括号序列**

**题目描述：** 给出一个由 `'('`、`')'`、`'{'`、`'}'`、`'['`、`']'` 这些字符组成的字符串，判断字符串是否有效。

**示例：** 输入："()[]{}"；输出：true

**答案解析：**

```go
func isValid(s string) bool {
    stk := []rune{}
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    for _, v := range s {
        switch v {
        case '(', '{', '[':
            stk = append(stk, v)
        case ')', '}', ']':
            if len(stk) == 0 || stk[len(stk)-1] != m[v] {
                return false
            }
            stk = stk[:len(stk)-1]
        }
    }
    return len(stk) == 0
}
```

**解析：** 本题使用栈（stack）实现，遍历字符串，将左括号入栈，遇到右括号时，判断是否与栈顶元素匹配，否则返回 false。

**题目 11：字符串匹配**

**题目描述：** 给定一个字符串 `haystack` 和一个字串 `needle` ，从 `haystack` 字符串中找出第一个出现的 `needle` 字串的下标。

**示例：** 输入："sunday"，"un"；输出：0

**答案解析：**

```go
func strStr(haystack string, needle string) int {
    n, m := len(haystack), len(needle)
    if m == 0 {
        return 0
    }
    if n < m {
        return -1
    }
    for i := 0; i <= n-m; i++ {
        j := 0
        for ; j < m; j++ {
            if haystack[i+j] != needle[j] {
                break
            }
        }
        if j == m {
            return i
        }
    }
    return -1
}
```

**解析：** 本题使用暴力匹配算法，遍历字符串 `haystack`，对每个位置进行匹配，直到找到匹配的子串。

**题目 12：最长公共前缀**

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** 输入：`["flower","flow","flight"]`；输出："fl"

**答案解析：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for _, v := range strs[1:] {
        for i, w := 0, len(ans); i < w; i++ {
            if i >= len(v) || ans[i] != v[i] {
                ans = ans[:i]
                break
            }
        }
    }
    return ans
}
```

**解析：** 本题使用分治算法，首先选取第一个字符串作为公共前缀，然后依次与其他字符串进行比较，更新公共前缀。

**题目 13：两数相加**

**题目描述：** 给出两个 非空 的链表表示两个非负的整数，每位数字都按照 逆序 的方式存储在链表中，将这两个数相加并返回一个新的链表。

**示例：** 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)；输出：7 -> 8 -> 0 -> 7

**答案解析：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    p, q, carry := dummy, l1, l2, 0
    for p != nil && q != nil {
        sum := carry + (p.Val + q.Val)
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p, q = p.Next, q.Next
    }
    for p != nil {
        sum := carry + p.Val
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p = p.Next
    }
    if carry > 0 {
        p = &ListNode{Val: carry}
        dummy.Next = p
    }
    return dummy.Next
}
```

**解析：** 本题首先将两个链表的数字进行相加，并处理进位。然后将结果链表返回。

**题目 14：有效的括号**

**题目描述：** 给定一个包含大括号`{}`、小括号`()`、中括号`[]`的字符串，判断字符串是否有效。

**示例：** 输入："()[]"；输出：true

**答案解析：**

```go
func isValid(s string) bool {
    stk := []rune{}
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    for _, v := range s {
        switch v {
        case '(', '{', '[':
            stk = append(stk, v)
        case ')', '}', ']':
            if len(stk) == 0 || stk[len(stk)-1] != m[v] {
                return false
            }
            stk = stk[:len(stk)-1]
        }
    }
    return len(stk) == 0
}
```

**解析：** 本题使用栈（stack）实现，遍历字符串，将左括号入栈，遇到右括号时，判断是否与栈顶元素匹配，否则返回 false。

**题目 15：寻找旋转排序数组中的最小值**

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例：** 输入：`[3,4,5,1,2]`；输出：`1`

**答案解析：**

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        mid := (l + r) / 2
        if nums[mid] > nums[r] {
            l = mid + 1
        } else {
            r = mid
        }
    }
    return nums[l]
}
```

**解析：** 本题使用二分查找（binary search）算法，找到旋转数组的分界点，即最小值的位置。

**题目 16：链表中倒数第k个节点**

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**示例：** 输入：`[1,2,3,4,5]`，k = 2；输出：节点值为 4

**答案解析：**

```go
func getKthFromEnd(head *ListNode, k int) *ListNode {
    fast, slow := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

**解析：** 本题使用快慢指针（fast 和 slow）算法，先让快指针前进 k 个节点，然后快慢指针同时前进，直到快指针到达链表末尾，此时慢指针即为倒数第 k 个节点。

**题目 17：最大子序和**

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**示例：** 输入：`[-2,1,-3,4,-1,2,1,-5,4]`；输出：6

**答案解析：**

```go
func maxSubArray(nums []int) int {
    ans, prev := nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        prev = max(prev+nums[i], nums[i])
        ans = max(ans, prev)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 本题使用动态规划（dynamic programming）算法，维护一个前缀和 `prev`，每次更新最大子序和 `ans`。

**题目 18：数组中重复的数字**

**题目描述：** 在一个长度为 n 的数组 `nums` 里的所有数字都在 0 到 n-1 的范围内，找出数组中任意一个重复的数字。

**示例：** 输入：`[2,3,1,0,2,5,3]`；输出：2 或 3

**答案解析：**

```go
func findRepeatNumber(nums []int) int {
    n := len(nums)
    for i := 0; i < n; i++ {
        for nums[i] != i {
            if nums[i] == nums[n-1] {
                return nums[i]
            }
            t := nums[i]
            nums[i], nums[t] = nums[t], nums[i]
        }
    }
    return -1
}
```

**解析：** 本题使用原地交换算法，遍历数组，将每个元素交换到其正确的位置。如果有重复元素，则返回重复的数字。

**题目 19：斐波那契数列**

**题目描述：** 斐波那契数列如下：

```
F(0) = 0,
F(1) = 1,
F(n) = F(n - 1) + F(n - 2) (n > 1).
```

**示例：** 输入：`n = 5`；输出：`5`

**答案解析：**

```go
func fib(n int) int {
    if n == 0 || n == 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 本题使用迭代算法，计算斐波那契数列的第 n 项。

**题目 20：合并两个有序链表**

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** 输入：`list1 = [1,2,4]`，`list2 = [1,3,4]`；输出：`[1,1,2,3,4,4]`

**答案解析：**

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    }
    list2.Next = mergeTwoLists(list1, list2.Next)
    return list2
}
```

**解析：** 本题使用递归算法，依次比较两个链表的头节点，将较小的节点链接到结果链表，并递归地处理剩余部分。

### 2. 2024 百度社招面试算法题库解析

**题目 1：数组中和为特定值的组合**

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中所有和为目标值的非空连续子数组。

**解析：** 本题使用深度优先搜索（DFS）算法，遍历数组中的每个数字，并将其与已存在的子数组组合，直到找到目标值。

```go
func combinationSum(nums []int, target int) [][]int {
    var res [][]int
    var dfs func(int, []int)
    dfs := func(t int, path []int) {
        if t == target {
            res = append(res, append([]int{}, path...))
            return
        }
        if t > target {
            return
        }
        for _, v := range nums {
            dfs(t+v, append(path, v))
        }
    }
    dfs(0, []int{})
    return res
}
```

**题目 2：最长公共子序列**

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**解析：** 本题使用动态规划（DP）算法，通过构建一个二维数组 `dp` 来记录最长公共子序列的长度，然后回溯求解最长公共子序列。

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    t := dp[m][n]
    ans := make([]byte, t)
    i, j := m, n
    for t > 0 {
        if text1[i-1] == text2[j-1] {
            ans[t-1] = text1[i-1]
            i--
            j--
            t--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(ans)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**题目 3：无重复字符的最长子串**

**题目描述：** 给定一个字符串 `s` ，找出其中不含有重复字符的最长子串。

**解析：** 本题使用哈希表（map）来记录每个字符的最后出现位置，遍历字符串时，更新哈希表并计算当前无重复字符的最长子串长度。

```go
func lengthOfLongestSubstring(s string) int {
    m := make(map[rune]int)
    ans, j := 0, 0
    for i := 0; i < len(s); i++ {
        if m[s[i]] != 0 {
            j = max(j, m[s[i]]+1)
        }
        ans = max(ans, i-j+1)
        m[s[i]] = i
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**题目 4：合并两个有序链表**

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**解析：** 本题使用递归算法，依次比较两个链表的头节点，将较小的节点链接到结果链表，并递归地处理剩余部分。

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    }
    list2.Next = mergeTwoLists(list1, list2.Next)
    return list2
}
```

**题目 5：两数相加**

**题目描述：** 给出两个 非空 的链表表示两个非负的整数，每位数字都按照 逆序 的方式存储在链表中，将这两个数相加并返回一个新的链表。

**解析：** 本题首先将两个链表的数字进行相加，并处理进位。然后将结果链表返回。

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    p, q, carry := dummy, l1, l2, 0
    for p != nil && q != nil {
        sum := carry + (p.Val + q.Val)
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p, q = p.Next, q.Next
    }
    for p != nil {
        sum := carry + p.Val
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p = p.Next
    }
    if carry > 0 {
        p = &ListNode{Val: carry}
        dummy.Next = p
    }
    return dummy.Next
}
```

**题目 6：最小栈**

**题目描述：** 设计一个支持 push ，pop ，top 操作的栈。

- push(x) —— 将元素 x 推到栈顶。
- pop() —— 删除栈顶元素。
- top() —— 获取栈顶元素。
- empty() —— 返回栈是否为空。

**解析：** 本题使用两个栈 `stk` 和 `mink`，分别记录所有元素和当前最小元素。在 `push` 操作中，如果新元素小于当前最小元素，则更新最小元素；在 `pop` 操作中，将栈顶元素弹出，并更新最小元素。

```go
type MinStack struct {
    stk    []int
    mink   []int
}

func Constructor() MinStack {
    return MinStack{
        stk:   []int{},
        mink: []int{int(^uint(0) >> 1)},
    }
}

func (this *MinStack) Push(x int) {
    this.stk = append(this.stk, x)
    if x < this.mink[len(this.mink)-1] {
        this.mink = append(this.mink, x)
    } else {
        this.mink = append(this.mink, this.mink[len(this.mink)-1])
    }
}

func (this *MinStack) Pop() {
    this.mink = this.mink[:len(this.mink)-1]
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) Empty() bool {
    return len(this.stk) == 0
}

func (this *MinStack) GetMin() int {
    return this.mink[len(this.mink)-1]
}
```

**题目 7：下一个更大节点**

**题目描述：** 给出二叉树的根节点 `root` ，每个节点都包含一个值为 `val` 的整数，初始化时，这些节点值为 `0` 。

树中的 节点 `node` 的 任意 右侧节点 `node.right` 都具有 `val >= node.val` 的值。树中的 节点 `node` 的 任意 左侧节点 `node.left` 都具有 `val <= node.val` 的值。

请你找出满足该条件的节点，并返回它们中的最小索引（最靠左侧的节点）。

**示例：** 输入：`[1,2,3,null,5,null,4]`；输出：2

**解析：** 本题使用深度优先搜索（DFS）算法，遍历每个节点，找到第一个满足条件的节点。

```go
func getNodes(root *TreeNode) []int {
    ans := []int{}
    dfs(root, &ans)
    return ans
}

func dfs(root *TreeNode, ans *[]int) {
    if root == nil {
        return
    }
    if root.Right == nil && root.Val < root.Left.Val {
        *ans = append(*ans, root.Val)
        return
    }
    dfs(root.Left, ans)
    dfs(root.Right, ans)
}
```

**题目 8：二叉树的层序遍历**

**题目描述：** 给定一个二叉树，返回其节点值的层序遍历。

**示例：** 输入：`[3,9,20,null,null,15,7]`；输出：`[[3],[9,20],[15,7]]`

**解析：** 本题使用广度优先搜索（BFS）算法，通过队列实现二叉树的层序遍历。

```go
func levelOrder(root *TreeNode) [][]int {
    var ans [][]int
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        var t [][]int
        for _, node := range q {
            t = append(t, node.Val)
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, t)
        q = q[1:]
    }
    return ans
}
```

**题目 9：两数之和**

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：** 输入：`[2,7,11,15]`，`target = 9`；输出：`[0,1]`

**解析：** 本题使用哈希表（map）实现，遍历数组，查找是否存在一个元素与当前元素之和等于目标值。

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, v := range nums {
        t := target - v
        if p, ok := m[t]; ok {
            return []int{p, i}
        }
        m[v] = i
    }
    return nil
}
```

**题目 10：有效的括号序列**

**题目描述：** 给出一个由 `'('`、`')'`、`'{'`、`'}'`、`'['`、`']'` 这些字符组成的字符串，判断字符串是否有效。

**示例：** 输入："()[]"；输出：true

**解析：** 本题使用栈（stack）实现，遍历字符串，将左括号入栈，遇到右括号时，判断是否与栈顶元素匹配，否则返回 false。

```go
func isValid(s string) bool {
    stk := []rune{}
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    for _, v := range s {
        switch v {
        case '(', '{', '[':
            stk = append(stk, v)
        case ')', '}', ']':
            if len(stk) == 0 || stk[len(stk)-1] != m[v] {
                return false
            }
            stk = stk[:len(stk)-1]
        }
    }
    return len(stk) == 0
}
```

**题目 11：字符串匹配**

**题目描述：** 给定一个字符串 `haystack` 和一个字串 `needle` ，从 `haystack` 字符串中找出第一个出现的 `needle` 字串的下标。

**示例：** 输入："sunday"，"un"；输出：0

**解析：** 本题使用暴力匹配算法，遍历字符串 `haystack`，对每个位置进行匹配，直到找到匹配的子串。

```go
func strStr(haystack string, needle string) int {
    n, m := len(haystack), len(needle)
    if m == 0 {
        return 0
    }
    if n < m {
        return -1
    }
    for i := 0; i <= n-m; i++ {
        j := 0
        for ; j < m; j++ {
            if haystack[i+j] != needle[j] {
                break
            }
        }
        if j == m {
            return i
        }
    }
    return -1
}
```

**题目 12：最长公共前缀**

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** 输入：`["flower","flow","flight"]`；输出："fl"

**解析：** 本题使用分治算法，首先选取第一个字符串作为公共前缀，然后依次与其他字符串进行比较，更新公共前缀。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for _, v := range strs[1:] {
        for i, w := 0, len(ans); i < w; i++ {
            if i >= len(v) || ans[i] != v[i] {
                ans = ans[:i]
                break
            }
        }
    }
    return ans
}
```

**题目 13：两数相加**

**题目描述：** 给出两个 非空 的链表表示两个非负的整数，每位数字都按照 逆序 的方式存储在链表中，将这两个数相加并返回一个新的链表。

**示例：** 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)；输出：7 -> 8 -> 0 -> 7

**解析：** 本题首先将两个链表的数字进行相加，并处理进位。然后将结果链表返回。

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    p, q, carry := dummy, l1, l2, 0
    for p != nil && q != nil {
        sum := carry + (p.Val + q.Val)
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p, q = p.Next, q.Next
    }
    for p != nil {
        sum := carry + p.Val
        carry = 0
        if sum >= 10 {
            sum -= 10
            carry = 1
        }
        p.Val = sum
        p = p.Next
    }
    if carry > 0 {
        p = &ListNode{Val: carry}
        dummy.Next = p
    }
    return dummy.Next
}
```

**题目 14：有效的括号**

**题目描述：** 给定一个包含大括号`{}`、小括号`()`、中括号`[]`的字符串，判断字符串是否有效。

**示例：** 输入："()[]"；输出：true

**解析：** 本题使用栈（stack）实现，遍历字符串，将左括号入栈，遇到右括号时，判断是否与栈顶元素匹配，否则返回 false。

```go
func isValid(s string) bool {
    stk := []rune{}
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    for _, v := range s {
        switch v {
        case '(', '{', '[':
            stk = append(stk, v)
        case ')', '}', ']':
            if len(stk) == 0 || stk[len(stk)-1] != m[v] {
                return false
            }
            stk = stk[:len(stk)-1]
        }
    }
    return len(stk) == 0
}
```

**题目 15：寻找旋转排序数组中的最小值**

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例：** 输入：`[3,4,5,1,2]`；输出：`1`

**解析：** 本题使用二分查找（binary search）算法，找到旋转数组的分界点，即最小值的位置。

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        mid := (l + r) / 2
        if nums[mid] > nums[r] {
            l = mid + 1
        } else {
            r = mid
        }
    }
    return nums[l]
}
```

**题目 16：链表中倒数第k个节点**

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**示例：** 输入：`[1,2,3,4,5]`，k = 2；输出：节点值为 4

**解析：** 本题使用快慢指针（fast 和 slow）算法，先让快指针前进 k 个节点，然后快慢指针同时前进，直到快指针到达链表末尾，此时慢指针即为倒数第 k 个节点。

```go
func getKthFromEnd(head *ListNode, k int) *ListNode {
    fast, slow := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

**题目 17：最大子序和**

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**示例：** 输入：`[-2,1,-3,4,-1,2,1,-5,4]`；输出：`6`

**解析：** 本题使用动态规划（dynamic programming）算法，维护一个前缀和 `prev`，每次更新最大子序和 `ans`。

```go
func maxSubArray(nums []int) int {
    ans, prev := nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        prev = max(prev+nums[i], nums[i])
        ans = max(ans, prev)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**题目 18：数组中重复的数字**

**题目描述：** 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内，找出数组中任意一个重复的数字。

**示例：** 输入：`[2,3,1,0,2,5,3]`；输出：2 或 3

**解析：** 本题使用原地交换算法，遍历数组，将每个元素交换到其正确的位置。如果有重复元素，则返回重复的数字。

```go
func findRepeatNumber(nums []int) int {
    n := len(nums)
    for i := 0; i < n; i++ {
        for nums[i] != i {
            if nums[i] == nums[n-1] {
                return nums[i]
            }
            t := nums[i]
            nums[i], nums[t] = nums[t], nums[i]
        }
    }
    return -1
}
```

**题目 19：斐波那契数列**

**题目描述：** 斐波那契数列如下：

```
F(0) = 0,
F(1) = 1,
F(n) = F(n - 1) + F(n - 2) (n > 1).
```

**示例：** 输入：`n = 5`；输出：`5`

**解析：** 本题使用迭代算法，计算斐波那契数列的第 n 项。

```go
func fib(n int) int {
    if n == 0 || n == 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**题目 20：合并两个有序链表**

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** 输入：`list1 = [1,2,4]`，`list2 = [1,3,4]`；输出：`[1,1,2,3,4,4]`

**解析：** 本题使用递归算法，依次比较两个链表的头节点，将较小的节点链接到结果链表，并递归地处理剩余部分。

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    if list1 == nil {
        return list2
    }
    if list2 == nil {
        return list1
    }
    if list1.Val < list2.Val {
        list1.Next = mergeTwoLists(list1.Next, list2)
        return list1
    }
    list2.Next = mergeTwoLists(list1, list2.Next)
    return list2
}
```

### 3. 2024 百度社招面试算法题库总结

通过本文，我们总结了 2024 年百度社招面试中的一些高频算法题目，包括数组、链表、字符串、二叉树等数据结构和算法的典型问题。这些问题在面试中经常出现，掌握这些题目有助于提高您的面试通过率。

在解答这些题目时，我们主要使用了以下算法：

1. **深度优先搜索（DFS）**：适用于需要遍历整棵树的题目，如最长公共子序列、合并两个有序链表等。
2. **广度优先搜索（BFS）**：适用于需要层次遍历树的题目，如二叉树的层序遍历。
3. **动态规划（DP）**：适用于需要计算最长子序列、最长公共子序列等题目。
4. **哈希表（map）**：适用于需要查找、统计等操作的题目，如两数之和、有效的括号序列等。
5. **二分查找（binary search）**：适用于需要快速查找某个值的题目，如寻找旋转排序数组中的最小值。

希望本文对您备战百度社招面试有所帮助，祝您面试成功！如果您还有其他问题，欢迎在评论区留言，我们将持续为您解答。

