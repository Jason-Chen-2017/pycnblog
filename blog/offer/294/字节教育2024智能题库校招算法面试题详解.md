                 

### 字节教育2024智能题库校招算法面试题详解

#### 目录

1. [两数之和](#1-两数之和)
2. [最长公共前缀](#2-最长公共前缀)
3. [无重复字符的最长子串](#3-无重复字符的最长子串)
4. [环形链表](#4-环形链表)
5. [二叉树的遍历](#5-二叉树的遍历)
6. [合并两个有序链表](#6-合并两个有序链表)
7. [单调栈](#7-单调栈)
8. [单调队列](#8-单调队列)
9. [二分查找](#9-二分查找)
10. [动态规划](#10-动态规划)
11. [贪心算法](#11-贪心算法)
12. [快速排序](#12-快速排序)
13. [归并排序](#13-归并排序)
14. [希尔排序](#14-希尔排序)
15. [计数排序](#15-计数排序)
16. [基数排序](#16-基数排序)
17. [拓扑排序](#17-拓扑排序)
18. [并查集](#18-并查集)
19. [深度优先搜索](#19-深度优先搜索)
20. [广度优先搜索](#20-广度优先搜索)

---

#### 1. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**
```plaintext
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9，返回 [0, 1]。
```

**答案解析：**
- 使用哈希表存储数组中的元素及其索引，遍历数组，对于当前元素 `x`，计算 `target - x`，在哈希表中查找是否存在该值，如果存在则返回当前索引和哈希表中对应的索引。
- 时间复杂度：O(n)，空间复杂度：O(n)。

**代码示例：**
```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return []int{}
}
```

---

#### 2. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```plaintext
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案解析：**
- 两两比较字符串，取公共前缀的最小值。
- 时间复杂度：O(n*m)，空间复杂度：O(1)。

**代码示例：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

---

#### 3. 无重复字符的最长子串

**题目：** 给定一个字符串 `s` ，找出其中不含有重复字符的最长子串 `T` 的长度。

**示例：**
```plaintext
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**答案解析：**
- 使用滑动窗口和哈希表记录字符出现的最后一个位置。
- 时间复杂度：O(n)，空间复杂度：O(n)。

**代码示例：**
```go
func lengthOfLongestSubstring(s string) int {
    last := make(map[rune]int)
    start, ans := 0, 0
    for i, v := range s {
        if last[v] >= start {
            start = last[v] + 1
        }
        last[v] = i
        if ans < i-start+1 {
            ans = i - start + 1
        }
    }
    return ans
}
```

---

#### 4. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**示例：**
```plaintext
输入：head = [3, 2, 0, -4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**答案解析：**
- 使用快慢指针，快指针每次移动两步，慢指针每次移动一步，如果有环，则快指针会追上慢指针。
- 时间复杂度：O(n)，空间复杂度：O(1)。

**代码示例：**
```go
func hasCycle(head *ListNode) bool {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            return true
        }
    }
    return false
}
```

---

#### 5. 二叉树的遍历

**题目：** 二叉树的遍历有哪几种方法？

- 前序遍历
- 中序遍历
- 后序遍历
- 层序遍历（广度优先搜索）

**示例：** 给定二叉树：

```plaintext
    1
   / \
  2   3
 / \ / \
4  5 6  7
```

**答案解析：**
- 前序遍历：1, 2, 4, 5, 3, 6, 7
- 中序遍历：4, 2, 5, 1, 6, 3, 7
- 后序遍历：4, 5, 2, 6, 7, 3, 1
- 层序遍历：1, 2, 3, 4, 5, 6, 7

**代码示例：**
```go
// 前序遍历
func preorderTraversal(root *TreeNode) []int {
    var ans []int
    dfs := func(node *TreeNode) {
        if node == nil {
            return
        }
        ans = append(ans, node.Val)
        dfs(node.Left)
        dfs(node.Right)
    }
    dfs(root)
    return ans
}

// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    var ans []int
    dfs := func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        ans = append(ans, node.Val)
        dfs(node.Right)
    }
    dfs(root)
    return ans
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    var ans []int
    dfs := func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        dfs(node.Right)
        ans = append(ans, node.Val)
    }
    dfs(root)
    return ans
}

// 层序遍历
func levelOrder(root *TreeNode) [][]int {
    ans := [][]int{}
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        level := []int{}
        for i := 0; i < len(q); i++ {
            node := q[0]
            level = append(level, node.Val)
            q = q[1:]
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, level)
    }
    return ans
}
```

---

#### 6. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```plaintext
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]
```

**答案解析：**
- 使用迭代或递归，比较两个链表的头节点，选择较小值作为新链表的头节点，然后递归或迭代处理剩余部分。
- 时间复杂度：O(n+m)，空间复杂度：O(1)。

**代码示例：**
```go
// 迭代
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    prev := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            prev.Next = l1
            l1 = l1.Next
        } else {
            prev.Next = l2
            l2 = l2.Next
        }
        prev = prev.Next
    }
    if l1 != nil {
        prev.Next = l1
    }
    if l2 != nil {
        prev.Next = l2
    }
    return dummy.Next
}

// 递归
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

---

#### 7. 单调栈

**题目：** 单调栈是一种数据结构，它保持元素的顺序要么递增要么递减。实现一个单调栈，支持以下操作：push(x)、pop()、top() 和 empty()。

**示例：**
```plaintext
push(1)
push(2)
top() -> 返回 2
pop() -> 返回 2
empty() -> 返回 False
```

**答案解析：**
- 单调递增栈：每次 push 时，如果栈不为空且新元素小于栈顶元素，则 pop 出栈直到满足单调递增。
- 单调递减栈：每次 push 时，如果栈不为空且新元素大于栈顶元素，则 pop 出栈直到满足单调递减。
- 时间复杂度：O(n)，空间复杂度：O(n)。

**代码示例：**
```go
// 单调递增栈
type MonotonicStack struct {
    stack []int
}

func NewMonotonicStack() *MonotonicStack {
    return &MonotonicStack{stack: []int{}}
}

func (s *MonotonicStack) Push(x int) {
    for len(s.stack) > 0 && s.stack[len(s.stack)-1] < x {
        s.Pop()
    }
    s.stack = append(s.stack, x)
}

func (s *MonotonicStack) Pop() {
    if len(s.stack) > 0 {
        s.stack = s.stack[:len(s.stack)-1]
    }
}

func (s *MonotonicStack) Top() int {
    if len(s.stack) > 0 {
        return s.stack[len(s.stack)-1]
    }
    return -1
}

func (s *MonotonicStack) Empty() bool {
    return len(s.stack) == 0

}

// 单调递减栈
type MonotonicStack struct {
    stack []int
}

func NewMonotonicStack() *MonotonicStack {
    return &MonotonicStack{stack: []int{}}
}

func (s *MonotonicStack) Push(x int) {
    for len(s.stack) > 0 && s.stack[len(s.stack)-1] > x {
        s.Pop()
    }
    s.stack = append(s.stack, x)
}

func (s *MonotonicStack) Pop() {
    if len(s.stack) > 0 {
        s.stack = s.stack[:len(s.stack)-1]
    }
}

func (s *MonotonicStack) Top() int {
    if len(s.stack) > 0 {
        return s.stack[len(s.stack)-1]
    }
    return -1
}

func (s *MonotonicStack) Empty() bool {
    return len(s.stack) == 0
}
```

---

#### 8. 单调队列

**题目：** 单调队列是一种数据结构，它保持元素的顺序要么递增要么递减。实现一个单调队列，支持以下操作：push(x)、pop()、top() 和 empty()。

**示例：**
```plaintext
push(1)
push(3)
push(2)
top() -> 返回 3
pop() -> 返回 3
empty() -> 返回 False
```

**答案解析：**
- 使用双端队列实现单调递增队列，每次 push 时，如果新元素大于队尾元素，则 pop 出队直到满足单调递增。
- 使用双端队列实现单调递减队列，每次 push 时，如果新元素小于队尾元素，则 pop 出队直到满足单调递减。
- 时间复杂度：O(n)，空间复杂度：O(n)。

**代码示例：**
```go
// 单调递增队列
type MonotonicQueue struct {
    queue []int
}

func NewMonotonicQueue() *MonotonicQueue {
    return &MonotonicQueue{queue: []int{}}
}

func (s *MonotonicQueue) Push(x int) {
    for len(s.queue) > 0 && s.queue[len(s.queue)-1] < x {
        s.Pop()
    }
    s.queue = append(s.queue, x)
}

func (s *MonotonicQueue) Pop() {
    if len(s.queue) > 0 {
        s.queue = s.queue[:len(s.queue)-1]
    }
}

func (s *MonotonicQueue) Top() int {
    if len(s.queue) > 0 {
        return s.queue[len(s.queue)-1]
    }
    return -1
}

func (s *MonotonicQueue) Empty() bool {
    return len(s.queue) == 0
}

// 单调递减队列
type MonotonicQueue struct {
    queue []int
}

func NewMonotonicQueue() *MonotonicQueue {
    return &MonotonicQueue{queue: []int{}}
}

func (s *MonotonicQueue) Push(x int) {
    for len(s.queue) > 0 && s.queue[len(s.queue)-1] > x {
        s.Pop()
    }
    s.queue = append(s.queue, x)
}

func (s *MonotonicQueue) Pop() {
    if len(s.queue) > 0 {
        s.queue = s.queue[:len(s.queue)-1]
    }
}

func (s *MonotonicQueue) Top() int {
    if len(s.queue) > 0 {
        return s.queue[len(s.queue)-1]
    }
    return -1
}

func (s *MonotonicQueue) Empty() bool {
    return len(s.queue) == 0
}
```

---

#### 9. 二分查找

**题目：** 实现一个二分查找算法，用于在一个排序数组中查找某个元素。

**示例：**
```plaintext
输入：nums = [-1, 0, 3, 5, 9, 12], target = 9
输出：4
解释：9 存储在数组中的索引是 4。
```

**答案解析：**
- 使用二分查找算法，不断缩小区间，直到找到目标元素或确定不存在。
- 时间复杂度：O(log n)，空间复杂度：O(1)。

**代码示例：**
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

---

#### 10. 动态规划

**题目：** 使用动态规划算法求解斐波那契数列。

**示例：**
```plaintext
输入：n = 10
输出：55
```

**答案解析：**
- 动态规划的核心是状态转移方程，斐波那契数列的状态转移方程为 `F(n) = F(n-1) + F(n-2)`。
- 时间复杂度：O(n)，空间复杂度：O(1)。

**代码示例：**
```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    prev2, prev1 := 0, 1
    for i := 2; i <= n; i++ {
        curr := prev1 + prev2
        prev2 = prev1
        prev1 = curr
    }
    return prev1
}
```

---

#### 11. 贪心算法

**题目：** 使用贪心算法求解背包问题。

**示例：**
```plaintext
给定： weights = [1, 3, 4], values = [1, 4, 5], capacity = 7
输出： 9
解释： 选择重量为 1 和 4 的物品，总价值为 9。
```

**答案解析：**
- 背包问题的贪心策略是选择单位重量价值最大的物品。
- 时间复杂度：O(n)，空间复杂度：O(1)。

**代码示例：**
```go
func knapsack(values []int, weights []int, capacity int) int {
    n := len(values)
    index := make([]int, n)
    for i := range index {
        index[i] = i
    }
    sort.Slice(index, func(i, j int) bool {
        return weights[index[i]]*values[index[j]] > weights[index[j]]*values[index[i]]
    })
    totalValue, totalWeight := 0, 0
    for _, i := range index {
        if totalWeight+weights[i] <= capacity {
            totalValue += values[i]
            totalWeight += weights[i]
        } else {
            remainingCapacity := capacity - totalWeight
            totalValue += values[i] * (float64(remainingCapacity) / float64(weights[i]))
            break
        }
    }
    return int(totalValue)
}
```

---

#### 12. 快速排序

**题目：** 使用快速排序算法对数组进行排序。

**示例：**
```plaintext
输入：nums = [5, 2, 9, 1]
输出：[1, 2, 5, 9]
```

**答案解析：**
- 快速排序的核心是 partition 操作，选择一个基准元素，将数组分为两部分，左侧小于基准元素，右侧大于基准元素。
- 时间复杂度：O(n*log n)，空间复杂度：O(log n)。

**代码示例：**
```go
func quickSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }
    pivot := nums[len(nums)/2]
    left, right := 0, len(nums)-1
    for {
        for nums[left] < pivot {
            left++
        }
        for nums[right] > pivot {
            right--
        }
        if left >= right {
            break
        }
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
    quickSort(nums[:left])
    quickSort(nums[left:])
    return nums
}
```

---

#### 13. 归并排序

**题目：** 使用归并排序算法对数组进行排序。

**示例：**
```plaintext
输入：nums = [5, 2, 9, 1]
输出：[1, 2, 5, 9]
```

**答案解析：**
- 归并排序的核心是合并操作，将两个有序数组合并为一个有序数组。
- 时间复杂度：O(n*log n)，空间复杂度：O(n)。

**代码示例：**
```go
func mergeSort(nums []int) []int {
    if len(nums) <= 1 {
        return nums
    }
    mid := len(nums) / 2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    ans := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            ans = append(ans, left[i])
            i++
        } else {
            ans = append(ans, right[j])
            j++
        }
    }
    ans = append(ans, left[i:]...)
    ans = append(ans, right[j:]...)
    return ans
}
```

---

#### 14. 希尔排序

**题目：** 使用希尔排序算法对数组进行排序。

**示例：**
```plaintext
输入：nums = [5, 2, 9, 1]
输出：[1, 2, 5, 9]
```

**答案解析：**
- 希尔排序是插入排序的改进版，它首先将数组分为多个子数组，分别进行插入排序，然后逐渐减小子数组的间隔，直到间隔为 1。
- 时间复杂度：O(n*log n)~O(n^2)，空间复杂度：O(1)。

**代码示例：**
```go
func shellSort(nums []int) {
    n := len(nums)
    gap := n / 2
    for gap > 0 {
        for i := gap; i < n; i++ {
            temp := nums[i]
            j := i
            for j-gap >= 0 && nums[j-gap] > temp {
                nums[j] = nums[j-gap]
                j -= gap
            }
            nums[j] = temp
        }
        gap /= 2
    }
}
```

---

#### 15. 计数排序

**题目：** 使用计数排序算法对数组进行排序。

**示例：**
```plaintext
输入：nums = [5, 2, 9, 1]
输出：[1, 2, 5, 9]
```

**答案解析：**
- 计数排序的核心思想是计数每个元素出现的次数，然后按照计数结果排序。
- 时间复杂度：O(n+k)，空间复杂度：O(n+k)，其中 k 是数组的范围。

**代码示例：**
```go
func countingSort(nums []int) []int {
    maxVal := math.MinInt
    for _, num := range nums {
        if num > maxVal {
            maxVal = num
        }
    }
    count := make([]int, maxVal+1)
    for _, num := range nums {
        count[num]++
    }
    ans := make([]int, 0, len(nums))
    for i, cnt := range count {
        for cnt > 0 {
            ans = append(ans, i)
            cnt--
        }
    }
    return ans
}
```

---

#### 16. 基数排序

**题目：** 使用基数排序算法对数组进行排序。

**示例：**
```plaintext
输入：nums = [5, 2, 9, 1]
输出：[1, 2, 5, 9]
```

**答案解析：**
- 基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数进行比较排序。
- 时间复杂度：O(d*(n+k))，空间复杂度：O(n+k)，其中 d 是数字位数，k 是基数（通常为 10 或 2）。

**代码示例：**
```go
func countingSortByDigit(nums []int, exp int) []int {
    maxVal := math.MinInt
    for _, num := range nums {
        if num > maxVal {
            maxVal = num
        }
    }
    count := make([]int, 10)
    output := make([]int, 0, len(nums))
    for _, num := range nums {
        count[(num/exp)%10]++
    }
    for i := 1; i < 10; i++ {
        count[i] += count[i-1]
    }
    for i := len(nums) - 1; i >= 0; i-- {
        output[count[(nums[i]/exp)%10]-1] = nums[i]
        count[(nums[i]/exp)%10]--
    }
    return output
}

func radixSort(nums []int) []int {
    maxVal := math.MinInt
    for _, num := range nums {
        if num > maxVal {
            maxVal = num
        }
    }
    exp := 1
    for maxVal/exp > 0 {
        nums = countingSortByDigit(nums, exp)
        exp *= 10
    }
    return nums
}
```

---

#### 17. 拓扑排序

**题目：**
使用拓扑排序算法对有向无环图（DAG）进行排序。

**示例：**
```plaintext
输入：
0: [5, 6]
1: []
2: [1, 3]
3: [4, 7]
4: [5]
5: [6, 7]
6: [0]
7: []

输出：[0, 6, 1, 2, 4, 3, 5, 7]
```

**答案解析：**
- 拓扑排序的核心是利用 DFS 求出每个节点的入度，并将入度为 0 的节点加入队列，然后依次出队，并将出队节点的邻接点入度减一，如果邻接点入度为 0，则加入队列。
- 时间复杂度：O(V+E)，空间复杂度：O(V)。

**代码示例：**
```go
func拓扑排序(edges [][]int) []int {
    n := len(edges)
    indeg := make([]int, n)
    for _, edge := range edges {
        for _, v := range edge {
            indeg[v]++
        }
    }
    q := []int{}
    ans := []int{}
    for i, v := range indeg {
        if v == 0 {
            q = append(q, i)
        }
    }
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        ans = append(ans, node)
        for _, v := range edges[node] {
            indeg[v]--
            if indeg[v] == 0 {
                q = append(q, v)
            }
        }
    }
    return ans
}
```

---

#### 18. 并查集

**题目：**
使用并查集（Union-Find）算法解决连通性问题。

**示例：**
```plaintext
输入：edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0]]
输出：[true, true, true, false, false, false]
```

**答案解析：**
- 并查集的核心是合并（Union）和查询（Find）操作。
- 合并操作用于将两个连通分量合并为一个，查询操作用于判断两个元素是否在同一连通分量中。
- 时间复杂度：O(log n)，空间复杂度：O(n)。

**代码示例：**
```go
type UnionFind struct {
    parent []int
    size   []int
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    size := make([]int, n)
    for i := range parent {
        parent[i] = i
        size[i] = 1
    }
    return &UnionFind{parent, size}
}

func (u *UnionFind) Find(x int) int {
    if u.parent[x] != x {
        u.parent[x] = u.Find(u.parent[x])
    }
    return u.parent[x]
}

func (u *UnionFind) Union(x, y int) bool {
    rootX, rootY := u.Find(x), u.Find(y)
    if rootX == rootY {
        return false
    }
    if u.size[rootX] > u.size[rootY] {
        u.parent[rootY] = rootX
        u.size[rootX] += u.size[rootY]
    } else {
        u.parent[rootX] = rootY
        u.size[rootY] += u.size[rootX]
    }
    return true
}

func findConnected(edges [][]int) []bool {
    n := len(edges)
    uf := NewUnionFind(n)
    ans := make([]bool, n)
    for i, edge := range edges {
        if uf.Union(edge[0], edge[1]) {
            ans[i] = true
        }
    }
    return ans
}
```

---

#### 19. 深度优先搜索

**题目：**
使用深度优先搜索（DFS）算法求解连通性问题。

**示例：**
```plaintext
输入：
0: [1, 2]
1: [0]
2: [0, 3]
3: [2, 4]
4: [3, 5]
5: [4]
6: [7]
7: [6]
8: [9]
9: [8]
10: [11]
11: [10]
12: [13]
13: [12]
14: [15]
15: [14]
16: [17]
17: [16, 18]
18: [17]
19: [16]

输出：[[0, 1, 2, 3, 4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 18], [17]]
```

**答案解析：**
- 深度优先搜索是一种遍历图或树的数据结构，其核心思想是沿着一个分支走到底，然后再换另一个分支。
- 时间复杂度：O(V+E)，空间复杂度：O(V)。

**代码示例：**
```go
var visited = make(map[int]bool)
var ans [][]int

func dfs(graph [][]int, node int) {
    if visited[node] {
        return
    }
    visited[node] = true
    ans = append(ans, []int{node})
    for _, neighbor := range graph[node] {
        dfs(graph, neighbor)
        ans[len(ans)-1] = append(ans[len(ans)-1], neighbor)
    }
}

func connectedComponents(graph [][]int) [][]int {
    for i := range visited {
        visited[i] = false
    }
    for i := range ans {
        ans[i] = nil
    }
    ans = nil
    n := len(graph)
    for i := 0; i < n; i++ {
        if !visited[i] {
            dfs(graph, i)
        }
    }
    return ans
}
```

---

#### 20. 广度优先搜索

**题目：**
使用广度优先搜索（BFS）算法求解连通性问题。

**示例：**
```plaintext
输入：
0: [1, 2]
1: [0]
2: [0, 3]
3: [2, 4]
4: [3, 5]
5: [4]
6: [7]
7: [6]
8: [9]
9: [8]
10: [11]
11: [10]
12: [13]
13: [12]
14: [15]
15: [14]
16: [17]
17: [16, 18]
18: [17]
19: [16]

输出：[[0, 1, 2, 3, 4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 18], [17]]
```

**答案解析：**
- 广度优先搜索是一种遍历图或树的数据结构，其核心思想是先遍历所有的邻接点，然后再依次遍历下一层邻接点。
- 时间复杂度：O(V+E)，空间复杂度：O(V)。

**代码示例：**
```go
func connectedComponents(graph [][]int) [][]int {
    n := len(graph)
    ans := make([][]int, 0)
    visited := make([]bool, n)
    for i := 0; i < n; i++ {
        if !visited[i] {
            ans = append(ans, bfs(graph, i))
            for j := range visited {
                visited[j] = false
            }
        }
    }
    return ans
}

func bfs(graph [][]int, start int) []int {
    q := []int{start}
    ans := []int{start}
    visited := make(map[int]bool)
    visited[start] = true
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        for _, neighbor := range graph[node] {
            if visited[neighbor] {
                continue
            }
            visited[neighbor] = true
            ans = append(ans, neighbor)
            q = append(q, neighbor)
        }
    }
    return ans
}
```

