                 

### 2025滴滴校招编程面试题精选与解答

#### 1. 反转链表

**题目：** 编写一个函数，反转单链表。

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head
    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}
```

**解析：** 本题主要考察链表的基本操作。通过三个指针变量 prev、cur 和 nextTemp，依次将链表中的节点反转。

#### 2. 二叉搜索树遍历

**题目：** 实现二叉搜索树的遍历（前序、中序、后序）。

**答案：**

```go
// 前序遍历
func preOrder(root *TreeNode) {
    if root == nil {
        return
    }
    fmt.Println(root.Val)
    preOrder(root.Left)
    preOrder(root.Right)
}

// 中序遍历
func inOrder(root *TreeNode) {
    if root == nil {
        return
    }
    inOrder(root.Left)
    fmt.Println(root.Val)
    inOrder(root.Right)
}

// 后序遍历
func postOrder(root *TreeNode) {
    if root == nil {
        return
    }
    postOrder(root.Left)
    postOrder(root.Right)
    fmt.Println(root.Val)
}
```

**解析：** 二叉搜索树遍历分为三种：前序、中序和后序。本题主要考察对二叉树结构的理解和递归的使用。

#### 3. 最长公共前缀

**题目：** 编写一个函数，找到字符串数组中的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 最长公共前缀问题主要考察字符串处理能力和对贪心算法的理解。

#### 4. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```go
func twoSum(nums []int, target int) []int {
    var hashmap = map[int]int{}
    for i, num := range nums {
        complement := target - num
        if v, ok := hashmap[complement]; ok {
            return []int{v, i}
        }
        hashmap[num] = i
    }
    return []int{}
}
```

**解析：** 使用哈希表优化两数之和问题，减少时间复杂度。

#### 5. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 `n` 阶才能到达楼顶，每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**答案：**

```go
func climbStairs(n int) int {
    if n < 2 {
        return n
    }
    a, b := 1, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 爬楼梯问题可以通过动态规划解决，利用斐波那契数列的性质。

#### 6. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 合并两个有序链表主要是对链表节点的比较和连接操作。

#### 7. 三数之和

**题目：** 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 使得 `nums[i] + nums[j] + nums[k] == 0` 。请

```go
func threeSum(nums []int) [][]int {
    var res [][]int
    sort.Ints(nums)
    n := len(nums)
    for i := 0; i < n-2; i++ {
        // 跳过重复元素
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        // 使用双指针法寻找另外两个数
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                // 跳过重复元素
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

**解析：** 三数之和问题可以使用双指针法，优化时间复杂度。

#### 8. 字符串转换整数 (atoi)

**题目：** 实现一个 myAtoi(string s) 函数，使其能将字符串转换为整数。

**答案：**

```go
func myAtoi(s string) int {
    const (
        MaxInt32 = 1<<31 - 1
        MinInt32 = -1<<31
    )
    sign, num, i := 1, 0, 0
    for i < len(s) && s[i] == ' ' {
        i++
    }
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        if s[i] == '-' {
            sign = -1
        }
        i++
    }
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        num = num*10 + int(s[i]-'0')
        if sign == 1 && num > MaxInt32 {
            return MaxInt32
        }
        if sign == -1 && num > -MinInt32 {
            return MinInt32
        }
        i++
    }
    return sign * num
}
```

**解析：** 首先处理字符串的空格和符号，然后对数字进行逐位处理，防止溢出。

#### 9. 二进制中 1 的个数

**题目：** 编写一个函数，输入一个无符号整数，返回其二进制表示中 1 的个数。

**答案：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num > 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 利用位运算，将二进制位逐一处理，统计 1 的个数。

#### 10. 合并两个有序数组

**题目：** 给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**解析：** 从后向前比较两个数组中的元素，将较大的元素放到 `nums1` 的末尾。

#### 11. 罗马数字转换器

**题目：** 罗马数字包含以下七种字符: I，V，X，L，C，D 和 M。

```
I，表示 1;
V，表示 5;
X，表示 10;
L，表示 50;
C，表示 100;
D，表示 500;
M，表示 1000;
```

例如，`2` 写做 `II` ，即为两个 `1` 背对背拼接。`12` 写做 `XII` ，即为 `X` `+` `II` 。`27` 写做 `XXVII` ，即为 `XX` `+` `V` `+` `II` 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如：

```
4 不写做 `IIII` ，而是 `IV` 。因为 `IIII` 要被解释为 `4000` 。
9 不写做 `IXIX` ，而是 `IX` 。因为 `IX` 要被解释为 `900` 。
```

```
给定一个整数，将其转换为罗马数字。输入确保在 1 到 3999 的范围内。
```

**答案：**

```go
var val = []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
var symbol = []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
func intToRoman(num int) string {
    ans := ""
    for i := 0; i < len(val); i++ {
        for num >= val[i] {
            ans += symbol[i]
            num -= val[i]
        }
    }
    return ans
}
```

**解析：** 根据题目要求，从大到小遍历每个数字，将对应的罗马数字添加到结果中，并更新剩余的数值。

#### 12. 等概率生成随机数

**题目：** 给定一个有 `n` 个元素的数组 `nums` 和一个目标值 `target`。请你找出并返回满足 `nums[i] + nums[j] == target` 的 `i` 和 `j` 的数目。

假设给定函数 `rand7()` 能等概率地从 `1` 到 `7` 范围内返回任意整数。

**答案：**

```go
var srand7 = func() int {
    return rand.Intn(7) + 1
}

func numPairsDivisibleBy60(nums []int) int {
    cnt := [6]int{0, 0, 0, 0, 0, 0}
    ans := 0
    for _, v := range nums {
        v = (v % 7 + 7) % 7
        ans += cnt[v]
        cnt[v]++
    }
    return ans
}
```

**解析：** 通过模拟 `rand7()` 函数，统计每个数字出现的概率，并计算满足条件的组合数。

#### 13. 合并区间

**题目：** 以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。你需要合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖所有初始区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, v := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < v[0] {
            ans = append(ans, v)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], v[1])
        }
    }
    return ans
}
```

**解析：** 首先，按照区间的起始值排序；然后，合并重叠的区间。

#### 14. 回溯算法解决 0-1 背包问题

**题目：** 0-1 背包问题。

**答案：**

```go
func backPack(nums []int, W int) int {
    var dfs = func(i, cw int) int {
        if i == len(nums) {
            return 0
        }
        if cw+W >= len(nums) {
            return 0
        }
        if cw+nums[i] <= W {
            return max(dfs(i+1, cw+nums[i]), dfs(i+1, cw))
        }
        return dfs(i+1, cw)
    }
    return dfs(0, 0)
}
```

**解析：** 使用回溯算法，尝试每一种可能性，并选择最优解。

#### 15. 矩阵中的路径

**题目：** 给定一个二维字符数组 `board` 和一个字符串 `word` ，找出 `board` 中是否有一个与 `word` 相同的路径。路径需要从 `board` 的任意一格开始，每一步可以在该格的上、下、左、右四个方向上移动一步，不能对角移动或者移动到外部区域。可以假设 `board` 不是一个平面的网格，只有一行或者一列。

**答案：**

```go
func exist(board [][]byte, word string) bool {
    var dfs = func(i, j int) bool {
        if len(word) == 0 {
            return true
        }
        if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] != word[0] {
            return false
        }
        board[i][j] = 0
        defer func() {
            board[i][j] = word[0]
        }()
        res := dfs(i+1, j) || dfs(i-1, j) || dfs(i, j+1) || dfs(i, j-1)
        return res
    }
    for i := 0; i < len(board); i++ {
        for j := 0; j < len(board[0]); j++ {
            if dfs(i, j) {
                return true
            }
        }
    }
    return false
}
```

**解析：** 使用深度优先搜索（DFS）算法，遍历矩阵中的每一个元素，并尝试找到一个与 `word` 相匹配的路径。

#### 16. 股票买卖

**题目：** 给定一个整数数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖 一支股票）。

**答案：**

```go
func maxProfit(prices []int) int {
    ans := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            ans += prices[i] - prices[i-1]
        }
    }
    return ans
}
```

**解析：** 每次价格上涨时，计算并累加利润。

#### 17. 最小栈

**题目：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

**答案：**

```go
type MinStack struct {
    Stack  []int
    Minval int
}

func Constructor() MinStack {
    return MinStack{[]int{}, math.MaxInt64}
}

func (this *MinStack) Push(val int) {
    this.Stack = append(this.Stack, val)
    if val < this.Minval {
        this.Minval = val
    }
}

func (this *MinStack) Pop() {
    if len(this.Stack) == 0 {
        return
    }
    if this.Stack[len(this.Stack)-1] == this.Minval {
        this.Minval = math.MaxInt64
        for i := range this.Stack {
            if this.Stack[i] < this.Minval {
                this.Minval = this.Stack[i]
            }
        }
    }
    this.Stack = this.Stack[:len(this.Stack)-1]
}

func (this *MinStack) Top() int {
    return this.Stack[len(this.Stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.Minval
}
```

**解析：** 利用一个辅助变量 `Minval` 记录当前栈中最小的元素。

#### 18. 链表相交

**题目：** 编写一个程序，找到链表中的两个相交节点。

**答案：**

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    a, b := headA, headB
    for a != b {
        if a == nil {
            a = headB
        } else {
            a = a.Next
        }
        if b == nil {
            b = headA
        } else {
            b = b.Next
        }
    }
    return a
}
```

**解析：** 通过两次遍历，保证两个链表长度一致，然后一次遍历找到相交节点。

#### 19. 单调栈

**题目：** 设计一个单调栈，用于处理数组中的每个元素，输出其左边和右边最近的小于当前元素的第一个位置。

**答案：**

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stk := []int{}
    ans := make([]int, len(nums1))
    for _, v := range nums2 {
        for len(stk) > 0 && stk[len(stk)-1] < v {
            pos := len(stk) - 1
            ans[stk[pos]] = v
            stk = stk[:pos]
        }
        stk = append(stk, v)
    }
    for i := range ans {
        if ans[i] == 0 {
            ans[i] = -1
        }
    }
    return ans
}
```

**解析：** 通过单调栈，从右向左处理数组 `nums2`，找到每个元素左边和右边最近的小于当前元素的第一个位置。

#### 20. 两数相加

**题目：** 你有两个长度相同的非空链表 `l1` 和 `l2`，其中 `l1` 的第 `i` 个节点和 `l2` 的第 `i` 个节点都是整数。

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy = &ListNode{}
    cur := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        cur.Next = &ListNode{Val: sum % 10}
        cur = cur.Next
    }
    return dummy.Next
}
```

**解析：** 遍历两个链表，将对应的节点相加，处理进位。

#### 21. 合并两个有序数组

**题目：** 给你两个有序整数数组 `nums1` 和 `nums2` ，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**解析：** 从后向前比较两个数组中的元素，将较大的元素放到 `nums1` 的末尾。

#### 22. 二叉树的层序遍历

**题目：** 给你一个二叉树，请你返回其按层序遍历的节点值。 （即逐层地，从左到右访问所有节点）

**答案：**

```go
func levelOrder(root *TreeNode) [][]int {
    var ans [][]int
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        t := []*TreeNode{}
        var v []int
        for _, node := range q {
            v = append(v, node.Val)
            if node.Left != nil {
                t = append(t, node.Left)
            }
            if node.Right != nil {
                t = append(t, node.Right)
            }
        }
        ans = append(ans, v)
        q = t
    }
    return ans
}
```

**解析：** 使用广度优先搜索（BFS）进行层序遍历。

#### 23. 打家劫舍

**题目：** 你是一个职业的小偷，计划偷窃一路上的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。在一阵精心的规划后，发现你只能偷窃最多 `k` 间房屋，希望你能够得到尽可能多的现金。

给定一个整数数组 `nums` 代表从 `1` 到 `N` 中每个 `i` 号房屋的现金数额，和一个整数 `k` ，返回你能不触动警报装置的情况下 ，最多能够偷窃到的现金数额。

**答案：**

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    return max(rob(nums[:len(nums)-1]), rob(nums[1:]))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 利用动态规划，计算最多能偷窃到的现金数额。

#### 24. 删除链表的节点

**题目：** 给定单向链表的头指针和一个节点，定义一个函数，将节点删除，并返回新的头节点。

**答案：**

```go
func deleteNode(node *ListNode) *ListNode {
    if node == nil || node.Next == nil {
        return nil
    }
    node.Val = node.Next.Val
    node.Next = node.Next.Next
    return node
}
```

**解析：** 复制下一个节点的值，并跳过下一个节点。

#### 25. 合并 K 个排序链表

**题目：** 合并 K 个排序链表。请设计一个算法能够将 K 个有序链表合并成一个有序链表。算法的时间复杂度应为 O(NlogK)，其中 N 是所有链表中的节点总数。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    var merge = func(a, b *ListNode) *ListNode {
        if a == nil {
            return b
        }
        if b == nil {
            return a
        }
        if a.Val < b.Val {
            a.Next = merge(a.Next, b)
            return a
        }
        b.Next = merge(a, b.Next)
        return b
    }
    for len(lists) > 1 {
        n := len(lists)
        for i := 0; i < n/2; i++ {
            lists[i] = merge(lists[i], lists[n-i-1])
        }
        if n%2 == 0 {
            lists = lists[:len(lists)/2]
        } else {
            lists = append(lists[:len(lists)/2], lists[len(lists)/2+1:]...)
        }
    }
    return lists[0]
}
```

**解析：** 使用归并排序的思想，不断合并两个有序链表。

#### 26. 长度最小的子数组

**题目：** 给定一个含有 `n` 个正整数的数组和一个正整数 `s` ，找出该数组中满足其和 ≥ `s` 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 `0` 。

**答案：**

```go
func minSubArrayLen(target int, nums []int) int {
    ans := 0
    s := 0
    for i, v := range nums {
        s += v
        for s >= target {
            ans = max(ans, i+1-s+1)
            s -= nums[s-target]
        }
    }
    return ans
}
```

**解析：** 通过双指针，寻找满足条件的子数组。

#### 27. 寻找旋转排序数组中的最小值

**题目：** 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 整数中的一个旋转，变为一个长度为 `n` 的数组。

例如，原数组 `nums = [0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` 。

请找出并返回数组中的最小元素。

**答案：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 使用二分查找，找到旋转点。

#### 28. 二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树的根节点 `root` 和一个值 `val`，判断 `val` 是否存在于二叉搜索树中。

**答案：**

```go
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }
    if root.Val < val {
        return searchBST(root.Right, val)
    }
    return searchBST(root.Left, val)
}
```

**解析：** 递归遍历二叉搜索树，直到找到或到达叶节点。

#### 29. 翻转二叉树

**题目：** 翻转一棵二叉树。

**答案：**

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }
    root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
    return root
}
```

**解析：** 递归翻转左右子树。

#### 30. 删除二叉搜索树中的节点

**题目：** 给定一个二叉搜索树的根节点 `root` 和一个值 `key`，删除该值对应的节点，并保证二叉搜索树的性质不变。返回删除节点后二叉搜索树的根节点。

**答案：**

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil {
        return root
    }
    if root.Val > key {
        root.Left = deleteNode(root.Left, key)
    } else if root.Val < key {
        root.Right = deleteNode(root.Right, key)
    } else {
        if root.Left == nil && root.Right == nil {
            return nil
        }
        if root.Left == nil {
            return root.Right
        }
        if root.Right == nil {
            return root.Left
        }
        temp := root.Right
        for temp.Left != nil {
            temp = temp.Left
        }
        root.Val = temp.Val
        root.Right = deleteNode(root.Right, temp.Val)
    }
    return root
}
```

**解析：** 删除节点后，需要处理其左右子树。根据节点的左右子树是否存在，进行不同的处理。

