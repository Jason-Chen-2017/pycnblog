                 

### 2025 华为校招编程面试题精选与解答

#### 目录

1. [两数相加](#1-两数相加)
2. [最长公共前缀](#2-最长公共前缀)
3. [环形链表](#3-环形链表)
4. [合并两个有序链表](#4-合并两个有序链表)
5. [最长递增子序列](#5-最长递增子序列)
6. [最长公共子序列](#6-最长公共子序列)
7. [最长公共子串](#7-最长公共子串)
8. [最大子序和](#8-最大子序和)
9. [单调栈](#9-单调栈)
10. [滑动窗口](#10-滑动窗口)
11. [快速排序](#11-快速排序)
12. [归并排序](#12-归并排序)
13. [快速幂算法](#13-快速幂算法)
14. [字符串匹配算法](#14-字符串匹配算法)
15. [哈希表](#15-哈希表)
16. [广度优先搜索](#16-广度优先搜索)
17. [深度优先搜索](#17-深度优先搜索)
18. [并查集](#18-并查集)
19. [动态规划](#19-动态规划)
20. [贪心算法](#20-贪心算法)

---

##### 1. 两数相加

**题目：** 给出两个 **非空** 的链表 **l1** 和 **l2** ，每个节点包含一个 **整数** ，返回其节点列表形式表示的 **和** 。

**示例：**
```python
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,5,8]
```

**答案：**
```python
# Python 代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        p, q, curr = l1, l2, dummy
        carry = 0
        while p or q or carry:
            x = p.val if p else 0
            y = q.val if q else 0
            total = x + y + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if p:
                p = p.next
            if q:
                q = q.next
        return dummy.next
```

**解析：**
该算法采用迭代法，首先创建一个虚拟头节点 `dummy`，以便返回链表时不需要处理头节点。然后通过两个指针 `p` 和 `q` 分别遍历两个链表，每次遍历计算当前节点 `x` 和 `y` 的和 `total`，以及进位 `carry`。如果 `total` 大于等于 10，则进位 `carry` 置为 `1`，否则置为 `0`。最后将 `total % 10` 作为新节点的值，并将指针 `curr` 指向新节点。

---

##### 2. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```python
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：**
```python
# Python 代码
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for i, c in enumerate(strs[0]):
            for other in strs[1:]:
                if i >= len(other) or other[i] != c:
                    return prefix
            prefix += c
        return prefix
```

**解析：**
该算法采用分治策略，首先取第一个字符串作为参考字符串，然后依次与后续字符串进行比较。在比较过程中，如果当前字符 `c` 与其他字符串中的字符不相等，则返回当前公共前缀。否则，将公共前缀长度加一。该算法的时间复杂度为 O(mn)，其中 m 是最长公共前缀的长度，n 是字符串数组的长度。

---

##### 3. 环形链表

**题目：** 给定一个链表，判断是否存在循环。

**示例：**
```python
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中存在循环，其中 `pos` 为 1。
```

**答案：**
```python
# Python 代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                return True
        return False
```

**解析：**
该算法采用快慢指针法，分别使用 `fast` 和 `slow` 指针遍历链表。每次 `fast` 指针移动两个节点，而 `slow` 指针只移动一个节点。如果链表中存在循环，那么 `fast` 和 `slow` 指针最终会相遇。否则，`fast` 指针会到达链表末尾。该算法的时间复杂度为 O(n)，其中 n 是链表的长度。

---

##### 4. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```python
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**
```python
# Python 代码
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        p = dummy
        while l1 and l2:
            if l1.val < l2.val:
                p.next = l1
                l1 = l1.next
            else:
                p.next = l2
                l2 = l2.next
            p = p.next
        p.next = l1 or l2
        return dummy.next
```

**解析：**
该算法采用迭代法，创建一个虚拟头节点 `dummy`，以便返回链表时不需要处理头节点。然后使用指针 `p` 遍历两个链表，每次遍历选择较小的节点，并将其链接到新链表中。最后将剩余的链表链接到新链表的末尾。

---

##### 5. 最长递增子序列

**题目：** 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**示例：**
```python
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。
```

**答案：**
```python
# Python 代码
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

**解析：**
该算法采用动态规划，定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。遍历数组 `nums`，对于每个 `i`，在 `0` 到 `i-1` 的范围内查找比 `nums[i]` 大的数，更新 `dp[i]` 的值。最终返回 `dp` 数组中的最大值。

---

##### 6. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**示例：**
```python
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，所以返回其长度 3。
```

**答案：**
```python
# Python 代码
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[m][n]
```

**解析：**
该算法采用动态规划，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。遍历 `text1` 和 `text2` 的每个字符，如果当前字符相同，则将 `dp[i][j]` 的值更新为 `dp[i - 1][j - 1] + 1`；否则，将 `dp[i][j]` 的值更新为 `dp[i - 1][j]` 和 `dp[i][j - 1]` 中的最大值。最终返回 `dp[m][n]` 的值。

---

##### 7. 最长公共子串

**题目：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子串的长度。

**示例：**
```python
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子串是 "ace"，所以返回其长度 3。
```

**答案：**
```python
# Python 代码
class Solution:
    def longestCommonSubstring(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_len = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    max_len = max(max_len, dp[i][j])
                else:
                    dp[i][j] = 0
        return max_len
```

**解析：**
该算法采用动态规划，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子串的长度。遍历 `text1` 和 `text2` 的每个字符，如果当前字符相同，则将 `dp[i][j]` 的值更新为 `dp[i - 1][j - 1] + 1`；否则，将 `dp[i][j]` 的值更新为 `0`。在每次更新过程中，更新 `max_len` 的值，以记录当前找到的最长公共子串的长度。最终返回 `max_len` 的值。

---

##### 8. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少长度为 1）。

**示例：**
```python
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**答案：**
```python
# Python 代码
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_sum = nums[0]
        curr_sum = nums[0]
        for num in nums[1:]:
            curr_sum = max(num, curr_sum + num)
            max_sum = max(max_sum, curr_sum)
        return max_sum
```

**解析：**
该算法采用动态规划，定义两个变量 `max_sum` 和 `curr_sum` 分别表示当前找到的最大子序和以及当前子序和。遍历数组 `nums`，对于每个 `num`，更新 `curr_sum` 的值为 `max(num, curr_sum + num)`，表示在当前子序和的基础上，加上当前数或从当前数开始一个新的子序和。同时，更新 `max_sum` 的值为 `max(max_sum, curr_sum)`，表示记录当前找到的最大子序和。最终返回 `max_sum` 的值。

---

##### 9. 单调栈

**题目：** 给定一个整数数组 `nums`，构建一个单调栈，并返回数组中每个元素对应的前一个较小值。

**示例：**
```python
输入：nums = [2,1,2,3,4]
输出：[2,1,2,3,4]
解释：对于每个元素，找到其前一个较小值，并将结果存储在数组中。
```

**答案：**
```python
# Python 代码
def monotonic_stack(nums):
    prev_smaller = [-1] * len(nums)
    stack = []
    for i, num in enumerate(nums):
        while stack and nums[stack[-1]] >= num:
            stack.pop()
        if stack:
            prev_smaller[i] = nums[stack[-1]]
        stack.append(i)
    return prev_smaller
```

**解析：**
该算法采用单调栈，首先创建一个长度为 `len(nums)` 的数组 `prev_smaller`，用于存储每个元素的前一个较小值，初始值设为 `-1`。然后创建一个空栈 `stack`，用于存储下标。遍历数组 `nums`，对于每个 `num`，将栈顶元素依次弹出，直到栈为空或栈顶元素的值小于 `num`。如果栈顶元素存在，则将栈顶元素的值赋给 `prev_smaller[i]`，表示当前 `num` 的前一个较小值为栈顶元素。然后将当前 `i` 的值压入栈中。最终返回 `prev_smaller` 数组。

---

##### 10. 滑动窗口

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，构建一个滑动窗口，并返回数组中每个窗口的平均值。

**示例：**
```python
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[1,2,2.5,4,4,5.5,6]
```

**答案：**
```python
# Python 代码
def sliding_window_average(nums, k):
    if not nums or k <= 0:
        return []
    result = []
    window = nums[:k]
    result.append(sum(window) / k)
    for i in range(k, len(nums)):
        window.pop(0)
        window.append(nums[i])
        result.append(sum(window) / k)
    return result
```

**解析：**
该算法采用滑动窗口，首先检查输入数组 `nums` 是否为空或窗口大小 `k` 是否小于等于零，如果是，则返回空列表。然后创建一个空列表 `result` 用于存储每个窗口的平均值。创建一个长度为 `k` 的窗口 `window`，计算窗口中所有元素的和，并将平均值添加到 `result` 中。然后遍历 `nums`，对于每个 `i`，将窗口的第一个元素弹出，并将 `nums[i]` 添加到窗口中。计算新的窗口的平均值，并将其添加到 `result` 中。最终返回 `result` 列表。

---

##### 11. 快速排序

**题目：** 给定一个整数数组 `nums`，实现快速排序算法。

**示例：**
```python
输入：nums = [3,2,1]
输出：[1,2,3]
```

**答案：**
```python
# Python 代码
def quick_sort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

**解析：**
该算法采用快速排序，首先判断数组 `nums` 的长度是否小于等于 1，如果是，则返回数组本身。然后选择一个枢轴元素 `pivot`，将数组分为三个部分：小于 `pivot` 的元素、等于 `pivot` 的元素和大于 `pivot` 的元素。递归地对小于 `pivot` 的元素和大于 `pivot` 的元素进行快速排序，并将结果拼接起来。

---

##### 12. 归并排序

**题目：** 给定一个整数数组 `nums`，实现归并排序算法。

**示例：**
```python
输入：nums = [5,2,7,1,3]
输出：[1,2,3,5,7]
```

**答案：**
```python
# Python 代码
def merge_sort(nums):
    if len(nums) <= 1:
        return nums
    mid = len(nums) // 2
    left = merge_sort(nums[:mid])
    right = merge_sort(nums[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

**解析：**
该算法采用归并排序，首先判断数组 `nums` 的长度是否小于等于 1，如果是，则返回数组本身。然后选择数组的中间位置 `mid`，将数组分为两个部分：左边和右边。递归地对左边和右边的元素进行归并排序，然后合并两个有序数组。

---

##### 13. 快速幂算法

**题目：** 给定一个整数 `x` 和一个非负整数 `n`，实现快速幂算法，计算 `x` 的 `n` 次方。

**示例：**
```python
输入：x = 2, n = 10
输出：1024
```

**答案：**
```python
# Python 代码
def quick_power(x, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        half_power = quick_power(x, n // 2)
        return half_power * half_power
    else:
        half_power = quick_power(x, n // 2)
        return x * half_power * half_power
```

**解析：**
该算法采用递归法，首先判断指数 `n` 是否为零，如果是，则返回 1。然后判断指数 `n` 是否为偶数，如果是，则递归计算 `x` 的 `(n // 2)` 次方，并将结果平方。否则，递归计算 `x` 的 `(n // 2)` 次方，并将结果乘以 `x`。

---

##### 14. 字符串匹配算法

**题目：** 给定一个字符串 `text` 和一个模式 `pattern`，实现 KMP 字符串匹配算法，返回模式在文本中第一次出现的起始索引。

**示例：**
```python
输入：text = "abcabax", pattern = "aba"
输出：2
```

**答案：**
```python
# Python 代码
def kmp_search(text, pattern):
    def compute_lps(pattern):
        lps = [0] * len(pattern)
        length = 0
        i = 1
        while i < len(pattern):
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps

    lps = compute_lps(pattern)
    i = j = 0
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            return i - j
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
    return -1
```

**解析：**
该算法采用 KMP 算法，首先计算模式 `pattern` 的最长前缀后缀数组 `lps`。然后使用两个指针 `i` 和 `j` 分别遍历文本 `text` 和模式 `pattern`，如果当前字符匹配，则指针 `i` 和 `j` 同时向后移动。如果指针 `j` 达到模式长度，则返回当前 `i - j` 的值。否则，根据 `lps` 数组，将指针 `j` 移动到前一个匹配位置。

---

##### 15. 哈希表

**题目：** 给定一个整数数组 `nums`，找出所有重复的数。

**示例：**
```python
输入：nums = [1,2,3,1]
输出：[1]
```

**答案：**
```python
# Python 代码
def find_duplicates(nums):
    nums_set = set()
    duplicates = []
    for num in nums:
        if num in nums_set:
            duplicates.append(num)
        else:
            nums_set.add(num)
    return duplicates
```

**解析：**
该算法采用哈希表，首先创建一个空集合 `nums_set` 用于存储已遍历的数，以及一个空列表 `duplicates` 用于存储重复的数。然后遍历数组 `nums`，对于每个 `num`，如果 `num` 在 `nums_set` 中，则将其添加到 `duplicates` 列表中；否则，将 `num` 添加到 `nums_set` 中。最终返回 `duplicates` 列表。

---

##### 16. 广度优先搜索

**题目：** 给定一个无向图 `graph` 和一个起点 `start`，实现广度优先搜索算法，返回从 `start` 到其他所有节点的最短路径。

**示例：**
```python
输入：graph = [[1,2], [3], [3], []], start = 0
输出：[[0,1],[0,2],[0,3],[2,3]]
```

**答案：**
```python
# Python 代码
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    distances = {start: 0}
    paths = {start: [start]}
    while queue:
        node = queue.popleft()
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append(neighbor)
                distances[neighbor] = distances[node] + 1
                paths[neighbor] = paths[node] + [neighbor]
    return [[node] + path for node, path in paths.items()]
```

**解析：**
该算法采用广度优先搜索，首先创建一个空集合 `visited` 用于存储已访问的节点，以及一个双端队列 `queue` 用于存储待访问的节点。创建一个字典 `distances` 用于存储从起点到其他节点的距离，以及一个字典 `paths` 用于存储从起点到其他节点的路径。然后从 `queue` 中依次取出节点，将其添加到 `visited` 集合中，并遍历其邻居节点。如果邻居节点未访问过，则将其添加到 `queue` 中，并更新其距离和路径。最终返回 `paths` 字典中的所有路径。

---

##### 17. 深度优先搜索

**题目：** 给定一个无向图 `graph` 和一个起点 `start`，实现深度优先搜索算法，返回从 `start` 到其他所有节点的最短路径。

**示例：**
```python
输入：graph = [[1,2], [3], [3], []], start = 0
输出：[[0,1],[0,2],[0,3],[2,3]]
```

**答案：**
```python
# Python 代码
def dfs(graph, start):
    visited = set()
    stack = [start]
    distances = {start: 0}
    paths = {start: [start]}
    while stack:
        node = stack.pop()
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                stack.append(neighbor)
                distances[neighbor] = distances[node] + 1
                paths[neighbor] = paths[node] + [neighbor]
    return [[node] + path for node, path in paths.items()]
```

**解析：**
该算法采用深度优先搜索，首先创建一个空集合 `visited` 用于存储已访问的节点，以及一个栈 `stack` 用于存储待访问的节点。创建一个字典 `distances` 用于存储从起点到其他节点的距离，以及一个字典 `paths` 用于存储从起点到其他节点的路径。然后从 `stack` 中依次取出节点，将其添加到 `visited` 集合中，并遍历其邻居节点。如果邻居节点未访问过，则将其添加到 `stack` 中，并更新其距离和路径。最终返回 `paths` 字典中的所有路径。

---

##### 18. 并查集

**题目：** 给定一个整数数组 `nums`，找出所有重复的数。

**示例：**
```python
输入：nums = [1,2,3,1]
输出：[1]
```

**答案：**
```python
# Python 代码
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, a, b):
        rootA = self.find(a)
        rootB = self.find(b)
        if rootA != rootB:
            if self.size[rootA] > self.size[rootB]:
                self.parent[rootB] = rootA
                self.size[rootA] += self.size[rootB]
            else:
                self.parent[rootA] = rootB
                self.size[rootB] += self.size[rootA]

def find_duplicates(nums):
    uf = UnionFind(len(nums))
    for i in range(len(nums)):
        uf.union(i, nums[i])
    visited = set()
    duplicates = []
    for i in range(len(nums)):
        if uf.find(i) in visited:
            duplicates.append(i)
        else:
            visited.add(uf.find(i))
    return duplicates
```

**解析：**
该算法采用并查集，首先创建一个并查集类 `UnionFind`，其中包含初始化并查集、查找元素根节点、合并两个集合的方法。然后创建一个并查集实例 `uf`，对于数组 `nums` 中的每个元素，使用 `uf.union()` 方法将其与数组中的索引进行合并。遍历数组 `nums`，如果当前元素的根节点已在 `visited` 集合中，则将其添加到 `duplicates` 列表中；否则，将根节点添加到 `visited` 集合中。最终返回 `duplicates` 列表。

---

##### 19. 动态规划

**题目：** 给定一个整数数组 `nums`，找出所有重复的数。

**示例：**
```python
输入：nums = [1,2,3,1]
输出：[1]
```

**答案：**
```python
# Python 代码
def find_duplicates(nums):
    dp = [0] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] == nums[j]:
                dp[i] = 1
                break
    return [i for i, count in enumerate(dp) if count == 1]
```

**解析：**
该算法采用动态规划，首先创建一个长度为 `len(nums)` 的数组 `dp`，用于存储每个元素是否为重复数，初始值设为 0。然后遍历数组 `nums`，对于每个元素 `nums[i]`，在 `0` 到 `i-1` 的范围内查找是否存在与其相等的元素，如果存在，则将 `dp[i]` 的值更新为 1。最终返回数组 `nums` 中所有重复的元素。

---

##### 20. 贪心算法

**题目：** 给定一个整数数组 `nums`，找出所有重复的数。

**示例：**
```python
输入：nums = [1,2,3,1]
输出：[1]
```

**答案：**
```python
# Python 代码
def find_duplicates(nums):
    visited = set()
    duplicates = []
    for num in nums:
        if num in visited:
            duplicates.append(num)
        else:
            visited.add(num)
    return duplicates
```

**解析：**
该算法采用贪心算法，首先创建一个空集合 `visited` 用于存储已遍历的数，以及一个空列表 `duplicates` 用于存储重复的数。然后遍历数组 `nums`，对于每个 `num`，如果 `num` 在 `visited` 集合中，则将其添加到 `duplicates` 列表中；否则，将 `num` 添加到 `visited` 集合中。最终返回 `duplicates` 列表。

