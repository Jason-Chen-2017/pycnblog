                 

### 京东社招面试算法题库大全：数据结构与算法解析

#### 题目 1：二维数组中的查找
**题目描述：** 在一个二维数组中（每个一维数组的长度相同），每行都按照从左到右递增的顺序排序，每列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**答案：** 可以从数组的右上角开始查找，如果当前元素大于目标值，向下移动；如果当前元素小于目标值，向左移动。这样可以利用数组的有序特性，减少查找次数。

```go
func Find(target []int, array [][]int) bool {
    if len(array) == 0 || len(array[0]) == 0 {
        return false
    }
    rows, cols := len(array), len(array[0])
    row, col := 0, cols - 1
    for row < rows && col >= 0 {
        if array[row][col] == target {
            return true
        } else if array[row][col] > target {
            col--
        } else {
            row++
        }
    }
    return false
}
```

**解析：** 该算法的时间复杂度为 O(m + n)，其中 m 是行数，n 是列数。通过从右上角开始搜索，每次都能排除一行或一列，因此可以快速找到目标值。

#### 题目 2：字符串转换大写
**题目描述：** 编写一个函数，将一个字符串转换为大写形式。字符串中的字符可以是字母、数字或特殊字符。

**答案：**

```go
func ToUpper(s string) string {
    runes := []rune(s)
    for i, r := range runes {
        if 'a' <= r && r <= 'z' {
            runes[i] = r - 'a' + 'A'
        }
    }
    return string(runes)
}
```

**解析：** 该函数使用 rune 类型来处理字符串中的每个字符，因为 rune 可以表示 Unicode 字符。对于每个字符，如果它是小写字母，则将其转换为相应的大写字母。

#### 题目 3：链表反转
**题目描述：** 反转一个单链表。链表节点定义如下：

```go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

**答案：**

```go
func Reverse(head *ListNode) *ListNode {
    var prev, curr *ListNode = nil, head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**解析：** 该函数通过迭代的方式，将链表的每个节点都指向其前一个节点，从而实现链表的反转。

#### 题目 4：快速排序
**题目描述：** 实现快速排序算法，并打印排序过程。

**答案：**

```go
func QuickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }
    QuickSort(arr[:len(arr)-1])
    if arr[len(arr)-1] < arr[0] {
        arr[0], arr[len(arr)-1] = arr[len(arr)-1], arr[0]
        PrintArray(arr)
    }
}
```

**解析：** 快速排序是一种分治算法，它通过递归地将数组分成两部分，然后对这两部分进行排序。

#### 题目 5：哈希表
**题目描述：** 实现一个哈希表，包括初始化、插入、查找和删除操作。

**答案：**

```go
type HashTable struct {
    size int
    data [][]int
}

func NewHashTable(size int) *HashTable {
    return &HashTable{
        size: size,
        data: make([][]int, size),
    }
}

func (t *HashTable) Insert(key int) {
    index := key % t.size
    if t.data[index] == nil {
        t.data[index] = []int{key}
    } else {
        for _, v := range t.data[index] {
            if v == key {
                return
            }
        }
        t.data[index] = append(t.data[index], key)
    }
}

func (t *HashTable) Find(key int) bool {
    index := key % t.size
    if t.data[index] == nil {
        return false
    }
    for _, v := range t.data[index] {
        if v == key {
            return true
        }
    }
    return false
}

func (t *HashTable) Delete(key int) {
    index := key % t.size
    if t.data[index] == nil {
        return
    }
    for i, v := range t.data[index] {
        if v == key {
            t.data[index] = append(t.data[index][:i], t.data[index][i+1:]...)
            return
        }
    }
}
```

**解析：** 哈希表是一种基于哈希函数的数据结构，用于高效地存储和检索键值对。这里的实现使用了数组加链表的方式解决冲突。

#### 题目 6：排序算法比较
**题目描述：** 比较冒泡排序、选择排序、插入排序、快速排序的时间复杂度和稳定性。

**答案：**

| 排序算法 | 时间复杂度（最好情况） | 时间复杂度（最坏情况） | 稳定性 |
|----------|----------------------|----------------------|--------|
| 冒泡排序 | O(n^2)                | O(n^2)                | 稳定   |
| 选择排序 | O(n^2)                | O(n^2)                | 不稳定 |
| 插入排序 | O(n)                  | O(n^2)                | 稳定   |
| 快速排序 | O(n log n)            | O(n^2)                | 不稳定 |

**解析：** 冒泡排序和选择排序的时间复杂度都是 O(n^2)，但插入排序的时间复杂度在最好情况下是 O(n)，而快速排序的时间复杂度在最好情况下是 O(n log n)。稳定性指的是相等的元素在排序后是否保持原有的顺序。

#### 题目 7：二叉树遍历
**题目描述：** 实现二叉树的先序、中序和后序遍历。

**答案：**

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func PreorderTraversal(root *TreeNode) []int {
    res := []int{}
    if root != nil {
        res = append(res, root.Val)
        res = append(res, PreorderTraversal(root.Left)...)
        res = append(res, PreorderTraversal(root.Right)...)
    }
    return res
}

func InorderTraversal(root *TreeNode) []int {
    res := []int{}
    if root != nil {
        res = append(res, InorderTraversal(root.Left)...)
        res = append(res, root.Val)
        res = append(res, InorderTraversal(root.Right)...)
    }
    return res
}

func PostorderTraversal(root *TreeNode) []int {
    res := []int{}
    if root != nil {
        res = append(res, PostorderTraversal(root.Left)...)
        res = append(res, PostorderTraversal(root.Right)...)
        res = append(res, root.Val)
    }
    return res
}
```

**解析：** 这些函数通过递归方式实现二叉树的遍历。先序遍历的顺序是根-左-右；中序遍历的顺序是左-根-右；后序遍历的顺序是左-右-根。

#### 题目 8：动态规划
**题目描述：** 使用动态规划求解斐波那契数列。

**答案：**

```go
func Fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

**解析：** 动态规划是一种优化递归的方法，通过保存中间结果来避免重复计算。这里使用了数组 `dp` 来存储每个斐波那契数，从而实现高效的计算。

#### 题目 9：最长公共子序列
**题目描述：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**

```go
func LongestCommonSubsequence(text1, text2 string) string {
    dp := make([][]int, len(text1)+1)
    for i := range dp {
        dp[i] = make([]int, len(text2)+1)
    }
    for i := 1; i <= len(text1); i++ {
        for j := 1; j <= len(text2); j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    i, j := len(text1), len(text2)
    res := ""
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            res = string(text1[i-1]) + res
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划求解最长公共子序列，通过构建一个二维数组 `dp` 来记录每个子问题的解，然后回溯得到最长公共子序列。

#### 题目 10：滑动窗口
**题目描述：** 给定一个字符串和一个整数 k，找到字符串中所有长度为 k 的最长重复子串。

**答案：**

```go
func LongestSubstring(s string, k int) string {
    cnt := make(map[int]int)
    i := 0
    for j := 0; j < len(s); j++ {
        cnt[int(s[j]-'A')]++
        if j >= k {
            cnt[int(s[i]-'A')]--
            i++
        }
        if j-i+1 == k && len(cnt) == k {
            return s[i : i+k]
        }
    }
    return ""
}
```

**解析：** 使用滑动窗口的方法，维护一个大小为 k 的窗口，通过计数器记录窗口中每个字符的个数，当窗口中的字符个数等于 k 时，更新最长重复子串。

#### 题目 11：回溯算法
**题目描述：** 使用回溯算法求解 0-1 背包问题。

**答案：**

```go
var res int
var path []int
var dp [][]int

func Knapsack(values []int, weights []int, capacity int) int {
    n := len(values)
    dp = make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    dfs(0, 0, weights, values, capacity)
    return res
}

func dfs(i, totalWeight []int, weights []int, values []int, capacity int) {
    if i == len(values) {
        res = max(res, totalWeight[0])
        return
    }
    dfs(i+1, totalWeight, weights, values, capacity)
    totalWeight[0] += weights[i]
    if totalWeight[0] <= capacity {
        dfs(i+1, totalWeight, weights, values, capacity)
    }
    totalWeight[0] -= weights[i]
}
```

**解析：** 回溯算法通过递归尝试每个可能的组合，并在遇到不可能的情况时回退。这里使用了动态规划来优化回溯的过程。

#### 题目 12：堆排序
**题目描述：** 使用堆排序算法对数组进行排序。

**答案：**

```go
type MaxHeap []int

func (h *MaxHeap) Len() int           { return len(*h) }
func (h *MaxHeap) Less(i, j int) bool { return (*h)[i] > (*h)[j] }
func (h *MaxHeap) Swap(i, j int)      { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] }

func (h *MaxHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *MaxHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func HeapSort(arr []int) {
    h := &MaxHeap{}
    for _, v := range arr {
        h.Push(v)
    }
    for h.Len() > 1 {
        arr[0] = h.Pop().(int)
        siftDown(h, 0)
    }
    arr[0] = h.Pop().(int)
}

func siftDown(h *MaxHeap, i int) {
    n := h.Len()
    l := 2*i + 1
    r := 2*i + 2
    maxIndex := i
    if l < n && h.Less(l, maxIndex) {
        maxIndex = l
    }
    if r < n && h.Less(r, maxIndex) {
        maxIndex = r
    }
    if maxIndex != i {
        h.Swap(i, maxIndex)
        siftDown(h, maxIndex)
    }
}
```

**解析：** 堆排序是一种基于二叉堆的排序算法。这里使用了最大堆来实现，首先将数组构建成最大堆，然后依次取出堆顶元素（最大值），并调整堆，直到堆为空。

#### 题目 13：排序与查找
**题目描述：** 给定一个整数数组，找出数组中的第 k 个最大元素。

**答案：**

```go
func FindKthLargest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[len(nums)-k]
}
```

**解析：** 通过排序找出第 k 个最大元素，这里使用了 Go 内置的 `sort.Ints` 函数。时间复杂度为 O(n log n)。

#### 题目 14：贪心算法
**题目描述：** 给定一个字符串，将其中的空格替换为 %20，要求最小化操作次数。

**答案：**

```go
func ReplaceSpaces(s string, length int) string {
    cnt := 0
    for i := 0; i < length; i++ {
        if s[i] == ' ' {
            cnt++
        }
    }
    newLen := length + 2*cnt
    newS := make([]byte, newLen)
    j := newLen - 1
    for i := length - 1; i >= 0; i-- {
        if s[i] == ' ' {
            newS[j] = '0'
            j--
            newS[j] = '2'
            j--
            newS[j] = '%'
            j--
        } else {
            newS[j] = s[i]
            j--
        }
    }
    return string(newS)
}
```

**解析：** 使用贪心算法，从后往前填充字符，遇到空格就填充相应的 %20，这样可以最小化操作次数。

#### 题目 15：优先队列
**题目描述：** 使用优先队列实现一个最小堆。

**答案：**

```go
type MinHeap []int

func (h *MinHeap) Len() int           { return len(*h) }
func (h *MinHeap) Less(i, j int) bool { return (*h)[i] < (*h)[j] }
func (h *MinHeap) Swap(i, j int)      { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] }

func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func (h *MinHeap) Insert(v int) {
    *h = append(*h, v)
    siftUp(h, len(*h)-1)
}

func (h *MinHeap) GetMin() int {
    return (*h)[0]
}

func siftUp(h *MinHeap, i int) {
    for i > 0 {
        p := (i - 1) / 2
        if (*h)[p] <= (*h)[i] {
            break
        }
        (*h)[p], (*h)[i] = (*h)[i], (*h)[p]
        i = p
    }
}
```

**解析：** 最小堆的实现在于插入和调整堆的操作，这里使用了 siftUp 方法来确保堆的有序性。

#### 题目 16：搜索算法
**题目描述：** 给定一个字符串，找出其中最长的回文子串。

**答案：**

```go
func LongestPalindrome(s string) string {
    n := len(s)
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        dp[i][i] = true
    }
    for i := 0; i < n-1; i++ {
        if s[i] == s[i+1] {
            dp[i][i+1] = true
            start = i
            maxLen = 2
        }
    }
    for l := 3; l <= n; l++ {
        for i := 0; i < n-l+1; i++ {
            j := i + l - 1
            if dp[i+1][j-1] && s[i] == s[j] {
                dp[i][j] = true
                if l > maxLen {
                    start = i
                    maxLen = l
                }
            }
        }
    }
    return s[start : start+maxLen]
}
```

**解析：** 使用动态规划来求解最长回文子串。通过遍历所有可能的子串，并使用二维数组 `dp` 来记录子串是否为回文。

#### 题目 17：图算法
**题目描述：** 使用深度优先搜索（DFS）算法求解图中两个节点之间的最短路径。

**答案：**

```go
var res int
var path []int

func DFS(graph [][]int, start, end int) {
    if start == end {
        res = path[len(path)-1] + graph[start][end]
        return
    }
    for i, v := range graph[start] {
        if v > 0 {
            path = append(path, i)
            DFS(graph, i, end)
            path = path[:len(path)-1]
        }
    }
}

func MinPathSum(graph [][]int) int {
    res = math.MaxInt64
    DFS(graph, 0, len(graph)-1)
    return res
}
```

**解析：** 使用递归实现深度优先搜索，记录每条路径的权重，最终得到最短路径的权重。

#### 题目 18：并查集
**题目描述：** 使用并查集算法求解图中连通分量个数。

**答案：**

```go
type UnionFind struct {
    parent []int
    size   []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        parent: make([]int, n),
        size:   make([]int, n),
    }
    for i := range uf.parent {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX != rootY {
        if uf.size[rootX] > uf.size[rootY] {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        } else {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        }
    }
}

func CountComponents(n int, edges [][]int) int {
    uf := NewUnionFind(n)
    for _, e := range edges {
        uf.Union(e[0], e[1])
    }
    cnt := 0
    for i := 0; i < n; i++ {
        if uf.Find(i) == i {
            cnt++
        }
    }
    return cnt
}
```

**解析：** 并查集通过路径压缩和按秩合并来优化查找和合并操作，从而实现高效的连通分量计数。

#### 题目 19：树形动态规划
**题目描述：** 给定一棵树的节点值，求出每个节点到根节点的最长路径。

**答案：**

```go
var res [][]int

func longestPath(root *TreeNode) [][]int {
    dfs(root)
    return res
}

func dfs(node *TreeNode) {
    if node == nil {
        return
    }
    left := dfs(node.Left)
    right := dfs(node.Right)
    path := make([]int, 0, len(left)+len(right)+1)
    if len(left) > len(right) {
        for _, v := range left {
            path = append(path, v)
        }
    } else {
        for _, v := range right {
            path = append(path, v)
        }
    }
    path = append(path, node.Val)
    if len(right) > len(left) {
        for _, v := range right {
            path = append(path, v)
        }
    } else {
        for _, v := range left {
            path = append(path, v)
        }
    }
    if len(path) > len(res[0]) {
        res = [][]int{path}
    } else if len(path) == len(res[0]) {
        res = append(res, path)
    }
}
```

**解析：** 通过递归遍历树的每个节点，计算每个节点到根节点的最长路径，并存储在数组 `res` 中。

#### 题目 20：线段树
**题目描述：** 给定一个整数数组，使用线段树实现区间查询和更新操作。

**答案：**

```go
type Node struct {
    l, r     int
    sum, lazy int
}

func buildTree(nums []int) *Node {
    root := &Node{l: 0, r: len(nums) - 1}
    build(root, nums)
    return root
}

func build(node *Node, nums []int) {
    if node.l == node.r {
        node.sum = nums[node.l]
        return
    }
    mid := (node.l + node.r) / 2
    left := &Node{l: node.l, r: mid}
    right := &Node{l: mid + 1, r: node.r}
    build(left, nums)
    build(right, nums)
    node.left = left
    node.right = right
    node.sum = left.sum + right.sum
}

func updateTree(node *Node, l, r, val int) {
    if node.l > r || node.r < l {
        return
    }
    if node.l == r && node.r == l {
        node.sum += val
        node.lazy += val
        return
    }
    if node.lazy > 0 {
        node.left.lazy += node.lazy
        node.right.lazy += node.lazy
        node.left.sum += node.lazy
        node.right.sum += node.lazy
        node.lazy = 0
    }
    update(node.left, l, r, val)
    update(node.right, l, r, val)
    node.sum = node.left.sum + node.right.sum
}

func queryTree(node *Node, l, r int) int {
    if node.l > r || node.r < l {
        return 0
    }
    if node.l >= l && node.r <= r {
        return node.sum
    }
    if node.lazy > 0 {
        node.left.lazy += node.lazy
        node.right.lazy += node.lazy
        node.left.sum += node.lazy
        node.right.sum += node.lazy
        node.lazy = 0
    }
    return query(node.left, l, r) + query(node.right, l, r)
}
```

**解析：** 线段树通过递归的方式构建，支持区间查询和更新操作。这里的实现使用了懒标记来优化更新操作。

#### 题目 21：二分查找
**题目描述：** 给定一个排序后的整数数组，找到目标值的位置。

**答案：**

```go
func Search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**解析：** 二分查找算法通过递归或迭代的方式，在有序数组中找到目标值的位置。时间复杂度为 O(log n)。

#### 题目 22：位运算
**题目描述：** 给定一个整数，找出它的唯一且最小的表示为 2 的幂的和的数字。

**答案：**

```go
func minOneBitOperations(num int) int {
    cnt := 0
    for num != 0 {
        cnt += num & 1
        num >>= 1
    }
    return 1 << cnt - 1
}
```

**解析：** 通过位运算，计算数字中 1 的个数，然后计算出最小的 2 的幂。

#### 题目 23：树形动态规划
**题目描述：** 给定一棵树的节点值，求出每个节点到根节点的最长路径。

**答案：**

```go
var res [][]int

func longestPath(root *TreeNode) [][]int {
    dfs(root)
    return res
}

func dfs(node *TreeNode) {
    if node == nil {
        return
    }
    left := dfs(node.Left)
    right := dfs(node.Right)
    path := make([]int, 0, len(left)+len(right)+1)
    if len(left) > len(right) {
        for _, v := range left {
            path = append(path, v)
        }
    } else {
        for _, v := range right {
            path = append(path, v)
        }
    }
    path = append(path, node.Val)
    if len(right) > len(left) {
        for _, v := range right {
            path = append(path, v)
        }
    } else {
        for _, v := range left {
            path = append(path, v)
        }
    }
    if len(path) > len(res[0]) {
        res = [][]int{path}
    } else if len(path) == len(res[0]) {
        res = append(res, path)
    }
}
```

**解析：** 通过递归遍历树的每个节点，计算每个节点到根节点的最长路径，并存储在数组 `res` 中。

#### 题目 24：滑动窗口
**题目描述：** 给定一个字符串和一个整数 k，找到字符串中所有长度为 k 的最长重复子串。

**答案：**

```go
func LongestSubstring(s string, k int) string {
    cnt := make(map[int]int)
    i := 0
    for j := 0; j < len(s); j++ {
        cnt[int(s[j]-'A')]++
        if j >= k {
            cnt[int(s[i]-'A')]--
            i++
        }
        if j-i+1 == k && len(cnt) == k {
            return s[i : i+k]
        }
    }
    return ""
}
```

**解析：** 使用滑动窗口的方法，维护一个大小为 k 的窗口，通过计数器记录窗口中每个字符的个数，当窗口中的字符个数等于 k 时，更新最长重复子串。

#### 题目 25：排序与查找
**题目描述：** 给定一个整数数组，找出数组中的第 k 个最小元素。

**答案：**

```go
func FindKthSmallest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[k-1]
}
```

**解析：** 通过排序找出第 k 个最小元素，这里使用了 Go 内置的 `sort.Ints` 函数。时间复杂度为 O(n log n)。

#### 题目 26：动态规划
**题目描述：** 使用动态规划求解零钱兑换的最小硬币数量。

**答案：**

```go
var res int

func CoinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    dp[0] = 0
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt64
        for _, coin := range coins {
            if i-coin >= 0 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    if dp[amount] == math.MaxInt64 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 动态规划通过构建一个数组 `dp` 来记录每个金额的最小硬币数量，最终得到兑换最小硬币数量。

#### 题目 27：双指针
**题目描述：** 给定一个整数数组，找出其中不含有重复数字的最长子串的长度。

**答案：**

```go
func LengthOfLongestSubstring(s string) int {
    left, right := 0, 0
    cnt := make(map[int]int)
    maxLen := 0
    for right < len(s) {
        c := s[right]
        right++
        cnt[int(c)]++
        for cnt[int(c)] > 1 {
            d := s[left]
            left++
            cnt[int(d)]--
        }
        maxLen = max(maxLen, right-left)
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用双指针的方法，维护一个窗口，当窗口中出现重复字符时，移动左指针，直到窗口中没有重复字符。

#### 题目 28：并查集
**题目描述：** 使用并查集算法求解图中连通分量个数。

**答案：**

```go
type UnionFind struct {
    parent []int
    size   []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        parent: make([]int, n),
        size:   make([]int, n),
    }
    for i := range uf.parent {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX != rootY {
        if uf.size[rootX] > uf.size[rootY] {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        } else {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        }
    }
}

func CountComponents(n int, edges [][]int) int {
    uf := NewUnionFind(n)
    for _, e := range edges {
        uf.Union(e[0], e[1])
    }
    cnt := 0
    for i := 0; i < n; i++ {
        if uf.Find(i) == i {
            cnt++
        }
    }
    return cnt
}
```

**解析：** 并查集通过路径压缩和按秩合并来优化查找和合并操作，从而实现高效的连通分量计数。

#### 题目 29：堆排序
**题目描述：** 使用堆排序算法对数组进行排序。

**答案：**

```go
type MaxHeap []int

func (h *MaxHeap) Len() int           { return len(*h) }
func (h *MaxHeap) Less(i, j int) bool { return (*h)[i] > (*h)[j] }
func (h *MaxHeap) Swap(i, j int)      { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] }

func (h *MaxHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *MaxHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func HeapSort(arr []int) {
    h := &MaxHeap{}
    for _, v := range arr {
        h.Push(v)
    }
    for h.Len() > 1 {
        arr[0] = h.Pop().(int)
        siftDown(h, 0)
    }
    arr[0] = h.Pop().(int)
}

func siftDown(h *MaxHeap, i int) {
    n := h.Len()
    l := 2*i + 1
    r := 2*i + 2
    maxIndex := i
    if l < n && h.Less(l, maxIndex) {
        maxIndex = l
    }
    if r < n && h.Less(r, maxIndex) {
        maxIndex = r
    }
    if maxIndex != i {
        h.Swap(i, maxIndex)
        siftDown(h, maxIndex)
    }
}
```

**解析：** 堆排序是一种基于二叉堆的排序算法。这里使用了最大堆来实现，首先将数组构建成最大堆，然后依次取出堆顶元素（最大值），并调整堆，直到堆为空。

#### 题目 30：拓扑排序
**题目描述：** 给定一个无向图，判断是否存在环。

**答案：**

```go
var res bool

func HasCycle(graph [][]int) bool {
    vis := make([]bool, len(graph))
    for i := range vis {
        if !vis[i] {
            dfs(graph, i, vis)
            if res {
                return true
            }
        }
    }
    return false
}

func dfs(graph [][]int, i int, vis []bool) {
    vis[i] = true
    for _, v := range graph[i] {
        if vis[v] || dfs(graph, v, vis) {
            res = true
            return
        }
    }
}
```

**解析：** 使用深度优先搜索（DFS）实现拓扑排序，通过递归遍历每个节点，如果在遍历过程中遇到已经访问过的节点，则说明存在环。时间复杂度为 O(n + m)，其中 n 是节点数，m 是边数。

### 结语

本文汇总了京东社招面试中常见的算法和数据结构问题，包括排序、查找、动态规划、图算法、并查集等。每个问题都给出了详细的解析和代码实现，旨在帮助求职者更好地准备面试。需要注意的是，实际面试中可能会根据具体岗位和公司要求，提出更复杂或特定的问题。因此，建议求职者在掌握基础算法和数据结构的同时，也要不断练习和总结，提高自己的解题能力。

