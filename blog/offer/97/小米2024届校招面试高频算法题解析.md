                 

### 小米2024届校招面试高频算法题解析

#### 1. 翻转单词里的单词

**题目描述：** 编写一个函数，实现将一个字符串中的单词翻转。例如，输入 "Hello World"，输出 "World Hello"。

**思路：** 
首先，将字符串按空格分割成单词，然后将每个单词翻转，最后将翻转后的单词按照空格拼接起来。

**代码示例：**

```go
func reverseWords(s string) string {
    words := strings.Split(s, " ")
    for i, word := range words {
        words[i] = reverseString(word)
    }
    return strings.Join(words, " ")
}

func reverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i := 0; i < n/2; i++ {
        runes[i], runes[n-i-1] = runes[n-i-1], runes[i]
    }
    return string(runes)
}
```

**解析：**
首先，使用 `strings.Split` 函数将字符串分割成单词。然后，遍历每个单词，使用 `reverseString` 函数将其翻转。最后，使用 `strings.Join` 函数将翻转后的单词拼接起来。

#### 2. 最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少长度为 1）。返回其最大和。

**思路：**
使用动态规划的思想，定义一个数组 `dp` ，其中 `dp[i]` 表示以 `nums[i]` 为结尾的最大子序和。然后遍历数组，更新 `dp` 数组，最终得到最大子序和。

**代码示例：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i])
        maxSum = max(maxSum, dp[i])
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
首先，初始化 `maxSum` 和 `dp` 数组。然后，遍历数组 `nums` ，更新 `dp` 数组，计算以每个元素为结尾的最大子序和。同时，更新 `maxSum` ，记录最大子序和。

#### 3. 三数和

**题目描述：** 给定一个整数数组 `nums` ，返回所有三个数字的和为 0 的三元组。

**思路：**
使用双指针法。首先，对数组进行排序。然后，遍历数组，对于每个元素，使用双指针分别指向其左右两侧，判断三者的和是否为 0。如果小于 0，移动左指针；如果大于 0，移动右指针。

**代码示例：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var result [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return result
}
```

**解析：**
首先，对数组进行排序。然后，遍历数组，对于每个元素，使用双指针法查找和为 0 的三元组。在找到合适的三元组后，移动左右指针，避免重复计算。

#### 4. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**思路：**
使用哈希表。遍历数组，对于每个元素 `nums[i]`，判断 `target - nums[i]` 是否存在于哈希表中。如果存在，返回 `[i, 哈希表中的值]`。

**代码示例：**

```go
func twoSum(nums []int, target int) []int {
    var result []int
    mp := make(map[int]int)
    for i, num := range nums {
        if v, ok := mp[target-num]; ok {
            result = []int{v, i}
            break
        }
        mp[num] = i
    }
    return result
}
```

**解析：**
创建一个哈希表 `mp` ，用于存储元素的值和下标。遍历数组，对于每个元素 `num`，判断 `target - num` 是否存在于哈希表中。如果存在，返回对应下标。否则，将 `num` 和其下标存储在哈希表中。

#### 5. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**思路：**
从第一个字符串开始，逐个字符比较，如果所有字符串都相同，则继续比较下一个字符，否则停止比较。

**代码示例：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, s := 0, strs[0]; i < len(s); i++ {
        for _, v := range strs[1:] {
            if i >= len(v) || s[i] != v[i] {
                return s[:i]
            }
        }
    }
    return s
}
```

**解析：**
首先，检查字符串数组是否为空。然后，从第一个字符串开始，逐个字符比较，如果所有字符串都相同，则继续比较下一个字符。如果遇到不同字符，则返回前缀。

#### 6. 寻找旋转排序数组中的最小值

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**思路：**
使用二分查找法。定义两个指针，一个指向数组的左端，一个指向数组的右端，然后不断缩小区间，直到找到最小值。

**代码示例：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：**
首先，定义两个指针 `left` 和 `right` ，分别指向数组的左右端。然后，进入循环，计算中间位置 `mid` 。如果 `nums[mid]` 大于 `nums[right]`，说明最小值在 `mid+1` 到 `right` 之间，否则最小值在 `left` 到 `mid` 之间。不断缩小区间，直到找到最小值。

#### 7. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 `head` 和一个整数 `val` ，删除链表中所有值为 `val` 的节点。

**思路：**
使用快慢指针法。定义两个指针 `fast` 和 `slow` ，`fast` 指向待删除节点的前一个节点，`slow` 指向待删除节点。然后，不断移动 `fast` 指针，找到下一个待删除节点，然后将 `slow` 指向 `fast` 的下一个节点，即可删除待删除节点。

**代码示例：**

```go
func deleteNode(head *ListNode, val int) *ListNode {
    dummy := &ListNode{0, head}
    fast, slow := dummy, dummy
    for fast != nil && fast.Val != val {
        fast = fast.Next
    }
    for fast != nil {
        slow.Next = fast.Next
        fast = fast.Next
    }
    return dummy.Next
}
```

**解析：**
首先，定义一个虚拟头节点 `dummy` ，然后使用快慢指针法找到待删除节点。如果找到，将 `slow` 的下一个节点指向 `fast` 的下一个节点，即可删除待删除节点。

#### 8. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**思路：**
使用递归或迭代的方法，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归或迭代地处理剩余的链表。

**代码示例：**

递归方法：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代方法：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            cur.Next = l1
            l1 = l1.Next
        } else {
            cur.Next = l2
            l2 = l2.Next
        }
        cur = cur.Next
    }
    if l1 != nil {
        cur.Next = l1
    }
    if l2 != nil {
        cur.Next = l2
    }
    return dummy.Next
}
```

**解析：**
递归方法：递归地比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归地处理剩余的链表。

迭代方法：使用一个循环，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后更新当前节点和两个链表的下一个节点。

#### 9. 合并两个有序数组

**题目描述：** 给定两个已经排序好的升序数组 `nums1` 和 `nums2` ，将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**思路：**
从 `nums1` 和 `nums2` 的末尾开始比较，将较大的值填充到 `nums1` 的末尾，直到 `nums2` 结束。

**代码示例：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**解析：**
首先，定义三个指针 `i`、`j` 和 `k` 分别指向 `nums1` 和 `nums2` 的末尾以及 `nums1` 的最后一个位置。从末尾开始比较，将较大的值填充到 `nums1` 的末尾。最后，将 `nums2` 中剩余的元素填充到 `nums1` 中。

#### 10. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2` ，返回它们的 **最长的公共子序列** 的长度。

**思路：**
使用动态规划的方法。定义一个二维数组 `dp` ，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。

**代码示例：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
首先，初始化一个二维数组 `dp` 。然后，遍历字符串 `text1` 和 `text2` ，更新 `dp` 数组。如果当前字符相同，则 `dp[i][j] = dp[i-1][j-1] + 1` ；否则，取前一个字符的最大值，即 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` 。最后，返回 `dp[m][n]` ，即为最长公共子序列的长度。

#### 11. 最长递增子序列

**题目描述：** 给定一个整数数组 `nums` ，返回 `nums` 的最长严格递增子序列的长度。

**思路：**
使用动态规划的方法。定义一个数组 `dp` ，其中 `dp[i]` 表示以 `nums[i]` 为结尾的最长递增子序列的长度。

**代码示例：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
首先，初始化一个数组 `dp` ，其中每个元素的值为 1。然后，遍历数组 `nums` ，对于每个元素 `nums[i]`，遍历前面的元素 `nums[j]`，如果 `nums[i]` 大于 `nums[j]`，则更新 `dp[i]` 的值。最后，返回 `dp` 中的最大值。

#### 12. 搜索插入位置

**题目描述：** 给定一个排序数组 `nums` ，和一个目标值 `target`，在数组中查找 `target` 的位置，如果不存在返回应插入的位置。

**思路：**
使用二分查找法。如果找到目标值，返回其位置；如果未找到，返回应插入的位置。

**代码示例：**

```go
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}
```

**解析：**
首先，定义两个指针 `left` 和 `right` 分别指向数组的左右端。然后，进入循环，计算中间位置 `mid` 。如果 `nums[mid]` 等于目标值，返回 `mid`；如果 `nums[mid]` 小于目标值，更新 `left` 为 `mid+1`；否则，更新 `right` 为 `mid`。循环直到 `left` 等于 `right`，返回 `left`，即为应插入的位置。

#### 13. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**思路：**
使用快慢指针法。定义两个指针 `fast` 和 `slow` ，`fast` 指向快节点，`slow` 指向慢节点。每次 `fast` 和 `slow` 分别向前移动两个节点和两个节点，如果它们相遇，则链表中存在环。

**代码示例：**

```go
func hasCycle(head *ListNode) bool {
    if head == nil {
        return false
    }
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            return true
        }
    }
    return false
}
```

**解析：**
首先，检查链表是否为空。然后，定义两个指针 `fast` 和 `slow` ，分别指向快节点和慢节点。每次 `fast` 和 `slow` 分别向前移动两个节点和两个节点，如果它们相遇，则返回 `true`，否则返回 `false`。

#### 14. 螺旋矩阵

**题目描述：** 给你一个 `m * n` 的矩阵 `mat` ，请你返回 `mat` 的螺旋矩阵形式。

**思路：**
模拟螺旋矩阵的生成过程，从外层开始，依次向内层循环。

**代码示例：**

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    m, n := len(matrix), len(matrix[0])
    ans := make([]int, 0, m*n)
    t, b, l, r := 0, m-1, 0, n-1
    for len(ans) < m*n {
        // 从左到右
        for r >= l && len(ans) < m*n {
            ans = append(ans, matrix[t][l:r+1])
            l++
        }
        // 从上到下
        for b >= t && len(ans) < m*n {
            ans = append(ans, matrix[b][l:r+1])
            b--
        }
        // 从右到左
        for r >= l && len(ans) < m*n {
            ans = append(ans, matrix[b][l:r+1])
            r--
        }
        // 从下到上
        for b >= t && len(ans) < m*n {
            ans = append(ans, matrix[t][l:r+1])
            b--
        }
        l++
        r--
        t++
        b--
    }
    return ans
}
```

**解析：**
首先，检查矩阵是否为空。然后，初始化四个边界变量 `t`（上边界）、`b`（下边界）、`l`（左边界）和 `r`（右边界）。接着，模拟螺旋矩阵的生成过程，从外层开始，依次向内层循环，将每一层的元素添加到结果数组 `ans` 中。

#### 15. 二进制中 1 的个数

**题目描述：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**思路：**
通过不断将数字除以 2，统计余数为 1 的次数。

**代码示例：**

```go
func hammingWeight(num uint32) int {
    cnt := 0
    for num > 0 {
        cnt += int(num & 1)
        num >>= 1
    }
    return cnt
}
```

**解析：**
通过位运算 `num & 1` 判断当前位是否为 1，如果为 1，计数器 `cnt` 加 1。然后，将数字右移一位，继续判断下一个位。循环直到数字变为 0，返回计数器 `cnt` 的值。

#### 16. 寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`，请你找出并返回这两个正序数组的中位数。

**思路：**
使用归并排序的思想，将两个数组合并为一个，然后找到中位数。

**代码示例：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i == m {
                minRight = nums2[j]
            } else if j == n {
                minRight = nums1[i]
            } else {
                minRight = min(nums1[i], nums2[j])
            }
            return (maxLeft + minRight) / 2.0
        }
    }
    return 0
}
```

**解析：**
首先，确定较小的数组 `nums1` 和较大的数组 `nums2`。然后，使用二分查找法，在 `nums1` 中找到合适的位置 `i`，使得 `nums1[i-1]` 和 `nums2[j-1]` 组成的数组和 `nums1[i]` 和 `nums2[j]` 组成的数组和相等。如果 `m+n` 为奇数，返回较大的数；如果为偶数，返回两个数的平均值。

#### 17. 搜索旋转排序数组

**题目描述：** 已知一个按升序排列的整数数组 `nums` ，可能存在多个旋转操作。请编写一个函数来找出并返回 `nums` 的旋转下标 `k` ，如果 `k` 存在，则返回 `k` ；否则返回 `-1` 。

**思路：**
使用二分查找法，找到旋转点。

**代码示例：**

```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    while left < right:
        mid := (left + right) / 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    if nums[left] == target:
        return left
    return -1
}
```

**解析：**
首先，定义两个指针 `left` 和 `right`，分别指向数组的左右边界。然后，进入二分查找的循环，如果 `nums[mid]` 大于 `nums[right]`，说明旋转点在 `mid+1` 到 `right` 之间，否则旋转点在 `left` 到 `mid` 之间。循环直到 `left` 等于 `right`，如果 `nums[left]` 等于目标值，返回 `left`；否则返回 `-1`。

#### 18. 寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`，请你找出并返回这两个正序数组的中位数。

**思路：**
使用归并排序的思想，将两个数组合并为一个，然后找到中位数。

**代码示例：**

```go
def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m
    imin, imax, halfLen = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = halfLen - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                maxLeft = nums2[j - 1]
            elif j == 0:
                maxLeft = nums1[i - 1]
            else:
                maxLeft = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return maxLeft
            if i == m:
                minRight = nums2[j]
            elif j == n:
                minRight = nums1[i]
            else:
                minRight = min(nums1[i], nums2[j])
            return (maxLeft + minRight) // 2
    return 0
```

**解析：**
首先，确定较小的数组 `nums1` 和较大的数组 `nums2`。然后，使用二分查找法，在 `nums1` 中找到合适的位置 `i`，使得 `nums1[i-1]` 和 `nums2[j-1]` 组成的数组和 `nums1[i]` 和 `nums2[j]` 组成的数组和相等。如果 `m+n` 为奇数，返回较大的数；如果为偶数，返回两个数的平均值。

#### 19. 盛水最多的容器

**题目描述：** 给定一个长度为 `n` 的数组 `heights` ，找出其中两个不同下标的数，使得它们的差值最大化，且这两个数的差值小于等于 `k`。

**思路：**
使用双指针法，一个指针指向容器的高度，另一个指针指向容器的长度，每次移动较短的一侧。

**代码示例：**

```python
def maxContainer(heights, k):
    n = len(heights)
    left, right = 0, 1
    max_diff = heights[right] - heights[left]
    while right < n:
        while right < n and heights[right] - heights[left] <= k:
            max_diff = max(max_diff, right - left)
            right += 1
        left += 1
        if left < right:
            max_diff = max(max_diff, heights[right] - heights[left])
    return max_diff
```

**解析：**
初始化两个指针 `left` 和 `right`，分别指向容器的左侧和右侧。然后，遍历数组，每次移动较短的一侧的指针，更新最大差值。如果当前差值大于最大差值，则更新最大差值。

#### 20. 最长回文子串

**题目描述：** 给定一个字符串 `s` ，找到其最长的回文子串。

**思路：**
使用动态规划的方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s` 的子串 `s[i...j]` 是否为回文。

**代码示例：**

```python
def longestPalindrome(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    start, max_len = 0, 1
    for i in range(n):
        dp[i][i] = True
        if i < n - 1 and s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_len = 2
    for l in range(3, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            dp[i][j] = s[i] == s[j] and dp[i + 1][j - 1]
            if dp[i][j] and l > max_len:
                start = i
                max_len = l
    return s[start:start + max_len]
```

**解析：**
首先，初始化一个二维数组 `dp`，其中 `dp[i][i]` 为 `True`，表示单个字符是回文。然后，遍历所有可能的子串长度，更新 `dp` 数组。如果 `s[i] == s[j]` 且 `dp[i+1][j-1]` 为 `True`，则 `dp[i][j]` 为 `True`。最后，返回最长的回文子串。

#### 21. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**思路：**
使用递归或迭代的方法，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归或迭代地处理剩余的链表。

**代码示例：**

递归方法：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

迭代方法：

```python
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

**解析：**
递归方法：递归地比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归地处理剩余的链表。

迭代方法：使用一个循环，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后更新当前节点和两个链表的下一个节点。

#### 22. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**思路：**
从第一个字符串开始，逐个字符比较，如果所有字符串都相同，则继续比较下一个字符，否则停止比较。

**代码示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i := 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix
```

**解析：**
首先，检查字符串数组是否为空。然后，从第一个字符串开始，逐个字符比较，如果所有字符串都相同，则继续比较下一个字符。如果遇到不同字符，则停止比较，返回当前的前缀。

#### 23. 合并两个有序链表

**题目描述：** 给定两个有序链表 `l1` 和 `l2` ，将它们合并为一个新的有序链表并返回。新链表是通过拼接 `l1` 和 `l2` 的所有节点组成的。

**思路：**
使用递归或迭代的方法，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归或迭代地处理剩余的链表。

**代码示例：**

递归方法：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

迭代方法：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

**解析：**
递归方法：递归地比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归地处理剩余的链表。

迭代方法：使用一个循环，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后更新当前节点和两个链表的下一个节点。

#### 24. 二进制求和

**题目描述：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**思路：**
使用位运算模拟加法运算，从最低位开始逐位相加，进位处理。

**代码示例：**

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        max_len = max(len(a), len(b))
        a = a.zfill(max_len)
        b = b.zfill(max_len)
        carry = 0
        result = []
        for i in range(max_len - 1, -1, -1):
            total = carry
            total += 1 if a[i] == '1' else 0
            total += 1 if b[i] == '1' else 0
            result.append(str(total % 2))
            carry = total // 2
        if carry:
            result.append('1')
        return ''.join(result[::-1])
```

**解析：**
首先，将两个二进制字符串填充为相同长度。然后，从最低位开始逐位相加，记录进位。将当前位的和取模 2 得到当前位的结果，将当前位的和除以 2 得到进位。最后，将结果反转并返回。

#### 25. 盛水最多的容器

**题目描述：** 给你一个整数数组 `heights` ，表示一个形状特殊的容器的高度图。容器沿地面展开后，形成一个直方形，容器的高度就是直方图中每个列的高度。宽度和长度分别为容器的高度图中的行数和列数。

**思路：**
使用双指针法，一个指针指向容器的左侧，另一个指针指向容器的右侧，每次移动较短的一侧。

**代码示例：**

```python
def maxArea(heights):
    left, right = 0, len(heights) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(heights[left], heights[right]) * (right - left))
        if heights[left] < heights[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**解析：**
初始化两个指针 `left` 和 `right`，分别指向容器的左侧和右侧。计算当前容器的面积，更新最大面积。每次移动较短的一侧，直到 `left` 等于 `right`。

#### 26. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2` ，请你返回它们的最长公共子序列的长度。

**思路：**
使用动态规划的方法。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。

**代码示例：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：**
首先，初始化一个二维数组 `dp`。然后，遍历字符串 `text1` 和 `text2`，更新 `dp` 数组。如果当前字符相同，则 `dp[i][j] = dp[i-1][j-1] + 1`；否则，取前一个字符的最大值，即 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。最后，返回 `dp[m][n]`，即为最长公共子序列的长度。

#### 27. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**思路：**
使用快慢指针法。定义两个指针 `fast` 和 `slow`，`fast` 指向快节点，`slow` 指向慢节点。每次 `fast` 和 `slow` 分别向前移动两个节点和两个节点，如果它们相遇，则链表中存在环。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head):
    if not head:
        return False
    fast, slow = head, head
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
        if fast == slow:
            return True
    return False
```

**解析：**
首先，检查链表是否为空。然后，定义两个指针 `fast` 和 `slow`，分别指向快节点和慢节点。每次 `fast` 和 `slow` 分别向前移动两个节点和两个节点，如果它们相遇，则返回 `True`，否则返回 `False`。

#### 28. 搜索旋转排序数组

**题目描述：** 给定一个按升序排列的整数数组 `nums` ，可能存在多个旋转操作。请编写一个函数来找出并返回 `nums` 的旋转下标 `k` ，如果 `k` 存在，则返回 `k` ；否则返回 `-1` 。

**思路：**
使用二分查找法，找到旋转点。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    if nums[left] == target:
        return left
    return -1
```

**解析：**
首先，定义两个指针 `left` 和 `right`，分别指向数组的左右边界。然后，进入二分查找的循环，如果 `nums[mid]` 大于 `nums[right]`，说明旋转点在 `mid+1` 到 `right` 之间，否则旋转点在 `left` 到 `mid` 之间。循环直到 `left` 等于 `right`，如果 `nums[left]` 等于目标值，返回 `left`；否则返回 `-1`。

#### 29. 最长回文子串

**题目描述：** 给定一个字符串 `s` ，找到其最长的回文子串。

**思路：**
使用动态规划的方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `s` 的子串 `s[i...j]` 是否为回文。

**代码示例：**

```python
def longestPalindrome(s):
    m = len(s)
    dp = [[False] * m for _ in range(m)]
    start, max_len = 0, 1
    for i in range(m):
        dp[i][i] = True
    for i in range(m - 1, -1, -1):
        for j in range(i + 1, m):
            if s[i] == s[j]:
                dp[i][j] = j - i < 3 or dp[i + 1][j - 1]
                if dp[i][j]:
                    start = i
                    max_len = j - i + 1
            else:
                dp[i][j] = False
    return s[start:start + max_len]
```

**解析：**
首先，初始化一个二维数组 `dp`。然后，遍历字符串 `s`，更新 `dp` 数组。如果当前字符相同，则 `dp[i][j]` 的值为前一个字符的回文子串加上当前字符，即 `dp[i][j] = dp[i + 1][j - 1]`。否则，`dp[i][j]` 的值为 `False`。最后，返回最长的回文子串。

#### 30. 合并两个有序链表

**题目描述：** 给定两个单链表，它们按升序排列，将这两个链表合并为一个新的链表并返回。新链表同样按升序排列。

**思路：**
使用递归或迭代的方法，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归或迭代地处理剩余的链表。

**代码示例：**

递归方法：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

迭代方法：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

**解析：**
递归方法：递归地比较两个链表的头节点值，将较小的值节点添加到新链表中，然后递归地处理剩余的链表。

迭代方法：使用一个循环，比较两个链表的头节点值，将较小的值节点添加到新链表中，然后更新当前节点和两个链表的下一个节点。

