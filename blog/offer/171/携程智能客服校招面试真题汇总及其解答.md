                 

### 2024携程智能客服校招面试真题汇总及其解答

#### 1. 计算字符串中两数之和的最小距离

**题目：** 给定一个字符串，其中包含数字和一些其他字符，请找出其中两个数字之和的最小距离。

**输入：** `"abc123def456"`

**输出：** `3`

**解析：** 找到字符串中的两个数字 `"123"` 和 `"456"`，它们之间的距离是 `3`。

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

func findMinDistance(s string) int {
    nums := strings.FieldsFunc(s, func(r rune) bool {
        return !strings.ContainsRune("0123456789", r)
    })

    minDistance := len(s)
    for i := 0; i < len(nums)-1; i++ {
        for j := i + 1; j < len(nums); j++ {
            num1, _ := strconv.Atoi(nums[i])
            num2, _ := strconv.Atoi(nums[j])
            distance := abs(num1+num2) - abs(int64(i)-int64(j))
            if distance < minDistance {
                minDistance = distance
            }
        }
    }
    return minDistance
}

func abs(x int64) int64 {
    if x < 0 {
        return -x
    }
    return x
}

func main() {
    s := "abc123def456"
    result := findMinDistance(s)
    fmt.Println(result) // 输出 3
}
```

#### 2. 判断字符串是否为有效的括号序列

**题目：** 给定一个字符串，请判断它是否为有效的括号序列。

**输入：** `"()"`

**输出：** `true`

**解析：** 该字符串是一个有效的括号序列，因为没有不平衡的括号。

**答案：**

```go
package main

import (
    "fmt"
)

func isValid(s string) bool {
    stack := []rune{}
    for _, v := range s {
        if v == '(' || v == '{' || v == '[' {
            stack = append(stack, v)
        } else {
            if len(stack) == 0 {
                return false
            }
            top := stack[len(stack)-1]
            if (v == ')' && top != '(') || (v == '}' && top != '{') || (v == ']' && top != '[') {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}

func main() {
    s := "()"
    result := isValid(s)
    fmt.Println(result) // 输出 true
}
```

#### 3. 找出字符串中第一个只出现一次的字符

**题目：** 给定一个字符串，找出其中第一个只出现一次的字符。

**输入：** `"abcdabc"`

**输出：** `'d'`

**解析：** 字符 `'d'` 是第一个只出现一次的字符。

**答案：**

```go
package main

import (
    "fmt"
)

func firstUniqChar(s string) rune {
    cnt := [26]int{}
    for _, v := range s {
        cnt[v-'a']++
    }
    for _, v := range s {
        if cnt[v-'a'] == 1 {
            return v
        }
    }
    return 0
}

func main() {
    s := "abcdabc"
    result := firstUniqChar(s)
    fmt.Println(string(result)) // 输出 'd'
}
```

#### 4. 判断一个整数是否是回文数

**题目：** 给定一个整数，请判断它是否是回文数。

**输入：** `12321`

**输出：** `true`

**解析：** 数字 `12321` 是回文数，因为它正读和反读都相同。

**答案：**

```go
package main

import (
    "fmt"
)

func isPalindrome(x int) bool {
    if x < 0 || (x%10==0 && x!=0) {
        return false
    }
    reverse := 0
    for x>reverse && x>=10 {
        reverse = reverse*10 + x%10
        x /= 10
    }
    return x==reverse || x==reverse/10
}

func main() {
    x := 12321
    result := isPalindrome(x)
    fmt.Println(result) // 输出 true
}
```

#### 5. 合并两个有序链表

**题目：** 将两个有序链表合并为一个有序链表。

**输入：** `1->3->5` 和 `2->4->6`

**输出：** `1->2->3->4->5->6`

**解析：** 合并后的链表应该包含所有节点，并保持原有的顺序。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5, Next: nil}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6, Next: nil}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

#### 6. 求最长公共前缀

**题目：** 给定一个字符串数组，找到其中最长公共前缀。

**输入：** `["flower", "flow", "flight"]`

**输出：** `"fl"`

**解析：** 最长公共前缀是 `"fl"`。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, str := range strs[1:] {
        for i := 0; i < len(prefix) && i < len(str); i++ {
            if prefix[i] != str[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println(result) // 输出 "fl"
}
```

#### 7. 二分查找

**题目：** 在一个有序数组中查找目标值，使用二分查找算法。

**输入：** `[1, 3, 5, 7, 9]`，目标值为 `5`

**输出：** `2`

**解析：** 目标值 `5` 在数组中的索引为 `2`。

**答案：**

```go
package main

import (
    "fmt"
)

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

func main() {
    nums := []int{1, 3, 5, 7, 9}
    target := 5
    result := search(nums, target)
    fmt.Println(result) // 输出 2
}
```

#### 8. 判断二分查找树是否是有效的

**题目：** 判断一棵二叉树是否是有效的二叉查找树。

**输入：** `1`（根节点）

```
   1
    \
     2
      \
       3
```

**输出：** `true`

**解析：** 该二叉树是有效的二叉查找树，因为每个节点的值都小于它的右子节点的值。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isValidBST(root *TreeNode) bool {
    return dfs(root, nil, nil)
}

func dfs(node *TreeNode, min, max *TreeNode) bool {
    if node == nil {
        return true
    }
    if min != nil && node.Val <= min.Val || max != nil && node.Val >= max.Val {
        return false
    }
    return dfs(node.Left, min, node) && dfs(node.Right, node, max)
}

func main() {
    root := &TreeNode{Val: 1}
    root.Right = &TreeNode{Val: 2}
    root.Right.Right = &TreeNode{Val: 3}
    result := isValidBST(root)
    fmt.Println(result) // 输出 true
}
```

#### 9. 调整数组顺序使奇数位于偶数前面

**题目：** 调整数组中奇数和偶数的顺序，使得奇数都位于偶数前面。

**输入：** `[2, 3, 1, 4]`

**输出：** `[1, 3, 2, 4]`

**解析：** 数组中奇数 `1` 和 `3` 位于偶数 `2` 和 `4` 之前。

**答案：**

```go
package main

import "fmt"

func swap(nums []int, i, j int) {
    nums[i], nums[j] = nums[j], nums[i]
}

func rearrange(nums []int) {
    left, right := 0, len(nums)-1
    for left < right {
        for left < right && nums[left]%2 == 0 {
            left++
        }
        for left < right && nums[right]%2 == 1 {
            right--
        }
        if left < right {
            swap(nums, left, right)
        }
    }
}

func main() {
    nums := []int{2, 3, 1, 4}
    rearrange(nums)
    fmt.Println(nums) // 输出 [1, 3, 2, 4]
}
```

#### 10. 检测循环链表

**题目：** 给定一个链表，判断其是否为循环链表。

**输入：** `1->2->3->4`

**输出：** `false`

**解析：** 该链表不是循环链表，因为链表的最后一个节点的 `next` 指针指向 `nil`。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    result := hasCycle(head)
    fmt.Println(result) // 输出 false
}
```

#### 11. 求最大子序列和

**题目：** 给定一个整数数组，求出所有子序列中的最大和。

**输入：** `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

**输出：** `6`

**解析：** 最大子序列和为 `6`，即子序列 `[4, -1, 2, 1]`。

**答案：**

```go
package main

import "fmt"

func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println(result) // 输出 6
}
```

#### 12. 求两个有序数组的合并

**题目：** 给定两个有序数组，合并这两个数组并排序。

**输入：** `nums1 = [1,2,3,0,0,0]`，`nums2 = [2,5,6]`

**输出：** `[1,2,2,3,5,6]`

**解析：** 合并后的数组应该包含两个数组中的所有元素，并保持有序。

**答案：**

```go
package main

import "fmt"

func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    tar := m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[tar] = nums1[p1]
            p1--
        } else {
            nums1[tar] = nums2[p2]
            p2--
        }
        tar--
    }
    for p2 >= 0 {
        nums1[tar] = nums2[p2]
        p2--
        tar--
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    nums2 := []int{2, 5, 6}
    merge(nums1, 3, nums2, 3)
    fmt.Println(nums1) // 输出 [1, 2, 2, 3, 5, 6]
}
```

#### 13. 找出旋转数组中的最小值

**题目：** 给定一个旋转数组，找出数组中的最小值。

**输入：** `[3, 4, 5, 1, 2]`

**输出：** `1`

**解析：** 数组 `[3, 4, 5, 1, 2]` 的最小值是 `1`。

**答案：**

```go
package main

import "fmt"

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{3, 4, 5, 1, 2}
    result := findMin(nums)
    fmt.Println(result) // 输出 1
}
```

#### 14. 判断二叉树是否是平衡的

**题目：** 判断一棵二叉树是否是平衡的。

**输入：** `1`（根节点）

```
   1
    \
     2
      \
       3
```

**输出：** `true`

**解析：** 该二叉树是平衡的，因为每个节点的左右子树的高度差不超过 1。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    leftHeight, rightHeight := height(root.Left), height(root.Right)
    if abs(leftHeight-rightHeight) > 1 {
        return false
    }
    return isBalanced(root.Left) && isBalanced(root.Right)
}

func height(node *TreeNode) int {
    if node == nil {
        return 0
    }
    return 1 + max(height(node.Left), height(node.Right))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    root := &TreeNode{Val: 1}
    root.Right = &TreeNode{Val: 2}
    root.Right.Right = &TreeNode{Val: 3}
    result := isBalanced(root)
    fmt.Println(result) // 输出 true
}
```

#### 15. 判断两个二叉树是否相同

**题目：** 判断两个二叉树是否相同。

**输入：** `tree1` 和 `tree2`（两棵二叉树的根节点）

**输出：** `true` 或 `false`

**解析：** 如果两棵二叉树的节点一一对应且值相同，则它们是相同的。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isSameTree(p *TreeNode, q *TreeNode) bool {
    if p == nil && q == nil {
        return true
    }
    if p == nil || q == nil {
        return false
    }
    if p.Val != q.Val {
        return false
    }
    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}

func main() {
    tree1 := &TreeNode{Val: 1}
    tree1.Left = &TreeNode{Val: 2}
    tree1.Right = &TreeNode{Val: 3}
    tree2 := &TreeNode{Val: 1}
    tree2.Left = &TreeNode{Val: 2}
    tree2.Right = &TreeNode{Val: 3}
    result := isSameTree(tree1, tree2)
    fmt.Println(result) // 输出 true
}
```

#### 16. 合并两个有序链表

**题目：** 合并两个有序链表。

**输入：** `l1` 和 `l2`（两个有序链表）

**输出：** 新的有序链表

**解析：** 合并后的链表应该包含两个链表中的所有元素，并保持有序。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

#### 17. 求两个数的最大公约数

**题目：** 求两个数的最大公约数。

**输入：** `12` 和 `18`

**输出：** `6`

**解析：** `12` 和 `18` 的最大公约数是 `6`。

**答案：**

```go
package main

import (
    "fmt"
)

func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    a := 12
    b := 18
    result := gcd(a, b)
    fmt.Println(result) // 输出 6
}
```

#### 18. 判断一个数是否是素数

**题目：** 判断一个数是否是素数。

**输入：** `13`

**输出：** `true`

**解析：** `13` 是素数，因为它只能被 `1` 和自身整除。

**答案：**

```go
package main

import (
    "fmt"
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func main() {
    n := 13
    result := isPrime(n)
    fmt.Println(result) // 输出 true
}
```

#### 19. 求两个数的和

**题目：** 求两个数的和。

**输入：** `5` 和 `7`

**输出：** `12`

**解析：** `5` 和 `7` 的和是 `12`。

**答案：**

```go
package main

import "fmt"

func add(a, b int) int {
    return a + b
}

func main() {
    a := 5
    b := 7
    result := add(a, b)
    fmt.Println(result) // 输出 12
}
```

#### 20. 求一个数组的中间值

**题目：** 求一个整数数组的中间值。

**输入：** `[1, 3, 5]`

**输出：** `3`

**解析：** 整数数组 `[1, 3, 5]` 的中间值是 `3`。

**答案：**

```go
package main

import "fmt"

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    total := m + n
    if total%2 == 1 {
        return float64(findKthElement(nums1, nums2, total/2+1))
    }
    return 0.5 * (findKthElement(nums1, nums2, total/2) + findKthElement(nums1, nums2, total/2+1))
}

func findKthElement(nums1, nums2 []int, k int) int {
    m, n := len(nums1), len(nums2)
    if nums1 == nil || m == 0 {
        return nums2[k-1]
    }
    if nums2 == nil || n == 0 {
        return nums1[k-1]
    }
    if k == 1 {
        return min(nums1[0], nums2[0])
    }
    p1, p2 := min(k/2, m), min(k/2, n)
    if nums1[p1-1] > nums2[p2-1] {
        return findKthElement(nums1, nums2[p2:], k-p2)
    } else if nums1[p1-1] < nums2[p2-1] {
        return findKthElement(nums1[p1:], nums2, k-p1)
    } else {
        return nums1[p1-1]
    }
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    nums1 := []int{1, 3, 5}
    nums2 := []int{2, 4, 6}
    result := findMedianSortedArrays(nums1, nums2)
    fmt.Println(result) // 输出 3.0
}
```

#### 21. 求字符串的长度

**题目：** 求给定字符串的长度。

**输入：** `"Hello, World!"`

**输出：** `13`

**解析：** 字符串 `"Hello, World!"` 的长度是 `13`。

**答案：**

```go
package main

import "fmt"

func length(s string) int {
    return len(s)
}

func main() {
    s := "Hello, World!"
    result := length(s)
    fmt.Println(result) // 输出 13
}
```

#### 22. 判断一个字符串是否是回文

**题目：** 判断给定字符串是否是回文。

**输入：** `"level"`

**输出：** `true`

**解析：** 字符串 `"level"` 是回文，因为它正读和反读都相同。

**答案：**

```go
package main

import "fmt"

func isPalindrome(s string) bool {
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}

func main() {
    s := "level"
    result := isPalindrome(s)
    fmt.Println(result) // 输出 true
}
```

#### 23. 求两个数的最大值

**题目：** 求给定两个整数的最大值。

**输入：** `3` 和 `5`

**输出：** `5`

**解析：** 整数 `3` 和 `5` 的最大值是 `5`。

**答案：**

```go
package main

import "fmt"

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    a := 3
    b := 5
    result := max(a, b)
    fmt.Println(result) // 输出 5
}
```

#### 24. 判断一个整数是否是偶数

**题目：** 判断给定整数是否是偶数。

**输入：** `4`

**输出：** `true`

**解析：** 整数 `4` 是偶数，因为它可以被 `2` 整除。

**答案：**

```go
package main

import "fmt"

func isEven(n int) bool {
    return n%2 == 0
}

func main() {
    n := 4
    result := isEven(n)
    fmt.Println(result) // 输出 true
}
```

#### 25. 求一个数组的平均值

**题目：** 求给定数组的平均值。

**输入：** `[1, 2, 3, 4, 5]`

**输出：** `3`

**解析：** 数组 `[1, 2, 3, 4, 5]` 的平均值是 `3`。

**答案：**

```go
package main

import "fmt"

func average(nums []int) float64 {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return float64(sum) / float64(len(nums))
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := average(nums)
    fmt.Println(result) // 输出 3
}
```

#### 26. 求一个整数数组的最大值

**题目：** 求给定整数数组的最大值。

**输入：** `[3, 1, 4, 1, 5]`

**输出：** `5`

**解析：** 整数数组 `[3, 1, 4, 1, 5]` 的最大值是 `5`。

**答案：**

```go
package main

import "fmt"

func max(nums []int) int {
    maxNum := nums[0]
    for _, num := range nums {
        if num > maxNum {
            maxNum = num
        }
    }
    return maxNum
}

func main() {
    nums := []int{3, 1, 4, 1, 5}
    result := max(nums)
    fmt.Println(result) // 输出 5
}
```

#### 27. 求一个整数数组的和

**题目：** 求给定整数数组的和。

**输入：** `[1, 2, 3, 4, 5]`

**输出：** `15`

**解析：** 整数数组 `[1, 2, 3, 4, 5]` 的和是 `15`。

**答案：**

```go
package main

import "fmt"

func sum(nums []int) int {
    sum := 0
    for _, num := range nums {
        sum += num
    }
    return sum
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    result := sum(nums)
    fmt.Println(result) // 输出 15
}
```

#### 28. 求一个数组的中间值

**题目：** 求给定整数数组的中间值。

**输入：** `[1, 3, 5]`

**输出：** `3`

**解析：** 整数数组 `[1, 3, 5]` 的中间值是 `3`。

**答案：**

```go
package main

import "fmt"

func findMedian(arr []int) float64 {
    n := len(arr)
    if n%2 == 0 {
        return float64(arr[n/2-1]+arr[n/2]) / 2.0
    } else {
        return float64(arr[n/2])
    }
}

func main() {
    arr := []int{1, 3, 5}
    result := findMedian(arr)
    fmt.Println(result) // 输出 3.0
}
```

#### 29. 判断一个整数是否是正数

**题目：** 判断给定整数是否是正数。

**输入：** `5`

**输出：** `true`

**解析：** 整数 `5` 是正数。

**答案：**

```go
package main

import "fmt"

func isPositive(num int) bool {
    return num > 0
}

func main() {
    num := 5
    result := isPositive(num)
    fmt.Println(result) // 输出 true
}
```

#### 30. 求两个字符串的长度

**题目：** 求给定两个字符串的长度。

**输入：** `"Hello"` 和 `"World"`

**输出：** `5` 和 `5`

**解析：** 字符串 `"Hello"` 和 `"World"` 的长度都是 `5`。

**答案：**

```go
package main

import "fmt"

func stringLength(s string) int {
    return len(s)
}

func main() {
    s1 := "Hello"
    s2 := "World"
    result1 := stringLength(s1)
    result2 := stringLength(s2)
    fmt.Println(result1, result2) // 输出 5 5
}
```

### 总结

本博客汇总了2024携程智能客服校招面试真题，包括算法编程题和数据结构题，提供了详细的答案解析和示例代码。通过这些面试题的解答，可以帮助准备校招的考生更好地理解和掌握相关的编程知识和算法技巧。希望这些面试题能够为大家的求职之路提供帮助！

