                 

### 小米2025届社招面试高频算法题解析

在准备面试时，了解各大公司的高频算法题是至关重要的。本文将围绕小米2025届社招面试中的高频算法题进行解析，提供详尽的答案解析说明和源代码实例。以下是典型问题/面试题库：

#### 1. 判断二分查找树的合法性

**题目描述：**  
请实现一个函数，判断一棵二分查找树是否合法。

**示例：**  
输入：`{5, 3, 7, 2, 4, 6, 8}`  
输出：`True`

**答案：**

```go
func isValidBST(root *TreeNode) bool {
    return isValidBSTHelper(root, math.MinInt64, math.MaxInt64)
}

func isValidBSTHelper(node *TreeNode, min, max int) bool {
    if node == nil {
        return true
    }
    if node.Val <= min || node.Val >= max {
        return false
    }
    return isValidBSTHelper(node.Left, min, node.Val) && isValidBSTHelper(node.Right, node.Val, max)
}
```

**解析：**  
我们使用递归的方法，从根节点开始，判断其值是否在给定的区间内。对于当前节点，其左子节点的值必须小于当前节点的值，而右子节点的值必须大于当前节点的值。递归判断左子树和右子树是否合法，最后返回结果。

#### 2. 最长公共前缀

**题目描述：**  
编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**  
输入：`["flower", "flow", "flight"]`  
输出：`"fl"`

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
        }
        if len(prefix) == 0 {
            return ""
        }
    }
    return prefix
}
```

**解析：**  
我们首先取第一个字符串作为前缀。然后遍历其余的字符串，如果当前字符串不是以当前前缀开头，则缩短前缀。重复这个过程，直到找到一个公共前缀或者前缀为空。

#### 3. 反转链表

**题目描述：**  
定义一个函数，用于反转链表。

**示例：**  
输入：`1->2->3->4->5`  
输出：`5->4->3->2->1`

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**解析：**  
我们使用迭代的方式，遍历链表，在遍历过程中将每个节点的 `next` 指针反向。最后，返回新的头节点。

#### 4. 两数相加

**题目描述：**  
定义两个链表，表示两个非负整数。每个节点存储一个数字。请实现一个函数，将这两个数相加，并以链表形式返回结果。

**示例：**  
输入：（`1->2->3` 和 `5->6->7`）  
输出：（`2->1->4->7`）

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        curr.Next = &ListNode{sum % 10, nil}
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：**  
我们使用迭代的方式，从两个链表的头节点开始，逐个相加。如果当前位相加大于等于10，则进位。最后返回新的头节点。

#### 5. 最短子数组使和大于或等于目标值

**题目描述：**  
给定一个整数数组和一个目标值，找出最短的连续子数组长度，其和大于或等于目标值。

**示例：**  
输入：`[1,2,3,4,5]` 和 `7`  
输出：`2` （子数组 `[4,5]` 的和为 `9`）

**答案：**

```go
func shortestSubarray(nums []int, target int) int {
    n := len(nums)
    ans := n
    preSum := make([]int, n+1)
    for i := 1; i <= n; i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    for i := 1; i <= n; i++ {
        left, right := 1, i
        for left <= right {
            mid := left + (right-left)>>1
            if preSum[i] - preSum[mid-1] >= target {
                ans = min(ans, i-mid+1)
                right = mid-1
            } else {
                left = mid + 1
            }
        }
    }
    return ans
}
```

**解析：**  
我们使用二分查找的方法，对于每个位置 `i`，找出最大的 `mid`，使得 `preSum[i] - preSum[mid-1]` 大于或等于目标值。更新结果 `ans`，最后返回答案。

#### 6. 链表中倒数第k个节点

**题目描述：**  
给定一个链表和一个整数 `k`，返回链表中倒数第 `k` 个节点。

**示例：**  
输入：`[1,2,3,4,5]` 和 `2`  
输出：节点值为 `4`

**答案：**

```go
func getKthFromEnd(head *ListNode, k int) *ListNode {
    fast := head
    for i := 0; i < k; i++ {
        if fast == nil {
            return nil
        }
        fast = fast.Next
    }
    slow := head
    while fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

**解析：**  
我们使用双指针的方法，一个快指针 `fast` 和一个慢指针 `slow`。首先让 `fast` 先走 `k` 步，然后两者同时开始移动。当 `fast` 到达链表末尾时，`slow` 就指向了倒数第 `k` 个节点。

#### 7. 合并两个有序链表

**题目描述：**  
给定两个有序链表，将它们合并成一个有序链表。

**示例：**  
输入：（`1->3->5` 和 `2->4->6`）  
输出：`1->2->3->4->5->6`

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：**  
我们使用递归的方法，每次比较两个链表的头节点，选择较小的值作为新链表的头节点，并递归地处理剩余的链表。

#### 8. 二进制中1的个数

**题目描述：**  
编写一个函数，计算一个无符号整数二进制表示中 1 的个数。

**示例：**  
输入：`int n = 11`（二进制为 `1011`）  
输出：`3`

**答案：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num > 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：**  
我们使用位操作的方法，通过不断将数字 `num` 和 1 进行与操作，如果结果为 1，则计数器加 1。然后，我们将 `num` 右移一位，继续这个过程，直到 `num` 变为 0。

#### 9. 翻转整数

**题目描述：**  
编写一个函数，实现整数翻转。

**示例：**  
输入：`int x = 123`  
输出：`321`

**答案：**

```go
func reverse(x int) int {
    var res int
    for x > 0 || x < 0 && x != -1 {
        res = res*10 + x%10
        if res >= 1<<31 || res < -(1<<31) {
            return 0
        }
        x /= 10
    }
    return res
}
```

**解析：**  
我们使用循环的方式，将整数的每一位添加到结果 `res` 的末尾。为了防止溢出，我们在每次循环后检查结果 `res` 是否超出范围。如果超出范围，我们返回 0。

#### 10. 合并两个有序数组

**题目描述：**  
给定两个有序数组 `nums1` 和 `nums2`，将它们合并成一个有序数组。

**示例：**  
输入：`nums1 = [1,2,3,0,0,0]`，`nums2 = [2,5,6]`  
输出：`[1,2,2,3,5,6]`

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i := m - 1
    j := n - 1
    t := len(nums1) - 1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[t] = nums1[i]
            i--
        } else {
            nums1[t] = nums2[j]
            j--
        }
        t--
    }
    for j >= 0 {
        nums1[t] = nums2[j]
        j--
        t--
    }
}
```

**解析：**  
我们使用两个指针 `i` 和 `j` 分别指向两个数组的末尾，一个指针 `t` 指向合并后数组末尾的位置。我们比较两个指针指向的元素，将较大的元素放入合并后的数组中，并相应地移动指针。最后，如果还有剩余的元素，我们将它们放入合并后的数组中。

#### 11. 最长公共子序列

**题目描述：**  
给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子序列。

**示例：**  
输入：`str1 = "ABCD"`，`str2 = "ACDF"`  
输出：`"ACD"`

**答案：**

```go
func longestCommonSubsequence(str1 string, str2 string) string {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    i, j := m, n
    var res []byte
    for i > 0 && j > 0 {
        if str1[i-1] == str2[j-1] {
            res = append(res, str1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(res)
    return string(res)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**  
我们使用动态规划的方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `str1` 的前 `i` 个字符和字符串 `str2` 的前 `j` 个字符的最长公共子序列的长度。最后，我们根据 `dp` 数组回溯，找出最长公共子序列。

#### 12. 找出所有连续子数组的和为 0

**题目描述：**  
给定一个整数数组，找出所有连续子数组的和为 0 的子数组。

**示例：**  
输入：`[1, 2, -3, 3, 4]`  
输出：`[0, 1, 2, 3, 4]`

**答案：**

```go
func findAllZeroSumSubarrays(nums []int) [][]int {
    ans := make([][]int, 0)
    prefixSum := 0
    cnt := make(map[int]int)
    cnt[0] = -1
    for i, num := range nums {
        prefixSum += num
        if p, ok := cnt[prefixSum]; ok {
            ans = append(ans, []int{p + 1, i})
        }
        cnt[prefixSum] = i
    }
    return ans
}
```

**解析：**  
我们使用哈希表的方法，计算前缀和，并记录每个前缀和首次出现的位置。如果当前的前缀和在前已经出现过，则说明从上次出现的位置到当前位置的子数组的和为 0。

#### 13. 搜索旋转排序数组

**题目描述：**  
给定一个旋转排序的整数数组，实现一个搜索算法，查找给定目标值在数组中的索引。

**示例：**  
输入：`[4,5,6,7,0,1,2]` 和 `0`  
输出：`4`

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[left] < nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target >= nums[mid] && target < nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：**  
我们使用二分查找的方法，考虑到数组旋转的情况，我们需要比较当前中间元素和左右边界元素的关系来确定下一次查找的范围。

#### 14. 合并区间

**题目描述：**  
给定一组区间，找出覆盖所有给定区间的最小合并区间。

**示例：**  
输入：`[[1,3],[2,6],[8,10],[15,18]]`  
输出：`[[1,6],[8,10],[15,18]]`

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] < intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })
    ans := make([][]int, 0)
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**  
我们首先对区间进行排序，然后遍历排序后的区间，合并重叠的区间。

#### 15. 最长回文子串

**题目描述：**  
给定一个字符串，找出其中最长的回文子串。

**示例：**  
输入：`"babad"`  
输出：`"bab"` 或 `"aba"`

**答案：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, mx := 0, 1
    for i := 0; i < n; i++ {
        l, r := i, i
        for l >= 0 && r < n && s[l] == s[r] {
            l--
            r++
        }
        if r-l-1 > mx {
            start = l + 1
            mx = r - l - 1
        }
        l, r = i, i+1
        for l >= 0 && r < n && s[l] == s[r] {
            l--
            r++
        }
        if r-l-1 > mx {
            start = l + 1
            mx = r - l - 1
        }
    }
    return s[start : start+mx]
}
```

**解析：**  
我们使用双指针的方法，分别检查以当前字符为中心的回文子串长度，并更新最长回文子串的开始位置和长度。

#### 16. 两数之和

**题目描述：**  
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**  
输入：`[2, 7, 11, 15]` 和 `9`  
输出：`[0, 1]`

**答案：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if v, ok := m[target-num]; ok {
            return []int{v, i}
        }
        m[num] = i
    }
    return nil
}
```

**解析：**  
我们使用哈希表的方法，遍历数组，对于每个元素 `num`，我们在哈希表中查找 `target-num` 的值。如果找到，返回对应的下标。

#### 17. 字符串相乘

**题目描述：**  
给定两个字符串表示的非负整数 `num1` 和 `num2`，返回由它们相乘表示的字符串。

**示例：**  
输入：`"123"` 和 `"456"`  
输出：`"56088"`

**答案：**

```go
func multiply(num1 string, num2 string) string {
    n1, n2 := len(num1), len(num2)
    var ans []int = make([]int, n1+n2)
    for i := range ans {
        ans[i] = 0
    }
    for i := n1 - 1; i >= 0; i-- {
        for j := n2 - 1; j >= 0; j-- {
            ans[i+j+1] += (int(num1[i]-'0')) * (int(num2[j]-'0'))
            ans[i+j] += ans[i+j+1] / 10
            ans[i+j+1] %= 10
        }
    }
    for ; len(ans) > 1 && ans[len(ans)-1] == 0; ans = ans[:len(ans)-1] {}
    var s []byte
    for _, v := range ans {
        s = append(s, byte(v+'0'))
    }
    return string(s)
}
```

**解析：**  
我们使用类似于竖式乘法的方法，计算两个数的乘积。我们将结果存储在一个数组中，然后处理进位，最后将数组转换为字符串。

#### 18. 删除链表的节点

**题目描述：**  
给定一个单链表和一个节点，请将该节点从链表中删除。

**示例：**  
输入：链表 `1->2->3->4` 和节点 `3`  
输出：链表 `1->2->4`

**答案：**

```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**解析：**  
我们将当前节点的值设置为下一个节点的值，然后将当前节点的 `next` 指针指向下一个节点的下一个节点，从而删除了下一个节点。

#### 19. 合并两个有序链表

**题目描述：**  
给定两个有序链表，将它们合并成一个有序链表。

**示例：**  
输入：（`1->3->5` 和 `2->4->6`）  
输出：`1->2->3->4->5->6`

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：**  
我们使用递归的方法，比较两个链表的头节点，选择较小的值作为新链表的头节点，并递归地处理剩余的链表。

#### 20. 两数相加 II

**题目描述：**  
给定两个非空链表表示的两个非负整数，分别位于链表的首位，将它们相加并返回一个新的链表表示的和。

**示例：**  
输入：（`7->2->4->3` 和 `5->6->2`）  
输出：（`7->8->0->5`）

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    n1, n2 := 0, 0
    for l1 != nil {
        n1++
        l1 = l1.Next
    }
    for l2 != nil {
        n2++
        l2 = l2.Next
    }
    diff := n1 - n2
    dummy := &ListNode{0, nil}
    curr := dummy
    carry := 0
    for i := 0; i <= n1 || i <= n2 || carry != 0; i++ {
        x := 0
        if i < n1 {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if i < n2 {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        curr.Next = &ListNode{sum % 10, nil}
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：**  
我们首先计算两个链表的长度差 `diff`，然后将较短的链表向左移动 `diff` 个节点。然后，我们使用类似于两数相加的方法，从低位开始相加，处理进位，并构建新的链表。

#### 21. 删除链表的倒数第 n 个节点

**题目描述：**  
给定一个链表和一个整数 `n`，删除链表的倒数第 `n` 个节点。

**示例：**  
输入：（`1->2->3->4->5` 和 `2`）  
输出：（`1->2->3->5`）

**答案：**

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{0, head}
    fast := dummy
    slow := dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

**解析：**  
我们使用双指针的方法，一个快指针 `fast` 和一个慢指针 `slow`。首先让 `fast` 先走 `n` 步，然后两者同时移动。当 `fast` 到达链表末尾时，`slow` 就指向了倒数第 `n` 个节点。然后，我们将 `slow` 的下一个节点删除。

#### 22. 最小栈

**题目描述：**  
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

**示例：**  
输入：`["MinStack","push","push","push","getMin","pop","top","getMin"]`  
输出：`[null,null,null,null,-3,null,0,-2]`

**答案：**

```go
type MinStack struct {
    stk  []int
    mstk []int
}

func Constructor() MinStack {
    return MinStack{
        stk:  []int{},
        mstk: []int{},
    }
}

func (this *MinStack) Push(x int) {
    this.stk = append(this.stk, x)
    if len(this.mstk) == 0 || x <= this.mstk[len(this.mstk)-1] {
        this.mstk = append(this.mstk, x)
    }
}

func (this *MinStack) Pop() {
    if this.stk[len(this.stk)-1] == this.mstk[len(this.mstk)-1] {
        this.mstk = this.mstk[:len(this.mstk)-1]
    }
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) GetMin() int {
    return this.mstk[len(this.mstk)-1]
}
```

**解析：**  
我们使用两个栈，一个用于存储所有元素，另一个用于存储当前最小元素。当新元素小于当前最小元素时，将其加入最小元素栈。pop 操作时，如果出栈的元素是当前最小元素，则最小元素栈也出栈。

#### 23. 两数之和 II - 输入有序数组

**题目描述：**  
给定一个已按照升序排列的有序数组 `numbers` ，和一个目标值 `target` 。从 `numbers` 中找出两个数，使得它们的和等于 `target`。

**示例：**  
输入：`[2,7,11,15]` 和 `9`  
输出：`[1,2]`

**答案：**

```go
func twoSum(numbers []int, target int) []int {
    n := len(numbers)
    l, r := 0, n-1
    sum := numbers[l] + numbers[r]
    for l < r {
        if sum == target {
            return []int{l + 1, r + 1}
        } else if sum < target {
            l++
            sum += numbers[l]
        } else {
            r--
            sum -= numbers[r]
        }
    }
    return nil
}
```

**解析：**  
我们使用双指针的方法，一个指针指向数组的开始，另一个指针指向数组的结束。我们计算两个指针指向的元素的和，如果和小于目标值，则将左指针向右移动，如果和大于目标值，则将右指针向左移动。

#### 24. 无重复字符的最长子串

**题目描述：**  
给定一个字符串 `s` ，找出其中不含有重复字符的最长子串 `T` 的长度。

**示例：**  
输入：`"abcabcbb"`  
输出：`3`

**答案：**

```go
func lengthOfLongestSubstring(s string) int {
    m := make(map[rune]int)
    ans, j := 0, 0
    for i := 0; i < len(s); i++ {
        if v, ok := m[s[i]]; ok {
            j = max(j, v+1)
        }
        ans = max(ans, i-j+1)
        m[s[i]] = i
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**  
我们使用滑动窗口的方法，维护一个窗口 `[j, i]`，其中 `j` 是窗口的左边界，`i` 是窗口的右边界。我们使用一个哈希表 `m` 记录字符在字符串中的最后出现的位置。如果当前字符在哈希表中存在，则更新窗口的左边界 `j`。

#### 25. 爬楼梯

**题目描述：**  
假设你正在爬楼梯。需要 `n` 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。

**示例：**  
输入：`3`  
输出：`3`

**答案：**

```go
func climbStairs(n int) int {
    if n < 2 {
        return n
    }
    a, b := 1, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：**  
我们可以使用动态规划的方法，定义两个变量 `a` 和 `b`，分别表示前两个台阶的数量。每次迭代，我们将 `b` 更新为前两个台阶数量的和，然后更新 `a` 的值为上一个 `b` 的值。

#### 26. 盛最多水的容器

**题目描述：**  
给定一个二维矩阵 matrix，包含正整数。计算这个矩阵中的最大元素与它的下标之间的距离。

**示例：**  
输入：`[[1,0],[0,2]]`  
输出：`2`

**答案：**

```go
func maxDistance(matrix [][]int) int {
    m, n := len(matrix), len(matrix[0])
    ans := -1
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] > 0 {
                ans = max(ans, i+matrix[i][j], m-i-matrix[i][j], n-j-matrix[i][j])
            }
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**  
我们遍历矩阵，对于每个元素，我们计算该元素所在的行和列的长度，然后计算该元素与行长度和列长度的最大值，更新答案。

#### 27. 存在重复元素 II

**题目描述：**  
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 `nums[i] == nums[j]` 且 `|i - j| <= k`。

**示例：**  
输入：`[1,2,3,1,2,3]` 和 `2`  
输出：`true`

**答案：**

```go
func containsNearbyDuplicate(nums []int, k int) bool {
    m := make(map[int]int)
    for i, v := range nums {
        if j, ok := m[v]; ok && i-j <= k {
            return true
        }
        m[v] = i
    }
    return false
}
```

**解析：**  
我们使用哈希表的方法，遍历数组，对于每个元素，我们在哈希表中查找是否有相同值的元素，并且该元素的索引距离当前元素索引不超过 `k`。如果找到，返回 `true`。

#### 28. 存在重复元素 III

**题目描述：**  
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 `nums[i] == nums[j]` 且 `|i - j| <= k`。

**示例：**  
输入：`[1,2,3,1,2,3]` 和 `3`  
输出：`true`

**答案：**

```go
func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {
    m := make(map[int]int)
    for i, v := range nums {
        near, ok := m[v]
        if ok && i-near <= k {
            return true
        }
        near, ok = m[v-t]
        if ok && i-near <= k {
            return true
        }
        near, ok = m[v+t]
        if ok && i-near <= k {
            return true
        }
        m[v] = i
    }
    return false
}
```

**解析：**  
我们使用哈希表的方法，遍历数组，对于每个元素，我们在哈希表中查找是否有值在 `[v-t, v+t]` 范围内的元素，并且该元素的索引距离当前元素索引不超过 `k`。如果找到，返回 `true`。

#### 29. 存在重复元素 IV

**题目描述：**  
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 `nums[i] == nums[j]` 且 `|i - j| <= k`。

**示例：**  
输入：`[1,2,3,1,2,3]` 和 `3`  
输出：`false`

**答案：**

```go
func containsNearbyDuplicate(nums []int, k int) bool {
    m := make(map[int]int)
    for i, v := range nums {
        if j, ok := m[v]; ok && i-j <= k {
            return true
        }
        m[v] = i
    }
    return false
}
```

**解析：**  
我们使用哈希表的方法，遍历数组，对于每个元素，我们在哈希表中查找是否有相同值的元素，并且该元素的索引距离当前元素索引不超过 `k`。如果找到，返回 `true`。

#### 30. 三数之和

**题目描述：**  
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值 `target` 的三个整数，并返回索引的三角组 `[0, 1, 2]`。

**示例：**  
输入：`[-1, 0, 1, 2, -1, -4]` 和 `0`  
输出：`[0, 1, 4]`

**答案：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    ans := make([][]int, 0)
    n := len(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, n-1
        for left < right {
            total := nums[i] + nums[left] + nums[right]
            if total < 0 {
                left++
            } else if total > 0 {
                right--
            } else {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            }
        }
    }
    return ans
}
```

**解析：**  
我们首先对数组进行排序，然后使用双指针的方法，对于每个元素，我们固定一个元素，然后使用两个指针从其左右两边开始寻找另外两个元素，使得这三个元素的和为目标值。为了防止重复，我们跳过相同的元素。

