                 

# 爱奇艺广告2025社招广告算法工程师面试指南：面试题与算法编程题解析

## 引言

在互联网广告行业中，算法工程师扮演着至关重要的角色。广告算法的优化与改进，不仅影响着广告展示的精准度，还直接关系到广告主与平台的双赢。本文旨在为准备参加爱奇艺广告算法工程师面试的候选人提供一份全面的指南，涵盖典型面试题与算法编程题，并提供详尽的解析。

## 面试题与解析

### 1. 如何评估广告点击率？

**题目：** 描述一种方法来评估广告的点击率（CTR）。

**答案：** 广告点击率（CTR）可以通过以下公式计算：

\[CTR = \frac{点击次数}{展示次数}\]

**解析：** 首先，需要收集广告的展示次数和点击次数数据。展示次数是指广告被用户看到但不点击的次数，点击次数是指用户点击广告的次数。通过计算这两个数的比值，可以得到广告的点击率。点击率越高，表明广告对用户的吸引力越强。

### 2. 如何优化广告投放策略？

**题目：** 请简述如何根据用户行为数据优化广告投放策略。

**答案：** 优化广告投放策略通常基于以下几个步骤：

1. **用户分群：** 根据用户的行为特征、兴趣标签等将用户分成不同的群体。
2. **投放测试：** 对不同用户群体进行广告投放测试，收集点击率、转化率等数据。
3. **数据分析：** 分析测试数据，找出对特定用户群体效果最好的广告类型和投放时段。
4. **调整策略：** 根据分析结果调整广告投放策略，提高广告效果。

### 3. 广告系统如何处理高并发请求？

**题目：** 描述广告系统在处理高并发请求时的技术方案。

**答案：** 高并发请求的处理方案包括：

1. **负载均衡：** 使用负载均衡器将请求分发到多个服务器节点，避免单点瓶颈。
2. **缓存：** 利用缓存系统存储热门广告数据，减少数据库访问压力。
3. **异步处理：** 对于不立即需要响应的请求，采用异步处理方式，降低系统负载。
4. **数据库优化：** 使用读写分离、分库分表等技术提升数据库性能。

### 4. 如何防止广告作弊行为？

**题目：** 描述一种方法来检测和防止广告作弊行为。

**答案：** 广告作弊行为的检测通常包括以下几种方法：

1. **行为分析：** 分析用户的点击行为，如点击频率、点击时段等，发现异常行为。
2. **黑名单：** 建立黑名单系统，将已知作弊的IP地址、设备号等加入黑名单。
3. **机器学习：** 使用机器学习算法识别可能的作弊行为，如自动化脚本、恶意点击等。

### 5. 广告推荐算法的原理是什么？

**题目：** 请解释广告推荐算法的基本原理。

**答案：** 广告推荐算法的基本原理是基于用户行为数据、广告内容特征和用户兴趣标签等信息，利用协同过滤、矩阵分解、深度学习等技术进行预测和推荐。

**解析：** 协同过滤通过寻找相似用户或商品进行推荐；矩阵分解将用户和商品矩阵分解为低维矩阵，用于预测用户对商品的评分；深度学习则通过神经网络模型学习用户行为数据，实现精细化推荐。

### 6. 如何评估广告投放效果？

**题目：** 描述一种评估广告投放效果的方法。

**答案：** 评估广告投放效果的方法包括：

1. **点击率（CTR）：** 衡量广告被点击的频率。
2. **转化率（CVR）：** 衡量点击后实际转化的比率。
3. **回报率（ROI）：** 计算广告投放带来的收益与投入成本之比。
4. **广告效果评分：** 通过用户反馈、市场调研等方式对广告效果进行评分。

### 7. 广告系统如何保证数据安全？

**题目：** 请简述广告系统在数据安全方面需要考虑的几个方面。

**答案：** 广告系统在数据安全方面需要考虑以下几个方面：

1. **数据加密：** 对敏感数据进行加密处理，防止数据泄露。
2. **访问控制：** 限制对数据的访问权限，确保只有授权用户可以访问。
3. **日志审计：** 记录系统操作日志，以便在发生问题时进行追踪和审计。
4. **安全审计：** 定期进行安全审计，发现并修复潜在的安全漏洞。

### 8. 广告展示的实时性如何保证？

**题目：** 请描述一种保证广告展示实时性的技术方案。

**答案：** 保证广告展示实时性的技术方案包括：

1. **分布式缓存：** 利用分布式缓存系统存储热门广告数据，提高数据读取速度。
2. **异步处理：** 对于广告展示请求，采用异步处理方式，减少等待时间。
3. **负载均衡：** 使用负载均衡器将请求分发到多个服务器节点，提高系统响应速度。
4. **CDN加速：** 利用内容分发网络（CDN）加速广告内容的加载。

### 9. 广告创意的优化策略有哪些？

**题目：** 请列举几种广告创意的优化策略。

**答案：** 广告创意的优化策略包括：

1. **A/B测试：** 对不同广告创意进行测试，根据用户反馈选择最优创意。
2. **用户反馈：** 分析用户对广告的反馈，调整广告内容和呈现方式。
3. **数据分析：** 利用数据分析工具分析广告效果，找到优化方向。
4. **市场调研：** 通过市场调研了解用户需求，为广告创意提供灵感。

### 10. 如何实现广告精准投放？

**题目：** 请简述如何实现广告精准投放。

**答案：** 实现广告精准投放的方法包括：

1. **用户画像：** 建立用户画像，包括用户的兴趣、行为等特征。
2. **行为预测：** 利用机器学习算法预测用户的兴趣和行为。
3. **多维度匹配：** 将广告内容与用户画像进行多维度匹配，实现精准投放。
4. **实时调整：** 根据广告效果实时调整投放策略，提高广告投放效果。

### 11. 广告系统如何处理大规模数据？

**题目：** 请描述一种处理大规模广告数据的技术方案。

**答案：** 处理大规模广告数据的技术方案包括：

1. **分布式存储：** 使用分布式存储系统存储海量数据，提高数据读取速度。
2. **大数据处理框架：** 利用大数据处理框架（如Hadoop、Spark）进行数据处理和分析。
3. **实时计算：** 利用实时计算框架（如Flink、Storm）处理实时数据流。
4. **数据索引：** 构建数据索引，提高数据查询效率。

### 12. 广告投放的定向策略有哪些？

**题目：** 请列举几种广告投放的定向策略。

**答案：** 广告投放的定向策略包括：

1. **地域定向：** 根据用户的地理位置投放广告。
2. **兴趣定向：** 根据用户的兴趣爱好投放广告。
3. **行为定向：** 根据用户的行为特征投放广告。
4. **社交定向：** 根据用户的社交网络特征投放广告。

### 13. 广告系统的架构设计原则是什么？

**题目：** 请简述广告系统架构设计时应遵循的原则。

**答案：** 广告系统架构设计应遵循以下原则：

1. **高可用性：** 确保系统在故障情况下能够快速恢复。
2. **高可扩展性：** 系统应能够灵活扩展，以应对流量增长。
3. **高并发处理能力：** 系统应具备处理高并发请求的能力。
4. **高安全性：** 确保广告数据的安全性和完整性。
5. **易维护性：** 系统设计应便于维护和升级。

### 14. 广告系统如何处理广告投放时延？

**题目：** 请描述一种减少广告投放时延的技术方案。

**答案：** 减少广告投放时延的技术方案包括：

1. **本地缓存：** 在用户设备上缓存部分广告数据，减少加载时间。
2. **边缘计算：** 在网络边缘节点处理广告数据，减少数据传输距离。
3. **异步加载：** 使用异步加载技术，将广告加载过程与页面渲染分离。
4. **CDN加速：** 利用内容分发网络（CDN）加速广告内容加载。

### 15. 广告系统的日志记录与监控如何设计？

**题目：** 请简述广告系统日志记录与监控的设计要点。

**答案：** 广告系统日志记录与监控的设计要点包括：

1. **日志格式标准化：** 确保日志格式统一，便于分析和管理。
2. **日志分级：** 根据日志重要程度设置不同的日志级别，便于问题定位。
3. **实时监控：** 使用实时监控工具，实时捕捉系统运行状态。
4. **告警机制：** 建立告警机制，及时发现和处理系统异常。

### 16. 如何防止广告投放中的广告欺诈行为？

**题目：** 请简述如何防止广告投放中的广告欺诈行为。

**答案：** 防止广告投放中的广告欺诈行为的方法包括：

1. **验证用户行为：** 通过验证用户行为（如点击频率、IP地址等）来识别可能的欺诈行为。
2. **黑名单策略：** 将已知欺诈IP地址、设备号等加入黑名单。
3. **机器学习检测：** 使用机器学习算法识别可能的欺诈行为。
4. **数据监控：** 定期监控广告投放数据，发现异常情况。

### 17. 广告系统如何支持多种广告形式？

**题目：** 请描述广告系统如何支持多种广告形式。

**答案：** 广告系统支持多种广告形式的方法包括：

1. **模块化设计：** 采用模块化设计，将不同类型的广告形式封装成独立的模块。
2. **动态加载：** 根据用户需求和广告形式动态加载广告内容。
3. **模板引擎：** 使用模板引擎生成不同类型的广告页面。
4. **接口化设计：** 提供接口化设计，方便接入多种广告形式。

### 18. 广告系统的性能优化策略有哪些？

**题目：** 请列举几种广告系统的性能优化策略。

**答案：** 广告系统的性能优化策略包括：

1. **缓存策略：** 利用缓存减少数据库访问次数。
2. **数据库优化：** 使用读写分离、分库分表等数据库优化技术。
3. **异步处理：** 使用异步处理减少系统负载。
4. **负载均衡：** 使用负载均衡器将请求均衡分配到多个服务器。

### 19. 广告系统的前端优化有哪些方法？

**题目：** 请描述广告系统前端优化的方法。

**答案：** 广告系统前端优化的方法包括：

1. **压缩文件：** 对静态文件（如CSS、JavaScript、图片）进行压缩，减少文件体积。
2. **懒加载：** 对不立即需要加载的内容（如图片、视频）采用懒加载技术。
3. **CDN加速：** 使用内容分发网络（CDN）加速广告内容加载。
4. **HTTP/2：** 使用HTTP/2协议提高页面加载速度。

### 20. 广告系统如何实现个性化推荐？

**题目：** 请描述广告系统实现个性化推荐的方法。

**答案：** 广告系统实现个性化推荐的方法包括：

1. **用户画像：** 建立用户画像，包括用户的兴趣、行为等特征。
2. **协同过滤：** 利用协同过滤算法为用户推荐相似用户喜欢的广告。
3. **内容推荐：** 利用内容推荐算法为用户推荐与用户兴趣相关的广告。
4. **深度学习：** 使用深度学习算法学习用户行为数据，实现精细化推荐。

### 21. 广告系统如何处理高并发请求？

**题目：** 请描述广告系统处理高并发请求的方法。

**答案：** 广告系统处理高并发请求的方法包括：

1. **负载均衡：** 使用负载均衡器将请求均衡分配到多个服务器。
2. **缓存策略：** 利用缓存减少数据库访问次数。
3. **异步处理：** 使用异步处理减少系统负载。
4. **分布式架构：** 采用分布式架构，提高系统并发处理能力。

### 22. 广告系统的实时数据处理技术有哪些？

**题目：** 请列举几种广告系统的实时数据处理技术。

**答案：** 广告系统的实时数据处理技术包括：

1. **流处理框架：** 使用流处理框架（如Apache Kafka、Apache Flink）处理实时数据流。
2. **消息队列：** 使用消息队列（如RabbitMQ、Kafka）实现实时数据传输。
3. **内存数据库：** 使用内存数据库（如Redis、Memcached）存储实时数据。
4. **分布式计算：** 使用分布式计算框架（如Apache Hadoop、Apache Spark）处理大规模实时数据。

### 23. 广告系统的数据安全措施有哪些？

**题目：** 请描述广告系统在数据安全方面需要采取的措施。

**答案：** 广告系统在数据安全方面需要采取的措施包括：

1. **数据加密：** 对敏感数据进行加密处理，防止数据泄露。
2. **访问控制：** 限制对数据的访问权限，确保只有授权用户可以访问。
3. **审计日志：** 记录系统操作日志，以便在发生问题时进行追踪和审计。
4. **数据备份：** 定期备份重要数据，防止数据丢失。

### 24. 广告系统的性能测试有哪些方法？

**题目：** 请描述广告系统性能测试的方法。

**答案：** 广告系统性能测试的方法包括：

1. **负载测试：** 模拟高并发用户访问，测试系统的负载承受能力。
2. **压力测试：** 模拟极限情况下的系统压力，测试系统的稳定性和可靠性。
3. **性能监控：** 在系统运行过程中持续监控性能指标，及时发现和解决问题。
4. **容量规划：** 根据性能测试结果，合理规划系统资源，确保系统在高并发情况下稳定运行。

### 25. 广告系统如何支持多语言、多地区广告投放？

**题目：** 请描述广告系统支持多语言、多地区广告投放的方法。

**答案：** 广告系统支持多语言、多地区广告投放的方法包括：

1. **多语言支持：** 在前端页面中使用多语言框架，根据用户语言设置自动切换广告语言。
2. **多地区数据隔离：** 根据用户地理位置将广告数据隔离，确保不同地区的广告内容准确无误。
3. **个性化定制：** 根据不同地区的用户需求和偏好，定制化广告内容和投放策略。
4. **多语言日志记录：** 记录多语言广告系统的运行日志，便于问题定位和解决。

### 26. 广告系统如何处理数据异常？

**题目：** 请描述广告系统处理数据异常的方法。

**答案：** 广告系统处理数据异常的方法包括：

1. **数据校验：** 在数据传输和存储过程中进行数据校验，确保数据完整性和准确性。
2. **异常监控：** 使用监控工具实时监控数据异常情况，及时报警和处理。
3. **数据恢复：** 在发生数据异常时，使用备份和数据恢复技术恢复数据。
4. **故障切换：** 在系统故障时，自动切换到备用系统，确保广告投放不受影响。

### 27. 广告系统的弹性伸缩策略有哪些？

**题目：** 请描述广告系统的弹性伸缩策略。

**答案：** 广告系统的弹性伸缩策略包括：

1. **动态伸缩：** 根据系统负载和业务需求，自动调整系统资源。
2. **服务拆分：** 将广告系统拆分为多个微服务，实现独立伸缩。
3. **容器化部署：** 使用容器技术（如Docker、Kubernetes）实现快速部署和伸缩。
4. **分布式架构：** 采用分布式架构，提高系统扩展性和容错能力。

### 28. 广告系统如何实现多渠道广告投放？

**题目：** 请描述广告系统实现多渠道广告投放的方法。

**答案：** 广告系统实现多渠道广告投放的方法包括：

1. **渠道接入：** 开发渠道接入接口，方便不同广告渠道接入广告系统。
2. **统一管理：** 在广告后台管理系统中实现多渠道广告的统一管理和调度。
3. **数据整合：** 整合不同渠道的广告数据，实现统一分析和优化。
4. **个性化推荐：** 根据用户行为和渠道特点，为用户推荐最适合的广告。

### 29. 广告系统如何处理广告素材管理？

**题目：** 请描述广告系统处理广告素材管理的方法。

**答案：** 广告系统处理广告素材管理的方法包括：

1. **素材上传：** 提供广告素材上传接口，方便广告主上传和管理广告素材。
2. **素材审核：** 对上传的广告素材进行审核，确保广告内容合法合规。
3. **素材存储：** 使用分布式存储系统存储广告素材，提高数据读取速度。
4. **素材优化：** 根据广告效果对素材进行优化，提高广告投放效果。

### 30. 广告系统如何实现广告精准定位？

**题目：** 请描述广告系统实现广告精准定位的方法。

**答案：** 广告系统实现广告精准定位的方法包括：

1. **用户画像：** 建立用户画像，包括用户的兴趣、行为等特征。
2. **行为预测：** 利用机器学习算法预测用户的兴趣和行为。
3. **多维度匹配：** 将广告内容与用户画像进行多维度匹配，实现精准定位。
4. **实时调整：** 根据广告效果实时调整定位策略，提高广告投放效果。

## 算法编程题与解析

### 1. 最长公共子序列

**题目：** 给定两个字符串 `str1` 和 `str2`，找出它们的最长公共子序列。

**输入：**
```
str1 = "ABCD"
str2 = "ACDF"
```

**输出：**
```
最长公共子序列为 "AC"
```

**解析：** 使用动态规划算法，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列长度。状态转移方程为：

\[ dp[i][j] = \begin{cases} 
      dp[i-1][j-1] + 1 & \text{如果 } str1[i-1] = str2[j-1] \\
      \max(dp[i-1][j], dp[i][j-1]) & \text{否则} 
   \end{cases} \]

**代码实例：**
```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    # 回溯求解最长公共子序列
    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if str1[i-1] == str2[j-1]:
            result.append(str1[i-1])
            i -= 1
            j -= 1
        elif dp[i-1][j] > dp[i][j-1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

print(longest_common_subsequence("ABCD", "ACDF"))  # 输出 "AC"
```

### 2. 单词搜索

**题目：** 给定一个二维字符网格和一个单词，判断该单词是否存在于网格中。

**输入：**
```
board = [
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
word = "ABCCED"
```

**输出：**
```
存在
```

**解析：** 使用深度优先搜索（DFS）算法，从网格中的每个位置开始搜索，找到单词的下一个字符。为了避免重复搜索，每次搜索后需要将当前字符替换为空字符，搜索结束后再恢复原字符。

**代码实例：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = any(dfs(i+1, j, k+1), dfs(i-1, j, k+1), dfs(i, j+1, k+1), dfs(i, j-1, k+1))
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False

board = [
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
word = "ABCCED"
print(exist(board, word))  # 输出 True
```

### 3. 合并两个有序链表

**题目：** 给定两个排序后的链表，合并两个链表为一个排序后的单链表。

**输入：**
```
l1 = [1, 3, 5]
l2 = [2, 4, 6]
```

**输出：**
```
[1, 2, 3, 4, 5, 6]
```

**解析：** 使用归并排序的思想，创建一个新的头节点，递归合并两个链表。

**代码实例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = merge_two_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_two_lists(l1, l2.next)
        return l2

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged = merge_two_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

### 4. 最小路径和

**题目：** 给定一个包含非负整数的网格，找出从左上角到右下角的最小路径和。

**输入：**
```
grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
```

**输出：**
```
7
```

**解析：** 使用动态规划算法，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示从左上角到 `(i, j)` 的最小路径和。状态转移方程为：

\[ dp[i][j] = grid[i][j] + \min(dp[i-1][j], dp[i][j-1]) \]

**代码实例：**
```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]

    for i in range(m):
        for j in range(n):
            if i == 0 and j == 0:
                dp[i][j] = grid[i][j]
            elif i == 0:
                dp[i][j] = grid[i][j] + dp[i][j-1]
            elif j == 0:
                dp[i][j] = grid[i][j] + dp[i-1][j]
            else:
                dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])

    return dp[-1][-1]

grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
print(minPathSum(grid))  # 输出 7
```

### 5. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**输入：**
```
strs = ["flower", "flow", "flight"]
```

**输出：**
```
"fl"
```

**解析：** 从第一个字符串开始，逐一比较后续字符串，找到最长公共前缀。

**代码实例：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]

    return prefix

strs = ["flower", "flow", "flight"]
print(longestCommonPrefix(strs))  # 输出 "fl"
```

### 6. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
[[1,6],[8,10],[15,18]]
```

**解析：** 将区间按照起点排序，然后逐一合并重叠的区间。

**代码实例：**
```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出 [[1,6],[8,10],[15,18]]
```

### 7. 找出第 k 小的元素

**题目：** 在未排序的数组中，找出第 k 小的元素。

**输入：**
```
nums = [3, 2, 1, 5, 6, 4] k = 2
```

**输出：**
```
第2小的元素是 2
```

**解析：** 使用快速选择算法，在平均情况下找到第 k 小的元素。

**代码实例：**
```python
def findKthLargest(nums, k):
    def partition(left, right):
        pivot = nums[right]
        i = left
        for j in range(left, right):
            if nums[j] < pivot:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        nums[i], nums[right] = nums[right], nums[i]
        return i

    left, right = 0, len(nums) - 1
    while left < right:
        pi = partition(left, right)
        if pi == k - 1:
            return nums[pi]
        elif pi < k - 1:
            left = pi + 1
        else:
            right = pi - 1

    return nums[left]

nums = [3, 2, 1, 5, 6, 4]
k = 2
print("第2小的元素是", findKthLargest(nums, k))  # 输出 "第2小的元素是 2"
```

### 8. 旋转图像

**题目：** 给定一个 `n x n` 的二维数组 `matrix` 表示一个图像，旋转图像 90 度。

**输入：**
```
matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
```

**输出：**
```
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**解析：** 先将矩阵按对角线翻转，然后再将矩阵的每一行进行翻转。

**代码实例：**
```python
def rotate(matrix):
    n = len(matrix)
    # 翻转矩阵的对角线
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    # 翻转矩阵的每一行
    for i in range(n):
        matrix[i].reverse()

matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
rotate(matrix)
for row in matrix:
    print(row)
```

### 9. 合并两个有序数组

**题目：** 给定两个有序数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**输入：**
```
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6], n = 3
```

**输出：**
```
nums1 = [1,2,2,3,5,6]
```

**解析：** 从后向前填充数组，比较两个数组的元素，将较大的元素放在 `nums1` 的末尾。

**代码实例：**
```python
def merge(nums1, m, nums2, n):
    i = m - 1
    j = n - 1
    k = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1

nums1 = [1,2,3,0,0,0]
nums2 = [2,5,6]
merge(nums1, 3, nums2, 3)
print(nums1)  # 输出 [1,2,2,3,5,6]
```

### 10. 搜索旋转排序数组

**题目：** 搜索一个整数数组的一个旋转排序数组，找出一个给定的目标值。

**输入：**
```
nums = [4,5,6,7,0,1,2]
target = 0
```

**输出：**
```
索引为 4 的位置
```

**解析：** 使用二分查找算法，根据数组的中点与目标值的关系，确定搜索区间。

**代码实例：**
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

nums = [4,5,6,7,0,1,2]
target = 0
print("索引为", search(nums, target), "的位置")  # 输出 "索引为 4 的位置"
```

### 11. 爬楼梯

**题目：** 假设你正在爬楼梯，每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？

**输入：**
```
n = 3
```

**输出：**
```
3
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示到达第 `i` 个台阶的方法数。

**代码实例：**
```python
def climbStairs(n):
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

n = 3
print(climbStairs(n))  # 输出 3
```

### 12. 整数转换英文表示

**题目：** 将非负整数转换为英文表示。

**输入：**
```
num = 123
```

**输出：**
```
"One Hundred Twenty Three"
```

**解析：** 分解整数，处理每一位数字的英文表示，然后拼接成完整的字符串。

**代码实例：**
```python
def intToEnglish(num):
    if num == 0:
        return "Zero"
    
    num_str = str(num)
    res = []
    for i in range(0, len(num_str), 3):
        group = num_str[i:i+3]
        if group == '000':
            continue
        res.append(digit_to_english(int(group)))
    
    return ' '.join(res)

def digit_to_english(digit):
    ones = ["", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    teens = ["Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"]
    tens = ["", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"]

    if digit < 10:
        return ones[digit]
    elif digit < 20:
        return teens[digit - 10]
    else:
        return tens[digit // 10] + (" " + ones[digit % 10] if digit % 10 else "")

num = 123
print(intToEnglish(num))  # 输出 "One Hundred Twenty Three"
```

### 13. 剪绳子

**题目：** 给你一个长度为 `n` 的绳子，请把绳子剪成若干段最大长度为 `k` 的段，请问可以剪出多少种不同的剪法？

**输入：**
```
n = 8, k = 3
```

**输出：**
```
6
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示剪出长度为 `i` 的绳子的方法数。

**代码实例：**
```python
def cuttingRope(n, k):
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        for j in range(1, k + 1):
            if i - j >= 0:
                dp[i] = max(dp[i], dp[i - j] * j)
    return dp[n]

n = 8
k = 3
print(cuttingRope(n, k))  # 输出 6
```

### 14. 分割等和子集

**题目：** 给定一个非空整数数组，判断是否存在两个子集，使得它们的和相等。

**输入：**
```
nums = [1, 5, 11, 5]
```

**输出：**
```
True
```

**解析：** 使用动态规划，定义状态 `dp[i][j]` 表示前 `i` 个元素能否组成和为 `j` 的子集。

**代码实例：**
```python
def canPartition(nums):
    total_sum = sum(nums)
    if total_sum % 2 != 0:
        return False
    target = total_sum // 2
    n = len(nums)
    dp = [[False] * (target + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = True
    for i in range(1, n + 1):
        for j in range(1, target + 1):
            if nums[i - 1] <= j:
                dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[n][target]

nums = [1, 5, 11, 5]
print(canPartition(nums))  # 输出 True
```

### 15. 粉刷房子

**题目：** 在一个无环的图中，每个节点都有颜色，你需要将图中的所有节点涂成三种颜色之一，求最小涂色次数。

**输入：**
```
n = 3
colors = [[1,1],[1,2],[2,2]]
```

**输出：**
```
3
```

**解析：** 使用动态规划，定义状态 `dp[i][j][k]` 表示前 `i` 个节点涂成 `j` 和 `k` 的最小涂色次数。

**代码实例：**
```python
def minCost(n, colors):
    color_map = {1: 0, 2: 1, 3: 2}
    INF = float('inf')
    dp = [[[INF] * 3 for _ in range(n)] for _ in range(n)]

    for i in range(n):
        for j in range(3):
            dp[i][i][j] = 0

    for i in range(1, n):
        for j in range(i):
            for k in range(3):
                if colors[i][0] == colors[j][0]:
                    dp[i][i][k] = min(dp[i][i][k], dp[j][i - 1][k])
                if colors[i][1] == colors[j][1]:
                    dp[i][i][k] = min(dp[i][i][k], dp[j][i - 1][k])
                for l in range(3):
                    if l != k:
                        dp[i][i][k] = min(dp[i][i][k], dp[j][i - 1][l] + 1)

    res = min(dp[n - 1][n - 1][0], dp[n - 1][n - 1][1], dp[n - 1][n - 1][2])
    return -1 if res == INF else res

n = 3
colors = [[1,1],[1,2],[2,2]]
print(minCost(n, colors))  # 输出 3
```

### 16. 判断是否存在有效三角序 列

**题目：** 给定一个无向图，判断是否存在一条路径，使得节点按照给定顺序排列。

**输入：**
```
edges = [[0,1],[1,2],[2,0],[1,3],[3,4]]
seq = [0,1,2,3,4]
```

**输出：**
```
True
```

**解析：** 使用拓扑排序，检查是否存在从第一个节点到最后一个节点的路径。

**代码实例：**
```python
from collections import defaultdict, deque

def validTree(n, edges, seq):
    graph = defaultdict(list)
    indeg = [0] * n
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)
        indeg[v] += 1
        indeg[u] += 1

    queue = deque()
    for i in range(n):
        if indeg[i] == 1:
            queue.append(i)

    visited = [False] * n
    while queue:
        node = queue.popleft()
        if visited[node]:
            return False
        visited[node] = True
        for neighbor in graph[node]:
            indeg[neighbor] -= 1
            if indeg[neighbor] == 1:
                queue.append(neighbor)

    return True

edges = [[0,1],[1,2],[2,0],[1,3],[3,4]]
seq = [0,1,2,3,4]
print(validTree(len(edges), edges, seq))  # 输出 True
```

### 17. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个有序链表。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**解析：** 使用归并排序的思想，比较两个链表的节点，将较小的节点添加到结果链表中。

**代码实例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

### 18. 判断是否存在环

**题目：** 给定一个链表，判断链表中是否存在环。

**输入：**
```
head = [3,2,0,-4]
pos = 1
```

**输出：**
```
存在
```

**解析：** 使用快慢指针法，如果存在环，快指针最终会追上慢指针。

**代码实例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
print("存在" if hasCycle(head) else "不存在")  # 输出 "存在"
```

### 19. 最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**输入：**
```
s1 = "abcde"
s2 = "acde"
```

**输出：**
```
最长公共子串为 "acde"
```

**解析：** 使用动态规划，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子串长度。

**代码实例：**
```python
def longestCommonSubstring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_pos = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i - 1
            else:
                dp[i][j] = 0

    return s1[end_pos - max_len + 1: end_pos + 1]

s1 = "abcde"
s2 = "acde"
print("最长公共子串为", longestCommonSubstring(s1, s2))  # 输出 "最长公共子串为 acde"
```

### 20. 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**输入：**
```
text1 = "abcdaf"
text2 = "abdef"
```

**输出：**
```
最长公共子序列为 "abdef"
```

**解析：** 使用动态规划，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。

**代码实例：**
```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            result.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

text1 = "abcdaf"
text2 = "abdef"
print("最长公共子序列为", longestCommonSubsequence(text1, text2))  # 输出 "最长公共子序列为 abdef"
```

### 21. 最小编辑距离

**题目：** 给定两个字符串，求它们的最小编辑距离。

**输入：**
```
word1 = "horse"
word2 = "ros"
```

**输出：**
```
最小编辑距离为 3
```

**解析：** 使用动态规划，构建一个二维数组 `dp`，其中 `dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符所需的最小编辑距离。

**代码实例：**
```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0:
                dp[i][j] = j
            elif j == 0:
                dp[i][j] = i
            elif word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

word1 = "horse"
word2 = "ros"
print("最小编辑距离为", minDistance(word1, word2))  # 输出 "最小编辑距离为 3"
```

### 22. 最长递增子序列

**题目：** 给定一个无序数组，找出最长递增子序列的长度。

**输入：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

**输出：**
```
最长递增子序列长度为 4
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

**代码实例：**
```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

nums = [10, 9, 2, 5, 3, 7, 101, 18]
print("最长递增子序列长度为", lengthOfLIS(nums))  # 输出 "最长递增子序列长度为 4"
```

### 23. 股票买卖

**题目：** 给定一个整数数组 `prices` 表示股票每天的价格，求最大利润。

**输入：**
```
prices = [7, 1, 5, 3, 6, 4]
```

**输出：**
```
最大利润为 5
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示到第 `i` 天的最大利润。

**代码实例：**
```python
def maxProfit(prices):
    if not prices:
        return 0
    dp = [0] * len(prices)
    for i in range(1, len(prices)):
        dp[i] = max(dp[i - 1], prices[i] - prices[i - 1])
    return max(dp)

prices = [7, 1, 5, 3, 6, 4]
print("最大利润为", maxProfit(prices))  # 输出 "最大利润为 5"
```

### 24. 爬楼梯

**题目：** 假设你正在爬楼梯，每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？

**输入：**
```
n = 3
```

**输出：**
```
3
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示到达第 `i` 个台阶的方法数。

**代码实例：**
```python
def climbStairs(n):
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]

n = 3
print(climbStairs(n))  # 输出 3
```

### 25. 二进制求和

**题目：** 给定两个二进制字符串，求它们的和。

**输入：**
```
a = "11"
b = "1"
```

**输出：**
```
"100"
```

**解析：** 从低位开始计算，使用字符串遍历和位运算。

**代码实例：**
```python
def addBinary(a, b):
    max_len = max(len(a), len(b))
    a, b = a.zfill(max_len), b.zfill(max_len)
    carry = 0
    res = []

    for i in range(max_len - 1, -1, -1):
        sum = carry + int(a[i]) + int(b[i])
        res.append(str(sum % 2))
        carry = sum // 2

    if carry:
        res.append('1')

    return ''.join(res[::-1])

a = "11"
b = "1"
print(addBinary(a, b))  # 输出 "100"
```

### 26. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
[[1,6],[8,10],[15,18]]
```

**解析：** 将区间按照起点排序，然后逐一合并重叠的区间。

**代码实例：**
```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出 [[1,6],[8,10],[15,18]]
```

### 27. 寻找旋转排序数组中的最小值

**题目：** 给定一个旋转排序的数组，找出旋转数组的最小元素。

**输入：**
```
nums = [3,4,5,1,2]
```

**输出：**
```
最小值为 1
```

**解析：** 使用二分查找，找到最小值的位置。

**代码实例：**
```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

nums = [3,4,5,1,2]
print("最小值为", findMin(nums))  # 输出 "最小值为 1"
```

### 28. 螺旋矩阵

**题目：** 给定一个 `m x n` 的矩阵，按照螺旋顺序返回矩阵中的所有元素。

**输入：**
```
matrix = [
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
]
```

**输出：**
```
[1,2,3,6,9,8,7,4,5]
```

**解析：** 按照螺旋方向遍历矩阵。

**代码实例：**
```python
def spiralOrder(matrix):
    if not matrix:
        return []

    rows, cols = len(matrix), len(matrix[0])
    top, bottom, left, right = 0, rows - 1, 0, cols - 1
    res = []

    while top <= bottom and left <= right:
        # 从左到右
        for j in range(left, right + 1):
            res.append(matrix[top][j])
        top += 1

        # 从上到下
        for i in range(top, bottom + 1):
            res.append(matrix[i][right])
        right -= 1

        if top <= bottom:
            # 从右到左
            for j in range(right, left - 1, -1):
                res.append(matrix[bottom][j])
            bottom -= 1

        if left <= right:
            # 从下到上
            for i in range(bottom, top - 1, -1):
                res.append(matrix[i][left])
            left += 1

    return res

matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
print(spiralOrder(matrix))  # 输出 [1,2,3,6,9,8,7,4,5]
```

### 29. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个有序链表。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**解析：** 使用递归或迭代比较两个链表的节点，将较小的节点添加到结果链表中。

**代码实例（递归）：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**代码实例（迭代）：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    tail.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

### 30. 有效括号

**题目：** 给定一个字符串 `s` ，判断 `s` 是否是有效的括号字符串。

**输入：**
```
s = "()()"
```

**输出：**
```
True
```

**解析：** 使用栈，将左括号入栈，遇到右括号时，检查栈顶元素是否匹配。

**代码实例：**
```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            stack.append(char)
    return not stack

s = "()()"
print(isValid(s))  # 输出 True
```

### 31. 等概率抽取

**题目：** 给定一个长度为 `n` 的数组 `nums`，请实现一个函数，返回抽取任意两个不同下标的元素的和的等概率随机结果。

**输入：**
```
nums = [1, 2, 3, 4, 5]
```

**输出：**
```
[7, 9, 11, 13, 15]
```

**解析：** 使用随机抽样算法，生成两个不同的下标，计算和值。

**代码实例：**
```python
import random

def sampleSum(nums):
    n = len(nums)
    results = []
    for _ in range(n - 1):
        i, j = random.randint(0, n - 1), random.randint(0, n - 1)
        while i == j:
            i, j = random.randint(0, n - 1), random.randint(0, n - 1)
        results.append(nums[i] + nums[j])
    return results

nums = [1, 2, 3, 4, 5]
print(sampleSum(nums))  # 输出可能是 [7, 9, 11, 13, 15] 等等
```

### 32. 字符串匹配

**题目：** 给定一个字符串 `s` 和一个字符串 `p`，请实现一个函数，返回 `s` 中包含 `p` 的所有起始位置的列表。

**输入：**
```
s = "abracadabra"
p = "abra"
```

**输出：**
```
[0, 7]
```

**解析：** 使用滑动窗口和哈希表，记录窗口内的字符数量。

**代码实例：**
```python
def findAnagrams(s, p):
    p_len, s_len = len(p), len(s)
    p_count, s_count = Counter(p), Counter()

    result = []
    for i in range(s_len - p_len + 1):
        if i > 0:
            s_count[s[i - 1]] -= 1
        s_count[s[i + p_len - 1]] += 1
        if p_count == s_count:
            result.append(i)

    return result

s = "abracadabra"
p = "abra"
print(findAnagrams(s, p))  # 输出 [0, 7]
```

### 33. 单调栈

**题目：** 给定一个数组 `arr`，请实现一个函数，返回每个元素对应的下一个更大元素。如果不存在更大元素，则为 `-1`。

**输入：**
```
arr = [4, 5, 2, 25]
```

**输出：**
```
[-1, 25, -1, 25]
```

**解析：** 使用单调栈，从右向左遍历数组，记录每个元素对应的下一个更大元素。

**代码实例：**
```python
def nextGreaterElements(arr):
    n = len(arr)
    stack = []
    result = [-1] * n

    for i in range(n * 2 - 1, -1, -1):
        while stack and arr[stack[-1]] <= arr[i % n]:
            stack.pop()
        if stack:
            result[i % n] = arr[stack[-1]]
        stack.append(i % n)

    return result

arr = [4, 5, 2, 25]
print(nextGreaterElements(arr))  # 输出 [-1, 25, -1, 25]
```

### 34. 合并有序链表

**题目：** 给定两个有序链表，将它们合并为一个有序链表。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**解析：** 使用递归或迭代比较两个链表的节点，将较小的节点添加到结果链表中。

**代码实例（递归）：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

**代码实例（迭代）：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    tail = dummy

    while l1 and l2:
        if l1.val < l2.val:
            tail.next = l1
            l1 = l1.next
        else:
            tail.next = l2
            l2 = l2.next
        tail = tail.next

    tail.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = mergeTwoLists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
```

### 35. 油漆工问题

**题目：** 给定一个矩形房间的大小为 `width` 和 `height`，以及油漆工的速度 `widthSpeed` 和 `heightSpeed`，计算油漆工涂完整个房间所需的时间。

**输入：**
```
width = 15
height = 10
widthSpeed = 1
heightSpeed = 2
```

**输出：**
```
涂完房间所需时间为 25 分钟
```

**解析：** 计算涂完房间所需的时间，即房间面积除以油漆工的速度。

**代码实例：**
```python
def timeToPaint(width, height, widthSpeed, heightSpeed):
    area = width * height
    time = area / (widthSpeed + heightSpeed)
    return time

width = 15
height = 10
widthSpeed = 1
heightSpeed = 2
print(f"涂完房间所需时间为 {timeToPaint(width, height, widthSpeed, heightSpeed)} 分钟")  # 输出 "涂完房间所需时间为 25.0 分钟"
```

### 36. 判断是否为平衡二叉树

**题目：** 给定一棵二叉树，请实现一个函数，判断它是否是平衡二叉树。

**输入：**
```
root = [3,9,20,null,null,15,7]
```

**输出：**
```
是平衡二叉树
```

**解析：** 使用递归，计算每个节点的左子树和右子树的高度，判断是否平衡。

**代码实例：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isBalanced(root):
    def check(node):
        if not node:
            return 0
        left_height = check(node.left)
        right_height = check(node.right)
        if abs(left_height - right_height) > 1:
            return -1
        return max(left_height, right_height) + 1

    return check(root) != -1

root = TreeNode(3, TreeNode(9, None, TreeNode(20, TreeNode(15), TreeNode(7))))
print("是平衡二叉树" if isBalanced(root) else "不是平衡二叉树")  # 输出 "是平衡二叉树"
```

### 37. 检查括号匹配

**题目：** 给定一个字符串 `s`，请实现一个函数，判断字符串中的括号是否匹配。

**输入：**
```
s = "()()"
```

**输出：**
```
匹配
```

**解析：** 使用栈，将左括号入栈，遇到右括号时，检查栈顶元素是否匹配。

**代码实例：**
```python
def isMatch(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return "不匹配"
        else:
            stack.append(char)
    return "匹配" if not stack else "不匹配"

s = "()()"
print(isMatch(s))  # 输出 "匹配"
```

### 38. 求最小公倍数

**题目：** 给定两个整数 `a` 和 `b`，求它们的最小公倍数。

**输入：**
```
a = 12
b = 18
```

**输出：**
```
最小公倍数为 36
```

**解析：** 使用最大公约数（GCD）和最小公倍数（LCM）的关系，LCM(a, b) = a * b / GCD(a, b)。

**代码实例：**
```python
import math

def lcm(a, b):
    return a * b // math.gcd(a, b)

a = 12
b = 18
print(f"最小公倍数为 {lcm(a, b)}")  # 输出 "最小公倍数为 36"
```

### 39. 二分查找

**题目：** 给定一个有序数组 `nums` 和一个目标值 `target`，请实现一个函数，查找目标值在数组中的索引。

**输入：**
```
nums = [1, 3, 5, 6]
target = 5
```

**输出：**
```
索引为 2
```

**解析：** 使用二分查找算法，在有序数组中查找目标值。

**代码实例：**
```python
def binarySearch(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

nums = [1, 3, 5, 6]
target = 5
print("索引为", binarySearch(nums, target))  # 输出 "索引为 2"
```

### 40. 链表相交

**题目：** 给定两个链表，请实现一个函数，找出两个链表的相交节点。

**输入：**
```
headA = [4,1,8,4,5]
headB = [5,6,1,8,4,5]
```

**输出：**
```
相交节点为 8
```

**解析：** 首先计算两个链表的长度差，然后让较长的链表先走长度差，接着同时遍历两个链表，找到相交节点。

**代码实例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getIntersectionNode(headA, headB):
    lenA, lenB = 0, 0
    tempA, tempB = headA, headB
    while tempA:
        lenA += 1
        tempA = tempA.next
    while tempB:
        lenB += 1
        tempB = tempB.next

    if lenA > lenB:
        for _ in range(lenA - lenB):
            headA = headA.next
    else:
        for _ in range(lenB - lenA):
            headB = headB.next

    while headA and headB:
        if headA == headB:
            return headA
        headA, headB = headA.next, headB.next

    return None

headA = ListNode(4, ListNode(1, ListNode(8, ListNode(4, ListNode(5)))))
headB = ListNode(5, ListNode(6, ListNode(1, ListNode(8, ListNode(4, ListNode(5))))))
node = getIntersectionNode(headA, headB)
if node:
    print("相交节点为", node.val)  # 输出 "相交节点为 8"
else:
    print("没有相交节点")
```

### 41. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
[[1,6],[8,10],[15,18]]
```

**解析：** 将区间按照起点排序，然后逐一合并重叠的区间。

**代码实例：**
```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        if result[-1][1] >= intervals[i][0]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])

    return result

intervals = [[1,3],[2,6],[8,10],[15,18]]
print(merge(intervals))  # 输出 [[1,6],[8,10],[15,18]]
```

### 42. 判断二叉树是否对称

**题目：** 给定一棵二叉树，请实现一个函数，判断它是否是镜像对称的。

**输入：**
```
root = [1,2,2,3,4,4,3]
```

**输出：**
```
是镜像对称的二叉树
```

**解析：** 使用递归，分别比较左右子树是否相同。

**代码实例：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isSymmetric(root):
    if not root:
        return True
    return isMirror(root.left, root.right)

def isMirror(left, right):
    if not left and not right:
        return True
    if not left or not right:
        return False
    if left.val != right.val:
        return False
    return isMirror(left.left, right.right) and isMirror(left.right, right.left)

root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3)))
print("是镜像对称的二叉树" if isSymmetric(root) else "不是镜像对称的二叉树")  # 输出 "是镜像对称的二叉树"
```

### 43. 翻转链表

**题目：** 给定一个链表，请实现一个函数，反转链表。

**输入：**
```
head = [1,2,3,4,5]
```

**输出：**
```
反转后的链表：[5,4,3,2,1]
```

**解析：** 使用递归或迭代，反转链表节点。

**代码实例（递归）：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    if not head or not head.next:
        return head
    p = reverseList(head.next)
    head.next.next = head
    head.next = None
    return p

head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
new_head = reverseList(head)
while new_head:
    print(new_head.val, end=" ")
    new_head = new_head.next
```

**代码实例（迭代）：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev

head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
new_head = reverseList(head)
while new_head:
    print(new_head.val, end=" ")
    new_head = new_head.next
```

### 44. 检查二分查找树是否有效

**题目：** 给定一棵二叉搜索树，请实现一个函数，判断它是否是一个有效的二叉搜索树。

**输入：**
```
root = [5,3,7,2,4,6,8]
```

**输出：**
```
是有效的二叉搜索树
```

**解析：** 中序遍历二叉搜索树，检查节点值是否递增。

**代码实例：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBST(root):
    def dfs(node):
        if not node:
            return True
        if (not dfs(node.left) or
                (node.val <= prev or
                 node.val >= next)):
            return False
        prev = node.val
        next = node.val
        return dfs(node.right)

    prev = float('-inf')
    next = float('inf')
    return dfs(root)

root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(7, TreeNode(6), TreeNode(8)))
print("是有效的二叉搜索树" if isValidBST(root) else "不是有效的二叉搜索树")  # 输出 "是有效的二叉搜索树"
```

### 45. 检查二叉树是否平衡

**题目：** 给定一棵二叉树，请实现一个函数，判断它是否是平衡二叉树。

**输入：**
```
root = [3,9,20,null,null,15,7]
```

**输出：**
```
是平衡二叉树
```

**解析：** 使用递归，计算每个节点的左右子树高度，判断是否平衡。

**代码实例：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isBalanced(root):
    def check(node):
        if not node:
            return 0
        left_height = check(node.left)
        right_height = check(node.right)
        if left_height < 0 or right_height < 0 or abs(left_height - right_height) > 1:
            return -1
        return max(left_height, right_height) + 1

    return check(root) != -1

root = TreeNode(3, TreeNode(9, None, TreeNode(20, TreeNode(15), TreeNode(7))))
print("是平衡二叉树" if isBalanced(root) else "不是平衡二叉树")  # 输出 "是平衡二叉树"
```

### 46. 求最小覆盖区间

**题目：** 给定一个数组 `nums`，请实现一个函数，找出一个最小覆盖区间，使得区间内的数字之和大于或等于一个给定数 `target`。

**输入：**
```
nums = [2, 7, 11, 15], target = 24
```

**输出：**
```
最小覆盖区间为 [2, 15]
```

**解析：** 使用双指针，找到最左边的起点和最右边的终点，使得区间的和大于或等于 `target`。

**代码实例：**
```python
def minInterval(nums, target):
    left, right = 0, 1
    sum = nums[left] + nums[right]
    while right < len(nums):
        if sum >= target:
            while left < right and sum - nums[left] >= target:
                left += 1
                sum -= nums[left]
            return [nums[left], nums[right]]
        right += 1
        sum += nums[right]

    return []

nums = [2, 7, 11, 15]
target = 24
print("最小覆盖区间为", minInterval(nums, target))  # 输出 "最小覆盖区间为 [2, 15]"
```

### 47. 求最长公共前缀

**题目：** 给定一个字符串数组 `strs`，请实现一个函数，找出一个最长公共前缀。

**输入：**
```
strs = ["flower", "flow", "flight"]
```

**输出：**
```
最长公共前缀为 "fl"
```

**解析：** 从前向后遍历字符串，找到所有字符串的公共前缀。

**代码实例：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    return prefix

strs = ["flower", "flow", "flight"]
print("最长公共前缀为", longestCommonPrefix(strs))  # 输出 "最长公共前缀为 fl"
```

### 48. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**输入：**
```
nums = [100, 4, 200, 1, 3, 2]
```

**输出：**
```
最长连续序列长度为 4
```

**解析：** 使用哈希表，记录每个数字的前一个数字，找出最长连续序列。

**代码实例：**
```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums_set = set(nums)
    max_len = 0
    for num in nums:
        if num - 1 not in nums_set:
            curr_len = 1
            while num + 1 in nums_set:
                num += 1
                curr_len += 1
            max_len = max(max_len, curr_len)
    return max_len

nums = [100, 4, 200, 1, 3, 2]
print("最长连续序列长度为", longestConsecutive(nums))  # 输出 "最长连续序列长度为 4"
```

### 49. 求和最大的连续子数组

**题目：** 给定一个整数数组，找出连续子数组的最大和。

**输入：**
```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```

**输出：**
```
最大连续子数组和为 6
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示以 `nums[i]` 结尾的连续子数组的最大和。

**代码实例：**
```python
def maxSubArray(nums):
    if not nums:
        return 0
    dp = [0] * len(nums)
    dp[0] = nums[0]
    max_sum = dp[0]
    for i in range(1, len(nums)):
        dp[i] = max(dp[i - 1] + nums[i], nums[i])
        max_sum = max(max_sum, dp[i])
    return max_sum

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print("最大连续子数组和为", maxSubArray(nums))  # 输出 "最大连续子数组和为 6"
```

### 50. 求和最小的连续子数组

**题目：** 给定一个整数数组，找出连续子数组的和最小值。

**输入：**
```
nums = [2, 3, 4, -5, 6, 7]
```

**输出：**
```
最小连续子数组和为 -5
```

**解析：** 使用动态规划，定义状态 `dp[i]` 表示以 `nums[i]` 结尾的连续子数组的和最小值。

**代码实例：**
```python
def minSubArraySum(nums):
    if not nums:
        return 0
    dp = [0] * len(nums)
    dp[0] = nums[0]
    min_sum = dp[0]
    for i in range(1, len(nums)):
        dp[i] = min(dp[i - 1] + nums[i], nums[i])
        min_sum = min(min_sum, dp[i])
    return min_sum

nums = [2, 3, 4, -5, 6, 7]
print("最小连续子数组和为", minSubArraySum(nums))  # 输出 "最小连续子数组和为 -5"
```

### 总结

本文详细解析了爱奇艺广告2025社招广告算法工程师面试指南中涉及的典型面试题和算法编程题。通过对每个问题的详细解析和代码实例，帮助读者更好地理解和掌握这些知识点。在面试过程中，除了掌握这些基本算法和题目，还需要注重逻辑思维、问题分析和解决问题的能力。希望本文能为准备参加爱奇艺广告算法工程师面试的候选人提供有价值的帮助。祝您面试成功！

