                 

### 滴滴2024校招iOS开发工程师算法题汇总

本文将汇总滴滴2024校招iOS开发工程师的部分面试题目，涵盖数据结构与算法、iOS开发相关等知识点。以下为具体题目及答案解析：

#### 1. 逆序对的数量

**题目描述：** 给定一个整数数组 `nums`，求出数组中的逆序对的数量。

**示例：**
```plaintext
输入：nums = [2, 4, 1, 3, 5]
输出：3
解释：(2, 1)，(4, 1)，(4, 3) 是数组中的逆序对。
```

**解题思路：** 使用归并排序求解。

**答案：**
```go
func reversePairs(nums []int) int {
    return mergeSort(nums)
}

func mergeSort(nums []int) int {
    if len(nums) < 2 {
        return 0
    }
    mid := len(nums) / 2
    left := mergeSort(nums[:mid])
    right := mergeSort(nums[mid:])
    return left + right + merge(nums[:mid], nums[mid:])
}

func merge(left, right []int) int {
    i, j, count := 0, 0, 0
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            i++
        } else {
            count += len(left) - i
            j++
        }
    }
    return count
}
```

#### 2. 单词搜索 II

**题目描述：** 给定一个二维网格和一个单词列表，找出网格中的所有单词。

**示例：**
```plaintext
输入：
board = [
  ['o', 'a', 'a', 'n'],
  ['e', 't', 'a', 'e'],
  ['i', 'h', 'k', 'r'],
  ['i', 'f', 'l', 'v']
]
words = ["oath", "pea", "eat", "rain"]

输出：["eat", "oath"]
```

**解题思路：** 使用深度优先搜索（DFS）和回溯算法。

**答案：**
```go
var res []string

func findWords(board [][]byte, words []string) []string {
    m, n := len(board), len(board[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            dfs(board, words, i, j, "")
        }
    }
    return res
}

func dfs(board [][]byte, words []string, i, j, word string) {
    if len(res) == len(words) {
        return
    }
    m, n := len(board), len(board[0])
    if i < 0 || i >= m || j < 0 || j >= n || board[i][j] == ' ' || visited[i][j] {
        return
    }
    visited[i][j] = true
    word += string(board[i][j])
    if strings.Contains(words, word) {
        res = append(res, word)
    }
    dfs(board, words, i+1, j, word)
    dfs(board, words, i-1, j, word)
    dfs(board, words, i, j+1, word)
    dfs(board, words, i, j-1, word)
    visited[i][j] = false
}
```

#### 3. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**
```plaintext
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。
```

**解题思路：** 使用哈希表。

**答案：**
```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, v := range nums {
        m[v] = i
    }
    for i, v := range nums {
        complement := target - v
        if j, ok := m[complement]; ok && j != i {
            return []int{i, j}
        }
    }
    return nil
}
```

#### 4. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```plaintext
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]
```

**解题思路：** 创建一个新的链表，遍历两个链表，将较小的节点添加到新链表中。

**答案：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 5. 删除链表的节点

**题目描述：** 给定单向链表的头指针和一个节点，定义一个函数来删除该节点。

**示例：**
```plaintext
输入：head = [4, 5, 1, 9], node = 5
输出：[4, 1, 9]
解释：给定你链表中值为 5 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9。
```

**解题思路：** 将前一个节点的值覆盖当前节点，然后删除当前节点。

**答案：**
```go
func deleteNode(node *ListNode) {
    if node == nil {
        return
    }
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

#### 6. 二叉树的直径

**题目描述：** 给定一棵二叉树，求该树的直径。

**示例：**
```plaintext
输入：root = [1, 2, 3, 4, 5]
输出：3
解释：树的直径为 3，节点 1 的左子树深度为 1，节点 2 的左子树深度为 2，节点 3 的右子树深度为 2。
```

**解题思路：** 使用递归求每个节点的最大深度，求出最大深度之和即为直径。

**答案：**
```go
var max int

func diameterOfBinaryTree(root *TreeNode) int {
    dfs(root)
    return max
}

func dfs(root *TreeNode) int {
    if root == nil {
        return 0
    }
    left := dfs(root.Left)
    right := dfs(root.Right)
    max = max(max, left+right)
    return max(1, max(left, right))
}
```

#### 7. 最小路径和

**题目描述：** 给定一个包含非负整数的矩阵，找出这个矩阵中的最小路径和。

**示例：**
```plaintext
输入：
matrix = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**解题思路：** 从左上角开始，遍历矩阵，每次更新当前节点的值为其上方和左方节点的最小值加上自身。

**答案：**
```go
func minPathSum(matrix [][]int) int {
    m, n := len(matrix), len(matrix[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i > 0 && j > 0 {
                matrix[i][j] += min(matrix[i-1][j], matrix[i][j-1])
            } else if i > 0 {
                matrix[i][j] += matrix[i-1][j]
            } else if j > 0 {
                matrix[i][j] += matrix[i][j-1]
            }
        }
    }
    return matrix[m-1][n-1]
}
```

#### 8. 反转链表

**题目描述：** 反转一个单链表。

**示例：**
```plaintext
输入：1->2->3->4->5
输出：5->4->3->2->1
```

**解题思路：** 使用递归或循环迭代实现。

**答案（递归）：**
```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

**答案（循环迭代）：**
```go
func reverseList(head *ListNode) *ListNode {
    prev := nil
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

#### 9. 快乐数

**题目描述：** 编写一个函数，判断一个数字是否是“快乐数”。

**示例：**
```plaintext
输入：19
输出：true
解释：
12 + 92 = 100
10 + 02 = 12
1 + 22 = 5
4 + 52 = 25
2 + 25 = 12
```

**解题思路：** 使用快慢指针法。

**答案：**
```go
func isHappy(n int) bool {
    slow, fast := n, n
    for fast != 1 && slow != fast {
        slow = next(slow)
        fast = next(next(fast))
    }
    return fast == 1
}

func next(n int) int {
    sum := 0
    for n > 0 {
        sum += (n % 10) * (n % 10)
        n /= 10
    }
    return sum
}
```

#### 10. 单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断该单词是否存在于网格中。

**示例：**
```plaintext
输入：
board = [
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
word = "ABCCED"

输出：true
```

**解题思路：** 使用深度优先搜索（DFS）。

**答案：**
```go
func exist(board [][]byte, word string) bool {
    m, n := len(board), len(board[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if dfs(board, word, i, j, 0) {
                return true
            }
        }
    }
    return false
}

func dfs(board [][]byte, word string, i int, j int, k int) bool {
    m, n := len(board), len(board[0])
    if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k] {
        return false
    }
    if k == len(word)-1 {
        return true
    }
    temp := board[i][j]
    board[i][j] = '#'
    res := dfs(board, word, i+1, j, k+1) ||
        dfs(board, word, i-1, j, k+1) ||
        dfs(board, word, i, j+1, k+1) ||
        dfs(board, word, i, j-1, k+1)
    board[i][j] = temp
    return res
}
```

#### 11. 寻找旋转排序数组中的最小值

**题目描述：** 已知一个升序排列的数组被分割成两个部分，求出两部分中的最小值。

**示例：**
```plaintext
输入：nums = [4, 5, 6, 7, 0, 1, 2]
输出：0
```

**解题思路：** 使用二分查找。

**答案：**
```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 12. 合并两个有序链表

**题目描述：** 给定两个有序链表，将它们合并为一个新的有序链表并返回。

**示例：**
```plaintext
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]
```

**解题思路：** 递归或循环迭代实现。

**答案（递归）：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**答案（循环迭代）：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}
```

#### 13. 合并K个升序链表

**题目描述：** 给定K个相互链接的升序链表，将它们合并成一个升序的链表。

**示例：**
```plaintext
输入：
lists = [
  [1, 4, 5],
  [1, 3, 4],
  [2, 6]
]
输出：[1, 1, 2, 3, 4, 4, 5, 6]
```

**解题思路：** 使用优先队列（最小堆）。

**答案：**
```go
type ListNode struct {
    Val  int
    Next *ListNode
}

type Node struct {
    Val  *ListNode
    Index int
}

func mergeKLists(lists []*ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    q := &container.PriorityQueue{}
    for i, list := range lists {
        if list != nil {
            q.Push(&Node{Val: list, Index: i}, list.Val)
        }
    }
    for !q.Empty() {
        node := q.Pop().(*Node)
        curr.Next = node.Val
        curr = curr.Next
        if node.Val.Next != nil {
            q.Push(&Node{Val: node.Val.Next, Index: node.Index}, node.Val.Next.Val)
        }
    }
    return dummy.Next
}
```

#### 14. 最长公共子序列

**题目描述：** 给定两个字符串text1和text2，找到它们的 longest common subsequence。

**示例：**
```plaintext
输入：text1 = "abcde", text2 = "ace"
输出："ace"
```

**解题思路：** 使用动态规划。

**答案：**
```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var result []byte
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            result = append(result, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(result)
    return string(result)
}

func reverse(s []byte) {
    n := len(s)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 15. 最长回文子串

**题目描述：** 给定一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例：**
```plaintext
输入：s = "babad"
输出："bab" 或 "aba"
```

**解题思路：** 动态规划。

**答案：**
```go
func longestPalindrome(s string) string {
    n := len(s)
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
    }
    maxLen, start := 1, 0
    for i := 0; i < n; i++ {
        dp[i][i] = true
    }
    for i := 0; i < n-1; i++ {
        if s[i] == s[i+1] {
            dp[i][i+1] = true
            maxLen = 2
            start = i
        }
    }
    for l := 3; l <= n; l++ {
        for i := 0; i < n-l+1; i++ {
            j := i + l - 1
            if s[i] == s[j] && dp[i+1][j-1] {
                dp[i][j] = true
                start = i
                maxLen = l
            }
        }
    }
    return s[start : start+maxLen]
}
```

#### 16. 二进制中1的个数

**题目描述：** 编写一个函数，计算一个无符号整数二进制表示中 1 的个数。

**示例：**
```plaintext
输入：n = 00000000000000000000000000001011
输出：3
解释：二进制位 11011，有三位为 1 。
```

**解题思路：** 位操作。

**答案：**
```go
func hammingWeight(num uint32) int {
    count := 0
    for num > 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

#### 17. 找到两个节点的最近公共祖先

**题目描述：** 给定一个二叉树，找到两个节点的最近公共祖先。

**示例：**
```plaintext
输入：
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**解题思路：** 使用递归。

**答案：**
```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left == nil {
        return right
    }
    if right == nil {
        return left
    }
    return root
}
```

#### 18. 重建二叉树

**题目描述：** 根据前序遍历和中序遍历的结果重建二叉树。

**示例：**
```plaintext
输入：
前序遍历：[3,9,20,15,7]
中序遍历：[9,3,15,20,7]

输出：
    3
   / \
  9  20
    /  \
   15   7
```

**解题思路：** 使用递归。

**答案：**
```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }
    rootVal := preorder[0]
    root := &TreeNode{Val: rootVal}
    rootIndex := 0
    for i, v := range inorder {
        if v == rootVal {
            rootIndex = i
            break
        }
    }
    root.Left = buildTree(preorder[1:1+rootIndex], inorder[:rootIndex])
    root.Right = buildTree(preorder[1+rootIndex:], inorder[rootIndex+1:])
    return root
}
```

#### 19. 找到两个节点的最近公共祖先

**题目描述：** 给定一个二叉树，找到两个节点的最近公共祖先。

**示例：**
```plaintext
输入：
        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**解题思路：** 使用递归。

**答案：**
```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left == nil {
        return right
    }
    if right == nil {
        return left
    }
    return root
}
```

#### 20. 判断二叉树是否是平衡树

**题目描述：** 判断一个二叉树是否是平衡二叉树。

**示例：**
```plaintext
输入：
     3
    / \
   9  20
     /  \
    15   7

输出：true
解释：因为左右两个子树的高度差异不超过 1 ，所以这是一个平衡二叉树。
```

**解题思路：** 使用递归。

**答案：**
```go
func isBalanced(root *TreeNode) bool {
    return maxDepth(root) != -1
}

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    left := maxDepth(root.Left)
    right := maxDepth(root.Right)
    if left == -1 || right == -1 || abs(left-right) > 1 {
        return -1
    }
    return 1 + max(left, right)
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

#### 21. 合并两个有序链表

**题目描述：** 给定两个有序链表，将它们合并为一个新的有序链表。

**示例：**
```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**解题思路：** 递归或循环迭代。

**答案（递归）：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**答案（循环迭代）：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}
```

#### 22. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```plaintext
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**解题思路：** 分治算法。

**答案：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    return lcp(strs, 0, len(strs)-1)
}

func lcp(strs []string, left int, right int) string {
    if left == right {
        return strs[left]
    }
    mid := (left + right) / 2
    leftPrefix := lcp(strs, left, mid)
    rightPrefix := lcp(strs, mid+1, right)
    return commonPrefix(leftPrefix, rightPrefix)
}

func commonPrefix(s1 string, s2 string) string {
    i := 0
    for i < len(s1) && i < len(s2) {
        if s1[i] != s2[i] {
            break
        }
        i++
    }
    return s1[:i]
}
```

#### 23. 合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]。
```

**解题思路：** 排序 + 双指针。

**答案：**
```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var result [][]int
    result = append(result, intervals[0])
    for i := 1; i < len(intervals); i++ {
        prev := result[len(result)-1]
        curr := intervals[i]
        if prev[1] >= curr[0] {
            prev[1] = max(prev[1], curr[1])
        } else {
            result = append(result, curr)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 24. 剪绳子

**题目描述：** 给定一个正整数 `n`，把整数剪成最多数目的 `3` 和 `2` 的乘积，求最大的乘积。

**示例：**
```plaintext
输入：n = 2
输出：2
解释：2 = 2

输入：n = 10
输出：36
解释：10 = 3 * 3 * 4 = 36
```

**解题思路：** 动态规划。

**答案：**
```go
func cuttingRo pe(n int) int {
    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 2
    for i := 3; i <= n; i++ {
        dp[i] = max3(dp[i-1], dp[i-2], dp[i/3]*dp[i/2])
    }
    return dp[n]
}

func max3(a, b, c int) int {
    return max(max(a, b), c)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 25. 寻找旋转排序数组中的最小值

**题目描述：** 已知一个升序排列的数组被分割成两个部分，求出两部分中的最小值。

**示例：**
```plaintext
输入：nums = [4, 5, 6, 7, 0, 1, 2]
输出：0
```

**解题思路：** 二分查找。

**答案：**
```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 26. 搜索二维矩阵

**题目描述：** 给定一个二维矩阵，编写一个高效的算法来搜索一个给定的目标值。矩阵的每行和每列都是递增的。

**示例：**
```plaintext
输入：matrix = [[1,3,5,7], [10,11,16,20], [23,30,34,50]], target = 3
输出：true

输入：matrix = [[1,3,5,7], [10,11,16,20], [23,30,34,50]], target = 13
输出：false
```

**解题思路：** 二分查找。

**答案：**
```go
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    left, right := 0, m-1
    for left < right {
        mid := (left + right) / 2
        if matrix[mid][0] > target {
            right = mid - 1
        } else if matrix[mid][n-1] < target {
            left = mid + 1
        } else {
            return true
        }
    }
    mid := left
    i := 0
    for i < n {
        if matrix[mid][i] == target {
            return true
        }
        i++
    }
    return false
}
```

#### 27. 寻找峰值元素

**题目描述：** 在一个整数数组的中，除了一个元素只出现一次之外，其他元素都出现两次。找出这个只出现一次的元素。

**示例：**
```plaintext
输入：nums = [1, 1, 2, 4, 4, 5]
输出：5

输入：nums = [1, 1, 2, 3, 3]
输出：2
```

**解题思路：** 二分查找。

**答案：**
```go
func singleNumber(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == nums[mid+1] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

#### 28. 最小栈

**题目描述：** 设计一个支持 `push`、`pop`、`top` 操作，并能在常数时间内检索到最小元素的栈。

**示例：**
```plaintext
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[(-2)],[ 0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**解题思路：** 使用两个栈。

**答案：**
```go
type MinStack struct {
    stack []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack: make([]int, 0),
        minStack: make([]int, 0),
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if len(this.minStack) == 0 || val <= this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    }
}

func (this *MinStack) Pop() {
    if this.stack[len(this.stack)-1] == this.minStack[len(this.minStack)-1] {
        this.minStack = this.minStack[:len(this.minStack)-1]
    }
    this.stack = this.stack[:len(this.stack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

#### 29. 汇总器

**题目描述：** 设计一个支持计数和求和的汇总器，实现 `add` 和 `sum` 方法。

**示例：**
```plaintext
输入：
["SummerWords","add","add","add","add","sum"]
[[],[1,3],[],[],[4,3],[]]

输出：
[null,null,null,null,null,9]
解释：
SummerWords summerWords = new SummerWords();
summerWords.add(1, 3);  // 频率为 [1, 3]，sum 为 0 + 1 + 3 + 3 = 7
summerWords.add(2, 2);  // 频率为 [1, 2, 3]，sum 为 0 + 1 + 2 + 3 + 2 = 9
summerWords.add(2, 5);  // 频率为 [1, 2, 3]，sum 为 0 + 1 + 2 + 3 + 5 = 12
summerWords.add(3, 3);  // 频率为 [1, 2, 3]，sum 为 0 + 1 + 2 + 3 + 3 = 12
summerWords.sum();  // 返回 12
```

**解题思路：** 使用哈希表。

**答案：**
```go
type SummerWords struct {
    freq map[int]int
}

func Constructor() SummerWords {
    return SummerWords{
        freq: make(map[int]int),
    }
}

func (this *SummerWords) Add(word1 int, word2 int) {
    if _, ok := this.freq[word1]; !ok {
        this.freq[word1] = 0
    }
    this.freq[word1] += word2
}

func (this *SummerWords) Sum() int {
    sum := 0
    for _, v := range this.freq {
        sum += v
    }
    return sum
}
```

#### 30. 合并数组

**题目描述：** 给定两个已排序的数组，将它们合并为一个新的排序数组。

**示例：**
```plaintext
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：nums1 = [1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6]。
```

**解题思路：** 双指针。

**答案：**
```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

