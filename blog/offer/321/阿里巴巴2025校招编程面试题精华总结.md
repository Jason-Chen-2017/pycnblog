                 

### 阿里巴巴2025校招编程面试题精华总结

#### 1. 二叉搜索树（BST）的遍历

**题目：** 请实现二叉搜索树的先序、中序、后序遍历。

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preOrderTraversal(root):
    if root is None:
        return
    print(root.val, end=' ')
    preOrderTraversal(root.left)
    preOrderTraversal(root.right)

def inOrderTraversal(root):
    if root is None:
        return
    inOrderTraversal(root.left)
    print(root.val, end=' ')
    inOrderTraversal(root.right)

def postOrderTraversal(root):
    if root is None:
        return
    postOrderTraversal(root.left)
    postOrderTraversal(root.right)
    print(root.val, end=' ')
```

**解析：** 二叉搜索树的遍历包括先序遍历（根-左-右）、中序遍历（左-根-右）和后序遍历（左-右-根）。递归实现遍历，打印节点值。

#### 2. 链表反转

**题目：** 请实现一个函数，反转单链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**解析：** 使用三个指针（prev、curr、next_temp）实现链表反转，遍历链表，不断改变指针指向，最后返回反转后的头结点。

#### 3. 快速排序

**题目：** 请实现快速排序算法。

**答案：**

```python
def quickSort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]
    return quickSort(left) + middle + quickSort(right)
```

**解析：** 快速排序是一种分治算法，选择一个基准元素，将数组分为小于基准元素、等于基准元素和大于基准元素的三个子数组，递归地对子数组进行排序。

#### 4. 红黑树

**题目：** 请简要介绍红黑树，并说明它的特点。

**答案：**

红黑树是一种自平衡的二叉搜索树，它的特点如下：

1. **每个节点要么是红色，要么是黑色。**
2. **根节点是黑色的。**
3. **每个叶子节点（NIL节点）是黑色的。**
4. **如果一个节点是红色的，则它的两个子节点都是黑色的。**
5. **从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。**

**解析：** 红黑树通过旋转和颜色变换保持树的平衡，确保树的高度不会超过 log(n)，从而保证搜索、插入和删除操作的时间复杂度为 O(log(n))。

#### 5. 堆排序

**题目：** 请实现堆排序算法。

**答案：**

```python
def heapify(nums, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and nums[i] < nums[left]:
        largest = left

    if right < n and nums[largest] < nums[right]:
        largest = right

    if largest != i:
        nums[i], nums[largest] = nums[largest], nums[i]
        heapify(nums, n, largest)

def heapSort(nums):
    n = len(nums)

    for i in range(n // 2 - 1, -1, -1):
        heapify(nums, n, i)

    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)

    return nums
```

**解析：** 堆排序通过构建最大堆（大根堆或小根堆），每次将堆顶元素与最后一个元素交换，然后重新调整堆，直到堆为空。

#### 6. 双指针算法

**题目：** 请简要介绍双指针算法，并给出一个应用示例。

**答案：**

双指针算法是一种在数组等数据结构中，通过同时移动两个指针来解决问题的算法。双指针算法通常用于解决寻找两个指针之间关系的问题，如寻找重复元素、寻找两个数的和等。

**应用示例：** 寻找两个数组的交集

```python
def findIntersection(nums1, nums2):
    nums1.sort()
    nums2.sort()
    i, j = 0, 0
    result = []

    while i < len(nums1) and j < len(nums2):
        if nums1[i] == nums2[j]:
            result.append(nums1[i])
            i += 1
            j += 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1

    return result
```

**解析：** 双指针算法通过同时移动两个指针，找到两个数组中的公共元素，并添加到结果列表中。

#### 7. 递归算法

**题目：** 请简要介绍递归算法，并给出一个应用示例。

**答案：**

递归算法是一种在函数中直接或间接调用自身的算法。递归算法通常用于解决具有递归关系的问题，如求阶乘、求斐波那契数列等。

**应用示例：** 求斐波那契数列

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

**解析：** 递归算法通过将大问题分解为小问题，递归地求解，最后将小问题的解组合成大问题的解。

#### 8. 字符串匹配算法

**题目：** 请简要介绍字符串匹配算法，并给出一个应用示例。

**答案：**

字符串匹配算法是一种用于查找字符串或子字符串的算法。常见的字符串匹配算法包括暴力匹配算法、KMP算法、Boyer-Moore算法等。

**应用示例：** 暴力匹配算法

```python
def暴力匹配(s, p):
    n, m = len(s), len(p)
    i, j = 0, 0
    while i < n and j < m:
        if s[i] == p[j]:
            i += 1
            j += 1
        else:
            i = i - j + 1
            j = 0
    return i - j if j == m else -1
```

**解析：** 暴力匹配算法通过逐个比较字符串中的字符，找到子字符串的位置。当匹配失败时，回溯并重新开始匹配。

#### 9. 链表反转

**题目：** 请实现一个函数，反转单链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**解析：** 使用三个指针（prev、curr、next_temp）实现链表反转，遍历链表，不断改变指针指向，最后返回反转后的头结点。

#### 10. 递归算法

**题目：** 请简要介绍递归算法，并给出一个应用示例。

**答案：**

递归算法是一种在函数中直接或间接调用自身的算法。递归算法通常用于解决具有递归关系的问题，如求阶乘、求斐波那契数列等。

**应用示例：** 求斐波那契数列

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

**解析：** 递归算法通过将大问题分解为小问题，递归地求解，最后将小问题的解组合成大问题的解。

#### 11. 回溯算法

**题目：** 请简要介绍回溯算法，并给出一个应用示例。

**答案：**

回溯算法是一种通过尝试所有可能的组合来解决问题的算法。回溯算法通常用于解决组合问题、排列问题等。

**应用示例：** 求所有可能的组合

```python
def combine(n, k):
    def backtrack(start, path):
        if len(path) == k:
            result.append(path[:])
            return
        for i in range(start, n + 1):
            path.append(i)
            backtrack(i + 1, path)
            path.pop()

    result = []
    backtrack(1, [])
    return result
```

**解析：** 回溯算法通过递归尝试所有可能的组合，找到满足条件的组合，并存储在结果列表中。

#### 12. 动态规划算法

**题目：** 请简要介绍动态规划算法，并给出一个应用示例。

**答案：**

动态规划算法是一种通过将问题分解为子问题，并利用子问题的解来求解原问题的算法。动态规划算法通常用于解决具有重叠子问题的最优子结构问题。

**应用示例：** 最长公共子序列

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

**解析：** 动态规划算法通过建立状态转移方程，计算出子问题的最优解，并利用子问题的解来求解原问题。

#### 13. 快排算法

**题目：** 请简要介绍快排算法，并给出一个应用示例。

**答案：**

快排算法（快速排序）是一种高效的排序算法，基于分治思想。快排算法通过一趟排序将数组划分为两个子数组，其中一个子数组的所有元素都比另一个子数组的所有元素小，然后递归地对这两个子数组进行排序。

**应用示例：**

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quicksort(left) + middle + quicksort(right)
```

**解析：** 快排算法通过选择一个基准元素，将数组划分为小于基准元素、等于基准元素和大于基准元素的三个子数组，然后递归地对子数组进行排序。

#### 14. 快速选择算法

**题目：** 请简要介绍快速选择算法，并给出一个应用示例。

**答案：**

快速选择算法是一种用于求解数组第 k 大元素的算法，基于快排算法的思想。快速选择算法通过一趟排序将数组划分为两个子数组，其中一个子数组的所有元素都比另一个子数组的所有元素大，然后递归地对这两个子数组进行选择。

**应用示例：**

```python
def quickSelect(nums, k):
    if len(nums) == 1:
        return nums[0]

    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]

    if k < len(left):
        return quickSelect(left, k)
    elif k < len(left) + len(middle):
        return nums[k]
    else:
        return quickSelect(right, k - len(left) - len(middle))
```

**解析：** 快速选择算法通过选择一个基准元素，将数组划分为小于基准元素和大于基准元素的子数组，然后递归地对子数组进行选择，直到找到第 k 大元素。

#### 15. 双指针算法

**题目：** 请简要介绍双指针算法，并给出一个应用示例。

**答案：**

双指针算法是一种在数组等数据结构中，通过同时移动两个指针来解决问题的算法。双指针算法通常用于解决寻找两个指针之间关系的问题，如寻找重复元素、寻找两个数的和等。

**应用示例：** 寻找两个数组的交集

```python
def findIntersection(nums1, nums2):
    nums1.sort()
    nums2.sort()
    i, j = 0, 0
    result = []

    while i < len(nums1) and j < len(nums2):
        if nums1[i] == nums2[j]:
            result.append(nums1[i])
            i += 1
            j += 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1

    return result
```

**解析：** 双指针算法通过同时移动两个指针，找到两个数组中的公共元素，并添加到结果列表中。

#### 16. 前缀树

**题目：** 请简要介绍前缀树，并给出一个应用示例。

**答案：**

前缀树（字典树）是一种树形结构，用于存储大量的字符串，并快速查找字符串或子字符串。前缀树通过将字符串的前缀作为节点的键，将具有相同前缀的字符串存储在相同的子节点中。

**应用示例：** 字符串搜索

```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end_of_word = False

    def insert(self, word):
        node = self
        for char in word:
            idx = ord(char) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end_of_word = True

    def search(self, word):
        node = self
        for char in word:
            idx = ord(char) - ord('a')
            if node.children[idx] is None:
                return False
            node = node.children[idx]
        return node.is_end_of_word

trie = Trie()
trie.insert("apple")
trie.insert("banana")
print(trie.search("apple"))  # 输出 True
print(trie.search("banana"))  # 输出 True
print(trie.search("app"))  # 输出 False
```

**解析：** 前缀树通过将字符串的前缀作为节点的键，快速查找字符串或子字符串。插入和搜索操作的时间复杂度为 O(m)，其中 m 为字符串的长度。

#### 17. 并查集

**题目：** 请简要介绍并查集，并给出一个应用示例。

**答案：**

并查集（Union-Find）是一种用于解决动态连通性问题（例如判断两个节点是否连通）的数据结构。并查集通过合并和查找两个节点所属的集合来维护节点的连通性。

**应用示例：** 判断两个节点是否连通

```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.size = [1] * n

    def find(self, p):
        if self.parent[p] != p:
            self.parent[p] = self.find(self.parent[p])
        return self.parent[p]

    def union(self, p, q):
        rootP = self.find(p)
        rootQ = self.find(q)
        if rootP != rootQ:
            if self.size[rootP] > self.size[rootQ]:
                self.parent[rootQ] = rootP
                self.size[rootP] += self.size[rootQ]
            else:
                self.parent[rootP] = rootQ
                self.size[rootQ] += self.size[rootP]

uf = UnionFind(5)
uf.union(1, 2)
uf.union(2, 3)
uf.union(4, 5)
print(uf.find(1) == uf.find(3))  # 输出 True
print(uf.find(1) == uf.find(4))  # 输出 False
```

**解析：** 并查集通过路径压缩和按秩合并来优化查找和合并操作的时间复杂度，通常为 O(log(n))。

#### 18. 贪心算法

**题目：** 请简要介绍贪心算法，并给出一个应用示例。

**答案：**

贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法。贪心算法通常用于解决最优子结构问题。

**应用示例：** 最小生成树

```python
def prim(graph):
    result = []
    mst_set = set()
    n = len(graph)

    result.append(graph[0])
    mst_set.add(0)

    for _ in range(1, n):
        min_weight = float('inf')
        min_index = -1
        for vertex in range(1, n):
            if vertex not in mst_set and graph[0][vertex] < min_weight:
                min_weight = graph[0][vertex]
                min_index = vertex
        result.append(min_index)
        mst_set.add(min_index)

    return result
```

**解析：** 贪心算法通过在每次迭代中选择最小权重边，构建最小生成树。

#### 19. 暴力枚举算法

**题目：** 请简要介绍暴力枚举算法，并给出一个应用示例。

**答案：**

暴力枚举算法是一种通过尝试所有可能的组合来解决问题的算法。暴力枚举算法通常用于解决组合问题、排列问题等。

**应用示例：** 全排列

```python
def permutation(nums):
    def dfs(nums, path, res):
        if not nums:
            res.append(path[:])
            return
        for i in range(len(nums)):
            path.append(nums[i])
            dfs(nums[:i] + nums[i+1:], path, res)
            path.pop()

    res = []
    dfs(nums, [], res)
    return res
```

**解析：** 暴力枚举算法通过递归尝试所有可能的组合，找到所有可能的排列。

#### 20. 爬楼梯问题

**题目：** 一个楼梯有 n 阶台阶，每次可以上一阶或两阶，求上楼的方法数。

**答案：**

```python
def climbStairs(n):
    if n <= 2:
        return n

    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2

    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]

    return dp[n]
```

**解析：** 爬楼梯问题可以转化为斐波那契数列，使用动态规划求解。

#### 21. 汉诺塔问题

**题目：** 汉诺塔（Hanoi Tower）是一种经典的递归问题，有三个柱子 A、B、C，初始时 A 柱上有 n 个大小不一的圆盘，要求将所有圆盘从 A 柱移动到 C 柱，每次移动只能将一个圆盘从一个柱子移动到另一个柱子，且在移动过程中，任意时刻都不能出现较大圆盘在较小圆盘之上。

**答案：**

```python
def hanoi(n, A, B, C):
    if n == 1:
        print(f"Move disk 1 from {A} to {C}")
        return
    hanoi(n-1, A, C, B)
    print(f"Move disk {n} from {A} to {C}")
    hanoi(n-1, B, A, C)
```

**解析：** 汉诺塔问题通过递归地将 n-1 个圆盘从 A 柱移动到 B 柱，再将第 n 个圆盘从 A 柱移动到 C 柱，最后将 n-1 个圆盘从 B 柱移动到 C 柱。

#### 22. 股票买卖问题

**题目：** 给定一个整数数组 prices，其中 prices[i] 是第 i 天股票的价格。如果在一个周期内只能购买一次股票，设计一个算法来找到最大的利润。返回最大的利润。如果没有交易完成，则返回 0。

**答案：**

```python
def maxProfit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        profit = prices[i] - prices[i - 1]
        max_profit = max(max_profit, profit)
    return max_profit
```

**解析：** 股票买卖问题可以通过遍历数组，计算相邻两天股票价格的差值，找到最大的利润。

#### 23. 单调栈

**题目：** 单调栈是一种特殊的栈结构，用于解决许多与数组或链表相关的问题，如寻找下一个更大或更小的元素。请简要介绍单调栈，并给出一个应用示例。

**答案：**

单调栈是一种特殊的栈结构，用于维护一个单调递增或递减的序列。在处理问题时，可以通过将元素压入栈或弹出栈来维护单调性。

**应用示例：** 寻找下一个更大元素

```python
def nextGreaterElements(nums):
    n = len(nums)
    stack = []
    result = [-1] * n

    for i in range(2 * n - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i]:
            stack.pop()
        if stack:
            result[i % n] = stack[-1]
        stack.append(i)

    return result
```

**解析：** 单调栈通过从后向前遍历数组，维护一个单调递增的序列，找到每个元素的下一个更大元素。

#### 24. 快速幂算法

**题目：** 快速幂算法是一种用于高效计算大整数幂的算法。请简要介绍快速幂算法，并给出一个应用示例。

**答案：**

快速幂算法通过将指数分解为二进制形式，使用递归或迭代方法计算幂。该方法利用了指数的二进制表示，避免了重复计算。

**应用示例：** 计算幂

```python
def quickPower(x, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        return quickPower(x * x, n // 2)
    return x * quickPower(x * x, (n - 1) // 2)
```

**解析：** 快速幂算法通过递归或迭代计算幂，避免重复计算，提高计算效率。

#### 25. 切绳子

**题目：** 给定一个正整数 n，将绳子剪成若干段，使得每段长度乘积最大。求最大的乘积。

**答案：**

```python
def maxProductAfterCutting(n):
    if n <= 3:
        return n - 1

    mod = 10**9 + 7
    cut_points = [0, 1, 2]
    dp = [0] * (n + 1)
    dp[1], dp[2], dp[3] = 1, 2, 3

    for i in range(4, n + 1):
        dp[i] = max(dp[i - 1], dp[i - 2] * 2, dp[i - 3] * 3)

    return dp[n] % mod
```

**解析：** 切绳子问题可以通过动态规划求解，将问题分解为较小的子问题，计算出最大的乘积。

#### 26. 数组中重复的数字

**题目：** 在一个无序的数组中，找出重复的数字。

**答案：**

```python
def findRepeatNumber(nums):
    n = len(nums)
    visited = [False] * n

    for num in nums:
        if not visited[num - 1]:
            visited[num - 1] = True
        else:
            return num

    return -1
```

**解析：** 数组中重复的数字问题可以通过哈希表或原地交换求解，找到重复的数字。

#### 27. 反转整数

**题目：** 反转一个整数。

**答案：**

```python
def reverse(x):
    sign = 1 if x >= 0 else -1
    x *= sign

    rev = 0
    while x:
        rev = rev * 10 + x % 10
        x //= 10

    return rev * sign
```

**解析：** 反转整数问题可以通过数学运算实现，不断提取整数的个位数并拼接为新整数。

#### 28. 最长公共前缀

**题目：** 找到多个字符串的最长公共前缀。

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]

    return prefix
```

**解析：** 最长公共前缀问题可以通过字符串比较实现，从第一个字符串开始，逐个比较后续字符串的前缀。

#### 29. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**答案：**

```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return left
```

**解析：** 搜索插入位置问题可以通过二分查找实现，找到目标值或确定目标值插入的位置。

#### 30. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy

    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    curr.next = l1 or l2
    return dummy.next
```

**解析：** 合并两个有序链表问题可以通过迭代或递归实现，将两个链表中的节点按顺序合并为新链表。

