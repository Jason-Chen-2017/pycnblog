                 

### 2025年阿里巴巴社招算法岗位面试题目汇编：算法与编程挑战

在阿里巴巴，算法岗位的面试通常包含了广泛的题型，涵盖了数据结构、算法设计、系统设计等多个方面。以下是根据2025年阿里巴巴社招算法岗位面试题目汇编，精选的30道具有代表性的面试题及其答案解析。

---

#### 1. 二维数组的查找

**题目描述：** 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**解答：**

```python
def find(target, array):
    if not array or not array[0]:
        return False
    
    rows, cols = len(array), len(array[0])
    row, col = 0, cols - 1
    
    while row < rows and col >= 0:
        if array[row][col] == target:
            return True
        elif array[row][col] > target:
            col -= 1
        else:
            row += 1
            
    return False
```

**解析：** 从右上角开始查找，如果目标值大于当前元素，向下移动；如果目标值小于当前元素，向左移动。

---

#### 2. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**解答：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
        
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

**解析：** 使用字符串的 `startswith()` 方法逐一检查，每次不匹配时，缩减前缀长度。

---

#### 3. 链表反转

**题目描述：** 反转单链表。

**解答：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    curr = head
    
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
        
    return prev
```

**解析：** 使用递归或迭代的方式，反转链表的指针方向。

---

#### 4. 最小路径和

**题目描述：** 给定一个包含正整数和负整数的二维数组，找到从左上角到右下角的最小路径和。

**解答：**

```python
def minPathSum(grid):
    if not grid:
        return 0
        
    rows, cols = len(grid), len(grid[0])
    dp = [[0] * (cols + 1) for _ in range(rows + 1)]
    
    for i in range(1, rows + 1):
        for j in range(1, cols + 1):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]
            
    return dp[rows][cols]
```

**解析：** 使用动态规划，更新每一个位置的值为到达该位置的最小路径和。

---

#### 5. 二叉搜索树中的搜索

**题目描述：** 在二叉搜索树中找到给定值的节点。

**解答：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root, val):
    while root:
        if root.val == val:
            return root
        elif root.val < val:
            root = root.right
        else:
            root = root.left
    return None
```

**解析：** 利用二叉搜索树的性质，递归或迭代搜索目标节点。

---

#### 6. 合并区间

**题目描述：** 合并一组区间，如果存在重叠区间的话，将其合并。

**解答：**

```python
def merge(intervals):
    if not intervals:
        return []
        
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for i in range(1, len(intervals)):
        last = merged[-1]
        current = intervals[i]
        if last[1] >= current[0]:
            merged[-1] = [last[0], max(last[1], current[1])]
        else:
            merged.append(current)
            
    return merged
```

**解析：** 先排序，然后依次合并重叠的区间。

---

#### 7. 有效的数独

**题目描述：** 判断一个9x9的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效。

- 数字1-9在每一行只能出现一次。
- 数字1-9在每一列只能出现一次。
- 数字1-9在每一个以粗实线分隔的3x3宫格内只能出现一次。

**解答：**

```python
def isValidSudoku(board):
    rows = [set() for _ in range(9)]
    cols = [set() for _ in range(9)]
    boxes = [set() for _ in range(9)]
    
    for i in range(9):
        for j in range(9):
            num = board[i][j]
            if num != '.':
                num = int(num)
                if num in rows[i] or num in cols[j] or num in boxes[i//3*3 + j//3]:
                    return False
                rows[i].add(num)
                cols[j].add(num)
                boxes[i//3*3 + j//3].add(num)
    
    return True
```

**解析：** 使用三个哈希集合分别记录每一行、每一列和每一个3x3宫格中的数字。

---

#### 8. 翻转二叉树

**题目描述：** 翻转一棵二叉树。

**解答：**

```python
def invertTree(root):
    if root:
        root.left, root.right = invertTree(root.right), invertTree(root.left)
        return root
    return None
```

**解析：** 通过递归交换左右子节点。

---

#### 9. 二分查找

**题目描述：** 实现一个二分查找算法。

**解答：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 标准的二分查找算法。

---

#### 10. 旋转图像

**题目描述：** 给定一个n × n的二维矩阵表示一个图像，旋转90度，是否能在原地旋转图像。

**解答：**

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```

**解析：** 分层旋转，每层进行四次交换。

---

#### 11. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。赵云链表中的值为递增顺序。

**解答：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

**解析：** 使用两个指针分别遍历两个链表，选择较小值添加到新链表中。

---

#### 12. 有效的括号

**题目描述：** 给定一个字符串，验证它是否是有效的括号序列，包括括号内的类型可以不同。

**解答：**

```python
def isValid(s):
    stack = []
    brackets = {'(': ')', '[': ']', '{': '}'}
    for char in s:
        if char in brackets:
            stack.append(char)
        elif not stack or char != brackets[stack.pop()]:
            return False
    return not stack
```

**解析：** 使用栈来匹配括号。

---

#### 13. 单调栈

**题目描述：** 使用单调栈解决数组中的下一个更大元素问题。

**解答：**

```python
def nextGreaterElements(self, nums: List[int]) -> List[int]:
    stack = []
    n = len(nums)
    result = [0] * n
    for i in range(2 * n - 1, -1, -1):
        while stack and nums[stack[-1]] <= nums[i % n]:
            stack.pop()
        if stack:
            result[i % n] = nums[stack[-1]]
        stack.append(i % n)
    return result
```

**解析：** 单调栈用于存储元素的下标，用于找到下一个更大的元素。

---

#### 14. 双指针

**题目描述：** 使用双指针解决数组中的三数之和问题。

**解答：**

```python
def threeSum(self, nums: List[int], target: int) -> List[List[int]]:
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return result
```

**解析：** 双指针从两端开始移动，第三数在中间寻找。

---

#### 15. 岛屿的最大面积

**题目描述：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的最大面积。

**解答：**

```python
def maxAreaOfIsland(grid):
    def dfs(i, j):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1:
            grid[i][j] = 0
            return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)
        return 0

    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))
```

**解析：** 使用深度优先搜索遍历岛屿，计算面积。

---

#### 16. 二分查找树的最近公共祖先

**题目描述：** 给定一个二叉搜索树，找到节点 p 和 q 的最近公共祖先。

**解答：**

```python
def lowestCommonAncestor(root, p, q):
    while root:
        if root.val > p.val and root.val > q.val:
            root = root.left
        elif root.val < p.val and root.val < q.val:
            root = root.right
        else:
            return root
    return None
```

**解析：** 利用二叉搜索树的性质，递归查找。

---

#### 17. 字符串中的单词数

**题目描述：** 计算字符串中的单词数。

**解答：**

```python
def countSegments(s):
    count = 0
    in_word = False
    for char in s:
        if char != ' ':
            if not in_word:
                count += 1
                in_word = True
        else:
            in_word = False
    return count
```

**解析：** 遍历字符串，遇到非空字符且不在单词中，计数加一。

---

#### 18. 最长公共前缀

**题目描述：** 找出字符串数组中的最长公共前缀。

**解答：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        for i, char in enumerate(s):
            if i >= len(prefix) or char != prefix[i]:
                prefix = prefix[:i]
                break
    return prefix
```

**解析：** 逐个比较字符串，找到公共前缀。

---

#### 19. 二进制表示中的数字范围

**题目描述：** 给定一个二进制数，返回它在范围 [lower, upper] 中的整数表示。

**解答：**

```python
def rangeBitwiseAnd(mut
```python
def rangeBitwiseAnd(nums, rangeLow, rangeHigh):
    shift = 0
    while rangeLow < rangeHigh:
        rangeLow >>= 1
        rangeHigh >>= 1
        shift += 1
    return nums[0] & (rangeHigh << shift)
```

**解析：** 通过不断右移 `rangeLow` 和 `rangeHigh`，找到它们的公共前缀，然后通过位运算还原结果。

---

#### 20. 最长公共子序列

**题目描述：** 给定两个字符串，返回它们的 longest common subsequence。

**解答：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**解析：** 使用动态规划计算最长公共子序列的长度。

---

#### 21. 等差数列中的缺失数字

**题目描述：** 给定一个等差数列，返回缺失的数字。

**解答：**

```python
def missingNumber(nums):
    n = len(nums)
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum
```

**解析：** 利用等差数列的求和公式计算缺失的数字。

---

#### 22. 快乐数

**题目描述：** 判断一个数是否是快乐数。

**解答：**

```python
def isHappy(n):
    def get_next(n):
        total = 0
        while n:
            total += n % 10 * n % 10
            n //= 10
        return total

    slow, fast = n, get_next(n)
    while fast != 1 and slow != fast:
        slow = get_next(slow)
        fast = get_next(get_next(fast))
    return fast == 1
```

**解析：** 使用快慢指针判断循环。

---

#### 23. 有效的括号字符串

**题目描述：** 判断字符串是否可以通过添加括号变为有效的括号字符串。

**解答：**

```python
def checkValidString(parens):
    stack = []
    for c in parens:
        if c == '(' or stack:
            stack.append(c)
        else:
            stack.pop()
    return not stack
```

**解析：** 使用栈判断括号的有效性。

---

#### 24. 计数二进制子串

**题目描述：** 统计二进制字符串中出现的连续1的最长子串。

**解答：**

```python
def countBinarySubstrings(s):
    count = prev = 0
    for c in s:
        if c == '1':
            count += 1
        else:
            count = 0
        if count > prev:
            prev = count
    return prev
```

**解析：** 遍历字符串，统计连续1的最大长度。

---

#### 25. 图的深度优先搜索

**题目描述：** 实现图的深度优先搜索算法。

**解答：**

```python
def dfs(graph, node, visited):
    if node not in visited:
        visited.add(node)
        for neighbour in graph[node]:
            dfs(graph, neighbour, visited)

def dfs_iter(graph, start):
    visited = set()
    stack = [start]
    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            stack.extend(graph[node])
    return visited
```

**解析：** 使用递归和迭代两种方式实现DFS。

---

#### 26. 搜索旋转排序数组

**题目描述：** 搜索一个旋转排序数组中的目标值。

**解答：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 利用旋转排序数组的特点，分区间搜索。

---

#### 27. 最小栈

**题目描述：** 实现一个具有最小栈功能的栈。

**解答：**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val):
        self.stack.append(val)
        if not self.min_stack or val < self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self):
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self):
        return self.stack[-1]

    def getMin(self):
        return self.min_stack[-1]
```

**解析：** 使用两个栈，一个存储数据，一个存储最小值。

---

#### 28. 汇总统计

**题目描述：** 给定一个整数数组  nums 和两个整数 lower 和 upper ，返回链表，其中包含 nums 中每个数字在 lower 和 upper 范围内出现的次数。

**解答：**

```python
from collections import Counter

def rangeSumHandler(nums, range_list):
    counter = Counter(nums)
    result = []
    for lower, upper in range_list:
        result.append([counter[i] for i in nums if lower <= i <= upper])
    return result
```

**解析：** 使用计数器统计，然后根据范围过滤。

---

#### 29. 找出重复的子串

**题目描述：** 给定一个字符串 s ，找出其中不重复的子串，并按照它们在 s 中出现的顺序排序。

**解答：**

```python
from collections import defaultdict

def findDuplicates(s):
    d = defaultdict(int)
    result = []
    for c in s:
        if d[c]:
            result.append(c)
        d[c] += 1
    return sorted(result)
```

**解析：** 使用哈希表统计字符出现次数，然后按照出现次数排序。

---

#### 30. 前K个高频元素

**题目描述：** 给定一个非空整数数组，返回其中出现频率最高的 k 个元素。

**解答：**

```python
from collections import Counter

def topKFrequent(nums, k):
    count = Counter(nums)
    return [v for v in count.most_common(k)]
```

**解析：** 使用计数器，然后根据频率降序排序，取前k个元素。

---

以上就是根据2025年阿里巴巴社招算法岗位面试题目汇编，精选的30道面试题及其答案解析。这些题目覆盖了算法的各个方面，是阿里巴巴算法面试的典型代表。希望这些答案能帮助准备面试的你更好地应对挑战。

