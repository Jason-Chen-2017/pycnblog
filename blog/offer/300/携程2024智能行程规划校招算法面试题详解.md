                 

## 携程2024智能行程规划校招算法面试题详解

### 1. 贪心算法

**题目：** 携程智能行程规划系统中，如何使用贪心算法找到最短路径？

**答案：** 贪心算法通过在每一步选择当前最优解，希望由此导致的结果是最优的。在智能行程规划中，可以使用Dijkstra算法的贪心选择策略来找到最短路径。

**解析：**

```go
func findShortestPath(graph [][]int, start int) int {
    n := len(graph)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0
    visited := make([]bool, n)
    for i := 0; i < n; i++ {
        u := -1
        for j := 0; j < n; j++ {
            if !visited[j] && (u == -1 || dist[j] < dist[u]) {
                u = j
            }
        }
        visited[u] = true
        for v, w := range graph[u] {
            if !visited[v] && dist[v] > dist[u]+w {
                dist[v] = dist[u]+w
            }
        }
    }
    return dist
}
```

### 2. 广度优先搜索

**题目：** 如何使用广度优先搜索（BFS）算法来找出最短路径？

**答案：** 广度优先搜索（BFS）是一种用于图遍历的算法，它首先访问起始节点，然后依次访问所有相邻节点，直到找到目标节点或遍历完整个图。

**解析：**

```go
func findShortestPathBFS(graph [][]int, start, target int) int {
    n := len(graph)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0
    q := []int{start}
    for len(q) > 0 {
        u := q[0]
        q = q[1:]
        for v, w := range graph[u] {
            if dist[v] > dist[u]+w {
                dist[v] = dist[u]+w
                q = append(q, v)
            }
        }
    }
    return dist[target]
}
```

### 3. 最小生成树

**题目：** 如何使用Prim算法求解最小生成树问题？

**答案：** Prim算法是一种用于求解加权无向图的最小生成树的贪心算法。

**解析：**

```go
func prim(graph [][]int) []int {
    n := len(graph)
    mst := make([]int, n)
    key := make([]int, n)
    inMst := make([]bool, n)
    key[0] = 0
    for i := range inMst {
        inMst[i] = false
    }
    mstCount := 0
    for mstCount < n {
        u := -1
        for i := range key {
            if !inMst[i] && (u == -1 || key[i] < key[u]) {
                u = i
            }
        }
        inMst[u] = true
        mstCount++
        for v, w := range graph[u] {
            if !inMst[v] && key[v] > w {
                key[v] = w
            }
        }
    }
    return mst
}
```

### 4. 动态规划

**题目：** 如何使用动态规划算法解决背包问题？

**答案：** 背包问题是一种经典的动态规划问题。

**解析：**

```go
func knapsack(values []int, weights []int, capacity int) int {
    n := len(values)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    for i := 1; i <= n; i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][capacity]
}
```

### 5. 搜索算法

**题目：** 如何使用A*算法求解最短路径问题？

**答案：** A*算法是一种基于启发式的搜索算法。

**解析：**

```go
func shortestPathAStar(graph [][]int, start, target int, heuristic func(int) int) int {
    n := len(graph)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0
    q := make(PriorityQueue, 0)
    q.push(&Node{val: start, dist: 0})
    for q.len() > 0 {
        u := q.pop().val
        if u == target {
            break
        }
        for v, w := range graph[u] {
            if dist[v] > dist[u]+w {
                dist[v] = dist[u]+w
                q.push(&Node{val: v, dist: dist[v]})
            }
        }
    }
    return dist[target]
}
```

### 6. 树形动态规划

**题目：** 如何使用树形动态规划解决最近公共祖先问题？

**答案：** 树形动态规划可以用来求解最近公共祖先问题。

**解析：**

```go
func lowestCommonAncestor(root *TreeNode, p, q *TreeNode) *TreeNode {
    memo := make(map[int]int)
    return dfs(root, p, q, memo)
}

func dfs(node *TreeNode, p, q int, memo map[int]int) *TreeNode {
    if node == nil || node == p || node == q {
        return node
    }
    if _, found := memo[node.val]; found {
        return memo[node.val]
    }
    left := dfs(node.Left, p, q, memo)
    right := dfs(node.Right, p, q, memo)
    if left != nil && right != nil {
        memo[node.val] = node
        return node
    }
    if left != nil {
        memo[node.val] = left
        return left
    }
    if right != nil {
        memo[node.val] = right
        return right
    }
    return nil
}
```

### 7. 快速幂算法

**题目：** 如何使用快速幂算法计算大数的幂？

**答案：** 快速幂算法可以用来高效地计算大数的幂。

**解析：**

```go
func quickPower(base int, exponent int) int {
    result := 1
    for exponent > 0 {
        if exponent%2 == 1 {
            result *= base
        }
        base *= base
        exponent /= 2
    }
    return result
}
```

### 8. 合并区间

**题目：** 如何合并区间？

**答案：** 合并区间的方法是将重叠的区间合并成一个区间。

**解析：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var merged [][]int
    for _, interval := range intervals {
        if len(merged) == 0 || merged[len(merged)-1][1] < interval[0] {
            merged = append(merged, interval)
        } else {
            merged[len(merged)-1][1] = max(merged[len(merged)-1][1], interval[1])
        }
    }
    return merged
}
```

### 9. 二分查找

**题目：** 如何使用二分查找？

**答案：** 二分查找是用于在有序数组中查找某个元素的算法。

**解析：**

```go
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

### 10. 优先队列

**题目：** 如何使用优先队列？

**答案：** 优先队列是一种特殊的队列，元素按照优先级排序。

**解析：**

```go
type PriorityQueue []*Node

func (pq PriorityQueue) Len() int { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool {
    return pq[i].dist < pq[j].dist
}
func (pq PriorityQueue) Swap(i, j int) {
    pq[i], pq[j] = pq[j], pq[i]
}
func (pq *PriorityQueue) Push(x interface{}) {
    node := x.(*Node)
    *node = &Node{val: node.val, dist: node.dist}
    *pq = append(*pq, node)
}
func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    x := old[n-1]
    *pq = old[0 : n-1]
    return x
}
```

### 11. 最小栈

**题目：** 如何使用栈实现一个最小栈？

**答案：** 使用两个栈，一个存储元素，一个存储最小值。

**解析：**

```go
type MinStack struct {
    s1 []int
    s2 []int
}

func Constructor() MinStack {
    return MinStack{s1: []int{}, s2: []int{}}
}

func (this *MinStack) Push(val int) {
    this.s1 = append(this.s1, val)
    if len(this.s2) == 0 || val <= this.s2[len(this.s2)-1] {
        this.s2 = append(this.s2, val)
    }
}

func (this *MinStack) Pop() {
    if this.s1[len(this.s1)-1] == this.s2[len(this.s2)-1] {
        this.s2 = this.s2[:len(this.s2)-1]
    }
    this.s1 = this.s1[:len(this.s1)-1]
}

func (this *MinStack) Top() int {
    return this.s1[len(this.s1)-1]
}

func (this *MinStack) GetMin() int {
    return this.s2[len(this.s2)-1]
}
```

### 12. 队列实现优先队列

**题目：** 如何使用队列实现一个优先队列？

**答案：** 使用两个队列，一个存储元素，一个存储优先级。

**解析：**

```go
type PriorityQueue struct {
    items []interface{}
    priority []int
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{
        items:   []interface{}{},
        priority: []int{},
    }
}

func (pq *PriorityQueue) Push(item interface{}, priority int) {
    pq.items = append(pq.items, item)
    pq.priority = append(pq.priority, priority)
}

func (pq *PriorityQueue) Pop() interface{} {
    item := pq.items[0]
    pq.items = pq.items[1:]
    pq.priority = pq.priority[1:]
    return item
}

func (pq *PriorityQueue) GetPriority() int {
    return pq.priority[0]
}
```

### 13. 没有虚拟内存的分页算法

**题目：** 如何实现没有虚拟内存的分页算法？

**答案：** 使用数组模拟内存，当发生缺页中断时，从磁盘读取数据。

**解析：**

```go
func pageReplacement(pages []int, frameSize int) int {
    pageFaults := 0
    cache := make([]int, frameSize)
    for i, page := range pages {
        found := false
        for _, c := range cache {
            if c == page {
                found = true
                break
            }
        }
        if !found {
            pageFaults++
            if pageFaults > frameSize {
                cache = append(cache[1:], page)
            } else {
                cache = append(cache, page)
            }
        }
    }
    return pageFaults
}
```

### 14. 字符串匹配算法

**题目：** 如何实现字符串匹配算法？

**答案：** 使用KMP算法。

**解析：**

```go
func KMP(pattern string, text string) int {
    n, m := len(text), len(pattern)
    lps := make([]int, m)
    j := -1
    for i := 0; i < m; {
        if pattern[i] == pattern[j] {
            i++
            j++
            lps[i-1] = j
        } else {
            if j != -1 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    i = 0
    j = 0
    for i < n {
        if pattern[i] == pattern[j] {
            i++
            j++
        }
        if j == m {
            return i - j
        }
        if i < n && pattern[i] != pattern[j] {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    return -1
}
```

### 15. 快速排序

**题目：** 如何实现快速排序？

**答案：** 选择一个基准元素，将数组分为两部分，递归地对两部分进行排序。

**解析：**

```go
func quickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

### 16. 快速选择

**题目：** 如何实现快速选择算法？

**答案：** 选择一个基准元素，将数组分为两部分，递归地对较小部分进行选择。

**解析：**

```go
func quickSelect(arr []int, low int, high int, k int) {
    if low < high {
        pi := partition(arr, low, high)
        if pi == k {
            return
        } else if pi > k {
            quickSelect(arr, low, pi-1, k)
        } else {
            quickSelect(arr, pi+1, high, k)
        }
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

### 17. 堆排序

**题目：** 如何实现堆排序？

**答案：** 使用大根堆进行排序。

**解析：**

```go
func heapify(arr []int, n int, i int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2
    if left < n && arr[left] > arr[largest] {
        largest = left
    }
    if right < n && arr[right] > arr[largest] {
        largest = right
    }
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func heapSort(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}
```

### 18. 归并排序

**题目：** 如何实现归并排序？

**答案：** 使用递归将数组分成两部分，然后合并排序后的两部分。

**解析：**

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left []int, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

### 19. 哈希表

**题目：** 如何实现哈希表？

**答案：** 使用数组+链表或数组+红黑树实现哈希表。

**解析：**

```go
type HashTable struct {
    buckets []*ListNode
    size int
}

func NewHashTable(size int) *HashTable {
    h := &HashTable{
        buckets: make([]*ListNode, size),
        size: size,
    }
    for i := range h.buckets {
        h.buckets[i] = &ListNode{}
    }
    return h
}

func (h *HashTable) Insert(key string, value interface{}) {
    index := hash(key) % h.size
    node := &ListNode{Key: key, Value: value}
    if h.buckets[index] == nil {
        h.buckets[index] = node
    } else {
        prev := h.buckets[index]
        for prev.Next != nil {
            prev = prev.Next
        }
        prev.Next = node
    }
}

func (h *HashTable) Get(key string) (interface{}, bool) {
    index := hash(key) % h.size
    node := h.buckets[index]
    for node != nil {
        if node.Key == key {
            return node.Value, true
        }
        node = node.Next
    }
    return nil, false
}
```

### 20. 并发编程

**题目：** 如何在Go中使用并发编程？

**答案：** 使用goroutine和channel实现并发编程。

**解析：**

```go
func main() {
    c := make(chan int)
    go func() {
        time.Sleep(time.Second)
        c <- 1
    }()
    select {
    case <-c:
        fmt.Println("Received:", <-c)
    case <-time.After(2 * time.Second):
        fmt.Println("Timeout")
    }
}
```

### 21. 反转链表

**题目：** 如何反转链表？

**答案：** 使用递归或迭代方法反转链表。

**解析：**

递归方法：

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

迭代方法：

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    for head != nil {
        next := head.Next
        head.Next = prev
        prev = head
        head = next
    }
    return prev
}
```

### 22. 快速幂算法

**题目：** 如何实现快速幂算法？

**答案：** 使用递归或迭代方法实现快速幂算法。

**解析：**

递归方法：

```go
func quickPower(base int, exponent int) int {
    if exponent == 0 {
        return 1
    }
    if exponent%2 == 0 {
        return quickPower(base*base, exponent/2)
    }
    return base * quickPower(base*base, exponent/2)
}
```

迭代方法：

```go
func quickPower(base int, exponent int) int {
    result := 1
    for exponent > 0 {
        if exponent%2 == 1 {
            result *= base
        }
        base *= base
        exponent /= 2
    }
    return result
}
```

### 23. 栈和队列

**题目：** 如何实现栈和队列？

**答案：** 使用数组或链表实现栈和队列。

**解析：**

栈：

```go
type Stack struct {
    items []int
}

func (s *Stack) Push(item int) {
    s.items = append(s.items, item)
}

func (s *Stack) Pop() int {
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

func (s *Stack) Peek() int {
    return s.items[len(s.items)-1]
}

func (s *Stack) IsEmpty() bool {
    return len(s.items) == 0
}
```

队列：

```go
type Queue struct {
    items []int
}

func (q *Queue) Enqueue(item int) {
    q.items = append(q.items, item)
}

func (q *Queue) Dequeue() int {
    item := q.items[0]
    q.items = q.items[1:]
    return item
}

func (q *Queue) Front() int {
    return q.items[0]
}

func (q *Queue) IsEmpty() bool {
    return len(q.items) == 0
}
```

### 24. 单调栈

**题目：** 如何实现单调栈？

**答案：** 使用栈实现单调栈，可以用于求解数组中的最大值或最小值。

**解析：**

```go
func monotonicStack(nums []int) []int {
    stack := []int{}
    for _, num := range nums {
        for len(stack) > 0 && stack[len(stack)-1] <= num {
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, num)
    }
    return stack
}
```

### 25. 单调队列

**题目：** 如何实现单调队列？

**答案：** 使用队列实现单调队列，可以用于求解数组中的最大值或最小值。

**解析：**

```go
type MonotonicQueue struct {
    queue []int
}

func (mq *MonotonicQueue) Push(v int) {
    for len(mq.queue) > 0 && mq.queue[len(mq.queue)-1] <= v {
        mq.queue = mq.queue[:len(mq.queue)-1]
    }
    mq.queue = append(mq.queue, v)
}

func (mq *MonotonicQueue) Pop() {
    if len(mq.queue) > 0 {
        mq.queue = mq.queue[:len(mq.queue)-1]
    }
}

func (mq *MonotonicQueue) Front() int {
    if len(mq.queue) > 0 {
        return mq.queue[0]
    }
    return -1
}
```

### 26. 双指针

**题目：** 如何使用双指针？

**答案：** 双指针是一种常用的算法技巧，可以用于解决数组中的问题，如找出数组中的重复元素、实现快慢指针等。

**解析：**

```go
func findDuplicate(nums []int) int {
    slow := 0
    fast := 0
    for {
        slow = nums[slow]
        fast = nums[nums[fast]]
        if slow == fast {
            break
        }
    }
    slow = 0
    for slow != fast {
        slow = nums[slow]
        fast = nums[fast]
    }
    return slow
}
```

### 27. 排序算法

**题目：** 如何实现排序算法？

**答案：** 实现常见的排序算法，如冒泡排序、选择排序、插入排序、快速排序等。

**解析：**

冒泡排序：

```go
func bubbleSort(nums []int) {
    n := len(nums)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if nums[j] > nums[j+1] {
                nums[j], nums[j+1] = nums[j+1], nums[j]
            }
        }
    }
}
```

选择排序：

```go
func selectionSort(nums []int) {
    n := len(nums)
    for i := 0; i < n; i++ {
        minIndex := i
        for j := i+1; j < n; j++ {
            if nums[j] < nums[minIndex] {
                minIndex = j
            }
        }
        nums[i], nums[minIndex] = nums[minIndex], nums[i]
    }
}
```

插入排序：

```go
func insertionSort(nums []int) {
    n := len(nums)
    for i := 1; i < n; i++ {
        key := nums[i]
        j := i - 1
        for j >= 0 && nums[j] > key {
            nums[j+1] = nums[j]
            j--
        }
        nums[j+1] = key
    }
}
```

快速排序：

```go
func quickSort(nums []int, low int, high int) {
    if low < high {
        pi := partition(nums, low, high)
        quickSort(nums, low, pi-1)
        quickSort(nums, pi+1, high)
    }
}

func partition(nums []int, low int, high int) int {
    pivot := nums[high]
    i := low - 1
    for j := low; j < high; j++ {
        if nums[j] < pivot {
            i++
            nums[i], nums[j] = nums[j], nums[i]
        }
    }
    nums[i+1], nums[high] = nums[high], nums[i+1]
    return i + 1
}
```

### 28. 并查集

**题目：** 如何实现并查集？

**答案：** 使用路径压缩和按秩合并实现并查集。

**解析：**

```go
type UnionFind struct {
    parents []int
    ranks   []int
}

func newUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        parents: make([]int, n),
        ranks:   make([]int, n),
    }
    for i := range uf.parents {
        uf.parents[i] = i
        uf.ranks[i] = 1
    }
    return uf
}

func (uf *UnionFind) find(x int) int {
    if uf.parents[x] != x {
        uf.parents[x] = uf.find(uf.parents[x])
    }
    return uf.parents[x]
}

func (uf *UnionFind) union(x int, y int) {
    rootX := uf.find(x)
    rootY := uf.find(y)
    if rootX != rootY {
        if uf.ranks[rootX] > uf.ranks[rootY] {
            uf.parents[rootY] = rootX
        } else if uf.ranks[rootX] < uf.ranks[rootY] {
            uf.parents[rootX] = rootY
        } else {
            uf.parents[rootY] = rootX
            uf.ranks[rootX]++
        }
    }
}
```

### 29. 常见数据结构

**题目：** 如何实现常见的数据结构？

**答案：** 实现常见的线性结构和非线性结构，如链表、栈、队列、二叉树等。

**解析：**

链表：

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func (l *ListNode) Append(val int) {
    node := &ListNode{Val: val}
    if l == nil {
        l = node
    } else {
        current := l
        for current.Next != nil {
            current = current.Next
        }
        current.Next = node
    }
}
```

栈：

```go
type Stack struct {
    elements []int
}

func (s *Stack) Push(val int) {
    s.elements = append(s.elements, val)
}

func (s *Stack) Pop() int {
    if len(s.elements) == 0 {
        return -1
    }
    val := s.elements[len(s.elements)-1]
    s.elements = s.elements[:len(s.elements)-1]
    return val
}

func (s *Stack) Peek() int {
    if len(s.elements) == 0 {
        return -1
    }
    return s.elements[len(s.elements)-1]
}
```

队列：

```go
type Queue struct {
    elements []int
}

func (q *Queue) Enqueue(val int) {
    q.elements = append(q.elements, val)
}

func (q *Queue) Dequeue() int {
    if len(q.elements) == 0 {
        return -1
    }
    val := q.elements[0]
    q.elements = q.elements[1:]
    return val
}

func (q *Queue) Front() int {
    if len(q.elements) == 0 {
        return -1
    }
    return q.elements[0]
}
```

二叉树：

```go
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func (t *TreeNode) Insert(val int) {
    if val < t.Val {
        if t.Left == nil {
            t.Left = &TreeNode{Val: val}
        } else {
            t.Left.Insert(val)
        }
    } else {
        if t.Right == nil {
            t.Right = &TreeNode{Val: val}
        } else {
            t.Right.Insert(val)
        }
    }
}
```

### 30. 其他算法

**题目：** 如何实现其他算法？

**答案：** 实现其他常见的算法，如最大子序列和、最长公共子序列、最长公共前缀等。

**解析：**

最大子序列和：

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}
```

最长公共子序列：

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

最长公共前缀：

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && strings.Index(strs[i], prefix) != 0 {
            prefix = prefix[:len(prefix)-1]
        }
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}
```

