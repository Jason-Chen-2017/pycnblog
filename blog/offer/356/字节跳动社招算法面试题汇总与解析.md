                 

## 2024字节跳动社招算法面试题汇总与解析

### 1. 快排优化

**题目：** 请实现一个快速排序算法，并考虑如何优化其性能。

**答案：** 快速排序算法的基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后递归地对这两部分记录继续进行快速排序。

**代码示例：**

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

**解析：** 该代码实现了快速排序算法，其中通过`partition`函数确定分区点，然后将数组划分为两部分，递归地对这两部分进行排序。为了优化性能，可以通过随机选择分区点、三数取中等方法来避免最坏情况。

### 2. 最小生成树

**题目：** 请使用 Prim 算法实现最小生成树。

**答案：** Prim 算法是一种贪心算法，用于寻找加权无向图的最小生成树。算法从任意一个顶点开始，逐步增加新的顶点和边，直到所有顶点都被包含在生成树中。

**代码示例：**

```go
package main

import (
    "fmt"
)

func prim(M [][]int) []int {
    n := len(M)
    key := make([]int, n)
    mst := make([]bool, n)
    key[0] = 0
    mst[0] = true
    edges := 0

    for edges < n-1 {
        minKey := -1
        for i := 0; i < n; i++ {
            if !mst[i] && (minKey == -1 || key[i] < key[minKey]) {
                minKey = i
            }
        }
        mst[minKey] = true
        edges++
        for j := 0; j < n; j++ {
            if mst[j] && M[minKey][j] > 0 {
                key[j] = M[minKey][j]
            }
        }
    }

    result := make([]int, n)
    for i := 0; i < n; i++ {
        result[i] = key[i]
    }
    return result
}

func main() {
    M := [][]int{
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 10, 9},
        {6, 8, 10, 0, 2},
        {0, 5, 9, 2, 0},
    }
    result := prim(M)
    fmt.Println("Minimum spanning tree:", result)
}
```

**解析：** 该代码实现了 Prim 算法，首先初始化关键值和已访问顶点数组，然后依次选择最小关键值的边，直至形成最小生成树。

### 3. 爬楼梯

**题目：** 一只青蛙一次可以跳上1级台阶，也可以跳上2级。假设台阶总数为n，请编写一个函数来计算有多少种方法可以爬到第n级台阶。

**答案：** 使用动态规划方法，设`f(n)`表示到达第n级台阶的方法数，则有递推关系：`f(n) = f(n-1) + f(n-2)`。

**代码示例：**

```go
package main

import (
    "fmt"
)

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i < n; i++ {
        a, b = b, a+b
    }
    return b
}

func main() {
    n := 4
    fmt.Printf("Number of ways to climb %d stairs: %d\n", n, climbStairs(n))
}
```

**解析：** 该代码使用动态规划方法计算到达第n级台阶的方法数，通过迭代计算得出结果。

### 4. 链表反转

**题目：** 实现一个函数，对链表进行反转。

**答案：** 使用递归或迭代方法，将当前节点的下一个节点指向当前节点的下一个节点的下一个节点，直至最后一个节点。

**代码示例（递归）：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    newHead := reverseList(head)
    fmt.Println("Reversed list:", newHead)
}
```

**代码示例（迭代）：**

```go
package main

import (
    "fmt"
)

func reverseList(head *ListNode) *ListNode {
    prev := nil
    curr := head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    newHead := reverseList(head)
    fmt.Println("Reversed list:", newHead)
}
```

**解析：** 该代码实现了两种方法，递归和迭代，用于对链表进行反转。

### 5. 合并两个有序链表

**题目：** 实现一个函数，合并两个有序链表。

**答案：** 使用迭代方法，将两个有序链表按顺序合并成一个有序链表。

**代码示例：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    tail := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            tail.Next = l1
            l1 = l1.Next
        } else {
            tail.Next = l2
            l2 = l2.Next
        }
        tail = tail.Next
    }
    tail.Next = l1 != nil ? l1 : l2
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1}
    l1.Next = &ListNode{Val: 3}
    l1.Next.Next = &ListNode{Val: 5}

    l2 := &ListNode{Val: 2}
    l2.Next = &ListNode{Val: 4}
    l2.Next.Next = &ListNode{Val: 6}

    merged := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", merged)
}
```

**解析：** 该代码实现了合并两个有序链表的方法，通过迭代比较两个链表的节点值，将较小的值添加到新链表中，直至其中一个链表结束，然后将剩余的链表连接到新链表的末尾。

### 6. 二叉树的层序遍历

**题目：** 实现一个函数，实现二叉树的层序遍历。

**答案：** 使用广度优先搜索（BFS）方法，使用队列实现。

**代码示例：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }
    queue := []*TreeNode{root}
    result := [][]int{}
    for len(queue) > 0 {
        level := []int{}
        for _, node := range queue {
            level = append(level, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        result = append(result, level)
        queue = queue[1:]
    }
    return result
}

func main() {
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}
    root.Right.Left = &TreeNode{Val: 6}
    root.Right.Right = &TreeNode{Val: 7}

    result := levelOrder(root)
    fmt.Println("Level order traversal:", result)
}
```

**解析：** 该代码实现了二叉树的层序遍历，通过队列实现广度优先搜索，逐层遍历二叉树的节点。

### 7. 字符串匹配算法

**题目：** 实现一个字符串匹配算法，如 Knuth-Morris-Pratt 算法。

**答案：** Knuth-Morris-Pratt 算法（KMP）通过构建部分匹配表（Next 数组）来优化字符串匹配。

**代码示例：**

```go
package main

import (
    "fmt"
)

func kmpNext(s string) []int {
    n := len(s)
    next := make([]int, n)
    next[0] = -1
    j := -1
    for i := 1; i < n; i++ {
        for j >= 0 && s[i] != s[j+1] {
            j = next[j]
        }
        if s[i] == s[j+1] {
            j++
        }
        next[i] = j
    }
    return next
}

func kmp(s, p string) int {
    n, m := len(s), len(p)
    next := kmpNext(p)
    i, j := 0, 0
    for i < n && j < m {
        if j == -1 || s[i] == p[j] {
            i++
            j++
        } else {
            j = next[j]
        }
    }
    if j == m {
        return i - j
    }
    return -1
}

func main() {
    s := "ababcabcab"
    p := "abc"
    result := kmp(s, p)
    fmt.Printf("The pattern '%s' is found at index: %d\n", p, result)
}
```

**解析：** 该代码实现了 Knuth-Morris-Pratt 算法，通过构建 Next 数组来避免从后往前回溯，从而提高字符串匹配的效率。

### 8. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**答案：** 首先将区间按照起始点排序，然后遍历区间，合并重叠的区间。

**代码示例：**

```go
package main

import (
    "fmt"
    "sort"
)

type Interval struct {
    Start int
    End   int
}

func merge(intervals []Interval) []Interval {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    result := []Interval{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        last := len(result) - 1
        if intervals[i].Start <= result[last].End {
            result[last].End = max(result[last].End, intervals[i].End)
        } else {
            result = append(result, intervals[i])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := []Interval{
        {Start: 1, End: 3},
        {Start: 2, End: 6},
        {Start: 8, End: 10},
        {Start: 15, End: 18},
    }
    result := merge(intervals)
    fmt.Println("Merged intervals:", result)
}
```

**解析：** 该代码首先对区间进行排序，然后遍历区间，合并重叠的区间。合并时，判断当前区间的起始点是否小于前一个区间的结束点，如果是，则更新前一个区间的结束点；否则，将当前区间添加到结果中。

### 9. 优先队列

**题目：** 实现一个优先队列，支持插入和删除操作。

**答案：** 可以使用堆（Heap）来实现优先队列，其中大顶堆用于获取最高优先级元素，小顶堆用于插入新元素。

**代码示例：**

```go
package main

import (
    "fmt"
    "container/heap"
)

type Item struct {
    Value    int
    Priority int
    Index    int
}

type MaxHeap []*Item

func (h MaxHeap) Len() int {
    return len(h)
}

func (h MaxHeap) Less(i, j int) bool {
    return h[i].Priority > h[j].Priority
}

func (h MaxHeap) Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
    h[i].Index = i
    h[j].Index = j
}

func (h *MaxHeap) Push(x interface{}) {
    n := len(*h)
    item := x.(*Item)
    item.Index = n
    *h = append(*h, item)
}

func (h *MaxHeap) Pop() interface{} {
    old := *h
    n := len(old)
    item := old[n-1]
    item.Index = -1
    *h = old[0 : n-1]
    return item
}

func (h *MaxHeap) update(item *Item, value int) {
    item.Value = value
    // 更新堆
    if h.Less(h.IndexOf(item), h.parent(h.IndexOf(item))) {
        heap.FixUp(h, h.IndexOf(item))
    } else {
        heap.FixDown(h, h.IndexOf(item))
    }
}

func (h *MaxHeap) IndexOf(item *Item) int {
    for i, v := range *h {
        if v == item {
            return i
        }
    }
    return -1
}

func (h *MaxHeap) parent(i int) int {
    return (i - 1) / 2
}

func main() {
    h := &MaxHeap{}
    heap.Init(h)

    heap.Push(h, &Item{Value: 1, Priority: 2})
    heap.Push(h, &Item{Value: 2, Priority: 1})
    heap.Push(h, &Item{Value: 3, Priority: 3})

    fmt.Println("Max heap:", h)

    heap.Pop(h)
    fmt.Println("After popping:", h)

    item := heap.Pop(h).(*Item)
    heap.Push(h, &Item{Value: item.Value, Priority: item.Priority + 1})
    fmt.Println("After updating:", h)
}
```

**解析：** 该代码实现了基于堆的优先队列，其中`MaxHeap`类型实现了`heap.Interface`接口，用于实现最大堆。通过`Push`、`Pop`方法分别实现插入和删除操作。

### 10. 前缀树

**题目：** 实现一个前缀树（Trie）。

**答案：** Trie 是一种树形结构，用于存储字符串，支持快速查询前缀和单词。

**代码示例：**

```go
package main

import (
    "fmt"
)

type TrieNode struct {
    children [26]*TrieNode
    isEnd    bool
}

func NewTrie() *TrieNode {
    return &TrieNode{}
}

func (n *TrieNode) Insert(word string) {
    node := n
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &TrieNode{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
}

func (n *TrieNode) Search(word string) bool {
    node := n
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            return false
        }
        node = node.children[idx]
    }
    return node.isEnd
}

func main() {
    trie := NewTrie()
    trie.Insert("apple")
    trie.Insert("banana")
    trie.Insert("app")

    fmt.Println("Search 'apple':", trie.Search("apple")) // true
    fmt.Println("Search 'banana':", trie.Search("banana")) // true
    fmt.Println("Search 'app':", trie.Search("app")) // true
    fmt.Println("Search 'ap':", trie.Search("ap")) // false
}
```

**解析：** 该代码实现了前缀树，通过插入和搜索操作，支持快速查找前缀和单词。

### 11. 快速幂

**题目：** 实现一个快速幂函数。

**答案：** 通过递归和循环两种方法实现快速幂函数，避免重复计算。

**代码示例（递归）：**

```go
package main

import (
    "fmt"
)

func quickPow(x, n int) int {
    if n == 0 {
        return 1
    }
    if n%2 == 0 {
        half := quickPow(x, n/2)
        return half * half
    }
    return x * quickPow(x, n-1)
}

func main() {
    x := 2
    n := 10
    fmt.Printf("x^%d = %d\n", n, quickPow(x, n))
}
```

**代码示例（循环）：**

```go
package main

import (
    "fmt"
)

func quickPow(x, n int) int {
    result := 1
    for n > 0 {
        if n%2 == 1 {
            result *= x
        }
        x *= x
        n /= 2
    }
    return result
}

func main() {
    x := 2
    n := 10
    fmt.Printf("x^%d = %d\n", n, quickPow(x, n))
}
```

**解析：** 该代码实现了快速幂函数，通过递归和循环两种方法，避免重复计算，提高计算效率。

### 12. 二分查找

**题目：** 实现一个二分查找函数。

**答案：** 通过递归和循环两种方法实现二分查找。

**代码示例（递归）：**

```go
package main

import (
    "fmt"
)

func binarySearch(arr []int, target int, low, high int) int {
    if low > high {
        return -1
    }
    mid := (low + high) / 2
    if arr[mid] == target {
        return mid
    } else if arr[mid] > target {
        return binarySearch(arr, target, low, mid-1)
    } else {
        return binarySearch(arr, target, mid+1, high)
    }
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    target := 5
    result := binarySearch(arr, target, 0, len(arr)-1)
    fmt.Printf("Element %d is at index: %d\n", target, result)
}
```

**代码示例（循环）：**

```go
package main

import (
    "fmt"
)

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] > target {
            high = mid - 1
        } else {
            low = mid + 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    target := 5
    result := binarySearch(arr, target)
    fmt.Printf("Element %d is at index: %d\n", target, result)
}
```

**解析：** 该代码实现了二分查找函数，通过递归和循环两种方法，在有序数组中查找目标元素。

### 13. 逆波兰表达式求值

**题目：** 实现一个逆波兰表达式求值函数。

**答案：** 使用栈实现逆波兰表达式的求值。

**代码示例：**

```go
package main

import (
    "fmt"
)

func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(s string) int {
    sign := 1
    if s[0] == '-' {
        sign = -1
        s = s[1:]
    }
    result := 0
    for _, c := range s {
        result = result*10 + int(c-'0')
    }
    return result * sign
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    result := evalRPN(tokens)
    fmt.Printf("Result: %d\n", result)
}
```

**解析：** 该代码实现了逆波兰表达式的求值，通过遍历 tokens，使用栈存储和计算结果。

### 14. 合并K个升序链表

**题目：** 合并 K 个升序链表。

**答案：** 使用优先队列（最小堆）实现，每次取出最小节点，将其与下一个节点合并，重新放入队列。

**代码示例：**

```go
package main

import (
    "fmt"
    "container/heap"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

type IntHeap []int

func (h IntHeap) Len() int {
    return len(h)
}

func (h IntHeap) Less(i, j int) bool {
    return h[i] < h[j]
}

func (h IntHeap) Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
}

func (h *IntHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    x := old[len(old)-1]
    *h = old[:len(old)-1]
    return x
}

type Item struct {
    Val    int
    Index  int
    ListNode *ListNode
}

type ListNodeHeap []*Item

func (h ListNodeHeap) Len() int {
    return len(h)
}

func (h ListNodeHeap) Less(i, j int) bool {
    return h[i].Val < h[j].Val
}

func (h ListNodeHeap) Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
    h[i].Index = i
    h[j].Index = j
}

func (h *ListNodeHeap) Push(x interface{}) {
    item := x.(*Item)
    item.Index = len(*h)
    *h = append(*h, item)
}

func (h *ListNodeHeap) Pop() interface{} {
    old := *h
    item := old[len(old)-1]
    *h = old[:len(old)-1]
    return item
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    dummy := &ListNode{}
    curr := dummy
    heap := ListNodeHeap{}
    for _, list := range lists {
        if list != nil {
            heap.Push(&Item{Val: list.Val, ListNode: list, Index: 0})
        }
    }
    heap.Init()
    for heap.Len() > 0 {
        item := heap.Pop().(*Item)
        curr.Next = item.ListNode
        curr = curr.Next
        if item.ListNode.Next != nil {
            heap.Push(&Item{Val: item.ListNode.Next.Val, ListNode: item.ListNode.Next, Index: item.Index + 1})
        }
    }
    return dummy.Next
}

func main() {
    lists := []*ListNode{
        &ListNode{Val: 1, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}},
        &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}},
        &ListNode{Val: 2, Next: &ListNode{Val: 6}},
    }
    result := mergeKLists(lists)
    fmt.Println("Merged list:", result)
}
```

**解析：** 该代码实现了合并 K 个升序链表，使用优先队列（最小堆）来存储和排序链表节点，每次取出最小节点，将其与下一个节点合并，重新放入队列。

### 15. 合并两个有序数组

**题目：** 合并两个有序数组。

**答案：** 使用双指针方法，从两个数组的头部开始比较，将较小的值添加到新数组中。

**代码示例：**

```go
package main

import (
    "fmt"
)

func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := 0, 0, 0
    for i < m && j < n {
        if nums1[i] <= nums2[j] {
            nums1[k] = nums1[i]
            i++
        } else {
            nums1[k] = nums2[j]
            j++
        }
        k++
    }
    for i < m {
        nums1[k] = nums1[i]
        i++
        k++
    }
    for j < n {
        nums1[k] = nums2[j]
        j++
        k++
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    m := 3
    nums2 := []int{2, 5, 6}
    n := 3
    merge(nums1, m, nums2, n)
    fmt.Println("Merged array:", nums1)
}
```

**解析：** 该代码实现了合并两个有序数组，使用双指针方法，从两个数组的头部开始比较，将较小的值添加到新数组中。

### 16. 合并区间 II

**题目：** 合并区间 II。

**答案：** 首先将区间按照结束点排序，然后遍历区间，合并重叠的区间。

**代码示例：**

```go
package main

import (
    "fmt"
    "sort"
)

type Interval struct {
    Start, End int
}

func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][1] < intervals[j][1]
    })
    result := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        last := len(result) - 1
        if intervals[i][0] <= result[last][1] {
            result[last] = []int{result[last][0], max(result[last][1], intervals[i][1])}
        } else {
            result = append(result, intervals[i])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := [][]int{
        {1, 3},
        {2, 6},
        {8, 10},
        {15, 18},
    }
    result := merge(intervals)
    fmt.Println("Merged intervals:", result)
}
```

**解析：** 该代码实现了合并区间 II，首先将区间按照结束点排序，然后遍历区间，合并重叠的区间。

### 17. 最大子序列和

**题目：** 最大子序列和。

**答案：** 使用动态规划方法，维护一个数组`dp`，其中`dp[i]`表示以`nums[i]`结尾的最大子序列和。

**代码示例：**

```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    maxSum := dp[0]
    for i := 1; i < len(nums); i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i])
        maxSum = max(maxSum, dp[i])
    }
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Printf("Maximum subarray sum: %d\n", result)
}
```

**解析：** 该代码实现了最大子序列和，使用动态规划方法，维护一个数组`dp`，其中`dp[i]`表示以`nums[i]`结尾的最大子序列和。遍历数组，更新`dp`数组，并找出最大值。

### 18. 股票买卖

**题目：** 股票买卖。

**答案：** 动态规划方法，维护两个数组`buy`和`sell`，其中`buy[i]`表示到达第i天的最大利润，`sell[i]`表示在第i天卖出的最大利润。

**代码示例：**

```go
package main

import (
    "fmt"
)

func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    buy, sell := -prices[0], 0
    for i := 1; i < len(prices); i++ {
        buy = max(buy, -prices[i])
        sell = max(sell, buy+prices[i])
    }
    return sell
}

func main() {
    prices := []int{3, 3, 5, 0, 0, 3, 1, 4}
    result := maxProfit(prices)
    fmt.Printf("Maximum profit: %d\n", result)
}
```

**解析：** 该代码实现了股票买卖问题，使用动态规划方法，维护两个数组`buy`和`sell`，其中`buy[i]`表示到达第i天的最大利润，`sell[i]`表示在第i天卖出的最大利润。遍历数组，更新`buy`和`sell`数组，并找出最大值。

### 19. 最长公共子序列

**题目：** 最长公共子序列。

**答案：** 动态规划方法，使用一个二维数组`dp`，其中`dp[i][j]`表示`text1[0...i-1]`和`text2[0...j-1]`的最长公共子序列长度。

**代码示例：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    result := longestCommonSubsequence(text1, text2)
    fmt.Printf("Longest common subsequence length: %d\n", result)
}
```

**解析：** 该代码实现了最长公共子序列，使用动态规划方法，使用一个二维数组`dp`，其中`dp[i][j]`表示`text1[0...i-1]`和`text2[0...j-1]`的最长公共子序列长度。遍历字符串，更新`dp`数组，并找出最长公共子序列的长度。

### 20. 最长回文子串

**题目：** 最长回文子串。

**答案：** 使用动态规划方法，使用一个二维数组`dp`，其中`dp[i][j]`表示`s[i...j]`是否为回文串。

**代码示例：**

```go
package main

import (
    "fmt"
)

func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, maxLen := 0, 1
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
    }
    for i := 0; i < n; i++ {
        dp[i][i] = true
    }
    for i := 0; i < n-1; i++ {
        if s[i] == s[i+1] {
            dp[i][i+1] = true
            start = i
            maxLen = 2
        }
    }
    for l := 3; l <= n; l++ {
        for i := 0; i <= n-l; i++ {
            j := i + l - 1
            if s[i] == s[j] && dp[i+1][j-1] {
                dp[i][j] = true
                start = i
                maxLen = l
            }
        }
    }
    return s[start : start+maxLen]
}

func main() {
    s := "babad"
    result := longestPalindrome(s)
    fmt.Printf("Longest palindromic substring: %s\n", result)
}
```

**解析：** 该代码实现了最长回文子串，使用动态规划方法，使用一个二维数组`dp`，其中`dp[i][j]`表示`s[i...j]`是否为回文串。遍历字符串，更新`dp`数组，并找出最长回文子串。

### 21. 逆序对

**题目：** 逆序对。

**答案：** 使用归并排序方法，在合并过程中计算逆序对的数量。

**代码示例：**

```go
package main

import (
    "fmt"
)

func merge(left, right []int) ([]int, int) {
    i, j, k := 0, 0, 0
    result := make([]int, len(left)+len(right))
    count := 0
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result[k] = left[i]
            i++
        } else {
            result[k] = right[j]
            j++
            count += len(left) - i
        }
        k++
    }
    for i < len(left) {
        result[k] = left[i]
        i++
        k++
    }
    for j < len(right) {
        result[k] = right[j]
        j++
        k++
    }
    return result, count
}

func mergeSort(nums []int) ([]int, int) {
    if len(nums) < 2 {
        return nums, 0
    }
    mid := len(nums) / 2
    left, leftCount := mergeSort(nums[:mid])
    right, rightCount := mergeSort(nums[mid:])
    result, mergeCount := merge(left, right)
    return result, leftCount + rightCount + mergeCount
}

func main() {
    nums := []int{7, 5, 6, 4}
    result, count := mergeSort(nums)
    fmt.Printf("Sorted array: %v, Inversion count: %d\n", result, count)
}
```

**解析：** 该代码实现了逆序对的计算，使用归并排序方法，在合并过程中计算逆序对的数量。

### 22. 寻找旋转排序数组中的最小值

**题目：** 寻找旋转排序数组中的最小值。

**答案：** 使用二分查找方法，判断中间元素与边界元素的关系，确定最小值所在区间。

**代码示例：**

```go
package main

import (
    "fmt"
)

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    result := findMin(nums)
    fmt.Printf("Minimum value: %d\n", result)
}
```

**解析：** 该代码实现了寻找旋转排序数组中的最小值，使用二分查找方法，判断中间元素与边界元素的关系，确定最小值所在区间。

### 23. 最长公共前缀

**题目：** 最长公共前缀。

**答案：** 遍历字符串数组，找出最长公共前缀。

**代码示例：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    result := strs[0]
    for _, s := range strs {
        for i, c := range s {
            if i < len(result) && c != result[i] {
                result = result[:i]
                break
            }
        }
    }
    return result
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Printf("Longest common prefix: %s\n", result)
}
```

**解析：** 该代码实现了最长公共前缀，遍历字符串数组，找出最长公共前缀。

### 24. 简化路径

**题目：** 简化路径。

**答案：** 使用栈实现，将路径中的非空目录名添加到栈中，当遇到「..」时，弹出栈顶元素。

**代码示例：**

```go
package main

import (
    "fmt"
)

func simplifyPath(path string) string {
    stack := []string{}
    parts := strings.Split(path, "/")
    for _, part := range parts {
        if part == ".." {
            if len(stack) > 0 {
                stack = stack[:len(stack)-1]
            }
        } else if part != "" {
            stack = append(stack, part)
        }
    }
    result := "/" + strings.Join(stack, "/")
    return result
}

func main() {
    path := "/home/dasda//../dasda/"
    result := simplifyPath(path)
    fmt.Printf("Simplified path: %s\n", result)
}
```

**解析：** 该代码实现了简化路径，使用栈实现，将路径中的非空目录名添加到栈中，当遇到「..」时，弹出栈顶元素。

### 25. 找到旋转排序数组中的最小值 II

**题目：** 找到旋转排序数组中的最小值 II。

**答案：** 使用二分查找方法，判断中间元素与边界元素的关系，确定最小值所在区间。

**代码示例：**

```go
package main

import (
    "fmt"
)

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else if nums[mid] < nums[right] {
            right = mid
        } else {
            right--
        }
    }
    return nums[left]
}

func main() {
    nums := []int{1, 3, 5}
    result := findMin(nums)
    fmt.Printf("Minimum value: %d\n", result)
}
```

**解析：** 该代码实现了找到旋转排序数组中的最小值 II，使用二分查找方法，判断中间元素与边界元素的关系，确定最小值所在区间。

### 26. 寻找两个正序数组的中位数

**题目：** 寻找两个正序数组的中位数。

**答案：** 使用归并排序方法，将两个数组合并并找出中位数。

**代码示例：**

```go
package main

import (
    "fmt"
)

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i < m {
                minRight = nums1[i]
            }
            if j < n {
                minRight = min(minRight, nums2[j])
            }
            return float64(maxLeft+minRight) / 2
        }
    }
    return 0
}

func main() {
    nums1 := []int{1, 2}
    nums2 := []int{3, 4}
    result := findMedianSortedArrays(nums1, nums2)
    fmt.Printf("Median: %f\n", result)
}
```

**解析：** 该代码实现了寻找两个正序数组的中位数，使用归并排序方法，将两个数组合并并找出中位数。

### 27. 两数相加

**题目：** 两数相加。

**答案：** 使用链表实现，将两个链表相加并返回新的链表。

**代码示例：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{2, &ListNode{4, &ListNode{3}}}
    l2 := &ListNode{5, &ListNode{6, &ListNode{4}}}
    result := addTwoNumbers(l1, l2)
    fmt.Println("Result:", result)
}
```

**解析：** 该代码实现了两数相加，使用链表实现，将两个链表相加并返回新的链表。

### 28. 股票买卖 II

**题目：** 股票买卖 II。

**答案：** 使用贪心算法，每次找到上升的起点，买入；找到下降的终点，卖出。

**代码示例：**

```go
package main

import (
    "fmt"
)

func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    prices := []int{7, 1, 5, 3, 6, 4}
    result := maxProfit(prices)
    fmt.Printf("Maximum profit: %d\n", result)
}
```

**解析：** 该代码实现了股票买卖 II，使用贪心算法，每次找到上升的起点，买入；找到下降的终点，卖出。

### 29. 合并两个有序链表

**题目：** 合并两个有序链表。

**答案：** 使用递归或迭代方法，将两个链表合并成一个有序链表。

**代码示例（递归）：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{1, &ListNode{3, &ListNode{5}}}
    l2 := &ListNode{2, &ListNode{4, &ListNode{6}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result)
}
```

**代码示例（迭代）：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{1, &ListNode{3, &ListNode{5}}}
    l2 := &ListNode{2, &ListNode{4, &ListNode{6}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result)
}
```

**解析：** 该代码实现了合并两个有序链表，分别使用递归和迭代方法，将两个链表合并成一个有序链表。

### 30. 爬楼梯 II

**题目：** 爬楼梯 II。

**答案：** 使用动态规划方法，计算到达第n级台阶的方法数。

**代码示例：**

```go
package main

import (
    "fmt"
)

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    dp := make([]int, n+1)
    dp[0], dp[1], dp[2] = 1, 1, 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}

func main() {
    n := 5
    result := climbStairs(n)
    fmt.Printf("Number of ways to climb %d stairs: %d\n", n, result)
}
```

**解析：** 该代码实现了爬楼梯 II，使用动态规划方法，计算到达第n级台阶的方法数。通过迭代更新动态规划数组。

