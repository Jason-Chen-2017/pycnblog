                 

# 京东2025届校招面试高频算法题解析：算法挑战与解题思路

在2025届京东校招面试中，算法题占据了重要地位，这些题目不仅考察了应聘者的编程能力，还考验了对数据结构和算法的深入理解。本文将针对京东2025届校招面试中的一些高频算法题目，提供详细的解题思路和满分答案解析，帮助准备校招的同学们更好地应对挑战。

## 题目一：最长公共子序列（LCS）

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出两个字符串的最长公共子序列。

**解题思路：** 使用动态规划方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列的长度。

**答案解析：**

```go
func longestCommonSubsequence(str1 string, str2 string) int {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 题目二：合并区间

**题目描述：** 给定一个无序的区间列表，合并所有重叠的区间。

**解题思路：** 首先将区间按照起点排序，然后遍历区间列表，合并重叠的区间。

**答案解析：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for _, interval := range intervals[1:] {
        last := len(ans) - 1
        if ans[last][1] >= interval[0] {
            ans[last] = []int{ans[last][0], max(ans[last][1], interval[1])}
        } else {
            ans = append(ans, interval)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 题目三：有效的括号序列

**题目描述：** 给定一个字符串，判断是否是一个有效的括号序列。

**解题思路：** 使用栈来模拟括号匹配，遇到左括号入栈，遇到右括号出栈，并检查栈是否为空。

**答案解析：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || string(stack[len(stack)-1]) != string(char) {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

## 题目四：排序数组中的重复项 II

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，修改数组，使得每个出现的重复项出现的次数不超过 `k`。

**解题思路：** 使用哈希表记录每个数字的出现次数，遍历数组，对于每个数字，如果它的出现次数小于等于 `k`，则将其放入结果数组中，并更新哈希表。

**答案解析：**

```go
func removeDuplicates(nums []int, k int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    j := 0
    count := make(map[int]int)
    for _, num := range nums {
        count[num]++
        if count[num] <= k {
            nums[j] = num
            j++
        }
    }
    return j
}
```

## 题目五：两数相加

**题目描述：** 给定两个非空链表，表示两个非负整数，每个节点包含一个数字，返回这两个数字相加的结果，以链表形式返回。

**解题思路：** 使用链表模拟加法运算，从最低位开始相加，处理进位。

**答案解析：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

## 题目六：寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`，请从两个数组中各选取一个数字，找出这两个数字的中位数。

**解题思路：** 使用二分查找法，在两个数组中寻找一个分割点，使得分割点左右两边的数字和相等。

**答案解析：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i == m {
                minOfRight = nums2[j]
            } else if j == n {
                minOfRight = nums1[i]
            } else {
                minOfRight = min(nums1[i], nums2[j])
            }
            return float64(maxOfLeft+minOfRight) / 2.0
        }
    }
    return 0
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## 题目七：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**解题思路：** 使用垂直扫描法，比较每个字符串的第一个字符，然后递归地比较剩余的前缀。

**答案解析：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for _, v := range strs {
        for len(ans) > 0 && !strings.HasPrefix(v, ans) {
            ans = ans[:len(ans)-1]
        }
    }
    return ans
}
```

## 题目八：整数转换 Roman 数字

**题目描述：** 给定一个整数，将其转换成 Roman 数字。

**解题思路：** 定义一个映射关系，将数字映射到相应的 Roman 数字，然后根据映射关系进行转换。

**答案解析：**

```go
var val = []int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}
var rom = []string{"I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"}
func intToRoman(num int) string {
    ans := ""
    for i := len(val) - 1; i >= 0; i-- {
        for num >= val[i] {
            ans += rom[i]
            num -= val[i]
        }
    }
    return ans
}
```

## 题目九：三角形最小路径和

**题目描述：** 给定一个三角形，找出从顶到底的最小路径和。

**解题思路：** 使用动态规划，从下往上更新每个元素的最小路径和。

**答案解析：**

```go
func minimumTotal(triangle [][]int) int {
    n := len(triangle)
    for i := n - 2; i >= 0; i-- {
        for j := 0; j <= i; j++ {
            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
        }
    }
    return triangle[0][0]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## 题目十：最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**解题思路：** 使用动态规划，遍历数组，维护当前子序列的和，并与前一个子序列的和进行更新。

**答案解析：**

```go
func maxSubArray(nums []int) int {
    ans := nums[0]
    curSum := nums[0]
    for i := 1; i < len(nums); i++ {
        curSum = max(curSum+nums[i], nums[i])
        ans = max(ans, curSum)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 题目十一：最长公共子串

**题目描述：** 给定两个字符串，找出它们的公共最长子串。

**解题思路：** 使用动态规划，创建一个二维数组，记录两个字符串的子串匹配情况。

**答案解析：**

```go
func longestCommonSubstr(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    ans := ""
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if s1[i] == s2[j] {
                if i == 0 || j == 0 {
                    dp[i][j] = 1
                } else {
                    dp[i][j] = dp[i-1][j-1] + 1
                }
                if len(ans) < dp[i][j] {
                    ans = string(s1[i-dp[i][j]+1 : i+1])
                }
            }
        }
    }
    return ans
}
```

## 题目十二：最长公共子数组

**题目描述：** 给定两个整数数组 `nums1` 和 `nums2`，找出它们的公共最长子数组。

**解题思路：** 使用动态规划，创建一个二维数组，记录两个数组的子数组匹配情况。

**答案解析：**

```go
func longestCommonSubarray(nums1 []int, nums2 []int) int {
    m, n := len(nums1), len(nums2)
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if nums1[i] == nums2[j] {
                if i == 0 || j == 0 {
                    dp[i][j] = 1
                } else {
                    dp[i][j] = dp[i-1][j-1] + 1
                }
                if ans < dp[i][j] {
                    ans = dp[i][j]
                }
            }
        }
    }
    return ans
}
```

## 题目十三：环形数组最小插值问题

**题目描述：** 给定一个由整数组成的环形数组 `nums` ，找到给定的整数 `target` 在数组中的下一个插入位置，保证数组中至少有一个位置可以插入该整数，且该位置是最小的。

**解题思路：** 使用二分查找法，找到 `target` 的插入位置。

**答案解析：**

```go
func searchInsert(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return left
}
```

## 题目十四：有序数组的平方

**题目描述：** 给定一个按非递减顺序排序的整数数组 `nums`，请你返回每个数字的平方组成的新数组，且也需要按非递减顺序排序。

**解题思路：** 使用双指针法，从数组的两端开始比较，将较大的平方值放入新数组中。

**答案解析：**

```go
func sortedSquares(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    i, j, k := 0, n-1, n-1
    for i <= j {
        if nums[i]*nums[i] > nums[j]*nums[j] {
            ans[k] = nums[i]*nums[i]
            i++
        } else {
            ans[k] = nums[j]*nums[j]
            j--
        }
        k--
    }
    return ans
}
```

## 题目十五：盛水最多的容器

**题目描述：** 给定一个二进制数组 `height` ，找出其中最大的矩形，其宽度和高度分别为若干连续块的最大值。

**解题思路：** 使用单调栈，遍历数组，计算每个高度对应的最大宽度。

**答案解析：**

```go
func maxArea(height []int) int {
    n := len(height)
    ans := 0
    stack := []int{}
    for i, h := range height {
        for len(stack) > 0 && height[stack[len(stack)-1]] < h {
            j := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                width := i
            } else {
                width := i - stack[len(stack)-1] - 1
            }
            ans = max(ans, width*height[j])
        }
        stack = append(stack, i)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 题目十六：找到二叉树的最近公共祖先

**题目描述：** 给定一个二叉树，找到两个节点 `p` 和 `q` 的最近公共祖先。

**解题思路：** 使用递归，遍历二叉树，返回 `p` 和 `q` 的最近公共祖先。

**答案解析：**

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}
```

## 题目十七：旋转图像

**题目描述：** 给定一个 `n x n` 的二维矩阵 `matrix` ，旋转矩阵 90 度，是否能够变成另一个给定的矩阵 `target` 。

**解题思路：** 首先判断是否能够通过旋转得到目标矩阵，然后分四步进行旋转。

**答案解析：**

```go
func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-1-i][n-1-j] = matrix[n-1-i][n-1-j], matrix[i][j]
        }
    }
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}
```

## 题目十八：最长递增子序列

**题目描述：** 给定一个无序数组，找出其中最长递增子序列的长度。

**解题思路：** 使用动态规划，维护一个数组，记录每个位置的最长递增子序列长度。

**答案解析：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 0; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    ans := 0
    for _, v := range dp {
        ans = max(ans, v)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 题目十九：打家劫舍

**题目描述：** 你是一个贼，想要偷窃沿街排列的房屋。每间房屋装有报警系统，如果两间相邻的房屋在同一天晚上被打劫，系统会自动报警。计算你能偷窃的最大金额。

**解题思路：** 使用动态规划，维护一个数组，记录每个位置的最大偷窃金额。

**答案解析：**

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 题目二十：打家劫舍 II

**题目描述：** 你是一个贼，想要偷窃沿街排列的房屋。每间房屋装有报警系统，如果两间相邻的房屋在同一天晚上被打劫，系统会自动报警。给定一个非空数组，代表每间房屋的金额，计算你能偷窃的最大金额，但你需要考虑整个房屋序列而非单
```go
# 京东2025届校招面试高频算法题解析

在京东2025届校招面试中，算法题占据了重要地位。这些题目不仅考察了应聘者的编程能力，还考验了对数据结构和算法的深入理解。本文将针对京东2025届校招面试中的一些高频算法题目，提供详细的解题思路和满分答案解析，帮助准备校招的同学们更好地应对挑战。

### 题目一：最长公共子序列（LCS）

**题目描述：** 给定两个字符串 `str1` 和 `str2`，找出两个字符串的最长公共子序列。

**解题思路：** 使用动态规划方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列的长度。

**答案解析：**

```go
func longestCommonSubsequence(str1 string, str2 string) int {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目二：合并区间

**题目描述：** 给定一个无序的区间列表，合并所有重叠的区间。

**解题思路：** 首先将区间按照起点排序，然后遍历区间列表，合并重叠的区间。

**答案解析：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for _, interval := range intervals[1:] {
        last := len(ans) - 1
        if ans[last][1] >= interval[0] {
            ans[last] = []int{ans[last][0], max(ans[last][1], interval[1])}
        } else {
            ans = append(ans, interval)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目三：有效的括号序列

**题目描述：** 给定一个字符串，判断是否是一个有效的括号序列。

**解题思路：** 使用栈来模拟括号匹配，遇到左括号入栈，遇到右括号出栈，并检查栈是否为空。

**答案解析：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || string(stack[len(stack)-1]) != string(char) {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

### 题目四：排序数组中的重复项 II

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，修改数组，使得每个出现的重复项出现的次数不超过 `k`。

**解题思路：** 使用哈希表记录每个数字的出现次数，遍历数组，对于每个数字，如果它的出现次数小于等于 `k`，则将其放入结果数组中，并更新哈希表。

**答案解析：**

```go
func removeDuplicates(nums []int, k int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    j := 0
    count := make(map[int]int)
    for _, num := range nums {
        count[num]++
        if count[num] <= k {
            nums[j] = num
            j++
        }
    }
    return j
}
```

### 题目五：两数相加

**题目描述：** 给定两个非空链表，表示两个非负整数，每个节点包含一个数字，返回这两个数字相加的结果，以链表形式返回。

**解题思路：** 使用链表模拟加法运算，从最低位开始相加，处理进位。

**答案解析：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

### 题目六：寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`，请从两个数组中各选取一个数字，找出这两个数字的中位数。

**解题思路：** 使用二分查找法，在两个数组中寻找一个分割点，使得分割点左右两边的数字和相等。

**答案解析：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i == m {
                minOfRight = nums2[j]
            } else if j == n {
                minOfRight = nums1[i]
            } else {
                minOfRight = min(nums1[i], nums2[j])
            }
            return float64(maxOfLeft+minOfRight) / 2.0
        }
    }
    return 0
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 题目七：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**解题思路：** 使用垂直扫描法，比较每个字符串的第一个字符，然后递归地比较剩余的前缀。

**答案解析：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for _, v := range strs {
        for len(ans) > 0 && !strings.HasPrefix(v, ans) {
            ans = ans[:len(ans)-1]
        }
    }
    return ans
}
```

### 题目八：整数转换 Roman 数字

**题目描述：** 给定一个整数，将其转换成 Roman 数字。

**解题思路：** 定义一个映射关系，将数字映射到相应的 Roman 数字，然后根据映射关系进行转换。

**答案解析：**

```go
var val = []int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000}
var rom = []string{"I", "IV", "V", "IX", "X", "XL", "L", "XC", "C", "CD", "D", "CM", "M"}
func intToRoman(num int) string {
    ans := ""
    for i := len(val) - 1; i >= 0; i-- {
        for num >= val[i] {
            ans += rom[i]
            num -= val[i]
        }
    }
    return ans
}
```

### 题目九：三角形最小路径和

**题目描述：** 给定一个三角形，找出从顶到底的最小路径和。

**解题思路：** 使用动态规划，从下往上更新每个元素的最小路径和。

**答案解析：**

```go
func minimumTotal(triangle [][]int) int {
    n := len(triangle)
    for i := n - 2; i >= 0; i-- {
        for j := 0; j <= i; j++ {
            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1])
        }
    }
    return triangle[0][0]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 题目十：最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**解题思路：** 使用动态规划，遍历数组，维护当前子序列的和，并与前一个子序列的和进行更新。

**答案解析：**

```go
func maxSubArray(nums []int) int {
    ans := nums[0]
    curSum := nums[0]
    for i := 1; i < len(nums); i++ {
        curSum = max(curSum+nums[i], nums[i])
        ans = max(ans, curSum)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目十一：最长公共子串

**题目描述：** 给定两个字符串，找出它们的公共最长子串。

**解题思路：** 使用动态规划，创建一个二维数组，记录两个字符串的子串匹配情况。

**答案解析：**

```go
func longestCommonSubstr(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    ans := ""
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if s1[i] == s2[j] {
                if i == 0 || j == 0 {
                    dp[i][j] = 1
                } else {
                    dp[i][j] = dp[i-1][j-1] + 1
                }
                if len(ans) < dp[i][j] {
                    ans = string(s1[i-dp[i][j]+1 : i+1])
                }
            }
        }
    }
    return ans
}
```

### 题目十二：最长公共子数组

**题目描述：** 给定两个整数数组 `nums1` 和 `nums2`，找出它们的公共最长子数组。

**解题思路：** 使用动态规划，创建一个二维数组，记录两个数组的子数组匹配情况。

**答案解析：**

```go
func longestCommonSubarray(nums1 []int, nums2 []int) int {
    m, n := len(nums1), len(nums2)
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if nums1[i] == nums2[j] {
                if i == 0 || j == 0 {
                    dp[i][j] = 1
                } else {
                    dp[i][j] = dp[i-1][j-1] + 1
                }
                if ans < dp[i][j] {
                    ans = dp[i][j]
                }
            }
        }
    }
    return ans
}
```

### 题目十三：环形数组最小插值问题

**题目描述：** 给定一个由整数组成的环形数组 `nums` ，找到给定的整数 `target` 在数组中的下一个插值位置，保证数组中至少有一个位置可以插入该整数，且该位置是最小的。

**解题思路：** 使用二分查找法，找到 `target` 的插值位置。

**答案解析：**

```go
func searchInsert(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] > target {
            right = mid - 1
        } else {
            left = mid + 1
        }
    }
    return left
}
```

### 题目十四：有序数组的平方

**题目描述：** 给定一个按非递减顺序排序的整数数组 `nums` ，请你返回每个数字的平方组成的新数组，且也需要按非递减顺序排序。

**解题思路：** 使用双指针法，从数组的两端开始比较，将较大的平方值放入新数组中。

**答案解析：**

```go
func sortedSquares(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    i, j, k := 0, n-1, n-1
    for i <= j {
        if nums[i]*nums[i] > nums[j]*nums[j] {
            ans[k] = nums[i]*nums[i]
            i++
        } else {
            ans[k] = nums[j]*nums[j]
            j--
        }
        k--
    }
    return ans
}
```

### 题目十五：盛水最多的容器

**题目描述：** 给定一个二进制数组 `height` ，找出其中最大的矩形，其宽度和高度分别为若干连续块的最大值。

**解题思路：** 使用单调栈，遍历数组，计算每个高度对应的最大宽度。

**答案解析：**

```go
func maxArea(height []int) int {
    n := len(height)
    ans := 0
    stack := []int{}
    for i, h := range height {
        for len(stack) > 0 && height[stack[len(stack)-1]] < h {
            j := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                width := i
            } else {
                width := i - stack[len(stack)-1] - 1
            }
            ans = max(ans, width*height[j])
        }
        stack = append(stack, i)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目十六：找到二叉树的最近公共祖先

**题目描述：** 给定一个二叉树，找到两个节点 `p` 和 `q` 的最近公共祖先。

**解题思路：** 使用递归，遍历二叉树，返回 `p` 和 `q` 的最近公共祖先。

**答案解析：**

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}
```

### 题目十七：旋转图像

**题目描述：** 给定一个二维矩阵 `matrix` ，你需要将矩阵顺时针旋转 90 度。

**解题思路：** 首先，将矩阵沿着主对角线进行翻转，然后沿垂直方向翻转。

**答案解析：**

```go
func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-1-i][n-1-j] = matrix[n-1-i][n-1-j], matrix[i][j]
        }
    }
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}
```

### 题目十八：最长递增子序列

**题目描述：** 给定一个无序数组，找出其中最长递增子序列的长度。

**解题思路：** 使用动态规划，维护一个数组，记录每个位置的最长递增子序列长度。

**答案解析：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 0; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    ans := 0
    for _, v := range dp {
        ans = max(ans, v)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目十九：打家劫舍

**题目描述：** 你是一个贼，想要偷窃沿街排列的房屋。每间房屋装有报警系统，如果两间相邻的房屋在同一天晚上被打劫，系统会自动报警。计算你能偷窃的最大金额。

**解题思路：** 使用动态规划，维护一个数组，记录每个位置的最大偷窃金额。

**答案解析：**

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目二十：打家劫舍 II

**题目描述：** 你是一个贼，想要偷窃沿街排列的房屋。每间房屋装有报警系统，如果两间相邻的房屋在同一天晚上被打劫，系统会自动报警。给定一个非空数组，代表每间房屋的金额，计算你能偷窃的最大金额，但你需要考虑整个房屋序列而非单个房屋。

**解题思路：** 分为两种情况讨论，如果包含最后一个房屋，则第一个房屋不能打劫；如果不包含最后一个房屋，则第一个房屋可以打劫。

**答案解析：**

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[n-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 总结

以上是京东2025届校招面试中的一些高频算法题的解题思路和答案解析。这些题目涵盖了从基础到进阶的不同难度，通过解决这些题目，可以帮助你在校招面试中更好地展现自己的算法能力和编程技巧。希望本文对你有所帮助，祝你校招顺利！

