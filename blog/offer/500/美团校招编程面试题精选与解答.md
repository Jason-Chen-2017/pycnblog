                 

### 美团2025校招编程面试题精选与解答

#### 1. 平衡二叉树的判断

**题目：** 编写一个函数，判断一棵二叉树是否是平衡二叉树。

**思路：** 使用递归遍历二叉树，计算每个节点的左右子树的高度差，如果任意一个节点的高度差大于1，则该二叉树不是平衡二叉树。

**代码：**

```go
package main

import "fmt"

// TreeNode 定义二叉树的节点
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// getHeight 获取节点的高度
func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    leftHeight := getHeight(node.Left)
    rightHeight := getHeight(node.Right)
    if abs(leftHeight-rightHeight) > 1 {
        return -1
    }
    return max(leftHeight, rightHeight) + 1
}

// max 获取最大值
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// abs 计算绝对值
func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}

// isBalanced 判断是否为平衡二叉树
func isBalanced(root *TreeNode) bool {
    if getHeight(root) == -1 {
        return false
    }
    return true
}

func main() {
    // 创建一棵二叉树
    root := &TreeNode{Val: 1}
    root.Left = &TreeNode{Val: 2}
    root.Right = &TreeNode{Val: 3}
    root.Left.Left = &TreeNode{Val: 4}
    root.Left.Right = &TreeNode{Val: 5}
    root.Right.Right = &TreeNode{Val: 6}

    if isBalanced(root) {
        fmt.Println("是平衡二叉树")
    } else {
        fmt.Println("不是平衡二叉树")
    }
}
```

**解析：** 该函数通过递归遍历每个节点，计算左右子树的高度差，如果任意一个节点的高度差大于1，则返回`false`，表示不是平衡二叉树。否则，返回`true`。

#### 2. 两数相加

**题目：** 给定两个非空链表表示的两个非负整数，分别位于链表的首部，每个节点包含一个数字。请计算这两个数字表示的整数之和，并以链表形式返回结果。

**思路：** 将两个链表按位对齐，从最低位开始相加，并处理进位。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// addTwoNumbers 相加两个链表
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10}
        current = current.Next
    }

    return dummy.Next
}

func main() {
    // 创建链表1
    l1 := &ListNode{Val: 2}
    l1.Next = &ListNode{Val: 4}
    l1.Next.Next = &ListNode{Val: 3}

    // 创建链表2
    l2 := &ListNode{Val: 5}
    l2.Next = &ListNode{Val: 6}
    l2.Next.Next = &ListNode{Val: 4}

    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数将两个链表按位对齐，从最低位开始相加，并处理进位。最终返回一个新的链表，表示两个链表所表示的整数之和。

#### 3. 两个有序数组的合并

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

**思路：** 从数组尾部开始比较，将较大的元素依次放入 num1 的尾部。

**代码：**

```go
package main

import "fmt"

// merge 排序合并两个有序数组
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    p := m + n - 1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    for p2 >= 0 {
        nums1[p] = nums2[p2]
        p2--
        p--
    }
}

func main() {
    nums1 := []int{1, 2, 3, 0, 0, 0}
    nums2 := []int{2, 5, 6}
    merge(nums1, 3, nums2, 3)
    fmt.Println(nums1)
}
```

**解析：** 该函数从数组尾部开始比较，将较大的元素依次放入 num1 的尾部。在处理完两个数组后，如果 num2 还有剩余元素，则直接将其填充到 num1 的剩余位置。

#### 4. 找到数组中的重复元素

**题目：** 在一个长度为 n 的数组 nums 里的所有数字都在 0 到 n-1 的范围内，找出数组中任意一个重复的数字。

**思路：** 利用数组下标与数组元素值对应关系，将数组元素值调整到其对应的下标位置，通过遍历判断是否出现不符合条件的元素。

**代码：**

```go
package main

import "fmt"

// findRepeatNumber 在一个长度为 n 的数组 nums 里的所有数字都在 0 到 n-1 的范围内，找出任意一个重复的数字
func findRepeatNumber(nums []int) int {
    n := len(nums)
    for i := 0; i < n; i++ {
        for nums[i] != i {
            if nums[i] == nums[n] {
                return nums[i]
            }
            t := nums[i]
            nums[i] = nums[t]
            nums[t] = t
        }
    }
    return -1
}

func main() {
    nums := []int{2, 3, 1, 0, 2, 5, 3}
    result := findRepeatNumber(nums)
    fmt.Println(result)
}
```

**解析：** 该函数通过将数组元素值调整到其对应的下标位置，利用哈希表统计每个数字出现的次数。如果出现不符合条件的元素，即下标与值不匹配的情况，则说明找到重复的数字。

#### 5. 求最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。

**思路：** 动态规划，用`dp[i]`表示以`nums[i]`结尾的最大子序和，`dp[i]`可以通过`nums[i]`和`dp[i-1]`计算得到，即`dp[i] = max(dp[i-1] + nums[i], nums[i])`。

**代码：**

```go
package main

import "fmt"

// maxSubArray 求最大子序和
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    dp := nums[0]
    for i := 1; i < len(nums); i++ {
        dp = max(dp+nums[i], nums[i])
        maxSum = max(maxSum, dp)
    }
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println(result)
}
```

**解析：** 该函数通过动态规划的方法，遍历数组计算以每个元素结尾的最大子序和，更新最大值。最终返回整个数组的最大子序和。

#### 6. 二进制中 1 的个数

**题目：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**思路：** 使用位操作，不断右移整数，统计移位过程中遇到1的次数。

**代码：**

```go
package main

import "fmt"

// hammingWeight 返回二进制中 1 的个数
func hammingWeight(num uint) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}

func main() {
    num := uint(11)
    result := hammingWeight(num)
    fmt.Println(result)
}
```

**解析：** 该函数通过位操作，不断右移整数，每次操作后将当前位与0做与运算，统计移位过程中遇到1的次数。`num & (num - 1)`的操作可以将当前位设置为0。

#### 7. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**思路：** 使用快慢指针，快指针每次走两步，慢指针每次走一步。如果快慢指针相遇，则链表中存在环。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// hasCycle 判断链表中是否有环
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    // 创建环形链表
    head := &ListNode{Val: 3}
    head.Next = &ListNode{Val: 2}
    tail := &ListNode{Val: 0}
    head.Next.Next = tail
    tail.Next = &ListNode{Val: -4}
    tail.Next.Next = head

    result := hasCycle(head)
    fmt.Println(result)
}
```

**解析：** 该函数使用快慢指针，快指针每次走两步，慢指针每次走一步。如果快慢指针相遇，则链表中存在环。否则，链表中不存在环。

#### 8. 验证二叉树

**题目：** 编写一个函数，验证一棵二叉树是否为有效的二叉搜索树。

**思路：** 使用中序遍历，判断遍历结果是否为升序排列。

**代码：**

```go
package main

import "fmt"

// TreeNode 定义二叉树的节点
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// isValidBST 验证一棵二叉树是否为有效的二叉搜索树
func isValidBST(root *TreeNode) bool {
    var stack []*TreeNode
    last := &TreeNode{}
    for root != nil || len(stack) > 0 {
        for root != nil {
            stack = append(stack, root)
            root = root.Left
        }
        root = stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        if root.Val <= last.Val {
            return false
        }
        last = root
        root = root.Right
    }
    return true
}

func main() {
    // 创建一棵有效的二叉搜索树
    root := &TreeNode{Val: 2}
    root.Left = &TreeNode{Val: 1}
    root.Right = &TreeNode{Val: 3}

    result := isValidBST(root)
    fmt.Println(result)
}
```

**解析：** 该函数使用中序遍历，判断遍历结果是否为升序排列。如果出现降序排列，则返回`false`，表示该二叉树不是有效的二叉搜索树。

#### 9. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**思路：** 使用两个指针分别指向两个链表的头节点，比较两个指针指向的节点值，将较小的节点添加到新链表中，并移动相应的指针。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// mergeTwoLists 合并两个有序链表
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    // 创建两个有序链表
    l1 := &ListNode{Val: 1}
    l1.Next = &ListNode{Val: 3}
    l1.Next.Next = &ListNode{Val: 5}

    l2 := &ListNode{Val: 2}
    l2.Next = &ListNode{Val: 4}
    l2.Next.Next = &ListNode{Val: 6}

    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数使用两个指针分别指向两个链表的头节点，比较两个指针指向的节点值，将较小的节点添加到新链表中，并移动相应的指针。最终返回合并后的有序链表。

#### 10. 两数相加 II

**题目：** 给定两个非空链表表示的两个非负整数，分别位于链表的首部，每个节点包含一个数字。请计算这两个数字表示的整数之和，并以链表形式返回结果。

**思路：** 将两个链表逆序，然后使用上一题的方法进行相加，最后再将结果链表逆序。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// reverse 反转链表
func reverse(head *ListNode) *ListNode {
    var prev, curr *ListNode
    curr = head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}

// addTwoNumbers 相加两个链表
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    l1 = reverse(l1)
    l2 = reverse(l2)

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10}
        current = current.Next
    }

    return reverse(dummy.Next)
}

func main() {
    // 创建链表1
    l1 := &ListNode{Val: 9}
    l1.Next = &ListNode{Val: 9}
    l1.Next.Next = &ListNode{Val: 1}

    // 创建链表2
    l2 := &ListNode{Val: 1}
    l2.Next = &ListNode{Val: 9}
    l2.Next.Next = &ListNode{Val: 9}

    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数首先将两个链表反转，然后使用上一题的`addTwoNumbers`函数进行相加，最后将结果链表反转。这样可以得到两个链表表示的整数之和。

#### 11. 删除链表的节点

**题目：** 给定一个单链表的头节点 `head` 和一个整数 `val`，删除链表中所有值为 `val` 的节点。

**思路：** 使用虚拟头节点，遍历链表，删除所有值为 `val` 的节点。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// deleteNode 删除链表中所有值为 val 的节点
func deleteNode(head *ListNode, val int) *ListNode {
    dummy := &ListNode{Val: 0}
    dummy.Next = head
    prev, curr := dummy, head
    for curr != nil {
        if curr.Val == val {
            prev.Next = curr.Next
        } else {
            prev = curr
        }
        curr = curr.Next
    }
    return dummy.Next
}

func main() {
    // 创建链表
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next = &ListNode{Val: 5}

    result := deleteNode(head, 3)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数使用虚拟头节点，遍历链表，删除所有值为 `val` 的节点。通过 `prev` 和 `curr` 指针的移动，将不需要的节点从链表中移除。

#### 12. 二进制求和

**题目：** 给你两个二进制字符串，返回它们的和（用二进制表示）。

**思路：** 将两个二进制字符串转换为整数，然后进行求和，最后将结果转换为二进制字符串。

**代码：**

```go
package main

import (
    "fmt"
    "strconv"
)

// getSum 二进制求和
func getSum(a string, b string) string {
    i, j := 0, 0
    for i < len(a) && a[i] == '0' {
        i++
    }
    for j < len(b) && b[j] == '0' {
        j++
    }
    if i >= len(a) {
        return b[j:]
    }
    if j >= len(b) {
        return a[i:]
    }
    sign := 0
    if a[i] == '1' && b[j] == '1' {
        sign = 2
    }
    carry := 0
    result := make([]byte, 0)
    for i >= 0 && j >= 0 {
        sum := int(a[i]-'0') + int(b[j]-'0') + sign
        if sum >= 2 {
            sum -= 2
            carry = 1
        } else {
            carry = 0
        }
        result = append(result, byte(sum+'0'))
        i--
        j--
    }
    if carry == 1 {
        result = append(result, '1')
    }
    if len(result) == 0 {
        result = append(result, '0')
    }
    return reverseString(string(result))
}

// reverseString 反转字符串
func reverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func main() {
    a := "1010"
    b := "1101"
    result := getSum(a, b)
    fmt.Println(result)
}
```

**解析：** 该函数首先去除两个二进制字符串开头的0，然后从后向前遍历，进行逐位求和，并处理进位。最后，将结果反转得到最终的二进制和。

#### 13. 旋转数组的最小值

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出并返回数组中的最小元素。

**思路：** 使用二分查找，找到旋转点的位置，旋转点的左侧即为最小值。

**代码：**

```go
package main

import "fmt"

// findMinValue 旋转数组的最小值
func findMinValue(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    result := findMinValue(nums)
    fmt.Println(result)
}
```

**解析：** 该函数使用二分查找，找到旋转点的位置。由于数组是升序排列的，旋转点的左侧即为最小值。

#### 14. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**思路：** 分治法，每次取中间的字符串与前后字符串进行比较，逐渐缩小查找范围。

**代码：**

```go
package main

import "fmt"

// longestCommonPrefix 查找字符串数组中的最长公共前缀
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    left, right := 0, len(strs[0])
    for i := 1; i < len(strs); i++ {
        if right > len(strs[i]) {
            right = len(strs[i])
        }
        for j := 0; j < right; j++ {
            if strs[0][j] != strs[i][j] {
                right = j
                break
            }
        }
    }
    return strs[0][:right]
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println(result)
}
```

**解析：** 该函数使用分治法，每次取中间的字符串与前后字符串进行比较，逐渐缩小查找范围。最终得到最长公共前缀。

#### 15. 三数之和

**题目：** 给定一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**思路：** 对数组进行排序，然后使用双指针遍历数组，对于每个元素，分别使用两个指针指向其右侧的两个元素，判断三数之和是否等于0。

**代码：**

```go
package main

import "fmt"

// threeSum 三数之和
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var triples [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    result := threeSum(nums)
    fmt.Println(result)
}
```

**解析：** 该函数对数组进行排序，然后使用双指针遍历数组，对于每个元素，分别使用两个指针指向其右侧的两个元素，判断三数之和是否等于0。如果找到满足条件的三元组，则将其添加到结果列表中。

#### 16. 盒子翻转

**题目：** 给定一系列的盒子，每个盒子都有一个高度 `h`，你想要将所有的盒子堆叠在一起，使得每层的高度都是 `k` 的倍数。每层至少要有一个盒子。

**思路：** 将盒子按照高度排序，然后从最高层开始堆叠，每层选择一个盒子作为该层的基础，并使其高度为 `k` 的倍数，剩余的盒子按照高度从小到大堆叠。

**代码：**

```go
package main

import "fmt"

// canPlaceBoxes 盒子翻转
func canPlaceBoxes(h []int, k int) bool {
    sort.Ints(h)
    layer := 0
    for i := 0; i < len(h); i++ {
        if h[i] > layer {
            layer += k
        }
        layer -= h[i]
        if layer < 0 {
            return false
        }
    }
    return true
}

func main() {
    h := []int{4, 3, 2, 1}
    k := 3
    result := canPlaceBoxes(h, k)
    fmt.Println(result)
}
```

**解析：** 该函数将盒子按照高度排序，然后从最高层开始堆叠，每层选择一个盒子作为该层的基础，并使其高度为 `k` 的倍数，剩余的盒子按照高度从小到大堆叠。如果能够将所有的盒子堆叠在一起，则返回 `true`。

#### 17. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**思路：** 使用两个指针分别指向两个链表的头节点，比较两个指针指向的节点值，将较小的节点添加到新链表中，并移动相应的指针。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// mergeTwoLists 合并两个有序链表
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    // 创建两个有序链表
    l1 := &ListNode{Val: 1}
    l1.Next = &ListNode{Val: 2}
    l1.Next.Next = &ListNode{Val: 4}

    l2 := &ListNode{Val: 1}
    l2.Next = &ListNode{Val: 3}
    l2.Next.Next = &ListNode{Val: 4}

    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数使用两个指针分别指向两个链表的头节点，比较两个指针指向的节点值，将较小的节点添加到新链表中，并移动相应的指针。最终返回合并后的有序链表。

#### 18. 有效的括号

**题目：** 给定一个字符串 `s` ，判断 `s` 是否为有效的括号字符串，并且可以无限重复使用括号。

**思路：** 使用栈，遍历字符串，遇到左括号入栈，遇到右括号出栈，并判断栈是否为空。

**代码：**

```go
package main

import "fmt"

// isValid 有效括号字符串
func isValid(s string) bool {
    stack := []rune{}
    for _, v := range s {
        switch v {
        case '(':
            stack = append(stack, v)
        case ')':
            if len(stack) == 0 {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}

func main() {
    s := "()()"
    result := isValid(s)
    fmt.Println(result)
}
```

**解析：** 该函数使用栈，遍历字符串，遇到左括号入栈，遇到右括号出栈，并判断栈是否为空。如果遍历结束后栈为空，则字符串为有效的括号字符串。

#### 19. 股票买卖

**题目：** 给定一个数组 `prices`，其中每个元素代表某一天的股票价格。假设你最多只能完成两笔交易，设计一个算法找出最大利润。

**思路：** 第一笔交易从数组头部开始，第二笔交易从数组尾部开始，分别计算每次交易的利润。

**代码：**

```go
package main

import "fmt"

// maxProfit 股票买卖最大利润
func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    prices := []int{7, 1, 5, 3, 6, 4}
    result := maxProfit(prices)
    fmt.Println(result)
}
```

**解析：** 该函数遍历数组，计算每次股票价格上涨的利润，并将其累加到总利润中。最终返回最大利润。

#### 20. 字符串相乘

**题目：** 给定两个字符串表示的非负整数 `num1` 和 `num2`，返回它们的乘积。

**思路：** 将字符串转换为整数，然后进行乘法运算，最后将结果转换为字符串。

**代码：**

```go
package main

import (
    "fmt"
    "strconv"
)

// multiplyString 字符串相乘
func multiplyString(num1 string, num2 string) string {
    i, j := 0, 0
    for i < len(num1) && num1[i] == '0' {
        i++
    }
    for j < len(num2) && num2[j] == '0' {
        j++
    }
    if i == len(num1) && j == len(num2) {
        return "0"
    }
    m, n := len(num1)-i, len(num2)-j
    result := make([]int, m+n)
    for i < len(num1) {
        result[0] += int(num1[i]-'0') * int(num2[0]-'0')
        i++
    }
    for j < len(num2) {
        result[j] += int(num1[0]-'0') * int(num2[j]-'0')
        j++
    }
    for i, j := 1, 0; i < len(result); i++ {
        carry := result[i] / 10
        result[i] %= 10
        if j < len(result) {
            result[j] += carry
        }
        j++
    }
    for i, j := len(result)-1, 0; i >= 0; i, j = i-1, j+1 {
        if j >= 0 {
            result[j] += int(num1[i]-'0') * int(num2[len(num2)-1]-'0')
        }
        if j >= 0 {
            carry := result[j] / 10
            result[j] %= 10
            if i-1 >= 0 {
                result[i-1] += carry
            }
        }
        i--
    }
    for i, j := len(result)-1, 0; i >= 0 && result[i] == 0; i-- {
        j++
    }
    if j == len(result) {
        return "0"
    }
    return string(result[j:])
}

func main() {
    num1 := "123"
    num2 := "456"
    result := multiplyString(num1, num2)
    fmt.Println(result)
}
```

**解析：** 该函数首先去除字符串开头的0，然后计算两个字符串表示的整数的乘积，并将结果转换为字符串。该函数使用了竖式乘法的方法进行计算。

#### 21. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**思路：** 使用二分查找，找到目标值的插入位置。

**代码：**

```go
package main

import "fmt"

// searchInsert 搜索插入位置
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}

func main() {
    nums := []int{1, 3, 5, 6}
    target := 5
    result := searchInsert(nums, target)
    fmt.Println(result)
}
```

**解析：** 该函数使用二分查找，找到目标值的插入位置。如果目标值不存在于数组中，则返回其将会被按顺序插入的位置。

#### 22. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**思路：** 动态规划，使用一个变量记录当前子序列的和，如果当前子序列的和小于0，则重置为0。

**代码：**

```go
package main

import "fmt"

// maxSubArray 最大子序和
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println(result)
}
```

**解析：** 该函数使用动态规划的方法，遍历数组计算以每个元素结尾的最大子序和，更新最大值。最终返回整个数组的最大子序和。

#### 23. 寻找峰值

**题目：** 给定一个整数数组 `nums` ，找到一个峰值元素，它是指一个元素，其值严格大于左右相邻的元素。

**思路：** 使用二分查找，找到峰值元素。

**代码：**

```go
package main

import "fmt"

// findPeakElement 寻找峰值
func findPeakElement(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[mid+1] {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}

func main() {
    nums := []int{1, 2, 3, 1}
    result := findPeakElement(nums)
    fmt.Println(result)
}
```

**解析：** 该函数使用二分查找，找到峰值元素。由于数组中存在严格递增的子序列，因此可以通过比较中间元素与其右侧相邻元素的大小关系，不断缩小查找范围。

#### 24. 三数之和

**题目：** 给定一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**思路：** 对数组进行排序，然后使用双指针遍历数组，对于每个元素，分别使用两个指针指向其右侧的两个元素，判断三数之和是否等于0。

**代码：**

```go
package main

import "fmt"

// threeSum 三数之和
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var triples [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    result := threeSum(nums)
    fmt.Println(result)
}
```

**解析：** 该函数对数组进行排序，然后使用双指针遍历数组，对于每个元素，分别使用两个指针指向其右侧的两个元素，判断三数之和是否等于0。如果找到满足条件的三元组，则将其添加到结果列表中。

#### 25. 有效的山形数组

**题目：** 给定一个整数数组 `arr` ，返回 `arr` 中山的数目。

**思路：** 遍历数组，找到上升子序列和下降子序列，计算山的数目。

**代码：**

```go
package main

import "fmt"

// peakIndexInMountainArray 有效的山形数组
func peakIndexInMountainArray(arr []int) int {
    left, right := 0, len(arr)-1
    for left < right {
        mid := (left + right) / 2
        if arr[mid] < arr[mid+1] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}

func main() {
    arr := []int{0, 10, 5, 2, 20}
    result := peakIndexInMountainArray(arr)
    fmt.Println(result)
}
```

**解析：** 该函数使用二分查找，找到山形数组的顶峰位置。由于数组中存在严格递增的子序列，因此可以通过比较中间元素与其右侧相邻元素的大小关系，不断缩小查找范围。顶峰位置即为山的数目。

#### 26. 删除链表的节点

**题目：** 给定一个单链表的头节点 `head` 和一个整数 `val`，删除链表中所有值为 `val` 的节点。

**思路：** 使用虚拟头节点，遍历链表，删除所有值为 `val` 的节点。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// deleteNode 删除链表中所有值为 val 的节点
func deleteNode(head *ListNode, val int) *ListNode {
    dummy := &ListNode{Val: 0}
    dummy.Next = head
    prev, curr := dummy, head
    for curr != nil {
        if curr.Val == val {
            prev.Next = curr.Next
        } else {
            prev = curr
        }
        curr = curr.Next
    }
    return dummy.Next
}

func main() {
    // 创建链表
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next = &ListNode{Val: 5}

    result := deleteNode(head, 3)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数使用虚拟头节点，遍历链表，删除所有值为 `val` 的节点。通过 `prev` 和 `curr` 指针的移动，将不需要的节点从链表中移除。

#### 27. 股票买卖 II

**题目：** 给定一个数组 `prices` ，其中每个元素代表了该时间点的股票价格。设计一个算法能够计算最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**思路：** 遍历数组，当价格上升时，买入股票；当价格下降时，卖出股票，并计算利润。

**代码：**

```go
package main

import "fmt"

// maxProfit 股票买卖 II
func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}

func main() {
    prices := []int{7, 1, 5, 3, 6, 4}
    result := maxProfit(prices)
    fmt.Println(result)
}
```

**解析：** 该函数遍历数组，当价格上升时，买入股票；当价格下降时，卖出股票，并计算利润。最终返回最大利润。

#### 28. 有效的山形数组

**题目：** 给定一个整数数组 `arr` ，返回 `arr` 中山的数目。

**思路：** 遍历数组，找到上升子序列和下降子序列，计算山的数目。

**代码：**

```go
package main

import "fmt"

// peakIndexInMountainArray 有效的山形数组
func peakIndexInMountainArray(arr []int) int {
    left, right := 0, len(arr)-1
    for left < right {
        mid := (left + right) / 2
        if arr[mid] < arr[mid+1] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}

func main() {
    arr := []int{0, 10, 5, 2, 20}
    result := peakIndexInMountainArray(arr)
    fmt.Println(result)
}
```

**解析：** 该函数使用二分查找，找到山形数组的顶峰位置。由于数组中存在严格递增的子序列，因此可以通过比较中间元素与其右侧相邻元素的大小关系，不断缩小查找范围。顶峰位置即为山的数目。

#### 29. 翻转链表

**题目：** 编写一个函数，反转一个单链表。

**思路：** 使用头插法，遍历原链表，将每个节点插入到新链表的开头。

**代码：**

```go
package main

import "fmt"

// ListNode 定义链表节点
type ListNode struct {
    Val  int
    Next *ListNode
}

// reverseList 翻转链表
func reverseList(head *ListNode) *ListNode {
    var newHead *ListNode
    for head != nil {
        nextTemp := head.Next
        head.Next = newHead
        newHead = head
        head = nextTemp
    }
    return newHead
}

func main() {
    // 创建链表
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}

    result := reverseList(head)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
    fmt.Println()
}
```

**解析：** 该函数使用头插法，遍历原链表，将每个节点插入到新链表的开头。最终返回翻转后的链表。

#### 30. 分割等和子集

**题目：** 给定一个整数数组 `nums` ，判断是否存在分割，使得分割后的两个子集的元素和相等。

**思路：** 使用动态规划，判断是否存在分割使得两个子集的元素和相等。

**代码：**

```go
package main

import "fmt"

// canPartition 判断是否存在分割使得两个子集的元素和相等
func canPartition(nums []int) bool {
    totalSum := 0
    for _, v := range nums {
        totalSum += v
    }
    if totalSum%2 != 0 {
        return false
    }
    targetSum := totalSum / 2
    dp := make([]bool, targetSum+1)
    dp[0] = true
    for _, v := range nums {
        for j := targetSum; j >= v; j-- {
            if dp[j-v] {
                dp[j] = true
            }
        }
    }
    return dp[targetSum]
}

func main() {
    nums := []int{1, 5, 11, 5}
    result := canPartition(nums)
    fmt.Println(result)
}
```

**解析：** 该函数使用动态规划，判断是否存在分割使得两个子集的元素和相等。首先计算数组的总和，如果总和是奇数，则不可能分割成两个和相等的子集。然后使用一个二维数组 `dp` 记录每个目标和是否能够被数组中的元素组成。遍历数组，更新 `dp` 数组。最终返回 `dp[targetSum]` 是否为 `true`。

### 总结

本文针对美团2025校招编程面试题精选与解答，从常见的算法和数据结构题目出发，给出了详细的解题思路和代码实现。这些题目涵盖了二叉树、链表、数组、字符串等基础知识点，以及动态规划、二分查找等常用算法。通过本文的学习，希望能帮助读者巩固编程基础，提高解题能力。同时，也欢迎大家提出宝贵意见，共同进步！

