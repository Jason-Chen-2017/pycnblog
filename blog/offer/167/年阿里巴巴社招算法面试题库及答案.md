                 

## 阿里巴巴2025年社招算法面试题库及答案解析

本文将围绕阿里巴巴2025年社招算法面试题库及答案，详细介绍20道典型高频的面试题和算法编程题。这些题目涵盖了数据结构与算法、系统设计、编程能力等多个方面，旨在帮助读者更好地准备阿里巴巴的面试。

### 1. 二分查找

**题目：** 实现一个二分查找算法，在有序数组中查找一个目标值。

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 二分查找是一种高效的查找算法，其时间复杂度为 O(logn)。在本题中，我们通过不断缩小区间，直到找到目标值或确定目标值不存在。

### 2. 快排

**题目：** 实现快速排序算法。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

**解析：** 快速排序是一种分治算法，其时间复杂度为 O(nlogn)。在本题中，我们选择中间元素作为基准，将数组划分为小于、等于、大于基准的三部分，然后递归排序。

### 3. 堆排序

**题目：** 实现堆排序算法。

**答案：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr
```

**解析：** 堆排序是一种基于堆数据结构的排序算法，其时间复杂度为 O(nlogn)。在本题中，我们首先将数组构建成大顶堆，然后依次取出堆顶元素，并调整堆结构。

### 4. 查找缺失的数字

**题目：** 给定一个包含 0 到 n（n > 1）个数字的数组，找出缺失的数字。

**答案：**

```python
def missing_number(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    return total_sum - sum(nums)
```

**解析：** 可以利用等差数列求和公式，计算 0 到 n 的和，然后减去数组中的元素和，即可得到缺失的数字。

### 5. 两数之和

**题目：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

**解析：** 利用哈希表存储数组元素及其索引，遍历数组，判断当前元素与目标值的差是否在哈希表中，从而找到两个数之和。

### 6. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 从起始位置开始包含两个数组。

**答案：**

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1
```

**解析：** 从后往前比较两个数组的元素，将较大的元素放入 nums1 的末尾，然后相应地更新两个数组的索引。

### 7. 有效的括号

**题目：** 给定一个字符串，判断是否是有效的括号。

**答案：**

```python
def is_valid(s):
    stack = []
    for char in s:
        if char in "({[":
            stack.append(char)
        elif not stack or (char == ")" and stack[-1] != "(" or char == "}" and stack[-1] != "{" or char == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()
    return not stack
```

**解析：** 使用栈存储左括号，遍历字符串，遇到右括号时判断是否与栈顶元素匹配，如果不匹配或栈为空，则返回 False。

### 8. 单词搜索

**题目：** 给定一个二维网格和一个单词，判断该单词是否存在于网格中。

**答案：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

**解析：** 使用深度优先搜索（DFS）遍历网格，对于每个位置，如果与单词的当前字符匹配，则将其标记为‘#’并继续搜索。搜索完毕后，恢复原始字符。

### 9. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or prefix[i] != s[i]:
                prefix = prefix[:i]
                break
    return prefix
```

**解析：** 遍历数组中的每个字符串，依次比较前缀。当出现不同字符时，截取前缀。

### 10. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        if merged[-1][1] >= interval[0]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)

    return merged
```

**解析：** 对区间数组进行排序，然后遍历区间。如果当前区间与上一个区间有重叠，则合并区间；否则，添加新区间。

### 11. 字符串匹配

**题目：** 给定一个字符串 (s) 和一个字符 (p)，判断是否是 s 的子序列。

**答案：**

```python
def isSubsequence(s, t):
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == len(s)
```

**解析：** 使用两个指针遍历 s 和 t，如果 s 的字符在 t 中出现，则 s 的指针向前移动；否则，t 的指针向前移动。

### 12. 逆波兰表达式求值

**题目：** 根据逆波兰表达式求值。

**答案：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack.pop()
```

**解析：** 遍历逆波兰表达式，根据运算符从栈顶弹出操作数进行计算，并将结果压入栈。

### 13. 最大子序和

**题目：** 给定一个整数数组 nums，找出一个序列的最大子序列和。

**答案：**

```python
def maxSubArray(nums):
    if not nums:
        return 0

    cur_max, global_max = nums[0], nums[0]
    for num in nums[1:]:
        cur_max = max(num, cur_max + num)
        global_max = max(global_max, cur_max)

    return global_max
```

**解析：** 使用动态规划思想，维护当前最大子序列和和全局最大子序列和。

### 14. 寻找峰值元素

**题目：** 给定一个整数数组，找出数组中的峰值元素。峰值元素是指其值大于左右相邻值的元素。

**答案：**

```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

**解析：** 使用二分查找，当中间元素的值小于其右侧元素的值时，峰值元素在右侧；否则，峰值元素在左侧。

### 15. 搜索旋转排序数组

**题目：** 给定一个旋转排序的整数数组，实现一个搜索算法，找出目标值。

**答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 利用二分查找，分别判断中间元素与左右边界的关系，确定搜索区间。

### 16. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**答案：**

```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**解析：** 使用快慢指针，如果快指针追上慢指针，说明链表中存在环。

### 17. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：**

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    max_length = 0
    for num in nums:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    return max_length
```

**解析：** 使用哈希表存储数组元素，遍历数组，计算最长连续序列长度。

### 18. 最大连续1的个数

**题目：** 给定一个布尔数组，找出连续 1 的最大个数。

**答案：**

```python
def findMaxConsecutiveOnes(nums):
    max_consecutive_ones = 0
    current_consecutive_ones = 0
    for num in nums:
        if num == 1:
            current_consecutive_ones += 1
            max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)
        else:
            current_consecutive_ones = 0
    return max_consecutive_ones
```

**解析：** 遍历数组，统计连续 1 的个数，更新最大连续 1 的个数。

### 19. 打家劫舍

**题目：** 给定一个数组，每个元素表示一笔钱，小偷只能在相邻的房屋中打劫，计算最大金额。

**答案：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]
```

**解析：** 使用动态规划，计算每个位置的最大金额，最后返回最后一个位置的最大金额。

### 20. 打家劫舍 II

**题目：** 给定一个数组，每个元素表示一笔钱，小偷不能同时打劫相邻的房屋，计算最大金额。

**答案：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    def rob_range(nums):
        dp = [0] * len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]

    if len(nums) == 2:
        return max(nums)

    return max(rob_range(nums[:-1]), rob_range(nums[1:]))

```

**解析：** 需要考虑最后一个房屋不能打劫的情况，将数组分为两个部分，分别计算最大金额，最后取较大值。

### 总结

本文介绍了阿里巴巴2025年社招算法面试题库及答案，涵盖了数据结构与算法、系统设计、编程能力等多个方面的知识点。通过这些题目和答案的解析，希望能够帮助读者更好地准备阿里巴巴的面试。同时，也提醒读者在面试过程中，注意理解题意、分析问题、寻找解决方案，并注重代码的可读性和性能。

---

### 附录：常见面试题及答案

**1. 数据结构与算法：**

- 二分查找
- 快速排序
- 堆排序
- 查找缺失的数字
- 两数之和
- 合并两个有序数组
- 有效的括号
- 单词搜索
- 最长公共前缀
- 合并区间

**2. 系统设计：**

- 搜索引擎的设计
- 缓存系统的设计
- 分布式系统的设计
- 高并发系统的设计

**3. 编程能力：**

- 字符串匹配
- 逆波兰表达式求值
- 最大子序和
- 寻找峰值元素
- 搜索旋转排序数组
- 环形链表
- 最长连续序列
- 最大连续1的个数
- 打家劫舍
- 打家劫舍 II

以上题目和答案仅供参考，实际面试题目可能有所不同。祝大家面试顺利！<|im_sep|>## 阿里巴巴2025年社招算法面试题库及答案解析

### 1. 二分查找

**题目描述：** 实现一个二分查找算法，在有序数组中查找一个目标值。

**答案解析：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 2. 快速排序

**题目描述：** 实现快速排序算法。

**答案解析：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

### 3. 堆排序

**题目描述：** 实现堆排序算法。

**答案解析：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr
```

### 4. 查找缺失的数字

**题目描述：** 给定一个包含 0 到 n（n > 1）个数字的数组，找出缺失的数字。

**答案解析：**

```python
def missing_number(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    return total_sum - sum(nums)
```

### 5. 两数之和

**题目描述：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

### 6. 合并两个有序数组

**题目描述：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 从起始位置开始包含两个数组。

**答案解析：**

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1
```

### 7. 有效的括号

**题目描述：** 给定一个字符串，判断是否是有效的括号。

**答案解析：**

```python
def is_valid(s):
    stack = []
    for char in s:
        if char in "({[":
            stack.append(char)
        elif not stack or (char == ")" and stack[-1] != "(" or char == "}" and stack[-1] != "{" or char == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()
    return not stack
```

### 8. 单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断该单词是否存在于网格中。

**答案解析：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

### 9. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or prefix[i] != s[i]:
                prefix = prefix[:i]
                break
    return prefix
```

### 10. 合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**答案解析：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        if merged[-1][1] >= interval[0]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)

    return merged
```

### 11. 字符串匹配

**题目描述：** 判断字符串 s 是否为 t 的子序列。

**答案解析：**

```python
def isSubsequence(s, t):
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == len(s)
```

### 12. 逆波兰表达式求值

**题目描述：** 根据逆波兰表达式求值。

**答案解析：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack.pop()
```

### 13. 最大子序和

**题目描述：** 给定一个整数数组，找出一个序列的最大子序列和。

**答案解析：**

```python
def maxSubArray(nums):
    if not nums:
        return 0

    cur_max, global_max = nums[0], nums[0]
    for num in nums[1:]:
        cur_max = max(num, cur_max + num)
        global_max = max(global_max, cur_max)

    return global_max
```

### 14. 寻找峰值元素

**题目描述：** 给定一个整数数组，找出数组中的峰值元素。峰值元素是指其值大于左右相邻值的元素。

**答案解析：**

```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

### 15. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的整数数组，实现一个搜索算法，找出目标值。

**答案解析：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 16. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**答案解析：**

```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### 17. 最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案解析：**

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    max_length = 0
    for num in nums:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    return max_length
```

### 18. 最大连续1的个数

**题目描述：** 给定一个布尔数组，找出连续 1 的最大个数。

**答案解析：**

```python
def findMaxConsecutiveOnes(nums):
    max_consecutive_ones = 0
    current_consecutive_ones = 0
    for num in nums:
        if num == 1:
            current_consecutive_ones += 1
            max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)
        else:
            current_consecutive_ones = 0
    return max_consecutive_ones
```

### 19. 打家劫舍

**题目描述：** 给定一个数组，每个元素表示一笔钱，小偷只能在相邻的房屋中打劫，计算最大金额。

**答案解析：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]
```

### 20. 打家劫舍 II

**题目描述：** 给定一个数组，每个元素表示一笔钱，小偷不能同时打劫相邻的房屋，计算最大金额。

**答案解析：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    def rob_range(nums):
        dp = [0] * len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]

    if len(nums) == 2:
        return max(nums)

    return max(rob_range(nums[:-1]), rob_range(nums[1:]))
```

### 总结

以上就是阿里巴巴2025年社招算法面试题库及答案解析，这些题目涵盖了数据结构与算法、系统设计、编程能力等多个方面。在实际面试中，可能会涉及到更多复杂的题目，但掌握了这些基础题目，就能应对大部分面试。祝大家面试顺利！<|im_sep|>## 阿里巴巴2025年社招算法面试题库及答案

### 1. 二分查找

**题目描述：** 实现一个二分查找算法，在有序数组中查找一个目标值。

**答案：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 2. 快速排序

**题目描述：** 实现快速排序算法。

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

### 3. 堆排序

**题目描述：** 实现堆排序算法。

**答案：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr
```

### 4. 查找缺失的数字

**题目描述：** 给定一个包含 0 到 n（n > 1）个数字的数组，找出缺失的数字。

**答案：**

```python
def missing_number(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    return total_sum - sum(nums)
```

### 5. 两数之和

**题目描述：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

### 6. 合并两个有序数组

**题目描述：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 从起始位置开始包含两个数组。

**答案：**

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1
```

### 7. 有效的括号

**题目描述：** 给定一个字符串，判断是否是有效的括号。

**答案：**

```python
def is_valid(s):
    stack = []
    for char in s:
        if char in "({[":
            stack.append(char)
        elif not stack or (char == ")" and stack[-1] != "(" or char == "}" and stack[-1] != "{" or char == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()
    return not stack
```

### 8. 单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断该单词是否存在于网格中。

**答案：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

### 9. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or prefix[i] != s[i]:
                prefix = prefix[:i]
                break
    return prefix
```

### 10. 合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        if merged[-1][1] >= interval[0]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)

    return merged
```

### 11. 字符串匹配

**题目描述：** 判断字符串 s 是否为 t 的子序列。

**答案：**

```python
def isSubsequence(s, t):
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == len(s)
```

### 12. 逆波兰表达式求值

**题目描述：** 根据逆波兰表达式求值。

**答案：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack.pop()
```

### 13. 最大子序和

**题目描述：** 给定一个整数数组，找出一个序列的最大子序列和。

**答案：**

```python
def maxSubArray(nums):
    if not nums:
        return 0

    cur_max, global_max = nums[0], nums[0]
    for num in nums[1:]:
        cur_max = max(num, cur_max + num)
        global_max = max(global_max, cur_max)

    return global_max
```

### 14. 寻找峰值元素

**题目描述：** 给定一个整数数组，找出数组中的峰值元素。峰值元素是指其值大于左右相邻值的元素。

**答案：**

```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

### 15. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的整数数组，实现一个搜索算法，找出目标值。

**答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 16. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**答案：**

```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### 17. 最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：**

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    max_length = 0
    for num in nums:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    return max_length
```

### 18. 最大连续1的个数

**题目描述：** 给定一个布尔数组，找出连续 1 的最大个数。

**答案：**

```python
def findMaxConsecutiveOnes(nums):
    max_consecutive_ones = 0
    current_consecutive_ones = 0
    for num in nums:
        if num == 1:
            current_consecutive_ones += 1
            max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)
        else:
            current_consecutive_ones = 0
    return max_consecutive_ones
```

### 19. 打家劫舍

**题目描述：** 给定一个数组，每个元素表示一笔钱，小偷只能在相邻的房屋中打劫，计算最大金额。

**答案：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]
```

### 20. 打家劫舍 II

**题目描述：** 给定一个数组，每个元素表示一笔钱，小偷不能同时打劫相邻的房屋，计算最大金额。

**答案：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    def rob_range(nums):
        dp = [0] * len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]

    if len(nums) == 2:
        return max(nums)

    return max(rob_range(nums[:-1]), rob_range(nums[1:]))
```

### 总结

以上就是阿里巴巴2025年社招算法面试题库及答案，这些题目涵盖了数据结构与算法、系统设计、编程能力等多个方面。在实际面试中，可能会涉及到更多复杂的题目，但掌握了这些基础题目，就能应对大部分面试。祝大家面试顺利！<|im_sep|>## 阿里巴巴2025年社招算法面试题库及答案解析

### 题目1：二分查找

**题目描述：** 实现一个二分查找算法，在有序数组中查找一个目标值。

**答案解析：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

二分查找算法的基本思想是：每次将数组中间的元素与目标值进行比较，如果中间元素大于目标值，则在数组的前半部分继续查找，否则在数组的后半部分查找。通过不断缩小查找范围，直到找到目标值或确定目标值不存在。

### 题目2：快速排序

**题目描述：** 实现快速排序算法。

**答案解析：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

快速排序是一种分治算法，其基本思想是选择一个基准元素，将数组分为小于基准元素和大于基准元素的两部分，然后递归地对这两部分进行快速排序。这里选择的基准元素是数组中间的元素。

### 题目3：堆排序

**题目描述：** 实现堆排序算法。

**答案解析：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    return arr
```

堆排序是一种利用堆这种数据结构的排序算法。首先将数组构建成一个最大堆，然后依次取出堆顶元素，并调整堆结构，直到堆为空。

### 题目4：查找缺失的数字

**题目描述：** 给定一个包含 0 到 n（n > 1）个数字的数组，找出缺失的数字。

**答案解析：**

```python
def missing_number(nums):
    n = len(nums)
    total_sum = n * (n + 1) // 2
    return total_sum - sum(nums)
```

该题可以通过计算 0 到 n 的和，然后减去数组中的元素和，得到缺失的数字。这里利用了等差数列求和公式。

### 题目5：两数之和

**题目描述：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案解析：**

```python
def two_sum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

这道题可以通过哈希表实现。遍历数组，对于每个元素，计算其与目标值的差，如果差在哈希表中存在，则返回对应的下标。

### 题目6：合并两个有序数组

**题目描述：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 从起始位置开始包含两个数组。

**答案解析：**

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1
```

这道题可以通过双指针法实现。分别从两个数组的末尾开始比较，将较大的元素放入 nums1 的末尾，然后相应地更新两个数组的索引。

### 题目7：有效的括号

**题目描述：** 给定一个字符串，判断是否是有效的括号。

**答案解析：**

```python
def is_valid(s):
    stack = []
    for char in s:
        if char in "({[:
            stack.append(char)
        elif not stack or (char == ")" and stack[-1] != "(" or char == "}" and stack[-1] != "{" or char == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()
    return not stack
```

这道题可以使用栈来实现。遍历字符串，遇到左括号时入栈，遇到右括号时与栈顶元素匹配，如果不匹配或栈为空，则返回 False。

### 题目8：单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断该单词是否存在于网格中。

**答案解析：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

这道题可以使用深度优先搜索（DFS）实现。对于网格中的每个元素，如果与单词的当前字符匹配，则将其标记为‘#’，并继续搜索。搜索完毕后，恢复原始字符。

### 题目9：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案解析：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or prefix[i] != s[i]:
                prefix = prefix[:i]
                break
    return prefix
```

这道题可以通过遍历字符串数组，依次比较前缀来实现。当出现不同字符时，截取前缀。

### 题目10：合并区间

**题目描述：** 给出一个区间的集合，请合并所有重叠的区间。

**答案解析：**

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        if merged[-1][1] >= interval[0]:
            merged[-1][1] = max(merged[-1][1], interval[1])
        else:
            merged.append(interval)

    return merged
```

这道题可以通过排序和遍历来实现。首先对区间数组进行排序，然后遍历区间数组，合并重叠的区间。

### 题目11：字符串匹配

**题目描述：** 判断字符串 s 是否为 t 的子序列。

**答案解析：**

```python
def isSubsequence(s, t):
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == len(s)
```

这道题可以通过双指针法实现。分别遍历字符串 s 和 t，当 s 的当前字符与 t 的当前字符相同时，s 的指针前进，否则 t 的指针前进。

### 题目12：逆波兰表达式求值

**题目描述：** 根据逆波兰表达式求值。

**答案解析：**

```python
def evalRPN(tokens):
    stack = []
    for token in tokens:
        if token in ['+', '-', '*', '/']:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.append(a + b)
            elif token == '-':
                stack.append(a - b)
            elif token == '*':
                stack.append(a * b)
            else:
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack.pop()
```

这道题可以通过栈来实现。遍历逆波兰表达式，根据运算符从栈顶弹出操作数进行计算，并将结果压入栈。

### 题目13：最大子序和

**题目描述：** 给定一个整数数组，找出一个序列的最大子序列和。

**答案解析：**

```python
def maxSubArray(nums):
    if not nums:
        return 0

    cur_max, global_max = nums[0], nums[0]
    for num in nums[1:]:
        cur_max = max(num, cur_max + num)
        global_max = max(global_max, cur_max)

    return global_max
```

这道题可以通过动态规划来实现。维护当前最大子序列和和全局最大子序列和，遍历数组更新这两个值。

### 题目14：寻找峰值元素

**题目描述：** 给定一个整数数组，找出数组中的峰值元素。峰值元素是指其值大于左右相邻值的元素。

**答案解析：**

```python
def findPeakElement(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

这道题可以通过二分查找来实现。当中间元素的值小于其右侧元素的值时，峰值元素在右侧；否则，峰值元素在左侧。

### 题目15：搜索旋转排序数组

**题目描述：** 给定一个旋转排序的整数数组，实现一个搜索算法，找出目标值。

**答案解析：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

这道题可以通过二分查找来实现。判断中间元素与左右边界的关系，确定搜索区间。

### 题目16：环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**答案解析：**

```python
def hasCycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

这道题可以使用快慢指针法来实现。当快指针追上慢指针时，说明链表中存在环。

### 题目17：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案解析：**

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums_set = set(nums)
    max_length = 0
    for num in nums:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    return max_length
```

这道题可以通过哈希表来实现。遍历数组，判断当前元素是否为最长连续序列的起点，如果是，则计算序列长度。

### 题目18：最大连续1的个数

**题目描述：** 给定一个布尔数组，找出连续 1 的最大个数。

**答案解析：**

```python
def findMaxConsecutiveOnes(nums):
    max_consecutive_ones = 0
    current_consecutive_ones = 0
    for num in nums:
        if num == 1:
            current_consecutive_ones += 1
            max_consecutive_ones = max(max_consecutive_ones, current_consecutive_ones)
        else:
            current_consecutive_ones = 0
    return max_consecutive_ones
```

这道题可以通过遍历数组来实现。遍历数组，统计连续 1 的个数，更新最大连续 1 的个数。

### 题目19：打家劫舍

**题目描述：** 给定一个数组，每个元素表示一笔钱，小偷只能在相邻的房屋中打劫，计算最大金额。

**答案解析：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]
```

这道题可以通过动态规划来实现。维护一个数组 dp，记录每个位置的最大金额。

### 题目20：打家劫舍 II

**题目描述：** 给定一个数组，每个元素表示一笔钱，小偷不能同时打劫相邻的房屋，计算最大金额。

**答案解析：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]

    def rob_range(nums):
        dp = [0] * len(nums)
        dp[0], dp[1] = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
        return dp[-1]

    if len(nums) == 2:
        return max(nums)

    return max(rob_range(nums[:-1]), rob_range(nums[1:]))
```

这道题可以通过动态规划来实现。分情况讨论，计算最大金额。如果数组长度为 1 或 2，直接返回数组元素的最大值；否则，分别计算首尾元素被抢劫的情况，取最大值。

