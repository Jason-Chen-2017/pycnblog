                 

### 小米2025校招面试真题与算法题解

#### 1. 判断字符串是否是回文

**题目：** 实现一个函数，判断一个字符串是否是回文。

**输入：** 字符串 s

**输出：** 布尔值，表示字符串是否是回文

**示例：**
```plaintext
isPalindrome("abcba") -> true
isPalindrome("abcd") -> false
```

**答案：** 我们可以使用双指针的方法来解决这个问题。一个指针指向字符串的开始位置，另一个指针指向字符串的结束位置，然后比较这两个位置的字符，如果相同，则将两个指针分别向中间移动，继续比较，直到两个指针相遇或者有一个字符不相同。

**代码实现：**
```go
func isPalindrome(s string) bool {
    n := len(s)
    left, right := 0, n-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

#### 2. 排序算法

**题目：** 实现一个排序算法，例如冒泡排序、选择排序或快速排序。

**输入：** 一个整数数组

**输出：** 排序后的整数数组

**示例：**
```plaintext
bubbleSort([3, 2, 1]) -> [1, 2, 3]
selectionSort([3, 2, 1]) -> [1, 2, 3]
quickSort([3, 2, 1]) -> [1, 2, 3]
```

**答案：** 下面是使用快速排序算法的代码实现：

**代码实现：**
```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)
    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }
    return append(quickSort(left), append(middle, quickSort(right)...)...)
}
```

#### 3. 单链表反转

**题目：** 实现一个函数，反转单链表。

**输入：** 单链表的头节点

**输出：** 反转后的单链表的头节点

**示例：**
```plaintext
reverseList(null) -> null
reverseList([1, 2, 3, 4, 5]) -> [5, 4, 3, 2, 1]
```

**答案：** 我们可以使用递归来实现这个函数：

**代码实现：**
```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

#### 4. 合并两个有序链表

**题目：** 实现一个函数，合并两个有序链表。

**输入：** 两个有序链表的头节点

**输出：** 合并后的有序链表的头节点

**示例：**
```plaintext
mergeTwoLists(null, null) -> null
mergeTwoLists([1, 2, 3], [4, 5, 6]) -> [1, 4, 5, 6, 2, 3]
```

**答案：** 下面是合并两个有序链表的代码实现：

**代码实现：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 5. 两数相加

**题目：** 实现一个函数，两数相加。

**输入：** 两个非空链表，每个链表中包含两个数字，分别表示一个非负整数

**输出：** 合并后的链表，表示两个数字的和

**示例：**
```plaintext
addTwoNumbers([2, 4, 3], [5, 6, 4]) -> [7, 0, 8]
```

**答案：** 下面是两数相加的代码实现：

**代码实现：**
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{Val: 0}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

#### 6. 二进制中 1 的个数

**题目：** 实现一个函数，计算二进制表示中 1 的个数。

**输入：** 一个整数

**输出：** 二进制表示中 1 的个数

**示例：**
```plaintext
hammingWeight(0) -> 0
hammingWeight(4) -> 1
hammingWeight(5) -> 2
```

**答案：** 下面是计算二进制中 1 的个数的代码实现：

**代码实现：**
```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

#### 7. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**输入：** `nums = [2, 7, 11, 15], target = 9`

**输出：** `[0, 1]`，因为 `nums[0] + nums[1] = 2 + 7 = 9`

**答案：** 下面是求解两数之和的代码实现：

**代码实现：**
```go
func twoSum(nums []int, target int) []int {
    var indexMap = make(map[int]int)
    for i, num := range nums {
        diff := target - num
        if j, ok := indexMap[diff]; ok {
            return []int{j, i}
        }
        indexMap[num] = i
    }
    return nil
}
```

#### 8. 三数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那三个整数，并返回它们的数组下标。

**输入：** `nums = [-1, 0, 1, 2, -1, -4], target = 0`

**输出：** `[-1, 0, 1]`，因为 `nums[-1] + nums[0] + nums[1] = -1 + 0 + 1 = 0`

**答案：** 下面是求解三数之和的代码实现：

**代码实现：**
```go
func threeSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, len(nums)-1
        for l < r {
            sum := nums[i] + nums[l] + nums[r]
            if sum == target {
                res = append(res, []int{nums[i], nums[l], nums[r]})
                for l < r && nums[l] == nums[l+1] {
                    l++
                }
                for l < r && nums[r] == nums[r-1] {
                    r--
                }
                l++
                r--
            } else if sum < target {
                l++
            } else {
                r--
            }
        }
    }
    return res
}
```

#### 9. 四数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那四个整数，并返回它们的数组下标。

**输入：** `nums = [1, 0, -1, 0, -2, 2], target = 0`

**输出：** `[0, 1, 2, 4]`，因为 `nums[0] + nums[1] + nums[3] + nums[4] = 1 + 0 + (-1) + (-2) + 2 = 0`

**答案：** 下面是求解四数之和的代码实现：

**代码实现：**
```go
func fourSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-3; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        for j := i + 1; j < len(nums)-2; j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            l, r := j+1, len(nums)-1
            for l < r {
                sum := nums[i] + nums[j] + nums[l] + nums[r]
                if sum == target {
                    res = append(res, []int{nums[i], nums[j], nums[l], nums[r]})
                    for l < r && nums[l] == nums[l+1] {
                        l++
                    }
                    for l < r && nums[r] == nums[r-1] {
                        r--
                    }
                    l++
                    r--
                } else if sum < target {
                    l++
                } else {
                    r--
                }
            }
        }
    }
    return res
}
```

#### 10. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**输入：** `strs = ["flower","flow","flight"]`

**输出：** `"fl"`,因为它是这三个字符串的最长公共前缀。

**答案：** 下面是求解最长公共前缀的代码实现：

**代码实现：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, str := range strs[1:] {
        for prefix != "" && strings.Index(str, prefix) != 0 {
            prefix = prefix[:len(prefix)-1]
        }
    }
    return prefix
}
```

#### 11. 盛最多水的容器

**题目：** 给定一个大小为 `m×n` 的网格，网格中的每个单元格都有一值（代表海平面高度）。有一个潜水员，他需要从网格左上角（`0,0`）出发，穿过网格的所有单元格，并最终达到右下角（`m-1,n-1`）。每走过一个单元格，他都会将水排到网格外。求潜水员能够容纳的最大水量。

**输入：** `grid = [[1,2],[3,5]]`

**输出：** `6`，因为当潜水员从左上角移动到右下角时，最多能容纳 6 单位水（单位为立方单位）。

**答案：** 下面是求解最大水量的代码实现：

**代码实现：**
```go
func maxArea(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    left, right := 0, n-1
    maxArea := 0
    for left < right {
        row := min(grid[left][left], grid[right][right])
        maxArea = max(maxArea, row*(right-left))
        if grid[left][left] < grid[right][right] {
            left++
        } else {
            right--
        }
    }
    return maxArea
}
```

#### 12. 合并两个有序数组

**题目：** 给定两个有序整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**输入：** `nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3`

**输出：** `nums1 = [1,2,2,3,5,6]`

**答案：** 下面是合并两个有序数组的代码实现：

**代码实现：**
```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p3 := m-1, n-1, m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p3] = nums1[p1]
            p1--
        } else {
            nums1[p3] = nums2[p2]
            p2--
        }
        p3--
    }
    if p2 >= 0 {
        copy(nums1[:p2+1], nums2[:p2+1])
    }
}
```

#### 13. 罗马数字转整数

**题目：** 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

|字符|I|V|X|L|C|D|M|
|---|---|---|---|---|---|---|---|
|值|1|5|10|50|100|500|1000|

例如，`3994` 表示为 `MMMCCCXCIV`。给定一个罗马数字，将其转换为整数。

**输入：** `"MMMCCCXCIV"`

**输出：** `3994`

**答案：** 下面是罗马数字转整数的代码实现：

**代码实现：**
```go
func romanToInt(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    prev, ans := 0, 0
    for _, v := range s {
        cur := m[v]
        if cur > prev {
            ans += cur - 2 * prev
        } else {
            ans += cur
        }
        prev = cur
    }
    return ans
}
```

#### 14. 有效的括号

**题目：** 给定一个字符串 `s` ，判断 `s` 是否包含有效的括号序列，并且可以从中取出所有有效的括号对。

**输入：** `"()`"`

**输出：** `true`

**答案：** 下面是判断有效括号的代码实现：

**代码实现：**
```go
func isValid(s string) bool {
    stack := []rune{}
    for _, v := range s {
        switch v {
        case ')':
            if len(stack) == 0 || stack[len(stack)-1] != '(' {
                return false
            }
            stack = stack[:len(stack)-1
```go
        case '}':
            if len(stack) == 0 || stack[len(stack)-1] != '{' {
                return false
            }
            stack = stack[:len(stack)-1]
        case ']':
            if len(stack) == 0 || stack[len(stack)-1] != '[' {
                return false
            }
            stack = stack[:len(stack)-1]
        default:
            stack = append(stack, v)
        }
    }
    return len(stack) == 0
}
```

#### 15. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：** `l1 = [1,2,4], l2 = [1,3,4]`

**输出：** `[1,1,2,3,4,4]`

**答案：** 下面是合并两个有序链表的代码实现：

**代码实现：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 16. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**输入：** `head = [3,2,0,-4], pos = 1`

**输出：** `true` (链表中存在环)

**答案：** 下面是判断环形链表的代码实现：

**代码实现：**
```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

#### 17. 两数相加 II

**题目：** 给定两个非空链表表示的两个非负整数，分别为 `l1` 和 `l2`，每个节点最多有四位数字。将这两个数相加，并以链表形式返回结果。

**输入：** `l1 = [7,2,4,3], l2 = [5,6,4]`

**输出：** `[7,8,0,7]`

**答案：** 下面是两数相加 II 的代码实现：

**代码实现：**
```go
func addTwoNumbersII(l1 *ListNode, l2 *ListNode) *ListNode {
    stack1, stack2 := getStacks(l1), getStacks(l2)
    var head, tail *ListNode
    carry := 0
    for len(stack1) > 0 || len(stack2) > 0 || carry > 0 {
        val1 := 0
        if len(stack1) > 0 {
            val1 = stack1[len(stack1)-1]
            stack1 = stack1[:len(stack1)-1]
        }
        val2 := 0
        if len(stack2) > 0 {
            val2 = stack2[len(stack2)-1]
            stack2 = stack2[:len(stack2)-1]
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        node := &ListNode{Val: sum % 10}
        if head == nil {
            head = node
        } else {
            tail.Next = node
        }
        tail = node
    }
    return head
}

func getStacks(head *ListNode) []int {
    var stack []int
    for head != nil {
        stack = append(stack, head.Val)
        head = head.Next
    }
    return stack
}
```

#### 18. 单调栈

**题目：** 实现一个单调栈，可以支持以下操作：

1. push(x) —— 将一个元素 x 入栈。
2. pop() —— 将栈顶元素出栈。
3. top() —— 获取栈顶元素。
4. empty() —— 判断栈是否为空。

**输入：**
```go
[
  ["push", "1"],
  ["push", "2"],
  ["top", ],
  ["pop", ],
  ["top", ],
  ["empty", ]
]
```

**输出：**
```go
[null, null, 2, null, 1, false]
```

**答案：** 下面是单调栈的代码实现：

**代码实现：**
```go
type MonotonicStack struct {
    s []int
}

func Constructor() MonotonicStack {
    return MonotonicStack{}
}

func (this *MonotonicStack) Push(x int) {
    for len(this.s) > 0 && this.s[len(this.s)-1] < x {
        this.s = this.s[:len(this.s)-1]
    }
    this.s = append(this.s, x)
}

func (this *MonotonicStack) Pop() {
    this.s = this.s[:len(this.s)-1]
}

func (this *MonotonicStack) Top() int {
    return this.s[len(this.s)-1]
}

func (this *MonotonicStack) Empty() bool {
    return len(this.s) == 0
}

/**
 * Your MonotonicStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(x);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Empty();
 */
```

#### 19. 岛屿数量

**题目：** 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

**输入：**
```go
grid = [
  ["1", "1", "1", "1", "0"],
  ["1", "1", "0", "1", "1"],
  ["1", "1", "0", "0", "0"],
  ["0", "0", "0", "0", "0"]
]
```

**输出：**
```go
3
```

**答案：** 下面是计算岛屿数量的代码实现：

**代码实现：**
```go
func numIslands(grid [][]byte) int {
    m, n := len(grid), len(grid[0])
    vis := make([][]bool, m)
    for i := range vis {
        vis[i] = make([]bool, n)
    }
    var dfs func(i, j int)
    dfs = func(i, j int) {
        if i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || grid[i][j] == '0' {
            return
        }
        vis[i][j] = true
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    }
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if !vis[i][j] && grid[i][j] == '1' {
                dfs(i, j)
                ans++
            }
        }
    }
    return ans
}
```

#### 20. 最小栈

**题目：** 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

**输入：**
```go
[
  ["push", "-3"],
  ["push", "2"],
  ["push", "3"],
  ["push", "4"],
  ["min", ],
  ["pop", ],
  ["min", ]
]
```

**输出：**
```go
[-3, -2, -1, 0]
```

**答案：** 下面是最小栈的代码实现：

**代码实现：**
```go
type MinStack struct {
    s  []int
    ms []int
}

func Constructor() MinStack {
    return MinStack{
        s:  []int{},
        ms: []int{},
    }
}

func (this *MinStack) Push(val int) {
    this.s = append(this.s, val)
    if len(this.ms) == 0 || val < this.ms[len(this.ms)-1] {
        this.ms = append(this.ms, val)
    } else {
        this.ms = append(this.ms, this.ms[len(this.ms)-1])
    }
}

func (this *MinStack) Pop() {
    this.s = this.s[:len(this.s)-1]
    this.ms = this.ms[:len(this.ms)-1]
}

func (this *MinStack) Top() int {
    return this.s[len(this.s)-1]
}

func (this *MinStack) Min() int {
    return this.ms[len(this.ms)-1]
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.Min();
 */
```

#### 21. 两数相加

**题目：** 给出两个非空链表表示两个非负整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请将这两个数相加，并以链表形式返回结果。

**输入：**
```go
l1 = [2, 4, 3], l2 = [5, 6, 4]
```

**输出：**
```go
[7, 0, 8]
```

**答案：** 下面是两数相加的代码实现：

**代码实现：**
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var (
        dummyHead = &ListNode{}
        p         = dummyHead
        carry     = 0
    )
    for l1 != nil || l2 != nil {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        p.Next = &ListNode{Val: sum % 10}
        p = p.Next
    }
    if carry > 0 {
        p.Next = &ListNode{Val: carry}
    }
    return dummyHead.Next
}
```

#### 22. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：**
```go
l1 = [1,2,4], l2 = [1,3,4]
```

**输出：**
```go
[1,1,2,3,4,4]
```

**答案：** 下面是合并两个有序链表的代码实现：

**代码实现：**
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 23. 反转链表

**题目：** 反转一个单链表。

**输入：**
```go
[1,2,3,4,5]
```

**输出：**
```go
[5,4,3,2,1]
```

**答案：** 下面是反转链表的代码实现：

**代码实现：**
```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    cur := head
    for cur != nil {
        nextTemp := cur.Next
        cur.Next = prev
        prev = cur
        cur = nextTemp
    }
    return prev
}
```

#### 24. 链表中倒数第 k 个节点

**题目：** 输入一个链表，输出该链表中倒数第 k 个节点。

**输入：**
```go
head = [1,2,3,4,5], k = 2
```

**输出：**
```go
节点值为 4
```

**答案：** 下面是链表中倒数第 k 个节点的代码实现：

**代码实现：**
```go
func getKthFromEnd(head *ListNode, k int) *ListNode {
    fast, slow := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

#### 25. 链表中两数相加

**题目：** 给出两个（表示两个非负整数的）非空链表，分别表示两个数。它们可以是正数或负数。将两个数相加，并以链表形式返回结果。

**输入：**
```go
l1 = [7,2,4,3], l2 = [5,6,4]
```

**输出：**
```go
[7,8,0,7]
```

**答案：** 下面是链表中两数相加的代码实现：

**代码实现：**
```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummyHead := &ListNode{}
    cur := dummyHead
    carry := 0
    for l1 != nil || l2 != nil {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        cur.Next = &ListNode{Val: sum % 10}
        cur = cur.Next
    }
    if carry > 0 {
        cur.Next = &ListNode{Val: carry}
    }
    return dummyHead.Next
}
```

#### 26. 删除链表的节点

**题目：** 给定一个单链表的头节点 `head` 和一个整数 `val`，删除链表中所有值为 `val` 的节点。

**输入：**
```go
head = [1,2,6,3,4,5,6], val = 6
```

**输出：**
```go
[1,2,3,4,5]
```

**答案：** 下面是删除链表中节点的代码实现：

**代码实现：**
```go
func removeElements(head *ListNode, val int) *ListNode {
    dummy := &ListNode{Val: -1, Next: head}
    prev, cur := dummy, head
    for cur != nil {
        if cur.Val == val {
            prev.Next = cur.Next
        } else {
            prev = cur
        }
        cur = cur.Next
    }
    return dummy.Next
}
```

#### 27. 回文链表

**题目：** 请判断一个链表是否为回文。

**输入：**
```go
[1,2]
```

**输出：**
```go
true
```

**答案：** 下面是判断回文链表的代码实现：

**代码实现：**
```go
func isPalindrome(head *ListNode) bool {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
    }
    if fast != nil { // odd length
        slow = slow.Next
    }
    var reverse *ListNode
    for slow != nil {
        tmp := slow.Next
        slow.Next = reverse
        reverse = slow
        slow = tmp
    }
    if head.Val != reverse.Val {
        return false
    }
    slow = reverse
    for head != nil && slow != nil {
        if head.Val != slow.Val {
            return false
        }
        head = head.Next
        slow = slow.Next
    }
    return true
}
```

#### 28. 相交链表

**题目：** 编写一个程序，找到单链表相交的节点。

**输入：**
```go
headA = [4,1,8,4,5], headB = [5,6,1,8,4,5]
```

**输出：**
```go
Node 8
```

**答案：** 下面是相交链表的代码实现：

**代码实现：**
```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    pA, pB := headA, headB
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    return pA
}
```

#### 29. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**输入：**
```go
head = [3,2,0,-4]
```

**输出：**
```go
true
```

**答案：** 下面是环形链表的代码实现：

**代码实现：**
```go
func hasCycle(head *ListNode) bool {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            return true
        }
    }
    return false
}
```

#### 30. 环形链表 II

**题目：** 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

**输入：**
```go
head = [3,2,0,-4], pos = 1
```

**输出：**
```go
Node 3
```

**答案：** 下面是环形链表 II 的代码实现：

**代码实现：**
```go
func detectCycle(head *ListNode) *ListNode {
    if head == nil {
        return nil
    }
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
        }
    }
    if fast == nil || fast.Next == nil {
        return nil
    }
    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    return slow
}
```

