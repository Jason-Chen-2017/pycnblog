                 

### 小米校招面试题与算法编程题全方位解析

#### 1. 单词拆分问题

**题目描述：** 给定一个非空字符串 `s` 和一个包含 `s` 中所有单词的字符串列表 `wordDict`，在字符串 `s` 中添加空格来构建一个句子，使得句子中的每个单词都在 `wordDict` 中。以任意顺序返回所有可能的句子。

**示例：**
```plaintext
输入：s = "catsanddog", wordDict = ["cat", "cats", "and", "sand", "dog"]
输出：[
   "cat sand dog",
   "cats and dog"
]
```

**答案解析：**
这个问题可以通过深度优先搜索（DFS）和回溯来解决。使用 DFS 遍历字符串的所有可能的分割方式，并使用回溯来尝试每一种分割方式，如果分割方式满足条件，则将其加入到结果中。

**代码示例：**
```go
func wordBreak(s string, wordDict []string) (ans []string) {
    var dfs func(int)    
    dfs = func(i int) {
        if i == len(s) {
            ans = append(ans, "")
            return
        }
        for j := i; j < len(s); j++ {
            if contains(wordDict, s[i:j+1]) {
                // 如果当前子字符串在字典中，则继续递归搜索
                dfs(j + 1)
                // 将结果连接起来
                ans = append(ans, s[i:j+1]+ans[len(ans)-1])
            }
        }
    }
    dfs(0)
    return
}

// 判断子字符串是否在字典中
func contains(words []string, word string) bool {
    for _, v := range words {
        if v == word {
            return true
        }
    }
    return false
}
```

#### 2. 两个数的和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**
```plaintext
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9，返回 [0, 1]。
```

**答案解析：**
这个问题可以通过哈希表来解决。遍历数组，对于每个元素 `x`，检查 `target - x` 是否在哈希表中，如果存在，则找到了答案。

**代码示例：**
```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if j, ok := m[target-num]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

#### 3. 盛水最多的容器

**题目描述：** 给定一个数组 `height` 表示容器的形状，计算容器的最大容量。

**示例：**
```plaintext
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：图中黄色部分是容器的最大容量。
```

**答案解析：**
这个问题可以通过双指针的方法解决。设置两个指针 `i` 和 `j` 分别指向数组的两端，每次移动较短的边，并更新最大容量。

**代码示例：**
```go
func maxArea(height []int) int {
    i, j := 0, len(height)-1
    maxArea := 0
    for i < j {
        maxArea = max(maxArea, min(height[i], height[j])*(j-i))
        if height[i] < height[j] {
            i++
        } else {
            j--
        }
    }
    return maxArea
}
```

#### 4. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```plaintext
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案解析：**
这个问题可以通过字符串比较来解决。从第一个字符串开始，依次与前一个字符串比较，取公共的前缀。

**代码示例：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

#### 5. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**
这个问题可以通过递归或迭代的方式解决。递归方法每次比较两个链表的头部，选择较小的值添加到新链表中，并递归处理剩余部分。迭代方法使用两个指针分别指向两个链表，每次移动较小的值的指针。

**代码示例：**
递归方法：
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代方法：
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p1, p2 := l1, l2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            curr.Next = p1
            p1 = p1.Next
        } else {
            curr.Next = p2
            p2 = p2.Next
        }
        curr = curr.Next
    }
    curr.Next = p1 // 或者 p2
    return dummy.Next
}
```

#### 6. 回文数

**题目描述：** 判断一个整数是否是回文数。回文数是指正反两个方向都相同的整数。

**示例：**
```plaintext
输入：x = 121
输出：true
```

**答案解析：**
这个问题可以通过将整数转换为字符串，然后比较字符串的正反是否相同来解决。另外，可以通过数学方法，将整数反转并比较反转后的值与原值是否相同。

**代码示例：**
字符串方法：
```go
func isPalindrome(x int) bool {
    s := strconv.Itoa(x)
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        if s[i] != s[j] {
            return false
        }
    }
    return true
}
```

数学方法：
```go
func isPalindrome(x int) bool {
    if x < 0 || (x%10 == 0 && x != 0) {
        return false
    }
    revertedNumber, tmp := 0, x
    for tmp > 0 {
        revertedNumber = revertedNumber*10 + tmp%10
        tmp /= 10
    }
    return x == revertedNumber
}
```

#### 7. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**
```plaintext
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9，返回 [0, 1]。
```

**答案解析：**
这个问题可以通过哈希表来解决。遍历数组，对于每个元素 `x`，检查 `target - x` 是否在哈希表中，如果存在，则找到了答案。

**代码示例：**
```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if j, ok := m[target-num]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

#### 8. 合并两个有序数组

**题目描述：** 给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**示例：**
```plaintext
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**
这个问题可以通过从数组末尾开始合并来解决。将两个数组中的元素从末尾开始比较，将较大的元素放入 `nums1` 的末尾，直到一个数组为空。

**代码示例：**
```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p := m-1, n-1, m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    if p2 >= 0 {
        copy(nums1[:p+1], nums2[:p2+1])
    }
}
```

#### 9. 有效的括号

**题目描述：** 给定一个只包含 `'('`，`')'`，`'{'`，`'}'`，`'['` 和 `']'` 的字符串，判断是否有效。

**示例：**
```plaintext
输入："()"
输出：true

输入："()[]{}"
输出：true

输入："{[()]}()"
输出：true
```

**答案解析：**
这个问题可以通过使用栈来解决。遍历字符串，遇到左括号入栈，遇到右括号时，检查栈顶元素是否匹配，不匹配则返回 `false`。

**代码示例：**
```go
func isValid(s string) bool {
    st := []rune{}
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    for _, v := range s {
        if v == '(' || v == '{' || v == '[' {
            st = append(st, v)
        } else if len(st) == 0 || m[v] != st[len(st)-1] {
            return false
        } else {
            st = st[:len(st)-1]
        }
    }
    return len(st) == 0
}
```

#### 10. 有效的数字

**题目描述：** 给定一个字符串 `s` ，判断是否能将字符串 `s` 转换成一个有效的数字（可能是正数、负数、小数或零）。

**示例：**
```plaintext
输入：s = "0"
输出：true

输入：s = " 0.0 "
输出：true

输入：s = "3." 
输出：true

输入：s = "   -42v"
输出：false
```

**答案解析：**
这个问题可以通过状态机的方法来解决。定义多个状态，如 `signed`、`integer`、`fraction`、`exp` 和 `none`，每个状态对应处理字符串的一部分。

**代码示例：**
```go
func isNumber(s string) bool {
    states := []struct {
        isNumber, signed, integer, fraction, exp bool
    }{
        {false, false, false, false, false},
        {true, true, false, false, false},
        {true, true, true, false, false},
        {true, true, true, true, false},
        {true, true, true, true, true},
        {true, false, false, false, false},
    }

    state := 0
    for _, c := range s {
        if '0' <= c && c <= '9' {
            state = 2
        } else if c == '+' || c == '-' {
            if state == 0 {
                state = 1
            } else {
                return false
            }
        } else if c == '.' {
            if state == 2 || state == 4 {
                return false
            }
            state = 3
        } else if c == 'e' {
            if state == 2 || state == 3 || state == 5 {
                return false
            }
            state = 5
        } else if c == ' ' {
            if state == 2 || state == 3 || state == 4 || state == 5 {
                return false
            }
        } else {
            return false
        }
    }

    return states[state].isNumber
}
```

#### 11. 盲人数独

**题目描述：** 假设你是一位盲人，现在你需要通过数独来猜测数字。你有一张数独棋盘，其中一些位置上已经填好了数字。你还有一个数字板，它有 6 个区域，每个区域有 6 个按钮，分别对应数独棋盘上的 6 个数字。每个按钮被按下时，你能够听到一个声音，表示该按钮代表的数字是否出现在你面前的那一行或那一列中。

**示例：**
```plaintext
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"]]
输出：true 或 false，取决于是否能够填出正确的数独。
```

**答案解析：**
这个问题可以通过深度优先搜索（DFS）和回溯来解决。从第一个空格开始填数字，如果填入的数字合法，则继续填下一个空格。如果某个位置无法填数字，则回溯到上一个位置，尝试填入下一个数字。

**代码示例：**
```go
func solveSudoku(board [][]byte) bool {
    var dfs func(int, int) bool

    dfs = func(i int, j int) bool {
        if i == 9 {
            return true
        }
        if j == 9 {
            return dfs(i+1, 0)
        }
        if board[i][j] != 0 {
            return dfs(i, j+1)
        }

        for v := 1; v <= 9; v++ {
            c := byte(v + '0')
            if isValid(board, i, j, c) {
                board[i][j] = c
                if dfs(i, j+1) {
                    return true
                }
                board[i][j] = 0 // 回溯
            }
        }
        return false
    }

    return dfs(0, 0)
}

func isValid(board [][]byte, i int, j int, c byte) bool {
    // 检查行和列
    for k := 0; k < 9; k++ {
        if board[i][k] == c || board[k][j] == c {
            return false
        }
    }

    // 检查 3x3 宫格
    startI, startJ := i - i%3, j - j%3
    for k := 0; k < 3; k++ {
        for l := 0; l < 3; l++ {
            if board[startI+k][startJ+l] == c {
                return false
            }
        }
    }
    return true
}
```

#### 12. 单词搜索

**题目描述：** 给定一个二维网格和一个单词，编写一个函数来查找网格中单词是否出现。

**示例：**
```plaintext
输入：
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED"
输出：true

输入：
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "SEE"
输出：true

输入：
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCB"
输出：false
```

**答案解析：**
这个问题可以通过深度优先搜索（DFS）来解决。从每个未使用的单元格开始搜索，如果找到单词，则返回 `true`。如果遍历整个网格都没有找到，则返回 `false`。

**代码示例：**
```go
func exist(board [][]byte, word string) bool {
    rows, cols := len(board), len(board[0])
    visited := make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }

    var dfs func(int, int, int) bool
    dfs = func(i int, j int, k int) bool {
        if i < 0 || i >= rows || j < 0 || j >= cols || visited[i][j] || board[i][j] != word[k] {
            return false
        }
        if k == len(word)-1 {
            return true
        }
        visited[i][j] = true
        if dfs(i+1, j, k+1) ||
            dfs(i-1, j, k+1) ||
            dfs(i, j+1, k+1) ||
            dfs(i, j-1, k+1) {
            return true
        }
        visited[i][j] = false
        return false
    }

    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if dfs(i, j, 0) {
                return true
            }
        }
    }
    return false
}
```

#### 13. 合并区间

**题目描述：** 给你一个区间列表，请合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**答案解析：**
这个问题可以通过排序和合并区间来解决。首先将区间按起始位置排序，然后遍历排序后的区间，合并重叠的区间。

**代码示例：**
```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ans := make([][]int, 0)
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 14. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**示例：**
```plaintext
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

**答案解析：**
这个问题可以通过动态规划（DP）来解决。定义一个二维数组 `dp[i][j]`，表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。

**代码示例：**
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 15. 合并K个排序链表

**题目描述：** 给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，并返回合并后的链表。

**示例：**
```plaintext
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到 1->1->2->3->4->4->5->6
```

**答案解析：**
这个问题可以通过分治和归并的思想解决。使用一个优先队列（最小堆）来存储当前最小的链表节点，每次取出最小节点，将其值加入结果链表，并继续从该节点的下一个节点放入优先队列。

**代码示例：**
```go
type Node struct {
    Val  int
    Next *Node
}

func mergeKLists(lists []*Node) *Node {
    dummy := &Node{}
    curr := dummy
    heap := &priorityQueue{}
    for _, list := range lists {
        if list != nil {
            heap.push(list)
        }
    }
    for !heap.isEmpty() {
        node := heap.pop()
        curr.Next = node
        curr = curr.Next
        if node.Next != nil {
            heap.push(node.Next)
        }
    }
    return dummy.Next
}

type priorityQueue struct {
    heap []interface{}
}

func (q *priorityQueue) push(v interface{}) {
    q.heap = append(q.heap, v)
    siftUp(q, len(q.heap)-1)
}

func (q *priorityQueue) pop() interface{} {
    if len(q.heap) == 0 {
        return nil
    }
    v := q.heap[0]
    q.heap[0] = q.heap[len(q.heap)-1]
    q.heap = q.heap[:len(q.heap)-1]
    siftDown(q, 0)
    return v
}

func (q *priorityQueue) isEmpty() bool {
    return len(q.heap) == 0
}

func siftUp(q *priorityQueue, i int) {
    for {
        parent := (i - 1) / 2
        if q.heap[parent] > q.heap[i] {
            q.heap[parent], q.heap[i] = q.heap[i], q.heap[parent]
            i = parent
        } else {
            break
        }
    }
}

func siftDown(q *priorityQueue, i int) {
    for {
        left := 2*i + 1
        right := 2*i + 2
        smallest := i
        if left < len(q.heap) && q.heap[left] < q.heap[smallest] {
            smallest = left
        }
        if right < len(q.heap) && q.heap[right] < q.heap[smallest] {
            smallest = right
        }
        if smallest != i {
            q.heap[i], q.heap[smallest] = q.heap[smallest], q.heap[i]
            i = smallest
        } else {
            break
        }
    }
}
```

#### 16. 合并K个排序数组

**题目描述：** 给你一个整数数组 `nums`，其中每个元素代表一个数组，每个子数组都按升序排列，但元素的相对顺序未保证。请将它们合并为一个大的有序数组。

**示例：**
```plaintext
输入：nums = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：数组如下：
[
  [1,4,5],
  [1,3,4],
  [2,6]
]
将它们合并得到 [1,1,2,3,4,4,5,6]。
```

**答案解析：**
这个问题可以通过分治和归并的思想解决。首先将每个子数组分成更小的数组，然后递归合并这些小数组，最终合并得到一个大的有序数组。

**代码示例：**
```go
func mergeSortedArray(nums [][]int) []int {
    if len(nums) == 0 {
        return []int{}
    }
    mid := (len(nums) - 1) / 2
    left := mergeSortedArray(nums[:mid])
    right := mergeSortedArray(nums[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    ans := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            ans = append(ans, left[i])
            i++
        } else {
            ans = append(ans, right[j])
            j++
        }
    }
    ans = append(ans, left[i:]...)
    ans = append(ans, right[j:]...)
    return ans
}
```

#### 17. 最长公共子串

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子串的长度。

**示例：**
```plaintext
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子串是 "ace"，它的长度为 3。
```

**答案解析：**
这个问题可以通过动态规划（DP）来解决。定义一个二维数组 `dp[i][j]`，表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子串的长度。

**代码示例：**
```go
func longestCommonSubstr(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    ans := 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                ans = max(ans, dp[i][j])
            }
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 18. 买卖股票的最佳时机

**题目描述：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果有一天你决定买入这只股票，第二天你就决定卖出它，返回你能够获取的最大利润。

**示例：**
```plaintext
输入：prices = [7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**答案解析：**
这个问题可以通过一次遍历来解决问题。定义两个变量 `minPrice` 和 `maxProfit`，`minPrice` 用于记录到目前为止见过的最小价格，`maxProfit` 用于记录当前能获得的最大利润。

**代码示例：**
```go
func maxProfit(prices []int) int {
    minPrice, maxProfit := math.MaxInt32, 0
    for _, price := range prices {
        if price < minPrice {
            minPrice = price
        } else if price-minPrice > maxProfit {
            maxProfit = price - minPrice
        }
    }
    return maxProfit
}
```

#### 19. 有效的括号

**题目描述：** 给定一个包含大括号"{}"的字符串 `s` ，判断字符串是否有效。

**示例：**
```plaintext
输入：s = "()"
输出：true

输入：s = "()[]{}"
输出：true

输入：s = "(]"
输出：false
```

**答案解析：**
这个问题可以通过使用栈来解决。遍历字符串，遇到左括号入栈，遇到右括号时，检查栈顶元素是否匹配，不匹配则返回 `false`。

**代码示例：**
```go
func isValid(s string) bool {
    st := []rune{}
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    for _, v := range s {
        if v == '(' || v == '{' || v == '[' {
            st = append(st, v)
        } else if len(st) == 0 || m[v] != st[len(st)-1] {
            return false
        } else {
            st = st[:len(st)-1]
        }
    }
    return len(st) == 0
}
```

#### 20. 二进制求和

**题目描述：** 给定两个二进制字符串 `a` 和 `b` ，返回它们的和（用二进制表示）。

**示例：**
```plaintext
输入：a = "11", b = "1"
输出："100"

输入：a = "1010", b = "1011"
输出："10101"
```

**答案解析：**
这个问题可以通过模拟手工计算二进制加法的方法来解决。定义两个指针分别指向两个字符串的末尾，从后向前进行加法计算，并处理进位。

**代码示例：**
```go
func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    ans := []byte{}
    for i >= 0 || j >= 0 || carry > 0 {
        x := 0
        if i >= 0 {
            x += int(a[i] - '0')
            i--
        }
        y := 0
        if j >= 0 {
            y += int(b[j] - '0')
            j--
        }
        sum := x + y + carry
        carry = sum / 2
        ans = append(ans, byte((sum%2) + '0'))
    }
    if carry > 0 {
        ans = append(ans, byte(carry+'0'))
    }
    return reverseString(string(ans))
}

func reverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}
```

#### 21. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**示例：**
```plaintext
输入：s = "anagram", t = "nagaram"
输出：true

输入：s = "rat", t = "car"
输出：false
```

**答案解析：**
这个问题可以通过计数的方法解决。使用一个数组记录字符串 `s` 中每个字符的频率，然后遍历字符串 `t`，对数组中的值进行减法操作，如果数组中的所有值都为 0，则 `t` 是 `s` 的字母异位词。

**代码示例：**
```go
func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    count := [26]int{}
    for _, v := range s {
        count[v-'a']++
    }
    for _, v := range t {
        count[v-'a']--
        if count[v-'a'] < 0 {
            return false
        }
    }
    return true
}
```

#### 22. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**
这个问题可以通过递归或迭代的方式解决。递归方法每次比较两个链表的头部，选择较小的值添加到新链表中，并递归处理剩余部分。迭代方法使用两个指针分别指向两个链表，每次移动较小的值的指针。

**代码示例：**
递归方法：
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代方法：
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p1, p2 := l1, l2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            curr.Next = p1
            p1 = p1.Next
        } else {
            curr.Next = p2
            p2 = p2.Next
        }
        curr = curr.Next
    }
    curr.Next = p1 // 或者 p2
    return dummy.Next
}
```

#### 23. 缺少的数字

**题目描述：** 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出0..n 中没有出现在序列中的那个数。

**示例：**
```plaintext
输入：[3,0,1]
输出：2

输入：[9,6,4,2,3,5,7,0,1]
输出：8
```

**答案解析：**
这个问题可以通过哈希表的方法解决。首先将序列中的数字放入哈希表中，然后遍历哈希表，找出没有出现的数字。

**代码示例：**
```go
func missingNumber(nums []int) int {
    m := make(map[int]bool)
    for _, v := range nums {
        m[v] = true
    }
    for i := range m {
        if m[i+1] == false {
            return i + 1
        }
    }
    return 0
}
```

#### 24. 删除链表的节点

**题目描述：** 删除链表中给定的节点，即删除链表中第一个出现给定值节点。

**示例：**
```plaintext
输入：head = [4,5,1,9], val = 5
输出：[4,1,9]
解释：给定值是 5，只有节点 5 被删除。
```

**答案解析：**
这个问题可以通过模拟链表操作来解决。首先找到要删除的节点，然后将其前一个节点的 `Next` 指针指向要删除节点的后一个节点。

**代码示例：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

#### 25. 回文数

**题目描述：** 判断一个整数是否是回文数。回文数是指正反两个方向都相同的整数。

**示例：**
```plaintext
输入：x = 121
输出：true

输入：x = -121
输出：false
解释：从左到右读，应为 -121 。从右到左读，为其相反数 121。-121 与 121 相反，因此它不是一个回文数。

输入：x = 10
输出：false
解释：从右到左读，应为 01 。因此它不是一个回文数。
```

**答案解析：**
这个问题可以通过将整数转换为字符串，然后比较字符串的正反是否相同来解决。另外，可以通过数学方法，将整数反转并比较反转后的值与原值是否相同。

**代码示例：**
字符串方法：
```go
func isPalindrome(x int) bool {
    s := strconv.Itoa(x)
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        if s[i] != s[j] {
            return false
        }
    }
    return true
}
```

数学方法：
```go
func isPalindrome(x int) bool {
    if x < 0 || (x%10 == 0 && x != 0) {
        return false
    }
    revertedNumber, tmp := 0, x
    for tmp > 0 {
        revertedNumber = revertedNumber*10 + tmp%10
        tmp /= 10
    }
    return x == revertedNumber
}
```

#### 26. 三数之和

**题目描述：** 给你一个包含 n 个整数的数组 `nums`，判断是否存在三个元素 a，b，c 使得 `a + b + c = 0`？请你找出所有满足条件且不重复的三元组。

**示例：**
```plaintext
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案解析：**
这个问题可以通过排序和双指针的方法解决。首先对数组进行排序，然后遍历数组，对于每个元素，使用双指针方法查找另外两个元素。

**代码示例：**
```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, len(nums)-1
        for l < r {
            sum := nums[i] + nums[l] + nums[r]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[l], nums[r]})
                for l < r && nums[l] == nums[l+1] {
                    l++
                }
                for l < r && nums[r] == nums[r-1] {
                    r--
                }
                l++
                r--
            } else if sum < 0 {
                l++
            } else {
                r--
            }
        }
    }
    return ans
}
```

#### 27. 有效的山脉数组

**题目描述：** 给定一个整数数组 `arr` ，如果它是有效的山脉数组就返回 `true`，否则返回 `false`。

**示例：**
```plaintext
输入：arr = [2,1]
输出：false

输入：arr = [3,5,5]
输出：false

输入：arr = [0,3,2,1]
输出：true
```

**答案解析：**
这个问题可以通过遍历数组，寻找升序和降序的部分，并确保没有平坦的部分。

**代码示例：**
```go
func validMountainArray(arr []int) bool {
    n := len(arr)
    if n < 3 {
        return false
    }
    i := 0
    // 升序到最高点
    for i < n-1 && arr[i] < arr[i+1] {
        i++
    }
    // 最高点
    if i == 0 || i == n-1 {
        return false
    }
    // 降序
    for i < n-1 && arr[i] > arr[i+1] {
        i++
    }
    return i == n-1
}
```

#### 28. 盛水最多的容器

**题目描述：** 给你一个整数数组 `height` 表示容器的形状，计算容器的最大容量。

**示例：**
```plaintext
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：图中黄色部分是容器的最大容量。
```

**答案解析：**
这个问题可以通过双指针的方法解决。设置两个指针 `i` 和 `j` 分别指向数组的两端，每次移动较短的边，并更新最大容量。

**代码示例：**
```go
func maxArea(height []int) int {
    i, j := 0, len(height)-1
    maxArea := 0
    for i < j {
        maxArea = max(maxArea, min(height[i], height[j])*(j-i))
        if height[i] < height[j] {
            i++
        } else {
            j--
        }
    }
    return maxArea
}
```

#### 29. 搜索二维矩阵

**题目描述：** 编写一个高效的算法来搜索 `mx` x `my` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例：**
```plaintext
输入：
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
target = 5

输出：true

输入：
matrix = [
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
target = 20

输出：false
```

**答案解析：**
这个问题可以通过从矩阵的右上角或左下角开始搜索来解决。从右上角开始搜索时，如果当前元素大于目标值，则向下移动；如果当前元素小于目标值，则向左移动。从左下角开始搜索时，如果当前元素大于目标值，则向右移动；如果当前元素小于目标值，则向上移动。

**代码示例：**
从右上角开始搜索：
```go
func searchMatrix(matrix [][]int, target int) bool {
    rows, cols := len(matrix), len(matrix[0])
    i, j := 0, cols-1
    for i < rows && j >= 0 {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][j] > target {
            j--
        } else {
            i++
        }
    }
    return false
}
```

从左下角开始搜索：
```go
func searchMatrix(matrix [][]int, target int) bool {
    rows, cols := len(matrix), len(matrix[0])
    i, j := rows-1, 0
    for i >= 0 && j < cols {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][j] > target {
            i--
        } else {
            j++
        }
    }
    return false
}
```

#### 30. 分隔等和子集

**题目描述：** 给定一个非负整数数组 `nums` ，返回该数组能组成的所有非空子集的元素和的集合。如果不能形成任何和为 0 的子集，返回 []。题目数据保证答案符合 32 位整数范围。

**示例：**
```plaintext
输入：nums = [1, 2, 3]
输出：[0, 1, 3, 4, 6]

输入：nums = [1, 1, 1, 1, 1]
输出：[0, 1, 3, 5, 6, 7, 8]

输入：nums = [1, 2, 3, 6, 7]
输出：[0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

**答案解析：**
这个问题可以通过动态规划（DP）的方法解决。定义一个二维数组 `dp[i][j]` 表示从数组的前 `i` 个数字中选取若干个数字，使得它们的和为 `j` 是否可能。初始时 `dp[0][0] = true`，其余 `dp[i][0] = true`。

**代码示例：**
```go
func subsetsWithDup(nums []int) [][]int {
    sort.Ints(nums)
    n := len(nums)
    dp := make([][]bool, n+1)
    for i := range dp {
        dp[i] = make([]bool, 1<<n)
        dp[i][0] = true
    }
    for i, num := range nums {
        for j := 0; j < (1<<n); j++ {
            if dp[i][j] {
                dp[i+1][j|1<<i] = true
            }
        }
    }
    ans := [][]int{}
    for i, v := range dp[n] {
        if v {
            var t []int
            for j, mask := range nums {
                if i&(1<<j) > 0 {
                    t = append(t, mask)
                }
            }
            ans = append(ans, t)
        }
    }
    return ans
}
```

#### 31. 零钱兑换

**题目描述：** 给定不同面额的硬币和一个总金额。编写一个函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

**示例：**
```plaintext
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

输入：amount = 3, coins = [2]
输出：0
解释：只有两种面额的硬币（面额为 2），因此无法凑成总金额为 3。

输入：amount = 10, coins = [10]
输出：1
```

**答案解析：**
这个问题可以通过动态规划（DP）的方法解决。定义一个一维数组 `dp[i]` 表示凑成金额 `i` 的方法数。初始时 `dp[0] = 1`，其余 `dp[i] = 0`。

**代码示例：**
```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    dp[0] = 1
    for _, coin := range coins {
        for i := coin; i <= amount; i++ {
            dp[i] += dp[i-coin]
        }
    }
    if dp[amount] == 0 {
        return -1
    }
    return dp[amount]
}
```

#### 32. 最小路径和

**题目描述：** 给定一个包含非负整数的 `m x n` 网格。请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**示例：**
```plaintext
输入：grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

输入：grid = [
  [1,2,3],
  [4,5,6]
]
输出：12
```

**答案解析：**
这个问题可以通过动态规划（DP）的方法解决。定义一个二维数组 `dp[i][j]` 表示从左上角到 `(i, j)` 的最小路径和。初始时 `dp[0][0] = grid[0][0]`，其余 `dp[i][j] = grid[i][j]`。

**代码示例：**
```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 33. 搜索旋转排序数组

**题目描述：** 给你一个数组 `nums` ，该数组已按升序排列。给你一个整数 `target`，请你在该数组中查找一个 `target`，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1`。

**示例：**
```plaintext
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

输入：nums = [1], target = 0
输出：-1
```

**答案解析：**
这个问题可以通过二分查找的方法解决。与标准二分查找不同的是，需要找到旋转点的位置，然后分两段进行查找。

**代码示例：**
```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

#### 34. 粉刷房子

**题目描述：** 在一个正方形房间里，有三面墙，高度分别为 `h1`, `h2` 和 `h3`。你现在要给墙壁涂上油漆，涂料会涂满所有墙面，但不会涂到地面上。如果你涂的是白色涂料，需要花费 `cost1` 元；如果你涂的是绿色涂料，需要花费 `cost2` 元。你可以选择其中一种颜色涂一面墙，或者两面墙，或者三面墙。请返回最小花费。

**示例：**
```plaintext
输入：h1 = 2, h2 = 3, h3 = 4, cost1 = 15, cost2 = 10
输出：35
解释：选择颜色1涂一面墙，颜色2涂两面墙，总花费为 15 + 2*10 = 35。

输入：h1 = 2, h2 = 3, h3 = 4, cost1 = 6, cost2 = 15
输出：13
解释：选择颜色2涂三面墙，总花费为 3*15 = 45。选择颜色1涂一面墙，颜色2涂两面墙，总花费为 6 + 2*15 = 36。选择颜色1涂两面墙，颜色2涂一面墙，总花费为 2*6 + 15 = 27。最小的花费是 13。
```

**答案解析：**
这个问题可以通过动态规划（DP）的方法解决。定义一个二维数组 `dp[i][j]` 表示选择前 `i` 墙，涂了 `j` 面墙的最小花费。初始时 `dp[0][0] = 0`，其余 `dp[i][0] = dp[i-1][0]`。

**代码示例：**
```go
func minCost(h1 int, h2 int, h3 int, cost1 int, cost2 int) int {
    dp := make([][]int, 4)
    for i := range dp {
        dp[i] = make([]int, 4)
    }
    dp[0][0] = 0
    dp[1][1] = cost1 + cost2*2
    dp[1][2] = cost1*2 + cost2
    dp[1][3] = cost1*3
    dp[2][1] = cost2 + cost1*2
    dp[2][2] = cost2*2 + cost1
    dp[2][3] = cost2*3
    dp[3][1] = 2*cost2 + cost1
    dp[3][2] = 2*cost2 + cost1
    dp[3][3] = 3*cost2

    for i := 2; i < 4; i++ {
        for j := 1; j < 4; j++ {
            if i > j {
                dp[i][j] = math.MaxInt32
            } else {
                dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i-1][j-2]) + cost2*j
                if j > 1 {
                    dp[i][j] = min(dp[i][j], dp[i-1][j-3]+cost1)
                }
            }
        }
    }
    return dp[3][3]
}
```

#### 35. 二进制数转十进制数

**题目描述：** 给定一个字符串 `num` 表示一个二进制数，将其转换为十进制数并返回。如果二进制数无法转换为十进制数，返回 `-1`。

**示例：**
```plaintext
输入：num = "1101"
输出：13
解释：输入的二进制数 1101，按位权展开就是 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 13。

输入：num = "1010"
输出：-1
解释：无法仅使用 1010 转换得到一个有效的十进制整数。
```

**答案解析：**
这个问题可以通过字符串处理和数学方法解决。将字符串从右向左遍历，根据位权计算十进制数。如果遇到前导零，则返回 `-1`。

**代码示例：**
```go
func trailingZeroes(n int) int {
    ans := 0
    for n > 0 {
        n /= 5
        ans += n
    }
    return ans
}

func myAtoi(s string) int {
    neg := false
    ans := 0
    m := len(s)
    i := 0

    // 跳过前导空格
    for i < m && s[i] == ' ' {
        i++
    }

    // 判断符号
    if i < m && (s[i] == '+' || s[i] == '-') {
        neg = s[i] == '-'
        i++
    }

    // 跳过前导零
    for i < m && s[i] == '0' {
        i++
    }

    // 计算数字
    for i < m && (s[i] >= '0' && s[i] <= '9') {
        digit := int(s[i] - '0')
        if ans > (1<<31)/10 || (ans == (1<<31)/10 && digit > 7) {
            return neg ? math.MinInt32 : math.MaxInt32
        }
        ans = ans*10 + digit
        i++
    }

    return neg ? -ans : ans
}
```

#### 36. 旋转图像

**题目描述：** 给定一个 `n x n` 的二维矩阵 `matrix` 表示一个图像。请你将图像按顺时针旋转 90 度。

**示例：**
```plaintext
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**答案解析：**
这个问题可以通过分块旋转的方法解决。将矩阵按对角线分成四块，然后对每块进行旋转，最后将四块重新拼接到一起。

**代码示例：**
```go
func rotate(matrix [][]int) {
    n := len(matrix)
    // 对角线交换
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    // 水平翻转
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]
        }
    }
}
```

#### 37. 找出第 k 大元素

**题目描述：** 在未排序的数组中，找到第 `k` 大的元素。请注意，它通常是数组中第 `k` 大或第 `k` 小的元素。

**示例：**
```plaintext
输入：[3,2,1,5,6,4] 和 k = 2
输出：2
解释：第 2 大的元素是 5。

输入：[3,2,3,1,2,4,5,5,6] 和 k = 4
输出：4
解释：第 4 大的元素是 4。
```

**答案解析：**
这个问题可以通过快速选择算法解决。快速选择是一个类似于快速排序的选择算法，它选择一个随机索引 `pivot`，然后将数组分成两部分，大于 `pivot` 的元素和小于 `pivot` 的元素。如果 `pivot` 索引是 `k`，则返回 `pivot` 的值；如果 `pivot` 索引大于 `k`，则在小于 `pivot` 的部分中继续搜索；如果 `pivot` 索引小于 `k`，则在大于 `pivot` 的部分中继续搜索。

**代码示例：**
```go
func findKthLargest(nums []int, k int) int {
    n := len(nums)
    return quickSelect(nums, 0, n-1, n-k)
}

func quickSelect(nums []int, left, right, k int) int {
    pivotIndex := left + rand.Intn(right-left+1)
    pivotIndex = partition(nums, left, right, pivotIndex)
    if k == pivotIndex {
        return nums[k]
    } else if k < pivotIndex {
        return quickSelect(nums, left, pivotIndex-1, k)
    } else {
        return quickSelect(nums, pivotIndex+1, right, k)
    }
}

func partition(nums []int, left, right, pivotIndex int) int {
    pivotValue := nums[pivotIndex]
    nums[pivotIndex], nums[right] = nums[right], nums[pivotIndex]
    storeIndex := left
    for i := left; i < right; i++ {
        if nums[i] < pivotValue {
            nums[storeIndex], nums[i] = nums[i], nums[storeIndex]
            storeIndex++
        }
    }
    nums[right], nums[storeIndex] = nums[storeIndex], nums[right]
    return storeIndex
}
```

#### 38. 加一

**题目描述：** 给定一个整数数组 `digits`，每个元素都是在 0-9 范围内的数字。数组中的数字表示一个整数。对这个整数执行加一运算，并将结果返回。你不能使用任何关于默认值 0 或最大数字的库函数。

**示例：**
```plaintext
输入：digits = [1,2,3]
输出：[1,2,4]
解释：数组表示数字 123。

输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：数组表示数字 4321。
```

**答案解析：**
这个问题可以通过模拟手工加法的方法解决。从数组末尾开始，依次对数字加一，如果当前数字大于 9，则进位。如果所有数字都大于 9，则在数组开头添加一个 1。

**代码示例：**
```go
func plusOne(digits []int) []int {
    n := len(digits)
    for i := n - 1; i >= 0; i-- {
        if digits[i] < 9 {
            digits[i]++
            return digits
        }
        digits[i] = 0
    }
    return append([]int{1}, digits...)
}
```

#### 39. 合并两个有序链表

**题目描述：** 给定两个有序单链表 `l1` 和 `l2`，将它们合并为一个新的有序单链表并返回。新链表是通过拼接 `l1` 和 `l2` 的所有节点组成的。

**示例：**
```plaintext
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

**答案解析：**
这个问题可以通过递归或迭代的方法解决。递归方法每次比较两个链表的头部，选择较小的值添加到新链表中，并递归处理剩余部分。迭代方法使用两个指针分别指向两个链表，每次移动较小的值的指针。

**代码示例：**
递归方法：
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代方法：
```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    p1, p2 := l1, l2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            curr.Next = p1
            p1 = p1.Next
        } else {
            curr.Next = p2
            p2 = p2.Next
        }
        curr = curr.Next
    }
    curr.Next = p1 // 或者 p2
    return dummy.Next
}
```

#### 40. 合并区间

**题目描述：** 给你一个区间列表 `intervals`，请合并所有重叠的区间。

**示例：**
```plaintext
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠，将它们合并为 [1,6]。
```

**答案解析：**
这个问题可以通过排序和合并区间来解决。首先将区间按起始位置排序，然后遍历排序后的区间，合并重叠的区间。

**代码示例：**
```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ans := make([][]int, 0)
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 41. 存在重复元素

**题目描述：** 给定一个整数数组 `nums`，判断是否存在重复元素。

**示例：**
```plaintext
输入：nums = [1,2,3,1]
输出：true

输入：nums = [1,2,3,4]
输出：false

输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
```

**答案解析：**
这个问题可以通过哈希表的方法解决。遍历数组，将每个元素作为键放入哈希表中，如果元素已经存在于哈希表中，则返回 `true`。

**代码示例：**
```go
func containsDuplicate(nums []int) bool {
    m := make(map[int]bool)
    for _, v := range nums {
        if m[v] {
            return true
        }
        m[v] = true
    }
    return false
}
```

#### 42. 存在重复元素 II

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，判断数组中是否存在两个不同的索引 `i` 和 `j`，使得 `nums[i] == nums[j]` 并且 `|i - j| <= k`。

**示例：**
```plaintext
输入：nums = [1,2,3,1], k = 3
输出：true

输入：nums = [1,0,1,1], k = 1
输出：true

输入：nums = [1,2,3,4,5], k = 2
输出：false
```

**答案解析：**
这个问题可以通过哈希表的方法解决。遍历数组，对于每个元素 `nums[i]`，检查哈希表中是否存在 `nums[i]`，如果存在，则检查索引差是否小于等于 `k`。如果不存在，则将 `nums[i]` 和索引 `i` 存入哈希表。

**代码示例：**
```go
func containsNearbyDuplicate(nums []int, k int) bool {
    m := make(map[int]int)
    for i, v := range nums {
        if idx, ok := m[v]; ok && i-idx <= k {
            return true
        }
        m[v] = i
    }
    return false
}
```

#### 43. 存在重复元素 III

**题目描述：** 给定一个整数数组 `nums` 和两个整数 `m` 和 `t`。判断数组中是否存在两个索引 `i` 和 `j`，使得 `nums[i] == nums[j]`，并且 `|i - j| <= t`，同时 |nums[i] - nums[j]| <= m。

**示例：**
```plaintext
输入：nums = [99,99], m = 2, t = 2
输出：true

输入：nums = [1,5,9,1,5,9], m = 1, t = 2
输出：false

输入：nums = [1,2,3,4,5], m = 100, t = 100
输出：false
```

**答案解析：**
这个问题可以通过哈希表和滑动窗口的方法解决。首先遍历数组，对于每个元素 `nums[i]`，创建一个哈希表存储在 `[nums[i]-m, nums[i]+m]` 范围内的所有元素及其索引。然后遍历哈希表，检查是否存在索引差小于等于 `t` 的元素对。

**代码示例：**
```go
func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {
    m := make(map[int]int)
    for i, v := range nums {
        v1, v2 := v-m, v+m
        for _, j := range m {
            if abs(i-j) <= k && abs(v-j) <= t {
                return true
            }
        }
        m[v] = i
        if len(m) > k {
            delete(m, nums[i-k])
        }
    }
    return false
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

#### 44. 相同字母异位词

**题目描述：** 给定一个字符串数组 `words`，返回列表中的单词组合，其中单词组合中的字母可以按任意顺序排列。

**示例：**
```plaintext
输入：words = ["code", "doce", "ecod", "ice", "icod"]
输出：["code", "doce", "ecod", "ice", "icod"]

输入：words = ["abc", "ab", "cd", "efg", "abcd"]
输出：["abc", "abcd", "abc", "abcd", "cd", "efg"]

输入：words = ["abcd"]
输出：["abcd"]
```

**答案解析：**
这个问题可以通过哈希表的方法解决。遍历数组，对于每个单词，将其转换为排序后的字符串，并将排序后的字符串作为键放入哈希表中。如果哈希表中存在该键，则将原始单词加入结果列表。

**代码示例：**
```go
func groupAnagrams(words []string) []string {
    m := make(map[string][]string)
    for _, word := range words {
        sorted := sortString(word)
        m[sorted] = append(m[sorted], word)
    }
    ans := make([]string, 0, len(m))
    for _, v := range m {
        ans = append(ans, v...)
    }
    return ans
}

func sortString(s string) string {
    runes := []rune(s)
    sort.Slice(runes, func(i, j int) bool {
        return runes[i] < runes[j]
    })
    return string(runes)
}
```

#### 45. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```plaintext
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""

输入：strs = ["a"]
输出："a"

输入：strs = [""]
输出：[]
```

**答案解析：**
这个问题可以通过字符串比较来解决。从第一个字符串开始，依次与前一个字符串比较，取公共的前缀。

**代码示例：**
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

#### 46. 反转字符串

**题目描述：** 编写一个函数，其功能是将输入的字符串反转过来。

**示例：**
```plaintext
输入："hello"
输出："olleh"

输入："a"
输出："a"

输入： ""
输出： ""

输入："ab"
输出："ba"
```

**答案解析：**
这个问题可以通过将字符串转换为切片，然后使用双指针法反转字符串。

**代码示例：**
```go
func reverseString(s string) string {
    runes := []rune(s)
    n := len(runes)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}
```

#### 47. 最小移动次数使数组元素相等

**题目描述：** 给定一个整数数组 `nums`，找到一个最小移动次数数组元素相等的方法。每次移动可以选择任意元素并将该元素的值增加 `1` 或减少 `1`。

**示例：**
```plaintext
输入：nums = [1,2,3]
输出：2
解释：仅两次移动可以将数组转换为 [2,2,2]。

输入：nums = [1,4,2,5,3]
输出：3
解释：仅三次移动可以将数组转换为 [2,2,2,4,4]。

输入：nums = [1,2,3,6,5,4]
输出：6
解释：仅六次移动可以将数组转换为 [3,3,3,5,5,5]。
```

**答案解析：**
这个问题可以通过数学方法解决。计算数组的中位数，然后计算数组中每个元素到中位数的距离之和，即为所需的最小移动次数。

**代码示例：**
```go
func minMoves2(nums []int) int {
    sort.Ints(nums)
    mid := nums[len(nums)/2]
    ans := 0
    for _, v := range nums {
        ans += abs(v - mid)
    }
    return ans
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

#### 48. 最长重复子串

**题目描述：** 给定一个字符串 `s` ，找到其中最长的重复子串，输出其长度。

**示例：**
```plaintext
输入："banana"
输出：3
解释："ana" 是最长的重复子串。

输入："abcdabcdabcdabcdabcdabcdabcdabcde"
输出：9
解释："abcdabcdabcdabcdabcdabcdabcd" 是最长的重复子串。
```

**答案解析：**
这个问题可以通过二分查找和前缀函数的方法解决。使用二分查找找到重复子串的最长长度，使用前缀函数计算子串的前缀和。

**代码示例：**
```go
func longestRepeatingSubstring(s string) int {
    n := len(s)
    left, right := 0, n
    ans := -1
    for left <= right {
        mid := (left + right) / 2
        if check(s, mid) {
            ans = mid
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return ans
}

func check(s string, l int) bool {
    cnt := make(map[string]int)
    j := 0
    for i := 0; i < len(s); i++ {
        for j < l && i-j < len(s) {
            cnt[s[i-j:i]]++
            j++
        }
        if cnt[s[i-j:i]] > 1 {
            return true
        }
        cnt[s[i-j:i]] = 0
        j = 0
    }
    return false
}
```

#### 49. 多线程打印 1 到 n

**题目描述：** 有 `n` 个线程同时运行，每个线程 `thread[i]` 将会执行以下循环操作：

1. 线程 `thread[i]`执行循环操作中的第 `i` 次循环，则执行 `printNumber(i)` 。
2. `printNumber(i)` 函数会输出整数 `i`，然后递增 `i` 的值。

请设计一个可以获取最终输出序列的函数。

**示例：**
```plaintext
输入：n = 2
输出："11233"
解释：
第一个线程执行三次循环操作，将输出1、2、3。
第二个线程只执行一次循环操作，将只输出1。
因此最终输出为 "11233"。

输入：n = 5
输出："123454321"
```

**答案解析：**
这个问题可以通过原子操作和计数器来解决。每个线程在执行 `printNumber(i)` 之前检查当前线程是否是下一个要打印的线程，如果是，则打印该数字并递增计数器。

**代码示例：**
```go
var count int32 = 0

func printNumber(num int) {
    if atomic.CompareAndSwapInt32(&count, int32(num-1), int32(num)) {
        fmt.Printf("%d", num)
        if num != n {
            printNumber(num + 1)
        }
    }
}
```

#### 50. 缩小范围到原长

**题目描述：** 给定一个字符串 `s` 和一个字符 `t`。将 `s` 中所有的 `t` 缩小到原长度的 `1/2`。如果字符串的长度为偶数，则最后字符串的长度为奇数。

**示例：**
```plaintext
输入：s = "aaabccddd", t = "a"
输出："bddd"
解释：字符 'a' 缩小到原长度的 1/2，即删除第二个 'a'。
```

**答案解析：**
这个问题可以通过字符串操作和计数器来解决。遍历字符串，统计每个字符出现的次数，然后按照出现次数重新构造字符串。

**代码示例：**
```go
func shrinkString(s string, t byte) string {
    cnt := make(map[byte]int)
    for _, v := range s {
        cnt[v]++
    }
    ans := make([]byte, 0, len(s)/2)
    for v, c := range cnt {
        if v == t {
            continue
        }
        ans = append(ans, bytes.Repeat([]byte{v}, c/2)...)
    }
    return string(ans)
}
```

### 总结

通过以上对小米校招面试题和算法编程题的全方位解析，我们可以看到，这些题目覆盖了数组、链表、字符串、哈希表、排序、搜索、动态规划等多种数据结构和算法。每个题目的解析都包含了问题背景、题目描述、答案解析以及代码示例。这些解析可以帮助我们更好地理解和掌握这些题目，提高解决类似问题的能力。

在准备面试时，不仅要掌握这些题目，还要注意以下几点：

1. **理解题目要求：** 确保自己完全理解题目的要求，避免因为理解错误而导致的解题错误。
2. **选择合适的算法：** 根据题目的特点选择合适的算法和数据结构，如排序、搜索、动态规划等。
3. **代码优化：** 写出简洁、高效的代码，注意时间和空间的复杂度。
4. **面试技巧：** 面试时要注意沟通和表达，清晰地阐述自己的思路和算法。

希望这些解析对你备战小米校招面试有所帮助！祝你面试成功！🎉🎉🎉

