                 

### 1. 阿里巴巴面试题：字符串匹配算法（KMP算法）

**题目：** 实现字符串匹配算法（KMP算法），给定一个文本字符串 `s` 和一个模式字符串 `p`，找出 `s` 中所有 `p` 的出现位置。

**输入：**
- 文本字符串 `s`: `"ABABDABACDABABCABAB"`
- 模式字符串 `p`: `"ABABCABAB"`

**输出：**
- 所有匹配的位置：`[10, 11]`

**答案：**

```go
package main

import "fmt"

func computeLPSArray pat *[]byte, lps *[]int) {
    m := len(*pat)
    length := 0
    lps[0] = 0 // lps[0] is always 0
    i := 1

    for i < m {
        if (*pat)[i] == (*pat)[length] {
            length++
            lps[i] = length
            i++
        } else // (pat[i] != pat[len])
        {
            if length != 0 {
                length = lps[length - 1]
 
                // This also covers the case when pattern is an
                // empty string
            } else {
                lps[i] = 0
                i++
            }
        }
    }
}

func KMP(s, p string) []int {
    n := len(s)
    m := len(p)
    lps := make([]int, m)
    i := 0 // index for txt[]
    j := 0 // index for pat[]
 
    computeLPSArray(&p, &lps)
 
    result := make([]int, 0)
    for i < n {
        if p[j] == s[i] {
            i++
            j++
        }
 
        if j == m {
            //printf("Found pattern at index %d", i - j)
            result = append(result, i-j)
            j = lps[j - 1]
        }
 
        // mismatch after j matches
        else if j != 0 {
            j = lps[j - 1]
        } else
            i = i + 1
    }
 
    return result
}

func main() {
    s := "ABABDABACDABABCABAB"
    p := "ABABCABAB"
    res := KMP(s, p)
    fmt.Println("All occurrences of pattern are at", res)
}
```

**解析：** KMP算法是一种高效的字符串匹配算法，主要思想是避免字符串的重复比较。`computeLPSArray` 函数用于计算最长公共前后缀（LPS）数组，`KMP` 函数实现字符串匹配过程。

### 2. 百度面试题：最长公共子序列（LCS）

**题目：** 给定两个字符串 `s1` 和 `s2`，求它们的最长公共子序列（LCS）。

**输入：**
- 字符串 `s1`: `"ABCDGH"`
- 字符串 `s2`: `"AEDFHR"`

**输出：**
- 最长公共子序列：`"ADH"`


**答案：**

```go
package main

import "fmt"

func lcs(X, Y string) string {
    m, n := len(X), len(Y)
    L := make([]int, (m+1)*(n+1))

    for i := 0; i <= m; i++ {
        for j := 0; j <= n; j++ {
            if i == 0 || j == 0 {
                L[i*j] = 0
            } else if X[i-1] == Y[j-1] {
                L[i*j] = L[i-1 j-1] + 1
            } else {
                L[i*j] = max(L[i-1][j], L[i][j-1])
            }
        }
    }
 
    index := L[m*n]
    lcs := make([]byte, index+1)
    i, j := m, n
    for index > 0 {
        if X[i-1] == Y[j-1] {
            lcs[index] = X[i-1]
            i--
            j--
            index--
        } else if L[i-1][j] > L[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(lcs)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    X := "ABCDGH"
    Y := "AEDFHR"
    result := lcs(X, Y)
    fmt.Println("LCS is", result)
}
```

**解析：** 最长公共子序列（LCS）问题是一个动态规划问题，`lcs` 函数通过动态规划计算最长公共子序列的长度，并回溯求得最长公共子序列。

### 3. 腾讯面试题：合并两个有序链表

**题目：** 合并两个有序链表，假设链表中的元素都是整数。

**输入：**
- 链表1: `[1, 3, 5]`
- 链表2: `[2, 4, 6]`

**输出：**
- 合并后的链表：`[1, 2, 3, 4, 5, 6]`


**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5, Next: nil}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6, Next: nil}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 合并两个有序链表可以通过递归实现，每次比较两个链表的头节点，将较小的节点链接到结果链表中。

### 4. 字节跳动面试题：快速排序

**题目：** 实现快速排序算法，对数组进行排序。

**输入：**
- 数组：`[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`

**输出：**
- 排序后的数组：`[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]`

**答案：**

```go
package main

import "fmt"

func quicksort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quicksort(arr, low, pi-1)
        quicksort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}
    quicksort(arr, 0, len(arr)-1)
    fmt.Println(arr)
}
```

**解析：** 快速排序算法通过递归划分和排序实现，`quicksort` 函数用于递归调用，`partition` 函数用于划分数组。

### 5. 拼多多面试题：环形链表

**题目：** 判断一个链表是否为环形链表。

**输入：**
- 链表：`[1, 2, 3, 4]`，其中最后一个节点指向第一个节点。

**输出：**
- 是否为环形链表：`true`


**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    l1 := &ListNode{Val: 3, Next: &ListNode{Val: 2, Next: &ListNode{Val: 0, Next: &ListNode{Val: -4, Next: l1}}}}
    result := hasCycle(l1)
    fmt.Println("Is cycle present?", result)
}
```

**解析：** 使用快慢指针判断链表是否为环形链表，如果快指针能够追上慢指针，则链表为环形。

### 6. 京东面试题：二分查找

**题目：** 实现二分查找算法，在有序数组中查找一个目标值。

**输入：**
- 有序数组：`[-1, 0, 3, 5, 9, 12]`
- 目标值：`3`

**输出：**
- 目标值的位置：`2`（数组下标从0开始）

**答案：**

```go
package main

import "fmt"

func binarySearch(arr []int, target int) int {
    low := 0
    high := len(arr) - 1

    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return -1
}

func main() {
    arr := []int{-1, 0, 3, 5, 9, 12}
    target := 3
    result := binarySearch(arr, target)
    fmt.Println("Element is present at index", result)
}
```

**解析：** 二分查找算法通过不断缩小区间来查找目标值，每次比较中点元素，并根据比较结果调整查找区间。

### 7. 美团面试题：两个数组的交集

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，输出两个数组的交集。

**输入：**
- 数组 `nums1`: `[1, 2, 2, 1]`
- 数组 `nums2`: `[2, 2]`

**输出：**
- 交集：`[2, 2]`

**答案：**

```go
package main

import "fmt"

func intersection(nums1 []int, nums2 []int) []int {
    m := make(map[int]bool)
    result := make([]int, 0)
    for _, v := range nums1 {
        m[v] = true
    }
    for _, v := range nums2 {
        if m[v] {
            result = append(result, v)
            m[v] = false
        }
    }
    return result
}

func main() {
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    result := intersection(nums1, nums2)
    fmt.Println("Intersection:", result)
}
```

**解析：** 使用哈希表存储数组 `nums1` 的元素，然后遍历数组 `nums2`，查找交集元素。

### 8. 快手面试题：字符串转换大写

**题目：** 实现字符串转换大写的方法。

**输入：**
- 字符串：`"hello world"`

**输出：**
- 转换后的大写字符串：`HELLO WORLD`


**答案：**

```go
package main

import "fmt"

func toUpperCase(s string) string {
    b := []byte(s)
    for i, v := range b {
        if v >= 'a' && v <= 'z' {
            b[i] = v - 'a' + 'A'
        }
    }
    return string(b)
}

func main() {
    s := "hello world"
    result := toUpperCase(s)
    fmt.Println("Upper case:", result)
}
```

**解析：** 将字符串转换为字节切片，然后遍历每个字符，将小写字母转换为对应的
大写字母。

### 9. 滴滴面试题：最大子序和

**题目：** 给定一个整数数组 `nums`，找出数组中连续子数组的最大和。

**输入：**
- 数组 `nums`: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

**输出：**
- 最大子序和：`6`（子数组 `[4, -1, 2, 1]`）

**答案：**

```go
package main

import "fmt"

func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }

    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println("Maximum subarray sum:", result)
}
```

**解析：** 使用动态规划方法，每次更新当前子序列和，并与最大子序列和进行比较。

### 10. 小红书面试题：矩阵乘法

**题目：** 实现矩阵乘法。

**输入：**
- 矩阵 A：`[[1, 2], [3, 4]]`
- 矩阵 B：`[[5, 6], [7, 8]]`

**输出：**
- 矩阵乘积：`[[19, 22], [43, 50]]`

**答案：**

```go
package main

import "fmt"

func matrixMultiply(A, B [][]int) [][]int {
    rowsA, colsA := len(A), len(A[0])
    rowsB, colsB := len(B), len(B[0])

    if colsA != rowsB {
        return nil
    }

    C := make([][]int, rowsA)
    for i := 0; i < rowsA; i++ {
        C[i] = make([]int, colsB)
        for j := 0; j < colsB; j++ {
            sum := 0
            for k := 0; k < colsA; k++ {
                sum += A[i][k] * B[k][j]
            }
            C[i][j] = sum
        }
    }

    return C
}

func main() {
    A := [][]int{{1, 2}, {3, 4}}
    B := [][]int{{5, 6}, {7, 8}}
    result := matrixMultiply(A, B)
    fmt.Println("Matrix multiplication result:")
    for _, row := range result {
        fmt.Println(row)
    }
}
```

**解析：** 矩阵乘法使用三重循环实现，计算每个元素的乘积并求和。

### 11. 阿里巴巴面试题：最长公共前缀

**题目：** 给定多个字符串，找出它们的最长公共前缀。

**输入：**
- 字符串数组：`["flower", "flow", "flight"]`

**输出：**
- 最长公共前缀：`"fl"`

**答案：**

```go
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix); j++ {
            if j >= len(strs[i]) || prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("Longest common prefix:", result)
}
```

**解析：** 遍历字符串数组，逐步减少公共前缀的长度，直到找到最长公共前缀。

### 12. 百度面试题：链表反转

**题目：** 实现单链表的反转。

**输入：**
- 单链表：`1 -> 2 -> 3 -> 4 -> 5`

**输出：**
- 反转后的链表：`5 -> 4 -> 3 -> 2 -> 1`

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head

    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}

func main() {
    head := &ListNode{Val: 1}
    head.Next = &ListNode{Val: 2}
    head.Next.Next = &ListNode{Val: 3}
    head.Next.Next.Next = &ListNode{Val: 4}
    head.Next.Next.Next.Next = &ListNode{Val: 5}

    newHead := reverseList(head)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：** 通过迭代反转链表，将每个节点的 `Next` 指针指向前一个节点。

### 13. 腾讯面试题：最小栈

**题目：** 设计一个最小栈，支持 `push`、`pop` 和 `getMin` 操作。

**输入：**
- 操作序列：`["push", "push", "push", "push", "pop", "getMin", "push", "getMin", "pop", "getMin"]`
- 操作值：`[5, 7, 9, 2, 1, null, 10, null, 1, null]`

**输出：**
- 最小值序列：`[5, 5, 5, 2, 2, 2, 2, 2]`

**答案：**

```go
package main

import "fmt"

type MinStack struct {
    stack  []int
    minVal int
}

func Constructor() MinStack {
    return MinStack{stack: make([]int, 0)}
}

func (this *MinStack) Push(val int) {
    if len(this.stack) == 0 || val < this.minVal {
        this.minVal = val
    }
    this.stack = append(this.stack, val)
}

func (this *MinStack) Pop() {
    if this.stack[len(this.stack)-1] == this.minVal {
        this.stack = this.stack[:len(this.stack)-1]
        this.minVal = this.getMin()
    } else {
        this.stack = this.stack[:len(this.stack)-1]
    }
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minVal
}

func main() {
    obj := Constructor()
    obj.Push(5)
    obj.Push(7)
    obj.Push(9)
    obj.Push(2)
    obj.Pop()
    fmt.Println(obj.GetMin())
    obj.Push(10)
    fmt.Println(obj.GetMin())
    obj.Pop()
    fmt.Println(obj.GetMin())
}
```

**解析：** 使用辅助变量 `minVal` 记录当前最小值，在 `push` 和 `pop` 操作中更新最小值。

### 14. 字节跳动面试题：滑动窗口最大值

**题目：** 给定一个数组 `nums` 和一个整数 `k`，找到滑动窗口中的最大值。

**输入：**
- 数组 `nums`: `[1, 3, -1, -3, 5, 3, 6, 7]`
- `k`: `3`

**输出：**
- 滑动窗口最大值序列：`[3, 3, 5, 5, 6, 7]`

**答案：**

```go
package main

import "fmt"

func maxSlidingWindow(nums []int, k int) []int {
    queue := make([]int, 0)
    result := make([]int, 0)
    for i := 0; i < len(nums); i++ {
        for len(queue) > 0 && nums[i] >= nums[queue[len(queue)-1]] {
            queue = queue[:len(queue)-1]
        }
        if len(queue) > 0 {
            result = append(result, nums[queue[len(queue)-1]])
        }
        queue = append(queue, i)
        if i >= k-1 {
            queue = queue[1:]
        }
    }
    return result
}

func main() {
    nums := []int{1, 3, -1, -3, 5, 3, 6, 7}
    k := 3
    result := maxSlidingWindow(nums, k)
    fmt.Println(result)
}
```

**解析：** 使用双端队列维护当前窗口中的最大值。

### 15. 拼多多面试题：二进制表示中1的个数

**题目：** 计算一个整数的二进制表示中1的个数。

**输入：**
- 整数：`00000000000000000000000000001011`

**输出：**
- 1的个数：`3`

**答案：**

```go
package main

import "fmt"

func hammingWeight(n uint32) int {
    count := 0
    for n > 0 {
        count += int(n & 1)
        n >>= 1
    }
    return count
}

func main() {
    n := uint32(0b00000000000000000000000000001011)
    result := hammingWeight(n)
    fmt.Println("Number of 1s:", result)
}
```

**解析：** 使用位操作，将整数与1进行按位与操作，统计结果中的1的个数。

### 16. 京东面试题：爬楼梯

**题目：** 假设你正在爬楼梯。需要 `n` 阶才能到达楼顶，每次你可以爬 1 或 2 个台阶。给定一个整数 `n`，返回到达楼顶的方法数。

**输入：**
- `n`: `3`

**输出：**
- 方法数：`3`

**答案：**

```go
package main

import "fmt"

func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    a, b := 1, 2
    for i := 3; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }
    return b
}

func main() {
    n := 3
    result := climbStairs(n)
    fmt.Println("Number of ways:", result)
}
```

**解析：** 使用动态规划，通过递推公式计算方法数。

### 17. 美团面试题：两数相加

**题目：** 给定两个非空链表表示的两个非负整数，分别位于链表的头节点，计算它们的和并返回链表形式。

**输入：**
- 链表1：`[2, 4, 3]`
- 链表2：`[5, 6, 4]`

**输出：**
- 相加后的链表：`[7, 0, 8]`

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 3, Next: nil}}}
    l2 := &ListNode{Val: 5, Next: &ListNode{Val: 6, Next: &ListNode{Val: 4, Next: nil}}}
    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 使用链表模拟两个数相加的过程，处理进位。

### 18. 滴滴面试题：两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中两数之和等于 `target` 的那两个数，并返回他们的下标。

**输入：**
- 数组：`[2, 7, 11, 15]`
- 目标值：`9`

**输出：**
- 下标：`[0, 1]`（因为 `nums[0] + nums[1] == 9`）

**答案：**

```go
package main

import "fmt"

func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    result := twoSum(nums, target)
    fmt.Println("Indices:", result)
}
```

**解析：** 使用哈希表存储数组中的元素及其索引，遍历数组并查找补数。

### 19. 小红书面试题：最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**输入：**
- 字符串1：`"abcdf"`
- 字符串2：`"abcce"`

**输出：**
- 最长公共子串：`"abc"`

**答案：**

```go
package main

import "fmt"

func longestCommonSubstring(s1, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen, maxEnd := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    maxEnd = i
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return s1[maxEnd-maxLen : maxEnd]
}

func main() {
    s1 := "abcdf"
    s2 := "abcce"
    result := longestCommonSubstring(s1, s2)
    fmt.Println("Longest common substring:", result)
}
```

**解析：** 使用动态规划计算最长公共子串的长度，并回溯求得最长公共子串。

### 20. 阿里巴巴面试题：寻找两个正序数组的中位数

**题目：** 给定两个已排序的正序数组 `nums1` 和 `nums2`，找出它们的中位数。

**输入：**
- 数组 `nums1`: `[1, 3]`
- 数组 `nums2`: `[2]`

**输出：**
- 中位数：`2`

**答案：**

```go
package main

import "fmt"

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            // i is too big
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            // i is too small
            imin = i + 1
        } else {
            // Found partition
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := min(nums1[i], nums2[j])
            return float64(maxLeft+minRight) / 2.0
        }
    }
    return 0 // Not possible
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    nums1 := []int{1, 3}
    nums2 := []int{2}
    result := findMedianSortedArrays(nums1, nums2)
    fmt.Println("Median:", result)
}
```

**解析：** 使用二分查找的方法，在两个有序数组中找到中位数。

### 21. 百度面试题：两数之和 II - 输入有序数组

**题目：** 给定一个已按照升序排列的有序数组，找到两个数使得它们相加等于目标值。

**输入：**
- 数组：`[2, 7, 11, 15]`
- 目标值：`9`

**输出：**
- 结果：`[1, 2]`（因为 `nums[1] + nums[2] == 9`）

**答案：**

```go
package main

import "fmt"

func twoSum(numbers []int, target int) []int {
    m := make(map[int]int)
    for i, num := range numbers {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j + 1, i + 1}
        }
        m[num] = i
    }
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    result := twoSum(nums, target)
    fmt.Println("Indices:", result)
}
```

**解析：** 使用哈希表存储数组中的元素及其索引，遍历数组并查找补数。

### 22. 腾讯面试题：环形链表

**题目：** 给定一个链表，判断是否存在环。

**输入：**
- 链表：`[3, 2, 0, -4]`，其中最后一个节点指向第一个节点。

**输出：**
- 是否存在环：`true`

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    l1 := &ListNode{Val: 3, Next: &ListNode{Val: 2, Next: &ListNode{Val: 0, Next: &ListNode{Val: -4, Next: l1}}}}
    result := hasCycle(l1)
    fmt.Println("Cycle present?", result)
}
```

**解析：** 使用快慢指针判断链表是否存在环。

### 23. 字节跳动面试题：最长递增子序列

**题目：** 给定一个整数数组，找出最长递增子序列的长度。

**输入：**
- 数组：`[10, 9, 2, 5, 3, 7, 101, 18]`

**输出：**
- 最长递增子序列的长度：`4`（子序列 `[2, 3, 7, 101]`）

**答案：**

```go
package main

import "fmt"

func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    result := lengthOfLIS(nums)
    fmt.Println("Length of LIS:", result)
}
```

**解析：** 使用动态规划计算最长递增子序列的长度。

### 24. 拼多多面试题：最长公共前缀

**题目：** 给定多个字符串，找出它们的最长公共前缀。

**输入：**
- 字符串数组：`["flower", "flow", "flight"]`

**输出：**
- 最长公共前缀：`"fl"`

**答案：**

```go
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix); j++ {
            if j >= len(strs[i]) || prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("Longest common prefix:", result)
}
```

**解析：** 遍历字符串数组，逐步减少公共前缀的长度，直到找到最长公共前缀。

### 25. 京东面试题：合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：**
- 链表1：`[1, 2, 4]`
- 链表2：`[1, 3, 4]`

**输出：**
- 合并后的链表：`[1, 1, 2, 3, 4, 4]`

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: nil}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 使用递归合并两个有序链表。

### 26. 美团面试题：最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**输入：**
- 数组：`[100, 4, 200, 1, 3, 2]`

**输出：**
- 最长连续序列的长度：`4`（序列 `[1, 2, 3, 4]`）

**答案：**

```go
package main

import "fmt"

func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numsMap := make(map[int]bool)
    for _, num := range nums {
        numsMap[num] = true
    }
    longest := 1
    for num := range numsMap {
        if !numsMap[num-1] {
            current := num
            count := 1
            for numsMap[current+1] {
                current++
                count++
            }
            longest = max(longest, count)
        }
    }
    return longest
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{100, 4, 200, 1, 3, 2}
    result := longestConsecutive(nums)
    fmt.Println("Longest consecutive sequence length:", result)
}
```

**解析：** 使用哈希表存储数组中的元素，遍历数组并计算最长连续序列的长度。

### 27. 滴滴面试题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**输入：**
- 字符串1：`"ABCDGH"`
- 字符串2：`"AEDFHR"`

**输出：**
- 最长公共子序列：`"ADH"`

**答案：**

```go
package main

import "fmt"

func longestCommonSubsequence(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    result := ""
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            result = string(text1[i-1]) + result
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCDGH"
    text2 := "AEDFHR"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("Longest common subsequence:", result)
}
```

**解析：** 使用动态规划计算最长公共子序列的长度，并回溯求得最长公共子序列。

### 28. 小红书面试题：最长回文子串

**题目：** 给定一个字符串，找出其中最长的回文子串。

**输入：**
- 字符串：`"babad"`

**输出：**
- 最长回文子串：`"bab"` 或 `"aba"`（两个子串长度相等）

**答案：**

```go
package main

import "fmt"

func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start, maxLen := 0, 1
    for i := 0; i < len(s); i++ {
        len1 := expandAroundCenter(s, i, i)
        len2 := expandAroundCenter(s, i, i+1)
        len := max(len1, len2)
        if len > maxLen {
            start = i - (len - 1) / 2
            maxLen = len
        }
    }
    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    L, R := left, right
    for L >= 0 && R < len(s) && s[L] == s[R] {
        L--
        R++
    }
    return R - L - 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    s := "babad"
    result := longestPalindrome(s)
    fmt.Println("Longest palindromic substring:", result)
}
```

**解析：** 使用中心扩展算法寻找最长回文子串。

### 29. 阿里巴巴面试题：合并区间

**题目：** 给定一组区间，找出需要合并的区间。

**输入：**
- 区间数组：`[[1, 3], [2, 6], [8, 10], [15, 18]]`

**输出：**
- 合并后的区间：`[[1, 6], [8, 10], [15, 18]]`

**答案：**

```go
package main

import "fmt"

func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    result := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        last := result[len(result)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            result = append(result, intervals[i])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}
    result := merge(intervals)
    fmt.Println("Merged intervals:", result)
}
```

**解析：** 使用排序和贪心算法合并重叠的区间。

### 30. 百度面试题：填充空缺

**题目：** 给定一个由若干 0 和 1 组成的二维网格，找出需要填充的空缺位置，并将其填充为 0。

**输入：**
- 网格：`[[0,1,0],[1,1,1],[0,1,0]]`

**输出：**
- 填充后的网格：`[[0,1,0],[1,1,1],[0,1,0]]`

**答案：**

```go
package main

import "fmt"

func fillGrid(grid [][]int) [][]int {
    rows, cols := len(grid), len(grid[0])
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if grid[i][j] == 0 {
                grid[i][j] = 1
                fill(grid, i, j)
            }
        }
    }
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if grid[i][j] == 2 {
                grid[i][j] = 0
            }
        }
    }
    return grid
}

func fill(grid [][]int, i, j int) {
    rows, cols := len(grid), len(grid[0])
    grid[i][j] = 2
    if i+1 < rows && grid[i+1][j] == 1 {
        fill(grid, i+1, j)
    }
    if j+1 < cols && grid[i][j+1] == 1 {
        fill(grid, i, j+1)
    }
    if i-1 >= 0 && grid[i-1][j] == 1 {
        fill(grid, i-1, j)
    }
    if j-1 >= 0 && grid[i][j-1] == 1 {
        fill(grid, i, j-1)
    }
}

func main() {
    grid := [][]int{{0, 1, 0}, {1, 1, 1}, {0, 1, 0}}
    result := fillGrid(grid)
    fmt.Println("Flood filled grid:", result)
}
```

**解析：** 使用深度优先搜索填充空缺，并将其标记为 2，然后回填为 0。

通过以上详细的面试题解析和代码实例，你可以更全面地掌握国内一线大厂的面试考点和解决思路。这不仅能帮助你准备面试，还能提升你的编程能力。希望这个面试题库对你有所帮助！

