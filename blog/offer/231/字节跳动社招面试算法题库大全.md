                 

### 2025字节跳动社招面试算法题库大全

**一、算法基础**

### 1. 爬楼梯问题

**题目：** 一个楼梯有n级台阶，每次可以上一级或者上两级。请问有多少种上楼的方法？

**答案：** 这是一个典型的斐波那契数列问题。可以使用动态规划来解决这个问题。

```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 1
    for i in range(2, n):
        a, b = b, a + b
    return b
```

### 2. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**答案：** 可以使用归并排序的思想来解决这个问题。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

### 3. 最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：** 使用动态规划来解决这个问题。

```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

**二、数据结构**

### 1. 链表翻转

**题目：** 翻转一个单链表。

**答案：** 可以使用递归来解决这个问题。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    if not head or not head.next:
        return head
    p = reverseList(head.next)
    head.next.next = head
    head.next = None
    return p
```

### 2. 二叉搜索树

**题目：** 设计一个二叉搜索树。

**答案：** 可以使用递归来实现。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert(self.root, val)

    def _insert(self, node, val):
        if val < node.val:
            if node.left is None:
                node.left = TreeNode(val)
            else:
                self._insert(node.left, val)
        else:
            if node.right is None:
                node.right = TreeNode(val)
            else:
                self._insert(node.right, val)
```

### 3. 堆

**题目：** 实现一个最小堆。

**答案：** 使用数组来实现最小堆。

```python
import heapq

class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, val):
        heapq.heappush(self.heap, val)

    def pop(self):
        return heapq.heappop(self.heap)

    def isEmpty(self):
        return len(self.heap) == 0
```

**三、算法进阶**

### 1. 股票买卖

**题目：** 给定一个整数数组prices，其中每个元素代表了某一天股票的价格。设计一个算法来找出最大利润。你可以完成最多两笔交易。

**答案：** 使用动态规划来解决这个问题。

```python
def maxProfit(prices):
    if not prices:
        return 0
    dp = [[0] * 2 for _ in range(len(prices))]
    for i in range(1, len(prices)):
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
    return dp[-1][0]
```

### 2. 合并K个排序链表

**题目：** 给定K个排序链表，将它们合并为一个新的排序链表。请理解和实现一种分治算法。

**答案：** 使用分治算法来解决这个问题。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists):
    if not lists:
        return None
    while len(lists) > 1:
        temp = []
        for i in range(0, len(lists), 2):
            if i + 1 < len(lists):
                lists[i], lists[i + 1] = mergeTwoLists(lists[i], lists[i + 1])
            temp.append(lists[i])
        lists = temp
    return lists[0]
```

### 3. 搜索旋转排序数组

**题目：** 整数数组nums按升序排序，数组中的元素在 0 到 n - 1范围内。数组中可能存在 两个 重复的数字，但不影响判断。假设二分查找函数查找的区间是 nums[l..r]，以下情况适用该函数：

- l <= r：正常情况
- l > r：返回 -1
- m > r：在区间 [l..r] 中不存在符合条件的元素，返回 -1
- l == m == r：无论 m 的值是多少，都返回 -1，因为此时不存在有效的区间

在上述假设下，请实现二分查找函数 search(nums, target)，实现逻辑如下：

- 初始化 l、r、m 为 0、n - 1、(l + r) / 2。
- 当 l > r 时，返回 -1。
- 当 m > r 时，更新 l 为 m + 1，继续循环。
- 当 l == m == r 时，返回 -1。
- 当 nums[m] == target 时，返回 m。
- 当 nums[l] <= nums[m] 时，说明 [l..m] 是有序的。
  - 如果 nums[l] == target，返回 l。
  - 如果 nums[m] > target，更新 r 为 m - 1。
  - 否则，更新 l 为 m + 1。
- 当 nums[l] > nums[m] 时，说明 [m..r] 是有序的。
  - 如果 nums[r] == target，返回 r。
  - 如果 nums[m] < target，更新 l 为 m + 1。
  - 否则，更新 r 为 m - 1。
- 重复步骤 4~6，直到找到目标元素或确定其不存在。

**答案：** 使用二分查找算法来解决这个问题。

```python
def search(nums, target):
    l, r = 0, len(nums) - 1
    while l <= r:
        m = (l + r) // 2
        if nums[m] == target:
            return m
        if nums[l] <= nums[m]:
            if nums[l] <= target < nums[m]:
                r = m - 1
            else:
                l = m + 1
        else:
            if nums[r] >= target > nums[m]:
                l = m + 1
            else:
                r = m - 1
    return -1
```


**四、系统设计**

### 1. 设计微博系统

**题目：** 设计一个微博系统，支持以下功能：

- 关注/取消关注用户
- 发布微博
- 获取用户的关注列表
- 获取用户的粉丝列表
- 获取用户的微博列表（包括自己的微博和关注的微博）

**答案：** 设计一个微博系统需要考虑以下几个方面：

- 用户信息存储：可以使用关系型数据库存储用户信息，如用户ID、昵称、关注者列表、粉丝列表等。
- 微博信息存储：可以使用时间序列数据库存储微博信息，如微博ID、用户ID、内容、发布时间、点赞数、评论数等。
- 关注/取消关注操作：通过更新用户关注者列表和粉丝列表来实现。
- 发布微博：通过插入新的微博记录来实现。
- 获取关注列表、粉丝列表、微博列表：可以通过查询数据库来实现。

### 2. 设计一个在线购物系统

**题目：** 设计一个在线购物系统，支持以下功能：

- 商品展示
- 购物车管理
- 订单管理
- 支付管理
- 用户评论

**答案：** 设计一个在线购物系统需要考虑以下几个方面：

- 商品展示：可以使用前端框架（如Vue、React）展示商品列表，并通过API与后端进行交互。
- 购物车管理：可以在用户登录后，使用本地存储（如localStorage）或后端存储（如关系型数据库）存储购物车信息。
- 订单管理：可以使用关系型数据库存储订单信息，包括订单号、用户ID、商品列表、订单金额等。
- 支付管理：可以使用第三方支付平台（如支付宝、微信支付）进行支付，并接收支付结果。
- 用户评论：可以在用户登录后，使用后端存储（如关系型数据库）存储用户评论信息。

**五、编程实践**

### 1. 实现一个函数，将字符串中的所有空格替换为'%20'。

**题目：** 请实现一个函数，将字符串中的所有空格替换为`%20`。

**答案：** 可以使用双指针的方法来实现。

```python
def replaceSpaces(s: str, num: int) -> str:
    if not s:
        return ""
    s = list(s)
    write = len(s) - 1
    for c in s:
        if c == ' ':
            s[write:write+3] = ['%', '2', '0']
            write += 3
        else:
            s[write] = c
            write += 1
    return ''.join(s[write:])
```

### 2. 实现一个函数，计算字符串中单词的个数。

**题目：** 请实现一个函数，计算字符串中单词的个数。

**答案：** 可以使用计数器来实现。

```python
def countWords(s: str) -> int:
    count = 0
    for c in s:
        if c != ' ':
            count += 1
    return count
```

### 3. 实现一个函数，对数组进行快速排序。

**题目：** 请实现一个函数，对数组进行快速排序。

**答案：** 可以使用递归来实现快速排序。

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

