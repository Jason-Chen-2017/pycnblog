                 

### 华为2025届社招面试高频算法题解析

#### 1. 岛屿问题

**题目：** 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

**示例：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","1"],
  ["1","1","1","1","1"],
  ["0","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**答案：**

```go
func numIslands(grid [][]byte) int {
    m, n := len(grid), len(grid[0])
    vis := make([][]bool, m)
    for i := range vis {
        vis[i] = make([]bool, n)
    }
    var dfs func(i, j int)
    dfs = func(i, j int) {
        if i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0' || vis[i][j] {
            return
        }
        vis[i][j] = true
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    }
    ans := 0
    for i := range grid {
        for j := range grid[0] {
            if grid[i][j] == '1' && !vis[i][j] {
                dfs(i, j)
                ans++
            }
        }
    }
    return ans
}
```

**解析：** 采用深度优先搜索（DFS）算法，遍历整个网格，对于每个未访问的陆地（'1'），调用DFS函数，并计数。

#### 2. 最长回文子串

**题目：** 给你一个字符串 s，找到 s 中最长的回文子串。

**示例：**

```
输入：s = "babad"
输出："bab"
```

**答案：**

```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }
    start, maxLen := 0, 1
    for i := 0; i < len(s); i++ {
        // odd length
        left, right := i, i
        for left >= 0 && right < len(s) && s[left] == s[right] {
            if right - left + 1 > maxLen {
                maxLen = right - left + 1
                start = left
            }
            left--
            right++
        }
        // even length
        left, right = i, i+1
        for left >= 0 && right < len(s) && s[left] == s[right] {
            if right - left + 1 > maxLen {
                maxLen = right - left + 1
                start = left
            }
            left--
            right++
        }
    }
    return s[start : start+maxLen]
}
```

**解析：** 使用中心扩散法，对每个字符（作为奇数长度的中心）和字符间（作为偶数长度的中心）进行扩展，找到最长的回文子串。

#### 3. 三数之和

**题目：** 给你一个整数数组 nums ，判断是否存在三个数 nums[i] ，nums[j] 和 nums[k] 使得它们两两之和等于 0 。

**示例：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[0,-1,1],[-1,-1,2]]
```

**答案：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var ans [][]int
    n := len(nums)
    for i := 0; i < n; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, n-1
        for l < r {
            s := nums[i] + nums[l] + nums[r]
            if s < 0 {
                l++
            } else if s > 0 {
                r--
            } else {
                ans = append(ans, []int{nums[i], nums[l], nums[r]})
                for l < r && nums[l] == nums[l+1] {
                    l++
                }
                for l < r && nums[r] == nums[r-1] {
                    r--
                }
                l++
                r--
            }
        }
    }
    return ans
}
```

**解析：** 对数组进行排序，然后遍历每个元素，使用双指针法找到两个其他元素，使得三个元素之和为0。

#### 4. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 遍历字符串数组，每次与前一个字符串比较，找到公共前缀。

#### 5. 螺旋矩阵

**题目：** 给你一个 m x n 的矩阵，请你返回 按之字形顺序 接下来的矩阵的锯齿形排列。

**示例：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,2,3,6,9],[4,5,7,8],[9]]
```

**答案：**

```go
func generateMatrix(matrix [][]int) [][]int {
    if len(matrix) == 0 {
        return [][]int{}
    }
    m, n := len(matrix), len(matrix[0])
    ans := make([][]int, m)
    for i := range ans {
        ans[i] = make([]int, n)
    }
    s := 0
    t := 0
    num := 1
    for ; s < m && t < n; {
        for j := t; j < n; j++ {
            ans[s][j] = num
            num++
        }
        s++
        for i := s; i < m; i++ {
            ans[i][n-1] = num
            num++
        }
        n--
        for j := n - 1; j >= t; j-- {
            ans[m-1][j] = num
            num++
        }
        m--
        for i := m - 1; i >= s; i-- {
            ans[i][t] = num
            num++
        }
        t++
    }
    return ans
}
```

**解析：** 从矩阵的左上角开始，按照螺旋的路径进行填充。

#### 6. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回它的索引。如果目标值不存在于数组中，返回它应当被插入的位置。

**示例：**

```
输入：nums = [1,3,5,6], target = 5
输出：2
```

**答案：**

```go
func searchInsert(nums []int, target int) int {
    low, high := 0, len(nums)-1
    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return low
}
```

**解析：** 使用二分查找算法找到目标值或其应当被插入的位置。

#### 7. 打家劫舍

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

**示例：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 [1,3] [4] 可得到最大的盗窃值。
```

**答案：**

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    rob := make([]int, len(nums))
    rob[0], rob[1] = nums[0], nums[0]+nums[1]
    for i := 2; i < len(nums); i++ {
        rob[i] = max(rob[i-1], rob[i-2]+nums[i])
    }
    return rob[len(nums)-1]
}
```

**解析：** 动态规划，当前的最大盗窃值为前两个最大盗窃值中的最大值，加上当前房屋的现金。

#### 8. 爬楼梯

**题目：** 一个楼梯总共有 n 阶台阶，每级有 1 或 2 个台阶。要求：一个人每次可以爬 1 或 2 个台阶，要求计算有多少种方法可以爬到楼梯顶部。

**示例：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1+1+1
2. 1+2
3. 2+1
```

**答案：**

```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i < n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 使用动态规划，当前台阶数为前两个台阶数之和。

#### 9. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归合并两个有序链表。

#### 10. 整数转换中文大写

**题目：** 将一个整数转换成中文大写表示形式。

**示例：**

```
输入：2
输出："贰"
```

**答案：**

```go
var (
    zeroToNine  = []string{"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"}
    tenToNineteen = []string{"拾", "貳拾", "叁拾", "肆拾", "伍拾", "陆拾", "柒拾", "捌拾", "玖拾"}
    thousand     = []string{"", "万", "亿"}
)

func intToChinese(num int) string {
    if num == 0 {
        return zeroToNine[0]
    }
    res := []rune{}
    pos := 0
    for num > 0 {
        if num%10 != 0 {
            res = append(res, zeroToNine[num%10])
        } else {
            res = append(res, zeroToNine[num%10])
            if pos > 0 && pos%4 == 0 {
                res = append(res, "零")
            }
        }
        pos++
        num /= 10
    }
    for i := 0; i < len(thousand); i++ {
        if pos >= i*4 && pos < (i+1)*4 {
            res = append(res, thousand[i])
        }
    }
    if res[len(res)-1] == "零" {
        res = res[:len(res)-1]
    }
    reverse(res)
    return string(res)
}

func reverse(s []rune) {
    n := len(s)
    for i, j := 0, n-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

**解析：** 分解整数，依次取出每位数字，并拼接中文大写表示。

#### 11. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 遍历字符串数组，每次与前一个字符串比较，找到公共前缀。

#### 12. 搜索旋转排序数组

**题目：** 整数数组 nums 按升序排列，数组中的值 互不相同 。

在数组被修改后，原数组中的 [0,1] 分区： 

- 0 分区的范围为 [0, n - 1] 
- 1 分区的范围为 [n, m - 1]

请你编写算法，以便查找 nums 中的目标值 target ，并在数组中返回它的索引。如果目标值不存在于数组中，则返回 -1 。

**示例：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**答案：**

```go
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        m := (l + r) / 2
        if nums[m] == target {
            return m
        }
        // 0 分区
        if nums[l] <= nums[m] {
            // target 在 0 分区
            if nums[l] <= target && target < nums[m] {
                r = m - 1
            } else {
                l = m + 1
            }
        } else {
            // target 在 1 分区
            if nums[m] < target && target <= nums[r] {
                l = m + 1
            } else {
                r = m - 1
            }
        }
    }
    return -1
}
```

**解析：** 采用二分查找算法，判断 target 所在分区，调整二分区间。

#### 13. 字符串转换大写

**题目：** 使用内置函数将字符串转换为大写。

**示例：**

```
输入：str = "hello world"
输出："HELLO WORLD"
```

**答案：**

```go
func toUpperCase(str string) string {
    return strings.ToUpper(str)
}
```

**解析：** 使用 strings 包的 ToUpper 函数将字符串转换为大写。

#### 14. 字符串中第一个唯一字符

**题目：** 编写一个函数来查找字符串中的第一个唯一字符。

**示例：**

```
输入：s = "leetcode"
输出：2
解释：字符 'l' 在第二个位置上是唯一的。
```

**答案：**

```go
func firstUniqChar(s string) int {
    count := [26]int{}
    for _, v := range s {
        count[v-'a']++
    }
    for i, v := range s {
        if count[v-'a'] == 1 {
            return i
        }
    }
    return -1
}
```

**解析：** 使用数组记录字符出现次数，遍历字符串找到第一个出现一次的字符。

#### 15. 判断字符串是否是回文

**题目：** 编写一个函数来判断字符串是否是回文。

**示例：**

```
输入：s = "abba"
输出：true
```

**答案：**

```go
func isPalindrome(s string) bool {
    n := len(s)
    left, right := 0, n-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

**解析：** 使用双指针法比较字符串两端字符是否相同，遍历整个字符串。

#### 16. 字符串转换整数（atoi）

**题目：** 实现一个整数到字符串的转换函数，使其能正确处理包括负号、溢出等情况。

**示例：**

```
输入：str = "42"
输出："42"
```

**答案：**

```go
func myAtoi(s string) int {
    const (
        MinInt = -1 << 31
        MaxInt = 1<<31 - 1
    )
    sign, num, i := 1, 0, 0
    for i < len(s) && s[i] == ' ' {
        i++
    }
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        sign = 2
        i++
    }
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        digit := int(s[i] - '0')
        if num > (MaxInt-digit)/10 {
            if sign == 1 {
                return MaxInt
            }
            return MinInt
        }
        num = num*10 + digit
        i++
    }
    if sign == 2 {
        num = -num
    }
    return num
}
```

**解析：** 处理字符串中的空格、符号和数字，防止整数溢出。

#### 17. 寻找两个正序数组的中位数

**题目：** 给定两个大小分别为 m 和 n 的正序数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

**示例：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**答案：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i < m {
                minRight = nums1[i]
            }
            if j < n {
                minRight = min(minRight, nums2[j])
            }
            return float64(maxLeft+minRight) / 2
        }
    }
    return 0
}
```

**解析：** 二分查找法，寻找两个数组的中位数。

#### 18. 三数之和

**题目：** 给你一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

**示例：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var ans [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, len(nums)-1
        for l < r {
            s := nums[i] + nums[l] + nums[r]
            if s == 0 {
                ans = append(ans, []int{nums[i], nums[l], nums[r]})
                for l < r && nums[l] == nums[l+1] {
                    l++
                }
                for l < r && nums[r] == nums[r-1] {
                    r--
                }
                l++
                r--
            } else if s < 0 {
                l++
            } else {
                r--
            }
        }
    }
    return ans
}
```

**解析：** 先排序，然后固定一个元素，使用双指针法查找另外两个元素。

#### 19. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归合并两个有序链表。

#### 20. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，返回它们的 最长公共子序列 的长度。如果不存在共同的子序列，返回 0 。

**示例：**

```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划，构建一个二维数组记录最长公共子序列的长度。

#### 21. 爬楼梯

**题目：** 一个楼梯总共有 n 阶台阶，每级有 1 或 2 个台阶。要求：一个人每次可以爬 1 或 2 个台阶，要求计算有多少种方法可以爬到楼梯顶部。

**示例：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1+1+1
2. 1+2
3. 2+1
```

**答案：**

```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i < n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 使用动态规划，当前台阶数为前两个台阶数之和。

#### 22. 盛最多水的容器

**题目：** 给你一个整数数组 height ，表示一个容器的高度图。容器关闭的顶部是一条水平线。请你计算并返回在容器填满水的情况下，水能淹没的最小面积。

**示例：**

```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：如上图所示，容器中的水会达到蓝色线所示的高度。
容器里水的面积为 49。
```

**答案：**

```go
func minArea(height []int) int {
    l, r := 0, len(height)-1
    ans := 1 << 31 - 1
    for l < r {
        ans = min(ans, (r-l)*min(height[l], height[r]))
        if height[l] < height[r] {
            l++
        } else {
            r--
        }
    }
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 双指针法，找到左右两侧高度的最小值，计算面积，并更新答案。

#### 23. 买卖股票的最佳时机

**题目：** 给定一个整数数组 prices ，其中 prices[i] 是在 i 天内第 i 次买卖股票的价格。如果可以在第 i 天买入股票并选择在任意后续天内卖出该股票，则可以正好获得 prices[i] 的收益。返回你可以通过最多两笔交易获得的最多利润。

**示例：**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这能获得 3 的利润。
然后再在在第 7 天（股票价格 = 1）的时候买入，在第 8 天（股票价格 = 4）的时候卖出，这能获得 4 的利润。  
总利润为 6 + 4 = 10 。
```

**答案：**

```go
func maxProfit(prices []int) int {
    if len(prices) < 2 {
        return 0
    }
    maxProf := 0
    minPrice := prices[0]
    for i := 1; i < len(prices); i++ {
        maxProf = max(maxProf, prices[i]-minPrice)
        minPrice = min(minPrice, prices[i])
    }
    return maxProf
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 维护一个最小价格和一个最大利润，遍历数组计算最大利润。

#### 24. 翻转单词顺序

**题目：** 给你一个字符串 s ，请你反转字符串中 单词 的顺序。

**示例：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**答案：**

```go
func reverseWords(s string) string {
    var ans []rune
    for i := len(s) - 1; i >= 0; i-- {
        if s[i] == ' ' {
            if len(ans) > 0 {
                ans = append(ans, ' ')
            }
            continue
        }
        ans = append(ans, s[i])
    }
    if len(ans) > 0 && ans[len(ans)-1] == ' ' {
        ans = ans[:len(ans)-1]
    }
    for i, j := 0, len(ans)-1; i < j; i, j = i+1, j-1 {
        ans[i], ans[j] = ans[j], ans[i]
    }
    return string(ans)
}
```

**解析：** 从后往前遍历字符串，遇到空格则跳过，否则将字符添加到结果中，最后反转结果。

#### 25. 合并两个有序链表

**题目：** 给你两个按 非递减顺序 排列的链表 head1 和 head2 ，请你将它们合并为一个单链表，使得该链表同样按 非递减顺序 排列。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 递归合并两个有序链表。

#### 26. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 排序后合并重叠区间。

#### 27. 字符串相乘

**题目：** 给定两个字符串表示的非负整数 num1 和 num2，返回由它们相乘得到的整数的字符串表示。

**示例：**

```
输入：num1 = "123", num2 = "456"
输出："56088"
```

**答案：**

```go
func multiply(num1 string, num2 string) string {
    ans := make([]int, len(num1)+len(num2))
    for i := range num1 {
        for j := range num2 {
            ans[i+j+1] += (int(num1[i]-'0')) * (int(num2[j]-'0'))
            ans[i+j] += ans[i+j+1] / 10
            ans[i+j+1] %= 10
        }
    }
    n := len(ans)
    for ans[n-1] == 0 && n > 1 {
        n--
    }
    return string(ans[n:])
}
```

**解析：** 使用数组的每位数进行乘法运算，类似于小学的竖式乘法。

#### 28. 有效的括号字符串

**题目：** 给定一个只包含 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

**示例：**

```
输入："()"
输出：true
```

**答案：**

```go
func isValid(s string) bool {
    cnt := 0
    for _, v := range s {
        switch v {
        case '(':
            cnt++
        case ')':
            cnt--
        case '{':
            cnt += 2
        case '}':
            cnt -= 2
        case '[':
            cnt += 4
        case ']':
            cnt -= 4
        }
        if cnt < 0 {
            return false
        }
    }
    return cnt == 0
}
```

**解析：** 使用计数法，判断括号是否匹配。

#### 29. 电话号码的字母组合

**题目：** 给定一个字符串 digits ，每个字符代表一个从 2 到 9 的数字。返回所有它能表示的字母组合。

**示例：**

```
输入：digits = "23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
```

**答案：**

```go
var letterMap = map[rune][]string{
    '2': {"a", "b", "c"},
    '3': {"d", "e", "f"},
    '4': {"g", "h", "i"},
    '5': {"j", "k", "l"},
    '6': {"m", "n", "o"},
    '7': {"p", "q", "r", "s"},
    '8': {"t", "u", "v"},
    '9': {"w", "x", "y", "z"},
}

func letterCombinations(digits string) []string {
    if len(digits) == 0 {
        return []string{}
    }
    ans := []string{}
    letter := letterMap[rune(digits[0])]
    for _, l := range letter {
        ans = append(ans, l)
    }
    for i := 1; i < len(digits); i++ {
        letter = letterMap[rune(digits[i])]
        temp := []string{}
        for _, a := range ans {
            for _, b := range letter {
                temp = append(temp, a+b)
            }
        }
        ans = temp
    }
    return ans
}
```

**解析：** 使用哈希表存储每个数字对应的字母，递归生成所有可能的组合。

#### 30. 合并有序数组

**题目：** 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使得 nums1 成为一个有序数组。

**示例：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**解析：** 从尾部开始比较，将较大的元素放到数组的尾部。

### 总结

本文针对华为2025届社招面试中的一些高频算法题目，如岛屿问题、最长回文子串、三数之和等，给出了详细的解答和源代码实现。这些题目涵盖了排序、查找、动态规划等算法思想，是面试中常见的考点。通过掌握这些题目的解题方法，可以帮助你在华为的面试中取得更好的成绩。希望本文对你有所帮助！

