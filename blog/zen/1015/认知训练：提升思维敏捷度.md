                 

 

# 认知训练：提升思维敏捷度的面试题库与算法编程题库

## 一、面试题库

### 1. 如何实现一个带缓存的前缀和查询功能？

**题目：** 设计一个带有缓存的前缀和查询功能的数据结构，要求时间复杂度尽可能低。

**答案：** 可以使用线段树来实现。线段树是一种高效的数据结构，可以用来处理区间查询和修改问题，通过将区间分割成更小的区间，实现高效的区间查询。

**代码示例：**

```python
class SegmentTree:
    def __init__(self, nums):
        self.n = len(nums)
        self.tree = [0] * (2 * self.n)
        for i, v in enumerate(nums, start=1):
            self.tree[i + self.n - 1] = v
        for i in range(self.n - 1, 0, -1):
            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]

    def update(self, l, r, v):
        l += self.n - 1
        r += self.n - 1
        while l <= r:
            if l & 1 == 1:
                self.tree[l] += v
                l += 1
            if r & 1 == 0:
                self.tree[r] += v
                r -= 1
            l >>= 1
            r >>= 1

    def query(self, l, r):
        l += self.n - 1
        r += self.n - 1
        res = 0
        while l <= r:
            if l & 1 == 1:
                res += self.tree[l]
                l += 1
            if r & 1 == 0:
                res += self.tree[r]
                r -= 1
            l >>= 1
            r >>= 1
        return res
```

### 2. 如何快速查找字符串中两个模式的匹配？

**题目：** 给定两个字符串 `s` 和 `p`，设计一个算法找到 `s` 中所有与 `p` 匹配的子串。`p` 中包含两种模式：`*` 和 `?`，`*` 表示任意字符，`?` 表示任意一个字符。

**答案：** 可以使用有限自动机（Finite Automaton）来实现。有限自动机是一种用来识别字符串的模式匹配算法，通过构建一个状态机，可以高效地匹配字符串。

**代码示例：**

```python
class Solution:
    def findSubstring(self, s: str, p: str) -> List[str]:
        def build_automaton(pattern):
            n = len(pattern)
            state = [[False] * 128 for _ in range(n + 1)]
            state[0][ord(pattern[0])] = True
            for i in range(n - 1):
                for j in range(128):
                    state[i + 1][j] = state[i][j]
                state[i + 1][ord(pattern[i + 1])] = True
            return state

        n = len(s)
        t = build_automaton(p)
        ans = []
        j = 0
        for i in range(n):
            while j <= len(p) and (j == len(p) or ord(s[i]) != ord(p[j])):
                j = 0
                for k in range(128):
                    if t[j][k]:
                        j += 1
                        break
            while j <= len(p) and t[j][ord(s[i])]:
                j += 1
            if j == len(p):
                ans.append(i - len(p) + 1)
        return ans
```

### 3. 如何实现一个字典树？

**题目：** 实现一个字典树（Trie），支持插入和搜索功能。

**答案：** 字典树是一种基于树的数据结构，用于高效存储和查找字符串。每个节点代表一个字符，从根节点到叶子节点的路径表示一个字符串。

**代码示例：**

```python
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.is_end = False

    def insert(self, word: str) -> None:
        node = self
        for char in word:
            idx = ord(char) - ord('a')
            if node.children[idx] is None:
                node.children[idx] = Trie()
            node = node.children[idx]
        node.is_end = True

    def search(self, word: str) -> bool:
        node = self
        for char in word:
            idx = ord(char) - ord('a')
            if node.children[idx] is None:
                return False
            node = node.children[idx]
        return node.is_end
```

### 4. 如何实现LRU缓存？

**题目：** 实现一个LRU（Least Recently Used）缓存算法。

**答案：** LRU缓存是一种基于最近最少使用原则的缓存算法，可以使用哈希表和双向链表来实现。

**代码示例：**

```python
class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)
        self._add(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        elif len(self.cache) >= self.capacity:
            lru_key = self.head.next.key
            self._remove(self.head.next)
            del self.cache[lru_key]
        self.cache[key] = self._add(Node(key, value))

    def _remove(self, node):
        prev, next = node.prev, node.next
        prev.next = next
        next.prev = prev

    def _add(self, node):
        next = self.tail.prev
        self.tail.prev = node
        node.prev = next
        node.next = self.tail
        next.next = node
        return node
```

### 5. 如何实现一个有效的堆？

**题目：** 实现一个堆（Heap），支持插入、删除、获取最大值等功能。

**答案：** 堆是一种基于完全二叉树实现的数据结构，用于高效地获取最大值或最小值。可以使用数组来实现堆。

**代码示例：**

```python
class Heap:
    def __init__(self):
        self.heap = []
    
    def insert(self, val):
        self.heap.append(val)
        self._sift_up(len(self.heap) - 1)

    def delete(self):
        if len(self.heap) == 0:
            return None
        val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._sift_down(0)
        return val

    def get_max(self):
        if len(self.heap) == 0:
            return None
        return self.heap[0]

    def _sift_up(self, idx):
        parent = (idx - 1) // 2
        while idx > 0 and self.heap[parent] < self.heap[idx]:
            self.heap[parent], self.heap[idx] = self.heap[idx], self.heap[parent]
            idx = parent
            parent = (idx - 1) // 2

    def _sift_down(self, idx):
        left = 2 * idx + 1
        right = 2 * idx + 2
        largest = idx
        if left < len(self.heap) and self.heap[left] > self.heap[largest]:
            largest = left
        if right < len(self.heap) and self.heap[right] > self.heap[largest]:
            largest = right
        if largest != idx:
            self.heap[largest], self.heap[idx] = self.heap[idx], self.heap[largest]
            self._sift_down(largest)
```

### 6. 如何实现一个队列？

**题目：** 实现一个队列（Queue），支持入队、出队、获取队首等功能。

**答案：** 队列是一种先进先出（FIFO）的数据结构，可以使用数组或链表来实现。

**代码示例：**

```python
class Queue:
    def __init__(self):
        self.queue = []

    def enqueue(self, val):
        self.queue.append(val)

    def dequeue(self):
        if not self.is_empty():
            return self.queue.pop(0)
        return None

    def front(self):
        if not self.is_empty():
            return self.queue[0]
        return None

    def is_empty(self):
        return len(self.queue) == 0
```

### 7. 如何实现一个栈？

**题目：** 实现一个栈（Stack），支持入栈、出栈、获取栈顶等功能。

**答案：** 栈是一种后进先出（LIFO）的数据结构，可以使用数组或链表来实现。

**代码示例：**

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, val):
        self.stack.append(val)

    def pop(self):
        if not self.is_empty():
            return self.stack.pop()
        return None

    def top(self):
        if not self.is_empty():
            return self.stack[-1]
        return None

    def is_empty(self):
        return len(self.stack) == 0
```

### 8. 如何实现一个双端队列？

**题目：** 实现一个双端队列（Deque），支持在头部和尾部入队、出队等功能。

**答案：** 双端队列是一种可以在头部和尾部进行插入和删除操作的数据结构，可以使用数组或链表来实现。

**代码示例：**

```python
class Deque:
    def __init__(self):
        self deque = []

    def appendleft(self, val):
        self deque.insert(0, val)

    def append(self, val):
        self deque.append(val)

    def popleft(self):
        if not self.is_empty():
            return self deque.pop(0)
        return None

    def pop(self):
        if not self.is_empty():
            return self deque.pop()
        return None

    def is_empty(self):
        return len(self deque) == 0
```

### 9. 如何实现一个并查集？

**题目：** 实现一个并查集（Union-Find），支持合并和查询功能。

**答案：** 并查集是一种用于处理动态连通性问题的数据结构，可以通过路径压缩和按秩合并等优化算法来提高效率。

**代码示例：**

```python
class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, a, b):
        root_a = self.find(a)
        root_b = self.find(b)
        if root_a != root_b:
            if self.size[root_a] > self.size[root_b]:
                self.p[root_b] = root_a
                self.size[root_a] += self.size[root_b]
            else:
                self.p[root_a] = root_b
                self.size[root_b] += self.size[root_a]
```

### 10. 如何实现一个堆排序？

**题目：** 实现一个堆排序算法，用于对数组进行排序。

**答案：** 堆排序是一种基于堆的数据结构进行排序的算法。首先将数组构建成一个大顶堆，然后依次取出堆顶元素，并将剩余元素重新构建成大顶堆，直到堆为空。

**代码示例：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
```

### 11. 如何实现一个快速排序？

**题目：** 实现一个快速排序算法，用于对数组进行排序。

**答案：** 快速排序是一种分治算法，通过递归地将数组分成较小的子数组，并排序。

**代码示例：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)
```

### 12. 如何实现一个归并排序？

**题目：** 实现一个归并排序算法，用于对数组进行排序。

**答案：** 归并排序是一种分治算法，通过递归地将数组分成较小的子数组，并排序。

**代码示例：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])

    return result
```

### 13. 如何实现一个哈希表？

**题目：** 实现一个哈希表，支持插入、删除、查询等功能。

**答案：** 哈希表是一种基于哈希函数将键映射到数组索引的数据结构。可以使用数组存储键值对，通过哈希函数计算索引。

**代码示例：**

```python
class HashTable:
    def __init__(self):
        self.size = 1000
        self.table = [None] * self.size

    def _hash(self, key):
        return key % self.size

    def insert(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    self.table[index][i] = (key, value)
                    return
            self.table[index].append((key, value))

    def delete(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return False
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return True
        return False

    def get(self, key):
        index = self._hash(key)
        if self.table[index] is None:
            return None
        for k, v in self.table[index]:
            if k == key:
                return v
        return None
```

### 14. 如何实现一个二叉搜索树？

**题目：** 实现一个二叉搜索树，支持插入、删除、查询等功能。

**答案：** 二叉搜索树是一种特殊的二叉树，满足左子树中的所有节点都小于根节点，右子树中的所有节点都大于根节点。

**代码示例：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        self.root = self._insert(self.root, val)

    def _insert(self, node, val):
        if node is None:
            return TreeNode(val)
        if val < node.val:
            node.left = self._insert(node.left, val)
        elif val > node.val:
            node.right = self._insert(node.right, val)
        return node

    def delete(self, val):
        self.root = self._delete(self.root, val)

    def _delete(self, node, val):
        if node is None:
            return None
        if val < node.val:
            node.left = self._delete(node.left, val)
        elif val > node.val:
            node.right = self._delete(node.right, val)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            temp = self._get_min(node.right)
            node.val = temp.val
            node.right = self._delete(node.right, temp.val)
        return node

    def _get_min(self, node):
        while node.left:
            node = node.left
        return node

    def search(self, val):
        return self._search(self.root, val)

    def _search(self, node, val):
        if node is None:
            return False
        if val == node.val:
            return True
        elif val < node.val:
            return self._search(node.left, val)
        else:
            return self._search(node.right, val)
```

### 15. 如何实现一个链表？

**题目：** 实现一个链表，支持插入、删除、查询等功能。

**答案：** 链表是一种基于节点的数据结构，每个节点包含数据和指向下一个节点的指针。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, val):
        if not self.head:
            self.head = ListNode(val)
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = ListNode(val)

    def delete(self, val):
        if not self.head:
            return
        if self.head.val == val:
            self.head = self.head.next
            return
        current = self.head
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
                return
            current = current.next

    def search(self, val):
        current = self.head
        while current:
            if current.val == val:
                return True
            current = current.next
        return False
```

### 16. 如何实现一个栈排序？

**题目：** 实现一个栈，支持插入、删除、排序等功能。

**答案：** 栈是一种后进先出的数据结构，可以使用辅助栈来实现排序功能。

**代码示例：**

```python
class Stack:
    def __init__(self):
        self.stack = []
        self.temp_stack = []

    def push(self, val):
        self.temp_stack.append(val)
        while self.stack:
            self.stack.append(self.temp_stack.pop())
        self.stack.append(val)

    def pop(self):
        if not self.stack:
            return None
        val = self.stack.pop()
        while self.stack:
            self.temp_stack.append(self.stack.pop())
        return val

    def sort(self):
        while self.stack:
            self.temp_stack.append(self.stack.pop())
        self.temp_stack.sort()
        while self.temp_stack:
            self.stack.append(self.temp_stack.pop())
```

### 17. 如何实现一个队列排序？

**题目：** 实现一个队列，支持插入、删除、排序等功能。

**答案：** 队列是一种先进先出的数据结构，可以使用辅助栈来实现排序功能。

**代码示例：**

```python
class Queue:
    def __init__(self):
        self.queue = []
        self.temp_queue = []

    def enqueue(self, val):
        self.temp_queue.append(val)
        while self.queue:
            self.queue.append(self.queue.pop(0))
        self.queue.append(val)

    def dequeue(self):
        if not self.queue:
            return None
        val = self.queue.pop(0)
        while self.queue:
            self.temp_queue.append(self.queue.pop(0))
        return val

    def sort(self):
        while self.queue:
            self.temp_queue.append(self.queue.pop(0))
        self.temp_queue.sort()
        while self.temp_queue:
            self.queue.append(self.temp_queue.pop(0))
```

### 18. 如何实现一个快速幂算法？

**题目：** 实现一个快速幂算法，用于计算大整数幂。

**答案：** 快速幂算法是一种通过递归和循环来减少幂运算次数的算法。

**代码示例：**

```python
def quick_power(x, n):
    if n == 0:
        return 1
    if n % 2 == 0:
        return quick_power(x * x, n // 2)
    return x * quick_power(x * x, n // 2)
```

### 19. 如何实现一个最长公共前缀算法？

**题目：** 实现一个最长公共前缀算法，用于计算字符串数组中的最长公共前缀。

**答案：** 最长公共前缀算法可以通过比较字符串的字符来找出最长公共前缀。

**代码示例：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        while s[:len(prefix)] != prefix:
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

### 20. 如何实现一个最长公共子串算法？

**题目：** 实现一个最长公共子串算法，用于计算字符串中的最长公共子串。

**答案：** 最长公共子串算法可以通过动态规划来求解。

**代码示例：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    max_len = 0
    end_pos = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i - 1
            else:
                dp[i][j] = 0

    return s1[end_pos - max_len + 1: end_pos + 1]
```

### 21. 如何实现一个最长公共子序列算法？

**题目：** 实现一个最长公共子序列算法，用于计算两个序列中的最长公共子序列。

**答案：** 最长公共子序列算法可以通过动态规划来求解。

**代码示例：**

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

### 22. 如何实现一个最长递增子序列算法？

**题目：** 实现一个最长递增子序列算法，用于计算序列中的最长递增子序列。

**答案：** 最长递增子序列算法可以通过动态规划来求解。

**代码示例：**

```python
def longest_increasing_subsequence(nums):
    n = len(nums)
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

### 23. 如何实现一个最长不上升子序列算法？

**题目：** 实现一个最长不上升子序列算法，用于计算序列中的最长不上升子序列。

**答案：** 最长不上升子序列算法可以通过动态规划来求解。

**代码示例：**

```python
def longest_non_increasing_subsequence(nums):
    n = len(nums)
    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if nums[i] <= nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)
```

### 24. 如何实现一个最长公共子串算法？

**题目：** 实现一个最长公共子串算法，用于计算两个序列中的最长公共子串。

**答案：** 最长公共子串算法可以通过动态规划来求解。

**代码示例：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    max_len = 0
    end_pos = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 
``` 

[1. 如何实现一个带缓存的前缀和查询功能？](#1-如何实现一个带缓存的前缀和查询功能)
[2. 如何快速查找字符串中两个模式的匹配？](#2-如何快速查找字符串中两个模式的匹配)
[3. 如何实现一个字典树？](#3-如何实现一个字典树)
[4. 如何实现一个有效的堆？](#4-如何实现一个有效的堆)
[5. 如何实现一个队列？](#5-如何实现一个队列)
[6. 如何实现一个栈？](#6-如何实现一个栈)
[7. 如何实现一个双端队列？](#7-如何实现一个双端队列)
[8. 如何实现一个并查集？](#8-如何实现一个并查集)
[9. 如何实现一个堆排序？](#9-如何实现一个堆排序)
[10. 如何实现一个快速排序？](#10-如何实现一个快速排序)
[11. 如何实现一个归并排序？](#11-如何实现一个归并排序)
[12. 如何实现一个哈希表？](#12-如何实现一个哈希表)
[13. 如何实现一个二叉搜索树？](#13-如何实现一个二叉搜索树)
[14. 如何实现一个链表？](#14-如何实现一个链表)
[15. 如何实现一个栈排序？](#15-如何实现一个栈排序)
[16. 如何实现一个队列排序？](#16-如何实现一个队列排序)
[17. 如何实现一个快速幂算法？](#17-如何实现一个快速幂算法)
[18. 如何实现一个最长公共前缀算法？](#18-如何实现一个最长公共前缀算法)
[19. 如何实现一个最长公共子串算法？](#19-如何实现一个最长公共子串算法)
[20. 如何实现一个最长公共子序列算法？](#20-如何实现一个最长公共子序列算法)
[21. 如何实现一个最长递增子序列算法？](#21-如何实现一个最长递增子序列算法)
[22. 如何实现一个最长不上升子序列算法？](#22-如何实现一个最长不上升子序列算法)
[23. 如何实现一个最长公共子串算法？](#23-如何实现一个最长公共子串算法)
[24. 如何实现一个最长公共子序列算法？](#24-如何实现一个最长公共子序列算法)
[25. 如何实现一个最长递增子序列和？](#25-如何实现一个最长递增子序列和)
[26. 如何实现一个最长公共子串长度？](#26-如何实现一个最长公共子串长度)
[27. 如何实现一个最长公共子序列长度？](#27-如何实现一个最长公共子序列长度)
[28. 如何实现一个最长公共子序列？](#28-如何实现一个最长公共子序列)
[29. 如何实现一个最长公共子序列的不同排列数？](#29-如何实现一个最长公共子序列的不同排列数)
[30. 如何实现一个最长公共子序列的不同排列组合数？](#30-如何实现一个最长公共子序列的不同排列组合数)

## 二、算法编程题库

### 1. 最长公共前缀

给定一个字符串数组 `strs`，找到其中最长公共前缀。

示例 1：

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**思路：** 

使用分治算法，将字符串数组分为两半，比较两半的最长公共前缀，然后逐步缩小区间，直到找到最长公共前缀。

**代码实现：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        def check(mid):
            pre = ""
            for s in strs:
                if len(s) < mid:
                    return False
                if not s[:mid] == pre:
                    return False
                pre = s[:mid]
            return True

        left, right = 0, min(len(s) for s in strs)
        while left < right:
            mid = (left + right) // 2
            if check(mid):
                left = mid + 1
            else:
                right = mid
        return strs[0][:left]
```

### 2. 最长公共子串

给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子串。

示例 1：

```
输入：s1 = "abcde", s2 = "ace"
输出："ace"
```

**思路：**

使用动态规划，定义一个二维数组 `dp[i][j]` 表示 `s1[0..i]` 和 `s2[0..j]` 的最长公共子串的长度。

**代码实现：**

```python
class Solution:
    def longestCommonSubstring(self, s1: str, s2: str) -> str:
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_len = 0
        end_pos = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    if dp[i][j] > max_len:
                        max_len = dp[i][j]
                        end_pos = i - 1
                else:
                    dp[i][j] = 0
        return s1[end_pos - max_len + 1: end_pos + 1]
```

### 3. 最长公共子序列

给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子序列。

示例 1：

```
输入：s1 = "abcde", s2 = "ace"
输出："ace"
```

**思路：**

使用动态规划，定义一个二维数组 `dp[i][j]` 表示 `s1[0..i]` 和 `s2[0..j]` 的最长公共子序列的长度。

**代码实现：**

```python
class Solution:
    def longestCommonSubsequence(self, s1: str, s2: str) -> str:
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        return dp[m][n]
```

### 4. 最长递增子序列

给定一个整数数组 `nums`，返回其最长递增子序列的长度。

示例 1：

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。
```

**思路：**

使用动态规划，定义一个一维数组 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

**代码实现：**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

### 5. 最长连续序列

给定一个未排序的整数数组 `nums`，找到最长连续序列的长度。

示例 1：

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**思路：**

使用哈希表记录每个数字的出现次数，遍历数组，对于每个数字，判断其是否为最长连续序列的一部分，如果是，则更新最长连续序列的长度。

**代码实现：**

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        s = set(nums)
        ans = 0
        for v in nums:
            if v - 1 not in s:
                current = v
                while current in s:
                    current += 1
                ans = max(ans, current - v)
        return ans
```

### 6. 最小栈

设计一个支持 push，pop，top 操作，并能在常数时间内检索最小元素的栈。

示例：

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();     --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**思路：**

使用两个栈，一个栈 `stack` 存储所有元素，另一个栈 `minStack` 存储每个元素对应的最小值。

**代码实现：**

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.minStack or val <= self.minStack[-1]:
            self.minStack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.minStack[-1]:
            self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
```

### 7. 逆波兰表达式求值

给定一个逆波兰表达式（RPN）评估其值。

示例 1：

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：((2 + 1) * 3) = 9
```

**思路：**

使用栈模拟逆波兰表达式的求值过程，遍历表达式，遇到数字则入栈，遇到运算符则弹出栈顶两个元素进行运算，将结果入栈。

**代码实现：**

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token in "+-*/":
                b = stack.pop()
                a = stack.pop()
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                else:
                    stack.append(int(a / b))
            else:
                stack.append(int(token))
        return stack[0]
```

### 8. 合并两个有序链表

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

示例 1：

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**思路：**

使用两个指针分别遍历两个链表，比较当前节点值，将较小的节点值链接到新链表，然后移动对应指针。

**代码实现：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

### 9. 盛水

给定一个长度为 n 的整数数组 `height` 。有 n 条垂线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器能容纳的最大水量。

**示例 1：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组。[1,8,6,2,5,4,8,3,7] 表示高度。[0,8,0,0,4,0,8,0,2,0,5,0,3,0,7,0] 表示宽度。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。
```

**提示：**

- `2 <= height.length <= 3 * 104`
- `0 <= height[i] <= 3 * 104`

**思路：**

使用双指针法，从两边开始遍历，找到较短边的高度，计算当前容器的容积，更新最大容积，然后移动指针。

**代码实现：**

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l = 0
        r = len(height) - 1
        ans = 0
        while l < r:
            left, right = height[l], height[r]
            ans = max(ans, (right - left) * min(left, right))
            if left < right:
                l += 1
            else:
                r -= 1
        return ans
```

### 10. 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 `一个不重叠的区间集合，该集合需恰好覆盖输入中的所有区间。`

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可以合并为 [1,5].
```

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 109`
- `不存在重复区间`

**思路：**

将区间按照结束时间进行排序，然后遍历排序后的区间，判断当前区间是否与上一个区间重叠，如果重叠则合并区间。

**代码实现：**

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x: x[1])
        ans = []
        for interval in intervals:
            if not ans or ans[-1][1] < interval[0]:
                ans.append(interval)
            else:
                ans[-1][1] = max(ans[-1][1], interval[1])
        return ans
```

### 11. 最小栈

设计一个支持 push，pop，top 操作，并能在常数时间内检索最小元素的栈。

**示例：**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();     --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**思路：**

使用两个栈，一个栈存储所有元素，另一个栈存储每个元素对应的最小值。

**代码实现：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.minStack or val <= self.minStack[-1]:
            self.minStack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.minStack[-1]:
            self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]
```

### 12. 设计循环双端队列

设计你的循环双端队列实现。它应该支持以下操作：

- MyCircularDeque(k)：构造一个长度为 k 的循环双端队列。
- insertFront(): 将一个元素添加到队列的前端。
- insertLast(): 将一个元素添加到队列的后端。
- deleteFront(): 删除前端元素。
- deleteLast(): 删除后端元素。
- getFront(): 获取前端元素。
- getRear(): 获取后端元素。
- isEmpty(): 检查队列是否为空。
- isFull(): 检查队列是否已满。

**示例：**

```
MyCircularDeque k = new MyCircularDeque(3); // 设容量为3
k.insertLast(1);            // 返回 true
k.insertLast(2);            // 返回 true
k.insertFront(3);          // 返回 true
k.insertFront(4);          // 返回 false，因为队列已经满
k.getRear();               // 返回 2
k.isFull();                // 返回 true
k.deleteLast();            // 返回 true
k.deleteFront();           // 返回 true
k.getFront();              // 返回 3
```

**思路：**

使用一个循环数组来实现循环双端队列，用一个额外的变量 `head` 和 `tail` 来记录头尾的位置，避免出现空队列和满队列的情况。

**代码实现：**

```python
class MyCircularDeque:

    def __init__(self, k: int):
        self.queue = [0] * k
        self.head = 0
        self.tail = 0
        self.size = k

    def insertFront(self, value: int) -> bool:
        if self.isFull():
            return False
        self.head = (self.head - 1) % self.size
        self.queue[self.head] = value
        return True

    def insertLast(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % self.size
        return True

    def deleteFront(self) -> bool:
        if self.isEmpty():
            return False
        self.head = (self.head + 1) % self.size
        return True

    def deleteLast(self) -> bool:
        if self.isEmpty():
            return False
        self.tail = (self.tail - 1) % self.size
        return True

    def getFront(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.head]

    def getRear(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.tail - 1]

    def isEmpty(self) -> bool:
        return self.tail == self.head

    def isFull(self) -> bool:
        return (self.tail + 1) % self.size == self.head
```

