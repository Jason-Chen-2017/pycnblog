
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在MySQL中，字符串类型分为定长字符串(fixed-length string)和变长字符串(variable-length string)。本文将对两种字符串类型的存储方式进行探索，包括用B+树索引的方式存储定长字符串、用InnoDB引擎页表的row_format字段值blob来存储变长字符串。
# 2.基本概念术语说明
## 2.1 B+树索引
B+树索引是一种索引数据结构，用来快速查找磁盘上的数据。它是基于B树索引的一种优化版本，其索引文件具有更好的平衡性和查询性能。如下图所示：

## 2.2 InnoDB行存
InnoDB是一个支持事务的关系型数据库管理系统，其中所有的表都以行的形式存放，表中每个字段的值占用一个页（Page）空间。InnoDB引擎以聚集索引组织数据，每张表只能有一个聚集索引。由于其聚集索引，对于单条记录的检索，时间复杂度最低为O(1)，非常高效。而B+树索引则通过非聚集索引定位到目标行所在的位置，再根据具体字段值的大小进行搜索，时间复杂度从O(log n)到O(n)不等。因此，对于InnoDB存储引擎来说，默认推荐采用聚集索引。如果需要建立非聚集索引，可以手工指定。如下图所示：



# 3. 定长字符串的存储方法
## 3.1 CHAR 和 VARCHAR 的区别
CHAR 和 VARCHAR 是 MySQL 中定义字符串类型的两种方法。它们之间的区别主要在于可存储的最大长度不同。

- CHAR 类型会将列的长度固定为创建表时声明的长度，也就是说当插入的数据超过了 CHAR 类型设置的长度时，数据会被截断；
- VARCHAR 类型会将列的长度设置为最大能够存储该列所有字符所需的长度。

VARCHAR 类型最大优点是在存储短文本时内存消耗小。但当要存储的文本长度超过了 VARCHAR 列的最大长度时，就会出现“数据溢出”的问题，因为会自动分配额外的空间来保存这个数据。

## 3.2 使用 B+树索引存储定长字符串

假设我们有一张表 `t1` ，表中有两个字段：`id` 和 `name`。其中 `name` 为定长字符串，且长度为 32 个字节，即 `CHAR(32)` 。

为了加速查找 `name` 中的字符串，我们可以使用 B+树索引。我们知道，B+树索引的高度决定了索引的叶子节点的数量，越多的叶子节点意味着索引的查询速度越快，但同时也增加了索引文件的大小。

那么，怎样才能选择合适的 B+ 树高度呢？假设每个索引键值需要 4 个字节，我们把 `name` 的长度除以 4 得出的整数作为叶子节点的数量。如此计算，可得：

```
height = log2 (max key length / page size) - 1
```

比如 `name` 的最大长度为 32，页大小为 16 KB，则：

```
32 / 16KB * 1024 = height ≈ 1.8974358974358973
```

因此，我们可以认为 `name` 需要 2 层的 B+ 树索引。

另外，为了避免因 B+ 树的高度过高导致索引文件过大，应该尽量减少索引键值的长度，保证最佳的查询效率。

下面给出创建索引的 SQL 语句：

```sql
CREATE TABLE t1 (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name CHAR(32),
    INDEX idx_name (name) USING BTREE
);
```

这样，我们就可以使用如下 SQL 语句来进行查询：

```sql
SELECT * FROM t1 WHERE name='foo'; -- 用完整的名字精确匹配
SELECT * FROM t1 WHERE name LIKE 'foo%'; -- 模糊查询
```

# 4. 使用InnoDB页表的row_format字段值blob来存储变长字符串

InnoDB 支持三种页表格式：

- Compact: 以紧凑格式存储数据，仅仅存储真实数据，并且在页表中只保留主键和辅助索引的字段信息；
- Redundant: 以冗余格式存储数据，除了实际数据之外，还额外存储同一行数据的其他所有信息，包括隐藏的主键值和溢出页指针等；
- Dynamic: 动态格式页表兼顾了前两者的特性，也是默认的页表格式。

定长字符串一般采用 `CHAR(n)` 来存储，但是若 `n` 不足以容纳实际长度的字符串，则会发生截断或者溢出。因此，InnoDB 提供了一个叫作 `ROW_FORMAT` 的参数，用于控制页表的存储格式。

在 MySQL 5.7 中，`ROW_FORMAT=DYNAMIC` 表示启用动态页表格式，也就意味着允许不同长度的字段，采用不同的存储格式。

因此，我们可以通过设置 `ROW_FORMAT=DYNAMIC` 来达到存储变长字符串的方法。

假设我们有一张表 `t1`，表中有两个字段：`id` 和 `name`。其中 `name` 为变长字符串，且长度可变。

```sql
CREATE TABLE t1 (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) CHARSET utf8mb4 COLLATE utf8mb4_bin,
    INDEX idx_name (name) USING BTREE
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;
```

上面的语句创建了一个 InnoDB 表 `t1` ，设置了 `ROW_FORMAT=DYNAMIC`，并定义了一个 `VARCHAR(255)` 类型的字段 `name`。此时，MySQL 会按照字符串的实际长度来确定存储格式，并动态地分配相应的存储空间。

但是，这种方法会比直接采用 `CHAR(n)` 更占用更多的存储空间，所以一般情况下还是建议采用 `VARCHAR(n)` 来存储变长字符串。

# 5. 后续发展方向

虽然 InnoDB 默认采用动态页表格式，使得我们无需担心存储空间问题，但是在实际应用场景中还是需要考虑一些因素，比如：

1. 对比 B+ 树索引，动态页表格式下，普通索引的叶子节点存储的是主键，不会占用太多存储空间；
2. 如果某个列的编码比较长，可能无法压缩，导致占用的空间较大；
3. 大表可能出现页分裂，影响写入效率；

因此，在不同场景下，有不同的最佳方案。另外，定长字符串的索引方式仍然有效，可以使用 B+ 树索引来提升检索效率。