
作者：禅与计算机程序设计艺术                    

# 1.简介
  


数据库事务（Transaction）是一种为了访问并更新数据库中数据而进行的操作序列。它是一个不可分割的工作单位，事务必须是原子性、一致性和持久性的，如果其中任何一个属性不满足，则整个事务都不能执行。事务通常是通过BEGIN、COMMIT或ROLLBACK语句来启动、提交或回滚。

当多个用户并发地存取数据库时，就可能出现事务的omalous，即运行中的事务对数据库产生了影响，导致其他事务不能正确地执行。为了保证数据的一致性，数据库提供了四种事务隔离级别（Isolation Levels）。不同的隔离级别会影响到事务执行时读取的数据的一致性。

SQL标准定义了4个事务隔离级别：

1. Serializable（串行化）：这是最高的隔离级别，通过确保事务在同一时间内只由一个线程执行，避免了读-写冲突，但效率低下。

2. Repeatable Read（可重复读）：该级别会强制事务重新读取记录直至取得最新值，可以防止脏读、不可重复读、幻读。

3. Read Committed（读已提交）：该级别仅允许已经提交的事务对记录做查询，可以避免dirty read，但是仍可能发生phantom read。

4. Read Uncommitted（读未提交）：该级别不会验证事务的完整性，任何语句都可以被忽略，可能会导致脏读、幻读或不可重复读。

为了选择合适的隔离级别，开发人员需要根据自己的业务需求、应用场景、并发量等因素综合考虑。本文将阐述MySQL的默认隔离级别Repeatable Read以及MySQL实现这些隔离级别的方法。

# 2.基本概念和术语说明
## 2.1 事物与隔离性
### 2.1.1 事物
在关系型数据库管理系统中，事务(transaction)是一组数据库操作序列，要么全部成功，要么全部失败。事务具有4个属性，ACID特性。

**原子性(atomicity)**：事务是一个不可分割的工作单位，事务中包括的诸操作要么全部完成，要么全部不起作用；其对数据库修改，要么全部提交，要么全部撤销。

**一致性(consistency)**：一个事务应该只有在它所生效时才是一致的。一致性与原子性是密切相关的，因为一致性依赖于原子性。

**隔离性(isolation)**：事务的隔离性规定了不同的事务之间如何相互影响，以及一个事务内部的操作及时何时对其他事务可见。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

**持久性(durability)**：一个事务一旦提交，它对数据库中的数据的改变就是永久性的，接下来的其他操作或故障不会对其有任何影响。持续性与原子性、一致性和隔离性密切相关，持续性也依赖于原子性。

### 2.1.2 隔离性
在关系数据库中，隔离性是指当多个事务同时操纵相同的数据时，最终得到的结果一定是所有事务都完全串行执行时的结果。

要实现事务的隔离性，数据库管理系统采取了不同的隔离级别。

#### 2.1.2.1 读未提交隔离级别
这种隔离级别最大的问题是，可能存在 dirty read，也就是读到另一事务尚未提交的数据。Dirty read 的表现为另外一个事务可以看到该事务还没有提交的变更，这就要求用户在使用读未提交隔离级别时，必须非常小心。

#### 2.1.2.2 可重复读隔离级别
解决了脏读问题，但无法避免非重复读。也就是说，对于同一张表来说，前后两次执行同样的SELECT语句，可能返回不同的数据（即前一次读到的结果是后面又发生了更新后的结果），原因是SELECT语句执行过程涉及加锁。在InnoDB存储引擎中，默认使用可重复读隔离级别。

可重复读隔离级别可以通过 InnoDB 的 next-key locking 来解决。next-key locking 是行级锁的一个变种，当一个事务获得某行的读锁时，还会申请该行对应的gap（不存在的值）上的写锁，因此使得其他事务无法插入该行间隙内的数据，从而解决了幻读问题。

#### 2.1.2.3 读提交隔离级别
在读提交隔离级别下，一个事务只能看见已经提交的事务所做的改变，因此，一个事务的操作在提交之前对其他事务是不可见的。换句话说，一个事务要等待其他事务提交之后才能看见它的效果。这个隔离级别可以避免脏读、不可重复读和幻影读。但是，可能遇到不可重构的情况，例如：两个事务交叉执行，第二个事务回滚后，第一个事务就会看到未回滚的第二个事务所作的更新。

#### 2.1.2.4 串行化隔离级别
所有的事务都以排他方式执行，即串行化执行，直到结束才释放资源。串行化隔离级别可以防止并行事务带来的问题，因为在同一时间只允许一条线程执行。当然，它也降低了并发度。一般情况下，应用不会选择串行化隔离级别。

## 2.2 MyISAM与InnoDB
### 2.2.1 MyISAM与InnoDB的区别
- 数据文件:
  - MyISAM:.frm文件, 数据文件(.MYD), 索引文件(.MYI)。
  - InnoDB:. frm文件，数据文件(.idb)，索引文件(.idx)。
- 空间组织：
  - MyISAM: 每个表对应三个文件, 压缩表支持, 使用B+Tree作为索引结构。
  - InnoDB: 每个表对应两个文件, 不支持压缩表，使用B+ Tree作为索引结构，支持事务，外键。
- 事务支持：
  - MyISAM: 不支持事务.
  - InnoDB: 支持事务.
- Foreign Key约束：
  - MyISAM: 没有外键支持.
  - InnoDB: 支持外键.
- 其它差异：
  - 是否保存成本：MyISAM比InnoDB少保存一些数据。
  - 性能方面：MyISAM的查询速度快些，并且占用的内存较少；InnoDB则相反。
  - 自动崩溃恢复能力：MyISAM不支持崩溃恢复，必须执行repair table命令。

### 2.2.2 InnoDB为什么比MyISAM快？
InnoDB是在MySQL 5.5版本引入的新存储引擎，它的特点是支持事务处理、外键完整性约束等功能。相对于MyISAM，InnoDB在插入、删除和更新记录的时候，采用了聚集索引组织方式，从而可以避免全表扫描，提升查询效率。另外，InnoDB支持事物隔离机制，确保数据一致性。因此，它是应对复杂、高并发、高写入负载的最佳选择。

但是，由于InnoDB采用的是聚集索引组织方式，并且支持事物处理等功能，因此其插入、删除和更新记录时性能会相对差些。

所以，如果数据的一致性不是很重要或者实时性要求比较高，那么可以使用MyISAM来提升性能。