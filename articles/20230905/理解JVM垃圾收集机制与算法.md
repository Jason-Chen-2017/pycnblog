
作者：禅与计算机程序设计艺术                    

# 1.简介
  

随着互联网的兴起、应用软件的飞速发展和计算机的普及，数据越来越多，产生了海量的数据，这些数据需要在内存中存放。当这些数据不再被引用时就应该进行回收，避免它们占用过多的内存空间。

JVM（Java Virtual Machine） 是运行 Java 字节码的虚拟机，它负责执行编译后的 Java 程序并将其结果保存在内存中。但是当程序结束运行或者系统崩溃时，垃圾回收器便会回收那些没有被使用的对象。

垃圾回收是JVM管理堆内存中对象的生命周期的一项重要功能。因此，了解JVM垃圾回收的工作原理对我们的开发工作有着至关重要的作用。

# 2.JVM垃圾收集机制
## 2.1 概念阐述
JVM垃圾收集机制是JVM实现自动内存管理的一种方法。JVM基于不同的垃圾收集算法，通过特定算法对堆内存进行划分，并定义相应的时间点进行垃圾回收。

根据收集方式，JVM可分为两种类型：
- 1.并发式GC（Concurrent GC）：将堆内存划分为多个区域，多线程并行地进行垃圾收集。适用于高吞吐量的场景；
- 2.串行GC（Serial GC）：单线程顺序地进行垃圾收集。适用于低延迟、低吞吐量的场景。

## 2.2 对象死亡判定规则
在JVM中，所有的对象都具备可达性（Reachability）特性。对于GC来说，只有一个根集的情况下，才能对所有对象进行可达性分析。

判断对象是否死亡的主要依据是两种：
- a) 如果从GC Roots到这个对象不可达，则该对象一定是死亡的。例如，如果一个对象的字段指向另一个对象，而后者又引用了一个第三个对象，如果GC Roots不能直接到达第三个对象，则前两个对象也将被判定为死亡的。
- b) 从Minor GC开始，若回收器确定某对象周围的存活比例小于某个阈值，则认为该对象存活率较高，可能成为老年代的一部分。若判断该对象能够晋升到老年代，则需要检查其是否仍然满足存活条件。对于Minor GC，若一个对象要晋升到老年代，则它的大小和被引用的次数都比较敏感。

## 2.3 Minor GC与Full GC
Minor GC(Young Generation GC)：指发生在新生代的垃圾回收。Young Generation GC是一个非常频繁的操作，一般每隔几百毫秒触发一次Minor GC，每次GC都会清除掉新生代垃圾最多的部分。

Full GC(Major Generation GC)：指发生在老年代或整个堆的垃圾回收。当老年代空间不足，触发Major GC的时候，JVM就会停止所有应用线程并执行Full GC。Full GC的成本很高昂，所以尽量减少Full GC的次数。一般来说，每隔上万次Minor GC才进行一次Major GC。

# 3.JVM垃圾收集算法
JVM提供了不同的垃圾收集算法，包括标记-清除、复制、标记-整理、分代回收等，下面逐一介绍：

## 3.1 标记-清除算法(Mark Sweep Algorithm)
该算法分为“标记”和“清除”两个阶段:首先遍历所有对象，标记出需要删除的对象，然后统一回收掉标记的所有对象。缺点是效率不稳定，执行过程中会产生很多内存碎片。

## 3.2 复制算法(Copying Algorithm)
该算法把内存分为两块相同的大小，每次只使用其中的一块，当这一块内存用完时，将还存活的对象复制到另一块上面。由于对象都是同样的内存大小，所以这种方式不会出现内存碎片的问题。缺点是浪费了一半的内存空间。

## 3.3 标记-整理算法(Mark Compact Algorithm)
和标记-清除算法不同的是，在标记完成之后不是直接回收内存，而是让所有存活的对象向一端移动，然后直接清理掉边界以外的内存。

## 3.4 分代回收算法(Generational Garbage Collection)
为了提高效率，JVM将堆内存分成三个部分——年轻代（Young Generation），中期代（Mid Generation），老年代（Old Generation）。对象优先在年轻代分配，当年轻代内存不够用时，将发生Minor GC，将没有被引用的对象移到中期代，再经历一次Minor GC，若还是存活，就将移到老年代；当老年代内存不够用时，进行Major GC。

在实际项目开发中，通常使用混合型垃圾回收器，即同时使用上面介绍的三种GC算法。