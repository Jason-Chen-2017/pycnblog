                 

### 2024京东社招面试算法题库大全

本文将针对京东社招面试中的算法题库进行详细解析，涵盖了数据结构、算法、系统设计等多个方面，旨在帮助准备面试的读者更好地理解和掌握相关知识点。

#### 题目1：链表反转

**题目描述：** 编写一个函数，实现单链表反转。

**答案解析：**

单链表反转可以通过遍历链表，使用三个指针变量分别记录当前节点、前一个节点和后一个节点，依次调整节点指针指向，最后返回反转后的链表头节点。

```go
func reverseList(head *ListNode) *ListNode {
    var prev, curr *ListNode = nil, head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

#### 题目2：二分查找

**题目描述：** 实现一个二分查找函数，用于在一个有序数组中查找一个目标值。

**答案解析：**

二分查找算法的时间复杂度为 \(O(\log n)\)，可以通过不断将查找范围缩小一半来实现。

```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

#### 题目3：字符串匹配

**题目描述：** 实现一个字符串匹配函数，支持 KMP 算法。

**答案解析：**

KMP 算法通过构建部分匹配表（Next数组）来避免重复比较，实现高效的字符串匹配。

```go
func KMP(s string, p string) int {
    n, m := len(s), len(p)
    next := make([]int, m)
    j := -1
    for i := 0; i < m; {
        if j == -1 || p[i] == p[j] {
            i++
            j++
            next[i] = j
        } else {
            j = next[j]
        }
    }
    i = 0
    j = 0
    for i < n {
        if j == -1 || s[i] == p[j] {
            i++
            j++
        } else {
            j = next[j]
        }
        if j == m {
            return i - j
        }
    }
    return -1
}
```

#### 题目4：爬楼梯

**题目描述：** 一只青蛙一次可以跳上1级或2级台阶，求该青蛙跳上n级台阶的总数。

**答案解析：**

可以使用动态规划求解，定义 dp[i] 为青蛙跳上第 i 级台阶的总数。

```go
func climbStairs(n int) int {
    if n == 1 || n == 2 {
        return n
    }
    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

#### 题目5：最长公共子序列

**题目描述：** 给定两个字符串，求它们的最长公共子序列。

**答案解析：**

可以使用动态规划求解，定义 dp[i][j] 为字符串 s1 的前 i 个字符与字符串 s2 的前 j 个字符的最长公共子序列长度。

```go
func longestCommonSubsequence(s1 string, s2 string) int {
    n, m := len(s1), len(s2)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[n][m]
}
```

#### 题目6：打家劫舍

**题目描述：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你的是相邻的房屋装有相互连通的防盗系统。计算你在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**答案解析：**

可以使用动态规划求解，定义 dp[i] 为考虑前 i 间房屋能够偷窃到的最高金额。

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, nums[0]
    dp[2] = max(nums[1], nums[2])
    for i := 3; i <= n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])
    }
    return dp[n]
}
```

#### 题目7：合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案解析：**

可以使用递归或迭代的方法合并两个链表。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 题目8：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度（不要求序列元素在原数组中连续）。

**答案解析：**

可以使用哈希表记录每个数字的前一个数字和后一个数字，然后遍历数组，计算最长连续序列的长度。

```go
func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := map[int]bool{}
    for _, num := range nums {
        numSet[num] = true
    }
    longest := 0
    for num := range numSet {
        if !prevExists(num-1) {
            curr := num
            length := 1
            for nextExists(curr+1) {
                curr++
                length++
            }
            longest = max(longest, length)
        }
    }
    return longest
}

func prevExists(num int) bool {
    _, exists := m[num]
    return exists
}

func nextExists(num int) bool {
    _, exists := m[num]
    return exists
}
```

#### 题目9：最小栈

**题目描述：** 设计一个支持 push ，pop ，top 操作的栈。

```go
type MinStack struct {
    Stack []int
    MinStack []int
}

/** initialize your data structure here. */
func Constructor() MinStack {
    return MinStack{[]int{}, []int{}}
}

func (this *MinStack) Push(val int) {
    this.Stack = append(this.Stack, val)
    if len(this.MinStack) == 0 || val <= this.MinStack[len(this.MinStack)-1] {
        this.MinStack = append(this.MinStack, val)
    }
}

func (this *MinStack) Pop() {
    if this.Stack[len(this.Stack)-1] == this.MinStack[len(this.MinStack)-1] {
        this.MinStack = this.MinStack[:len(this.MinStack)-1]
    }
    this.Stack = this.Stack[:len(this.Stack)-1]
}

func (this *MinStack) Top() int {
    return this.Stack[len(this.Stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.MinStack[len(this.MinStack)-1]
}
```

#### 题目10：合并区间

**题目描述：** 以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组必须按区间端点升序排列。

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] != intervals[j][0] {
            return intervals[i][0] < intervals[j][0]
        }
        return intervals[i][1] < intervals[j][1]
    })

    ans := make([][]int, 0, len(intervals))
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

#### 题目11：环形数组最大分数

**题目描述：** 给你一个大小为 n 的整数数组 nums ，以及两个整数 lower 和 upper 。两个数组的 分数分别是：

* 数组 nums 的分数等于数组 nums 中满足 lower <= nums[i] <= upper 的元素数目。
* 数组 nums 分数最大为 maxScore。
* 数组 nums 的分数字数最大为 maxPoints。

在遍历数组 nums 的同时，你需要实现一个算法来找到 分数最大且分数字数 最多的 下标组合 。如果存在多个这样的下标组合，请你按数组形式 [t, k] 返回。t 是分数字数最多的下标点，k 是该下标点的分数最大值。如果没有这样的下标组合，请返回空数组。数组形式中第一个元素是分数字数最多的下标点，第二个元素是该下标点的分数。

请你实现一个函数 maxScoreIndices，它接收三个整数数组 nums、lower 和 upper，并返回一个数组 [t, k] 或者空数组 []。

注意：返回数组中的元素需要按字典序排列。

**示例：**

```go
输入：nums = [1,4,3,2,5,7,9], lower = 3, upper = 9
输出：[2,4]
解释：nums 中满足 3 <= nums[i] <= 9 的下标有：
- [3, 4, 5, 6, 7] 对应的下标分数为：[1, 1, 2, 1, 1]
- [4, 5, 6, 7, 9] 对应的下标分数为：[2, 2, 3, 2, 3]
分数最大的下标集合是 [4, 5, 6, 7] ，分数为 3 。
存在两个下标集合分数为 3 ：[4, 5, 6, 7] 和 [5, 6, 7, 9] ，但 [2, 4] 按字典序更小。

输入：nums = [1,4,3,2,5,7,9], lower = 1, upper = 6
输出：[0,1]
解释：nums 中满足 1 <= nums[i] <= 6 的下标有：
- [1, 4, 3, 5, 7] 对应的下标分数为：[1, 2, 1, 2, 1]
- [4, 3, 2, 5, 7] 对应的下标分数为：[2, 1, 1, 2, 1]
- [3, 4, 2, 5, 7] 对应的下标分数为：[1, 2, 1, 2, 1]
- [2, 4, 3, 5, 7] 对应的下标分数为：[1, 2, 1, 2, 1]
- [4, 3, 2, 5, 7] 对应的下标分数为：[2, 1, 1, 2, 1]
分数最大的下标集合是 [4, 3, 2, 5, 7] ，分数为 2 。
存在多个下标集合分数为 2 ，但 [0, 1] 按字典序最小。

输入：nums = [3,8,3,3], lower = 2, upper = 6
输出：[]
解释：nums 中满足 2 <= nums[i] <= 6 的下标有：
- [3, 3] 对应的下标分数为：[1, 1]
- [3, 3] 对应的下标分数为：[1, 1]
- [3, 3] 对应的下标分数为：[1, 1]
不存在分数大于 1 的下标集合。
```

**答案解析：**

我们可以使用哈希表记录每个元素出现的次数，然后遍历所有元素，找出满足条件的下标点。为了避免重复计算，我们可以使用前缀和数组来优化时间复杂度。

```go
func maxScoreIndices(nums []int, lower int, upper int) []int {
    count := make([]int, len(nums))
    for i := range nums {
        if lower <= nums[i] && nums[i] <= upper {
            count[i] = 1
        }
    }

    maxCount := 0
    maxScore := 0
    for i, cnt := range count {
        if cnt > maxCount || (cnt == maxCount && nums[i] > maxScore) {
            maxCount = cnt
            maxScore = nums[i]
        }
    }

    if maxCount == 0 {
        return nil
    }

    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if count[mid] == maxCount && (mid == 0 || count[mid-1] < maxCount) {
            return []int{mid, maxScore}
        }
        if count[mid] < maxCount {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return []int{left, maxScore}
}
```

#### 题目12：数组中的逆序对

**题目描述：** 在数组中的两个数字，如果前面数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

**示例：**

```go
输入：[7,5,6,4]
输出：5
```

**答案解析：**

我们可以使用归并排序的方法来求解。归并排序过程中，每次合并两个有序数组时，如果左边的数组中的元素大于右边的数组中的元素，那么左边的数组中剩下的元素都会与右边的数组中的当前元素构成逆序对。

```go
func inversePairs(nums []int) int {
    n := len(nums)
    if n <= 1 {
        return 0
    }
    temp := make([]int, n)
    copy(temp, nums)
    return mergeSort(temp, 0, n-1)
}

func mergeSort(nums []int, left int, right int) int {
    if left >= right {
        return 0
    }
    mid := left + (right - left) / 2
    count := mergeSort(nums, left, mid) + mergeSort(nums, mid+1, right)
    i, j := left, mid+1
    k := left
    for ; i <= mid && j <= right; k++ {
        if nums[i] <= nums[j] {
            nums[k] = nums[i]
            i++
        } else {
            nums[k] = nums[j]
            j++
            count += mid - i + 1
        }
    }
    for i <= mid {
        nums[k] = nums[i]
        k++
        i++
    }
    for j <= right {
        nums[k] = nums[j]
        k++
        j++
    }
    return count
}
```

#### 题目13：二进制矩阵中的特殊位置

**题目描述：** 在一个二进制矩阵中，0 和 1 形成了若干平形线段和矩形块。给你一个大小为 m x n 的二进制矩阵 matrix ，其中 0 表示平线段，1 表示矩形块。

请你找出所有矩形块的边界，并且按顺时针顺序返回。边界坐标组成的数对（x，y）中，x 是矩阵的行数，y 是列数。行数越小，数对排序越靠前；如果两个数对行数相同，那么列数越大，数对越靠前。

```go
输入：
matrix = [
  [1,1,2,2,2],
  [3,1,2,2,2],
  [1,2,2,3,3],
]

输出：
[
  [1,1],
  [1,3],
  [2,2],
  [2,3],
]
```

**答案解析：**

遍历矩阵，对于每一个矩形块的左上角和右下角坐标，判断其是否为特殊位置，如果是，则加入结果数组。

```go
func getSpecialPositions(matrix [][]int) [][]int {
    m, n := len(matrix), len(matrix[0])
    ans := make([][]int, 0)
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if matrix[i][j] == 1 {
                // 判断是否为左上角
                if (i == 0 || matrix[i-1][j] == 0) && (j == 0 || matrix[i][j-1] == 0) {
                    ans = append(ans, []int{i, j})
                }
                // 判断是否为右下角
                if (i == m-1 || matrix[i+1][j] == 0) && (j == n-1 || matrix[i][j+1] == 0) {
                    ans = append(ans, []int{i, j})
                }
            }
        }
    }
    return ans
}
```

#### 题目14：最大树值

**题目描述：** 给定一棵树的边权，每条边指向一棵树的子节点，求这棵树的父节点的最大值。

**示例：**

```go
输入：edges = [[0,1,2],[0,2,1]]
输出：3
解释：0 是根节点，它的最大值由它的子节点 1 和 2 提供，所以最大值为 3。

输入：edges = [[0,1,1],[1,2,2],[1,3,2]]
输出：4
解释：0 是根节点，它的最大值由它的子节点 1，2 和 3 提供，所以最大值为 4。

输入：edges = [[0,1,4],[1,2,5],[1,3,1]]
输出：7
解释：0 是根节点，它的最大值由它的子节点 1，2 和 3 提供，所以最大值为 7。

输入：edges = [[0,1,3],[1,2,4],[1,3,4]]
输出：4
解释：0 是根节点，它的最大值由它的子节点 1 和 3 提供，所以最大值为 4。
```

**答案解析：**

使用深度优先搜索（DFS）遍历树，同时记录每个节点的最大值。遍历结束后，返回根节点的最大值。

```go
func maxAncestorFunction(edges [][]int, values []int) int {
    n := len(edges)
    g := make([][]int, n)
    for _, edge := range edges {
        g[edge[0]] = append(g[edge[0]], edge[2])
        g[edge[1]] = append(g[edge[1]], edge[2])
    }
    var dfs func(int) int
    dfs = func(i int) int {
        mx := values[i]
        for _, j := range g[i] {
            mx = max(mx, dfs(j))
        }
        return mx
    }
    return dfs(0)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 题目15：单调栈

**题目描述：** 给定一个数组，使用单调栈求解以下问题：

1. 每个元素左边第一个比它大的元素。
2. 每个元素右边第一个比它大的元素。

**示例：**

```go
输入：[1,2,3,4,5]
输出：[4, 5, -1, 4, -1]

输入：[1,2,3,4,5,6]
输出：[5, 6, 6, 6, 6, -1]
```

**答案解析：**

使用两个单调栈分别求解左边和右边的问题。对于每个元素，将其与栈顶元素进行比较，如果大于栈顶元素，则栈顶元素的答案更新为当前元素的下标。

```go
func monotonicStack(nums []int) ([]int, []int) {
    n := len(nums)
    left := make([]int, n)
    right := make([]int, n)
    stk := []int{}
    for i, num := range nums {
        for len(stk) > 0 && nums[stk[len(stk)-1]] <= num {
            stk = stk[:len(stk)-1]
        }
        if len(stk) == 0 {
            left[i] = -1
        } else {
            left[i] = stk[len(stk)-1]
        }
        stk = append(stk, i)
    }
    stk = []int{}
    for i := n - 1; i >= 0; i-- {
        for len(stk) > 0 && nums[stk[len(stk)-1]] <= nums[i] {
            stk = stk[:len(stk)-1]
        }
        if len(stk) == 0 {
            right[i] = -1
        } else {
            right[i] = stk[len(stk)-1]
        }
        stk = append(stk, i)
    }
    return left, right
}
```

#### 题目16：三角形最小路径和

**题目描述：** 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

**示例：**

```go
输入：[
  [2],
  [3,4],
  [6,5,7],
  [4,1,8,3]
]
输出：11
解释：最短路径 2 -> 4 -> 1 -> 3 -> 1 共 11，但最小的路径 2 -> 1 -> 1 -> 3 -> 1 共 10。

输入：[
  [3],
  [7,4],
  [2,4,6],
  [8,5,9]
]
输出：13
```

**答案解析：**

从下往上更新每行最后一个元素的最小路径和。对于每一行，最后一个元素的最小路径和为该元素值加上下一行相邻两个元素的最小值。

```go
func minimumTotal(triangle [][]int) int {
    n := len(triangle)
    if n == 0 {
        return 0
    }
    minPath := triangle[n-1]
    for i := n - 2; i >= 0; i-- {
        for j := 0; j < len(triangle[i]); j++ {
            minPath[j] = triangle[i][j] + min(minPath[j], minPath[j+1])
        }
    }
    return minPath[0]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 题目17：最少箭数量

**题目描述：** 在一个无限的XY坐标平面上，产品的射击游戏玩者是位于原点O (0,0) 。平面上有若干散落的垂直于X轴的箭。箭会射向Y轴最接近的箭。如果射中的箭在同一位置存在多个箭，则取上方的箭优先。

每支箭都有一个x坐标，如果射箭者试图向X轴正方向射击，则射中的是最接近他且位于其右侧的箭。如果有多支箭在同一位置射中，取上方的箭。

给定一个二维数组，其中每一项为箭的坐标。|x| <= 2^7 - 1。箭不会射穿X轴上的任何点，箭的x值是整数。

返回垂直射击方式下，垂直射击的箭数的最大数量。

**示例：**

```go
输入：[
  [1,8],
  [7,4],
  [4,9],
  [7,2],
  [3,6],
  [6,1],
  [8,3],
  [8,4],
  [5,7],
  [4,4],
  [2,0]
]
输出：4
解释：用最少的箭数射击，可以射击以下箭：
箭1，箭6，箭2，箭3
```

**答案解析：**

使用排序和双指针法。首先将箭按照x坐标和y坐标进行排序。然后从左到右遍历箭，维护一个变量lastY表示已射击箭的y坐标中的最大值。当前箭的y坐标小于lastY时，说明需要射击新的箭，更新lastY。

```go
func findMinArrowShots(points [][]int) int {
    if len(points) == 0 {
        return 0
    }
    sort.Slice(points, func(i, j int) bool {
        if points[i][0] == points[j][0] {
            return points[i][1] < points[j][1]
        }
        return points[i][0] < points[j][0]
    })
    ans := 1
    lastY := points[0][1]
    for i := 1; i < len(points); i++ {
        if points[i][1] > lastY {
            ans++
            lastY = points[i][1]
        }
    }
    return ans
}
```

#### 题目18：每日温度

**题目描述：** 根据每日 气温 列表，请重新生成一个列表，表示需要连续多久不存在高温天气才能重新出现高温天气。请以数组形式返回生成的列表。

如果不存在连续的高温天气，请返回一个空列表。数据中的值以每日 气温 列表给定，不存在任何无效数据（例如负数）。注意：温度是用整数表示的。

**示例：**

```go
输入：temperatures = [73,74,75,71,69,72,76,73]
输出：[5,4,3,2,1,1,0,0]

输入：temperatures = [30,40,50,60]
输出：[1,1,1,0]

输入：temperatures = [30,60,90]
输出：[1,1,0]
```

**答案解析：**

使用单调栈。遍历温度列表，对于每个元素，从栈顶弹出所有比当前元素小的元素，计算当前元素与栈顶元素之间的天数差，更新结果数组。

```go
func dailyTemperatures(temperatures []int) []int {
    n := len(temperatures)
    ans := make([]int, n)
    stk := []int{}
    for i, t := range temperatures {
        for len(stk) > 0 && temperatures[stk[len(stk)-1]] < t {
            j := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            ans[j] = i - j
        }
        stk = append(stk, i)
    }
    return ans
}
```

#### 题目19：合并区间

**题目描述：** 以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组必须按区间端点升序排列。

**示例：**

```go
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**答案解析：**

首先将区间按照起始端点排序，然后遍历排序后的区间，对于当前区间，如果与下一个区间有重叠，则将它们的结束端点更新为较大的那一个，否则直接加入结果数组。

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return [][]int{}
    }
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] < intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] <= ans[len(ans)-1][1] {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}
```

#### 题目20：最长公共子串

**题目描述：** 给定两个字符串 s 和 t，返回两个字符串的最长公共子串。

**示例：**

```go
输入：s = "abc", t = "abd"
输出："ab"
解释：公共子串为 "a" 和 "ab"。

输入：s = "abc", t = "adc"
输出："a"
解释：公共子串为 "a"。

输入：s = "abc", t = "adcde"
输出："abc"
解释：公共子串为 "abc"。
```

**答案解析：**

使用动态规划求解。定义 dp[i][j] 为 s 的前 i 个字符与 t 的前 j 个字符的最长公共子串长度。遍历字符串，更新 dp 数组，最后返回最长公共子串长度。

```go
func longestCommonSubstring(s string, t string) string {
    n, m := len(s), len(t)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    mx, j := 0, -1
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if s[i-1] == t[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > mx {
                    mx = dp[i][j]
                    jx = j
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    if mx == 0 {
        return ""
    }
    return s[jx-mx : jx]
}
```

#### 题目21：合并二叉树

**题目描述：** 给定两个二叉树的根节点 root1 和 root2 ，想象你自己站在其中一个二叉树的根节点位置，当你从该位置向左、向右、向左下角或是向右下角遍历该二叉树时，你能看到的不同节点数目分别是 m、n、p 和 q 。请返回一个整数，表示在不改变节点原来的相对位置的情况下，将两个二叉树合并后得到的二叉树可以被看到的节点最大数量。

**示例：**

```go
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：8
解释：没有办法看到更多的节点。一种合并方案如下：
    3
   / \
  2   2
 / \ / \
1  5 1  4
       /
      7
```

**答案解析：**

使用深度优先搜索（DFS）遍历两棵树，对于每个节点，计算左子树、右子树和根节点的可见节点数，然后取最大值。

```go
var ans int

func maxVisiable(root1 *TreeNode, root2 *TreeNode) {
    if root1 == nil && root2 == nil {
        return
    }
    if root1 != nil && root2 != nil {
        left1, right1, left2, right2 := 0, 0, 0, 0
        if root1.Left != nil {
            left1 = 1 + maxVisiable(root1.Left, root2.Left)
        }
        if root1.Right != nil {
            right1 = 1 + maxVisiable(root1.Right, root2.Right)
        }
        if root2.Left != nil {
            left2 = 1 + maxVisiable(root1.Left, root2.Left)
        }
        if root2.Right != nil {
            right2 = 1 + maxVisiable(root1.Right, root2.Right)
        }
        ans = max(ans, left1+right2, right1+left2)
    } else if root1 != nil {
        ans = max(ans, 1+maxVisiable(root1.Left, root2.Left), 1+maxVisiable(root1.Right, root2.Right))
    } else if root2 != nil {
        ans = max(ans, 1+maxVisiable(root1.Left, root2.Left), 1+maxVisiable(root1.Right, root2.Right))
    }
}

func maxVisiableNodes(root1 *TreeNode, root2 *TreeNode) int {
    ans = 0
    maxVisiable(root1, root2)
    return ans
}
```

#### 题目22：最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回它们的 最长公共子序列 的长度。如果不存在共同子序列，返回 0。

**示例：**

```go
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

**答案解析：**

使用动态规划求解。定义 dp[i][j] 为 s 的前 i 个字符与 t 的前 j 个字符的最长公共子序列长度。

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    n, m := len(text1), len(text2)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[n][m]
}
```

#### 题目23：两个链表的第一个公共节点

**题目描述：** 给出两个单链表，找出它们的第一个公共节点。

**示例：**

```go
输入：headA = [4,1,8,4,5], headB = [5,0,1,8,4,5]
输出：Node 8

输入：headA = [2,6,4], headB = [1,5]
输出：null
解释：这两个链表没有交点。
```

**答案解析：**

首先计算两个链表的长度，然后使较长的链表先移动到与较短链表相同的位置，然后同时遍历两个链表，找到第一个公共节点。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    a, b := headA, headB
    pa, pb := a, b
    for pa != pb {
        if pa == nil {
            pa = headB
        } else {
            pa = pa.Next
        }
        if pb == nil {
            pb = headA
        } else {
            pb = pb.Next
        }
    }
    return pa
}
```

#### 题目24：寻找旋转排序数组中的最小值

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2]。

请找出并返回数组中的最小元素。

**示例：**

```go
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5]，在索引 3 处旋转。
```

**答案解析：**

使用二分查找的方法，每次将中间元素与两端元素进行比较，确定最小值所在区间。

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        m := (l + r) / 2
        if nums[m] > nums[r] {
            l = m + 1
        } else {
            r = m
        }
    }
    return nums[l]
}
```

#### 题目25：打家劫舍

**题目描述：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你的是相邻的房屋装有相互连通的防盗系统。问你在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**示例：**

```go
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 3 号房屋 (金额 = 9), 和 5 号房屋 (金额 = 1) 。
```

**答案解析：**

使用动态规划的方法，定义 dp[i] 为考虑前 i 间房屋能够偷窃到的最高金额。

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }
    dp := make([]int, n+1)
    dp[1], dp[2] = nums[0], max(nums[0], nums[1])
    for i := 3; i <= n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])
    }
    return dp[n]
}
```

#### 题目26：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```go
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

**答案解析：**

使用递归或迭代的方法合并两个链表。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 题目27：环形链表

**题目描述：** 给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到 pos 的位置（索引从 0 开始）。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true ；否则，返回 false 。

**示例：**

```go
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**答案解析：**

使用快慢指针法。定义两个指针 slow 和 fast，slow每次走一步，fast每次走两步。如果链表中存在环，fast 一定会追上 slow。

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

#### 题目28：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

**示例：**

```go
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""

提示：

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] 仅由小写英文字母组成
```

**答案解析：**

从第一个字符串开始，逐个比较后续字符串，找到公共前缀。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, s := range strs[1:] {
        for i, v := range s {
            if i >= len(prefix) || v != prefix[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}
```

#### 题目29：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度（不要求序列元素在原数组中连续）。

**示例：**

```go
输入：[100,4,200,1,3,2]
输出：4
解释：最长连续序列是 [1,2,3,4]。它的长度为 4。

输入：[0,3,7,2,5,8,4,6,0,1]
输出：9
```

**答案解析：**

使用哈希表记录每个数字的前一个数字和后一个数字，然后遍历数组，计算最长连续序列的长度。

```go
func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := map[int]bool{}
    for _, num := range nums {
        numSet[num] = true
    }
    longest := 0
    for num := range numSet {
        if !prevExists(num-1) {
            curr := num
            length := 1
            for nextExists(curr+1) {
                curr++
                length++
            }
            longest = max(longest, length)
        }
    }
    return longest
}

func prevExists(num int) bool {
    _, exists := m[num]
    return exists
}

func nextExists(num int) bool {
    _, exists := m[num]
    return exists
}
```

#### 题目30：两数之和

**题目描述：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例：**

```go
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。

输入：nums = [3,2,4], target = 6
输出：[1,2]

输入：nums = [3,3], target = 6
输出：[0,1]
```

**答案解析：**

使用哈希表记录数组中的每个元素及其索引，遍历数组，对于当前元素，判断 target - 当前元素是否存在于哈希表中。

```go
func twoSum(nums []int, target int) []int {
    numMap := map[int]int{}
    for i, num := range nums {
        complement := target - num
        if idx, ok := numMap[complement]; ok {
            return []int{idx, i}
        }
        numMap[num] = i
    }
    return []int{}
}
```

### 结语

本文详细解析了京东社招面试中的经典算法题库，涵盖了链表、数组、二叉树、哈希表等多个常见数据结构和算法。通过对这些题目的理解和练习，相信读者能够更好地应对未来的面试挑战。希望本文能够对您的面试准备有所帮助！

