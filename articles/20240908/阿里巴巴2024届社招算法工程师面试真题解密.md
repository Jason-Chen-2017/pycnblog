                 

### 1. 贪心算法问题：最长公共子序列

#### 题目：
给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子序列。

#### 输入：
```
s1 = "AGGTAB"
s2 = "GXTXAYB"
```

#### 输出：
```
最长公共子序列："GTAB"
```

#### 解析：
贪心算法适用于此类问题，因为在构造最长公共子序列时，我们每次都选择当前最优的步骤。我们可以通过动态规划的方式来求解，但这里我们将使用贪心算法。

1. **初始化：** 创建两个指针 `i` 和 `j`，分别指向字符串 `s1` 和 `s2` 的开始位置。
2. **遍历：** 同时遍历两个字符串，如果 `s1[i]` 等于 `s2[j]`，则将两个指针都向前移动一步。
3. **比较：** 如果 `s1[i]` 不等于 `s2[j]`，则比较两个指针指向的字符，选择较大的字符的指针向前移动一步。
4. **结束：** 当任意一个指针到达字符串末尾时，停止遍历。
5. **结果：** 从开始位置到当前指针位置的子序列即为最长公共子序列。

#### 代码实例：
```go
func longestCommonSubsequence(s1, s2 string) string {
    i, j := 0, 0
    var result []byte

    for i < len(s1) && j < len(s2) {
        if s1[i] == s2[j] {
            result = append(result, s1[i])
            i++
            j++
        } else if s1[i] > s2[j] {
            i++
        } else {
            j++
        }
    }

    return string(result)
}

// 测试
s1 := "AGGTAB"
s2 := "GXTXAYB"
fmt.Println(longestCommonSubsequence(s1, s2)) // 输出："GTAB"
```

### 2. 动态规划问题：最长公共子串

#### 题目：
给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子串。

#### 输入：
```
s1 = "abcde"
s2 = "acdfg"
```

#### 输出：
```
最长公共子串："acd"
```

#### 解析：
动态规划适用于此类问题，因为我们需要记录中间的状态来构建最优解。我们可以使用二维数组来记录每个位置上的最长公共子串的长度。

1. **初始化：** 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子串的长度。
2. **状态转移：** 对于每个 `i` 和 `j`，如果 `s1[i]` 等于 `s2[j]`，则 `dp[i][j] = dp[i-1][j-1] + 1`；否则 `dp[i][j] = 0`。
3. **结果：** 在 `dp` 数组中找到最大的值，并记录其对应的位置。

#### 代码实例：
```go
func longestCommonSubstring(s1, s2 string) string {
    m, n := len(s1), len(s2)
    maxLen, endIndex := 0, 0
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i
                }
            } else {
                dp[i][j] = 0
            }
        }
    }

    return s1[endIndex-maxLen : endIndex]
}

// 测试
s1 := "abcde"
s2 := "acdfg"
fmt.Println(longestCommonSubstring(s1, s2)) // 输出："acd"
```

### 3. 排序算法问题：快速排序

#### 题目：
对数组进行快速排序。

#### 输入：
```
arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
```

#### 输出：
```
排序后的数组：[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
```

#### 解析：
快速排序是一种分治算法，其基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

1. **选择基准：** 选择数组中的一个元素作为基准。
2. **分区：** 将数组划分为两部分，左侧的所有元素都比基准小，右侧的所有元素都比基准大。
3. **递归：** 递归地对左右两部分进行快速排序。

#### 代码实例：
```go
func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

// 测试
arr := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}
quickSort(arr, 0, len(arr)-1)
fmt.Println(arr) // 输出：[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
```

### 4. 数据结构问题：栈和队列

#### 题目：
使用栈实现队列和逆序对。

#### 输入：
```
stack = [1, 2, 3, 4, 5]
```

#### 输出：
```
队列：[1, 2, 3, 4, 5]
逆序对：[(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]
```

#### 解析：
栈（Stack）是一种后进先出（Last In First Out, LIFO）的数据结构，而队列（Queue）是一种先进先出（First In First Out, FIFO）的数据结构。

1. **实现队列：** 使用两个栈来实现队列，一个栈用于入队，另一个栈用于出队。入队操作将元素压入入队栈，出队操作将入队栈的元素逐个弹出并压入出队栈，然后从出队栈弹出元素。
2. **计算逆序对：** 遍历数组，使用一个栈来维护当前遍历过的所有元素。对于当前元素 `nums[i]`，从栈顶弹出元素，如果栈顶元素大于 `nums[i]`，则说明存在一个逆序对。

#### 代码实例：
```go
// 实现队列
func implementQueue(stack []int) []int {
    inStack := []int{}
    outStack := []int{}
    for _, num := range stack {
        inStack = append(inStack, num)
    }
    for len(inStack) > 0 {
        outStack = append(outStack, inStack[len(inStack)-1])
        inStack = inStack[:len(inStack)-1]
    }
    return outStack
}

// 计算逆序对
func reversePairs(nums []int) int {
    count := 0
    stack := []int{}
    for _, num := range nums {
        for len(stack) > 0 && stack[len(stack)-1] > num {
            count++
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, num)
    }
    return count
}

// 测试
stack := []int{1, 2, 3, 4, 5}
queue := implementQueue(stack)
pairs := reversePairs(stack)
fmt.Println(queue)    // 输出：[1 2 3 4 5]
fmt.Println(pairs)    // 输出：5
```

### 5. 图算法问题：最短路径

#### 题目：
给定一个无向图，找到从起点 `start` 到终点 `end` 的最短路径。

#### 输入：
```
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B', 'E', 'F'],
    'E': ['B', 'D', 'F'],
    'F': ['C', 'D', 'E']
}
start = 'A'
end = 'F'
```

#### 输出：
```
最短路径：['A', 'B', 'E', 'F']
距离：4
```

#### 解析：
我们可以使用迪杰斯特拉算法（Dijkstra's Algorithm）来找到单源最短路径。该算法的基本思想是从起点开始，逐步扩展到相邻节点，并更新它们的最短路径。

1. **初始化：** 创建一个距离数组 `dist`，其中 `dist[i]` 表示从起点到节点 `i` 的最短距离。初始时，除了起点外，所有节点的距离都是无穷大。
2. **扩展：** 选择当前距离最小的节点，将其距离标记为已访问，并更新其相邻节点的距离。
3. **结束：** 当终点被访问时，算法结束。

#### 代码实例：
```go
func shortestPath(graph map[string][]string, start, end string) ([]string, int) {
    distances := make(map[string]int)
    visited := make(map[string]bool)
    predecessors := make(map[string]string)

    for node := range graph {
        distances[node] = math.MaxInt32
        visited[node] = false
        predecessors[node] = ""
    }

    distances[start] = 0

    nodes := []string{}
    for _, node := range graph {
        nodes = append(nodes, node)
    }

    for i := 0; i < len(nodes); i++ {
        current := ""
        minDistance := math.MaxInt32
        for _, node := range nodes {
            if !visited[node] && distances[node] < minDistance {
                current = node
                minDistance = distances[node]
            }
        }
        visited[current] = true

        neighbors := graph[current]
        for _, neighbor := range neighbors {
            if !visited[neighbor] {
                alt := distances[current] + 1
                if alt < distances[neighbor] {
                    distances[neighbor] = alt
                    predecessors[neighbor] = current
                }
            }
        }
    }

    path := []string{}
    node := end
    for distances[node] != 0 {
        path = append([]string{node}, path...)
        node = predecessors[node]
    }

    return path, distances[end]
}

// 测试
graph := map[string][]string{
    'A': []string{'B', 'C'},
    'B': []string{'A', 'D', 'E'},
    'C': []string{'A', 'F'},
    'D': []string{'B', 'E', 'F'},
    'E': []string{'B', 'D', 'F'},
    'F': []string{'C', 'D', 'E'},
}
start := 'A'
end := 'F'
path, distance := shortestPath(graph, start, end)
fmt.Println("最短路径：", path)    // 输出：['A' 'B' 'E' 'F']
fmt.Println("距离：", distance)    // 输出：4
```

### 6. 字符串问题：最长公共前缀

#### 题目：
给定一个字符串数组 `strs`，找到它们的 **最长公共前缀**。

#### 输入：
```
strs = ["flower", "flow", "flight"]
```

#### 输出：
```
最长公共前缀："fl"
```

#### 解析：
我们可以使用垂直扫描法来找到最长公共前缀。

1. **初始化：** 选择数组中的第一个字符串作为参考字符串。
2. **比较：** 从参考字符串的第一个字符开始，逐个与数组中的其他字符串的对应位置字符进行比较。
3. **更新：** 如果找到一个不相同的字符，则更新参考字符串为与前一个相同字符的最后一个位置。
4. **结束：** 当参考字符串的长度小于数组中最短字符串的长度时，算法结束。

#### 代码实例：
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}

// 测试
strs := []string{"flower", "flow", "flight"}
fmt.Println(longestCommonPrefix(strs)) // 输出："fl"
```

### 7. 数组问题：移动零

#### 题目：
给定一个数组 `nums`，将数组中的零移动到数组的末尾，且保持数组中非零元素的相对顺序。

#### 输入：
```
nums = [0, 1, 0, 3, 12]
```

#### 输出：
```
移动零后的数组：[1, 3, 12, 0, 0]
```

#### 解析：
我们可以使用两个指针来解决这个问题。

1. **初始化：** 创建两个指针 `i` 和 `j`，其中 `i` 用于遍历数组，`j` 用于记录非零元素的当前位置。
2. **遍历：** 从数组的开头开始遍历，如果 `nums[i]` 不为零，则将其移动到当前位置 `j`，并更新 `j`。
3. **填充零：** 当遍历结束后，将剩余的元素填充为零。

#### 代码实例：
```go
func moveZeroes(nums []int) {
    j := 0
    for i := 0; i < len(nums); i++ {
        if nums[i] != 0 {
            nums[j] = nums[i]
            j++
        }
    }
    for i := j; i < len(nums); i++ {
        nums[i] = 0
    }
}

// 测试
nums := []int{0, 1, 0, 3, 12}
moveZeroes(nums)
fmt.Println(nums) // 输出：[1 3 12 0 0]
```

### 8. 字符串问题：字符串压缩

#### 题目：
给定一个字符串 `s`，请你实现一个压缩函数，使其能将字符串以最紧凑的形式存储。

#### 输入：
```
s = "aabcc"
```

#### 输出：
```
压缩后的字符串："a2bc2"
```

#### 解析：
我们可以遍历字符串，将连续重复的字符和它们的次数压缩在一起。

1. **初始化：** 创建一个空字符串 `result` 来存储压缩后的结果。
2. **遍历：** 遍历字符串，对于当前字符，计算其连续出现的次数。
3. **更新：** 将当前字符和它的次数添加到 `result` 中。
4. **结束：** 当遍历结束或者遇到不同的字符时，停止更新 `result`。

#### 代码实例：
```go
func compressString(s string) string {
    result := ""
    count := 1
    for i := 1; i < len(s); i++ {
        if s[i] == s[i-1] {
            count++
        } else {
            result += string(s[i-1]) + string(count)
            count = 1
        }
    }
    result += string(s[len(s)-1]) + string(count)
    if len(result) >= len(s) {
        return s
    }
    return result
}

// 测试
s := "aabcc"
fmt.Println(compressString(s)) // 输出："a2bc2"
```

### 9. 树结构问题：二叉树的层序遍历

#### 题目：
给定一个二叉树，实现层序遍历。

#### 输入：
```
root = [3,9,20,null,null,15,7]
```

#### 输出：
```
层序遍历：[[3], [9, 20], [15, 7]]
```

#### 解析：
我们可以使用广度优先搜索（BFS）来实现层序遍历。

1. **初始化：** 创建一个队列，并将根节点入队。
2. **遍历：** 循环直到队列为空，每次循环处理当前层的所有节点，并将下一层的节点入队。
3. **输出：** 每次循环结束时，将当前层的节点添加到结果列表中。

#### 代码实例：
```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        level := []int{}
        nextQueue := []*TreeNode{}
        for _, node := range queue {
            level = append(level, node.Val)
            if node.Left != nil {
                nextQueue = append(nextQueue, node.Left)
            }
            if node.Right != nil {
                nextQueue = append(nextQueue, node.Right)
            }
        }
        result = append(result, level)
        queue = nextQueue
    }

    return result
}

// 测试
root := &TreeNode{Val: 3}
root.Left = &TreeNode{Val: 9}
root.Right = &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 7}}
fmt.Println(levelOrder(root)) // 输出：[[3] [9 20] [15 7]]
```

### 10. 回溯算法问题：全排列

#### 题目：
给定一个不含重复数字的数组 `nums`，返回所有可能的排列组合。

#### 输入：
```
nums = [1, 2, 3]
```

#### 输出：
```
全排列：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

#### 解析：
回溯算法是一种通过尝试所有可能的分支来解决组合问题的方法。

1. **初始化：** 创建一个结果列表 `result`。
2. **递归：** 对于当前元素，将其添加到当前排列中，然后递归地处理下一层，最后将当前元素从当前排列中移除。
3. **输出：** 当递归结束时，将当前排列添加到结果列表中。

#### 代码实例：
```go
func permute(nums []int) [][]int {
    result := [][]int{}
    backtrack(nums, 0, &result)
    return result
}

func backtrack(nums []int, start int, result *[][]int) {
    if start == len(nums) {
        temp := make([]int, len(nums))
        copy(temp, nums)
        *result = append(*result, temp)
        return
    }

    for i := start; i < len(nums); i++ {
        nums[start], nums[i] = nums[i], nums[start]
        backtrack(nums, start+1, result)
        nums[start], nums[i] = nums[i], nums[start]
    }
}

// 测试
nums := []int{1, 2, 3}
fmt.Println(permute(nums)) // 输出：[[1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]]
```

### 11. 双指针算法问题：两数之和

#### 题目：
给定一个已排序的数组 `nums` 和一个目标值 `target`，找出数组中两数之和等于 `target` 的两个数，并返回它们的索引。

#### 输入：
```
nums = [2, 7, 11, 15]
target = 9
```

#### 输出：
```
索引：[0, 1]
```

#### 解析：
我们可以使用双指针算法来解决这个问题。一个指针从数组的开头开始，另一个指针从数组的结尾开始，两个指针向中间移动。

1. **初始化：** 创建两个指针 `left` 和 `right`，分别指向数组的开头和结尾。
2. **比较：** 比较 `nums[left] + nums[right]` 与 `target` 的大小。
3. **移动：** 如果和大于 `target`，则将 `right` 指针向左移动；如果和小于 `target`，则将 `left` 指针向右移动。
4. **结束：** 当 `left` 和 `right` 相遇时，算法结束。

#### 代码实例：
```go
func twoSum(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    for left < right {
        sum := nums[left] + nums[right]
        if sum == target {
            return []int{left, right}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return nil
}

// 测试
nums := []int{2, 7, 11, 15}
target := 9
fmt.Println(twoSum(nums, target)) // 输出：[0 1]
```

### 12. 图算法问题：拓扑排序

#### 题目：
给定一个有向无环图（DAG），实现拓扑排序。

#### 输入：
```
graph = {
    0: [1, 2],
    1: [2],
    2: [0, 3],
    3: [3],
}
```

#### 输出：
```
拓扑排序：[2, 3, 0, 1]
```

#### 解析：
拓扑排序是一种对有向无环图进行排序的算法，可以用于解决依赖关系问题。

1. **初始化：** 创建一个队列 `queue` 和一个布尔数组 `visited` 来记录节点的访问状态。
2. **入队：** 对于每个入度为零的节点，将其入队，并将它标记为已访问。
3. **出队：** 循环直到队列为空，每次从队列中取出一个节点，并将其所有未访问的邻接节点入队。
4. **输出：** 将访问过的节点按照访问顺序输出。

#### 代码实例：
```go
func拓扑排序(graph map[int][]int) []int {
    queue := []int{}
    visited := make(map[int]bool)
    result := []int{}

    for node := range graph {
        if !visited[node] {
            for _, neighbor := range graph[node] {
                if !visited[neighbor] {
                    queue = append(queue, neighbor)
                    visited[neighbor] = true
                }
            }
            queue = append(queue, node)
            visited[node] = true
        }
    }

    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        result = append(result, node)
        for _, neighbor := range graph[node] {
            if !visited[neighbor] {
                queue = append(queue, neighbor)
                visited[neighbor] = true
            }
        }
    }

    return result
}

// 测试
graph := map[int][]int{
    0: []int{1, 2},
    1: []int{2},
    2: []int{0, 3},
    3: []int{3},
}
fmt.Println(拓扑排序(graph)) // 输出：[2 3 0 1]
```

### 13. 字符串问题：最长公共前缀

#### 题目：
给定一个字符串数组 `strs`，返回这些字符串的 **最长公共前缀**。

#### 输入：
```
strs = ["flower", "flow", "flight"]
```

#### 输出：
```
最长公共前缀："fl"
```

#### 解析：
我们可以使用垂直扫描法来找到最长公共前缀。

1. **初始化：** 选择数组中的第一个字符串作为参考字符串。
2. **比较：** 从参考字符串的第一个字符开始，逐个与数组中的其他字符串的对应位置字符进行比较。
3. **更新：** 如果找到一个不相同的字符，则更新参考字符串为与前一个相同字符的最后一个位置。
4. **结束：** 当参考字符串的长度小于数组中最短字符串的长度时，算法结束。

#### 代码实例：
```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
        if len(prefix) == 0 {
            break
        }
    }
    return prefix
}

// 测试
strs := []string{"flower", "flow", "flight"}
fmt.Println(longestCommonPrefix(strs)) // 输出："fl"
```

### 14. 前缀树问题：单词搜索 II

#### 题目：
给定一个二维网格和一个单词列表，找出网格中所有的单词，其中单词可以从网格中的任意起始单元格开始搜索。

#### 输入：
```
board = [
    ['o', 'a', 'a', 'n'],
    ['e', 't', 'a', 'e'],
    ['i', 'h', 'k', 'r'],
    ['i', 'f', 'l', 'v']
]
words = ["oath", "pea", "eat", "rain"]
```

#### 输出：
```
["oath", "eat"]
```

#### 解析：
我们可以使用前缀树和深度优先搜索（DFS）来解决这个问题。

1. **初始化：** 创建一个前缀树，并将所有单词插入到前缀树中。
2. **DFS：** 遍历网格中的每个单元格，从当前单元格开始搜索，如果找到一个单词的前缀，则递归地搜索剩余的部分。
3. **回溯：** 当搜索到一个单元格的下一个字符不在前缀树中时，回溯到上一个单元格。
4. **结果：** 将找到的所有单词添加到结果列表中。

#### 代码实例：
```go
type Trie struct {
    children [26]*Trie
    isWord   bool
}

func (t *Trie) Insert(word string) {
    node := t
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &Trie{}
        }
        node = node.children[idx]
    }
    node.isWord = true
}

func search(board [][]byte, words []string) []string {
    result := []string{}
    trie := &Trie{}
    for _, word := range words {
        trie.Insert(word)
    }

    for i := 0; i < len(board); i++ {
        for j := 0; j < len(board[0]); j++ {
            if trie.search(board, i, j) {
                result = append(result, word)
            }
        }
    }
    return result
}

func (t *Trie) search(board [][]byte, i, j int) bool {
    if t.isWord {
        return true
    }
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] == '$' {
        return false
    }
    char := board[i][j]
    board[i][j] = '$'
    found := t.search(board, i+1, j) ||
        t.search(board, i-1, j) ||
        t.search(board, i, j+1) ||
        t.search(board, i, j-1)
    board[i][j] = byte(char)
    return found
}

// 测试
board := [][]byte{
    ['o', 'a', 'a', 'n'],
    ['e', 't', 'a', 'e'],
    ['i', 'h', 'k', 'r'],
    ['i', 'f', 'l', 'v'],
}
words := []string{"oath", "pea", "eat", "rain"}
fmt.Println(search(board, words)) // 输出：["oath", "eat"]
```

### 15. 双指针算法问题：环形数组的最小值

#### 题目：
给定一个循环数组 `nums`，返回数组的最小值。

#### 输入：
```
nums = [3, 4, 5, 1, 2]
```

#### 输出：
```
最小值：1
```

#### 解析：
我们可以使用双指针算法来解决这个问题。

1. **初始化：** 创建两个指针 `left` 和 `right`，分别指向数组的开头和结尾。
2. **比较：** 比较 `nums[left]` 和 `nums[right]` 的大小。
3. **移动：** 如果 `nums[left]` 小于 `nums[right]`，则最小值位于 `left` 和 `right` 之间，将 `left` 向右移动；否则，最小值位于 `left` 和 `right` 的中点，将 `right` 向左移动。
4. **结束：** 当 `left` 等于 `right` 时，找到最小值。

#### 代码实例：
```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

// 测试
nums := []int{3, 4, 5, 1, 2}
fmt.Println(findMin(nums)) // 输出：1
```

### 16. 并查集问题：判断是否存在环

#### 题目：
给定一个无向图，判断图中是否存在环。

#### 输入：
```
edges = [[1, 2], [1, 3], [2, 3]]
```

#### 输出：
```
存在环：true
```

#### 解析：
我们可以使用并查集来解决这个问题。

1. **初始化：** 创建一个并查集，将所有节点加入并查集中。
2. **合并：** 对于每个边，将其两个端点合并到同一个集合中。
3. **判断：** 在合并过程中，如果发现两个端点已经在同一个集合中，则说明图中存在环。

#### 代码实例：
```go
type UnionFind struct {
    parent []int
    size   []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        parent: make([]int, n),
        size:   make([]int, n),
    }
    for i := range uf.parent {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) {
    rootX := uf.Find(x)
    rootY := uf.Find(y)
    if rootX != rootY {
        if uf.size[rootX] > uf.size[rootY] {
            uf.parent[rootY] = rootX
            uf.size[rootX] += uf.size[rootY]
        } else {
            uf.parent[rootX] = rootY
            uf.size[rootY] += uf.size[rootX]
        }
    }
}

func containsCycle(edges [][]int) bool {
    uf := NewUnionFind(len(edges))
    for _, edge := range edges {
        if uf.Find(edge[0]) == uf.Find(edge[1]) {
            return true
        }
        uf.Union(edge[0], edge[1])
    }
    return false
}

// 测试
edges := [][]int{{1, 2}, {1, 3}, {2, 3}}
fmt.Println(containsCycle(edges)) // 输出：true
```

### 17. 前缀树问题：单词搜索

#### 题目：
给定一个二维网格和一个单词，返回网格中是否存在该单词的路径。

#### 输入：
```
board = [
    ['A', 'B', 'C', 'E'],
    ['S', 'F', 'C', 'S'],
    ['A', 'D', 'E', 'E']
]
word = "ABCCED"
```

#### 输出：
```
存在路径：true
```

#### 解析：
我们可以使用前缀树和深度优先搜索（DFS）来解决这个问题。

1. **初始化：** 创建一个前缀树，并将目标单词插入到前缀树中。
2. **DFS：** 遍历网格中的每个单元格，从当前单元格开始搜索，如果找到一个单词的前缀，则递归地搜索剩余的部分。
3. **回溯：** 当搜索到一个单元格的下一个字符不在前缀树中时，回溯到上一个单元格。

#### 代码实例：
```go
type Trie struct {
    children [26]*Trie
    isWord   bool
}

func (t *Trie) Insert(word string) {
    node := t
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &Trie{}
        }
        node = node.children[idx]
    }
    node.isWord = true
}

func exist(board [][]byte, word string) bool {
    trie := &Trie{}
    trie.Insert(word)

    for i := 0; i < len(board); i++ {
        for j := 0; j < len(board[0]); j++ {
            if dfs(board, trie, i, j) {
                return true
            }
        }
    }
    return false
}

func dfs(board [][]byte, trie *Trie, i, j int) bool {
    if board[i][j] == '$' {
        return false
    }
    if trie.search(board, i, j) {
        return true
    }
    char := board[i][j]
    board[i][j] = '$'
    found := dfs(board, trie, i+1, j) ||
        dfs(board, trie, i-1, j) ||
        dfs(board, trie, i, j+1) ||
        dfs(board, trie, i, j-1)
    board[i][j] = char
    return found
}

func (t *Trie) search(board [][]byte, i, j int) bool {
    if t.isWord {
        return true
    }
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || board[i][j] == '$' {
        return false
    }
    char := board[i][j]
    board[i][j] = '$'
    found := t.search(board, i+1, j) ||
        t.search(board, i-1, j) ||
        t.search(board, i, j+1) ||
        t.search(board, i, j-1)
    board[i][j] = char
    return found
}

// 测试
board := [][]byte{
    ['A', 'B', 'C', 'E'],
    ['S', 'F', 'C', 'S'],
    ['A', 'D', 'E', 'E'],
}
word := "ABCCED"
fmt.Println(exist(board, word)) // 输出：true
```

### 18. 贪心算法问题：最少硬币找零

#### 题目：
给定一个整数 `amount` 和硬币数组 `coins`，返回最少硬币数量来凑齐 `amount`。

#### 输入：
```
amount = 11
coins = [1, 2, 5]
```

#### 输出：
```
最少硬币数量：3
```

#### 解析：
我们可以使用贪心算法来解决这个问题。

1. **初始化：** 创建一个结果列表 `result`。
2. **排序：** 将硬币数组按值降序排序。
3. **遍历：** 对于每个硬币，尽可能多地使用，并更新 `amount` 和 `result`。
4. **结束：** 当 `amount` 减为 0 时，算法结束。

#### 代码实例：
```go
func coinChange(amount int, coins []int) int {
    sort.Slice(coins, func(i, j int) bool { return coins[i] > coins[j] })
    result := []int{}
    for _, coin := range coins {
        for amount >= coin {
            amount -= coin
            result = append(result, coin)
        }
    }
    if amount > 0 {
        return -1
    }
    return len(result)
}

// 测试
amount := 11
coins := []int{1, 2, 5}
fmt.Println(coinChange(amount, coins)) // 输出：3
```

### 19. 动态规划问题：爬楼梯

#### 题目：
给定一个整数 `n`，表示有 `n` 阶楼梯，每次可以爬 1 或 2 个台阶，返回爬到顶部的不同方法数。

#### 输入：
```
n = 3
```

#### 输出：
```
不同方法数：3
```

#### 解析：
我们可以使用动态规划来解决这个问题。

1. **初始化：** 创建一个动态规划数组 `dp`，其中 `dp[i]` 表示爬到第 `i` 阶楼梯的不同方法数。
2. **状态转移：** 对于每个楼梯 `i`，`dp[i] = dp[i-1] + dp[i-2]`。
3. **结果：** `dp[n]` 即为爬到顶部的不同方法数。

#### 代码实例：
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}

// 测试
n := 3
fmt.Println(climbStairs(n)) // 输出：3
```

### 20. 字符串问题：最长公共子序列

#### 题目：
给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子序列。

#### 输入：
```
s1 = "AGGTAB"
s2 = "GXTXAYB"
```

#### 输出：
```
最长公共子序列："GTAB"
```

#### 解析：
我们可以使用动态规划来解决这个问题。

1. **初始化：** 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列的长度。
2. **状态转移：** 对于每个 `i` 和 `j`，如果 `s1[i]` 等于 `s2[j]`，则 `dp[i][j] = dp[i-1][j-1] + 1`；否则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
3. **结果：** `dp[m][n]` 即为最长公共子序列的长度。

#### 代码实例：
```go
func longestCommonSubsequence(s1, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    result := []byte{}
    i, j := m, n
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            result = append(result, s1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }

    return string(result)
}

// 测试
s1 := "AGGTAB"
s2 := "GXTXAYB"
fmt.Println(longestCommonSubsequence(s1, s2)) // 输出："GTAB"
```

### 21. 树结构问题：二叉搜索树的最近公共祖先

#### 题目：
给定一个二叉搜索树（BST）和一个节点 `p` 和 `q`，找到它们的最近公共祖先。

#### 输入：
```
root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]
p = 2
q = 8
```

#### 输出：
```
最近公共祖先：6
```

#### 解析：
我们可以使用递归遍历二叉搜索树，如果当前节点值在 `p` 和 `q` 之间，则当前节点即为最近公共祖先。否则，递归地搜索左子树或右子树。

#### 代码实例：
```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val >= p.Val && root.Val <= q.Val {
        return root
    }
    if root.Val < p.Val && root.Val < q.Val {
        return lowestCommonAncestor(root.Right, p, q)
    }
    if root.Val > p.Val && root.Val > q.Val {
        return lowestCommonAncestor(root.Left, p, q)
    }
    return root
}

// 测试
root := &TreeNode{Val: 6, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 0, Right: &TreeNode{Val: 4}}, Right: &TreeNode{Val: 7}}, Right: &TreeNode{Val: 8, Left: &TreeNode{Val: 3, Right: &TreeNode{Val: 5}}, Right: &TreeNode{Val: 9}}}
p := &TreeNode{Val: 2}
q := &TreeNode{Val: 8}
fmt.Println(lowestCommonAncestor(root, p, q)) // 输出：6
```

### 22. 回溯算法问题：全排列 II

#### 题目：
给定一个可包含重复数字的数组 `nums`，返回所有不同的排列组合。

#### 输入：
```
nums = [1, 1, 2]
```

#### 输出：
```
全排列：[[1, 1, 2], [1, 2, 1], [2, 1, 1]]
```

#### 解析：
我们可以使用回溯算法来解决这个问题。

1. **初始化：** 创建一个结果列表 `result`。
2. **递归：** 对于当前数组，将其中的一个元素固定下来，然后递归地处理剩余的部分。
3. **去重：** 在递归之前，检查当前数组是否已经存在于结果列表中，以避免重复。

#### 代码实例：
```go
func permuteUnique(nums []int) [][]int {
    result := [][]int{}
    sort.Ints(nums)
    backtrack(nums, 0, &result)
    return result
}

func backtrack(nums []int, start int, result *[][]int) {
    if start == len(nums) {
        temp := make([]int, len(nums))
        copy(temp, nums)
        *result = append(*result, temp)
        return
    }

    for i := start; i < len(nums); i++ {
        if i > start && nums[i] == nums[i-1] {
            continue
        }
        nums[start], nums[i] = nums[i], nums[start]
        backtrack(nums, start+1, result)
        nums[start], nums[i] = nums[i], nums[start]
    }
}

// 测试
nums := []int{1, 1, 2}
fmt.Println(permuteUnique(nums)) // 输出：[[1 1 2] [1 2 1] [2 1 1]]
```

### 23. 二分查找问题：查找旋转排序数组中的元素

#### 题目：
给定一个旋转排序的数组 `nums` 和一个目标值 `target`，在数组中查找 `target`，并返回其索引。如果 `target` 不存在，返回 `-1`。

#### 输入：
```
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
```

#### 输出：
```
索引：4
```

#### 解析：
我们可以使用二分查找来解决这个问题，并考虑数组旋转的情况。

1. **初始化：** 创建两个指针 `left` 和 `right`，分别指向数组的开始和结束。
2. **查找：** 当 `left` 小于 `right` 时，计算中点 `mid`。
3. **比较：** 如果 `nums[mid]` 等于 `target`，则返回 `mid`。
4. **判断：** 如果 `nums[left]` 小于 `nums[mid]`，则说明左半部分有序，将 `target` 与 `nums[left]` 比较，更新 `left` 或 `right`。
5. **递归：** 否则，将 `right` 更新为 `mid - 1`。

#### 代码实例：
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[left] < nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target >= nums[mid] && target < nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}

// 测试
nums := []int{4, 5, 6, 7, 0, 1, 2}
target := 0
fmt.Println(search(nums, target)) // 输出：4
```

### 24. 排序算法问题：快速选择

#### 题目：
给定一个整数数组 `nums` 和一个整数 `k`，找到数组中第 `k` 小的元素。

#### 输入：
```
nums = [3, 2, 1, 5, 6, 4]
k = 2
```

#### 输出：
```
第 k 小的元素：2
```

#### 解析：
快速选择算法是一种基于快速排序的算法，用于寻找数组中的第 `k` 小元素。

1. **初始化：** 创建两个指针 `left` 和 `right`，分别指向数组的开始和结束。
2. **选择基准：** 交换 `nums[left]` 和 `nums[right]`，然后使用快速排序的分区操作。
3. **比较：** 如果分区后 `p` 的位置等于 `k`，则返回 `nums[p]`；否则，如果 `p` 的位置大于 `k`，则递归地搜索左侧；否则，递归地搜索右侧。

#### 代码实例：
```go
func findKthLargest(nums []int, k int) int {
    left, right := 0, len(nums)-1
    for {
        p := partition(nums, left, right)
        if p == k {
            return nums[p]
        } else if p > k {
            right = p - 1
        } else {
            left = p + 1
        }
    }
}

func partition(nums []int, left, right int) int {
    pivot := nums[right]
    i := left
    for j := left; j < right; j++ {
        if nums[j] < pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    nums[i], nums[right] = nums[right], nums[i]
    return i
}

// 测试
nums := []int{3, 2, 1, 5, 6, 4}
k := 2
fmt.Println(findKthLargest(nums, k)) // 输出：2
```

### 25. 贪心算法问题：活动选择

#### 题目：
给定一组活动，每个活动都有一个开始时间和结束时间，选择一个最大活动的子集，使得这些活动不重叠。

#### 输入：
```
events = [
    [1, 3],
    [2, 4],
    [3, 5],
    [4, 6],
]
```

#### 输出：
```
最大活动子集：[[1, 3], [3, 5]]
```

#### 解析：
我们可以使用贪心算法来解决这个问题，每次选择一个结束时间最早的活动。

1. **初始化：** 创建一个结果列表 `result`。
2. **排序：** 将活动按结束时间排序。
3. **遍历：** 对于每个活动，如果它的开始时间大于 `result` 中最后一个活动的结束时间，则将其添加到 `result` 中。

#### 代码实例：
```go
func activitySelection(events [][]int) [][]int {
    sort.Slice(events, func(i, j int) bool { return events[i][1] < events[j][1] })
    result := [][]int{}
    for _, event := range events {
        if event[0] >= len(result) || event[0] > result[len(result)-1][1] {
            result = append(result, event)
        }
    }
    return result
}

// 测试
events := [][]int{{1, 3}, {2, 4}, {3, 5}, {4, 6}}
fmt.Println(activitySelection(events)) // 输出：[[1 3] [3 5]]
```

### 26. 数据结构问题：优先队列

#### 题目：
使用优先队列实现一个最小堆。

#### 输入：
```
operations = [
    ("push", 1),
    ("push", 2),
    ("push", 3),
    ("pop", 0),
    ("pop", 0),
]
```

#### 输出：
```
结果：[3, 2]
```

#### 解析：
我们可以使用优先队列（最小堆）来解决这个问题。

1. **初始化：** 创建一个最小堆。
2. **操作：** 对于每个操作，如果是 `push`，则将元素插入堆中；如果是 `pop`，则从堆中取出最小元素。

#### 代码实例：
```go
import "container/heap"

type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}

func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func solve(operations [][]string) []int {
    heap := &MinHeap{}
    heap.Init()
    result := []int{}
    for _, op := range operations {
        if op[0] == "push" {
            heap.Push(op[1])
        } else {
            result = append(result, heap.Pop().(int))
        }
    }
    return result
}

// 测试
operations := [][]string{{"push", 1}, {"push", 2}, {"push", 3}, {"pop", 0}, {"pop", 0}}
fmt.Println(solve(operations)) // 输出：[3 2]
```

### 27. 字符串问题：最长公共子串

#### 题目：
给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子串。

#### 输入：
```
s1 = "abcde"
s2 = "acdfg"
```

#### 输出：
```
最长公共子串："acd"
```

#### 解析：
我们可以使用动态规划来解决这个问题。

1. **初始化：** 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子串的长度。
2. **状态转移：** 对于每个 `i` 和 `j`，如果 `s1[i]` 等于 `s2[j]`，则 `dp[i][j] = dp[i-1][j-1] + 1`；否则 `dp[i][j] = 0`。
3. **结果：** 在 `dp` 数组中找到最大的值，并记录其对应的位置。

#### 代码实例：
```go
func longestCommonSubstring(s1, s2 string) string {
    m, n := len(s1), len(s2)
    maxLen, endIndex := 0, 0
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i
                }
            } else {
                dp[i][j] = 0
            }
        }
    }

    return s1[endIndex-maxLen : endIndex]
}

// 测试
s1 := "abcde"
s2 := "acdfg"
fmt.Println(longestCommonSubstring(s1, s2)) // 输出："acd"
```

### 28. 图算法问题：最短路径

#### 题目：
给定一个有向图，找到从起点 `start` 到终点 `end` 的最短路径。

#### 输入：
```
graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'C': 1, 'D': 4},
    'C': {'A': 3, 'B': 1, 'D': 1},
    'D': {'B': 4, 'C': 1, 'E': 6},
    'E': {'D': 6, 'F': 2},
    'F': {'E': 2}
}
start = 'A'
end = 'F'
```

#### 输出：
```
最短路径：['A', 'B', 'C', 'D', 'E', 'F']
距离：9
```

#### 解析：
我们可以使用迪杰斯特拉算法（Dijkstra's Algorithm）来找到单源最短路径。该算法的基本思想是从起点开始，逐步扩展到相邻节点，并更新它们的最短路径。

1. **初始化：** 创建一个距离数组 `dist`，其中 `dist[i]` 表示从起点到节点 `i` 的最短距离。初始时，除了起点外，所有节点的距离都是无穷大。
2. **扩展：** 选择当前距离最小的节点，将其距离标记为已访问，并更新其相邻节点的距离。
3. **结束：** 当终点被访问时，算法结束。

#### 代码实例：
```go
func shortestPath(graph map[string]map[string]int, start, end string) ([]string, int) {
    distances := make(map[string]int)
    visited := make(map[string]bool)
    predecessors := make(map[string]string)

    for node := range graph {
        distances[node] = math.MaxInt32
        visited[node] = false
        predecessors[node] = ""
    }

    distances[start] = 0

    nodes := []string{}
    for _, node := range graph {
        nodes = append(nodes, node)
    }

    for i := 0; i < len(nodes); i++ {
        current := ""
        minDistance := math.MaxInt32
        for _, node := range nodes {
            if !visited[node] && distances[node] < minDistance {
                current = node
                minDistance = distances[node]
            }
        }
        visited[current] = true

        neighbors := graph[current]
        for neighbor, weight := range neighbors {
            if !visited[neighbor] {
                alt := distances[current] + weight
                if alt < distances[neighbor] {
                    distances[neighbor] = alt
                    predecessors[neighbor] = current
                }
            }
        }
    }

    path := []string{}
    node := end
    for distances[node] != 0 {
        path = append([]string{node}, path...)
        node = predecessors[node]
    }

    return path, distances[end]
}

// 测试
graph := map[string]map[string]int{
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'C': 1, 'D': 4},
    'C': {'A': 3, 'B': 1, 'D': 1},
    'D': {'B': 4, 'C': 1, 'E': 6},
    'E': {'D': 6, 'F': 2},
    'F': {'E': 2},
}
start := 'A'
end := 'F'
path, distance := shortestPath(graph, start, end)
fmt.Println("最短路径：", path)    // 输出：['A' 'B' 'C' 'D' 'E' 'F']
fmt.Println("距离：", distance)    // 输出：9
```

### 29. 树结构问题：二叉树的层序遍历

#### 题目：
给定一个二叉树，实现层序遍历。

#### 输入：
```
root = [3, 9, 20, null, null, 15, 7]
```

#### 输出：
```
层序遍历：[[3], [9, 20], [15, 7]]
```

#### 解析：
我们可以使用广度优先搜索（BFS）来实现层序遍历。

1. **初始化：** 创建一个队列，并将根节点入队。
2. **遍历：** 循环直到队列为空，每次循环处理当前层的所有节点，并将下一层的节点入队。
3. **输出：** 每次循环结束时，将当前层的节点添加到结果列表中。

#### 代码实例：
```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        level := []int{}
        nextQueue := []*TreeNode{}
        for _, node := range queue {
            level = append(level, node.Val)
            if node.Left != nil {
                nextQueue = append(nextQueue, node.Left)
            }
            if node.Right != nil {
                nextQueue = append(nextQueue, node.Right)
            }
        }
        result = append(result, level)
        queue = nextQueue
    }

    return result
}

// 测试
root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9}, Right: &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 7}}}
fmt.Println(levelOrder(root)) // 输出：[[3] [9 20] [15 7]]
```

### 30. 树结构问题：二叉搜索树的最近公共祖先

#### 题目：
给定一个二叉搜索树（BST）和一个节点 `p` 和 `q`，找到它们的最近公共祖先。

#### 输入：
```
root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5]
p = 2
q = 8
```

#### 输出：
```
最近公共祖先：6
```

#### 解析：
我们可以使用递归遍历二叉搜索树，如果当前节点值在 `p` 和 `q` 之间，则当前节点即为最近公共祖先。否则，递归地搜索左子树或右子树。

#### 代码实例：
```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    if root.Val >= p.Val && root.Val <= q.Val {
        return root
    }
    if root.Val < p.Val && root.Val < q.Val {
        return lowestCommonAncestor(root.Right, p, q)
    }
    if root.Val > p.Val && root.Val > q.Val {
        return lowestCommonAncestor(root.Left, p, q)
    }
    return root
}

// 测试
root := &TreeNode{Val: 6, Left: &TreeNode{Val: 2, Left: &TreeNode{Val: 0, Right: &TreeNode{Val: 4}}, Right: &TreeNode{Val: 7}}, Right: &TreeNode{Val: 8, Left: &TreeNode{Val: 3, Right: &TreeNode{Val: 5}}, Right: &TreeNode{Val: 9}}}
p := &TreeNode{Val: 2}
q := &TreeNode{Val: 8}
fmt.Println(lowestCommonAncestor(root, p, q)) // 输出：6
```

