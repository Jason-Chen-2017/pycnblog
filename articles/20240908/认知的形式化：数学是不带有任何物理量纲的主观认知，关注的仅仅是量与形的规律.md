                 

### 1. 快排的实现及其时间复杂度分析

**题目：** 实现快速排序算法（Quick Sort），并分析其时间复杂度。

**答案：**

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

**解析：**

快速排序（Quick Sort）是一种高效的排序算法，其平均时间复杂度为 \(O(n\log n)\)。上述代码首先定义了一个 `quickSort` 函数，它使用递归方法实现快速排序。函数内部调用 `partition` 函数，用于划分数组。

`partition` 函数选择数组最后一个元素作为基准值（pivot），将小于 pivot 的元素移到其左侧，大于 pivot 的元素移到其右侧。返回的 `pi` 是 pivot 的最终位置。

时间复杂度分析：

- 最坏情况时间复杂度为 \(O(n^2)\)，当数组已经是有序或逆序时发生。
- 平均情况时间复杂度为 \(O(n\log n)\)，因为快速排序在每次划分后，大约将数组分为两个长度为 \(n/2\) 的子数组。

### 2. 贪心算法的应用：硬币找零问题

**题目：** 给定一个金额和一个硬币数组，计算最少的硬币数量来凑出该金额。

**答案：**

```go
package main

import (
    "fmt"
)

func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    dp[0] = 0

    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
        for _, coin := range coins {
            if i-coin >= 0 && dp[i-coin]+1 < dp[i] {
                dp[i] = dp[i-coin] + 1
            }
        }
    }

    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func main() {
    coins := []int{1, 2, 5}
    amount := 11
    fmt.Println("Minimum coins:", coinChange(coins, amount))
}
```

**解析：**

这是一个典型的贪心算法应用，贪心算法通过在每一步选择局部最优解，以期达到全局最优解。

上述代码使用动态规划（DP）实现。定义一个长度为 `amount+1` 的数组 `dp`，其中 `dp[i]` 表示凑出金额 `i` 的最少硬币数量。初始时，`dp[0] = 0`（不需要硬币凑出 0 元）。

在循环中，对于每个金额 `i`，遍历所有硬币，找出能够凑出金额 `i` 的硬币，并更新 `dp[i]`。

时间复杂度为 \(O(amount \times N)\)，其中 `N` 是硬币的数量。

### 3. 广度优先搜索：二叉树的层序遍历

**题目：** 实现二叉树的层序遍历。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return nil
    }

    ans := [][]int{}
    q := []*TreeNode{root}

    for len(q) > 0 {
        t := []int{}
        for _, node := range q {
            t = append(t, node.Val)
            if node.Left != nil {
                q = append(q, node.Left)
            }
            if node.Right != nil {
                q = append(q, node.Right)
            }
        }
        ans = append(ans, t)
        q = q[1:]
    }
    return ans
}

func main() {
    root := &TreeNode{Val: 3,
        Left:  &TreeNode{Val: 9,
            Left:  &TreeNode{Val: 15,
                Left:  &TreeNode{Val: 20,
                    Left:  &TreeNode{Val: 25},
                    Right: &TreeNode{Val: 30}}},
            Right: &TreeNode{Val: 10,
                Left:  &TreeNode{Val: 16},
                Right: &TreeNode{Val: 22}}},
        Right: &TreeNode{Val: 20,
            Left:  &TreeNode{Val: 7,
                Left:  &TreeNode{Val: 8},
                Right: &TreeNode{Val: 14}},
            Right: &TreeNode{Val: 17,
                Left:  &TreeNode{Val: 18},
                Right: &TreeNode{Val: 24}}}}
    fmt.Println("Level order traversal:", levelOrder(root))
}
```

**解析：**

广度优先搜索（BFS）使用队列实现，适用于层次遍历二叉树。

初始化队列 `q`，将根节点加入队列。然后循环处理队列中的节点，依次遍历其左右子节点，并将它们加入队列。每次循环结束后，将当前层的所有节点值加入答案数组 `ans`。

时间复杂度为 \(O(n)\)，其中 `n` 是二叉树的节点数量。

### 4. 深度优先搜索：二叉树的最大深度

**题目：** 计算二叉树的最大深度。

**答案：**

```go
package main

import (
    "fmt"
)

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return max(leftDepth, rightDepth) + 1
}

func main() {
    root := &TreeNode{Val: 3,
        Left:  &TreeNode{Val: 9,
            Left:  &TreeNode{Val: 15,
                Left:  &TreeNode{Val: 20,
                    Left:  &TreeNode{Val: 25},
                    Right: &TreeNode{Val: 30}}},
            Right: &TreeNode{Val: 10,
                Left:  &TreeNode{Val: 16},
                Right: &TreeNode{Val: 22}}},
        Right: &TreeNode{Val: 20,
            Left:  &TreeNode{Val: 7,
                Left:  &TreeNode{Val: 8},
                Right: &TreeNode{Val: 14}},
            Right: &TreeNode{Val: 17,
                Left:  &TreeNode{Val: 18},
                Right: &TreeNode{Val: 24}}}}
    fmt.Println("Max depth:", maxDepth(root))
}
```

**解析：**

深度优先搜索（DFS）使用递归实现，从根节点开始，递归计算左右子树的最大深度，并取最大值加 1。

时间复杂度为 \(O(n)\)，其中 `n` 是二叉树的节点数量。

### 5. 递归与非递归实现合并两个有序链表

**题目：** 实现合并两个有序链表。

**答案：**

**递归实现：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**非递归实现：**

```go
package main

import (
    "fmt"
)

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    prev := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            prev.Next = l1
            l1 = l1.Next
        } else {
            prev.Next = l2
            l2 = l2.Next
        }
        prev = prev.Next
    }

    if l1 != nil {
        prev.Next = l1
    } else if l2 != nil {
        prev.Next = l2
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：**

递归实现：每次比较两个链表的头节点，选择较小的值作为下一个节点，并递归处理剩余的链表。

非递归实现：使用一个哑节点 `dummy`，逐个比较两个链表，将较小的节点连接到 `prev` 后续，然后移动 `prev` 和较小节点。

时间复杂度为 \(O(n+m)\)，其中 `n` 和 `m` 分别是两个链表的长度。

### 6. 递归与非递归实现删除链表的节点

**题目：** 实现删除链表中的节点。

**答案：**

**递归实现：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**非递归实现：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(node *ListNode) {
    if node == nil || node.Next == nil {
        return
    }
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**解析：**

递归实现：直接将当前节点的值替换为下一个节点的值，然后删除下一个节点。

非递归实现：判断当前节点是否为空或下一个节点是否为空，如果都不为空，将当前节点的值替换为下一个节点的值，然后删除下一个节点。

时间复杂度为 \(O(1)\)，只需要修改当前节点的值和指针。

### 7. 动态规划：最长递增子序列

**题目：** 找出最长递增子序列的长度。

**答案：**

```go
package main

import (
    "fmt"
)

func lengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }
    for i := 0; i < n; i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    fmt.Println("Length of LIS:", lengthOfLIS(nums))
}
```

**解析：**

动态规划实现。定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。遍历数组，对于每个元素 `nums[i]`，遍历所有前面的元素 `nums[j]`，如果 `nums[i] > nums[j]`，则更新 `dp[i]`。

时间复杂度为 \(O(n^2)\)，其中 `n` 是数组长度。

### 8. 回溯算法：全排列

**题目：** 给定一个无重复元素的数组，返回该数组的所有全排列。

**答案：**

```go
package main

import (
    "fmt"
)

func permute(nums []int) [][]int {
    ans := [][]int{}
    path := []int{}
    visited := make([]bool, len(nums))

    dfs(nums, 0, path, visited, &ans)
    return ans
}

func dfs(nums []int, step int, path []int, visited []bool, ans *[][]int) {
    if step == len(nums) {
        t := make([]int, len(path))
        copy(t, path)
        *ans = append(*ans, t)
        return
    }

    for i := 0; i < len(nums); i++ {
        if visited[i] {
            continue
        }
        visited[i] = true
        path = append(path, nums[i])
        dfs(nums, step+1, path, visited, ans)
        visited[i] = false
        path = path[:len(path)-1]
    }
}

func main() {
    nums := []int{1, 2, 3}
    fmt.Println("Permutations:", permute(nums))
}
```

**解析：**

回溯算法实现。递归遍历每个元素，将其加入到路径中，然后继续递归处理剩余的元素。当到达最后一个元素时，将路径加入答案。回溯时，将当前元素从路径中删除，然后继续遍历下一个元素。

时间复杂度为 \(O(n!\))，其中 `n` 是数组长度。

### 9. 位运算：判断两个整数是否互为位逆

**题目：** 判断两个整数是否互为位逆，即它们的二进制表示逐位相反。

**答案：**

```go
package main

import (
    "fmt"
)

func isBitwiseInverse(x int, y int) bool {
    return x^y == -1
}

func main() {
    x := 5 // 101
    y := 2 // 010
    fmt.Println("Are x and y bitwise inverse?", isBitwiseInverse(x, y))
}
```

**解析：**

利用位运算中的异或（`^`）操作。两个整数互为位逆的条件是它们的异或结果为 -1（即二进制表示全部位为 1）。

时间复杂度为 \(O(1)\)，空间复杂度为 \(O(1)\)。

### 10. 栈与队列：最小栈

**题目：** 设计一个最小栈，支持 `push`, `pop`, 和 `getMin` 操作。

**答案：**

```go
package main

import (
    "fmt"
)

type MinStack struct {
    stack []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack: []int{},
        minStack: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    this.minStack = append(this.minStack, 
```
[...]
```python
                min(val, this.minStack[-1]))
}

func (this *MinStack) Pop() {
    if len(this.stack) == 0 {
        return
    }
    this.stack = this.stack[:len(this.stack)-1]
    this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
    if len(this.stack) == 0 {
        return -1
    }
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    if len(this.minStack) == 0 {
        return -1
    }
    return this.minStack[len(this.minStack)-1]
}

func main() {
    obj := Constructor()
    obj.Push(2)
    obj.Push(4)
    obj.Push(3)
    print("Minimum element:", obj.GetMin())
    obj.Pop()
    print("Minimum element:", obj.GetMin())
    print("Top element:", obj.Top())
}
```

**解析：**

使用两个栈来维护最小栈。一个栈 `stack` 用于存储所有元素，另一个栈 `minStack` 用于存储每个元素对应的最小值。

- `push`: 在 `stack` 中添加元素，并在 `minStack` 中添加当前元素和前一个最小值中的最小值。
- `pop`: 从 `stack` 和 `minStack` 中同时弹出最后一个元素。
- `top`: 返回 `stack` 的最后一个元素。
- `getMin`: 返回 `minStack` 的最后一个元素，即当前栈中的最小值。

时间复杂度为 \(O(1)\)，空间复杂度为 \(O(n)\)。

### 11. 图的深度优先搜索：判断二分图

**题目：** 判断一个无向图是否为二分图。

**答案：**

```go
package main

import (
    "fmt"
)

type Graph struct {
    V   int
    Adj [][]int
}

func (g *Graph) DFS(u int, visited *[]bool, color *[]int) bool {
    *visited[u] = true
    color[u] = 1

    for _, v := range g.Adj[u] {
        if !*visited[v] {
            if !g.DFS(v, visited, color) {
                return false
            }
        } else if color[u] == color[v] {
            return false
        }
    }
    return true
}

func isBipartite(graph [][]int) bool {
    n := len(graph)
    visited := make([]bool, n)
    color := make([]int, n)

    for u := 0; u < n; u++ {
        if !visited[u] {
            if !g.DFS(u, &visited, &color) {
                return false
            }
        }
    }
    return true
}

func main() {
    graph := [][]int{
        {1, 3},
        {0, 2},
        {1, 3},
        {0, 2},
    }
    fmt.Println("Is bipartite:", isBipartite(graph))
}
```

**解析：**

使用深度优先搜索（DFS）来判断图是否为二分图。每个节点都可以被染成红色或蓝色，使得相邻的节点颜色不同。

遍历每个未访问的节点，使用 DFS 进行深度优先搜索。如果找到一个相邻节点颜色相同的边，则图不是二分图。

时间复杂度为 \(O(V+E)\)，其中 \(V\) 是节点数量，\(E\) 是边数量。

### 12. 二分查找：在排序数组中查找元素的第一个和最后一个位置

**题目：** 在排序数组中查找元素的第一个和最后一个位置。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func searchRange(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    first := -1
    last := -1

    // 查找第一个位置
    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] == target {
            first = mid
            right = mid - 1
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    left, right = 0, len(nums)-1
    // 查找最后一个位置
    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] == target {
            last = mid
            left = mid + 1
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return []int{first, last}
}

func main() {
    nums := []int{5, 7, 7, 8, 8, 10}
    target := 8
    fmt.Println("First and last positions:", searchRange(nums, target))
}
```

**解析：**

使用二分查找分别查找第一个和最后一个位置。对于第一个位置，每次找到目标值后，继续向左查找；对于最后一个位置，每次找到目标值后，继续向右查找。

时间复杂度为 \(O(\log n)\)，其中 \(n\) 是数组长度。

### 13. 链表：反转链表

**题目：** 反转一个单链表。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head

    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }

    return prev
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}
    newHead := reverseList(head)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：**

使用迭代方法，初始化两个指针 `prev` 和 `current`，遍历链表，每次循环将当前节点指向前一个节点，最终返回新的头节点。

时间复杂度为 \(O(n)\)，其中 \(n\) 是链表长度。

### 14. 二分查找：寻找旋转排序数组的最小值

**题目：** 寻找旋转排序数组的最小值。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    if nums[left] < nums[right] {
        return nums[left]
    }
    for left < right {
        mid := left + (right - left) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else if nums[mid] < nums[right] {
            right = mid
        } else {
            right--
        }
    }
    return nums[left]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    fmt.Println("Minimum value:", findMin(nums))
}
```

**解析：**

使用二分查找，当中间值大于右侧值时，说明最小值在右侧，否则在左侧。当中间值等于右侧值时，最小值可能出现在右侧或者中间值左侧，因此将右侧边界向左移动一位。

时间复杂度为 \(O(\log n)\)，其中 \(n\) 是数组长度。

### 15. 字符串：最长公共前缀

**题目：** 找出两个字符串的公共前缀。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    ans := strs[0]
    for i := 1; i < len(strs); i++ {
        j := 0
        for j < len(ans) && j < len(strs[i]) && ans[j] == strs[i][j] {
            j++
        }
        ans = ans[:j]
        if ans == "" {
            return ""
        }
    }
    return ans
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println("Longest common prefix:", longestCommonPrefix(strs))
}
```

**解析：**

遍历所有字符串，逐个比较字符，找到最长公共前缀。

时间复杂度为 \(O(nm)\)，其中 \(n\) 是字符串数量，\(m\) 是最长公共前缀的长度。

### 16. 递归：计算斐波那契数列

**题目：** 计算斐波那契数列的第 \(n\) 项。

**答案：**

```go
package main

import (
    "fmt"
)

func fib(n int) int {
    if n <= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}

func main() {
    n := 10
    fmt.Println("Fibonacci number:", fib(n))
}
```

**解析：**

递归实现斐波那契数列。时间复杂度为 \(O(2^n)\)。

### 17. 贪心算法：打家劫舍

**题目：** 你是一个职业小偷，计划偷窃沿街的房屋。每间房屋只能偷窃一次，相邻的房屋装有相互连通的防盗系统。计算你最多可以偷窃多少金额。

**答案：**

```go
package main

import (
    "fmt"
)

func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }

    return max(rob(nums[:len(nums)-1]), rob(nums[1:]))
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{1, 2, 3, 1}
    fmt.Println("Maximum amount:", rob(nums))
}
```

**解析：**

贪心算法。每次选择最大金额的子数组进行抢劫。

时间复杂度为 \(O(n)\)，其中 \(n\) 是数组长度。

### 18. 哈希表：两个数组的交集 II

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，返回两个数组中的公共元素。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func intersect(nums1 []int, nums2 []int) []int {
    m, n := len(nums1), len(nums2)
    var ans []int
    i, j := 0, 0

    sort.Ints(nums1)
    sort.Ints(nums2)

    for i < m && j < n {
        if nums1[i] == nums2[j] {
            ans = append(ans, nums1[i])
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }

    return ans
}

func main() {
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    fmt.Println("Intersection:", intersect(nums1, nums2))
}
```

**解析：**

先对两个数组进行排序，然后使用两个指针遍历数组，找到公共元素。

时间复杂度为 \(O(m\log m + n\log n)\)，其中 \(m\) 和 \(n\) 分别是两个数组长度。

### 19. 滑动窗口：最短的有效括号对数

**题目：** 给定一个字符串 `s`，找出字符串中有效的括号对数。

**答案：**

```go
package main

import (
    "fmt"
)

func minWindow(s string, t string) string {
    cnt := [128]int{}
    for i := 0; i < len(t); i++ {
        cnt[t[i]]++
    }
    l, r, start, ansLen := 0, 0, 0, len(s) + 1

    for r < len(s) {
        cnt[s[r]]--
        if cnt[s[r]] >= 0 {
            if cnt[s[l]] < 0 {
                l = r
            }
        }

        if cnt[s[r]] < 0 && r-l+1 < ansLen {
            start = l
            ansLen = r - l + 1
        }
        r++
    }

    if ansLen > len(s) {
        return ""
    }
    return s[start : start+ansLen]
}

func main() {
    s := "ADOBECODEBANC"
    t := "ABC"
    fmt.Println("Minimum window:", minWindow(s, t))
}
```

**解析：**

滑动窗口。使用两个指针 `l` 和 `r` 表示当前窗口的左右边界。当右指针移动时，更新计数器。如果当前窗口的有效字符数量等于目标字符串的长度，更新最小窗口。当左指针移动时，如果当前窗口的有效字符数量大于目标字符串的长度，更新左指针。

时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串长度。

### 20. 动态规划：最大子序和

**题目：** 给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（至少包含一个数）。

**答案：**

```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    ans, prev := nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        prev = max(prev+nums[i], nums[i])
        ans = max(ans, prev)
    }
    return ans
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println("Maximum subarray sum:", maxSubArray(nums))
}
```

**解析：**

动态规划。定义两个变量 `ans` 和 `prev`，分别表示当前的最大子序列和和上一个最大子序列和。遍历数组，更新 `prev` 和 `ans`。

时间复杂度为 \(O(n)\)，其中 \(n\) 是数组长度。

### 21. 双指针：有效的字母异位词

**题目：** 给定两个字符串 `s` 和 `t`，编写一个函数来判断 `s` 是否是 `t` 的字母异位词。

**答案：**

```go
package main

import (
    "fmt"
)

func isAnagram(s string, t string) bool {
    cntS, cntT := [26]int{}, [26]int{}
    for _, c := range s {
        cntS[c-'a']++
    }
    for _, c := range t {
        cntT[c-'a']++
    }
    return cntS == cntT
}

func main() {
    s := "anagram"
    t := "nagaram"
    fmt.Println("Is anagram:", isAnagram(s, t))
}
```

**解析：**

使用两个计数数组分别统计字符串 `s` 和 `t` 的字符频率。然后比较两个计数数组是否相等。

时间复杂度为 \(O(n+m)\)，其中 \(n\) 和 \(m\) 分别是字符串 `s` 和 `t` 的长度。

### 22. 双指针：寻找两个正序数组的中位数

**题目：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，找到这两个数组的中位数。

**答案：**

```go
package main

import (
    "fmt"
)

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i

        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            if i == 0 {
                maxOfLeft := nums2[j-1]
            } else if j == 0 {
                maxOfLeft := nums1[i-1]
            } else {
                maxOfLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxOfLeft)
            }
            minOfRight := 0
            if i == m {
                minOfRight = nums2[j]
            } else if j == n {
                minOfRight = nums1[i]
            } else {
                minOfRight = min(nums1[i], nums2[j])
            }
            return float64(maxOfLeft+minOfRight) / 2
        }
    }
    return 0
}

func main() {
    nums1 := []int{1, 3}
    nums2 := []int{2}
    fmt.Println("Median:", findMedianSortedArrays(nums1, nums2))
}
```

**解析：**

使用二分查找。分别取两个数组的中间值，比较中间值，调整查找范围。

时间复杂度为 \(O((m+n)\log\min(m, n))\)，其中 \(m\) 和 \(n\) 分别是两个数组长度。

### 23. 双指针：寻找旋转排序数组中的最小值

**题目：** 给定一个旋转排序的数组，找出其最小元素。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    if nums[left] < nums[right] {
        return nums[left]
    }
    for left < right {
        mid := left + (right - left) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else if nums[mid] < nums[right] {
            right = mid
        } else {
            right--
        }
    }
    return nums[left]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    fmt.Println("Minimum value:", findMin(nums))
}
```

**解析：**

使用二分查找。当中间值大于右侧值时，说明最小值在右侧。当中间值小于右侧值时，说明最小值在左侧或中间。当中间值等于右侧值时，最小值可能出现在右侧或者中间值左侧，因此将右侧边界向左移动一位。

时间复杂度为 \(O(\log n)\)，其中 \(n\) 是数组长度。

### 24. 栈与队列：有效的括号

**题目：** 给定一个字符串 `s` ，判断是否为有效的括号字符串。

**答案：**

```go
package main

import (
    "fmt"
)

func isValid(s string) bool {
    stack := []rune{}
    for _, c := range s {
        if c == '(' || c == '[' || c == '{' {
            stack = append(stack, c)
        } else if len(stack) == 0 || (c == ')' && stack[len(stack)-1] != '(') || (c == ']' && stack[len(stack)-1] != '[') || (c == '}' && stack[len(stack)-1] != '{') {
            return false
        }
        stack = stack[:len(stack)-1]
    }
    return len(stack) == 0
}

func main() {
    s := "()"
    fmt.Println("Is valid:", isValid(s))
}
```

**解析：**

使用栈来匹配括号。遍历字符串，将左括号入栈，遇到右括号时，检查栈顶元素是否与之匹配。如果匹配，则出栈；如果不匹配或栈为空，则返回 `false`。

时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串长度。

### 25. 树的层序遍历：二叉树的层序遍历

**题目：** 实现二叉树的层序遍历。

**答案：**

```go
package main

import (
    "fmt"
    "sync"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    ans := [][]int{}
    if root == nil {
        return ans
    }
    q := []*TreeNode{root}
    for len(q) > 0 {
        t := []int{}
        nextQ := []*TreeNode{}
        for _, node := range q {
            t = append(t, node.Val)
            if node.Left != nil {
                nextQ = append(nextQ, node.Left)
            }
            if node.Right != nil {
                nextQ = append(nextQ, node.Right)
            }
        }
        ans = append(ans, t)
        q = nextQ
    }
    return ans
}

func main() {
    root := &TreeNode{Val: 3,
        Left:  &TreeNode{Val: 9,
            Left:  &TreeNode{Val: 15,
                Left:  &TreeNode{Val: 20,
                    Left:  &TreeNode{Val: 25},
                    Right: &TreeNode{Val: 30}}},
            Right: &TreeNode{Val: 10,
                Left:  &TreeNode{Val: 16},
                Right: &TreeNode{Val: 22}}},
        Right: &TreeNode{Val: 20,
            Left:  &TreeNode{Val: 7,
                Left:  &TreeNode{Val: 8},
                Right: &TreeNode{Val: 14}},
            Right: &TreeNode{Val: 17,
                Left:  &TreeNode{Val: 18},
                Right: &TreeNode{Val: 24}}}}
    fmt.Println("Level order traversal:", levelOrder(root))
}
```

**解析：**

使用广度优先搜索（BFS），初始化队列 `q`，将根节点加入队列。循环遍历队列，每次循环处理当前层所有节点，并将下一层的节点加入队列。

时间复杂度为 \(O(n)\)，其中 \(n\) 是节点数量。

### 26. 递归：全排列 II

**题目：** 给定一个可包含重复数字的序列，返回所有不重复的全排列。

**答案：**

```go
package main

import (
    "fmt"
)

func permuteUnique(nums []int) [][]int {
    ans := [][]int{}
    path := []int{}
    visited := make([]bool, len(nums))

    sort.Ints(nums)
    dfs(nums, 0, path, visited, &ans)
    return ans
}

func dfs(nums []int, step int, path []int, visited []bool, ans *[][]int) {
    if step == len(nums) {
        t := make([]int, len(path))
        copy(t, path)
        *ans = append(*ans, t)
        return
    }

    for i := 0; i < len(nums); i++ {
        if visited[i] {
            continue
        }
        if i > 0 && nums[i] == nums[i-1] && !visited[i-1] {
            continue
        }
        visited[i] = true
        path = append(path, nums[i])
        dfs(nums, step+1, path, visited, ans)
        visited[i] = false
        path = path[:len(path)-1]
    }
}

func main() {
    nums := []int{1, 1, 2}
    fmt.Println("Permutations:", permuteUnique(nums))
}
```

**解析：**

使用递归和剪枝。首先对数组进行排序，然后遍历数组，对于重复的元素，只有当前面的元素没有被访问过时才继续访问。每次访问一个元素，将其加入路径，并递归处理剩余的元素，然后回溯。

时间复杂度为 \(O(n!\))，其中 \(n\) 是数组长度。

### 27. 快排：快速排序

**题目：** 实现快速排序算法。

**答案：**

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

**解析：**

快速排序算法。选择一个基准值，将数组划分为两部分，一部分小于基准值，另一部分大于基准值。递归地对两部分进行快速排序。

时间复杂度为 \(O(n\log n)\)，最坏情况为 \(O(n^2)\)。

### 28. 递归与非递归：实现两个数组的交集

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，返回 `nums1` 和 `nums2` 的交集。

**答案：**

递归实现：

```go
package main

import (
    "fmt"
)

func intersect(nums1 []int, nums2 []int) []int {
    if len(nums1) == 0 || len(nums2) == 0 {
        return []int{}
    }
    if nums1[0] == nums2[0] {
        return append([]int{nums1[0]}, intersect(nums1[1:], nums2[1:])...)  
```
[...]
```python
    } else if nums1[0] < nums2[0] {
        return intersect(nums1[1:], nums2)
    } else {
        return intersect(nums1, nums2[1:])
    }
}

func main() {
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    fmt.Println("Intersection:", intersect(nums1, nums2))
}
```

非递归实现：

```go
package main

import (
    "fmt"
)

func intersect(nums1 []int, nums2 []int) []int {
    m, n := len(nums1), len(nums2)
    i, j := 0, 0
    ans := []int{}

    for i < m && j < n {
        if nums1[i] == nums2[j] {
            ans = append(ans, nums1[i])
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }

    return ans
}

func main() {
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    fmt.Println("Intersection:", intersect(nums1, nums2))
}
```

**解析：**

递归实现：每次比较两个数组的前两个元素，如果相等，将元素加入答案，并递归处理剩余的两个数组。如果当前元素小于目标元素，递归处理当前数组剩余部分和目标数组；如果当前元素大于目标元素，递归处理当前数组，并处理目标数组剩余部分。

非递归实现：使用两个指针遍历两个数组，找到公共元素并加入答案。

时间复杂度为 \(O(m+n)\)，其中 \(m\) 和 \(n\) 分别是两个数组长度。

### 29. 贪心算法：背包问题

**题目：** 给定一个背包容量 `W` 和一组物品，每个物品有一个价值 `w` 和重量 `v`，求解在不超过背包容量的情况下，能够装入的最大价值。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func knapsack(W int, weights []int, values []int) float64 {
    n := len(values)
    dp := make([][]float64, n+1)
    for i := range dp {
        dp[i] = make([]float64, W+1)
    }
    for i := 1; i <= n; i++ {
        for w := 1; w <= W; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][W]
}

func main() {
    W := 50
    weights := []int{10, 20, 30}
    values := []int{60, 100, 120}
    fmt.Println("Maximum value:", knapsack(W, weights, values))
}
```

**解析：**

贪心算法。使用动态规划实现。定义一个二维数组 `dp`，其中 `dp[i][w]` 表示在前 `i` 个物品中选择不超过重量 `w` 的最大价值。遍历每个物品和每个可能的重量，更新 `dp` 数组。

时间复杂度为 \(O(nW)\)，其中 \(n\) 是物品数量，\(W\) 是背包容量。

### 30. 前缀树：实现前缀树

**题目：** 实现一个前缀树（Trie）。

**答案：**

```go
package main

import (
    "fmt"
)

type Trie struct {
    Children [26]*Trie
    IsEnd    bool
}

func Constructor() *Trie {
    return &Trie{}
}

func (t *Trie) Insert(word string) {
    node := t
    for _, ch := range word {
        idx := ch - 'a'
        if node.Children[idx] == nil {
            node.Children[idx] = Constructor()
        }
        node = node.Children[idx]
    }
    node.IsEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t
    for _, ch := range word {
        idx := ch - 'a'
        if node.Children[idx] == nil {
            return false
        }
        node = node.Children[idx]
    }
    return node.IsEnd
}

func main() {
    trie := Constructor()
    trie.Insert("apple")
    fmt.Println("Search 'apple':", trie.Search("apple")) // true
    fmt.Println("Search 'app':", trie.Search("app"))      // false
}
```

**解析：**

前缀树实现。每个节点包含一个指向子节点的数组 `Children` 和一个表示单词结束的标志 `IsEnd`。插入单词时，从根节点开始，逐个字符添加到前缀树。搜索单词时，从根节点开始，逐个字符查找，直到找到结束标志。

时间复杂度为 \(O(L)\)，其中 \(L\) 是单词长度。

### 31. 二叉搜索树：二叉搜索树的最近公共祖先

**题目：** 给定一个二叉搜索树，找到两个节点 \(p\) 和 \(q\) 的最近公共祖先。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func lowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)

    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}

func main() {
    root := &TreeNode{Val: 6,
        Left:  &TreeNode{Val: 2,
            Left:  &TreeNode{Val: 0,
                Left:  &TreeNode{Val: -3},
                Right: &TreeNode{Val: 1}},
            Right: &TreeNode{Val: 4,
                Left:  &TreeNode{Val: 3},
                Right: &TreeNode{Val: 5}}},
        Right: &TreeNode{Val: 8,
            Left:  &TreeNode{Val: 7},
            Right: &TreeNode{Val: 9}}}
    p := root.Left
    q := root.Right
    fmt.Println("Lowest common ancestor:", lowestCommonAncestor(root, p, q).Val)
}
```

**解析：**

递归查找。如果根节点等于 \(p\) 或 \(q\)，则返回根节点；如果左子树和右子树都存在，则返回根节点；否则返回左子树或右子树的最近公共祖先。

时间复杂度为 \(O(h)\)，其中 \(h\) 是树的高度。

### 32. 并查集：判断是否存在环

**题目：** 使用并查集判断一个图是否存在环。

**答案：**

```go
package main

import (
    "fmt"
)

type UnionFind struct {
    Parent []int
    Rank   []int
}

func Constructor(n int) *UnionFind {
    uf := &UnionFind{
        Parent: make([]int, n),
        Rank:   make([]int, n),
    }
    for i := 0; i < n; i++ {
        uf.Parent[i] = i
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.Parent[x] != x {
        uf.Parent[x] = uf.Find(uf.Parent[x])
    }
    return uf.Parent[x]
}

func (uf *UnionFind) Union(x int, y int) bool {
    rootX := uf.Find(x)
    rootY := uf.Find(y)
    if rootX == rootY {
        return false
    }
    if uf.Rank[rootX] < uf.Rank[rootY] {
        uf.Parent[rootX] = rootY
    } else if uf.Rank[rootX] > uf.Rank[rootY] {
        uf.Parent[rootY] = rootX
    } else {
        uf.Parent[rootX] = rootY
        uf.Rank[rootY]++
    }
    return true
}

func containsCycle(edges [][]int) bool {
    uf := Constructor(len(edges))
    for _, edge := range edges {
        if !uf.Union(edge[0], edge[1]) {
            return true
        }
    }
    return false
}

func main() {
    edges := [][]int{
        {0, 1},
        {1, 2},
        {2, 0},
        {1, 3},
    }
    fmt.Println("Contains cycle:", containsCycle(edges))
}
```

**解析：**

并查集实现。每次合并两个节点，如果根节点相同，则说明存在环。

时间复杂度为 \(O(E \alpha(V))\)，其中 \(E\) 是边数，\(V\) 是节点数，\(\alpha(V)\) 是并查集的操作复杂度。

### 33. 栈与队列：设计循环队列

**题目：** 设计一个循环队列。

**答案：**

```go
package main

import (
    "fmt"
)

type MyCircularQueue struct {
    Data []int
    Front, Rear, Capacity int
}

func Constructor(k int) *MyCircularQueue {
    return &MyCircularQueue{
        Data:  make([]int, k),
        Front: 0,
        Rear:  0,
        Capacity: k,
    }
}

func (queue *MyCircularQueue) EnQueue(value int) bool {
    if queue.Rear == queue.Front {
        return false
    }
    queue.Data[queue.Rear] = value
    queue.Rear = (queue.Rear + 1) % queue.Capacity
    return true
}

func (queue *MyCircularQueue) DeQueue() bool {
    if queue.Rear == queue.Front {
        return false
    }
    queue.Front = (queue.Front + 1) % queue.Capacity
    return true
}

func (queue *MyCircularQueue) Front() int {
    if queue.Rear == queue.Front {
        return -1
    }
    return queue.Data[queue.Front]
}

func (queue *MyCircularQueue) Rear() int {
    if queue.Rear == queue.Front {
        return -1
    }
    return queue.Data[queue.Rear-1]
}

func (queue *MyCircularQueue) IsEmpty() bool {
    return queue.Rear == queue.Front
}

func (queue *MyCircularQueue) IsFull() bool {
    return (queue.Rear+1)%queue.Capacity == queue.Front
}

func main() {
    queue := Constructor(3)
    fmt.Println("EnQueue:", queue.EnQueue(1)) // true
    fmt.Println("EnQueue:", queue.EnQueue(2)) // true
    fmt.Println("Rear:", queue.Rear())        // 2
    fmt.Println("Front:", queue.Front())      // 1
    fmt.Println("DeQueue:", queue.DeQueue())   // true
    fmt.Println("Rear:", queue.Rear())        // 0
    fmt.Println("Front:", queue.Front())      // 2
    fmt.Println("IsFull:", queue.IsFull())    // false
    fmt.Println("IsEmpty:", queue.IsEmpty())  // false
}
```

**解析：**

循环队列实现。使用一个数组 `Data` 存储队列元素，使用 `Front` 和 `Rear` 指针表示队头和队尾。当 `Rear` 追上 `Front` 时，说明队列已满。

时间复杂度为 \(O(1)\)。

### 34. 双指针：移动零

**题目：** 给定一个数组，将数组中的所有零移到数组末尾，同时保持其他元素的相对顺序。

**答案：**

```go
package main

import (
    "fmt"
)

func moveZeroes(nums []int) {
    slow, fast := 0, 0
    for fast < len(nums) {
        if nums[fast] != 0 {
            nums[slow], nums[fast] = nums[fast], nums[slow]
            slow++
        }
        fast++
    }
}

func main() {
    nums := []int{0, 1, 0, 3, 12}
    moveZeroes(nums)
    fmt.Println(nums) // [1, 3, 12, 0, 0]
}
```

**解析：**

双指针实现。使用 `slow` 指针记录非零元素的位置，`fast` 指针遍历数组。当 `fast` 指针遇到非零元素时，将非零元素移动到 `slow` 指针的位置，并将 `slow` 指针向后移动。

时间复杂度为 \(O(n)\)，其中 \(n\) 是数组长度。

### 35. 双指针：两数组的交集

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，返回两个数组的交集。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func intersection(nums1 []int, nums2 []int) []int {
    m, n := len(nums1), len(nums2)
    sort.Ints(nums1)
    sort.Ints(nums2)
    i, j := 0, 0
    ans := []int{}
    for i < m && j < n {
        if nums1[i] == nums2[j] {
            ans = append(ans, nums1[i])
            i++
            j++
        } else if nums1[i] < nums2[j] {
            i++
        } else {
            j++
        }
    }
    return ans
}

func main() {
    nums1 := []int{1, 2, 2, 1}
    nums2 := []int{2, 2}
    fmt.Println("Intersection:", intersection(nums1, nums2))
}
```

**解析：**

排序 + 双指针实现。先对两个数组进行排序，然后使用两个指针 `i` 和 `j` 分别遍历两个数组。当指针指向的元素相等时，将元素加入答案，并移动两个指针；否则移动较小指针。

时间复杂度为 \(O(m\log m + n\log n)\)，其中 \(m\) 和 \(n\) 分别是两个数组长度。

### 36. 动态规划：零钱兑换

**题目：** 给定不同面额的硬币和一个总金额，计算最少需要多少枚硬币凑出总金额。

**答案：**

```go
package main

import (
    "fmt"
)

func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
        for _, coin := range coins {
            if i-coin >= 0 && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    coins := []int{1, 2, 5}
    amount := 11
    fmt.Println("Minimum coins:", coinChange(coins, amount))
}
```

**解析：**

动态规划。定义一个数组 `dp`，其中 `dp[i]` 表示凑出金额 `i` 的最少硬币数量。遍历每个金额，对于每个硬币，如果当前金额减去硬币面额大于等于 0，且 `dp[i-coin]` 不为无穷大，则更新 `dp[i]`。

时间复杂度为 \(O(amount \times N)\)，其中 \(N\) 是硬币数量。

### 37. 链表：删除链表的倒数第 \(n\) 个节点

**题目：** 删除单链表的倒数第 \(n\) 个节点。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Val: 0, Next: head}
    slow, fast := dummy, head
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        slow = slow.Next
        fast = fast.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}

func main() {
    head := &ListNode{Val: 1,
        Next: &ListNode{Val: 2,
            Next: &ListNode{Val: 3,
                Next: &ListNode{Val: 4,
                    Next: &ListNode{Val: 5}}}}}
    newHead := removeNthFromEnd(head, 2)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：**

使用快慢指针。初始化一个哑节点 `dummy`，快指针 `fast` 先移动 `n` 个节点，然后慢指针 `slow` 和快指针同时移动。当快指针到达链表末尾时，慢指针位于倒数第 \(n\) 个节点。将慢指针的 `Next` 指针指向 `Next.Next`，即可删除倒数第 \(n\) 个节点。

时间复杂度为 \(O(n)\)，其中 \(n\) 是链表长度。

### 38. 图的深度优先搜索：单词查找器

**题目：** 设计一个搜索建议引擎，实现一个搜索建议函数 `suggest`，输入是一个字符串 `word`，返回一个字符串数组，包含所有可能的搜索建议。

**答案：**

```go
package main

import (
    "fmt"
    "strings"
)

var trie *Trie

func init() {
    trie = Constructor()
    words := []string{"hot", "hotpot", "pot", "potion", "pota
```
[...]
```python
    trie.Insert(word)
}

func suggest(words []string) []string {
    ans := []string{}
    for _, word := range words {
        dfs(trie, word, "", &ans)
    }
    return ans
}

func dfs(node *Trie, word string, path string, ans *[]string) {
    if node == nil {
        return
    }
    if node.IsEnd {
        *ans = append(*ans, path+word)
    }
    for i := 0; i < 26; i++ {
        if node.Children[i] != nil {
            dfs(node.Children[i], word, path+string(rune('a'+i)), ans)
        }
    }
}

func main() {
    words := []string{"hot", "hotpot", "pot", "potion", "pota
```
[...]
```python
    fmt.Println("Suggestions:", suggest(words))
}
```

**解析：**

前缀树实现。首先构建一个前缀树，包含所有单词。然后遍历所有单词，对于每个单词，从根节点开始递归查找所有可能的路径，将这些路径加入答案。

时间复杂度为 \(O(nL)\)，其中 \(n\) 是单词数量，\(L\) 是最长单词长度。

### 39. 链表：合并两个有序链表

**题目：** 给出两个有序的链表，将它们合并为一个新的有序链表并返回。不能修改原链表。

**答案：**

递归实现：

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1,
        Next: &ListNode{Val: 2,
            Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1,
        Next: &ListNode{Val: 3,
            Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

迭代实现：

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1,
        Next: &ListNode{Val: 2,
            Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1,
        Next: &ListNode{Val: 3,
            Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：**

递归实现：比较两个链表的头节点，选择较小的节点作为下一个节点，并递归处理剩余的链表。

迭代实现：使用哑节点 `dummy`，遍历两个链表，将较小的节点连接到 `curr` 后续，然后移动 `curr` 和较小节点的指针。

时间复杂度为 \(O(n+m)\)，其中 \(n\) 和 \(m\) 分别是两个链表长度。

### 40. 链表：删除链表的节点

**题目：** 删除链表的节点，给定一个单链表的头节点和要删除的节点的值，删除该节点。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    prev, curr := head, head.Next
    for curr != nil && curr.Val != val {
        prev = curr
        curr = curr.Next
    }
    if curr != nil {
        prev.Next = curr.Next
    }
    return head
}

func main() {
    head := &ListNode{Val: 1,
        Next: &ListNode{Val: 2,
            Next: &ListNode{Val: 3}}}
    newHead := deleteNode(head, 3)
    for newHead != nil {
        fmt.Println(newHead.Val)
        newHead = newHead.Next
    }
}
```

**解析：**

遍历链表，找到要删除的节点，然后将其前一个节点的 `Next` 指针指向要删除节点的下一个节点。如果删除的是头节点，直接返回头节点的下一个节点。

时间复杂度为 \(O(n)\)，其中 \(n\) 是链表长度。

### 41. 栈与队列：实现一个栈

**题目：** 实现一个栈，支持基本的栈操作（push、pop、top）。

**答案：**

```go
package main

import (
    "fmt"
)

type Stack struct {
    Data []int
}

func Constructor() Stack {
    return Stack{Data: []int{}}
}

func (s *Stack) Push(x int) {
    s.Data = append(s.Data, x)
}

func (s *Stack) Pop() int {
    if len(s.Data) == 0 {
        return -1
    }
    x := s.Data[len(s.Data)-1]
    s.Data = s.Data[:len(s.Data)-1]
    return x
}

func (s *Stack) Top() int {
    if len(s.Data) == 0 {
        return -1
    }
    return s.Data[len(s.Data)-1]
}

func (s *Stack) Empty() bool {
    return len(s.Data) == 0
}

func main() {
    stack := Constructor()
    stack.Push(1)
    stack.Push(2)
    fmt.Println("Top:", stack.Top())  // 2
    fmt.Println("Pop:", stack.Pop())  // 2
    fmt.Println("Top:", stack.Top())  // 1
}
```

**解析：**

使用数组实现栈。`push` 操作将元素添加到数组的末尾；`pop` 操作返回并删除数组的最后一个元素；`top` 操作返回数组的最后一个元素；`empty` 操作判断数组是否为空。

时间复杂度为 \(O(1)\)。

### 42. 并查集：判断是否存在环

**题目：** 使用并查集判断一个图是否存在环。

**答案：**

```go
package main

import (
    "fmt"
)

type UnionFind struct {
    Parent []int
}

func Constructor(n int) *UnionFind {
    uf := &UnionFind{
        Parent: make([]int, n),
    }
    for i := 0; i < n; i++ {
        uf.Parent[i] = i
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.Parent[x] != x {
        uf.Parent[x] = uf.Find(uf.Parent[x])
    }
    return uf.Parent[x]
}

func (uf *UnionFind) Union(x int, y int) bool {
    rootX := uf.Find(x)
    rootY := uf.Find(y)
    if rootX == rootY {
        return false
    }
    uf.Parent[rootX] = rootY
    return true
}

func containsCycle(edges [][]int) bool {
    uf := Constructor(len(edges))
    for _, edge := range edges {
        if !uf.Union(edge[0], edge[1]) {
            return true
        }
    }
    return false
}

func main() {
    edges := [][]int{{0, 1}, {1, 2}, {2, 0}, {1, 3}}
    fmt.Println("Contains cycle:", containsCycle(edges))
}
```

**解析：**

并查集实现。每次合并两个节点，如果根节点相同，则说明存在环。

时间复杂度为 \(O(E \alpha(V))\)，其中 \(E\) 是边数，\(V\) 是节点数，\(\alpha(V)\) 是并查集的操作复杂度。

### 43. 贪心算法：硬币找零

**题目：** 给定一个金额和一个硬币数组，计算最少需要多少枚硬币凑出该金额。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func coinChange(coins []int, amount int) int {
    sort.Ints(coins)
    dp := make([]int, amount+1)
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
        for _, coin := range coins {
            if i-coin >= 0 && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    coins := []int{1, 2, 5}
    amount := 11
    fmt.Println("Minimum coins:", coinChange(coins, amount))
}
```

**解析：**

贪心算法 + 动态规划。先对硬币数组进行排序，然后使用动态规划计算最少硬币数量。对于每个金额，计算使用当前硬币的最少数量。

时间复杂度为 \(O(amount \times N)\)，其中 \(N\) 是硬币数量。

### 44. 滑动窗口：最长不含重复字符的子串

**题目：** 给定一个字符串，找出最长不含重复字符的子串的长度。

**答案：**

```go
package main

import (
    "fmt"
)

func lengthOfLongestSubstring(s string) int {
    ans, i, j := 0, 0, 0
    m := map[rune]int{}
    for j < len(s) {
        if m[s[j]] > 0 {
            i = max(m[s[j]], i)
        }
        ans = max(ans, j-i+1)
        m[s[j]]++
        j++
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    s := "abcabcbb"
    fmt.Println("Length of longest substring:", lengthOfLongestSubstring(s))
}
```

**解析：**

滑动窗口。使用两个指针 `i` 和 `j` 表示当前窗口的左右边界，使用哈希表 `m` 记录字符的最后一次出现的位置。当 `j` 指向的字符已出现过时，将 `i` 移动到出现位置之后。

时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串长度。

### 45. 递归与非递归：实现快速排序

**题目：** 实现快速排序算法。

**答案：**

递归实现：

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low int, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

非递归实现：

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low int, high int) {
    stack := []int{}
    stack = append(stack, low)
    stack = append(stack, high)

    for len(stack) > 0 {
        high := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        low := stack[len(stack)-1]
        stack = stack[:len(stack)-1]

        pi := partition(arr, low, high)
        if pi-1 > low {
            stack = append(stack, low)
            stack = append(stack, pi-1)
        }
        if pi+1 < high {
            stack = append(stack, pi+1)
            stack = append(stack, high)
        }
    }
}

func partition(arr []int, low int, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    fmt.Println("Original array:", arr)
    quickSort(arr, 0, len(arr)-1)
    fmt.Println("Sorted array:", arr)
}
```

**解析：**

递归实现：选择一个基准值，将数组划分为两部分，递归地对两部分进行排序。

非递归实现：使用栈实现递归过程，将每个递归调用入栈，然后依次出栈并处理。

时间复杂度为 \(O(n\log n)\)，最坏情况为 \(O(n^2)\)。

### 46. 双指针：环形数组的最小整数

**题目：** 给定一个循环数组，找到数组中的最小整数。

**答案：**

```go
package main

import (
    "fmt"
)

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := left + (right - left) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{3, 4, 5, 1, 2}
    fmt.Println("Minimum value:", findMin(nums))
}
```

**解析：**

双指针实现。将问题转化为在非循环数组中找最小值，当中间值大于右侧值时，说明最小值在右侧，否则在左侧。

时间复杂度为 \(O(n)\)，其中 \(n\) 是数组长度。

### 47. 动态规划：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    fmt.Println("Length of LCS:", longestCommonSubsequence(text1, text2))
}
```

**解析：**

动态规划。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 的前 `i` 个字符和字符串 `text2` 的前 `j` 个字符的最长公共子序列长度。遍历每个字符，根据字符是否相同更新 `dp` 数组。

时间复杂度为 \(O(m\log n)\)，其中 \(m\) 和 \(n\) 分别是两个字符串的长度。

### 48. 栈与队列：实现一个队列

**题目：** 使用栈实现一个队列。

**答案：**

```go
package main

import (
    "fmt"
)

type MyQueue struct {
    Stack1 []int
    Stack2 []int
}

func Constructor() MyQueue {
    return MyQueue{
        Stack1: []int{},
        Stack2: []int{},
    }
}

func (this *MyQueue) Push(x int) {
    this.Stack1 = append(this.Stack1, x)
}

func (this *MyQueue) Pop() int {
    if len(this.Stack2) == 0 {
        for len(this.Stack1) > 0 {
            this.Stack2 = append(this.Stack2, this.Stack1[len(this.Stack1)-1])
            this.Stack1 = this.Stack1[:len(this.Stack1)-1]
        }
    }
    x := this.Stack2[len(this.Stack2)-1]
    this.Stack2 = this.Stack2[:len(this.Stack2)-1]
    return x
}

func (this *MyQueue) Peek() int {
    if len(this.Stack2) == 0 {
        for len(this.Stack1) > 0 {
            this.Stack2 = append(this.Stack2, this.Stack1[len(this.Stack1)-1])
            this.Stack1 = this.Stack1[:len(this.Stack1)-1]
        }
    }
    return this.Stack2[len(this.Stack2)-1]
}

func (this *MyQueue) Empty() bool {
    return len(this.Stack1) == 0 && len(this.Stack2) == 0
}

func main() {
    obj := Constructor()
    obj.Push(1)
    obj.Push(2)
    fmt.Println("Peek:", obj.Peek())   // 1
    fmt.Println("Pop:", obj.Pop())     // 1
    fmt.Println("Empty:", obj.Empty()) // false
}
```

**解析：**

使用两个栈实现队列。`push` 操作将元素入栈 `Stack1`；`pop` 和 `peek` 操作将元素从栈 `Stack1` 移动到栈 `Stack2`，然后从栈 `Stack2` 出栈。

时间复杂度为 \(O(n)\)，其中 \(n\) 是元素数量。

### 49. 图的深度优先搜索：拓扑排序

**题目：** 给定一个有向图，进行拓扑排序。

**答案：**

```go
package main

import (
    "fmt"
)

type Graph struct {
    V   int
    Adj [][]int
}

func (g *Graph) DFS(u int, visited *[]bool, stack *[]int) {
    *visited[u] = true
    for _, v := range g.Adj[u] {
        if !*visited[v] {
            g.DFS(v, visited, stack)
        }
    }
    *stack = append(*stack, u)
}

func拓扑排序(graph *Graph) []int {
    visited := make([]bool, graph.V)
    stack := []int{}

    for i := 0; i < graph.V; i++ {
        if !visited[i] {
            graph.DFS(i, &visited, &stack)
        }
    }
    reverse(stack)
    return stack
}

func reverse(arr *[]int) {
    n := len(*arr)
    for i := 0; i < n/2; i++ {
        (*arr)[i], (*arr)[n-i-1] = (*arr)[n-i-1], (*arr)[i]
    }
}

func main() {
    graph := &Graph{V: 6,
        Adj: [][]int{
            {1, 2},
            {2},
            {3, 5},
            {0, 4},
            {1, 4, 5},
            {3},
        }}
    fmt.Println("Topological sort:",拓扑排序(graph))
}
```

**解析：**

深度优先搜索（DFS）实现。递归遍历每个节点，将每个节点的入度为 0 的节点加入栈。

时间复杂度为 \(O(V+E)\)，其中 \(V\) 是节点数量，\(E\) 是边数量。

### 50. 动态规划：最长公共子串

**题目：** 给定两个字符串，求它们的最长公共子串。

**答案：**

```go
package main

import (
    "fmt"
)

func longestCommonSubstring(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    maxLen, endIndex := 0, 0
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - maxLen
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return text1[endIndex : endIndex+maxLen]
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    fmt.Println("Longest common substring:", longestCommonSubstring(text1, text2))
}
```

**解析：**

动态规划。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 的前 `i` 个字符和字符串 `text2` 的前 `j` 个字符的最长公共子串长度。遍历每个字符，根据字符是否相同更新 `dp` 数组。记录最大长度和对应的位置。

时间复杂度为 \(O(m\log n)\)，其中 \(m\) 和 \(n\) 分别是两个字符串的长度。

