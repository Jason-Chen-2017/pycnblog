                 

### 自拟标题

《众包时代：揭示集体智慧在问题解决中的应用与实践》

### 概述

本文旨在探讨如何利用集体智慧解决复杂问题，以众包为例，介绍一系列实际应用场景，并附上相关领域的典型面试题和算法编程题及详细解析。通过对这些问题的深入剖析，我们希望读者能够更好地理解集体智慧在问题解决中的重要性，并学会在实际项目中有效运用。

### 众包的应用场景

#### 1. 开源社区

- **代码审查：** 社区成员协作审查代码，提高代码质量和安全性。
- **功能建议：** 用户为产品提供改进建议，促进产品迭代。

#### 2. 商业领域

- **产品测试：** 用户测试新产品，收集反馈，优化用户体验。
- **创意征集：** 征集广告创意、Logo 设计等，激发创意灵感。

#### 3. 科学研究

- **数据标注：** 众包数据标注任务，如图片分类、语音识别等，加快研究进程。
- **问题求解：** 社区合作解决科学难题，如数学难题、生物问题等。

### 典型面试题及答案解析

#### 1. 函数是值传递还是引用传递？

**题目：** Golang 中函数参数传递是值传递还是引用传递？请举例说明。

**答案：** Golang 中所有参数都是值传递。这意味着函数接收的是参数的一份拷贝，对拷贝的修改不会影响原始值。

**举例：**

```go
package main

import "fmt"

func modify(x int) {
    x = 100
}

func main() {
    a := 10
    modify(a)
    fmt.Println(a) // 输出 10，而不是 100
}
```

#### 2. 如何安全读写共享变量？

**题目：** 在并发编程中，如何安全地读写共享变量？

**答案：** 可以使用以下方法安全地读写共享变量：

- **互斥锁（sync.Mutex）：** 通过加锁和解锁操作，保证同一时间只有一个 goroutine 可以访问共享变量。
- **读写锁（sync.RWMutex）：** 允许多个 goroutine 同时读取共享变量，但只允许一个 goroutine 写入。
- **原子操作（sync/atomic 包）：** 提供了原子级别的操作，例如 `AddInt32`、`CompareAndSwapInt32` 等，可以避免数据竞争。
- **通道（chan）：** 可以使用通道来传递数据，保证数据同步。

**举例：** 使用互斥锁保护共享变量：

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mu      sync.Mutex
)

func increment() {
    mu.Lock()
    defer mu.Unlock()
    counter++
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
            wg.Add(1)
            go func() {
                    defer wg.Done()
                    increment()
            }()
    }
    wg.Wait()
    fmt.Println("Counter:", counter)
}
```

#### 3. 缓冲、无缓冲 chan 的区别

**题目：** Golang 中，带缓冲和不带缓冲的通道有什么区别？

**答案：**

- **无缓冲通道（unbuffered channel）：** 发送操作会阻塞，直到有接收操作准备好接收数据；接收操作会阻塞，直到有发送操作准备好发送数据。
- **带缓冲通道（buffered channel）：** 发送操作只有在缓冲区满时才会阻塞；接收操作只有在缓冲区为空时才会阻塞。

**举例：**

```go
// 无缓冲通道
c := make(chan int)

// 带缓冲通道，缓冲区大小为 10
c := make(chan int, 10) 
```

### 总结

通过本文，我们介绍了众包在问题解决中的应用场景，并针对常见面试题给出了详细解析。希望本文能够帮助读者更好地理解集体智慧在问题解决中的重要性，并在实际项目中灵活运用。同时，也提醒读者在编程中注意并发编程和通道的使用，以确保代码的可靠性和性能。


### 额外面试题及算法编程题库

#### 4. 快排（Quick Sort）

**题目：** 实现快速排序算法，并分析其时间复杂度。

**答案：**

快速排序算法是一种高效的排序算法，其基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

```go
package main

import "fmt"

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    n := len(arr)
    quickSort(arr, 0, n-1)
    fmt.Println("Sorted array:", arr)
}
```

时间复杂度分析：

- 最好和平均情况：\(O(n \log n)\)
- 最坏情况：\(O(n^2)\)

#### 5. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并成一个有序链表。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result.Val, result.Next.Val, result.Next.Next.Val, result.Next.Next.Next.Val)
}
```

#### 6. 最小路径和

**题目：** 给定一个包含非负数的 m x n 网格，找到一条从左上角到右下角的路径，使得路径上的数字总和为最小值。

**答案：**

```go
package main

import "fmt"

func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i > 0 {
                grid[i][j] += grid[i-1][j]
            }
            if j > 0 {
                grid[i][j] += grid[i][j-1]
            }
        }
    }
    return grid[m-1][n-1]
}

func main() {
    grid := [][]int{
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1},
    }
    fmt.Println("Minimum path sum:", minPathSum(grid))
}
```

#### 7. 反转链表

**题目：** 实现一个函数，用于反转单链表。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head
    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}
    newHead := reverseList(l1)
    fmt.Println("Reversed list:", newHead.Val, newHead.Next.Val, newHead.Next.Next.Val)
}
```

#### 8. 二进制中1的个数

**题目：** 请实现一个函数，用于计算一个无符号整数二进制表示中 1 的个数。

**答案：**

```go
package main

import "fmt"

func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num = num >> 1
    }
    return count
}

func main() {
    fmt.Println("Number of 1s in binary:", hammingWeight(0b1011))
}
```

#### 9. 搜索旋转排序数组

**题目：** 已知一个长度为 n 的数组，假设这个数组在预先未知的某个点上进行了旋转。请编写一个函数，找到并返回数组中的某个元素。

**答案：**

```go
package main

import "fmt"

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println("Index of target:", search(nums, target))
}
```

#### 10. 动态规划之爬楼梯

**题目：** 假设你正在使用一个梯子爬上一座有 n 阶台阶的楼梯。每次你可以爬 1 或 2 个台阶。请问有多少种不同的方法可以爬到楼顶？

**答案：**

```go
package main

import "fmt"

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i < n; i++ {
        a, b = b, a+b
    }
    return b
}

func main() {
    fmt.Println("Number of ways to climb stairs:", climbStairs(5))
}
```

#### 11. 二分查找

**题目：** 在一个有序数组中查找一个目标值，返回其索引。如果不存在，返回 -1。

**答案：**

```go
package main

import "fmt"

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

func main() {
    nums := []int{1, 3, 5, 6}
    target := 5
    fmt.Println("Index of target:", search(nums, target))
}
```

#### 12. 合并两个有序链表

**题目：** 给定两个有序链表，将它们合并为一个有序链表。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result.Val, result.Next.Val, result.Next.Next.Val, result.Next.Next.Next.Val)
}
```

#### 13. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：**

```go
package main

import (
    "fmt"
    "math"
)

func evalRPN(tokens []string) float64 {
    stack := []float64{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            if a == 0 {
                return math.NaN()
            }
            stack = append(stack, a/b)
        default:
            stack = append(stack, float64(parseInt(token)))
        }
    }
    return stack[0]
}

func parseInt(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    num := 0
    for _, digit := range token {
        num = num*10 + int(digit-'0')
    }
    return num * sign
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    fmt.Println("Result:", evalRPN(tokens))
}
```

#### 14. 两数相加

**题目：** 不使用加法运算符，实现两个整数相加的功能。

**答案：**

```go
package main

import "fmt"

func add(a int, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}

func main() {
    a := 1
    b := 2
    fmt.Println("Sum:", add(a, b))
}
```

#### 15. 判断一个数是否是回文数

**题目：** 判断一个整数是否是回文数。回文数是指正反两个方向读取都一样的整数。

**答案：**

```go
package main

import "fmt"

func isPalindrome(x int) bool {
    if x < 0 || (x%10==0 && x!=0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x /= 10
    }
    return x == reversed || x == reversed/10
}

func main() {
    x := 12321
    fmt.Println("Is palindrome:", isPalindrome(x))
}
```

#### 16. 罗马数字转整数

**题目：** 罗马数字包含以下七种字符: I，V，X，L，C，D 和 M。

- 字符          | 预示值
- --------------|--------
- I             | 1
- V             | 5
- X             | 10
- L             | 50
- C             | 100
- D             | 500
- M             | 1000

例如，罗马数字 2 写做 II ，即两个并列的 1。罗马数字 12 写做 XII ，即 X + II 。罗马数字 27 写做 XXVII, 即 XX + V + II 。

请根据罗马数字使用规则，实现一个函数将罗马数字转换为整数。

**答案：**

```go
package main

import "fmt"

func romanToInteger(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    var prev, total int
    for _, v := range s {
        cur := m[v]
        if cur > prev {
            total += cur - 2*prev
        } else {
            total += cur
        }
        prev = cur
    }
    return total
}

func main() {
    s := "III"
    fmt.Println("Integer value:", romanToInteger(s))
}
```

#### 17. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```go
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
        }
        if prefix == "" {
            break
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println("Longest common prefix:", longestCommonPrefix(strs))
}
```

#### 18. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**答案：**

```go
package main

import "fmt"

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    fmt.Println("Length of longest common subsequence:", longestCommonSubsequence(text1, text2))
}
```

#### 19. 合并两个有序链表

**题目：** 给定两个已经排序的单链表，请把它们合并成一个有序链表。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result.Val, result.Next.Val, result.Next.Next.Val, result.Next.Next.Next.Val)
}
```

#### 20. 判断二叉树是否是平衡二叉树

**题目：** 实现一个函数，判断一个二叉树是否是平衡二叉树。

**答案：**

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    leftHeight := getHeight(root.Left)
    rightHeight := getHeight(root.Right)
    if abs(leftHeight-rightHeight) <= 1 && isBalanced(root.Left) && isBalanced(root.Right) {
        return true
    }
    return false
}

func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    return 1 + max(getHeight(node.Left), getHeight(node.Right))
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}

func main() {
    root := &TreeNode{Val: 3,
                      Left: &TreeNode{Val: 4,
                                      Left: &TreeNode{Val: 5},
                                      Right: &TreeNode{Val: 6}},
                      Right: &TreeNode{Val: 2,
                                       Left: &TreeNode{Val: 7},
                                       Right: &TreeNode{Val: 8}}}
    fmt.Println("Is balanced:", isBalanced(root))
}
```

#### 21. 链表中的环

**题目：** 给定一个链表，判断链表中是否存在环。

**答案：**

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}
    head.Next.Next.Next.Next = &ListNode{Val: 6}
    fmt.Println("Has cycle:", hasCycle(head))
}
```

#### 22. 快速幂算法

**题目：** 实现一个快速幂算法，计算 \(a^{n}\) 的值。

**答案：**

```go
package main

import "fmt"

func myPow(x float64, n int) float64 {
    if n < 0 {
        return 1 / myPow(x, -n)
    }
    res := 1
    for n > 0 {
        if n&1 == 1 {
            res *= x
        }
        x *= x
        n >>= 1
    }
    return res
}

func main() {
    x := 2.0
    n := 10
    fmt.Println("Result:", myPow(x, n))
}
```

#### 23. 双指针法解决链表问题

**题目：** 使用双指针法解决链表中的问题，如检测链表中的环、找出链表中的中间节点等。

**答案：**

```go
package main

import "fmt"

// 双指针法检测链表中是否有环
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

// 双指针法找出链表中的中间节点
func middleNode(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}
    fmt.Println("Has cycle:", hasCycle(head))
    fmt.Println("Middle node value:", middleNode(head).Val)
}
```

#### 24. 常见的字符串匹配算法

**题目：** 实现几种常见的字符串匹配算法，如 Brute-Force、KMP、Rabin-Karp 等。

**答案：**

**Brute-Force：**

```go
package main

import "fmt"

// 暴力法匹配字符串
func bruteForce(s, p string) int {
    for i := 0; i <= len(s)-len(p); i++ {
        for j := 0; j < len(p); j++ {
            if s[i+j] != p[j] {
                break
            }
            if j == len(p)-1 {
                return i
            }
        }
    }
    return -1
}

func main() {
    s := "hello"
    p := "ll"
    fmt.Println("Index of pattern:", bruteForce(s, p))
}
```

**KMP：**

```go
package main

import "fmt"

// KMP 算法预处理部分
func computeLPSArray(pat *[]rune, lps *[]int) {
    lenPat := len(*pat)
    lenLPS := 0
    *lps = make([]int, lenPat)
    i := 1
    for i < lenPat {
        if (*pat)[i] == (*pat)[lenLPS] {
            lenLPS++
            (*lps)[i] = lenLPS
            i++
        } else {
            if lenLPS != 0 {
                lenLPS = (*lps)[lenLPS-1]
            } else {
                (*lps)[i] = 0
                i++
            }
        }
    }
}

// KMP 算法匹配部分
func KMP(s, p string) int {
    m, n := len(s), len(p)
    pat := []rune(p)
    lps := make([]int, n)
    computeLPSArray(&pat, &lps)
    i, j := 0, 0
    for i < m {
        if pat[j] == s[i] {
            i++
            j++
        }
        if j == n {
            return i - j
        } else if i < m && pat[j] != s[i] {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    return -1
}

func main() {
    s := "hello world"
    p := "world"
    fmt.Println("Index of pattern:", KMP(s, p))
}
```

**Rabin-Karp：**

```go
package main

import (
    "fmt"
    "math"
)

const prime int = 101

// Rabin-Karp 算法匹配字符串
func RabinKarp(s, p string) int {
    n, m := len(s), len(p)
    hashS, hashP := 0, 0
    h := 1
    for i := 0; i < m; i++ {
        h = h*256 % prime
    }
    for i := 0; i < m; i++ {
        hashP = (hashP*256 + int(p[i])) % prime
    }
    for i := 0; i <= n-m; i++ {
        hashS = (hashS*256 + int(s[i])) % prime
        if i == m-1 {
            if hashS == hashP {
                for j := 0; j < m; j++ {
                    if s[i-j] != p[j] {
                        break
                    }
                    if j == m-1 {
                        return i - j
                    }
                }
            }
        }
        if i < n-m {
            hashS = (hashS-int(s[i])*h)%prime + int(s[i+m])*256
            hashS = (hashS + prime) % prime
        }
    }
    return -1
}

func main() {
    s := "hello world"
    p := "world"
    fmt.Println("Index of pattern:", RabinKarp(s, p))
}
```

#### 25. 回溯算法

**题目：** 实现回溯算法解决组合、排列、子集等问题。

**答案：**

**组合问题：**

```go
package main

import "fmt"

func combine(n int, k int) [][]int {
    var result [][]int
    current := make([]int, 0)
    backtracking(&result, &current, 1, n, k)
    return result
}

func backtracking(result *[][]int, current *[]int, start, n, k int) {
    if len(*current) == k {
        temp := make([]int, len(*current))
        copy(temp, *current)
        *result = append(*result, temp)
        return
    }
    for i := start; i <= n; i++ {
        *current = append(*current, i)
        backtracking(result, current, i+1, n, k)
        *current = (*current)[:len(*current)-1]
    }
}

func main() {
    n, k := 4, 2
    fmt.Println("Combination:", combine(n, k))
}
```

**排列问题：**

```go
package main

import "fmt"

func permute(nums []int) [][]int {
    var result [][]int
    current := make([]int, 0)
    backtracking(&result, &current, nums)
    return result
}

func backtracking(result *[][]int, current *[]int, nums []int) {
    if len(*current) == len(nums) {
        temp := make([]int, len(*current))
        copy(temp, *current)
        *result = append(*result, temp)
        return
    }
    for i := 0; i < len(nums); i++ {
        if used[i] {
            continue
        }
        used[i] = true
        *current = append(*current, nums[i])
        backtracking(result, current, nums)
        used[i] = false
        *current = (*current)[:len(*current)-1]
    }
}

var used = make([]bool, 0)

func main() {
    nums := []int{1, 2, 3}
    fmt.Println("Permutations:", permute(nums))
}
```

**子集问题：**

```go
package main

import "fmt"

func subsets(nums []int) [][]int {
    var result [][]int
    current := make([]int, 0)
    backtracking(&result, &current, nums)
    return result
}

func backtracking(result *[][]int, current *[]int, nums []int) {
    *result = append(*result, append(make([]int, 0, len(*current)), *current...))
    for i := 0; i < len(nums); i++ {
        *current = append(*current, nums[i])
        backtracking(result, current, nums[i+1:])
        *current = (*current)[:len(*current)-1]
    }
}

func main() {
    nums := []int{1, 2, 3}
    fmt.Println("Subsets:", subsets(nums))
}
```

#### 26. 二进制表示中的1的个数

**题目：** 编写一个函数，输入一个无符号整数，返回其二进制表达式中 1 的个数。

**答案：**

```go
package main

import "fmt"

func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}

func main() {
    num := uint32(0b1011)
    fmt.Println("Number of 1s in binary:", hammingWeight(num))
}
```

#### 27. 数组中的第K个最大元素

**题目：** 在未排序的数组中，找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

func findKthLargest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[len(nums)-k]
}

func main() {
    nums := []int{3, 2, 1, 5, 6, 4}
    k := 2
    fmt.Println("The kth largest element is:", findKthLargest(nums, k))
}
```

#### 28. 设计一个支持增量操作的栈

**题目：** 设计一个支持增量操作的栈，你需要实现一个这样的栈，栈中的栈顶元素是递增有序的，并且可以执行以下操作：

- `pushVal(val)`：将元素`val`插入栈顶。
- `popInc()`：删除栈顶元素并将该元素的增量返回。
- `popDec()`：删除栈顶元素并将该元素的增量返回。

**答案：**

```go
package main

import (
    "fmt"
    "sort"
)

type MinStack struct {
    Stack   []int
    IncStack []int
}

func Constructor() MinStack {
    return MinStack{
        Stack:   []int{},
        IncStack: []int{},
    }
}

func (this *MinStack) Push(val int) {
    this.Stack = append(this.Stack, val)
    if len(this.IncStack) > 0 {
        this.IncStack = append(this.IncStack, this.IncStack[len(this.IncStack)-1]+val)
    } else {
        this.IncStack = append(this.IncStack, val)
    }
}

func (this *MinStack) PopInc() int {
    topVal := this.Stack[len(this.Stack)-1]
    this.Stack = this.Stack[:len(this.Stack)-1]
    this.IncStack = this.IncStack[:len(this.IncStack)-1]
    return topVal
}

func (this *MinStack) PopDec() int {
    topVal := this.Stack[len(this.Stack)-1]
    this.Stack = this.Stack[:len(this.Stack)-1]
    this.IncStack = this.IncStack[:len(this.IncStack)-1]
    return topVal - this.IncStack[len(this.IncStack)-1]
}

func main() {
    obj := Constructor()
    obj.Push(1)
    obj.Push(2)
    obj.Push(3)
    fmt.Println("Increment:", obj.PopInc())  // 输出 2
    fmt.Println("Decrement:", obj.PopDec()) // 输出 1
}
```

#### 29. 二叉树的层序遍历

**题目：** 给定一个二叉树，返回其节点值的层序遍历。即逐层按从左到右的顺序返回每个层的节点值。

**答案：**

```go
package main

import (
    "fmt"
    "container/list"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    result := make([][]int, 0)
    if root == nil {
        return result
    }
    queue := list.New()
    queue.PushBack(root)
    for queue.Len() > 0 {
        level := make([]int, 0)
        for queue.Len() > 0 {
            node := queue.Front()
            queue.Remove(node)
            level = append(level, node.Value.(*TreeNode).Val)
            if node.Value.(*TreeNode).Left != nil {
                queue.PushBack(node.Value.(*TreeNode).Left)
            }
            if node.Value.(*TreeNode).Right != nil {
                queue.PushBack(node.Value.(*TreeNode).Right)
            }
        }
        result = append(result, level)
    }
    return result
}

func main() {
    root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 20}}, Right: &TreeNode{Val: 10, Left: &TreeNode{Val: 5}}}
    fmt.Println("Level order traversal:", levelOrder(root))
}
```

#### 30. 盛水最多的容器

**题目：** 给定一个二叉树，找出其最大深度。

**答案：**

```go
package main

import (
    "fmt"
)

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return 1 + max(leftDepth, rightDepth)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 20}}, Right: &TreeNode{Val: 10, Left: &TreeNode{Val: 5}}}
    fmt.Println("Max depth:", maxDepth(root))
}
```

### 完整代码示例

以下是所有题目和算法编程题的完整代码示例：

```go
// 快速排序算法
package main

import "fmt"

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j <= high-1; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    n := len(arr)
    quickSort(arr, 0, n-1)
    fmt.Println("Sorted array:", arr)
}

// 合并两个有序链表
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result.Val, result.Next.Val, result.Next.Next.Val, result.Next.Next.Next.Val)
}

// 最小路径和
package main

import "fmt"

func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i > 0 {
                grid[i][j] += grid[i-1][j]
            }
            if j > 0 {
                grid[i][j] += grid[i][j-1]
            }
        }
    }
    return grid[m-1][n-1]
}

func main() {
    grid := [][]int{
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1},
    }
    fmt.Println("Minimum path sum:", minPathSum(grid))
}

// 反转链表
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head
    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }
    return prev
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3}}}
    newHead := reverseList(l1)
    fmt.Println("Reversed list:", newHead.Val, newHead.Next.Val, newHead.Next.Next.Val)
}

// 二进制中1的个数
package main

import "fmt"

func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}

func main() {
    fmt.Println("Number of 1s in binary:", hammingWeight(0b1011))
}

// 搜索旋转排序数组
package main

import "fmt"

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[left] <= nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println("Index of target:", search(nums, target))
}

// 动态规划之爬楼梯
package main

import "fmt"

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i < n; i++ {
        a, b = b, a+b
    }
    return b
}

func main() {
    fmt.Println("Number of ways to climb stairs:", climbStairs(5))
}

// 二分查找
package main

import "fmt"

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}

func main() {
    nums := []int{1, 3, 5, 6}
    target := 5
    fmt.Println("Index of target:", search(nums, target))
}

// 合并两个有序链表
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }
    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }
    return dummy.Next
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result.Val, result.Next.Val, result.Next.Next.Val, result.Next.Next.Next.Val)
}

// 逆波兰表达式求值
package main

import (
    "fmt"
    "math"
)

func evalRPN(tokens []string) float64 {
    stack := []float64{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            if a == 0 {
                return math.NaN()
            }
            stack = append(stack, a/b)
        default:
            stack = append(stack, float64(parseInt(token)))
        }
    }
    return stack[0]
}

func parseInt(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    num := 0
    for _, digit := range token {
        num = num*10 + int(digit-'0')
    }
    return num * sign
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    fmt.Println("Result:", evalRPN(tokens))
}

// 两数相加
package main

import "fmt"

func add(a int, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}

func main() {
    a := 1
    b := 2
    fmt.Println("Sum:", add(a, b))
}

// 判断一个数是否是回文数
package main

import "fmt"

func isPalindrome(x int) bool {
    if x < 0 || (x%10==0 && x!=0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x /= 10
    }
    return x == reversed || x == reversed/10
}

func main() {
    x := 12321
    fmt.Println("Is palindrome:", isPalindrome(x))
}

// 罗马数字转整数
package main

import "fmt"

func romanToInteger(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }
    var prev, total int
    for _, v := range s {
        cur := m[v]
        if cur > prev {
            total += cur - 2*prev
        } else {
            total += cur
        }
        prev = cur
    }
    return total
}

func main() {
    s := "III"
    fmt.Println("Integer value:", romanToInteger(s))
}

// 最长公共前缀
package main

import "fmt"

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 && !strings.HasPrefix(strs[i], prefix) {
            prefix = prefix[:len(prefix)-1]
        }
        if prefix == "" {
            break
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println("Longest common prefix:", longestCommonPrefix(strs))
}

// 最长公共子序列
package main

import "fmt"

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    fmt.Println("Length of longest common subsequence:", longestCommonSubsequence(text1, text2))
}

// 合并两个有序链表
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 5}}}
    l2 := &ListNode{Val: 2, Next: &ListNode{Val: 4, Next: &ListNode{Val: 6}}}
    result := mergeTwoLists(l1, l2)
    fmt.Println("Merged list:", result.Val, result.Next.Val, result.Next.Next.Val, result.Next.Next.Next.Val)
}

// 链表中的环
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}
    head.Next.Next.Next = &ListNode{Val: 6}
    fmt.Println("Has cycle:", hasCycle(head))
}

// 快速幂算法
package main

import "fmt"

func myPow(x float64, n int) float64 {
    if n < 0 {
        return 1 / myPow(x, -n)
    }
    res := 1
    for n > 0 {
        if n&1 == 1 {
            res *= x
        }
        x *= x
        n >>= 1
    }
    return res
}

func main() {
    x := 2.0
    n := 10
    fmt.Println("Result:", myPow(x, n))
}

// 双指针法解决链表问题
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func middleNode(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}

func main() {
    head := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: &ListNode{Val: 5}}}}}
    fmt.Println("Has cycle:", hasCycle(head))
    fmt.Println("Middle node value:", middleNode(head).Val)
}

// 常见的字符串匹配算法
package main

import "fmt"

// 暴力法匹配字符串
func bruteForce(s, p string) int {
    for i := 0; i <= len(s)-len(p); i++ {
        for j := 0; j < len(p); j++ {
            if s[i+j] != p[j] {
                break
            }
            if j == len(p)-1 {
                return i
            }
        }
    }
    return -1
}

// KMP 算法预处理部分
func computeLPSArray(pat *[]rune, lps *[]int) {
    lenPat := len(*pat)
    lenLPS := 0
    *lps = make([]int, lenPat)
    i := 1
    for i < lenPat {
        if (*pat)[i] == (*pat)[lenLPS] {
            lenLPS++
            (*lps)[i] = lenLPS
            i++
        } else {
            if lenLPS != 0 {
                lenLPS = (*lps)[lenLPS-1]
            } else {
                (*lps)[i] = 0
                i++
            }
        }
    }
}

// KMP 算法匹配部分
func KMP(s, p string) int {
    m, n := len(s), len(p)
    pat := []rune(p)
    lps := make([]int, n)
    computeLPSArray(&pat, &lps)
    i, j := 0, 0
    for i < m {
        if pat[j] == s[i] {
            i++
            j++
        }
        if j == n {
            return i - j
        } else if i < m && pat[j] != s[i] {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    return -1
}

// Rabin-Karp 算法匹配字符串
func RabinKarp(s, p string) int {
    n, m := len(s), len(p)
    hashS, hashP := 0, 0
    h := 1
    for i := 0; i < m; i++ {
        h = h*256 % prime
    }
    for i := 0; i < m; i++ {
        hashP = (hashP*256 + int(p[i])) % prime
    }
    for i := 0; i <= n-m; i++ {
        hashS = (hashS*256 + int(s[i])) % prime
        if i == m-1 {
            if hashS == hashP {
                for j := 0; j < m; j++ {
                    if s[i-j] != p[j] {
                        break
                    }
                    if j == m-1 {
                        return i - j
                    }
                }
            }
        }
        if i < n-m {
            hashS = (hashS-int(s[i])*h)%prime + int(s[i+m])*256
            hashS = (hashS + prime) % prime
        }
    }
    return -1
}

func main() {
    s := "hello"
    p := "ll"
    fmt.Println("Index of pattern:", bruteForce(s, p))
    fmt.Println("Index of pattern:", KMP(s, p))
    fmt.Println("Index of pattern:", RabinKarp(s, p))
}

// 回溯算法
package main

import "fmt"

// 组合问题
func combine(n int, k int) [][]int {
    var result [][]int
    current := make([]int, 0)
    backtracking(&result, &current, 1, n, k)
    return result
}

func backtracking(result *[][]int, current *[]int, start, n, k int) {
    if len(*current) == k {
        temp := make([]int, len(*current))
        copy(temp, *current)
        *result = append(*result, temp)
        return
    }
    for i := start; i <= n; i++ {
        *current = append(*current, i)
        backtracking(result, current, i+1, n, k)
        *current = (*current)[:len(*current)-1]
    }
}

func main() {
    n, k := 4, 2
    fmt.Println("Combination:", combine(n, k))

    // 排列问题
    func permute(nums []int) [][]int {
        var result [][]int
        current := make([]int, 0)
        backtracking(&result, &current, nums)
        return result
    }

    func backtracking(result *[][]int, current *[]int, nums []int) {
        if len(*current) == len(nums) {
            temp := make([]int, len(*current))
            copy(temp, *current)
            *result = append(*result, temp)
            return
        }
        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            used[i] = true
            *current = append(*current, nums[i])
            backtracking(result, current, nums)
            used[i] = false
            *current = (*current)[:len(*current)-1]
        }
    }

    var used = make([]bool, 0)

    func main() {
        nums := []int{1, 2, 3}
        fmt.Println("Permutations:", permute(nums))

        // 子集问题
        func subsets(nums []int) [][]int {
            var result [][]int
            current := make([]int, 0)
            backtracking(&result, &current, nums)
            return result
        }

        func backtracking(result *[][]int, current *[]int, nums []int) {
            *result = append(*result, append(make([]int, 0, len(*current)), *current...))
            for i := 0; i < len(nums); i++ {
                *current = append(*current, nums[i])
                backtracking(result, current, nums[i+1:])
                *current = (*current)[:len(*current)-1]
            }
        }

        func main() {
            nums := []int{1, 2, 3}
            fmt.Println("Subsets:", subsets(nums))
        }
    }
}

// 二进制表示中的1的个数
package main

import "fmt"

func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}

func main() {
    fmt.Println("Number of 1s in binary:", hammingWeight(0b1011))

    // 数组中的第K个最大元素
    package main

import (
    "fmt"
    "sort"
)

func findKthLargest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[len(nums)-k]
}

func main() {
    nums := []int{3, 2, 1, 5, 6, 4}
    k := 2
    fmt.Println("The kth largest element is:", findKthLargest(nums, k))

    // 设计一个支持增量操作的栈
    package main

import (
    "fmt"
    "sort"
)

type MinStack struct {
    Stack   []int
    IncStack []int
}

func Constructor() MinStack {
    return MinStack{
        Stack:   []int{},
        IncStack: []int{},
    }
}

func (this *MinStack) Push(val int) {
    this.Stack = append(this.Stack, val)
    if len(this.IncStack) > 0 {
        this.IncStack = append(this.IncStack, this.IncStack[len(this.IncStack)-1]+val)
    } else {
        this.IncStack = append(this.IncStack, val)
    }
}

func (this *MinStack) PopInc() int {
    topVal := this.Stack[len(this.Stack)-1]
    this.Stack = this.Stack[:len(this.Stack)-1]
    this.IncStack = this.IncStack[:len(this.IncStack)-1]
    return topVal
}

func (this *MinStack) PopDec() int {
    topVal := this.Stack[len(this.Stack)-1]
    this.Stack = this.Stack[:len(this.Stack)-1]
    this.IncStack = this.IncStack[:len(this.IncStack)-1]
    return topVal - this.IncStack[len(this.IncStack)-1]
}

func main() {
    obj := Constructor()
    obj.Push(1)
    obj.Push(2)
    obj.Push(3)
    fmt.Println("Increment:", obj.PopInc())  // 输出 2
    fmt.Println("Decrement:", obj.PopDec()) // 输出 1

    // 二叉树的层序遍历
    package main

import (
    "fmt"
    "container/list"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func levelOrder(root *TreeNode) [][]int {
    result := make([][]int, 0)
    if root == nil {
        return result
    }
    queue := list.New()
    queue.PushBack(root)
    for queue.Len() > 0 {
        level := make([]int, 0)
        for queue.Len() > 0 {
            node := queue.Front()
            queue.Remove(node)
            level = append(level, node.Value.(*TreeNode).Val)
            if node.Value.(*TreeNode).Left != nil {
                queue.PushBack(node.Value.(*TreeNode).Left)
            }
            if node.Value.(*TreeNode).Right != nil {
                queue.PushBack(node.Value.(*TreeNode).Right)
            }
        }
        result = append(result, level)
    }
    return result
}

func main() {
    root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 20}}, Right: &TreeNode{Val: 10, Left: &TreeNode{Val: 5}}}
    fmt.Println("Level order traversal:", levelOrder(root))

    // 盛水最多的容器
    package main

import (
    "fmt"
)

func maxArea(height []int) int {
    left, right := 0, len(height)-1
    ans := 0
    for left < right {
        ans = max(ans, min(height[left], height[right])*(right-left))
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    return ans
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    fmt.Println("Max area:", maxArea(height))

    // 给定一个二叉树，找出其最大深度
    package main

import (
    "fmt"
)

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return 1 + max(leftDepth, rightDepth)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 20}}, Right: &TreeNode{Val: 10, Left: &TreeNode{Val: 5}}}
    fmt.Println("Max depth:", maxDepth(root))
}
```

