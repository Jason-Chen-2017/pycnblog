                 

# 2025 华为社招面试算法题库大全

## 1. 回文数

### 题目

判断一个整数是否是回文数。回文数是指正反两个方向都一样的整数。

### 示例

```text
输入: 121
输出: true

输入: -121
输出: false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

输入: 10
输出: false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

### 解题思路

- 判断输入数字是否为负数，如果是，直接返回 false。
- 将输入数字转换为字符串，利用字符串的 reverse 函数进行反转。
- 将反转后的字符串转换为整数，判断原数字与反转后的数字是否相等。

### 代码实现

```go
package main

import (
    "strconv"
    "strings"
)

func isPalindrome(x int) bool {
    if x < 0 {
        return false
    }

    strX := strconv.Itoa(x)
    reversedStrX := reverseString(strX)
    reversedX, _ := strconv.Atoi(reversedStrX)

    return x == reversedX
}

func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func main() {
    x := 121
    if isPalindrome(x) {
        fmt.Println("是回文数")
    } else {
        fmt.Println("不是回文数")
    }
}
```

## 2. 两数相加

### 题目

给定两个非空链表表示两个非负整数，链表中的每个节点包含一个数字。需要将这两个数相加并返回一个新的链表表示相加的结果。

### 示例

```text
输入：([2, 4, 3], [5, 6, 4])
输出：[7, 0, 8]
解释：342 + 465 = 807。
```

### 解题思路

- 初始化一个新的链表，用于存储相加的结果。
- 将两个链表从头到尾遍历，逐位相加，如果相加结果大于等于 10，则需要进位。
- 如果两个链表长度不同，则将较长的链表剩余部分添加到结果链表的末尾。
- 返回结果链表。

### 代码实现

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        sum = sum % 10

        current.Next = &ListNode{Val: sum}
        current = current.Next
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{2, &ListNode{4, &ListNode{3, nil}}}
    l2 := &ListNode{5, &ListNode{6, &ListNode{4, nil}}}
    result := addTwoNumbers(l1, l2)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
}
```

## 3. 三数之和

### 题目

给定一个包含 n 个整数的数组 `nums`，判断是否存在三个元素 `a, b, c` 使得 `a + b + c = 0`？找出所有满足条件且不重复的三元组。

### 示例

```text
输入：nums = [-1, 0, 1, 2, -1, -4]
输出：[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

### 解题思路

- 对数组进行排序。
- 遍历数组，对于每个元素，使用双指针法找到另外两个元素。
- 避免重复情况。

### 代码实现

```go
package main

import (
    "sort"
)

func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var result [][]int

    for i := 0; i < len(nums)-2; i++ {
        // 避免重复情况
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                left++
                right--
                // 避免重复情况
                for left < right && nums[left] == nums[left-1] {
                    left++
                }
                for left < right && nums[right] == nums[right+1] {
                    right--
                }
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }

    return result
}

func main() {
    nums := []int{-1, 0, 1, 2, -1, -4}
    result := threeSum(nums)
    for _, trio := range result {
        fmt.Printf("%v ", trio)
    }
}
```

## 4. 四数之和

### 题目

给定一个包含 n 个整数的数组 `nums`，判断是否存在四个元素 `a, b, c, d` 使得 `a + b + c + d = 0`？找出所有满足条件且不重复的四元组。

### 示例

```text
输入：nums = [1, 0, -1, 0, -2, 2]
输出：[
  [-2, -1, 1, 2],
  [-2, 0, 0, 2],
  [-1, 0, 0, 1]
]
```

### 解题思路

- 对数组进行排序。
- 遍历数组，对于每个元素，使用双指针法找到另外三个元素。
- 避免重复情况。

### 代码实现

```go
package main

import (
    "sort"
)

func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    var result [][]int

    for i := 0; i < len(nums)-3; i++ {
        // 避免重复情况
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        for j := i + 1; j < len(nums)-2; j++ {
            // 避免重复情况
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }

            left, right := j+1, len(nums)-1
            for left < right {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum == target {
                    result = append(result, []int{nums[i], nums[j], nums[left], nums[right]})
                    left++
                    right--
                    // 避免重复情况
                    for left < right && nums[left] == nums[left-1] {
                        left++
                    }
                    for left < right && nums[right] == nums[right+1] {
                        right--
                    }
                } else if sum < target {
                    left++
                } else {
                    right--
                }
            }
        }
    }

    return result
}

func main() {
    nums := []int{1, 0, -1, 0, -2, 2}
    result := fourSum(nums, 0)
    for _, quad := range result {
        fmt.Printf("%v ", quad)
    }
}
```

## 5. 爬楼梯

### 题目

假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次你可以爬 1 或 2 个台阶。请问有多少种不同的方法可以爬到楼顶？

### 示例

```text
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

### 解题思路

- 使用动态规划，定义 `dp[i]` 为爬到第 i 个台阶的方法数。
- 状态转移方程为 `dp[i] = dp[i-1] + dp[i-2]`。
- 初始化 `dp[0] = 1`，`dp[1] = 1`。

### 代码实现

```go
package main

import "fmt"

func climbStairs(n int) int {
    if n == 0 || n == 1 {
        return 1
    }

    dp := make([]int, n+1)
    dp[0], dp[1] = 1, 1

    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}

func main() {
    n := 3
    result := climbStairs(n)
    fmt.Println("方法数：", result)
}
```

## 6. 逆波兰表达式求值

### 题目

给定一个逆波兰表达式（后缀表示法），求其对应的值。

### 示例

```text
输入：["2", "1", "+", "3", "*"]
输出：9
解释：((2 + 1) * 3) = 9

输入：["4", "13", "5", "/", "+"]
输出：6
解释：(4 + (13 / 5)) = 6

输入：["10", "6", "9", "3", "+", "-11", "*", "/"]
输出：-22
解释：((10 * (6 / (-11))) + 9) - 3 = -22
```

### 解题思路

- 使用栈存储操作数和操作符。
- 遍历表达式，遇到数字直接入栈；遇到操作符，从栈顶弹出相应数量的数字进行运算，将结果入栈。
- 最后栈顶元素即为表达式的值。

### 代码实现

```go
package main

import (
    "math"
    "strconv"
)

func evalRPN(tokens []string) int {
    var stack []int

    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, int(float64(a)/float64(b)))
        default:
            num, _ := strconv.Atoi(token)
            stack = append(stack, num)
        }
    }

    return stack[0]
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    result := evalRPN(tokens)
    fmt.Println("结果：", result)
}
```

## 7. 盛水问题

### 题目

给定一个由若干个非负整数 a1，a2，...，an 组成的数组，确定能否将其分成三个部分，使得这三个部分各自和相等。

### 示例

```text
输入：[0, 2, 1, 5, 3, 4]
输出：true
解释：可以将数组分成 [0, 2, 1] + [5, 3] + [4]。

输入：[2, 2, 2, 11, 2]
输出：true
解释：可以将数组分成 [2, 2, 2] + [11] + [2]。
```

### 解题思路

- 使用哈希表存储每个数字的和。
- 遍历数组，对于每个元素，检查是否存在两个和相等的部分，其中一个部分以当前元素为结尾。

### 代码实现

```go
package main

import (
    "fmt"
    "map"
)

func canThreePartsEqualSum(A []int) bool {
    sum := 0
    m := map[int]bool{}

    for _, num := range A {
        sum += num
        m[sum] = true
    }

    count := 0
    currentSum := 0

    for _, num := range A {
        currentSum += num

        if currentSum == sum/3 {
            count++
            currentSum = 0
        }
    }

    if count >= 3 {
        return true
    }

    return false
}

func main() {
    A := []int{0, 2, 1, 5, 3, 4}
    result := canThreePartsEqualSum(A)
    fmt.Println("能否分成三个部分和相等：", result)
}
```

## 8. 最大子序和

### 题目

给定一个整数数组 `nums`，找出一个连续子数组，使子数组内所有元素之和最大，并返回该子数组的和。

### 示例

```text
输入：nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
输出：6
解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6。
```

### 解题思路

- 初始化最大子序和为第一个元素，当前子序和也为第一个元素。
- 遍历数组，对于每个元素，计算当前子序和，如果当前子序和小于零，则重置为下一个元素。
- 更新最大子序和，取当前最大子序和和当前子序和的较大值。

### 代码实现

```go
package main

import (
    "fmt"
)

func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }

    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Println("最大子序和：", result)
}
```

## 9. 合并两个有序链表

### 题目

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

### 示例

```text
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

### 解题思路

- 创建一个新的链表，用于存储合并后的结果。
- 比较两个链表的当前节点值，将较小的值添加到新链表中。
- 移动被添加节点所对应的链表指针。

### 代码实现

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }

    if l1 != nil {
        current.Next = l1
    } else if l2 != nil {
        current.Next = l2
    }

    return dummy.Next
}

func main() {
    l1 := &ListNode{1, &ListNode{2, &ListNode{4, nil}}}
    l2 := &ListNode{1, &ListNode{3, &ListNode{4, nil}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
}
```

## 10. 翻转链表

### 题目

定义一个函数，输入一个链表的头节点，反转该链表并返回新链表的的头节点。

### 示例

```text
输入：1->2->3->4->5
输出：5->4->3->2->1
```

### 解题思路

- 初始化三个指针，分别表示前一个节点、当前节点和下一个节点。
- 依次将当前节点的 `next` 指针指向前一个节点，然后移动三个指针。
- 最后，当前节点即为新的头节点。

### 代码实现

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    prev := nil
    current := head

    for current != nil {
        next := current.Next
        current.Next = prev
        prev = current
        current = next
    }

    return prev
}

func main() {
    l := &ListNode{1, &ListNode{2, &ListNode{3, &ListNode{4, &ListNode{5, nil}}}}}
    result := reverseList(l)
    for result != nil {
        fmt.Printf("%d ", result.Val)
        result = result.Next
    }
}
```

## 11. 最长公共前缀

### 题目

编写一个函数来查找字符串数组中的最长公共前缀。

### 示例

```text
输入：["flower","flow","flight"]
输出："fl"

输入：["dog","racecar","car"]
输出：""

提示：

- 所有输入只包含小写字母 a-z。
```

### 解题思路

- 首先确定最长公共前缀的长度，初始化为第一个字符串的长度。
- 遍历数组中的每个字符串，与最长公共前缀进行比较，更新最长公共前缀的长度。
- 使用字符串的 `commonPrefix` 方法，获取两个字符串的最长公共前缀。

### 代码实现

```go
package main

import (
    "fmt"
    "strings"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        prefix = strings.CommonPrefix(prefix, strs[i])
        if prefix == "" {
            break
        }
    }

    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("最长公共前缀：", result)
}
```

## 12. 二进制求和

### 题目

给你两个二进制字符串，返回它们的和（用二进制表示）。

### 示例

```text
输入：a = "11", b = "1"
输出："100"

输入：a = "1010", b = "1011"
输出："10101"
```

### 解题思路

- 将两个二进制字符串拼接在一起。
- 将拼接后的字符串转换为整数。
- 将整数转换为二进制字符串。

### 代码实现

```go
package main

import (
    "fmt"
    "math"
    "strconv"
)

func addBinary(a string, b string) string {
    maxLen := max(len(a), len(b))
    a = strings.Repeat("0", maxLen-len(a)) + a
    b = strings.Repeat("0", maxLen-len(b)) + b

    result := ""
    carry := 0

    for i := maxLen - 1; i >= 0; i-- {
        sum := int(a[i]-'0') + int(b[i]-'0') + carry
        result = strconv.Itoa(sum%2) + result
        carry = sum / 2
    }

    if carry > 0 {
        result = strconv.Itoa(carry) + result
    }

    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    a := "11"
    b := "1"
    result := addBinary(a, b)
    fmt.Println("二进制和：", result)

    a = "1010"
    b = "1011"
    result = addBinary(a, b)
    fmt.Println("二进制和：", result)
}
```

## 13. 合并 k 个排序链表

### 题目

给定一个链表数组，每个链表都已经按升序排列，请将它们合并为一个新的 sorted 链表并返回。

### 示例

```text
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并类似于这样的形式：
1->1->2->3->4->4->5->6
```

### 解题思路

- 初始化一个空的优先级队列，用于存储链表节点。
- 将所有链表头节点加入优先级队列。
- 依次取出优先级队列中的最小节点，将其值添加到结果链表中，并将该节点的下一个节点加入优先级队列。
- 当优先级队列为空时，说明所有节点已经取出，返回结果链表。

### 代码实现

```go
package main

import (
    "container/heap"
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

type ListNodeHeap []*ListNode

func (h List

