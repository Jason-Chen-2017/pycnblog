                 

### 2024京东零售子集团校招面试真题汇总及其解答

#### 1. 计算字符串的编辑距离

**题目：** 请实现一个函数，计算两个字符串的编辑距离。

**示例：** `editDistance("kitten", "sitting")` 应返回 3。

**答案：** 可以使用动态规划的方法来计算编辑距离。

```go
func editDistance(a, b string) int {
    m, n := len(a), len(b)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
        dp[i][0] = i
    }
    for j := range dp[0] {
        dp[0][j] = j
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if a[i-1] == b[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = dp[i-1][j-1] + 1
            }
            dp[i][j] = min(dp[i][j], dp[i][j-1])
            dp[i][j] = min(dp[i][j], dp[i-1][j])
        }
    }
    return dp[m][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

#### 2. 最长公共子序列

**题目：** 请实现一个函数，找出两个字符串的最长公共子序列。

**示例：** `longestCommonSubsequence("abcde", "ace")` 应返回 "ace"。

**答案：** 同样使用动态规划的方法。

```go
func longestCommonSubsequence(a, b string) string {
    m, n := len(a), len(b)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if a[i-1] == b[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var result []rune
    i, j := m, n
    for i > 0 && j > 0 {
        if a[i-1] == b[j-1] {
            result = append(result, a[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    reverse(result)
    return string(result)
}

func reverse(s []rune) {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 3. 单调栈

**题目：** 给定一个数组，使用单调栈找出数组中的所有波峰元素。

**示例：** 对于数组 `[1, 2, 3, 1]`，应返回 `[3, 1]`。

**答案：**

```go
func getPeaks(nums []int) []int {
    stack := []int{}
    peaks := []int{}
    for _, num := range nums {
        for len(stack) > 0 && nums[stack[len(stack)-1]] <= num {
            stack = stack[:len(stack)-1]
        }
        stack = append(stack, len(nums)-1)
        if len(stack) == 1 || nums[stack[len(stack)-2]] != nums[stack[len(stack)-1]] {
            peaks = append(peaks, num)
        }
    }
    return peaks
}
```

#### 4. 二分查找

**题目：** 给定一个排序后的数组，使用二分查找找到目标值。

**示例：** 对于数组 `[1, 3, 5, 7, 9]` 和目标值 `7`，应返回 `3`。

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

#### 5. 链表求和

**题目：** 给定两个非空链表，分别表示两个非负整数，将它们相加并以链表形式返回。

**示例：** 对于链表 `1->2->4` 和 `1->5->7`，应返回 `2->0->1`。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

#### 6. 判断链表是否为回文

**题目：** 给定一个链表，判断它是否是回文的。

**示例：** 对于链表 `[1, 2, 3, 2, 1]`，应返回 `true`。

**答案：**

```go
func isPalindrome(head *ListNode) bool {
    fast, slow := head, head
    for fast != nil && fast.Next != nil {
        fast = fast.Next.Next
        slow = slow.Next
    }
    if fast != nil {
        slow = slow.Next
    }
    reversed := reverse(slow)
    for head != nil && reversed != nil {
        if head.Val != reversed.Val {
            return false
        }
        head = head.Next
        reversed = reversed.Next
    }
    return true
}

func reverse(head *ListNode) *ListNode {
    prev, curr := nil, head
    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

#### 7. 旋转数组

**题目：** 给定一个数组，将数组中的元素向右移动 `k` 个位置。

**示例：** 对于数组 `[1, 2, 3, 4, 5]` 和 `k = 2`，应返回 `[4, 5, 1, 2, 3]`。

**答案：**

```go
func rotate(nums []int, k int) {
    n := len(nums)
    k %= n
    reverse(nums, 0, n-k-1)
    reverse(nums, n-k, n-1)
    reverse(nums, 0, n-1)
}

func reverse(nums []int, start, end int) {
    for start < end {
        nums[start], nums[end] = nums[end], nums[start]
        start++
        end--
    }
}
```

#### 8. 最大子序和

**题目：** 给定一个整数数组，找出数组中的最大子序和。

**示例：** 对于数组 `[1, -2, 3, 10, -4]`，应返回 `12`。

**答案：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 9. 两数相加

**题目：** 给定两个非空链表，分别表示两个非负整数，将它们相加并以链表形式返回。

**示例：** 对于链表 `1->2->4` 和 `1->5->7`，应返回 `2->0->1`。

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

#### 10. 最小栈

**题目：** 设计一个支持 push、pop、top 操作，并能获取最小元素的栈。

**示例：** 对于操作序列 `[push(1), push(2), push(3), pop(), top(), pop(), getMin()]`，应返回 `[3, 2, 1, 1]`。

**答案：**

```go
type MinStack struct {
    stack []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack: []int{},
        minStack: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if val < this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    } else {
        this.minStack = append(this.minStack, this.minStack[len(this.minStack)-1])
    }
}

func (this *MinStack) Pop() {
    this.stack = this.stack[:len(this.stack)-1]
    this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
```

#### 11. 合并区间

**题目：** 给定一个区间列表，合并所有重叠的区间。

**示例：** 对于区间列表 `[[1,3],[2,6],[8,10],[15,18]]`，应返回 `[[1,6],[8,10],[15,18]]`。

**答案：**

```go
type Interval struct {
    Start int
    End   int
}

func merge(intervals [][]Interval) [][]Interval {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    var result [][]Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### 12. 搜索旋转排序数组

**题目：** 给定一个旋转排序的整数数组，实现一个搜索算法，搜索一个给定的目标值。

**示例：** 对于数组 `[4,5,6,7,0,1,2]` 和目标值 `0`，应返回 `4`。

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target <= nums[right] && target > nums[mid] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

#### 13. 设计哈希表

**题目：** 实现一个哈希表（Hash Table），支持基本的插入、删除和查询操作。

**示例：** 对于操作序列 `[["MyHash

