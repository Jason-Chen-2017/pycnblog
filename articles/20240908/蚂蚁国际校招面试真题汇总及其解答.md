                 

### 2024蚂蚁国际校招面试真题汇总及其解答

#### 1. 算法题：最小生成树

**题目：** 请用 Prim 算法或 Kruskal 算法求解给定图的最小生成树。

**输入：** 无

**输出：** 输出最小生成树的边及其权重。

**答案：** 使用 Prim 算法求解。

```python
def prim(arr):
    visited = [False] * len(arr)
    result = []
    for i in range(len(arr)):
        min_val = float('inf')
        min_index = -1
        for j in range(len(arr[i])):
            if arr[i][j] < min_val and not visited[j]:
                min_val = arr[i][j]
                min_index = j
        result.append((i, min_index, min_val))
        visited[min_index] = True
    return result

# 示例
arr = [
    [0, 2, 4, 0, 0],
    [2, 0, 1, 3, 0],
    [4, 1, 0, 6, 4],
    [0, 3, 6, 0, 2],
    [0, 0, 4, 2, 0]
]
print(prim(arr))
```

#### 2. 数据结构题：二叉搜索树

**题目：** 实现一个二叉搜索树，并实现插入、删除、查找等基本操作。

**输入：** 插入的元素或待删除的元素。

**输出：** 返回操作后的二叉搜索树。

**答案：** 使用递归实现。

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, value):
        if not self.root:
            self.root = Node(value)
        else:
            self._insert(self.root, value)

    def _insert(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = Node(value)
            else:
                self._insert(node.left, value)
        else:
            if node.right is None:
                node.right = Node(value)
            else:
                self._insert(node.right, value)

    def delete(self, value):
        self.root = self._delete(self.root, value)

    def _delete(self, node, value):
        if node is None:
            return node
        if value < node.value:
            node.left = self._delete(node.left, value)
        elif value > node.value:
            node.right = self._delete(node.right, value)
        else:
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            temp = self._find_min(node.right)
            node.value = temp.value
            node.right = self._delete(node.right, temp.value)
        return node

    def _find_min(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current

    def search(self, value):
        return self._search(self.root, value)

    def _search(self, node, value):
        if node is None:
            return False
        if value == node.value:
            return True
        elif value < node.value:
            return self._search(node.left, value)
        else:
            return self._search(node.right, value)

# 示例
bst = BST()
bst.insert(5)
bst.insert(3)
bst.insert(7)
print(bst.search(3))  # 输出 True
print(bst.search(6))  # 输出 False
bst.delete(3)
print(bst.search(3))  # 输出 False
```

#### 3. 算法题：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**输入：** 两个字符串。

**输出：** 最长公共子序列。

**答案：** 使用动态规划求解。

```python
def lcs(X, Y):
    m = len(X)
    n = len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            result.append(X[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

# 示例
X = "ABCD"
Y = "ACDF"
print(lcs(X, Y))  # 输出 "ACD"
```

#### 4. 数据结构题：双向链表

**题目：** 实现一个双向链表，并实现插入、删除、遍历等基本操作。

**输入：** 待插入的元素或待删除的元素。

**输出：** 返回操作后的双向链表。

**答案：** 使用类实现。

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, value):
        new_node = Node(value)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

    def delete(self, value):
        current = self.head
        while current:
            if current.value == value:
                if current.prev:
                    current.prev.next = current.next
                else:
                    self.head = current.next
                if current.next:
                    current.next.prev = current.prev
                else:
                    self.tail = current.prev
                return
            current = current.next

    def traverse(self):
        current = self.head
        while current:
            print(current.value, end=" ")
            current = current.next
        print()

# 示例
dll = DoublyLinkedList()
dll.insert(1)
dll.insert(2)
dll.insert(3)
dll.traverse()  # 输出 1 2 3
dll.delete(2)
dll.traverse()  # 输出 1 3
```

#### 5. 算法题：最长递增子序列

**题目：** 给定一个数组，求它的最长递增子序列。

**输入：** 一个数组。

**输出：** 最长递增子序列。

**答案：** 使用动态规划求解。

```python
def longest_increasing_subsequence(nums):
    if not nums:
        return []

    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    max_length = max(dp)
    result = []
    for i in range(len(nums)):
        if dp[i] == max_length:
            result.append(nums[i])
            max_length -= 1

    return result

# 示例
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(longest_increasing_subsequence(nums))  # 输出 [2, 3, 7, 101]
```

#### 6. 算法题：快速排序

**题目：** 实现快速排序算法。

**输入：** 一个数组。

**输出：** 排序后的数组。

**答案：** 使用递归实现。

```python
def quick_sort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# 示例
nums = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(nums))  # 输出 [1, 1, 2, 3, 6, 8, 10]
```

#### 7. 数据结构题：堆

**题目：** 实现一个小顶堆，并实现插入、删除等基本操作。

**输入：** 待插入的元素或待删除的元素。

**输出：** 返回操作后的堆。

**答案：** 使用数组实现。

```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def insert(self, value):
        self.heap.append(value)
        self._sift_up(len(self.heap) - 1)

    def delete(self, value):
        index = self.heap.index(value)
        self.heap[index] = self.heap[-1]
        self.heap.pop()
        self._sift_down(index)

    def _sift_up(self, index):
        while index > 0:
            parent = (index - 1) // 2
            if self.heap[parent] > self.heap[index]:
                self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent]
                index = parent
            else:
                break

    def _sift_down(self, index):
        while True:
            left_child = 2 * index + 1
            right_child = 2 * index + 2
            smallest = index

            if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]:
                smallest = left_child

            if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]:
                smallest = right_child

            if smallest != index:
                self.heap[smallest], self.heap[index] = self.heap[index], self.heap[smallest]
                index = smallest
            else:
                break

    def get_min(self):
        if self.heap:
            return self.heap[0]
        else:
            return None

# 示例
heap = MinHeap()
heap.insert(4)
heap.insert(10)
heap.insert(3)
heap.insert(1)
print(heap.get_min())  # 输出 1
heap.delete(1)
print(heap.get_min())  # 输出 3
```

#### 8. 算法题：最长公共前缀

**题目：** 给定多个字符串，求它们的最长公共前缀。

**输入：** 多个字符串。

**输出：** 最长公共前缀。

**答案：** 使用横向比较。

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]

    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

#### 9. 算法题：二分查找

**题目：** 在一个有序数组中查找目标值。

**输入：** 有序数组和一个目标值。

**输出：** 目标值的索引。

**答案：** 使用二分查找。

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 示例
nums = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search(nums, 7))  # 输出 3
```

#### 10. 算法题：合并两个有序链表

**题目：** 合并两个有序链表。

**输入：** 两个有序链表。

**输出：** 合并后的有序链表。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1

    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2

# 示例
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
merged_list = merge_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end=" ")
    merged_list = merged_list.next
# 输出 1 2 3 4 5 6
```

#### 11. 算法题：环形链表

**题目：** 判断一个链表是否为环形链表。

**输入：** 链表的头节点。

**输出：** 是否为环形链表。

**答案：** 使用快慢指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True

    return False

# 示例
head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
print(has_cycle(head))  # 输出 True
head.next.next.next.next = head.next
print(has_cycle(head))  # 输出 True
```

#### 12. 算法题：最大子序和

**题目：** 给定一个整数数组，找出所有子数组中的最大子序和。

**输入：** 一个整数数组。

**输出：** 最大子序和。

**答案：** 使用动态规划。

```python
def max_subarray_sum(nums):
    if not nums:
        return 0

    max_so_far = nums[0]
    curr_max = nums[0]

    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far

# 示例
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))  # 输出 6
```

#### 13. 算法题：打家劫舍

**题目：** 你是一个偷窃者，选择连续的若干房子进行偷窃，每偷窃一处房子后，你需要跳过接下来的一处房子。给定一个整数数组，表示每处房子的价值，求偷窃得到最大价值的方案。

**输入：** 一个整数数组。

**输出：** 偷窃得到的最大价值。

**答案：** 使用动态规划。

```python
def rob(nums):
    if not nums:
        return 0

    prev1, prev2 = 0, 0
    for num in nums:
        curr = max(prev2 + num, prev1)
        prev2 = prev1
        prev1 = curr

    return prev1

# 示例
nums = [2, 7, 9, 3, 1]
print(rob(nums))  # 输出 12
```

#### 14. 算法题：最长公共子串

**题目：** 给定两个字符串，求它们的最长公共子串。

**输入：** 两个字符串。

**输出：** 最长公共子串。

**答案：** 使用动态规划。

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    max_len = 0
    end_pos = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i - 1
            else:
                dp[i][j] = 0

    return s1[end_pos - max_len + 1: end_pos + 1]

# 示例
s1 = "abcdefg"
s2 = "acdeghijk"
print(longest_common_substring(s1, s2))  # 输出 "acde"
```

#### 15. 算法题：最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**输入：** 未排序的整数数组。

**输出：** 最长连续序列的长度。

**答案：** 使用哈希表。

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    num_set = set(nums)
    max_len = 0

    for num in num_set:
        if num - 1 not in num_set:
            curr_num = num
            curr_len = 1

            while curr_num + 1 in num_set:
                curr_num += 1
                curr_len += 1

            max_len = max(max_len, curr_len)

    return max_len

# 示例
nums = [100, 4, 200, 1, 3, 2]
print(longest_consecutive(nums))  # 输出 4
```

#### 16. 算法题：两数之和

**题目：** 给定一个整数数组和一个目标值，找出两个数使得它们的和等于目标值。

**输入：** 整数数组和一个目标值。

**输出：** 两个数的索引。

**答案：** 使用哈希表。

```python
def two_sum(nums, target):
    num_set = set(nums)
    for num in nums:
        complement = target - num
        if complement in num_set:
            return [nums.index(num), nums.index(complement)]

    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # 输出 [0, 1]
```

#### 17. 算法题：有效的括号

**题目：** 判断一个字符串是否是有效的括号。

**输入：** 字符串。

**输出：** 是否有效。

**答案：** 使用栈。

```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)

    return not stack

# 示例
s = "()[]{}"
print(isValid(s))  # 输出 True
```

#### 18. 算法题：合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**输入：** 一组区间。

**输出：** 合并后的区间。

**答案：** 排序后合并。

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        last_end = result[-1][1]
        curr_start, curr_end = intervals[i]

        if curr_start <= last_end:
            result[-1][1] = max(last_end, curr_end)
        else:
            result.append(intervals[i])

    return result

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

#### 19. 算法题：单词搜索

**题目：** 给定一个二维字符网格和一个单词，判断该单词是否存在于网格中。

**输入：** 二维字符网格和一个单词。

**输出：** 是否存在。

**答案：** 深度优先搜索。

```python
def exist(board, word):
    rows, cols = len(board), len(board[0])
    visited = [[False] * cols for _ in range(rows)]

    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= rows or j < 0 or j >= cols or visited[i][j] or board[i][j] != word[k]:
            return False

        visited[i][j] = True
        if dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1):
            return True
        visited[i][j] = False

        return False

    for i in range(rows):
        for j in range(cols):
            if dfs(i, j, 0):
                return True

    return False

# 示例
board = [
    ['A', 'B', 'C', 'E'],
    ['S', 'F', 'C', 'S'],
    ['A', 'D', 'E', 'E']
]
word = "ABCCED"
print(exist(board, word))  # 输出 True
```

#### 20. 算法题：单词搜索 II

**题目：** 给定一个二维字符网格和一个单词列表，找出所有单词在网格中出现的路径。

**输入：** 二维字符网格和一个单词列表。

**输出：** 所有单词在网格中出现的路径。

**答案：** 深度优先搜索 + 剪枝。

```python
def find_words(board, words):
    def dfs(i, j, k, word):
        if k == len(word):
            result.append(word)
            return
        if i < 0 or i >= rows or j < 0 or j >= cols or visited[i][j] or board[i][j] != word[k]:
            return

        visited[i][j] = True
        for dx, dy in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            x, y = i + dx, j + dy
            if 0 <= x < rows and 0 <= y < cols:
                dfs(x, y, k + 1, word)
        visited[i][j] = False

    rows, cols = len(board), len(board[0])
    visited = [[False] * cols for _ in range(rows)]
    result = []

    for word in words:
        for i in range(rows):
            for j in range(cols):
                if board[i][j] == word[0]:
                    dfs(i, j, 0, word)

    return result

# 示例
board = [
    ['o', 'a', 'a', 'n'],
    ['e', 't', 'a', 'e'],
    ['i', 'h', 'k', 'r'],
    ['i', 'f', 'l', 'v']
]
words = ["oath", "pea", "eat", "rain"]
print(find_words(board, words))  # 输出 ['oath', 'eat']
```

#### 21. 算法题：岛屿数量

**题目：** 给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。

**输入：** 二维网格。

**输出：** 岛屿数量。

**答案：** 深度优先搜索。

```python
def num_islands(grid):
    def dfs(i, j):
        if i < 0 or i >= rows or j < 0 or j >= cols or grid[i][j] != '1':
            return
        grid[i][j] = '0'
        dfs(i - 1, j)
        dfs(i + 1, j)
        dfs(i, j - 1)
        dfs(i, j + 1)

    rows, cols = len(grid), len(grid[0])
    count = 0

    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '1':
                dfs(i, j)
                count += 1

    return count

# 示例
grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
]
print(num_islands(grid))  # 输出 1
```

#### 22. 算法题：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**输入：** 两个字符串。

**输出：** 最长公共子序列。

**答案：** 动态规划。

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            result.append(s1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

# 示例
s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))  # 输出 "ACD"
```

#### 23. 算法题：合并 k 个排序链表

**题目：** 合并 k 个排序链表并返回合并后的排序链表。

**输入：** k 个排序链表。

**输出：** 合并后的排序链表。

**答案：** 分治 + 优先队列。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_k_lists(lists):
    if not lists:
        return None

    priority_queue = []
    for head in lists:
        if head:
            heapq.heappush(priority_queue, (head.val, head))

    dummy = ListNode()
    current = dummy

    while priority_queue:
        val, node = heapq.heappop(priority_queue)
        current.next = node
        current = current.next

        if node.next:
            heapq.heappush(priority_queue, (node.next.val, node.next))

    return dummy.next

# 示例
l1 = ListNode(1, ListNode(4, ListNode(5)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
l3 = ListNode(2, ListNode(6))
lists = [l1, l2, l3]
merged_list = merge_k_lists(lists)
while merged_list:
    print(merged_list.val, end=" ")
    merged_list = merged_list.next
# 输出 1 1 2 3 4 4 5 6
```

#### 24. 算法题：最长公共前缀

**题目：** 给定多个字符串，求它们的最长公共前缀。

**输入：** 多个字符串。

**输出：** 最长公共前缀。

**答案：** 横向比较。

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]

    return prefix

# 示例
strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

#### 25. 算法题：最长递增子序列

**题目：** 给定一个整数数组，找出所有子数组中的最长递增子序列。

**输入：** 整数数组。

**输出：** 最长递增子序列。

**答案：** 动态规划。

```python
def longest_increasing_subsequence(nums):
    if not nums:
        return []

    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    max_len = max(dp)
    result = []
    for i in range(len(nums)):
        if dp[i] == max_len:
            result.append(nums[i])
            max_len -= 1

    return result

# 示例
nums = [10, 9, 2, 5, 3, 7, 101, 18]
print(longest_increasing_subsequence(nums))  # 输出 [2, 3, 7, 101]
```

#### 26. 算法题：最大子序和

**题目：** 给定一个整数数组，找出所有子数组中的最大子序和。

**输入：** 整数数组。

**输出：** 最大子序和。

**答案：** 动态规划。

```python
def max_subarray_sum(nums):
    if not nums:
        return 0

    max_so_far = nums[0]
    curr_max = nums[0]

    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)

    return max_so_far

# 示例
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))  # 输出 6
```

#### 27. 算法题：两数之和

**题目：** 给定一个整数数组和一个目标值，找出两个数使得它们的和等于目标值。

**输入：** 整数数组和目标值。

**输出：** 两个数的索引。

**答案：** 哈希表。

```python
def two_sum(nums, target):
    num_set = set(nums)
    for num in nums:
        complement = target - num
        if complement in num_set:
            return [nums.index(num), nums.index(complement)]

    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # 输出 [0, 1]
```

#### 28. 算法题：有效的括号

**题目：** 判断一个字符串是否是有效的括号。

**输入：** 字符串。

**输出：** 是否有效。

**答案：** 栈。

```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)

    return not stack

# 示例
s = "()[]{}"
print(isValid(s))  # 输出 True
```

#### 29. 算法题：合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**输入：** 一组区间。

**输出：** 合并后的区间。

**答案：** 排序后合并。

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        last_end = result[-1][1]
        curr_start, curr_end = intervals[i]

        if curr_start <= last_end:
            result[-1][1] = max(last_end, curr_end)
        else:
            result.append(intervals[i])

    return result

# 示例
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

#### 30. 算法题：环形链表

**题目：** 判断一个链表是否为环形链表。

**输入：** 链表的头节点。

**输出：** 是否为环形链表。

**答案：** 快慢指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True

    return False

# 示例
head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
print(has_cycle(head))  # 输出 True
head.next.next.next = head.next
print(has_cycle(head))  # 输出 True
```

