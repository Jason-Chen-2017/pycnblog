                 

### 字节跳动2024届校招算法工程师面试真题解密

#### 1. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(0, min(len(strs[0]), len(strs[1]))):
        if i == len(strs[1]):
            break
        curr = strs[1][i]
        for j in range(2, len(strs)):
            if i == len(strs[j]) or strs[j][i] != curr:
                return prefix
        prefix += curr
    return prefix
```

**解析：** 该函数使用字符串 `strs[0]` 作为初始前缀，然后逐个字符地与后续字符串进行比较。一旦发现不相等的字符，则返回当前找到的最长公共前缀。这种方法的时间复杂度为 \(O(NM)\)，其中 \(N\) 是字符串数组中的字符串数量，\(M\) 是最长字符串的长度。

#### 2. 盒子摞放

**题目：** 给定一个数组 heights，表示一些盒子的高度，找出一种放置盒子的方式，使得摞放后的总高度最大。

```python
def max_height(heights):
    heights.sort(reverse=True)
    max_height = heights[0]
    total_height = 0
    for i in range(1, len(heights)):
        total_height += heights[i]
        max_height = max(max_height, total_height * 2)
    return max_height
```

**解析：** 该函数首先将盒子高度数组按从大到小排序，然后逐个累加下一个盒子的高度，并将其乘以 2（因为两个相同高度的盒子摞放后的高度是原来的两倍）。最后，返回最大的高度值。这种方法的时间复杂度为 \(O(N\log N)\)。

#### 3. 股票买卖

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天的股票价格。如果在一个购买之后第二天卖出股票可以获得利润，返回最大利润。不允许同时持有两支股票。

```python
def max_profit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        max_profit += max(0, prices[i] - prices[i - 1])
    return max_profit
```

**解析：** 该函数遍历股票价格数组，每次发现价格上升时，计算利润并累加。如果价格下降，则不进行操作。这种方法的时间复杂度为 \(O(N)\)。

#### 4. 合并区间

**题目：** 给定一个区间列表，合并所有重叠的区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for i in range(1, len(intervals)):
        if intervals[i][0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])
    return result
```

**解析：** 该函数首先将区间列表按起始值排序，然后遍历列表，合并重叠的区间。如果当前区间的起始值小于等于前一个区间的结束值，则合并它们。否则，将当前区间添加到结果列表中。这种方法的时间复杂度为 \(O(N\log N)\)。

#### 5. 最小栈

**题目：** 实现一个最小栈，支持插入、删除和获取最小值操作。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack:
            if self.stack[-1] == self.min_stack[-1]:
                self.min_stack.pop()
            self.stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]

    def getMin(self) -> int:
        if self.min_stack:
            return self.min_stack[-1]
```

**解析：** 该类使用两个栈来实现最小栈。主栈用于插入和删除操作，辅助栈用于跟踪最小值。在插入时，如果插入的值小于等于当前最小值，则将其添加到辅助栈中。在删除时，如果删除的值等于当前最小值，则从辅助栈中删除。这种方法的时间复杂度为 \(O(1)\)。

#### 6. 寻找两个正序数组的中位数

**题目：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，找到这两个数组中的中位数。

```python
def findMedianSortedArrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2 = nums2, nums1
        m, n = n, m
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j - 1]
            elif j == 0:
                max_of_left = nums1[i - 1]
            else:
                max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2
```

**解析：** 该函数使用二分查找法在两个数组中找到中位数。通过调整 `imin` 和 `imax`，可以找到两个数组的中间值，然后根据数组长度和奇偶性返回中位数。这种方法的时间复杂度为 \(O(log(\min(m, n)))\)。

#### 7. 翻转单词顺序

**题目：** 编写一个函数，将一个字符串的单词逆序，并返回新的字符串。

```python
def reverseWords(s):
    s = s.strip().split()
    return ' '.join(s[::-1])
```

**解析：** 该函数首先移除字符串两端的空白字符，然后按空格分割字符串，最后逆序拼接返回。这种方法的时间复杂度为 \(O(N)\)。

#### 8. 链表相加

**题目：** 给定两个非空链表，每个链表表示一个非负整数，它们每位上的数字是逆序的，编写一个函数将这两个链表相加，并返回相加的结果。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = 0 if not l1 else l1.val
            val2 = 0 if not l2 else l2.val
            sum = val1 + val2 + carry
            carry = sum // 10
            curr.next = ListNode(sum % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

**解析：** 该函数使用一个哑节点 `dummy` 来构建结果链表，通过遍历两个链表并计算各位的和以及进位，构建新的链表。这种方法的时间复杂度为 \(O(max(m, n))\)。

#### 9. 数据流的中位数

**题目：** 设计一个数据结构，实现数据流的中位数。

```python
from sortedcontainers import SortedList

class MedianFinder:
    def __init__(self):
        self.data = SortedList()

    def addNum(self, num: int) -> None:
        self.data.add(num)

    def findMedian(self) -> float:
        n = len(self.data)
        if n % 2 == 1:
            return float(self.data[n // 2])
        else:
            return (self.data[n // 2 - 1] + self.data[n // 2]) / 2
```

**解析：** 该类使用有序列表 `SortedList` 来存储数据，提供 `addNum` 和 `findMedian` 方法。在 `addNum` 方法中，数据被添加到有序列表中。在 `findMedian` 方法中，计算并返回中位数。这种方法的时间复杂度为 \(O(log N)\)。

#### 10. 零钱兑换

**题目：** 给定一些面额的硬币和一个总金额，计算最少需要多少枚硬币来凑出这个金额。

```python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1
```

**解析：** 该函数使用动态规划来计算最小硬币数量。对于每个金额 \(i\)，尝试使用所有硬币 \(coin\)，并更新 \(dp[i]\) 的最小值。最后，返回 \(dp[amount]\) 的值。如果无法凑出金额，则返回 -1。这种方法的时间复杂度为 \(O(amount \times N)\)。

#### 11. 子数组最大平均数 I

**题目：** 给定一个数组 `nums` 和一个整数 `k`，找到子数组长度为 `k` 的最大平均数。

```python
def largest boa
```
**题目：** 给定一个数组 `nums` 和一个整数 `k`，找到子数组长度为 `k` 的最大平均数。

```python
def largestAverage(nums: List[int], k: int) -> float:
    avg = sum(nums[:k]) / k
    for i in range(k, len(nums)):
        avg = max(avg, (avg * k - nums[i - k] + nums[i]) / k)
    return avg
```

**解析：** 该函数首先计算窗口 `[nums[0], nums[1], ..., nums[k-1]]` 的平均值 `avg`，然后遍历数组 `nums`，每次向右滑动窗口，更新 `avg` 的值并保持最大值。这种方法的时间复杂度为 \(O(N)\)。

#### 12. 最长回文子串

**题目：** 给定一个字符串 `s`，找到其最长的回文子串。

```python
def longestPalindrome(s: str) -> str:
    def f(l, r):
        while l >= 0 and r < len(s) and s[l] == s[r]:
            l, r = l - 1, r + 1
        return r - l - 1

    start, max_len = 0, 1
    for i in range(len(s)):
        a = f(i, i)
        b = f(i, i + 1)
        max_len = max(max_len, a, b)
        if max_len == len(s):
            return s
        start = i - ((max_len - 1) >> 1)

    return s[start : start + max_len]
```

**解析：** 该函数使用中心扩展法寻找最长的回文子串。对于每个字符，分别以字符为中心向左右扩展，找到回文子串。这种方法的时间复杂度为 \(O(N^2)\)。

#### 13. 寻找旋转排序数组中的最小值

**题目：** 给定一个循环旋转排序的数组 `nums` ，找到并返回数组中的最小元素。

```python
def findMin(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：** 该函数使用二分查找法在旋转排序数组中找到最小值。如果中间值大于最右边的值，则最小值在右侧，否则在左侧。这种方法的时间复杂度为 \(O(log N)\)。

#### 14. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 该函数使用哑节点 `dummy` 来构建结果链表，遍历两个链表，按值顺序将节点添加到结果链表中。这种方法的时间复杂度为 \(O(N + M)\)，其中 \(N\) 和 \(M\) 分别是两个链表的长度。

#### 15. 多数元素

**题目：** 给定一个整数数组 `nums`，在数组中找出多数元素。多数元素是指在数组中超过 `nums.length / 2` 的元素。

```python
def majorityElement(nums: List[int]) -> int:
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate
```

**解析：** 该函数使用摩尔投票算法来找到多数元素。算法的核心思想是：如果一个元素是多数元素，那么它可以和任意其他元素抵消。遍历数组，当计数值为 0 时，选择当前元素作为候选元素，然后将其与后续的元素配对。这种方法的时间复杂度为 \(O(N)\)。

#### 16. 岛屿数量

**题目：** 给你一个由 '1'（陆地）和 '0'（水）组成的的网格 grid ，请计算网格中岛屿的数量。

```python
def numIslands(grid: List[List[str]]) -> int:
    def dfs(i, j):
        grid[i][j] = '0'
        for a, b in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
            x, y = i + a, j + b
            if 0 <= x < m and 0 <= y < n and grid[x][y] == '1':
                dfs(x, y)

    m, n = len(grid), len(grid[0])
    ans = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                dfs(i, j)
                ans += 1
    return ans
```

**解析：** 该函数使用深度优先搜索（DFS）来计算岛屿数量。对于每个未标记的陆地，执行 DFS 来将其和相邻的陆地都标记为水，然后增加岛屿计数。这种方法的时间复杂度为 \(O(M \times N)\)，其中 \(M\) 和 \(N\) 分别是网格的行数和列数。

#### 17. 有效的括号

**题目：** 给定一个包含 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

```python
def isValid(s: str) -> bool:
    d = {')': '(', '}': '{', ']': '['}
    stack = []
    for c in s:
        if c in d:
            top_element = stack.pop() if stack else '#'
            if d[c] != top_element:
                return False
        else:
            stack.append(c)
    return not stack
```

**解析：** 该函数使用栈来实现有效括号判断。遍历字符串，对于左括号，将其压入栈中；对于右括号，将其与栈顶元素比较，如果不匹配则返回 False。遍历结束后，如果栈为空，则字符串有效。这种方法的时间复杂度为 \(O(N)\)。

#### 18. 股票买卖 II

**题目：** 给你一个整数数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。

请计算你能够获取的最大利润。

你可以尽可能地完成更多的交易（多次买卖 一支股票）。

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```python
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在这个例子中，最多可以完成 3 笔交易，得到的最大利润为 7。
进行下列交易：
买入  5股   价格：  1
卖出  5股   价格：  6
买入  3股   价格：  3
卖出  3股   价格：  5
```

**示例 2：**

```python
输入：prices = [1,2,3,4,5]
输出：4
解释：在这个例子中，最多可以完成 4 笔交易，但只有 3 笔的交易能带来利润。
```

**示例 3：**

```python
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下，无法获取任何利润。
```

**提示：**

- 1 <= prices.length <= 3 \* 104
- 0 <= prices[i] <= 104

**思路：** 动态规划，状态转移方程如下：

\[ dp[i] = \max(dp[i - 1], dp[i - 2] + prices[i] - prices[i - 1]) \]

其中，`dp[i]` 表示到第 `i` 天的最大利润。

**代码实现：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        dp = [0] * len(prices)
        dp[0] = 0
        if len(prices) > 1:
            dp[1] = max(0, prices[1] - prices[0])
        for i in range(2, len(prices)):
            dp[i] = max(dp[i - 1], dp[i - 2] + prices[i] - prices[i - 1])
        return dp[-1]
```

#### 19. 股票买卖 III

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 是第 `i` 天的股票价格。最多只允许进行两笔交易，设计一个算法来计算你所能获取的最大利润。

**示例 1：**

```python
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这能够获得利润= 3。
    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这能够获得利润= 4。
```

**示例 2：**

```python
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出,这能够获得利润= 4。
     注意，无法在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```python
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下,无法获取任何利润。
```

**提示：**

- 1 <= prices.length <= 3 \* 10^4
- 0 <= prices[i] <= 10^3

**思路：** 动态规划，状态转移方程如下：

\[ dp[i][0] = \max(dp[i - 1][0], dp[i - 1][1] - prices[i]) \]

\[ dp[i][1] = \max(dp[i - 1][1], dp[i - 1][0] + prices[i]) \]

其中，`dp[i][0]` 表示第 `i` 天手里没有股票的最大利润，`dp[i][1]` 表示第 `i` 天手里有一只股票的最大利润。

**代码实现：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        dp = [[0] * 2 for _ in range(n)]
        dp[0][0] = 0
        dp[0][1] = -prices[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])
        return dp[-1][0]
```

#### 20. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```python
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**思路：** 递归或迭代，比较两个链表当前节点的值，将较小的节点添加到新链表中，并递归或迭代处理剩余部分。

**递归实现：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if l1 is None:
            return l2
        if l2 is None:
            return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

**迭代实现：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

#### 21. 删除链表的节点

**题目：** 给定单向链表的头指针和一个节点，定义一个函数删除该节点。

**示例：**

```python
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：给定你链表中值为 5 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9。
```

**思路：** 将待删除节点的下一个节点的值复制给待删除节点，然后删除下一个节点。

**代码实现：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```

#### 22. 剑指 Offer 48. 最长序列之和

**题目：** 给定一个数组 arr，返回 subarray 之和的最大值，其中 subarray 是 arr 的一个连续子数组。

**示例：**

```python
输入：[1, -2, 3, 4]
输出：6
解释：最大的和为 [3, 4]
```

**思路：** 动态规划，定义状态 `dp[i]` 为以 `i` 结尾的连续子数组的最大和。状态转移方程为：

\[ dp[i] = \max(dp[i - 1] + arr[i], arr[i]) \]

其中，`dp[i - 1]` 是前一个状态，`arr[i]` 是当前数组的值。

**代码实现：**

```python
class Solution:
    def maxSubArray(self, arr: List[int]) -> int:
        dp = arr[:]
        for i in range(1, len(arr)):
            dp[i] = max(dp[i - 1] + arr[i], arr[i])
        return max(dp)
```

#### 23. 剑指 Offer 57. 和为指定值的两个数

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**

```python
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] = 2 + 7 = 9，所以返回 [0, 1]。
```

**思路：** 哈希表，遍历数组，对于每个元素 `nums[i]`，计算 `target - nums[i]`，然后检查该值是否在哈希表中。

**代码实现：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash_set = set()
        for i, num in enumerate(nums):
            complement = target - num
            if complement in hash_set:
                return [hash_set[complement], i]
            hash_set.add(num)
        return []
```

#### 24. 剑指 Offer 66. 构建乘积数组

**题目：** 给定一个数组 `nums`，请构建一个数组 `ans`，其中 `ans[i]` 的值是 `nums` 中除 `nums[i]` 之外其余数组的乘积。

**示例：**

```python
输入：nums = [1, 2, 3, 4]
输出：[24, 12, 8, 6]
解释：nums[0] 的值为 24，它是由 nums[1] \* nums[2] \* nums[3] 得到的。nums[1] 的值为 12，它是由 nums[0] \* nums[2] \* nums[3] 得到的。以此类推。
```

**思路：** 前缀积和后缀积，计算前缀积数组 `prefix` 和后缀积数组 `suffix`，然后 `ans[i] = prefix[i] \* suffix[i]`。

**代码实现：**

```python
class Solution:
    def constructArr(self, nums: List[int]) -> List[int]:
        n = len(nums)
        prefix = [1] * n
        suffix = [1] * n
        for i in range(1, n):
            prefix[i] = prefix[i - 1] * nums[i - 1]
        for i in range(n - 2, -1, -1):
            suffix[i] = suffix[i + 1] * nums[i + 1]
        return [prefix[i] * suffix[i] for i in range(n)]
```

#### 25. 剑指 Offer 67. 把字符串转换成整数

**题目：** 将一个字符串转换为整数（以字符串 "123" 为例）。如果字符串超过了整数范围，则返回 `None`。

**示例：**

```python
输入："123"
输出：123

输入："abc123"
输出：None

输入："-123"
输出：-123
```

**思路：** 分为两步，首先跳过字符串开头的空白字符，然后判断字符串的第一个字符是否为符号，接着转换为数字并乘以符号。

**代码实现：**

```python
class Solution:
    def strToInt(self, s: str) -> int:
        INT_MAX = 2 ** 31 - 1
        INT_MIN = -2 ** 31
        i = 0
        sign = 1
        while i < len(s) and s[i] == ' ':
            i += 1
        if i < len(s) and (s[i] == '+' or s[i] == '-'):
            sign = -1 if s[i] == '-' else 1
            i += 1
        res = 0
        while i < len(s) and s[i].isdigit():
            digit = ord(s[i]) - ord('0')
            if res > (INT_MAX - digit) // 10:
                return INT_MAX if sign == 1 else INT_MIN
            res = res * 10 + digit
            i += 1
        return res * sign
```

#### 26. 剑指 Offer 68 - I. 数组的交集

**题目：** 给定两个整数数组 `nums1` 和 `nums2`，返回两个数组中的交集。

**示例：**

```python
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

**思路：** 哈希表，将其中一个数组放入哈希表中，遍历另一个数组，检查每个元素是否在哈希表中。

**代码实现：**

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hash_set = set(nums1)
        res = []
        for num in nums2:
            if num in hash_set:
                res.append(num)
                hash_set.remove(num)
        return res
```

#### 27. 剑指 Offer 59 - I. 滑动窗口的最大值

**题目：** 给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**示例：**

```python
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,-1,-3,5,3,6,7]
解释：
  滑动窗口的位置                最大值
---------------               -----
       [1  3  -1]   -3   最大值 3
       [  3  -1  -3]   5   最大值 3
       [ -1  -3  5 ]   3   最大值 5
       [ -3  5  3 ]   3   最大值 3
       [  5  3  6 ]   6   最大值 6
       [  3  6  7 ]   7   最大值 7
```

**思路：** 双端队列，维护一个递减的双端队列，存储当前窗口中的最大值。遍历数组，对于每个元素：

- 删除队列头部的元素，如果队列头部的元素不在当前窗口内。
- 删除队列尾部的元素，如果队列尾部的元素小于当前元素。
- 将当前元素添加到队列尾部。

**代码实现：**

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        queue = deque()
        res = []
        for i, num in enumerate(nums):
            if queue and queue[0] < 0 or i - queue[0] >= k:
                queue.popleft()
            while queue and queue[-1] < num:
                queue.pop()
            queue.append(i)
            if i >= k - 1:
                res.append(queue[0])
        return res
```

#### 28. 剑指 Offer 50. 第一个只出现一次的字符

**题目：** 在字符串 `s` 中找出第一个只出现一次的字符，并返回它的位置。如果不存在，返回 `-1`。

**示例：**

```python
输入：s = "abaccdeff"
输出：1
解释：该字符串中的第一个只出现一次的字符是 "b"，它在字符串中的位置是 1。

输入：s = ""
输出：-1

输入：s = "abcd"
输出：-1
```

**思路：** 哈希表，遍历字符串，使用哈希表记录每个字符出现的次数。再次遍历字符串，检查每个字符的次数，找到第一个只出现一次的字符。

**代码实现：**

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        hash_set = {}
        for c in s:
            if c in hash_set:
                hash_set[c] += 1
            else:
                hash_set[c] = 1
        for i, c in enumerate(s):
            if hash_set[c] == 1:
                return i
        return -1
```

#### 29. 剑指 Offer 18. 删除链表的节点

**题目：** 给定单向链表的头指针和一个节点，定义一个函数删除该节点。

**示例：**

```python
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：删除值为 5 的节点后，链表变为 4 -> 1 -> 9。
```

**思路：** 将待删除节点的下一个节点的值复制给待删除节点，然后删除下一个节点。

**代码实现：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next
```

#### 30. 剑指 Offer 24. 反转链表

**题目：** 反转一个单链表。

**示例：**

```python
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**思路：** 迭代，使用一个指针遍历链表，每次反转当前节点的指针。

**代码实现：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        curr = head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev
```

### 总结

本文针对字节跳动2024届校招算法工程师面试真题进行了解密，涵盖了从简单到复杂的多道面试题和算法编程题。每道题目都给出了详细的解析和代码实现，旨在帮助读者理解和掌握算法和数据结构的基本概念和应用。通过这些题目的解答，读者可以更好地应对字节跳动等互联网大厂的面试挑战。

