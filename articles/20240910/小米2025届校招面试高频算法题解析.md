                 

### 小米2025届校招面试高频算法题解析

#### 1. 二分查找

**题目描述：** 在一个有序数组中查找一个给定的元素，并返回它的索引。如果数组中不存在该元素，返回 -1。

```python
def search(nums: List[int], target: int) -> int:
```

**答案解析：** 

二分查找算法的时间复杂度为 \(O(\log n)\)，适用于在有序数组中查找元素。算法的核心思想是：通过不断将数组分为两半，判断中间元素是否为目标值，然后决定是继续在左半部分还是右半部分查找。

```python
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

#### 2. 合并两个有序链表

**题目描述：** 合并两个有序链表并返回一个新的有序链表。

```python
def mergeTwoLists(list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
```

**答案解析：**

可以使用递归或迭代的方式合并两个有序链表。这里使用迭代的方法。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
    dummy = ListNode(0)
    curr = dummy
    while list1 and list2:
        if list1.val < list2.val:
            curr.next = list1
            list1 = list1.next
        else:
            curr.next = list2
            list2 = list2.next
        curr = curr.next
    curr.next = list1 or list2
    return dummy.next
```

#### 3. 两数之和

**题目描述：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
```

**答案解析：**

使用哈希表可以高效地解决这个问题。将数组中的每个元素作为键，其索引作为值存储在哈希表中，然后遍历数组，对于每个元素，检查哈希表中是否存在补数（即 `target - nums[i]`）。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

#### 4. 三数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为 `target` 的三个整数，并返回索引元组 `(i, j, k)`。

```python
def threeSum(nums: List[int], target: int) -> List[List[int]]:
```

**答案解析：**

首先对数组进行排序，然后遍历每个元素，对于每个元素，使用双指针算法找到与其互补的两个数。

```python
def threeSum(nums: List[int], target: int) -> List[List[int]]:
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return result
```

#### 5. 旋转图像

**题目描述：** 给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像，请你将图像顺时针旋转 90 度。

```python
def rotate(matrix: List[List[int]]) -> None:
    """
    Do not return anything, modify matrix in-place instead.
    """
```

**答案解析：**

旋转图像可以通过以下步骤实现：

1. 水平翻转矩阵。
2. 对矩阵的每一行进行翻转。

```python
def rotate(matrix: List[List[int]]) -> None:
    n = len(matrix)
    # 水平翻转矩阵
    for i in range(n // 2):
        for j in range(n):
            matrix[i][j], matrix[n - 1 - i][j] = matrix[n - 1 - i][j], matrix[i][j]
    # 对矩阵的每一行进行翻转
    for i in range(n):
        for j in range(n // 2):
            matrix[i][j], matrix[i][n - 1 - j] = matrix[i][n - 1 - j], matrix[i][j]
```

#### 6. 有效的括号

**题目描述：** 给定一个字符串 `s` ，判断 `s` 是否是有效的括号字符串，并且可以无限嵌套。

```python
def isValid(s: str) -> bool:
```

**答案解析：**

使用栈来跟踪所有未匹配的左括号。当遇到右括号时，从栈中弹出最近的左括号，如果栈为空，则字符串是有效的。

```python
def isValid(s: str) -> bool:
    stack = []
    for c in s:
        if c == '(':
            stack.append(c)
        elif c == ')':
            if not stack or stack.pop() != '(':
                return False
    return not stack
```

#### 7. 翻转字符串中的单词

**题目描述：** 给你一个字符串 s ，逐个翻转字符串中的所有单词。

```python
def reverseWords(s: str) -> str:
```

**答案解析：**

首先去除字符串中的空格，然后使用两个指针找到单词的开始和结束位置，将单词插入到结果字符串中。

```python
def reverseWords(s: str) -> str:
    s = s.strip()
    words = []
    i, j = 0, 0
    while i < len(s):
        if s[i] == ' ':
            words.append(s[j:i])
            j = i + 1
        i += 1
    words.append(s[j:])
    return ' '.join(words[::-1])
```

#### 8. 爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```python
def climbStairs(n: int) -> int:
```

**答案解析：**

这是一个典型的动态规划问题。可以通过计算前两个数列的和来得到第 n 个数列的值。

```python
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    a, b = 1, 1
    for i in range(2, n):
        a, b = b, a + b
    return b
```

#### 9. 两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
```

**答案解析：**

可以使用一个哑节点作为结果的头部，然后遍历两个链表，逐位相加，并处理进位。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

#### 10. 两数之和 II - 输入有序数组

**题目描述：** 给定一个已按照升序排列 的有序数组 `numbers` ，请你从中找出两个数使得它们相加之和等于目标数 `target`。函数应该返回这两个下标值 `index1` 和 `index2`，其中 `index1  must be less than `index2`。

```python
def twoSum(numbers: List[int], target: int) -> List[int]:
```

**答案解析：**

可以使用两个指针，一个从前往后遍历，一个从后往前遍历。当两个指针指向的数字和大于目标值时，右指针左移；当两个指针指向的数字和小于目标值时，左指针右移。

```python
def twoSum(numbers: List[int], target: int) -> List[int]:
    left, right = 0, len(numbers) - 1
    while left < right:
        total = numbers[left] + numbers[right]
        if total == target:
            return [left + 1, right + 1]
        elif total < target:
            left += 1
        else:
            right -= 1
    return []
```

#### 11. 盛最多水的容器

**题目描述：** 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 个垂直线段，线段和 `x` 轴相交，线段宽度为 1 。找出能够使这些垂直线段构成的最小矩形的面积。

```python
def maxArea(height: List[int]) -> int:
```

**答案解析：**

使用双指针方法，一个指针从左边开始，一个指针从右边开始，每次移动较矮的那一边的指针，并更新最大面积。

```python
def maxArea(height: List[int]) -> int:
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        min_height = min(height[left], height[right])
        max_area = max(max_area, min_height * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

#### 12. 寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 中位数 。

```python
def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
```

**答案解析：**

可以使用二分查找的方法，将两个数组合并并找到中位数。以下是 Python 的实现：

```python
def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    m, n = len(nums1), len(nums2)
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j - 1]
            elif j == 0:
                max_of_left = nums1[i - 1]
            else:
                max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2
```

#### 13. 搜索插入位置

**题目描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```python
def searchInsert(nums: List[int], target: int) -> int:
```

**答案解析：**

可以使用二分查找的方法，找到目标值的位置。

```python
def searchInsert(nums: List[int], target: int) -> int:
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left
```

#### 14. 最小栈

**题目描述：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val < self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

**答案解析：**

使用两个栈，一个用于存储元素，另一个用于存储当前栈中的最小元素。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val < self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

#### 15. 螺旋矩阵

**题目描述：** 给你一个 `m x n` 的矩阵 `matrix` ，请你返回矩阵的 螺旋顺序 。

```python
def spiralOrder(matrix: List[List[int]]) -> List[int]:
```

**答案解析：**

从外层向内层遍历，按照右、下、左、上的顺序。

```python
def spiralOrder(matrix: List[List[int]]) -> List[int]:
    if not matrix:
        return []
    m, n = len(matrix), len(matrix[0])
    ans = []
    top, bottom, left, right = 0, m - 1, 0, n - 1
    while True:
        if left > right:
            break
        for i in range(left, right + 1):
            ans.append(matrix[top][i])
        top += 1
        if top > bottom:
            break
        for i in range(top, bottom + 1):
            ans.append(matrix[i][right])
        right -= 1
        if left > right:
            break
        for i in range(right, left - 1, -1):
            ans.append(matrix[bottom][i])
        bottom -= 1
        if top > bottom:
            break
        for i in range(bottom, top - 1, -1):
            ans.append(matrix[i][left])
        left += 1
    return ans
```

#### 16. 汉明距离

**题目描述：** 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

```python
def hammingDistance(nums1: List[int], nums2: List[int]) -> int:
```

**答案解析：**

使用位操作，计算两个数二进制位不同的位置。

```python
def hammingDistance(nums1: List[int], nums2: List[int]) -> int:
    x = nums1 ^ nums2
    ans = 0
    while x:
        ans += x & 1
        x >>= 1
    return ans
```

#### 17. 有效数字

**题目描述：** 给定一个字符串 `s` ，判断 `s` 是否为 有效数字 。

```python
def isNumber(s: str) -> bool:
```

**答案解析：**

使用正则表达式来判断。

```python
def isNumber(s: str) -> bool:
    import re
    return re.fullmatch(r'[+-]?(\d*\.?\d+|[+\-]?\d+\.?\d*)([eE][+-]?\d+)?$', s) is not None
```

#### 18. 股票买卖

**题目描述：** 给定一个整数数组 `prices` ，其中 `prices[i]` 是一支给定股票第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

```python
def maxProfit(prices: List[int]) -> int:
```

**答案解析：**

遍历数组，每次更新利润为当前价格减去前一个价格。

```python
def maxProfit(prices: List[int]) -> int:
    ans = 0
    for i in range(1, len(prices)):
        ans += prices[i] - prices[i - 1]
    return ans
```

#### 19. 找到重复数

**题目描述：** 给你一个长度为 `n` 的整数数组 `nums` ，其中 `n > 2` 且 `nums` 包含所有从 `1` 到 `n` 的数字。但其中恰好有一个整数是重复的。

```python
def findDuplicate(nums: List[int]) -> int:
```

**答案解析：**

使用快慢指针的方法，找到循环的入口点。

```python
def findDuplicate(nums: List[int]) -> int:
    slow = nums[0]
    fast = nums[nums[0]]
    while slow != fast:
        slow = nums[slow]
        fast = nums[nums[fast]]
    slow = 0
    while slow != fast:
        slow = nums[slow]
        fast = nums[fast]
    return slow
```

#### 20. 合并两个有序链表

**题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
```

**答案解析：**

递归或迭代地合并两个链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

#### 21. 合并两个有序数组

**题目描述：** 给你两个整数数组 `nums1` 和 `nums2` ，按照以下方式合并它们的数组：

1. 初始化 `nums2` 中的下标 `i` 和 `nums1` 中的下标 `j` 到 `0` 。
2. 从两个数组的开始部分开始比较元素，直到两个数组到达结尾，选择较小元素放入 `nums1` 的下标 `i` ，然后 `i` 和 `j` 分别自增 `1` 。
3. 如果 `nums1` 还有剩余位置，将 `nums2` 中剩下的所有元素直接添加到 `nums1` 的末尾。

```python
def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    """
    Do not return anything, modify nums1 in-place instead.
    """
    i = m - 1
    j = n - 1
    pos = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[pos] = nums1[i]
            i -= 1
        else:
            nums1[pos] = nums2[j]
            j -= 1
        pos -= 1
    while j >= 0:
        nums1[pos] = nums2[j]
        pos -= 1
        j -= 1
```

**答案解析：**

使用双指针从后向前比较，将较大的元素放入数组的末尾，从而实现合并。

```python
def merge(nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    """
    Do not return anything, modify nums1 in-place instead.
    """
    i = m - 1
    j = n - 1
    pos = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[pos] = nums1[i]
            i -= 1
        else:
            nums1[pos] = nums2[j]
            j -= 1
        pos -= 1
    while j >= 0:
        nums1[pos] = nums2[j]
        pos -= 1
        j -= 1
```

#### 22. 螺旋矩阵 IV

**题目描述：** 给定一个 `m x n` 的矩阵 `mat`和一个整数 `k` ，你需要返回矩阵中第 `k` 个排序后的元素的值。

```python
def kthElement(mat: List[List[int]], k: int) -> int:
```

**答案解析：**

将矩阵中的元素放入一个列表中，然后对列表进行排序，返回第 `k` 个元素。

```python
def kthElement(mat: List[List[int]], k: int) -> int:
    arr = []
    for row in mat:
        for x in row:
            arr.append(x)
    arr.sort()
    return arr[k - 1]
```

#### 23. 两数之和 III - 数据流模式

**题目描述：** 设计一个算法，找出两数之和等于目标值的数对，并在数据流中第一个出现重复值时，返回这个数对。

```python
from collections import defaultdict

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        d = defaultdict(list)
        for i, v in enumerate(numbers):
            d[v].append(i + 1)
        for i, v in enumerate(numbers):
            complement = target - v
            if complement in d:
                if d[complement]:
                    return [i + 1, d[complement].pop(0)]
                else:
                    d[v].append(i + 1)
        return []
```

**答案解析：**

使用哈希表来存储每个数字和其出现的索引，当出现重复值时，返回第一个出现的索引。

```python
from collections import defaultdict

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        d = defaultdict(list)
        for i, v in enumerate(numbers):
            d[v].append(i + 1)
        for i, v in enumerate(numbers):
            complement = target - v
            if complement in d:
                if d[complement]:
                    return [i + 1, d[complement].pop(0)]
                else:
                    d[v].append(i + 1)
        return []
```

#### 24. 分割等和子集

**题目描述：** 给定一个不为空的整数数组 `nums` ，判断能否将其划分为两个和相等的子集。

```python
def canPartition(nums: List[int]) -> bool:
```

**答案解析：**

使用动态规划来解决这个问题，判断是否存在一个子集的和等于总和的一半。

```python
def canPartition(nums: List[int]) -> bool:
    total = sum(nums)
    if total % 2 != 0:
        return False
    target = total // 2
    n = len(nums)
    dp = [[False] * (target + 1) for _ in range(n + 1)]
    dp[0][0] = True
    for i in range(1, n + 1):
        for j in range(target + 1):
            if j < nums[i - 1]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
    return dp[n][target]
```

#### 25. 超级丑数

**题目描述：** 超级丑数是指一个正整数，并满足其所有质因数都是小于或等于 10 的 2 个自然数 。
 
```python
def nthSuperUglyNumber(n: int) -> int:
```

**答案解析：**

使用动态规划来生成超级丑数。

```python
def nthSuperUglyNumber(n: int) -> int:
    ugly = [1]
    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
    indexes = [0] * len(primes)
    while len(ugly) < n:
        next_ugly = min(ugly[index] * primes[i] for i, index in enumerate(indexes))
        ugly.append(next_ugly)
        for i, index in enumerate(indexes):
            if ugly[index] * primes[i] == next_ugly:
                indexes[i] += 1
    return ugly[-1]
```

#### 26. 环形链表

**题目描述：** 给定一个链表，判断该链表是否为环形链表。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
```

**答案解析：**

使用快慢指针来判断链表是否为环形链表。

```python
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

#### 27. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
```

**答案解析：**

从第一个字符串开始，逐个字符与后续字符串比较，找到最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

#### 28. 最长公共子串

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子串。

```python
def longestCommonSubstring(text1: str, text2: str) -> str:
```

**答案解析：**

使用动态规划来找到最长公共子串。

```python
def longestCommonSubstring(text1: str, text2: str) -> str:
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_pos = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i - 1
            else:
                dp[i][j] = 0
    return text1[end_pos - max_len + 1: end_pos + 1]
```

#### 29. 排序链表

**题目描述：** 给定一个链表，返回链表中的节点按升序排序后的链表。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
```

**答案解析：**

使用归并排序的方法来对链表进行排序。

```python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        mid = self.getMid(head)
        right = self.sortList(mid)
        left = self.sortList(head)
        return self.merge(left, right)

    def merge(self, left: Optional[ListNode], right: Optional[ListNode]) -> Optional[ListNode]:
        if not left:
            return right
        if not right:
            return left
        if left.val < right.val:
            left.next = self.merge(left.next, right)
            return left
        else:
            right.next = self.merge(left, right.next)
            return right

    def getMid(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

#### 30. 搜索旋转排序数组

**题目描述：** 给你一个旋转排序的数组 `nums` ，请你实现一个函数来查找给定的目标值 `target` ，并返回它在数组中的下标。如果目标值不存在于数组中，则返回 `−1` 。

```python
def search(nums: List[int], target: int) -> int:
```

**答案解析：**

在旋转排序的数组中，首先找到最小值，然后确定最小值的位置，接着使用二分查找。

```python
def search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] >= nums[right]:
            left = mid + 1
        else:
            right = mid
    pivot = left
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        real_mid = (mid + pivot) % len(nums)
        if nums[real_mid] == target:
            return real_mid
        elif nums[real_mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

