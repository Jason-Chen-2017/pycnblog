                 

### 美团2024届社招面试高频算法题解析

#### 题目1：最长公共子序列（LCS）

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到两个字符串的最长公共子序列。

**示例：**
```plaintext
s1 = "ABCBDAB"
s2 = "BDCAB"
```
**输出：**
```
LCS: "BCAB"
```

**答案解析：** 使用动态规划的方法求解。定义一个二维数组 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列长度。

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # 回溯获取最长公共子序列
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            lcs.append(s1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(reversed(lcs))

s1 = "ABCBDAB"
s2 = "BDCAB"
print(longest_common_subsequence(s1, s2))  # 输出 "BCAB"
```

#### 题目2：单源最短路径（Dijkstra算法）

**题目描述：** 给定一个无权图中所有的边长度，以及一个起始节点 `s`，求图中每个节点到起始节点 `s` 的最短路径。

**示例：**
```plaintext
edges = [
    (0, 1, 2),
    (0, 2, 1),
    (1, 2, 3),
    (1, 3, 6),
    (2, 3, 7)
]
s = 0
```
**输出：**
```
Shortest path to each node from node 0:
0 -> 0 (0)
1 -> 0 (2)
2 -> 0 (1)
3 -> 0 (7)
```

**答案解析：** 使用 Dijkstra 算法求解。首先定义一个优先队列（最小堆），用来选择距离起点最近的未访问节点，然后逐步更新其他节点的最短路径。

```python
import heapq

def dijkstra(edges, s):
    n = len(edges)
    INF = float('inf')
    dist = [INF] * n
    dist[s] = 0
    priority_queue = [(0, s)]

    while priority_queue:
        current_dist, u = heapq.heappop(priority_queue)
        if current_dist > dist[u]:
            continue
        for v, weight in edges[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(priority_queue, (dist[v], v))

    return dist

edges = [
    (0, 1, 2),
    (0, 2, 1),
    (1, 2, 3),
    (1, 3, 6),
    (2, 3, 7)
]
s = 0
print(dijkstra(edges, s))
```

#### 题目3：最大子序和（Kadane算法）

**题目描述：** 给定一个整数数组 `nums`，找出连续子数组的最大和。

**示例：**
```plaintext
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```
**输出：**
```
Maximum subarray sum: 6
```

**答案解析：** 使用 Kadane 算法求解。定义两个变量 `max_ending_here` 和 `max_so_far`，分别表示以当前元素为结尾的最大子序和以及到目前为止发现的最大子序和。

```python
def max_subarray_sum(nums):
    max_ending_here = max_so_far = nums[0]
    for x in nums[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))  # 输出 6
```

#### 题目4：合并区间（Merge Intervals）

**题目描述：** 给定一个区间列表，合并所有重叠的区间。

**示例：**
```plaintext
intervals = [
    (1, 3),
    (2, 6),
    (8, 10),
    (15, 18)
]
```
**输出：**
```
Merged intervals: [(1, 6), (8, 10), (15, 18)]
```

**答案解析：** 首先对区间按照左端点排序，然后遍历区间列表，合并重叠的区间。

```python
def merge_intervals(intervals):
    intervals.sort()
    merged = []
    for interval in intervals:
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1]))
    return merged

intervals = [(1, 3), (2, 6), (8, 10), (15, 18)]
print(merge_intervals(intervals))  # 输出 [(1, 6), (8, 10), (15, 18)]
```

#### 题目5：二分查找（Binary Search）

**题目描述：** 给定一个排序后的整数数组 `nums` 和一个目标值 `target`，找出 `nums` 中目标值的索引。

**示例：**
```plaintext
nums = [1, 3, 5, 6, 8, 9]
target = 6
```
**输出：**
```
Index of target: 3
```

**答案解析：** 使用二分查找算法，定义左右边界 `left` 和 `right`，逐步缩小查找范围。

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

nums = [1, 3, 5, 6, 8, 9]
target = 6
print(binary_search(nums, target))  # 输出 3
```

#### 题目6：合并两个有序链表（Merge Sorted List）

**题目描述：** 给定两个已排序的链表，合并它们为一个新的有序链表。

**示例：**
```plaintext
l1 = [1, 2, 4]
l2 = [1, 3, 4]
```
**输出：**
```
Merged list: [1, 1, 2, 3, 4, 4]
```

**答案解析：** 创建一个虚拟头节点，然后通过比较两个链表的当前节点值，将较小的节点添加到新链表中，并移动相应的链表指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged_list = merge_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
```

#### 题目7：回溯算法（N-Queens）

**题目描述：** 解 n 皇后问题，即找到一种放置 n 个皇后的方法，使得皇后们不在同一行、同一列或同一对角线上。

**示例：**
```plaintext
n = 4
```
**输出：**
```
Solutions for 4-Queens:
[
  [".Q..", "...Q", "Q...", "..Q."],
  ["..Q.", "Q...", "...Q", ".Q.."],
]
```

**答案解析：** 使用回溯算法求解。在放置皇后时，检查当前行的所有列和两个对角线上的位置是否已经被占据。

```python
def is_valid(board, row, col):
    for i in range(row):
        # 同一列
        if board[i] == col or \
           # 左上对角线
           board[i] - i == col - row or \
           # 右上对角线
           board[i] + i == col + row:
            return False
    return True

def solve_n_queens(board, row, solutions):
    if row == len(board):
        solutions.append([''.join(['Q' if c == i else '.' for c in range(len(board))]) for i in range(len(board))])
        return
    
    for col in range(len(board)):
        if is_valid(board, row, col):
            board[row] = col
            solve_n_queens(board, row + 1, solutions)
            board[row] = -1

n = 4
board = [-1] * n
solutions = []
solve_n_queens(board, 0, solutions)
for solution in solutions:
    print('[' + ','.join(solution) + ']')
```

#### 题目8：树遍历（Preorder, Inorder, Postorder）

**题目描述：** 给定一个二叉树，实现其先序遍历、中序遍历和后序遍历。

**示例：**
```plaintext
tree = [3, 9, 20, None, None, 15, 7]
```
**输出：**
```plaintext
Preorder: [3, 9, 20, 15, 7]
Inorder: [9, 3, 15, 20, 7]
Postorder: [9, 15, 7, 20, 3]
```

**答案解析：** 分别定义先序遍历、中序遍历和后序遍历的函数。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_traversal(root):
    result = []
    if root:
        result.append(root.val)
        result.extend(preorder_traversal(root.left))
        result.extend(preorder_traversal(root.right))
    return result

def inorder_traversal(root):
    result = []
    if root:
        result.extend(inorder_traversal(root.left))
        result.append(root.val)
        result.extend(inorder_traversal(root.right))
    return result

def postorder_traversal(root):
    result = []
    if root:
        result.extend(postorder_traversal(root.left))
        result.extend(postorder_traversal(root.right))
        result.append(root.val)
    return result

root = TreeNode(3, TreeNode(9, TreeNode(15, TreeNode(20)), TreeNode(7)))
print(preorder_traversal(root))
print(inorder_traversal(root))
print(postorder_traversal(root))
```

#### 题目9：反转链表（Reverse Linked List）

**题目描述：** 给定一个单链表，实现其反转。

**示例：**
```plaintext
linked_list = [1, 2, 3, 4, 5]
```
**输出：**
```plaintext
Reversed linked list: [5, 4, 3, 2, 1]
```

**答案解析：** 使用迭代或递归的方式实现链表反转。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev

head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
new_head = reverse_linked_list(head)
while new_head:
    print(new_head.val, end=' ')
    new_head = new_head.next
```

#### 题目10：求和两数（Two Sum）

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中两数之和等于目标值的两个数，并返回它们的索引。

**示例：**
```plaintext
nums = [2, 7, 11, 15]
target = 9
```
**输出：**
```plaintext
Two numbers at indices (0, 1) sum to the target: 2 + 7 = 9
```

**答案解析：** 使用哈希表存储数组中每个元素及其索引，然后遍历数组，对于当前元素，计算其与目标值的差，并检查哈希表中是否存在该差值。

```python
def two_sum(nums, target):
    nums_dict = {num: i for i, num in enumerate(nums)}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in nums_dict and nums_dict[complement] != i:
            return (i, nums_dict[complement])

nums = [2, 7, 11, 15]
target = 9
print(f"Two numbers at indices {two_sum(nums, target)} sum to the target: {nums[two_sum(nums, target)[0]]} + {nums[two_sum(nums, target)[1]]}")
```

#### 题目11：最长公共前缀（Longest Common Prefix）

**题目描述：** 给定一个字符串数组 `strs`，找出其中最长公共前缀。

**示例：**
```plaintext
strs = ["flower", "flow", "flight"]
```
**输出：**
```plaintext
Longest common prefix: "fl"
```

**答案解析：** 从第一个字符串开始，逐个字符与前一个字符串比较，直到不匹配为止。

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    for i, char in enumerate(strs[0]):
        for s in strs[1:]:
            if i >= len(s) or s[i] != char:
                return strs[0][:i]
    return strs[0]

strs = ["flower", "flow", "flight"]
print(f"Longest common prefix: \"{longest_common_prefix(strs)}\"")
```

#### 题目12：两数相加（Add Two Numbers）

**题目描述：** 给出两个非空链表表示两个非负整数，每个节点包含一个数字，将这两个数相加并返回一个链表。

**示例：**
```plaintext
l1 = [2, 4, 3]
l2 = [5, 6, 4]
```
**输出：**
```plaintext
Add two numbers: [7, 0, 8]
```

**答案解析：** 定义一个新的链表用于存储结果，然后逐位相加，处理进位。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        current.next = ListNode(sum % 10)
        current = current.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
result = add_two_numbers(l1, l2)
while result:
    print(result.val, end=' ')
    result = result.next
```

#### 题目13：LRU缓存（Least Recently Used Cache）

**题目描述：** 实现一个具有 `get` 和 `put` 函数的 LRU 缓存。

**示例：**
```plaintext
cache = LruCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))  # 输出 1
cache.put(3, 3)
print(cache.get(2))  # 输出 -1（不存在）
cache.put(4, 4)
print(cache.get(1))  # 输出 -1（已移除）
print(cache.get(3))  # 输出 3
print(cache.get(4))  # 输出 4
```

**答案解析：** 使用哈希表和双链表实现 LRU 缓存。

```python
class ListNode:
    def __init__(self, key=None, value=None, next=None, prev=None):
        self.key = key
        self.value = value
        self.next = next
        self.prev = prev

class LruCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        if key in self.cache:
            node = self.cache[key]
            self._move_to_head(node)
            return node.value
        return -1

    def put(self, key, value):
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._move_to_head(node)
        else:
            if len(self.cache) >= self.capacity:
                lru_key = self.tail.prev.key
                self._remove_tail()
                del self.cache[lru_key]
            new_node = ListNode(key, value)
            self.cache[key] = new_node
            self._add_to_head(new_node)

    def _remove_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add_to_head(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def _move_to_head(self, node):
        self._remove_node(node)
        self._add_to_head(node)
```

#### 题目14：反转整数（Reverse Integer）

**题目描述：** 实现一个函数，计算并返回整数的反转。

**示例：**
```plaintext
x = 123
```
**输出：**
```plaintext
Reversed integer: 321
```

**答案解析：** 逐位取出整数的各位数字，然后拼接成反转后的整数。

```python
def reverse(x):
    sign = -1 if x < 0 else 1
    x *= sign
    reversed_x = 0
    while x:
        reversed_x = reversed_x * 10 + x % 10
        x //= 10
    return reversed_x * sign

x = 123
print(f"Reversed integer: {reverse(x)}")
```

#### 题目15：环形链表（Detect Cycle）

**题目描述：** 给定一个链表，判断链表中是否存在环。

**示例：**
```plaintext
linked_list = [3, 2, 0, -4]
```
**输出：**
```plaintext
There is a cycle in the linked list.
```

**答案解析：** 使用快慢指针，慢指针每次移动一步，快指针每次移动两步。如果链表中存在环，那么快指针最终会追上慢指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

linked_list = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
print("There is a cycle in the linked list." if has_cycle(linked_list) else "There is no cycle in the linked list.")
```

#### 题目16：字符串转换整数（String to Integer）

**题目描述：** 实现一个函数，将字符串转换成整数。

**示例：**
```plaintext
s = "42"
```
**输出：**
```plaintext
Integer: 42
```

**答案解析：** 检查字符串的首个字符是否为正负号，然后逐个字符转换为整数。

```python
def myAtoi(s: str) -> int:
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    i, sign, result = 0, 1, 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i < len(s) and (s[i] == '+' or s[i] == '-'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        result = result * 10 + int(s[i])
        i += 1
    return max(INT_MIN, min(INT_MAX, result * sign))

s = "42"
print(f"Integer: {myAtoi(s)}")
```

#### 题目17：两数之和 II - 输入有序数组（Two Sum II - Input Array Is Sorted）

**题目描述：** 给定一个已排序的整数数组 `numbers` 和一个目标值 `target`，找出两个数，使得它们的和等于目标值，并返回它们的索引。

**示例：**
```plaintext
numbers = [2, 7, 11, 15]
target = 9
```
**输出：**
```plaintext
Two numbers at indices (0, 1) sum to the target: 2 + 7 = 9
```

**答案解析：** 使用两个指针分别指向数组的起始和结束位置，如果两个指针指向的数之和小于目标值，移动左指针；如果两个指针指向的数之和大于目标值，移动右指针。

```python
def two_sum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        if numbers[left] + numbers[right] == target:
            return (left, right)
        elif numbers[left] + numbers[right] < target:
            left += 1
        else:
            right -= 1
    return None

numbers = [2, 7, 11, 15]
target = 9
print(f"Two numbers at indices {two_sum(numbers, target)} sum to the target: {numbers[two_sum(numbers, target)[0]]} + {numbers[two_sum(numbers, target)[1]]}")
```

#### 题目18：有效的括号（Valid Parentheses）

**题目描述：** 给定一个字符串 `s` ，验证它是否是有效的括号字符串。

**示例：**
```plaintext
s = "()[]{}"
```
**输出：**
```plaintext
True
```

**答案解析：** 使用栈存储左括号，当遇到右括号时，检查栈顶是否为对应的左括号。

```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack

s = "()[]{}"
print(isValid(s))
```

#### 题目19：最大子序和 II（Maximum Subarray SumCircular）

**题目描述：** 给定一个整数数组 `nums` 和一个整数 `k`，找到最大子序和，使得子序的长度为 `k`。

**示例：**
```plaintext
nums = [1, -2, 3, 4, -5, 6]
k = 4
```
**输出：**
```plaintext
Maximum subarray sum: 10
```

**答案解析：** 使用前缀和 + 滑动窗口的方法。首先计算前 `k` 个元素的和，然后逐个滑动窗口，更新最大子序和。

```python
def maxSubarraySumCircular(nums, k):
    if not nums:
        return 0
    max_ending_here = max_so_far = nums[0]
    min_ending_here = min_so_far = nums[0]
    total = nums[0]
    for i in range(1, len(nums)):
        max_ending_here = max(nums[i], max_ending_here + nums[i])
        max_so_far = max(max_so_far, max_ending_here)
        min_ending_here = min(nums[i], min_ending_here + nums[i])
        min_so_far = min(min_so_far, min_ending_here)
        total += nums[i]
    if max_so_far < 0:
        return max_so_far
    return max(max_so_far, total - min_so_far)

nums = [1, -2, 3, 4, -5, 6]
k = 4
print(f"Maximum subarray sum: {maxSubarraySumCircular(nums, k)}")
```

#### 题目20：最长公共子串（Longest Common Substring）

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到它们最长的公共子串。

**示例：**
```plaintext
s1 = "abcdf"
s2 = "abdf"
```
**输出：**
```plaintext
Longest common substring: "bdf"
```

**答案解析：** 使用动态规划的方法。定义一个二维数组 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子串长度。

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end = i - 1
            else:
                dp[i][j] = 0
    return s1[end - max_len + 1: end + 1]

s1 = "abcdf"
s2 = "abdf"
print(f"Longest common substring: \"{longest_common_substring(s1, s2)}\"")
```

#### 题目21：合并两个有序链表（Merge Two Sorted Lists）

**题目描述：** 给定两个已排序的链表，将它们合并为一个链表。

**示例：**
```plaintext
l1 = [1, 2, 4]
l2 = [1, 3, 4]
```
**输出：**
```plaintext
Merged list: [1, 1, 2, 3, 4, 4]
```

**答案解析：** 定义一个虚拟头节点，然后比较两个链表的当前节点值，将较小的节点添加到新链表中，并移动相应的链表指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged_list = merge_two_sorted_lists(l1, l2)
while merged_list:
    print(merged_list.val, end=' ')
    merged_list = merged_list.next
```

#### 题目22：最长公共子序列（Longest Common Subsequence）

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到它们最长的公共子序列。

**示例：**
```plaintext
s1 = "ABCBDAB"
s2 = "BDCAB"
```
**输出：**
```plaintext
Longest common subsequence: "BCAB"
```

**答案解析：** 使用动态规划的方法。定义一个二维数组 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列长度。

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            lcs.append(s1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(reversed(lcs))

s1 = "ABCBDAB"
s2 = "BDCAB"
print(longest_common_subsequence(s1, s2))  # 输出 "BCAB"
```

#### 题目23：最小栈（Minimum Stack）

**题目描述：** 设计一个最小栈，它应该支持插入、删除和获取最小元素的操作。

**示例：**
```plaintext
stack = MinStack()
stack.push(-2)
stack.push(0)
stack.push(-3)
stack.getMin()  # 返回 -3
stack.pop()
stack.getMin()  # 返回 -2
```

**答案解析：** 使用两个栈，一个用于存储所有元素，另一个用于存储最小元素。

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

#### 题目24：最大子序和（Kadane算法）

**题目描述：** 给定一个整数数组 `nums`，找出连续子数组的最大和。

**示例：**
```plaintext
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```
**输出：**
```plaintext
Maximum subarray sum: 6
```

**答案解析：** 使用 Kadane 算法求解。定义两个变量 `max_ending_here` 和 `max_so_far`，分别表示以当前元素为结尾的最大子序和以及到目前为止发现的最大子序和。

```python
def max_subarray_sum(nums):
    max_ending_here = max_so_far = nums[0]
    for x in nums[1:]:
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))  # 输出 6
```

#### 题目25：删除链表的节点（Delete Node in a Linked List）

**题目描述：** 给定一个单链表的节点，删除该节点。

**示例：**
```plaintext
head = [4, 5, 1, 9]
pos = 1
```
**输出：**
```plaintext
List after deleting node at position 1: [4, 1, 9]
```

**答案解析：** 将前一个节点的值赋给当前节点，然后删除当前节点。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_node(node):
    node.val = node.next.val
    node.next = node.next.next

head = ListNode(4, ListNode(5, ListNode(1, ListNode(9))))
delete_node(head.next)
while head:
    print(head.val, end=' ')
    head = head.next
```

#### 题目26：删除有序链表中的重复节点（Delete Duplicates from Sorted List）

**题目描述：** 给定一个排序后的链表，删除重复节点。

**示例：**
```plaintext
head = [1, 1, 2, 3, 3]
```
**输出：**
```plaintext
List after deleting duplicates: [1, 2, 3]
```

**答案解析：** 使用快慢指针遍历链表，快指针每次移动两步，慢指针每次移动一步。当快指针指向的节点与慢指针指向的节点值不相同时，移动慢指针。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_duplicates(head):
    if not head:
        return
    slow = fast = head
    while fast and fast.next:
        if slow.val != fast.val:
            slow = slow.next
        fast = fast.next
    slow.next = fast
    return head

head = ListNode(1, ListNode(1, ListNode(2, ListNode(3, ListNode(3)))))
new_head = delete_duplicates(head)
while new_head:
    print(new_head.val, end=' ')
    new_head = new_head.next
```

#### 题目27：合并两个有序数组（Merge Sorted Array）

**题目描述：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中。

**示例：**
```plaintext
nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
```
**输出：**
```plaintext
Merged array: [1, 2, 2, 3, 5, 6]
```

**答案解析：** 从数组的末尾开始比较两个数组中的元素，将较大的元素放入 `nums1` 的末尾，并相应地移动两个数组的指针。

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    return nums1

nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
print(merge_sorted_arrays(nums1, 3, nums2, 3))
```

#### 题目28：两数之和（Two Sum）

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出两个数，使得它们的和等于目标值，并返回它们的索引。

**示例：**
```plaintext
nums = [2, 7, 11, 15]
target = 9
```
**输出：**
```plaintext
Two numbers at indices (0, 1) sum to the target: 2 + 7 = 9
```

**答案解析：** 使用哈希表存储数组中每个元素及其索引，然后遍历数组，对于当前元素，计算其与目标值的差，并检查哈希表中是否存在该差值。

```python
def two_sum(nums, target):
    nums_dict = {num: i for i, num in enumerate(nums)}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in nums_dict and nums_dict[complement] != i:
            return (i, nums_dict[complement])

nums = [2, 7, 11, 15]
target = 9
print(f"Two numbers at indices {two_sum(nums, target)} sum to the target: {nums[two_sum(nums, target)[0]]} + {nums[two_sum(nums, target)[1]]}")
```

#### 题目29：实现排序算法（Implement Sorting Algorithms）

**题目描述：** 实现冒泡排序、选择排序和插入排序。

**示例：**
```plaintext
nums = [64, 34, 25, 12, 22, 11, 90]
```
**输出：**
```plaintext
Bubble sort: [11, 12, 22, 25, 34, 64, 90]
Selection sort: [11, 12, 22, 25, 34, 64, 90]
Insertion sort: [11, 12, 22, 25, 34, 64, 90]
```

**答案解析：** 分别实现冒泡排序、选择排序和插入排序。

```python
def bubble_sort(nums):
    n = len(nums)
    for i in range(n):
        for j in range(0, n - i - 1):
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums

def selection_sort(nums):
    n = len(nums)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if nums[j] < nums[min_idx]:
                min_idx = j
        nums[i], nums[min_idx] = nums[min_idx], nums[i]
    return nums

def insertion_sort(nums):
    n = len(nums)
    for i in range(1, n):
        key = nums[i]
        j = i - 1
        while j >= 0 and key < nums[j]:
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = key
    return nums

nums = [64, 34, 25, 12, 22, 11, 90]
print("Bubble sort:", bubble_sort(nums.copy()))
print("Selection sort:", selection_sort(nums.copy()))
print("Insertion sort:", insertion_sort(nums.copy()))
```

#### 题目30：实现栈（Implement Stack）

**题目描述：** 使用链表实现一个栈。

**示例：**
```plaintext
stack = Stack()
stack.push(1)
stack.push(2)
stack.pop()
stack.isEmpty()
```
**输出：**
```plaintext
Stack after pushing 1 and 2: [1, 2]
Stack after popping: [1]
Is stack empty? False
```

**答案解析：** 使用链表实现栈。

```python
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None

class Stack:
    def __init__(self):
        self.top = None

    def push(self, val):
        new_node = Node(val)
        new_node.next = self.top
        self.top = new_node

    def pop(self):
        if self.isEmpty():
            return "Stack is empty"
        val = self.top.val
        self.top = self.top.next
        return val

    def isEmpty(self):
        return self.top is None

stack = Stack()
stack.push(1)
stack.push(2)
print("Stack after pushing 1 and 2:", stack.top.val, end=' ')
print(stack.top.next.val, end=' ')
print()
print("Stack after popping:", stack.pop())
print("Is stack empty?", stack.isEmpty())
```

