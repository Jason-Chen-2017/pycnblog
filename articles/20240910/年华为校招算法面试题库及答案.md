                 

# 2025年华为校招算法面试题库及答案

本文将为您介绍2025年华为校招中的典型算法面试题及答案。这些题目涵盖数组、链表、树、图、排序、搜索、动态规划等多个领域，旨在帮助您全面了解华为校招算法面试的要求。每道题目都附有详细的答案解析，以及相应的源代码实例。

## 1. 数组

### 题目1：找出数组中的重复元素

**题目描述：** 给定一个整数数组，找出其中的重复元素。

**示例：** 输入：[1, 2, 3, 4, 5, 2]，输出：2。

**答案解析：** 可以使用哈希表或者排序的方法来解决这个问题。

**代码示例：**

```go
// 使用哈希表
func findDuplicate(nums []int) int {
    m := make(map[int]int)
    for _, v := range nums {
        if m[v] > 0 {
            return v
        }
        m[v]++
    }
    return -1
}

// 使用排序
func findDuplicate(nums []int) int {
    sort.Ints(nums)
    for i := 1; i < len(nums); i++ {
        if nums[i] == nums[i-1] {
            return nums[i]
        }
    }
    return -1
}
```

## 2. 链表

### 题目2：两数相加

**题目描述：** 给出两个非空链表，每个链表表示一个非负整数，数字按逆序方式存储。请将两个数相加并返回链表形式。

**示例：** 输入：[2, 4, 3]，[5, 6, 4]，输出：[7, 0, 8]。

**答案解析：** 可以通过模拟加法运算，将两个链表对应的数字相加，并处理进位。

**代码示例：**

```go
//Definition for singly-linked list.
type ListNode struct {
    Val int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        x := 0
        if l1 != nil {
            x += l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y += l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        cur.Next = &ListNode{Val: sum % 10}
        cur = cur.Next
    }
    return dummy.Next
}
```

## 3. 树

### 题目3：二叉搜索树中的搜索

**题目描述：** 给定一个二叉搜索树的根节点 root 和一个目标值 target，在树中查找 target 值的节点。

**示例：** 输入：[4, 2, 7, 1, 3]，target = 6，输出：[4, 7, 3]。

**答案解析：** 可以利用二叉搜索树的特性，逐步缩小搜索范围。

**代码示例：**

```go
//Definition for a binary tree node.
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func searchBST(root *TreeNode, target int) *TreeNode {
    if root == nil || root.Val == target {
        return root
    }
    if target < root.Val {
        return searchBST(root.Left, target)
    }
    return searchBST(root.Right, target)
}
```

## 4. 图

### 题目4：拓扑排序

**题目描述：** 给定一个无向图，完成拓扑排序。

**示例：** 输入：[[0, 1], [0, 2], [1, 2]，输出：[0, 1, 2]。

**答案解析：** 可以使用 DFS 或 BFS 实现拓扑排序。

**代码示例：**

```go
// 使用 DFS
func topologySort(DAG [][]int) []int {
    visited := make([]bool, len(DAG))
    res := []int{}
    for i := range visited {
        if !visited[i] {
            dfs(i, DAG, &visited, &res)
        }
    }
    return res
}

func dfs(i int, DAG [][]int, visited *[]bool, res *[]int) {
    (*visited)[i] = true
    for _, j := range DAG[i] {
        if !(*visited)[j] {
            dfs(j, DAG, visited, res)
        }
    }
    *res = append(*res, i)
}

// 使用 BFS
func topologySort(DAG [][]int) []int {
    inDegree := make([]int, len(DAG))
    for _, edges := range DAG {
        for _, edge := range edges {
            inDegree[edge]++
        }
    }
    q := []int{}
    for i, v := range inDegree {
        if v == 0 {
            q = append(q, i)
        }
    }
    res := []int{}
    for len(q) > 0 {
        i := q[0]
        q = q[1:]
        res = append(res, i)
        for _, j := range DAG[i] {
            inDegree[j]--
            if inDegree[j] == 0 {
                q = append(q, j)
            }
        }
    }
    return res
}
```

## 5. 排序

### 题目5：快速排序

**题目描述：** 给定一个整数数组，使用快速排序算法进行排序。

**示例：** 输入：[3, 2, 1]，输出：[1, 2, 3]。

**答案解析：** 快速排序的基本思想是通过一趟排序将数组分为两个部分，其中一部分的所有元素都比另一部分的所有元素小。

**代码示例：**

```go
func quickSort(nums []int) {
    qsort(nums, 0, len(nums)-1)
}

func qsort(nums []int, low, high int) {
    if low >= high {
        return
    }
    pivot := partition(nums, low, high)
    qsort(nums, low, pivot-1)
    qsort(nums, pivot+1, high)
}

func partition(nums []int, low, high int) int {
    pivot := nums[high]
    i := low
    for j := low; j < high; j++ {
        if nums[j] <= pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    nums[i], nums[high] = nums[high], nums[i]
    return i
}
```

## 6. 搜索

### 题目6：DFS 和 BFS

**题目描述：** 给定一个无向图，使用 DFS 和 BFS 算法找到从源点 s 到目标点 t 的路径。

**示例：** 输入：[0, 1, 3]，[3]，[[0, 1, 3], [1, 2, 3]，[0, 2]，输出：[[0, 1, 3]，[0, 2]。

**答案解析：** DFS 和 BFS 都是图遍历算法，DFS 是深度优先搜索，BFS 是广度优先搜索。

**代码示例：**

```go
// DFS
func dfs(graph [][]int, start, target int) [][]int {
    res := [][]int{}
    visited := make(map[int]bool)
    dfsHelper(graph, start, target, visited, []int{}, &res)
    return res
}

func dfsHelper(graph [][]int, start, target int, visited map[int]bool, path []int, res *[][]int) {
    if start == target {
        *res = append(*res, append([]int{}, path...))
        return
    }
    visited[start] = true
    for _, neighbor := range graph[start] {
        if !visited[neighbor] {
            path = append(path, neighbor)
            dfsHelper(graph, neighbor, target, visited, path, res)
            path = path[:len(path)-1]
        }
    }
}

// BFS
func bfs(graph [][]int, start, target int) [][]int {
    res := [][]int{}
    q := []int{start}
    visited := make(map[int]bool)
    visited[start] = true
    for len(q) > 0 {
        node := q[0]
        q = q[1:]
        for _, neighbor := range graph[node] {
            if !visited[neighbor] {
                if neighbor == target {
                    res = append(res, append([]int{}, node, neighbor))
                    return res
                }
                q = append(q, neighbor)
                visited[neighbor] = true
            }
        }
    }
    return res
}
```

## 7. 动态规划

### 题目7：最长公共子序列

**题目描述：** 给定两个字符串，求它们的最长公共子序列。

**示例：** 输入：`"ABCBDAB"`，`"BDCAB"`，输出：`"BCAB"`。

**答案解析：** 动态规划是一种用于求解最优子结构问题的算法，可以通过子问题的最优解来推导出原问题的最优解。

**代码示例：**

```go
func longestCommonSubsequence(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    idx := dp[m][n]
    t1, t2 := m, n
    res := make([]byte, idx)
    for idx > 0 {
        if text1[t1-1] == text2[t2-1] {
            res[idx-1] = text1[t1-1]
            t1--
            t2--
            idx--
        } else if dp[t1-1][t2] > dp[t1][t2-1] {
            t1--
        } else {
            t2--
        }
    }
    return string(res)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 8. 其他

### 题目8：最小生成树

**题目描述：** 给定一个无向图，求它的最小生成树。

**示例：** 输入：`[['a', 'b', 2], ['a', 'c', 3], ['b', 'c', 1]]`，输出：`[['a', 'b', 2], ['b', 'c', 1]]`。

**答案解析：** 可以使用 Prim 算法或 Kruskal 算法求解最小生成树。

**代码示例：**

```go
// Prim 算法
func findMinTree(edges [][]int) [][]int {
    n := len(edges)
    vis := make([]bool, n)
    res := [][]int{}
    for i := 0; i < n; i++ {
        if !vis[i] {
            vis[i] = true
            u, v, w := edges[i][0], edges[i][1], edges[i][2]
            for j := 0; j < n; j++ {
                if !vis[j] && edges[j][0] == u {
                    vis[j] = true
                    res = append(res, []int{u, v, w})
                    u, v, w = edges[j][1], edges[j][2], edges[j][3]
                } else if !vis[j] && edges[j][0] == v {
                    vis[j] = true
                    res = append(res, []int{u, v, w})
                    u, v, w = edges[j][1], edges[j][2], edges[j][3]
                }
            }
        }
    }
    return res
}

// Kruskal 算法
type UnionFind struct {
    p     []int
    size  []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        p:     make([]int, n),
        size:  make([]int, n),
    }
    for i := range uf.p {
        uf.p[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.p[x] != x {
        uf.p[x] = uf.Find(uf.p[x])
    }
    return uf.p[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX == rootY {
        return false
    }
    if uf.size[rootX] > uf.size[rootY] {
        uf.p[rootY] = rootX
        uf.size[rootX] += uf.size[rootY]
    } else {
        uf.p[rootX] = rootY
        uf.size[rootY] += uf.size[rootX]
    }
    return true
}

func findMinTree(edges [][]int) [][]int {
    sort.Slice(edges, func(i, j int) bool {
        return edges[i][2] < edges[j][2]
    })
    uf := NewUnionFind(len(edges))
    res := [][]int{}
    for _, edge := range edges {
        if uf.Union(edge[0], edge[1]) {
            res = append(res, edge)
        }
    }
    return res
}
```

## 总结

以上是2025年华为校招中的典型算法面试题及答案，这些题目涵盖了各种领域，有助于您全面了解华为校招算法面试的要求。希望通过本文的解析，能对您的算法学习和面试准备有所帮助。祝您面试成功！

