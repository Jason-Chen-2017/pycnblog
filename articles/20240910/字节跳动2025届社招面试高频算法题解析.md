                 

## 字节跳动2025届社招面试高频算法题解析

### 面试题库与算法编程题库

字节跳动是国内领先的一线互联网公司，其面试题和算法编程题库在业界具有极高的参考价值。以下是字节跳动2025届社招面试中的一些典型高频算法题，我们将对这些题目进行详细解析。

### 1. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""

    # 暴力法
    prefix = ""
    for c in strs[0]:
        for s in strs:
            if s.index(c) != 0:
                return prefix
        prefix += c
    return prefix
```

**解析：** 暴力法的时间复杂度为O(mn)，其中m是字符串的平均长度，n是字符串的数量。

**进阶：** 使用排序+二分查找的方法，可以将时间复杂度降低到O(nmlogn)。

### 2. 字符串转换整数 (atoi)

**题目描述：** 实现一个函数，将字符串转换为整数。

**示例：**

```python
def myAtoi(s: str) -> int:
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    i, sign, result = 0, 1, 0

    # 判断正负
    if s[0] == '-':
        sign = -1
        i = 1
    elif s[0] == '+':
        i = 1

    # 跳过空白字符
    while i < len(s) and s[i] == ' ':
        i += 1

    # 构建整数
    for ; i < len(s); i += 1:
        if s[i].isdigit():
            result = result * 10 + int(s[i])
            if result * sign > INT_MAX:
                return INT_MAX
            if result * sign < INT_MIN:
                return INT_MIN
        else:
            break

    return result * sign
```

**解析：** 此题需要注意边界条件，如字符串过长导致的溢出、包含非数字字符等。

### 3. 两个数组的交集 II

**题目描述：** 给定两个整数数组，输出两个数组的交集。

**示例：**

```python
def intersect(nums1, nums2):
    from collections import Counter
    cnt1 = Counter(nums1)
    ans = []
    cnt2 = Counter(nums2)
    for num in cnt2:
        cnt = min(cnt1[num], cnt2[num])
        ans.extend([num] * cnt)
    return ans
```

**解析：** 使用Counter计数，找出两个数组中每个元素的最小出现次数。

### 4. 字符串转换整数 (atoi) - 难度较高

**题目描述：** 实现一个函数，将字符串转换为整数，考虑更多边界条件。

**示例：**

```python
def myAtoi_higher(s: str) -> int:
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    i, sign, result = 0, 1, 0

    # 判断正负
    if s[0] == '-':
        sign = -1
        i = 1
    elif s[0] == '+':
        sign = 1
        i = 1

    # 跳过空白字符
    while i < len(s) and s[i] == ' ':
        i += 1

    # 判断是否为数字
    if i == len(s) or not s[i].isdigit():
        return 0

    # 构建整数
    for ; i < len(s); i += 1:
        if not s[i].isdigit():
            break
        result = result * 10 + int(s[i])
        if result * sign > INT_MAX:
            return INT_MAX
        if result * sign < INT_MIN:
            return INT_MIN

    return result * sign
```

**解析：** 此题需要处理更复杂的边界条件，如字符串前导零、正负号等。

### 5. 三数之和

**题目描述：** 给定一个数组，找出所有满足a + b + c = 0的三元组。

**示例：**

```python
def threeSum(nums):
    nums.sort()
    ans = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        l, r = i + 1, len(nums) - 1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if s < 0:
                l += 1
            elif s > 0:
                r -= 1
            else:
                ans.append([nums[i], nums[l], nums[r]])
                while l < r and nums[l] == nums[l + 1]:
                    l += 1
                while l < r and nums[r] == nums[r - 1]:
                    r -= 1
    return ans
```

**解析：** 使用排序+双指针的方法，时间复杂度为O(n^2)。

### 6. 两数相加

**题目描述：** 给定两个非空链表，每个链表表示一个非负整数，返回这两个数字相加的结果。

**示例：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            if l1:
                carry += l1.val
                l1 = l1.next
            if l2:
                carry += l2.val
                l2 = l2.next
            curr.next = ListNode(carry % 10)
            curr = curr.next
            carry //= 10
        return dummy.next
```

**解析：** 使用链表的方式存储结果，注意处理进位。

### 7. 顺时针打印矩阵

**题目描述：** 给定一个按顺时针顺序螺旋排列的矩阵，返回矩阵中的所有元素。

**示例：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    m, n = len(matrix), len(matrix[0])
    left, right, top, bottom = 0, n - 1, 0, m - 1
    ans = []
    while left <= right and top <= bottom:
        for i in range(left, right + 1):
            ans.append(matrix[top][i])
        top += 1
        for i in range(top, bottom + 1):
            ans.append(matrix[i][right])
        right -= 1
        if top <= bottom:
            for i in range(right, left - 1, -1):
                ans.append(matrix[bottom][i])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top - 1, -1):
                ans.append(matrix[i][left])
            left += 1
    return ans
```

**解析：** 利用边界逐步缩小，模拟螺旋遍历。

### 8. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False
```

**解析：** 使用快慢指针，判断是否相遇。

### 9. 搜索二维矩阵

**题目描述：** 给定一个排序矩阵，找到给定值的元素。

**示例：**

```python
def searchMatrix(matrix, target):
    row, col = 0, len(matrix[0]) - 1
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False
```

**解析：** 利用矩阵的有序特性，使用二分查找。

### 10. 螺旋矩阵

**题目描述：** 给定一个矩阵，将其按螺旋顺序打印出来。

**示例：**

```python
def spiralOrder(matrix):
    if not matrix:
        return []
    m, n = len(matrix), len(matrix[0])
    left, right, top, bottom = 0, n - 1, 0, m - 1
    ans = []
    while left <= right and top <= bottom:
        for i in range(left, right + 1):
            ans.append(matrix[top][i])
        top += 1
        for i in range(top, bottom + 1):
            ans.append(matrix[i][right])
        right -= 1
        if top <= bottom:
            for i in range(right, left - 1, -1):
                ans.append(matrix[bottom][i])
            bottom -= 1
        if left <= right:
            for i in range(bottom, top - 1, -1):
                ans.append(matrix[i][left])
            left += 1
    return ans
```

**解析：** 利用边界逐步缩小，模拟螺旋遍历。

### 11. 爬楼梯

**题目描述：** 一个楼梯总共有n个台阶，每次可以爬1或2个台阶，求有多少种不同的方法可以爬到楼顶。

**示例：**

```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(n - 2):
        a, b = b, a + b
    return b
```

**解析：** 使用动态规划，时间复杂度为O(n)。

### 12. 有效的括号

**题目描述：** 给定一个字符串，判断其是否为有效的括号。

**示例：**

```python
def isValid(s: str) -> bool:
    stack = []
    for c in s:
        if c in "({[":
            stack.append(c)
        else:
            if not stack:
                return False
            top = stack.pop()
            if (c == ')' and top != '(') or (c == ']' and top != '[') or (c == '}' and top != '{'):
                return False
    return not stack
```

**解析：** 使用栈实现，判断括号是否匹配。

### 13. 合并两个有序链表

**题目描述：** 给定两个有序链表，将它们合并为一个新的有序链表并返回。

**示例：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 使用循环遍历，合并两个有序链表。

### 14. 二进制中1的个数

**题目描述：** 给定一个整数，返回其二进制表示中 1 的个数。

**示例：**

```python
def hammingWeight(self, n: int) -> int:
    ans = 0
    while n:
        ans += n & 1
        n >>= 1
    return ans
```

**解析：** 使用位运算，统计1的个数。

### 15. 旋转数组的最小数字

**题目描述：** 给定一个旋转排序数组，找出其最小元素。

**示例：**

```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) >> 1
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

**解析：** 使用二分查找，找到最小元素。

### 16. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序数组，找到给定的目标值。

**示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) >> 1
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target <= nums[right] and target > nums[mid]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 使用二分查找，考虑旋转数组的特点。

### 17. 买卖股票的最佳时机 III

**题目描述：** 给定一个数组，找出能赚取最多利润的买卖股票时机，其中最多只能进行两笔交易。

**示例：**

```python
def maxProfit(self, prices: List[int]) -> int:
    first, second, result = 0, 0, 0
    for p in prices:
        second = max(second, first+p)
        first = max(first, -p)
        result = max(result, second)
    return result
```

**解析：** 使用动态规划，记录每一笔交易的最大利润。

### 18. 两数之和 III - 数据结构设计

**题目描述：** 设计一个数据结构，能够实现添加、查询、删除操作，并支持两数之和的功能。

**示例：**

```python
class TwoSum:
    def __init__(self):
        self.nums = {}

    def add(self, number: int) -> None:
        self.nums[number] = self.nums.get(number, 0) + 1

    def find(self, value: int) -> int:
        for num, count in self.nums.items():
            target = value - num
            if target in self.nums and (target != num or count > 1):
                return num
        return -1

    def remove(self, number: int) -> None:
        self.nums[number] -= 1
        if self.nums[number] == 0:
            del self.nums[number]
```

**解析：** 使用哈希表记录元素及其出现次数，实现添加、查询、删除操作。

### 19. 设计前中后三个栈

**题目描述：** 设计一个包含三个栈的容器，允许在O(1)时间内获取栈的最大元素。

**示例：**

```python
class TripleStack:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []
        self.stack3 = []
        self.max_val = -inf

    def push(self, val, stack_number):
        if stack_number == 1:
            self.stack1.append(val)
            if val > self.max_val:
                self.max_val = val
        elif stack_number == 2:
            self.stack2.append(val)
            if val > self.max_val:
                self.max_val = val
        elif stack_number == 3:
            self.stack3.append(val)
            if val > self.max_val:
                self.max_val = val

    def pop(self, stack_number):
        if stack_number == 1:
            val = self.stack1.pop()
            if val == self.max_val:
                self.find_new_max(self.stack1)
            return val
        elif stack_number == 2:
            val = self.stack2.pop()
            if val == self.max_val:
                self.find_new_max(self.stack2)
            return val
        elif stack_number == 3:
            val = self.stack3.pop()
            if val == self.max_val:
                self.find_new_max(self.stack3)
            return val

    def find_new_max(self, stack):
        self.max_val = max(stack)
```

**解析：** 分别维护三个栈，并维护最大元素。

### 20. 设计推特

**题目描述：** 设计一个推特，支持发送、关注、关注微博等操作。

**示例：**

```python
class Twitter:
    def __init__(self):
        self.tweets = defaultdict(list)
        self.followees = defaultdict(set)

    def postTweet(self, userId: int, tweetId: int) -> None:
        self.tweets[userId].append(tweetId)

    def follow(self, followerId: int, followeeId: int) -> None:
        self.followees[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -> None:
        self.followees[followerId].remove(followeeId)

    def getNewsFeed(self, userId: int) -> List[int]:
        feed = []
        followees = self.followees[userId]
        for id in sorted(followees, reverse=True):
            feed.extend(self.tweets[id])
        feed.extend(self.tweets[userId])
        return feed[:10]
```

**解析：** 使用哈希表记录推文和关注关系。

### 21. 环形缓冲区

**题目描述：** 设计一个环形缓冲区，支持入队、出队、获取队列长度等操作。

**示例：**

```python
class CircularQueue:
    def __init__(self, k: int):
        self.queue = [None] * k
        self.head = self.tail = 0

    def enQueue(self, value: int) -> bool:
        if (self.tail + 1) % len(self.queue) == self.head:
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % len(self.queue)
        return True

    def deQueue(self) -> bool:
        if self.head == self.tail:
            return False
        self.head = (self.head + 1) % len(self.queue)
        return True

    def Front(self) -> int:
        if self.head == self.tail:
            return -1
        return self.queue[self.head]

    def Rear(self) -> int:
        if self.head == self.tail:
            return -1
        return self.queue[self.tail - 1]

    def isEmpty(self) -> bool:
        return self.head == self.tail

    def isFull(self) -> bool:
        return (self.tail + 1) % len(self.queue) == self.head
```

**解析：** 使用数组实现环形缓冲区。

### 22. 设计一个支持中序遍历的后缀表达式树

**题目描述：** 设计一个支持中序遍历的后缀表达式树，支持解析后缀表达式并计算结果。

**示例：**

```python
class SuffixExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 23. 模拟器

**题目描述：** 设计一个模拟器，支持执行指令、添加指令等操作。

**示例：**

```python
class Simulator:
    def __init__(self):
        self.instructions = []

    def addInstruction(self, instruction: str):
        self.instructions.append(instruction)

    def execute(self):
        for instr in self.instructions:
            print(instr)
            # 执行指令
```

**解析：** 使用列表存储指令，并逐条执行。

### 24. 设计一个支持中序遍历的前缀表达式树

**题目描述：** 设计一个支持中序遍历的前缀表达式树，支持解析前缀表达式并计算结果。

**示例：**

```python
class PrefixExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 25. 设计一个支持中序遍历的逆波兰表达式树

**题目描述：** 设计一个支持中序遍历的逆波兰表达式树，支持解析逆波兰表达式并计算结果。

**示例：**

```python
class InfixExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 26. 设计一个支持中序遍历的表达式树

**题目描述：** 设计一个支持中序遍历的表达式树，支持解析表达式并计算结果。

**示例：**

```python
class ExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 27. 设计一个支持中序遍历的表达式树

**题目描述：** 设计一个支持中序遍历的表达式树，支持解析表达式并计算结果。

**示例：**

```python
class ExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 28. 设计一个支持中序遍历的逆波兰表达式树

**题目描述：** 设计一个支持中序遍历的逆波兰表达式树，支持解析逆波兰表达式并计算结果。

**示例：**

```python
class InfixExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 29. 设计一个支持中序遍历的前缀表达式树

**题目描述：** 设计一个支持中序遍历的前缀表达式树，支持解析前缀表达式并计算结果。

**示例：**

```python
class PrefixExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

### 30. 设计一个支持中序遍历的表达式树

**题目描述：** 设计一个支持中序遍历的表达式树，支持解析表达式并计算结果。

**示例：**

```python
class ExpressionTree:
    def __init__(self):
        self.root = Node()

    def insert(self, expr: str):
        for c in expr:
            self.root.insert(c)

    def inorder(self):
        self.root.inorder()

    def evaluate(self, expr: str) -> int:
        self.insert(expr)
        return self.root.evaluate()

class Node:
    def __init__(self):
        self.children = defaultdict(Node)
        self.val = None

    def insert(self, c: str):
        if c.isdigit():
            self.val = int(c)
        else:
            self.children[c] = Node()
        return self.children[c]

    def inorder(self):
        for c in sorted(self.children):
            if self.children[c].val is not None:
                print(self.children[c].val, end=" ")
                self.children[c].inorder()
            else:
                self.children[c].inorder()

    def evaluate(self) -> int:
        if self.val is not None:
            return self.val
        left, right = self.children['('].evaluate(), self.children[')'].evaluate()
        if self.val == '+':
            return left + right
        elif self.val == '-':
            return left - right
        elif self.val == '*':
            return left * right
        elif self.val == '/':
            return left // right
```

**解析：** 使用哈希表实现树的每个节点，并支持中序遍历和计算结果。

