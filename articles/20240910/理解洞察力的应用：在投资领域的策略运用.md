                 

### 理解洞察力的应用：在投资领域的策略运用

#### 高频面试题和算法编程题库

##### 1. 股票买卖的最佳时机

**题目：** 给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格。设计一个算法来找出最大利润。你可以尽可能地完成更多的交易（多次买卖一辆车）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        low = prices[0]
        max_profit = 0
        for price in prices:
            low = min(low, price)
            profit = price - low
            max_profit = max(max_profit, profit)
        return max_profit
```

**解析：** 该算法通过遍历数组，记录当前最低价格和最大利润。每次更新最低价格，然后计算利润，更新最大利润。

##### 2. 股票价格的最高价格 II

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 是第 `i` 天的股票价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一辆车），但是你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]
        return profit
```

**解析：** 该算法通过遍历数组，记录当前价格和前一天价格的差值。如果差值为正，则将其累加到总利润中。

##### 3. 股票价格波动

**题目：** 给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格。设计一个算法来找到最大的利润，在购买和卖出一支股票之后，再购买该股票。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        profit = max(0, prices[1] - prices[0])
        min_price = prices[0]
        for price in prices[1:]:
            profit = max(profit, price - min_price)
            min_price = min(min_price, price - profit)
        return profit
```

**解析：** 该算法通过遍历数组，记录当前最低价格和最大利润。每次更新最低价格和最大利润，计算两次购买和卖出的最大利润。

##### 4. 买卖股票的最佳时机 IV

**题目：** 给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格。设计一个算法来计算你最大利润。你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices or k == 0:
            return 0
        n = len(prices)
        dp = [[0] * 2 for _ in range(k+1)]
        for i in range(1, k+1):
            max_diff = -prices[0]
            for j in range(1, n):
                dp[i][0] = max(dp[i][0], dp[i-1][1] + prices[j])
                dp[i][1] = max(dp[i][1], dp[i-1][0] - prices[j])
                max_diff = max(max_diff, dp[i-1][0] - prices[j])
            dp[k][0] += max_diff
        return dp[k][0]
```

**解析：** 该算法使用动态规划，记录每次交易的状态。通过计算当前交易的最大差价，更新状态。

##### 5. 最佳买卖股票时机含冷冻期

**题目：** 给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格。设计一个算法来计算最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一辆车）：卖出股票后，你无法在第二天再次购买股票（即冷冻期为 1 天）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        buy = [inf] * (n + 1)
        sell = [0] * (n + 1)
        sell[1] = -prices[0]
        for i in range(2, n + 1):
            buy[i] = min(buy[i - 1], sell[i - 2] - prices[i - 1])
            sell[i] = max(sell[i - 1], buy[i - 1] + prices[i - 1])
        return sell[n]
```

**解析：** 该算法使用动态规划，分别记录前一天买入和卖出的状态。通过更新状态，计算当前的最大利润。

##### 6. 摩天轮最低票价

**题目：** 给定一个整数数组 `rides`，其中 `rides[i] = [start[i], end[i]]` 表示第 `i` 次旅行从 `start[i]` 到 `end[i]` 。计算你从 `0` 号车站到达最后一站（`rides[-1][1]`）的最低票价。

**答案：**

```python
class Solution:
    def minMoney(self, rides: List[List[int]]) -> int:
        rides.sort()
        dp = [0] + [inf] * len(rides)
        last = 0
        for i, (start, end) in enumerate(rides):
            dp[i + 1] = min(dp[i], dp[last] + (start - last))
            last = i + 1
        return dp[-1]
```

**解析：** 该算法使用动态规划，记录到达每个车站的最低票价。通过更新状态，计算到达最后一站的最低票价。

##### 7. 判断是否为有效交易

**题目：** 给定一个整数数组 `arr`，表示某一天股票的价格。设计一个算法来判断以下规则是否成立：如果存在两个时间点 `i` 和 `j`（`i < j`），使得在时间点 `i` 购买股票，在时间点 `j` 卖出股票，则该交易是有效的。注意：在购买股票后，必须等待至少一天才能进行下一次交易。

**答案：**

```python
class Solution:
    def checkValidTransactions(self, arr: List[int]) -> List[str]:
        ans = []
        for i in range(1, len(arr)):
            if abs(arr[i - 1] - arr[i]) > 1:
                ans.append("Illegal Transaction")
            elif i > 1 and arr[i - 1] == arr[i - 2]:
                ans.append("Illegal Transaction")
            else:
                ans.append("Legal")
        return ans
```

**解析：** 该算法通过遍历数组，判断相邻两天的股票价格差是否大于 1，以及前一天的股票价格是否与当前价格相同。根据判断结果，将结果添加到答案列表中。

##### 8. 找到最大利润的一天

**题目：** 给定一个整数数组 `arr`，表示某一天股票的价格。设计一个算法来找到能够获得最大利润的那一天。如果无法获得利润，返回 `-1`。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        min_price = arr[0]
        max_profit = 0
        for price in arr:
            min_price = min(min_price, price)
            profit = price - min_price
            max_profit = max(max_profit, profit)
        return max_profit if max_profit > 0 else -1
```

**解析：** 该算法通过遍历数组，记录最低价格和最大利润。最后，判断最大利润是否大于 0，返回结果。

##### 9. 求最大连续子序列和

**题目：** 给定一个整数数组 `arr`，找到连续子序列的最大和。如果数组为空，返回 0。

**答案：**

```python
class Solution:
    def maxSubArray(self, arr: List[int]) -> int:
        max_sum = arr[0]
        current_sum = arr[0]
        for num in arr[1:]:
            current_sum = max(num, current_sum + num)
            max_sum = max(max_sum, current_sum)
        return max_sum
```

**解析：** 该算法使用动态规划，通过更新当前子序列和和最大子序列和，计算连续子序列的最大和。

##### 10. 验证买卖时机

**题目：** 给定一个整数数组 `arr`，表示某一天股票的价格。设计一个算法来验证以下规则：如果存在两个时间点 `i` 和 `j`（`i < j`），使得在时间点 `i` 购买股票，在时间点 `j` 卖出股票，则该交易是有效的。如果数组为空，返回 `False`。

**答案：**

```python
class Solution:
    def checkValidity(self, arr: List[int]) -> bool:
        for i in range(1, len(arr)):
            if arr[i] > arr[i - 1]:
                return True
        return False
```

**解析：** 该算法通过遍历数组，判断相邻两天的股票价格差是否大于 0。如果存在大于 0 的情况，返回 `True`，否则返回 `False`。

##### 11. 贪心算法求最大利润

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个贪心算法来计算最大利润。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        profit = 0
        for i in range(1, len(arr)):
            if arr[i] > arr[i - 1]:
                profit += arr[i] - arr[i - 1]
        return profit
```

**解析：** 该算法通过遍历数组，判断相邻两天的股票价格差是否大于 0。如果大于 0，则将其累加到总利润中。

##### 12. 动态规划求解最大利润

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个动态规划算法来计算最大利润。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        n = len(arr)
        buy = [-arr[0]]
        sell = [0]
        for i in range(1, n):
            buy.append(min(buy[-1], sell[-1] - arr[i]))
            sell.append(max(sell[-1], buy[-1] + arr[i]))
        return sell[-1]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 13. 模拟买卖股票

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个模拟买卖股票的算法，计算最大利润。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        profit = 0
        for i in range(1, len(arr)):
            if arr[i] > arr[i - 1]:
                profit += arr[i] - arr[i - 1]
        return profit
```

**解析：** 该算法通过遍历数组，计算相邻两天的股票价格差值。如果差值为正，则将其累加到总利润中。

##### 14. 股票买卖的最佳时机 III

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        k = 2
        n = len(arr)
        dp = [[0] * 3 for _ in range(n)]
        dp[0][1] = -arr[0]
        dp[0][2] = -arr[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] + arr[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - arr[i])
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + arr[i])
        return dp[n - 1][0]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 15. 股票买卖的最佳时机 IV

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        k = len(arr) // 2
        n = len(arr)
        dp = [[0] * 3 for _ in range(n)]
        dp[0][1] = -arr[0]
        dp[0][2] = -arr[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][2] + arr[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - arr[i])
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + arr[i])
        return dp[n - 1][0]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 16. 股票买卖的最佳时机 V

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票，但必须保证卖出后才能买入。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        buy1, buy2, sell1, sell2 = -arr[0], -arr[0], 0, 0
        for price in arr[1:]:
            buy1 = max(buy1, sell2 - price)
            buy2 = max(buy2, sell1 - price)
            sell1 = max(sell1, buy1 + price)
            sell2 = max(sell2, buy2 + price)
        return sell2
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 17. 股票买卖的最佳时机 VI

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票，但必须保证卖出后才能买入。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        k = len(arr) // 2
        n = len(arr)
        dp = [[0] * (k + 1) for _ in range(n)]
        dp[0][0] = 0
        dp[0][1] = -arr[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + arr[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - arr[i])
            for j in range(2, k + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + arr[i])
        return dp[n - 1][k]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 18. 股票买卖的最佳时机 VII

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票，但必须保证卖出后才能买入。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        k = len(arr) // 2
        n = len(arr)
        dp = [[0] * (k + 1) for _ in range(n)]
        dp[0][0] = 0
        dp[0][1] = -arr[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + arr[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - arr[i])
            for j in range(2, k + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + arr[i])
        return dp[n - 1][k]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 19. 股票买卖的最佳时机 VIII

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票，但必须保证卖出后才能买入。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        k = len(arr) // 2
        n = len(arr)
        dp = [[0] * (k + 1) for _ in range(n)]
        dp[0][0] = 0
        dp[0][1] = -arr[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + arr[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - arr[i])
            for j in range(2, k + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + arr[i])
        return dp[n - 1][k]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

##### 20. 股票买卖的最佳时机 IX

**题目：** 给定一个整数数组 `arr`，其中 `arr[i]` 表示第 `i` 天的股票价格。设计一个算法来计算最大利润。假设你在每一天都可以买入和卖出一次股票，但必须保证卖出后才能买入。

**答案：**

```python
class Solution:
    def maxProfit(self, arr: List[int]) -> int:
        if not arr:
            return 0
        k = len(arr) // 2
        n = len(arr)
        dp = [[0] * (k + 1) for _ in range(n)]
        dp[0][0] = 0
        dp[0][1] = -arr[0]
        for i in range(1, n):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + arr[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - arr[i])
            for j in range(2, k + 1):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + arr[i])
        return dp[n - 1][k]
```

**解析：** 该算法使用动态规划，记录前一天的买入和卖出状态。通过更新状态，计算当前的最大利润。

