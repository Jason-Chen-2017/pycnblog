                 

### 2025年网易校招算法面试题库及答案

#### 1. 最长公共前缀

**题目：** 找出字符串数组中的最长公共前缀。

**示例：**  
输入：`["apple", "application", "app"]`  
输出：`"app"`

**解答：**

Python 代码：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if not s.startswith(prefix):
                return prefix
        prefix += c
    return prefix

strs = ["apple", "application", "app"]
print(longest_common_prefix(strs))  # 输出：'app'
```

#### 2. 两数相加

**题目：** 不使用 + 或 - 运算符，实现两个整数的加法。

**示例：**  
输入：`2, 3`  
输出：`5`

**解答：**

Python 代码：

```python
def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

l1 = ListNode(2)
l1.next = ListNode(4)
l1.next.next = ListNode(3)
l2 = ListNode(5)
l2.next = ListNode(6)
l2.next.next = ListNode(4)

result = add_two_numbers(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
```

#### 3. 二进制求和

**题目：** 给你两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**  
输入：`a = "1010", b = "1011"`  
输出：`"10101"`

**解答：**

Python 代码：

```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        carry, ans = 0, []
        i, j = len(a) - 1, len(b) - 1

        while i >= 0 or j >= 0 or carry:
            x = ord(a[i]) - ord('0') if i >= 0 else 0
            y = ord(b[j]) - ord('0') if j >= 0 else 0
            carry, bit = divmod(x + y + carry, 2)
            ans.append(str(bit))

        return ''.join(ans[::-1])
```

#### 4. 有效的括号

**题目：** 给定一个字符串，验证它是否是有效的括号组合。

**示例：**  
输入：`"()"`  
输出：`True`

**解答：**

Python 代码：

```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for c in s:
        if c in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[c] != top_element:
                return False
        else:
            stack.append(c)

    return not stack

s = "()"
print(isValid(s))  # 输出：True
```

#### 5. 最长回文子串

**题目：** 给你一个字符串，找出最长的回文子串。

**示例：**  
输入：`"babad"`  
输出：`"bab"`

**解答：**

Python 代码：

```python
def longest_palindrome(s):
    if not s:
        return ""

    start, max_len = 0, 1

    for i in range(len(s)):
        len1 = expand_around_center(s, i, i)
        len2 = expand_around_center(s, i, i + 1)
        len = max(len1, len2)
        if len > max_len:
            start = i - ((len - 1) // 2)
            max_len = len

    return s[start:start + max_len]

def expand_around_center(s, left, right):
    L, R = left, right
    while L >= 0 and R < len(s) and s[L] == s[R]:
        L -= 1
        R += 1
    return R - L - 1

s = "babad"
print(longest_palindrome(s))  # 输出："bab"
```

#### 6. 旋转图像

**题目：** 给定一个 n × n 的二维矩阵表示一个图像，旋转 90 度，如何将图像在原地旋转？

**示例：**  
输入：`[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`  
输出：`[[7, 4, 1], [8, 5, 2], [9, 6, 3]]`

**解答：**

Python 代码：

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
rotate(matrix)
for row in matrix:
    print(row)
```

#### 7. 三数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你找出并返回三个数的和与 `target` 相等的最小非空数组，如果不存在，返回 `[]`。

**示例：**  
输入：`nums = [-1, 0, 1, 2, -1, -4], target = 0`  
输出：`[-1, 0, 1]`

**解答：**

Python 代码：

```python
def threeSum(nums, target):
    nums.sort()
    ans = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                ans.append([nums[i], nums[left], nums[right]])
                left += 1
                right -= 1
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1

    return ans

nums = [-1, 0, 1, 2, -1, -4]
target = 0
print(threeSum(nums, target))
```

#### 8. 最长公共子序列

**题目：** 给定两个字符串，找出最长的公共子序列。

**示例：**  
输入：`text1 = "ABCD", text2 = "ACDF"`  
输出：`"ACD"`

**解答：**

Python 代码：

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    result = []
    i, j = m, n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            result.append(text1[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return ''.join(result[::-1])

text1 = "ABCD"
text2 = "ACDF"
print(longest_common_subsequence(text1, text2))
```

#### 9. 有效的数字

**题目：** 判断字符串是否表示一个有效的数字。

**示例：**  
输入："123.456e-78"  
输出：`True`

**解答：**

Python 代码：

```python
def is_number(s):
    s = s.strip()
    if not s:
        return False

    dot_count = 0
    exp_count = 0
    start, end = 0, len(s) - 1

    while end >= 0 and not s[end].isdigit():
        if s[end] == 'e' or s[end] == 'E':
            if exp_count > 0:
                return False
            exp_count += 1
            end -= 1
        elif s[end] == '.':
            if dot_count > 0:
                return False
            dot_count += 1
            end -= 1
        else:
            break

    if end < 0:
        return False

    while start < len(s) and not s[start].isdigit():
        start += 1

    if start == len(s):
        return False

    if exp_count > 0:
        if start == len(s):
            return False
        start += 1
        while start < len(s) and not s[start].isdigit():
            if s[start] == '.' or s[start] == 'e' or s[start] == 'E':
                return False
            start += 1

    return True

s = "123.456e-78"
print(is_number(s))  # 输出：True
```

#### 10. 二进制中1的个数

**题目：** 给定一个整数，返回其二进制表示中 1 的个数。

**示例：**  
输入：`1111`（二进制）  
输出：`4`（十进制）

**解答：**

Python 代码：

```python
def hamming_weight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

n = 0b1111
print(hamming_weight(n))  # 输出：4
```

#### 11. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。

**示例：**  
输入：`n = 3`  
输出：`3`

**解答：**

Python 代码：

```python
def climb_stairs(n):
    if n < 2:
        return n
    a, b = 1, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

n = 3
print(climb_stairs(n))  # 输出：3
```

#### 12. 罗马数字转整数

**题目：** 给定一个罗马数字，将其转换为整数。

**示例：**  
输入："III"  
输出：`3`

**解答：**

Python 代码：

```python
def roman_to_int(s):
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    result = 0
    for i in range(len(s)):
        if i > 0 and roman_map[s[i]] > roman_map[s[i - 1]]:
            result += roman_map[s[i]] - 2 * roman_map[s[i - 1]]
        else:
            result += roman_map[s[i]]

    return result

s = "III"
print(roman_to_int(s))  # 输出：3
```

#### 13. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的、有序的链表并返回。

**示例：**  
输入：`l1 = [1, 3, 5], l2 = [2, 4, 6]`  
输出：`[1, 2, 3, 4, 5, 6]`

**解答：**

Python 代码：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while list1 and list2:
            if list1.val < list2.val:
                curr.next = list1
                list1 = list1.next
            else:
                curr.next = list2
                list2 = list2.next
            curr = curr.next

        curr.next = list1 or list2
        return dummy.next

# 辅助函数用于创建链表
def create_linked_list(nums):
    dummy = ListNode(0)
    curr = dummy
    for num in nums:
        curr.next = ListNode(num)
        curr = curr.next
    return dummy.next

l1 = create_linked_list([1, 3, 5])
l2 = create_linked_list([2, 4, 6])
result = Solution().mergeTwoLists(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
```

#### 14. 逆波兰表达式求值

**题目：** 根据逆波兰表达式求值。有效的逆波兰表达式包含整数字、操作符 '+'、'-'、'*'、'/' 以及括号 '()'. 例如："3+2*2" = 7。

**示例：**  
输入：`["2", "1", "+", "3", "*"]`  
输出：`3`

**解答：**

Python 代码：

```python
from collections import deque

def evaluateRPN(tokens):
    stack = deque()

    for token in tokens:
        if token.isdigit():
            stack.append(int(token))
        else:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            elif token == "/":
                stack.append(a / b)

    return stack.pop()

tokens = ["2", "1", "+", "3", "*"]
print(evaluateRPN(tokens))  # 输出：3
```

#### 15. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**  
输入：`intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]`  
输出：`[[1, 6], [8, 10], [15, 18]]`

**解答：**

Python 代码：

```python
def merge(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]

    for interval in intervals[1:]:
        last = merged[-1]
        if last[1] >= interval[0]:
            merged[-1] = [last[0], max(last[1], interval[1])]
        else:
            merged.append(interval)

    return merged

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge(intervals))  # 输出：[[1, 6], [8, 10], [15, 18]]
```

#### 16. 寻找旋转排序数组中的最小值

**题目：** 给定一个旋转排序的数组，找出并返回数组中的最小元素。

**示例：**  
输入：`[3, 4, 5, 1, 2]`  
输出：`1`

**解答：**

Python 代码：

```python
def find_min(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

nums = [3, 4, 5, 1, 2]
print(find_min(nums))  # 输出：1
```

#### 17. 爬楼梯（动态规划）

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。

**示例：**  
输入：`n = 3`  
输出：`3`

**解答：**

Python 代码：

```python
def climb_stairs(n):
    if n < 2:
        return n
    a, b = 1, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

n = 3
print(climb_stairs(n))  # 输出：3
```

#### 18. 打家劫舍

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。你要制定一个只偷相邻房屋的方案来获取尽可能多的现金。

**示例：**  
输入：`[2, 7, 9, 3, 1]`  
输出：`12`

**解答：**

Python 代码：

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    return max(rob(nums[:-1]), rob(nums[:-2]) + nums[-1])

nums = [2, 7, 9, 3, 1]
print(rob(nums))  # 输出：12
```

#### 19. 盛最多水的容器

**题目：** 给定一个二叉树，请找出其中路径最长且值最大的路径。

**示例：**  
输入：`[1, 2, 3, null, 5, null, 4]`  
输出：`13`（路径为 `[2, 3, 4]`）

**解答：**

Python 代码：

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.max_sum = float('-inf')
        self.dfs(root)
        return self.max_sum

    def dfs(self, node):
        if not node:
            return 0
        left = max(0, self.dfs(node.left))
        right = max(0, self.dfs(node.right))
        self.max_sum = max(self.max_sum, left + right + node.val)
        return max(left, right) + node.val

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(5)
root.right.left = TreeNode(4)

max_path_sum = Solution().maxPathSum(root)
print(max_path_sum)  # 输出：13
```

#### 20. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个二分搜索算法找到给定的目标值。

**示例：**  
输入：`[4, 5, 6, 7, 0, 1, 2]`，目标值：`0`  
输出：`4`

**解答：**

Python 代码：

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
print(search(nums, target))  # 输出：4
```

#### 21. 删除链表的节点

**题目：** 给定一个单链表的节点，删除该节点。

**示例：**  
输入：`[4, 5, 1, 9]`，删除节点：`5`  
输出：`[4, 1, 9]`

**解答：**

Python 代码：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node):
        node.val = node.next.val
        node.next = node.next.next

# 辅助函数用于创建链表
def create_linked_list(nums):
    dummy = ListNode(0)
    curr = dummy
    for num in nums:
        curr.next = ListNode(num)
        curr = curr.next
    return dummy.next

# 辅助函数用于打印链表
def print_linked_list(head):
    while head:
        print(head.val, end=" ")
        head = head.next
    print()

nums = [4, 5, 1, 9]
head = create_linked_list(nums)
deleteNode(head, 5)
print_linked_list(head)  # 输出：4 1 9
```

#### 22. 合并两个有序链表

**题目：** 给出两个有序的链表，将它们合并为一个有序的链表。

**示例：**  
输入：`l1 = [1, 2, 4], l2 = [1, 3, 4]`  
输出：`[1, 1, 2, 3, 4, 4]`

**解答：**

Python 代码：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

# 辅助函数用于创建链表
def create_linked_list(nums):
    dummy = ListNode(0)
    curr = dummy
    for num in nums:
        curr.next = ListNode(num)
        curr = curr.next
    return dummy.next

l1 = create_linked_list([1, 2, 4])
l2 = create_linked_list([1, 3, 4])
merged_list = Solution().mergeTwoLists(l1, l2)
while merged_list:
    print(merged_list.val, end=" ")
    merged_list = merged_list.next
```

#### 23. 二进制表示中1的个数

**题目：** 给定一个整数，返回其二进制表示中 1 的个数。

**示例：**  
输入：`1111`（二进制）  
输出：`4`（十进制）

**解答：**

Python 代码：

```python
def hammingWeight(num):
    count = 0
    while num:
        count += num & 1
        num >>= 1
    return count

num = 0b1111
print(hammingWeight(num))  # 输出：4
```

#### 24. 链表反转

**题目：** 对一个链表进行反转。

**示例：**  
输入：`[1, 2, 3, 4, 5]`  
输出：`[5, 4, 3, 2, 1]`

**解答：**

Python 代码：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        curr = head
        while curr:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev

# 辅助函数用于创建链表
def create_linked_list(nums):
    dummy = ListNode(0)
    curr = dummy
    for num in nums:
        curr.next = ListNode(num)
        curr = curr.next
    return dummy.next

# 辅助函数用于打印链表
def print_linked_list(head):
    while head:
        print(head.val, end=" ")
        head = head.next
    print()

nums = [1, 2, 3, 4, 5]
head = create_linked_list(nums)
reversed_head = Solution().reverseList(head)
print_linked_list(reversed_head)  # 输出：5 4 3 2 1
```

#### 25. 最长公共前缀

**题目：** 给定一个字符串数组，找到它们的公共前缀。

**示例：**  
输入：`["flower", "flow", "flight"]`  
输出：`"fl"`

**解答：**

Python 代码：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if not s.startswith(prefix):
                return prefix
        prefix += c
    return prefix

strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # 输出："fl"
```

#### 26. 删除有序数组中的重复项

**题目：** 给定一个有序数组，删除重复项，使每个元素只出现一次，返回新的长度。

**示例：**  
输入：`[0, 0, 1, 1, 1, 2, 2, 3, 3, 4]`  
输出：`[0, 1, 2, 3, 4]，新长度为 5`

**解答：**

Python 代码：

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[slow] != nums[fast]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1

nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
new_length = removeDuplicates(nums)
print(nums[:new_length])  # 输出：[0, 1, 2, 3, 4]
```

#### 27. 罗马数字转整数

**题目：** 给定一个罗马数字，将其转换为整数。

**示例：**  
输入："III"  
输出：3

**解答：**

Python 代码：

```python
def roman_to_int(s):
    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    result = 0
    for i in range(len(s)):
        if i > 0 and roman_map[s[i]] > roman_map[s[i - 1]]:
            result += roman_map[s[i]] - 2 * roman_map[s[i - 1]]
        else:
            result += roman_map[s[i]]
    return result

s = "III"
print(roman_to_int(s))  # 输出：3
```

#### 28. 整数转罗马数字

**题目：** 给定一个整数，将其转换为罗马数字。

**示例：**  
输入：`3999`  
输出："MMMCMXCIX"

**解答：**

Python 代码：

```python
def int_to_roman(num):
    romans = ["I", "IV", "V", "IX", "X", "XL", "L", "XL", "C", "CD", "D", "CM", "M"]
    arabics = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]
    result = []
    for i in range(len(arabics)):
        count = num // arabics[i]
        result.append(romans[i] * count)
        num -= arabics[i] * count
    return ''.join(result)

num = 3999
print(int_to_roman(num))  # 输出："MMMCMXCIX"
```

#### 29. 两数相加（链表）

**题目：** 不使用 + 或 - 运算符，实现两个整数的加法。

**示例：**  
输入：`[2, 4, 3] + [5, 6, 4]`  
输出：`[7, 0, 7]`

**解答：**

Python 代码：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next

            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next

        return dummy.next

# 辅助函数用于创建链表
def create_linked_list(nums):
    dummy = ListNode(0)
    curr = dummy
    for num in nums:
        curr.next = ListNode(num)
        curr = curr.next
    return dummy.next

l1 = create_linked_list([2, 4, 3])
l2 = create_linked_list([5, 6, 4])
result = Solution().addTwoNumbers(l1, l2)
while result:
    print(result.val, end=" ")
    result = result.next
```

#### 30. 缩小范围至原数字的两倍

**题目：** 给定一个整数数组，你需要缩小范围至原数字的两倍，要求缩小后的数字必须包含原数组中的所有元素。

**示例：**  
输入：`[1, 2, 3]`  
输出：`[1, 2]`

**解答：**

Python 代码：

```python
def shrink_range(nums):
    if not nums:
        return []

    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > 2 * nums[left]:
            right = mid
        else:
            left = mid + 1

    return nums[left:]

nums = [1, 2, 3]
print(shrink_range(nums))  # 输出：[1, 2]
```

