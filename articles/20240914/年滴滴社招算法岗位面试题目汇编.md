                 

### 2025年滴滴社招算法岗位面试题目汇编

#### 面试题 1：排序算法

**题目：** 实现一个快速排序算法，并分析其时间复杂度和空间复杂度。

**答案：**

快速排序（Quick Sort）是一种分治策略的排序算法。以下是快速排序的实现：

```go
package main

import "fmt"

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    n := len(arr)
    quickSort(arr, 0, n-1)
    fmt.Println(arr)
}
```

**解析：** 快速排序的平均时间复杂度为 \(O(n \log n)\)，最坏情况下的时间复杂度为 \(O(n^2)\)。空间复杂度为 \(O(\log n)\)，因为它使用了递归栈。

#### 面试题 2：二分查找

**题目：** 实现一个二分查找算法，并分析其时间复杂度。

**答案：**

二分查找算法在有序数组中查找目标元素。以下是二分查找的实现：

```go
package main

import "fmt"

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    target := 7
    result := binarySearch(arr, target)
    if result != -1 {
        fmt.Printf("元素 %d 在数组中的索引为 %d\n", target, result)
    } else {
        fmt.Printf("元素 %d 不在数组中\n", target)
    }
}
```

**解析：** 二分查找的时间复杂度为 \(O(\log n)\)，因为它每次都能将搜索范围缩小一半。

#### 面试题 3：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

可以使用动态规划求解最长公共子序列问题。以下是实现的代码：

```go
package main

import "fmt"

func longestCommonSubsequence(text1, text2 string) string {
    dp := make([][]int, len(text1)+1)
    for i := range dp {
        dp[i] = make([]int, len(text2)+1)
    }

    for i := 1; i <= len(text1); i++ {
        for j := 1; j <= len(text2); j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    result := ""
    i, j := len(text1), len(text2)
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            result = string(text1[i-1]) + result
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCDGH"
    text2 := "AEDFHR"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("最长公共子序列：", result)
}
```

**解析：** 动态规划的时间复杂度为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别是两个字符串的长度。

#### 面试题 4：合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**答案：**

首先对区间进行排序，然后遍历排序后的区间，合并重叠的区间。以下是实现的代码：

```go
package main

import (
    "fmt"
    "sort"
)

type Interval struct {
    Start, End int
}

func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })

    var result []Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := []Interval{
        {1, 3},
        {2, 6},
        {8, 10},
        {15, 18},
    }
    result := merge(intervals)
    fmt.Println("合并后的区间：", result)
}
```

**解析：** 合并区间的时间复杂度为 \(O(n \log n)\)，因为需要对区间进行排序，其中 \(n\) 是区间的数量。

#### 面试题 5：环形房屋粉刷

**题目：** 给定一个环形房屋，需要粉刷房屋的外部和内部，每种颜色的油漆都有一定的数量，求最小油漆使用量。

**答案：**

首先计算房屋外部需要粉刷的长度，然后计算内部每个房间需要粉刷的长度，并找出最小的油漆使用量。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func minCost(cycles []int, cost []int) int {
    n := len(cycles)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= n; i++ {
        dp[i][0] = dp[i-1][1] + cost[i-1]
        dp[i][1] = dp[i-1][0]
        for j := 2; j <= n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + cost[i-1]
        }
    }

    return dp[n][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    cycles := []int{1, 2, 3, 4, 5}
    cost := []int{3, 4, 6, 7, 8}
    result := minCost(cycles, cost)
    fmt.Println("最小油漆使用量：", result)
}
```

**解析：** 环形房屋粉刷的时间复杂度为 \(O(n^2)\)，其中 \(n\) 是房屋的数量。

#### 面试题 6：文本整洁化

**题目：** 给定一个字符串，将字符串中的空格、逗号和句号替换为空格，并移除重复的空格和标点符号。

**答案：**

使用双指针技术，遍历字符串并替换空格、逗号和句号为空格，并移除重复的空格和标点符号。以下是实现的代码：

```go
package main

import (
    "fmt"
    "strings"
)

func cleanText(s string) string {
    var result []rune
    prev := ' '
    for _, c := range s {
        if c == ' ' || c == ',' || c == '.' {
            if c != ' ' && prev != ' ' {
                result = append(result, ' ')
            }
        } else {
            result = append(result, c)
        }
        prev = c
    }
    return string(result)
}

func main() {
    s := "Hello,  Hello,   World."
    result := cleanText(s)
    fmt.Println("整洁化文本：", result)
}
```

**解析：** 文本整洁化的时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串的长度。

#### 面试题 7：最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长的公共前缀。

**答案：**

从第一个字符串开始，逐个比较其他字符串的前缀，直到找到第一个不同的字符。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, c := 0, strs[0][0]; i < len(strs[0]); i++ {
        for _, str := range strs[1:] {
            if i >= len(str) || str[i] != c {
                return strs[0][:i]
            }
            c = str[i]
        }
    }
    return strs[0]
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("最长公共前缀：", result)
}
```

**解析：** 最长公共前缀的时间复杂度为 \(O(n \times m)\)，其中 \(n\) 是字符串数组中的字符串数量，\(m\) 是最短字符串的长度。

#### 面试题 8：两个链表的第一个公共节点

**题目：** 给定两个单链表，找出它们的第一个公共节点。

**答案：**

使用两个指针分别遍历两个链表，第一个公共节点即为两个指针相遇的节点。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func getIntersectionNode(headA, headB *ListNode) *ListNode {
    pA, pB := headA, headB
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    return pA
}

func main() {
    // 构建两个链表
    // 示例：
    // A: 1 → 2 → 3
    // B: 2 → 3 → 4
    listA := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: nil}}}
    listB := &ListNode{Val: 2, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4, Next: nil}}}
    intersectionNode := getIntersectionNode(listA, listB)
    if intersectionNode != nil {
        fmt.Println("第一个公共节点：", intersectionNode.Val)
    } else {
        fmt.Println("两个链表没有公共节点")
    }
}
```

**解析：** 两个链表的第一个公共节点的时间复杂度为 \(O(n + m)\)，其中 \(n\) 和 \(m\) 分别是两个链表的长度。

#### 面试题 9：最小栈

**题目：** 设计一个最小栈，支持 push、pop 和 getMin 操作。

**答案：**

使用两个栈，一个用于存储栈元素，另一个用于存储当前栈中的最小值。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type MinStack struct {
    stack  []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack:   []int{},
        minStack: []int{int(^uint(0) >> 1)},
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if val < this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    } else {
        this.minStack = append(this.minStack, this.minStack[len(this.minStack)-1])
    }
}

func (this *MinStack) Pop() {
    this.stack = this.stack[:len(this.stack)-1]
    this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}

func main() {
    minStack := Constructor()
    minStack.Push(2)
    minStack.Push(4)
    minStack.Push(3)
    fmt.Println("栈顶元素：", minStack.Top())
    fmt.Println("当前最小值：", minStack.GetMin())
    minStack.Pop()
    fmt.Println("栈顶元素：", minStack.Top())
    fmt.Println("当前最小值：", minStack.GetMin())
}
```

**解析：** 最小栈的时间复杂度为 \(O(1)\)，因为每个操作都只涉及到栈顶元素。

#### 面试题 10：LRU缓存

**题目：** 实现一个LRU（Least Recently Used）缓存。

**答案：**

使用哈希表和双向链表实现LRU缓存。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type LRUCache struct {
    capacity int
    cache    map[int]*DList.Node
    head, tail *DList.Node
}

type DList struct {
    head, tail *Node
}

type Node struct {
    key   int
    value int
    next  *Node
    prev  *Node
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*Node),
        head:     &Node{},
        tail:     &Node{},
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (this *LRUCache) Get(key int) int {
    if node, exist := this.cache[key]; exist {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, exist := this.cache[key]; exist {
        node.value = value
        this.moveToHead(node)
    } else {
        if len(this.cache) == this.capacity {
            removeNode(this.tail.prev)
            delete this.cache[this.tail.prev.key]
        }
        newNode := &Node{key: key, value: value}
        this.cache[key] = newNode
        this.addToHead(newNode)
    }
}

func (this *LRUCache) moveToHead(node *Node) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) addToHead(node *Node) {
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
    node.prev = this.head
}

func (this *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func main() {
    lruCache := Constructor(2)
    lruCache.Put(1, 1)
    lruCache.Put(2, 2)
    fmt.Println(lruCache.Get(1))  // 输出 1
    lruCache.Put(3, 3)
    fmt.Println(lruCache.Get(2))  // 输出 -1（因为 2 被移除）
    lruCache.Put(4, 4)
    fmt.Println(lruCache.Get(1))  // 输出 -1
    fmt.Println(lruCache.Get(3))  // 输出 3
    fmt.Println(lruCache.Get(4))  // 输出 4
}
```

**解析：** LRU缓存的时间复杂度为 \(O(1)\)，因为添加、获取和删除操作都可以在常数时间内完成。

#### 面试题 11：二叉树的深度

**题目：** 计算二叉树的深度。

**答案：**

使用递归遍历二叉树，计算每个节点的深度，并返回最大深度。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1
}

func main() {
    root := &TreeNode{Val: 3, Left: &TreeNode{Val: 9, Right: &TreeNode{Val: 20, Left: &TreeNode{Val: 15}, Right: &TreeNode{Val: 18}}}, Right: &TreeNode{Val: 5}}
    result := maxDepth(root)
    fmt.Println("二叉树的深度：", result)
}
```

**解析：** 计算二叉树的深度的时间复杂度为 \(O(n)\)，其中 \(n\) 是二叉树的节点数量。

#### 面试题 12：二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树和一个目标值，找到树中值等于目标值的节点。

**答案：**

由于二叉搜索树的特点是左子树的所有节点值小于根节点值，右子树的所有节点值大于根节点值，因此可以直接使用二分搜索的方法。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }
    if val < root.Val {
        return searchBST(root.Left, val)
    }
    return searchBST(root.Right, val)
}

func main() {
    root := &TreeNode{Val: 5, Left: &TreeNode{Val: 3, Left: &TreeNode{Val: 2}, Right: &TreeNode{Val: 4}}, Right: &TreeNode{Val: 7, Left: &TreeNode{Val: 6}, Right: &TreeNode{Val: 8}}}
    target := 6
    result := searchBST(root, target)
    if result != nil {
        fmt.Println("找到节点值：", result.Val)
    } else {
        fmt.Println("未找到节点值")
    }
}
```

**解析：** 在二叉搜索树中搜索的时间复杂度为 \(O(\log n)\)，其中 \(n\) 是二叉搜索树的节点数量。

#### 面试题 13：路径总和

**题目：** 给定一个二叉树和一个目标值，找出所有路径总和等于给定值的路径。

**答案：**

使用递归遍历二叉树，对于每个节点，检查从根节点到当前节点的路径总和是否等于目标值。如果相等，将该路径添加到结果中。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func pathSum(root *TreeNode, targetSum int) [][]int {
    var paths [][]int
    var dfs func(node *TreeNode, currentPath []int, currentSum int)
    dfs = func(node *TreeNode, currentPath []int, currentSum int) {
        if node == nil {
            return
        }
        currentSum += node.Val
        currentPath = append(currentPath, node.Val)
        if len(currentPath) > 1 && currentSum == targetSum {
            paths = append(paths, append([]int{}, currentPath...))
        }
        dfs(node.Left, currentPath, currentSum)
        dfs(node.Right, currentPath, currentSum)
        currentPath = currentPath[:len(currentPath)-1]
    }
    dfs(root, []int{}, 0)
    return paths
}

func main() {
    root := &TreeNode{Val: 10, Left: &TreeNode{Val: 5, Left: &TreeNode{Val: 3}, Right: &TreeNode{Val: 7}}, Right: &TreeNode{Val: -3, Right: &TreeNode{Val: 11}}}
    targetSum := 8
    result := pathSum(root, targetSum)
    for _, path := range result {
        fmt.Println(path)
    }
}
```

**解析：** 路径总和的时间复杂度为 \(O(n)\)，其中 \(n\) 是二叉树的节点数量。

#### 面试题 14：合并两个有序链表

**题目：** 合并两个有序链表。

**答案：**

创建一个新的链表，然后遍历两个链表，将较小的节点添加到新链表中。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

func main() {
    l1 := &ListNode{Val: 1, Next: &ListNode{Val: 2, Next: &ListNode{Val: 4}}}
    l2 := &ListNode{Val: 1, Next: &ListNode{Val: 3, Next: &ListNode{Val: 4}}}
    result := mergeTwoLists(l1, l2)
    for result != nil {
        fmt.Println(result.Val)
        result = result.Next
    }
}
```

**解析：** 合并两个有序链表的时间复杂度为 \(O(n + m)\)，其中 \(n\) 和 \(m\) 分别是两个链表的长度。

#### 面试题 15：字符串转换整数

**题目：** 实现字符串转换整数的函数，处理溢出和非法输入。

**答案：**

首先处理字符串的前导空格，然后根据字符串的第一个字符判断是正数还是负数，或者是否是非法输入。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func myAtoi(s string) int {
    const INT_MAX = 2147483647
    const INT_MIN = -2147483648
    i := 0
    sign := 1
    result := 0

    // 跳过前导空格
    for i < len(s) && s[i] == ' ' {
        i++
    }

    // 处理符号
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        sign = 1 - 2 * (s[i] == '-')
        i++
    }

    // 计算数值
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        digit := int(s[i] - '0')
        if result > (INT_MAX - digit)/10 {
            return INT_MAX
        }
        if result < (INT_MIN + digit)/10 && sign == 1 {
            return INT_MIN
        }
        result = result*10 + digit
        i++
    }

    return result * sign
}

func main() {
    s := "   -42"
    result := myAtoi(s)
    fmt.Println("转换后的整数：", result)
}
```

**解析：** 字符串转换整数的时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串的长度。

#### 面试题 16：最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长的公共前缀。

**答案：**

从第一个字符串开始，逐个比较其他字符串的前缀，直到找到第一个不同的字符。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, s := range strs[1:] {
        for i, r := range s {
            if i >= len(prefix) || r != prefix[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("最长公共前缀：", result)
}
```

**解析：** 最长公共前缀的时间复杂度为 \(O(n \times m)\)，其中 \(n\) 是字符串数组中的字符串数量，\(m\) 是最短字符串的长度。

#### 面试题 17：反转整数

**题目：** 实现一个函数，将整数反转。

**答案：**

不断将整数的最后一位加到结果上，同时更新整数，直到整数变为零。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func reverse(x int) int {
    const INT_MAX = 2147483647
    const INT_MIN = -2147483648
    result := 0
    for x != 0 {
        digit := x % 10
        if result > (INT_MAX - digit)/10 || result < (INT_MIN + digit)/10 {
            return 0
        }
        result = result*10 + digit
        x /= 10
    }
    return result
}

func main() {
    x := 123
    result := reverse(x)
    fmt.Println("反转后的整数：", result)
}
```

**解析：** 反转整数的时间复杂度为 \(O(\log n)\)，其中 \(n\) 是整数的位数。

#### 面试题 18：删除链表的节点

**题目：** 删除链表中的节点。

**答案：**

将当前节点的值设置为下一节点的值，然后将当前节点的下一节点指向下一节点的下一节点，最后删除下一节点。以下是实现的代码：

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}

func main() {
    node1 := &ListNode{Val: 1}
    node2 := &ListNode{Val: 2}
    node3 := &ListNode{Val: 3}
    node1.Next = node2
    node2.Next = node3
    deleteNode(node2)
    for node := node1; node != nil; node = node.Next {
        fmt.Println(node.Val)
    }
}
```

**解析：** 删除链表节点的时间复杂度为 \(O(1)\)，因为只需要对当前节点进行常数时间的操作。

#### 面试题 19：爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶？

**答案：**

使用动态规划求解。定义 dp[i] 为到达第 i 阶台阶的方法数，则 dp[i] = dp[i-1] + dp[i-2]。初始条件为 dp[0] = 1，dp[1] = 1。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 1, 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}

func main() {
    n := 3
    result := climbStairs(n)
    fmt.Println("爬楼梯的方法数：", result)
}
```

**解析：** 爬楼梯的时间复杂度为 \(O(n)\)，空间复杂度也为 \(O(n)\)。

#### 面试题 20：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

使用动态规划求解。定义 dp[i][j] 为字符串 text1 的前 i 个字符和字符串 text2 的前 j 个字符的最长公共子序列的长度。状态转移方程为：

- 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1；
- 如果 text1[i-1] != text2[j-1]，则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。

以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("最长公共子序列长度：", result)
}
```

**解析：** 最长公共子序列的时间复杂度为 \(O(m \times n)\)，空间复杂度也为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别是两个字符串的长度。

#### 面试题 21：最长连续序列

**题目：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**答案：**

使用哈希表记录数组中每个数字出现的次数，然后遍历数组，对于每个数字，如果它前面已经出现过了，则更新当前最长连续序列的长度；如果它后面还有数字出现，则继续遍历。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    maxLen := 1
    for num := range numSet {
        if !numSet[num-1] {
            currNum := num
            currLen := 1
            for numSet[currNum+1] {
                currNum++
                currLen++
            }
            maxLen = max(maxLen, currLen)
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{100, 4, 200, 1, 3, 2}
    result := longestConsecutive(nums)
    fmt.Println("最长连续序列长度：", result)
}
```

**解析：** 最长连续序列的时间复杂度为 \(O(n)\)，空间复杂度也为 \(O(n)\)，其中 \(n\) 是数组中数字的数量。

#### 面试题 22：环形房屋粉刷

**题目：** 给定一个环形房屋，需要粉刷房屋的外部和内部，每种颜色的油漆都有一定的数量，求最小油漆使用量。

**答案：**

首先计算房屋外部需要粉刷的长度，然后计算内部每个房间需要粉刷的长度，并找出最小的油漆使用量。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func minCost(cycles []int, cost []int) int {
    n := len(cycles)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= n; i++ {
        dp[i][0] = dp[i-1][1] + cost[i-1]
        dp[i][1] = dp[i-1][0]
        for j := 2; j <= n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + cost[i-1]
        }
    }

    return dp[n][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    cycles := []int{1, 2, 3, 4, 5}
    cost := []int{3, 4, 6, 7, 8}
    result := minCost(cycles, cost)
    fmt.Println("最小油漆使用量：", result)
}
```

**解析：** 环形房屋粉刷的时间复杂度为 \(O(n^2)\)，其中 \(n\) 是房屋的数量。

#### 面试题 23：字符串转换整数

**题目：** 实现字符串转换整数的函数，处理溢出和非法输入。

**答案：**

首先处理字符串的前导空格，然后根据字符串的第一个字符判断是正数还是负数，或者是否是非法输入。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func myAtoi(s string) int {
    const INT_MAX = 2147483647
    const INT_MIN = -2147483648
    i := 0
    sign := 1
    result := 0

    // 跳过前导空格
    for i < len(s) && s[i] == ' ' {
        i++
    }

    // 处理符号
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        sign = 1 - 2 * (s[i] == '-')
        i++
    }

    // 计算数值
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        digit := int(s[i] - '0')
        if result > (INT_MAX - digit)/10 {
            return INT_MAX
        }
        if result < (INT_MIN + digit)/10 && sign == 1 {
            return INT_MIN
        }
        result = result*10 + digit
        i++
    }

    return result * sign
}

func main() {
    s := "   -42"
    result := myAtoi(s)
    fmt.Println("转换后的整数：", result)
}
```

**解析：** 字符串转换整数的时间复杂度为 \(O(n)\)，其中 \(n\) 是字符串的长度。

#### 面试题 24：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

使用动态规划求解。定义 dp[i][j] 为字符串 text1 的前 i 个字符和字符串 text2 的前 j 个字符的最长公共子序列的长度。状态转移方程为：

- 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1；
- 如果 text1[i-1] != text2[j-1]，则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。

以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("最长公共子序列长度：", result)
}
```

**解析：** 最长公共子序列的时间复杂度为 \(O(m \times n)\)，空间复杂度也为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别是两个字符串的长度。

#### 面试题 25：最长连续序列

**题目：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**答案：**

使用哈希表记录数组中每个数字出现的次数，然后遍历数组，对于每个数字，如果它前面已经出现过了，则更新当前最长连续序列的长度；如果它后面还有数字出现，则继续遍历。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    maxLen := 1
    for num := range numSet {
        if !numSet[num-1] {
            currNum := num
            currLen := 1
            for numSet[currNum+1] {
                currNum++
                currLen++
            }
            maxLen = max(maxLen, currLen)
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{100, 4, 200, 1, 3, 2}
    result := longestConsecutive(nums)
    fmt.Println("最长连续序列长度：", result)
}
```

**解析：** 最长连续序列的时间复杂度为 \(O(n)\)，空间复杂度也为 \(O(n)\)，其中 \(n\) 是数组中数字的数量。

#### 面试题 26：环形房屋粉刷

**题目：** 给定一个环形房屋，需要粉刷房屋的外部和内部，每种颜色的油漆都有一定的数量，求最小油漆使用量。

**答案：**

首先计算房屋外部需要粉刷的长度，然后计算内部每个房间需要粉刷的长度，并找出最小的油漆使用量。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func minCost(cycles []int, cost []int) int {
    n := len(cycles)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= n; i++ {
        dp[i][0] = dp[i-1][1] + cost[i-1]
        dp[i][1] = dp[i-1][0]
        for j := 2; j <= n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + cost[i-1]
        }
    }

    return dp[n][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    cycles := []int{1, 2, 3, 4, 5}
    cost := []int{3, 4, 6, 7, 8}
    result := minCost(cycles, cost)
    fmt.Println("最小油漆使用量：", result)
}
```

**解析：** 环形房屋粉刷的时间复杂度为 \(O(n^2)\)，其中 \(n\) 是房屋的数量。

#### 面试题 27：最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长的公共前缀。

**答案：**

从第一个字符串开始，逐个比较其他字符串的前缀，直到找到第一个不同的字符。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for _, s := range strs[1:] {
        for i, r := range s {
            if i >= len(prefix) || r != prefix[i] {
                prefix = prefix[:i]
                break
            }
        }
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    result := longestCommonPrefix(strs)
    fmt.Println("最长公共前缀：", result)
}
```

**解析：** 最长公共前缀的时间复杂度为 \(O(n \times m)\)，其中 \(n\) 是字符串数组中的字符串数量，\(m\) 是最短字符串的长度。

#### 面试题 28：最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

使用动态规划求解。定义 dp[i][j] 为字符串 text1 的前 i 个字符和字符串 text2 的前 j 个字符的最长公共子序列的长度。状态转移方程为：

- 如果 text1[i-1] == text2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1；
- 如果 text1[i-1] != text2[j-1]，则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。

以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCD"
    text2 := "ACDF"
    result := longestCommonSubsequence(text1, text2)
    fmt.Println("最长公共子序列长度：", result)
}
```

**解析：** 最长公共子序列的时间复杂度为 \(O(m \times n)\)，空间复杂度也为 \(O(m \times n)\)，其中 \(m\) 和 \(n\) 分别是两个字符串的长度。

#### 面试题 29：最长连续序列

**题目：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**答案：**

使用哈希表记录数组中每个数字出现的次数，然后遍历数组，对于每个数字，如果它前面已经出现过了，则更新当前最长连续序列的长度；如果它后面还有数字出现，则继续遍历。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    maxLen := 1
    for num := range numSet {
        if !numSet[num-1] {
            currNum := num
            currLen := 1
            for numSet[currNum+1] {
                currNum++
                currLen++
            }
            maxLen = max(maxLen, currLen)
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{100, 4, 200, 1, 3, 2}
    result := longestConsecutive(nums)
    fmt.Println("最长连续序列长度：", result)
}
```

**解析：** 最长连续序列的时间复杂度为 \(O(n)\)，空间复杂度也为 \(O(n)\)，其中 \(n\) 是数组中数字的数量。

#### 面试题 30：环形房屋粉刷

**题目：** 给定一个环形房屋，需要粉刷房屋的外部和内部，每种颜色的油漆都有一定的数量，求最小油漆使用量。

**答案：**

首先计算房屋外部需要粉刷的长度，然后计算内部每个房间需要粉刷的长度，并找出最小的油漆使用量。以下是实现的代码：

```go
package main

import (
    "fmt"
)

func minCost(cycles []int, cost []int) int {
    n := len(cycles)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= n; i++ {
        dp[i][0] = dp[i-1][1] + cost[i-1]
        dp[i][1] = dp[i-1][0]
        for j := 2; j <= n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + cost[i-1]
        }
    }

    return dp[n][n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func main() {
    cycles := []int{1, 2, 3, 4, 5}
    cost := []int{3, 4, 6, 7, 8}
    result := minCost(cycles, cost)
    fmt.Println("最小油漆使用量：", result)
}
```

**解析：** 环形房屋粉刷的时间复杂度为 \(O(n^2)\)，其中 \(n\) 是房屋的数量。

