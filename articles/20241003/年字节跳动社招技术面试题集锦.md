                 

# 2025年字节跳动社招技术面试题集锦

> **关键词：** 字节跳动、社招、技术面试、算法、前端、后端、数据库、架构设计

> **摘要：** 本文将围绕2025年字节跳动社招技术面试的各个主题，详细解析核心概念、算法原理、数学模型、项目实战和实际应用场景。旨在帮助读者全面掌握面试所需的知识和技能，为技术面试做好准备。

## 1. 背景介绍

随着互联网行业的快速发展，字节跳动作为一家知名科技公司，其社招技术面试备受关注。本文旨在总结和解析2025年字节跳动社招技术面试的主要内容和考点，为即将参加面试的候选人提供有针对性的复习和准备指导。

字节跳动社招技术面试主要涵盖以下领域：

- **算法与数据结构**：涉及常见的算法和数据结构，如排序、查找、图算法等。
- **前端技术**：涉及HTML、CSS、JavaScript、Vue、React等前端框架。
- **后端技术**：涉及Java、Python、Golang等后端开发语言，以及相关框架和中间件。
- **数据库技术**：涉及关系型数据库（如MySQL、Oracle）和非关系型数据库（如MongoDB、Redis）。
- **架构设计**：涉及系统架构、分布式系统、微服务架构等。

## 2. 核心概念与联系

为了更好地理解和掌握字节跳动社招技术面试的内容，我们需要梳理和掌握以下核心概念和它们之间的联系：

### 2.1 算法与数据结构

- **排序算法**：冒泡排序、选择排序、插入排序、快速排序、归并排序等。
- **查找算法**：二分查找、哈希查找等。
- **图算法**：深度优先搜索（DFS）、广度优先搜索（BFS）、最短路径算法（如Dijkstra算法、Floyd算法）等。

### 2.2 前端技术

- **HTML**：超文本标记语言，用于构建网页的结构。
- **CSS**：层叠样式表，用于美化网页。
- **JavaScript**：一种脚本语言，用于实现网页的交互功能。
- **Vue**：一款前端框架，用于构建用户界面。
- **React**：一款前端框架，用于构建用户界面。

### 2.3 后端技术

- **Java**：一种面向对象编程语言，广泛应用于后端开发。
- **Python**：一种解释型编程语言，具有简洁易读的特点。
- **Golang**：一种静态强类型、编译型、并发型语言，适用于高性能的后端开发。
- **框架和中间件**：如Spring Boot、Django、Flask等。

### 2.4 数据库技术

- **关系型数据库**：如MySQL、Oracle等，适用于结构化数据存储。
- **非关系型数据库**：如MongoDB、Redis等，适用于海量数据的存储和缓存。

### 2.5 架构设计

- **系统架构**：包括系统设计原则、系统模块划分、系统性能优化等。
- **分布式系统**：包括分布式存储、分布式计算、分布式一致性等。
- **微服务架构**：包括服务拆分、服务发现、服务容错等。

## 3. 核心算法原理 & 具体操作步骤

### 3.1 冒泡排序

冒泡排序是一种简单的排序算法，它重复地遍历待排序的列表，比较每对相邻的项目，并将不在顺序的项目交换过来。

**具体操作步骤：**

1. 比较相邻的元素。如果第一个比第二个大（升序排序），就交换它们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 重复步骤1~3，直到排序完成。

**时间复杂度：** O(n^2)

### 3.2 二分查找

二分查找是一种高效的查找算法，它将一个有序数组分成两部分，根据目标值与中间元素的关系，决定查找的区间。

**具体操作步骤：**

1. 确定中间元素：low + (high - low) / 2。
2. 比较中间元素与目标值：
   - 如果中间元素等于目标值，返回中间元素的索引。
   - 如果中间元素大于目标值，说明目标值在左半部分，令 high = mid - 1。
   - 如果中间元素小于目标值，说明目标值在右半部分，令 low = mid + 1。
3. 重复步骤1~2，直到找到目标值或low > high。

**时间复杂度：** O(log n)

## 4. 数学模型和公式 & 详细讲解 & 举例说明

### 4.1 快速排序

快速排序是一种高效的排序算法，其基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

**数学模型：**

$$
\text{QuickSort}(A, low, high) \\
\text{if } low \geq high \text{ then return } A \\
\text{pivot} = A[\text{random}(low, high)] \\
i = low \text{ and } j = high \\
\text{while } i \lt j \\
\text{while } A[i] \lt pivot \text{ and } i \lt high \\
\text{while } A[j] \gt pivot \text{ and } j \gt low \\
\text{swap } A[i] \text{ and } A[j] \\
\text{swap } A[low] \text{ and } A[j] \\
\text{QuickSort}(A, low, j-1) \\
\text{QuickSort}(A, j+1, high)
$$

**详细讲解：**

快速排序算法的关键在于选择一个基准元素（pivot），将数组分为两部分，左边的所有元素都比基准元素小，右边的所有元素都比基准元素大。然后分别对这两部分进行快速排序。

**举例说明：**

假设数组 A = [5, 2, 9, 1, 5, 6]，我们要对其进行快速排序。

1. 选择基准元素：pivot = A[random(0, 5)] = A[3] = 1。
2. 分割数组：i = 0，j = 5，i < j，执行while循环：
   - i = 0，A[i] = 5，pivot = 1，A[i] > pivot，j = 5，A[j] = 6，pivot = 1，A[j] > pivot，交换 A[i] 和 A[j]，数组变为 [5, 6, 9, 1, 5, 2]。
   - i = 0，A[i] = 5，pivot = 1，A[i] > pivot，j = 4，A[j] = 5，pivot = 1，A[j] = 5，交换 A[i] 和 A[j]，数组变为 [6, 5, 9, 1, 5, 2]。
   - i = 0，A[i] = 6，pivot = 1，A[i] > pivot，j = 3，A[j] = 9，pivot = 1，A[j] > pivot，交换 A[i] 和 A[j]，数组变为 [9, 5, 6, 1, 5, 2]。
   - i = 1，A[i] = 5，pivot = 1，A[i] > pivot，j = 2，A[j] = 2，pivot = 1，A[j] < pivot，i = i + 1。
   - i = 2，A[i] = 2，pivot = 1，A[i] < pivot，j = 2，A[j] = 2，i = i + 1。
   - i = 3，A[i] = 1，pivot = 1，A[i] < pivot，j = 1，A[j] = 5，pivot = 1，A[j] > pivot，交换 A[i] 和 A[j]，数组变为 [9, 2, 6, 1, 5, 5]。
   - i = 4，A[i] = 5，pivot = 1，A[i] > pivot，j = 0，A[j] = 5，pivot = 1，A[j] > pivot，交换 A[i] 和 A[j]，数组变为 [9, 2, 6, 1, 5, 5]。
   - i = 4，A[i] = 5，pivot = 1，A[i] > pivot，j = 4，A[j] = 5，i = i + 1。
   - i = 5，A[i] = 5，pivot = 1，A[i] > pivot，j = 3，A[j] = 9，i = i + 1。
3. 快速排序 [6, 5, 9, 1, 5, 2]，low = 0，high = 4，选择基准元素 pivot = A[random(0, 4)] = A[2] = 6，分割数组：
   - i = 0，A[i] = 6，pivot = 6，i = i + 1。
   - i = 1，A[i] = 5，pivot = 6，i = i + 1。
   - i = 2，A[i] = 9，pivot = 6，i = i + 1。
   - i = 3，A[i] = 1，pivot = 6，i = i + 1。
   - i = 4，A[i] = 5，pivot = 6，i = i + 1。
   - i = 5，A[i] = 2，pivot = 6，交换 A[i] 和 A[j]，数组变为 [6, 2, 9, 1, 5, 5]，快速排序 [2, 6, 9, 1, 5, 5]，low = 0，high = 2，选择基准元素 pivot = A[random(0, 2)] = A[0] = 2，分割数组：
     - i = 0，A[i] = 2，pivot = 2，i = i + 1。
     - i = 1，A[i] = 6，pivot = 2，交换 A[i] 和 A[j]，数组变为 [6, 2, 9, 1, 5, 5]，快速排序 [6, 2, 9, 1, 5, 5]，low = 1，high = 2，选择基准元素 pivot = A[random(1, 2)] = A[1] = 6，分割数组：
       - i = 1，A[i] = 6，pivot = 6，i = i + 1。
       - i = 2，A[i] = 9，pivot = 6，i = i + 1。
       - i = 3，A[i] = 1，pivot = 6，交换 A[i] 和 A[j]，数组变为 [6, 1, 9, 2, 5, 5]，快速排序 [6, 1, 9, 2, 5, 5]，low = 0，high = 2，选择基准元素 pivot = A[random(0, 2)] = A[0] = 6，分割数组：
         - i = 0，A[i] = 6，pivot = 6，i = i + 1。
         - i = 1，A[i] = 1，pivot = 6，交换 A[i] 和 A[j]，数组变为 [1, 6, 9, 2, 5, 5]，快速排序 [1, 6, 9, 2, 5, 5]，low = 1，high = 2，选择基准元素 pivot = A[random(1, 2)] = A[1] = 6，分割数组：
           - i = 1，A[i] = 6，pivot = 6，i = i + 1。
           - i = 2，A[i] = 9，pivot = 6，i = i + 1。
           - i = 3，A[i] = 2，pivot = 6，交换 A[i] 和 A[j]，数组变为 [1, 2, 9, 6, 5, 5]，快速排序 [1, 2, 9, 6, 5, 5]，low = 3，high = 4，选择基准元素 pivot = A[random(3, 4)] = A[3] = 9，分割数组：
             - i = 3，A[i] = 9，pivot = 9，i = i + 1。
             - i = 4，A[i] = 6，pivot = 9，交换 A[i] 和 A[j]，数组变为 [1, 2, 9, 6, 5, 9]，快速排序 [1, 2, 9, 6, 5, 9]，low = 4，high = 5，选择基准元素 pivot = A[random(4, 5)] = A[4] = 5，分割数组：
               - i = 4，A[i] = 5，pivot = 5，i = i + 1。
               - i = 5，A[i] = 9，pivot = 5，交换 A[i] 和 A[j]，数组变为 [1, 2, 9, 6, 5, 5]。
4. 快速排序 [1, 2, 9, 6, 5, 5]，low = 0，high = 2，选择基准元素 pivot = A[random(0, 2)] = A[0] = 1，分割数组：
   - i = 0，A[i] = 1，pivot = 1，i = i + 1。
   - i = 1，A[i] = 2，pivot = 1，i = i + 1。
   - i = 2，A[i] = 9，pivot = 1，交换 A[i] 和 A[j]，数组变为 [2, 1, 9, 6, 5, 5]，快速排序 [2, 1, 9, 6, 5, 5]，low = 1，high = 2，选择基准元素 pivot = A[random(1, 2)] = A[1] = 1，分割数组：
     - i = 1，A[i] = 1，pivot = 1，i = i + 1。
     - i = 2，A[i] = 9，pivot = 1，交换 A[i] 和 A[j]，数组变为 [2, 9, 1, 6, 5, 5]，快速排序 [2, 9, 1, 6, 5, 5]，low = 0，high = 2，选择基准元素 pivot = A[random(0, 2)] = A[0] = 2，分割数组：
       - i = 0，A[i] = 2，pivot = 2，i = i + 1。
       - i = 1，A[i] = 9，pivot = 2，交换 A[i] 和 A[j]，数组变为 [9, 2, 1, 6, 5, 5]，快速排序 [9, 2, 1, 6, 5, 5]，low = 1，high = 2，选择基准元素 pivot = A[random(1, 2)] = A[1] = 9，分割数组：
         - i = 1，A[i] = 9，pivot = 9，i = i + 1。
         - i = 2，A[i] = 1，pivot = 9，交换 A[i] 和 A[j]，数组变为 [9, 1, 2, 6, 5, 5]。

最终排序结果：[1, 2, 5, 6, 9]

**时间复杂度：** O(n log n)

### 4.2 Dijkstra算法

Dijkstra算法是一种用于计算加权图中两点之间最短路径的算法。

**数学模型：**

$$
\text{Dijkstra}(G, s) \\
\text{for each } v \in G \\
\text{distance}[v] = \infty \\
\text{previous}[v] = \text{nil} \\
\text{distance}[s] = 0 \\
\text{Q} = G.V \\
\text{while } Q \neq \emptyset \\
\text{u} = \text{extract\_min}(Q) \\
\text{for each } v \in G.Adj(u) \\
\text{if } distance[v] > distance[u] + w(u, v) \\
\text{distance[v]} = distance[u] + w(u, v) \\
\text{previous[v]} = u \\
\text{return distance[]
$$

**详细讲解：**

Dijkstra算法的基本思想是从源点 s 开始，逐步扩展到其他未访问过的顶点，每次扩展都选择当前已知的最短路径的顶点作为扩展点。具体步骤如下：

1. 初始化：将图中所有顶点的距离初始化为无穷大，源点 s 的距离初始化为 0。将所有顶点加入优先队列 Q。
2. 循环执行以下步骤，直到 Q 为空：
   - 从 Q 中取出距离最小的顶点 u。
   - 遍历 u 的邻接点 v，如果 distance[v] > distance[u] + w(u, v)，则更新 distance[v] 和 previous[v]。
   - 将 v 加入优先队列 Q。
3. 返回所有顶点的最短路径距离和前驱节点。

**举例说明：**

假设有如下加权图：

```
A---(2)---B
|        |
|        |
(3)     (1)
|        |
|        |
C---(4)---D
```

我们要计算从 A 到 D 的最短路径。

1. 初始化：distance[A] = 0，distance[B] = 2，distance[C] = 3，distance[D] = \infty。将 A、B、C、D 加入优先队列 Q。
2. 取出距离最小的顶点 A，更新邻接点 B、C 的距离：distance[B] = 2，distance[C] = 3。将 B、C 加入优先队列 Q。
3. 取出距离最小的顶点 B，更新邻接点 D 的距离：distance[D] = 3。将 D 加入优先队列 Q。
4. 取出距离最小的顶点 C，更新邻接点 D 的距离：distance[D] = 2。将 D 加入优先队列 Q。
5. 取出距离最小的顶点 D，此时 Q 为空，算法结束。

最短路径为 A-B-D，距离为 2 + 1 = 3。

**时间复杂度：** O(n^2)

## 5. 项目实战：代码实际案例和详细解释说明

### 5.1 开发环境搭建

为了完成以下项目实战，我们需要搭建相应的开发环境。

1. 安装 JDK 1.8 或更高版本。
2. 安装 MySQL 5.7 或更高版本。
3. 安装 Redis 3.2 或更高版本。
4. 安装 Node.js 12.x 或更高版本。

### 5.2 源代码详细实现和代码解读

以下是一个简单的用户管理系统，包括用户注册、登录和查询功能。

**用户注册：**

```java
// UserController.java
public class UserController {
    private static final String URL = "jdbc:mysql://localhost:3306/user?useSSL=false";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "root";

    public static void register(String username, String password) {
        try (Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
            String sql = "INSERT INTO user (username, password) VALUES (?, ?)";
            PreparedStatement stmt = conn.prepareStatement(sql);
            stmt.setString(1, username);
            stmt.setString(2, password);
            stmt.executeUpdate();
            System.out.println("注册成功！");
        } catch (SQLException e) {
            e.printStackTrace();
            System.out.println("注册失败！");
        }
    }
}
```

**用户登录：**

```java
// UserController.java
public static void login(String username, String password) {
    try (Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
        String sql = "SELECT * FROM user WHERE username = ? AND password = ?";
        PreparedStatement stmt = conn.prepareStatement(sql);
        stmt.setString(1, username);
        stmt.setString(2, password);
        ResultSet rs = stmt.executeQuery();
        if (rs.next()) {
            System.out.println("登录成功！");
        } else {
            System.out.println("登录失败！");
        }
    } catch (SQLException e) {
        e.printStackTrace();
        System.out.println("登录失败！");
    }
}
```

**用户查询：**

```java
// UserController.java
public static void queryByUsername(String username) {
    try (Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {
        String sql = "SELECT * FROM user WHERE username = ?";
        PreparedStatement stmt = conn.prepareStatement(sql);
        stmt.setString(1, username);
        ResultSet rs = stmt.executeQuery();
        if (rs.next()) {
            System.out.println("用户名：" + rs.getString("username"));
            System.out.println("密码：" + rs.getString("password"));
        } else {
            System.out.println("用户不存在！");
        }
    } catch (SQLException e) {
        e.printStackTrace();
        System.out.println("查询失败！");
    }
}
```

### 5.3 代码解读与分析

**用户注册：**

1. 加载 JDBC 驱动程序：`Class.forName("com.mysql.jdbc.Driver")`。
2. 建立连接：`Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)`。
3. 创建 SQL 语句：`String sql = "INSERT INTO user (username, password) VALUES (?, ?)"`。
4. 创建 PreparedStatement：`PreparedStatement stmt = conn.prepareStatement(sql)`。
5. 设置参数：`stmt.setString(1, username)` 和 `stmt.setString(2, password)`。
6. 执行 SQL 语句：`stmt.executeUpdate()`。
7. 输出结果：`System.out.println("注册成功！"` 或 `System.out.println("注册失败！"`)。

**用户登录：**

1. 加载 JDBC 驱动程序：`Class.forName("com.mysql.jdbc.Driver")`。
2. 建立连接：`Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)`。
3. 创建 SQL 语句：`String sql = "SELECT * FROM user WHERE username = ? AND password = ?"`。
4. 创建 PreparedStatement：`PreparedStatement stmt = conn.prepareStatement(sql)`。
5. 设置参数：`stmt.setString(1, username)` 和 `stmt.setString(2, password)`。
6. 执行 SQL 语句：`ResultSet rs = stmt.executeQuery()`。
7. 判断结果：如果 `rs.next()`，则输出 `System.out.println("登录成功！"`)，否则输出 `System.out.println("登录失败！"`)。

**用户查询：**

1. 加载 JDBC 驱动程序：`Class.forName("com.mysql.jdbc.Driver")`。
2. 建立连接：`Connection conn = DriverManager.getConnection(URL, USERNAME, PASSWORD)`。
3. 创建 SQL 语句：`String sql = "SELECT * FROM user WHERE username = ?"`。
4. 创建 PreparedStatement：`PreparedStatement stmt = conn.prepareStatement(sql)`。
5. 设置参数：`stmt.setString(1, username)`。
6. 执行 SQL 语句：`ResultSet rs = stmt.executeQuery()`。
7. 判断结果：如果 `rs.next()`，则输出用户信息，否则输出 `System.out.println("用户不存在！"`)。

## 6. 实际应用场景

字节跳动社招技术面试的内容涵盖了广泛的实际应用场景，包括但不限于：

- **算法与数据结构**：应用于搜索引擎、推荐系统、广告系统等。
- **前端技术**：应用于网页开发、移动应用开发、桌面应用开发等。
- **后端技术**：应用于网站后台、服务器端开发、大数据处理等。
- **数据库技术**：应用于数据存储、数据查询、数据分析和报表生成等。
- **架构设计**：应用于分布式系统、微服务架构、云计算等。

在面试过程中，面试官可能会根据实际项目场景出题，考察候选人对相关技术领域的掌握程度和应用能力。因此，了解相关实际应用场景，对面试备考具有重要意义。

## 7. 工具和资源推荐

### 7.1 学习资源推荐

- **书籍**：
  - 《算法导论》
  - 《深入理解计算机系统》
  - 《计算机网络：自顶向下方法》
  - 《大型分布式系统设计》
- **论文**：
  - 《MapReduce：大规模数据处理的并行算法》
  - 《微服务架构设计》
  - 《分布式系统原理与范型》
- **博客**：
  - [字节跳动技术博客](https://tech.youdao.com/)
  - [掘金](https://juejin.cn/)
  - [CSDN](https://www.csdn.net/)
- **网站**：
  - [GitHub](https://github.com/)
  - [LeetCode](https://leetcode-cn.com/)
  - [牛客网](https://www.nowcoder.com/)

### 7.2 开发工具框架推荐

- **前端开发**：
  - Vue
  - React
  - Angular
- **后端开发**：
  - Java：Spring Boot、MyBatis、Hibernate
  - Python：Django、Flask
  - Golang：Gin、Beego
- **数据库**：
  - 关系型数据库：MySQL、Oracle、PostgreSQL
  - 非关系型数据库：MongoDB、Redis、Cassandra
- **开发工具**：
  - IntelliJ IDEA
  - Visual Studio Code
  - Sublime Text

### 7.3 相关论文著作推荐

- 《大规模分布式存储系统：原理解析与架构实战》
- 《高并发系统设计》
- 《深度学习》
- 《机器学习》

## 8. 总结：未来发展趋势与挑战

随着科技的不断发展，字节跳动社招技术面试的内容和难度也在不断提高。未来，我们可以预见以下发展趋势和挑战：

- **人工智能与大数据**：随着人工智能技术的快速发展，面试内容将更加注重对大数据处理、深度学习、自然语言处理等领域的考察。
- **云计算与分布式系统**：云计算和分布式系统技术将成为面试的重点，面试官将更加关注候选人对相关技术的掌握程度和应用能力。
- **区块链与安全**：随着区块链技术的广泛应用，面试内容将涉及区块链的基本原理、应用场景和安全问题。
- **网络安全与隐私保护**：随着网络安全威胁的日益严重，面试内容将更加关注网络安全、隐私保护等方面的知识和技能。

面对这些发展趋势和挑战，候选人需要不断学习和提升自己的技术能力，以适应未来技术领域的发展需求。

## 9. 附录：常见问题与解答

### 9.1 算法与数据结构

**Q：什么是时间复杂度？**

A：时间复杂度是指算法在执行过程中所消耗的时间与输入规模之间的增长关系。通常用大O符号（O）表示，如 O(n)、O(n^2)、O(log n) 等。

**Q：什么是空间复杂度？**

A：空间复杂度是指算法在执行过程中所消耗的存储空间与输入规模之间的增长关系。同样，也用大O符号（O）表示，如 O(n)、O(n^2)、O(log n) 等。

**Q：冒泡排序的时间复杂度是多少？**

A：冒泡排序的时间复杂度为 O(n^2)。

### 9.2 前端技术

**Q：什么是单页面应用（SPA）？**

A：单页面应用（Single Page Application，简称 SPA）是一种仅刷新单页面的 Web 应用程序。与传统的多页面应用相比，SPA 具有更好的用户体验和更高的性能。

**Q：React 和 Vue 有什么区别？**

A：React 和 Vue 都是前端框架，具有以下区别：

- React 是由 Facebook 开发的，Vue 是由尤雨溪开发的。
- React 使用虚拟 DOM，Vue 使用真实 DOM。
- React 有更多的社区支持和丰富的生态资源，Vue 则更简洁易用。

### 9.3 后端技术

**Q：什么是微服务架构？**

A：微服务架构是一种将应用程序拆分成多个独立的服务，每个服务负责不同的功能模块。这些服务可以通过 RESTful API 或消息队列等方式进行通信。

**Q：什么是 Spring Boot？**

A：Spring Boot 是一个基于 Spring 框架的快速开发工具，可以帮助开发者简化 Spring 应用程序的构建和部署。

### 9.4 数据库技术

**Q：什么是 NoSQL 数据库？**

A：NoSQL 数据库（Not Only SQL）是一种非关系型数据库，与传统的关系型数据库相比，具有更好的扩展性和灵活性。常见的 NoSQL 数据库包括 MongoDB、Redis、Cassandra 等。

### 9.5 架构设计

**Q：什么是分布式系统？**

A：分布式系统是一种由多个计算机节点组成的系统，这些节点通过网络进行通信，共同完成一个任务。分布式系统具有更好的容错性、可扩展性和可靠性。

**Q：什么是微服务架构？**

A：微服务架构是一种将应用程序拆分成多个独立的服务，每个服务负责不同的功能模块。这些服务可以通过 RESTful API 或消息队列等方式进行通信。

## 10. 扩展阅读 & 参考资料

- 《算法导论》
- 《深入理解计算机系统》
- 《计算机网络：自顶向下方法》
- 《大规模分布式存储系统：原理解析与架构实战》
- 《高并发系统设计》
- 《深度学习》
- 《机器学习》
- 《微服务架构设计》
- 《分布式系统原理与范型》
- 《计算机网络》
- 《操作系统概念》
- 《数据库系统概念》

---

**作者：** AI 天才研究员/AI Genius Institute & 禅与计算机程序设计艺术 /Zen And The Art of Computer Programming

