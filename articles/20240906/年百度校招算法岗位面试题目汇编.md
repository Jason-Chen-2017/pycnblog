                 

### 2025年百度校招算法岗位面试题目汇编

#### 面试题库

1. **排序算法**
   - **题目：** 请实现快速排序算法，并分析其时间复杂度和空间复杂度。
   - **答案：** 快速排序算法实现如下，时间复杂度为 O(nlogn)，最坏情况下的空间复杂度为 O(n)。
     
     ```go
     func quickSort(arr []int) []int {
         if len(arr) <= 1 {
             return arr
         }
         pivot := arr[0]
         left := make([]int, 0)
         right := make([]int, 0)
         for _, v := range arr[1:] {
             if v < pivot {
                 left = append(left, v)
             } else {
                 right = append(right, v)
             }
         }
         return append(quickSort(left), pivot), quickSort(right)
     }
     ```

2. **二分查找**
   - **题目：** 请实现二分查找算法，并分析其时间复杂度。
   - **答案：** 二分查找算法实现如下，时间复杂度为 O(logn)。
     
     ```go
     func binarySearch(arr []int, target int) int {
         low, high := 0, len(arr)-1
         for low <= high {
             mid := (low + high) / 2
             if arr[mid] == target {
                 return mid
             } else if arr[mid] < target {
                 low = mid + 1
             } else {
                 high = mid - 1
             }
         }
         return -1
     }
     ```

3. **数据结构设计**
   - **题目：** 请设计一个队列，支持在队头和队尾添加元素，以及从队头删除元素。请实现 EnQueue、DeQueueFront、DeQueueRear 方法。
   - **答案：** 可以使用两个栈实现队列，代码如下。
     
     ```go
     type MyQueue struct {
         inStack, outStack []int
     }

     func NewMyQueue() *MyQueue {
         return &MyQueue{}
     }

     func (q *MyQueue) EnQueue(value int) {
         q.inStack = append(q.inStack, value)
     }

     func (q *MyQueue) DeQueueFront() int {
         if len(q.outStack) == 0 {
             for len(q.inStack) > 0 {
                 q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])
                 q.inStack = q.inStack[:len(q.inStack)-1]
             }
         }
         if len(q.outStack) == 0 {
             return -1
         }
         top := q.outStack[len(q.outStack)-1]
         q.outStack = q.outStack[:len(q.outStack)-1]
         return top
     }

     func (q *MyQueue) DeQueueRear() int {
         if len(q.inStack) == 0 {
             return -1
         }
         return q.inStack[len(q.inStack)-1]
     }
     ```

#### 算法编程题库

1. **最长公共子序列**
   - **题目：** 给定两个字符串，找出它们的最长公共子序列。
   - **答案：** 动态规划实现如下，时间复杂度为 O(mn)，空间复杂度为 O(mn)。
     
     ```go
     func longestCommonSubsequence(text1, text2 string) string {
         m, n := len(text1), len(text2)
         dp := make([][]int, m+1)
         for i := range dp {
             dp[i] = make([]int, n+1)
         }
         for i := 1; i <= m; i++ {
             for j := 1; j <= n; j++ {
                 if text1[i-1] == text2[j-1] {
                     dp[i][j] = dp[i-1][j-1] + 1
                 } else {
                     dp[i][j] = max(dp[i-1][j], dp[i][j-1])
                 }
             }
         }
         var res []byte
         i, j := m, n
         for i > 0 && j > 0 {
             if text1[i-1] == text2[j-1] {
                 res = append(res, text1[i-1])
                 i--
                 j--
             } else if dp[i-1][j] > dp[i][j-1] {
                 i--
             } else {
                 j--
             }
         }
         reverse(res)
         return string(res)
     }

     func reverse(s []byte) {
         for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
             s[i], s[j] = s[j], s[i]
         }
     }

     func max(a, b int) int {
         if a > b {
             return a
         }
         return b
     }
     ```

2. **背包问题**
   - **题目：** 给定一个物品列表和它们的重量和价值，以及一个背包的最大承重，找出如何放置这些物品以使总价值最大。
   - **答案：** 动态规划实现如下，时间复杂度为 O(nW)，空间复杂度为 O(W)，其中 n 是物品数量，W 是背包最大承重。
     
     ```go
     func knapsack(values, weights []int, W int) int {
         n := len(values)
         dp := make([][]int, n+1)
         for i := range dp {
             dp[i] = make([]int, W+1)
         }
         for i := 1; i <= n; i++ {
             for w := 1; w <= W; w++ {
                 if weights[i-1] <= w {
                     dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
                 } else {
                     dp[i][w] = dp[i-1][w]
                 }
             }
         }
         return dp[n][W]
     }

     func max(a, b int) int {
         if a > b {
             return a
         }
         return b
     }
     ```

3. **合并区间**
   - **题目：** 给定一组区间，合并所有重叠的区间，并返回合并后的区间列表。
   - **答案：** 排序后合并区间，代码如下，时间复杂度为 O(nlogn)，空间复杂度为 O(n)。
     
     ```go
     func merge(intervals [][]int) [][]int {
         sort.Slice(intervals, func(i, j int) bool {
             return intervals[i][0] < intervals[j][0]
         })
         var res [][]int
         for _, interval := range intervals {
             if len(res) == 0 || res[len(res)-1][1] < interval[0] {
                 res = append(res, interval)
             } else {
                 res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
             }
         }
         return res
     }

     func max(a, b int) int {
         if a > b {
             return a
         }
         return b
     }
     ```

4. **字符串匹配**
   - **题目：** 实现字符串匹配算法，如 KMP 算法，找出字符串 `s` 中子串 `p` 的第一个匹配位置。
   - **答案：** KMP 算法实现如下，时间复杂度为 O(n+m)，其中 n 是字符串 `s` 的长度，m 是字符串 `p` 的长度。
     
     ```go
     func kmp(s, p string) int {
         n, m := len(s), len(p)
         lps := make([]int, m)
         computeLPSArray(p, m, lps)
         i, j := 0, 0
         for i < n {
             if s[i] == p[j] {
                 i++
                 j++
             }
             if j == m {
                 return i - j
             } else if i < n && s[i] != p[j] {
                 if j != 0 {
                     j = lps[j-1]
                 } else {
                     i++
                 }
             }
         }
         return -1
     }

     func computeLPSArray pat []byte, M int) {
         lps := make([]int, M)
         length := 0
         i := 1
         for i < M {
             if pat[i] == pat[length] {
                 length++
                 lps[i] = length
                 i++
             } else {
                 if length != 0 {
                     length = lps[length-1]
                 } else {
                     lps[i] = 0
                     i++
                 }
             }
         }
     }
     ```

5. **无重复字符的最长子串**
   - **题目：** 给定一个字符串，找出其中不含有重复字符的最长子串的长度。
   - **答案：** 滑动窗口实现如下，时间复杂度为 O(n)，空间复杂度为 O(min(m, n))，其中 m 是字符集大小，n 是字符串长度。
     
     ```go
     func lengthOfLongestSubstring(s string) int {
         n := len(s)
         chs := make(map[rune]int)
         ans, j := 0, 0
         for i := 0; i < n; i++ {
             c := s[i]
             if j < i {
                 j = chs[c]
             }
             chs[c] = i + 1
             ans = max(ans, i-j)
         }
         return ans
     }

     func max(a, b int) int {
         if a > b {
             return a
         }
         return b
     }
     ```

6. **链表相交**
   - **题目：** 给定两个单链表，找出它们的相交节点。
   - **答案：** 使用哈希表实现如下，时间复杂度为 O(n+m)，空间复杂度为 O(n+m)，其中 n 和 m 分别是两个链表的长度。
     
     ```go
     func getIntersectionNode(headA, headB *ListNode) *ListNode {
         nodes := make(map[*ListNode]bool)
         for p := headA; p != nil; p = p.Next {
             nodes[p] = true
         }
         for p := headB; p != nil; p = p.Next {
             if nodes[p] {
                 return p
             }
         }
         return nil
     }
     ```

#### 答案解析

- **面试题解析：**
  - **排序算法：** 快速排序算法通过递归地将数组分成两部分，一部分比 pivot 小，一部分比 pivot 大，然后分别对这两部分进行快速排序。快速排序的平均时间复杂度为 O(nlogn)，但最坏情况下的时间复杂度为 O(n^2)。
  - **二分查找：** 二分查找算法通过不断将搜索范围缩小一半来查找目标元素。在每次循环中，比较目标元素与中间元素的大小，然后决定是继续在左侧还是右侧搜索。二分查找算法的时间复杂度为 O(logn)。
  - **数据结构设计：** 使用两个栈实现队列，一个用于入队操作，另一个用于出队操作。当出队栈为空时，将入队栈中的元素依次弹出并压入出队栈，以保证出队操作的正确顺序。

- **算法编程题解析：**
  - **最长公共子序列：** 使用动态规划算法来求解最长公共子序列问题。动态规划的核心思想是利用已计算出的子问题的解来求解更大规模的问题。通过构建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串 `text1` 的前 `i` 个字符和字符串 `text2` 的前 `j` 个字符的最长公共子序列长度。
  - **背包问题：** 使用动态规划算法来求解背包问题。动态规划的核心思想是利用已计算出的子问题的解来求解更大规模的问题。通过构建一个二维数组 `dp`，其中 `dp[i][w]` 表示在前 `i` 个物品中，总重量不超过 `w` 的最大价值。
  - **合并区间：** 使用排序和双指针算法来求解合并区间问题。首先对区间列表按照起点进行排序，然后使用两个指针分别指向当前考虑的区间和下一个待合并的区间，判断当前区间是否与下一个区间重叠，如果重叠则合并它们，否则继续移动下一个区间。
  - **字符串匹配：** 使用 KMP 算法来求解字符串匹配问题。KMP 算法通过预计算一个最长公共前后缀数组 `lps` 来优化匹配过程，避免不必要的字符比较。
  - **无重复字符的最长子串：** 使用滑动窗口算法来求解无重复字符的最长子串问题。滑动窗口算法通过不断地移动右边界来扩大窗口，并在遇到重复字符时移动左边界来缩小窗口，同时记录当前窗口的最大长度。
  - **链表相交：** 使用哈希表算法来求解链表相交问题。哈希表算法通过构建一个哈希表来存储一个链表中的所有节点，然后遍历另一个链表，检查每个节点是否在哈希表中，从而找到相交节点。

#### 源代码实例

- **排序算法：** 快速排序算法实现。
  
  ```go
  func quickSort(arr []int) []int {
      if len(arr) <= 1 {
          return arr
      }
      pivot := arr[0]
      left := make([]int, 0)
      right := make([]int, 0)
      for _, v := range arr[1:] {
          if v < pivot {
              left = append(left, v)
          } else {
              right = append(right, v)
          }
      }
      return append(quickSort(left), pivot), quickSort(right)
  }
  ```

- **二分查找：** 二分查找算法实现。

  ```go
  func binarySearch(arr []int, target int) int {
      low, high := 0, len(arr)-1
      for low <= high {
          mid := (low + high) / 2
          if arr[mid] == target {
              return mid
          } else if arr[mid] < target {
              low = mid + 1
          } else {
              high = mid - 1
          }
      }
      return -1
  }
  ```

- **数据结构设计：** 使用两个栈实现队列。

  ```go
  type MyQueue struct {
      inStack, outStack []int
  }

  func NewMyQueue() *MyQueue {
      return &MyQueue{}
  }

  func (q *MyQueue) EnQueue(value int) {
      q.inStack = append(q.inStack, value)
  }

  func (q *MyQueue) DeQueueFront() int {
      if len(q.outStack) == 0 {
          for len(q.inStack) > 0 {
              q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])
              q.inStack = q.inStack[:len(q.inStack)-1]
          }
      }
      if len(q.outStack) == 0 {
          return -1
      }
      top := q.outStack[len(q.outStack)-1]
      q.outStack = q.outStack[:len(q.outStack)-1]
      return top
  }

  func (q *MyQueue) DeQueueRear() int {
      if len(q.inStack) == 0 {
          return -1
      }
      return q.inStack[len(q.inStack)-1]
  }
  ```

- **最长公共子序列：** 动态规划算法实现。

  ```go
  func longestCommonSubsequence(text1, text2 string) string {
      m, n := len(text1), len(text2)
      dp := make([][]int, m+1)
      for i := range dp {
          dp[i] = make([]int, n+1)
      }
      for i := 1; i <= m; i++ {
          for j := 1; j <= n; j++ {
              if text1[i-1] == text2[j-1] {
                  dp[i][j] = dp[i-1][j-1] + 1
              } else {
                  dp[i][j] = max(dp[i-1][j], dp[i][j-1])
              }
          }
      }
      var res []byte
      i, j := m, n
      for i > 0 && j > 0 {
          if text1[i-1] == text2[j-1] {
              res = append(res, text1[i-1])
              i--
              j--
          } else if dp[i-1][j] > dp[i][j-1] {
              i--
          } else {
              j--
          }
      }
      reverse(res)
      return string(res)
  }

  func reverse(s []byte) {
      for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
          s[i], s[j] = s[j], s[i]
      }
  }

  func max(a, b int) int {
      if a > b {
          return a
      }
      return b
  }
  ```

- **背包问题：** 动态规划算法实现。

  ```go
  func knapsack(values, weights []int, W int) int {
      n := len(values)
      dp := make([][]int, n+1)
      for i := range dp {
          dp[i] = make([]int, W+1)
      }
      for i := 1; i <= n; i++ {
          for w := 1; w <= W; w++ {
              if weights[i-1] <= w {
                  dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
              } else {
                  dp[i][w] = dp[i-1][w]
              }
          }
      }
      return dp[n][W]
  }

  func max(a, b int) int {
      if a > b {
          return a
      }
      return b
  }
  ```

- **合并区间：** 排序和双指针算法实现。

  ```go
  func merge(intervals [][]int) [][]int {
      sort.Slice(intervals, func(i, j int) bool {
          return intervals[i][0] < intervals[j][0]
      })
      var res [][]int
      for _, interval := range intervals {
          if len(res) == 0 || res[len(res)-1][1] < interval[0] {
              res = append(res, interval)
          } else {
              res[len(res)-1][1] = max(res[len(res)-1][1], interval[1])
          }
      }
      return res
  }

  func max(a, b int) int {
      if a > b {
          return a
      }
      return b
  }
  ```

- **字符串匹配：** KMP 算法实现。

  ```go
  func kmp(s, p string) int {
      n, m := len(s), len(p)
      lps := make([]int, m)
      computeLPSArray(p, m, lps)
      i, j := 0, 0
      for i < n {
          if s[i] == p[j] {
              i++
              j++
          }
          if j == m {
              return i - j
          } else if i < n && s[i] != p[j] {
              if j != 0 {
                  j = lps[j-1]
              } else {
                  i++
              }
          }
      }
      return -1
  }

  func computeLPSArray pat []byte, M int) {
      lps := make([]int, M)
      length := 0
      i := 1
      for i < M {
          if pat[i] == pat[length] {
              length++
              lps[i] = length
              i++
          } else {
              if length != 0 {
                  length = lps[length-1]
              } else {
                  lps[i] = 0
                  i++
              }
          }
      }
  }
  ```

- **无重复字符的最长子串：** 滑动窗口算法实现。

  ```go
  func lengthOfLongestSubstring(s string) int {
      n := len(s)
      chs := make(map[rune]int)
      ans, j := 0, 0
      for i := 0; i < n; i++ {
          c := s[i]
          if j < i {
              j = chs[c]
          }
          chs[c] = i + 1
          ans = max(ans, i-j)
      }
      return ans
  }

  func max(a, b int) int {
      if a > b {
          return a
      }
      return b
  }
  ```

- **链表相交：** 哈希表算法实现。

  ```go
  func getIntersectionNode(headA, headB *ListNode) *ListNode {
      nodes := make(map[*ListNode]bool)
      for p := headA; p != nil; p = p.Next {
          nodes[p] = true
      }
      for p := headB; p != nil; p = p.Next {
          if nodes[p] {
              return p
          }
      }
      return nil
  }
  ```

### 总结

通过本文，我们介绍了几道百度校招算法岗位的面试题和算法编程题，并给出了详细的答案解析和源代码实例。这些题目涵盖了排序算法、二分查找、数据结构设计、最长公共子序列、背包问题、合并区间、字符串匹配、无重复字符的最长子串和链表相交等多个方面。通过掌握这些算法和数据结构，可以更好地应对百度校招算法岗位的面试和笔试。同时，我们也提供了一些实用的源代码实例，帮助读者更好地理解和应用这些算法。希望本文对您有所帮助！

