                 



# 题库示例

## 1. 判断字符串是否唯一

### 题目描述

请实现一个函数，判断字符串中的所有字符是否只出现一次。

### 输入

字符串 `s`

### 输出

布尔值，如果字符串中的所有字符只出现一次，返回 `true`；否则返回 `false`。

### 示例

```
输入：s = "abracadabra"
输出：false

输入：s = "abcdef"
输出：true
```

### 解答

```python
def is_unique(s: str) -> bool:
    char_set = set()
    for char in s:
        if char in char_set:
            return False
        char_set.add(char)
    return True
```

### 解析

该函数使用一个集合（`set`）来存储已遍历的字符。遍历字符串时，如果当前字符已存在于集合中，说明字符串中的字符不唯一，直接返回 `false`。如果遍历完整个字符串后，集合中的字符数量等于字符串长度，则说明字符串中的所有字符只出现一次，返回 `true`。

## 2. 两数之和

### 题目描述

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

### 输入

整数数组 `nums` 和目标值 `target`

### 输出

整数数组，包含两个元素，分别表示两个数的位置，如果找不到满足条件的两个数，返回空数组。

### 示例

```
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]

输入：nums = [3, 2, 4], target = 6
输出：[1, 2]
```

### 解答

```python
def two_sum(nums, target):
    num_dict = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_dict:
            return [num_dict[complement], i]
        num_dict[num] = i
    return []
```

### 解析

该函数使用一个字典（`num_dict`）来存储已遍历的数字及其索引。遍历数组时，计算目标值与当前数的差值（`complement`），如果差值存在于字典中，说明已经找到了满足条件的两个数，返回差值在字典中的索引和当前索引。如果遍历完整个数组后仍未找到满足条件的两个数，返回空数组。

## 3. 无重复字符的最长子串

### 题目描述

给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串 `T` 的长度。

### 输入

字符串 `s`

### 输出

整数，表示不含有重复字符的最长子串的长度。

### 示例

```
输入：s = "abcabcbb"
输出：3

输入：s = "bbbbb"
输出：1

输入：s = "pwwkew"
输出：3
```

### 解答

```python
def length_of_longest_substring(s: str) -> int:
    start = 0
    max_len = 0
    seen = {}
    for end in range(len(s)):
        if s[end] in seen:
            start = max(start, seen[s[end]] + 1)
        max_len = max(max_len, end - start + 1)
        seen[s[end]] = end
    return max_len
```

### 解析

该函数使用一个滑动窗口（由 `start` 和 `end` 指针定义）来遍历字符串。通过一个字典（`seen`）来记录已遍历的字符及其索引。如果当前字符已存在于字典中，更新 `start` 指针为当前字符上次出现位置的下一个位置。每次更新 `max_len` 为当前窗口长度。遍历完整个字符串后，返回 `max_len`。

## 4. 合并两个有序链表

### 题目描述

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

### 输入

两个有序链表 `l1` 和 `l2`

### 输出

合并后的有序链表。

### 示例

```
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

### 解答

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

### 解析

该函数创建一个虚拟头节点（`dummy`）和一个当前节点（`current`），用于构建新的链表。遍历两个链表，每次比较两个链表当前节点的值，将较小的值添加到新链表中。遍历结束后，将剩余的一个链表连接到新链表的末尾。

## 5. 反转链表

### 题目描述

定义一个函数，该函数接收一个链表的头节点，并返回链表反转后的头节点。

### 输入

链表的头节点

### 输出

反转后的链表的头节点。

### 示例

```
输入：head = [1, 2, 3, 4, 5]
输出：[5, 4, 3, 2, 1]

输入：head = [1]
输出：[1]
```

### 解答

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev
```

### 解析

该函数使用一个虚拟头节点（`prev`）和一个当前节点（`current`）来反转链表。遍历链表时，每次将当前节点的 `next` 指针指向前一个节点（`prev`），然后将 `prev` 和 `current` 分别向前移动一位。遍历结束后，返回 `prev`，即新的链表头节点。

## 6. 字符串相乘

### 题目描述

给定两个字符串表示的非负整数 `num1` 和 `num2`，返回由它们相乘得到的字符串表示的非负整数。

### 输入

字符串 `num1` 和 `num2`

### 输出

字符串表示的非负整数。

### 示例

```
输入：num1 = "2", num2 = "3"
输出："6"

输入：num1 = "123", num2 = "456"
输出："56088"
```

### 解答

```python
def multiply(num1, num2):
    m, n = len(num1), len(num2)
    if m > n:
        num1, num2 = num2, num1
        m, n = n, m

    res = [0] * (m + n)
    i, j = 0, 0
    while i < m and j < n:
        res[i + j] += int(num1[i]) * int(num2[j])
        res[i + j + 1] += res[i + j] // 10
        res[i + j] %= 10
        i += 1
        j += 1

    while i < m:
        res[i + j] += int(num1[i]) * int(num2[0])
        res[i + j + 1] += res[i + j] // 10
        res[i + j] %= 10
        i += 1

    while j < n:
        res[i + j] += int(num1[0]) * int(num2[j])
        res[i + j + 1] += res[i + j] // 10
        res[i + j] %= 10
        j += 1

    while res[-1] == 0:
        res.pop()

    return ''.join(map(str, res[::-1]))
```

### 解析

该函数将两个字符串转换为整数，然后按照整数乘法的规则进行计算。将乘积的每一位存储在一个列表（`res`）中，从最低位到最高位。在计算过程中，如果乘积超过 10，则向前进位。最后，将列表转换为字符串并返回。

## 7. 搜索二维矩阵

### 题目描述

编写一个高效的算法来搜索一个二维矩阵。矩阵中的整数按升序排列，每行中的整数从左到右按升序排列，每列中的整数从上到下按升序排列。

### 输入

二维矩阵 `matrix` 和目标值 `target`

### 输出

布尔值，如果矩阵中存在目标值，返回 `true`；否则返回 `false`。

### 示例

```
输入：matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], target = 3
输出：true

输入：matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], target = 13
输出：false
```

### 解答

```python
def search_matrix(matrix, target):
    row, col = 0, len(matrix[0]) - 1
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False
```

### 解析

该函数使用一个类似于二分查找的算法来搜索矩阵。从左下角（`row = 0, col = len(matrix[0]) - 1`）开始，如果当前元素等于目标值，返回 `true`。如果当前元素小于目标值，说明目标值可能在下一行，因此行指针 `row` 向上移动。如果当前元素大于目标值，说明目标值可能在上一列，因此列指针 `col` 向左移动。遍历结束后，如果未找到目标值，返回 `false`。

## 8. 盘点收获

### 题目描述

假设你是一名农场主人，有一块面积为 `N x M` 的田地，你需要在田地上种植作物。田地上的每个位置都有一个收获值，你可以选择任意形状的田地来种植作物，但每种植一次，田地上的收获值就会减半。你的目标是最大化总收获值。

### 输入

一个二维数组 `grid`，表示田地上的收获值。

### 输出

一个整数，表示最大收获值。

### 示例

```
输入：
grid = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

输出：
9
```

### 解答

```python
def max_profit(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * (n+1) for _ in range(m+1)]
    
    for i in range(1, m+1):
        for j in range(1, n+1):
            dp[i][j] = max(
                dp[i-1][j],  # 不种植当前行
                dp[i][j-1],  # 不种植当前列
                dp[i-1][j-1] + grid[i-1][j-1]  # 种植当前行和列
            )
    
    return dp[-1][-1]
```

### 解析

该问题可以使用动态规划来解决。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示种植到第 `i` 行和第 `j` 列时的最大收获值。状态转移方程为：

```
dp[i][j] = max(
    dp[i-1][j],  # 不种植当前行
    dp[i][j-1],  # 不种植当前列
    dp[i-1][j-1] + grid[i-1][j-1]  # 种植当前行和列
)
```

最终，`dp[m][n]` 就是最大收获值。

## 9. 合并区间

### 题目描述

给定一组区间，请合并所有有交集的区间。

### 输入

一组区间，以列表形式给出。

### 输出

合并后的区间列表。

### 示例

```
输入：intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
输出：[[1, 6], [8, 10], [15, 18]]

输入：intervals = [[1, 4], [4, 5]]
输出：[[1, 5]]
```

### 解答

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for interval in intervals[1:]:
        last = merged[-1]
        if last[1] >= interval[0]:
            merged[-1] = [last[0], max(last[1], interval[1])]
        else:
            merged.append(interval)
    return merged
```

### 解析

该函数首先对区间列表进行排序，然后遍历区间列表。对于当前区间，如果它与前一个区间有交集（即前一个区间的结束时间大于或等于当前区间的开始时间），则合并两个区间。如果它们没有交集，则将当前区间添加到结果列表中。最终，返回合并后的区间列表。

## 10. 打家劫舍

### 题目描述

你是一个小偷，计划偷窃沿街的房屋。每间房屋装有防盗系统，如果你相邻的房屋被盗窃，系统会自动报警。计算你最多能偷窃多少金额。

### 输入

一个整数数组 `nums`，表示每间房屋的金额。

### 输出

最多能偷窃的金额。

### 示例

```
输入：nums = [1, 2, 3, 1]
输出：4

输入：nums = [2, 7, 9, 3, 1]
输出：12
```

### 解答

```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    return max(rob(nums[:-1]), rob(nums[:-2]) + nums[-1])
```

### 解析

该问题可以使用递归和记忆化搜索来解决。定义一个函数 `rob`，它接受一个整数数组 `nums` 作为输入，返回最多能偷窃的金额。状态转移方程为：

```
rob(nums) = max(
    rob(nums[:-1]),  # 不偷取最后一个元素
    rob(nums[:-2]) + nums[-1]  # 偷取最后一个元素
)
```

递归的基例是当 `nums` 为空时，返回 0；当 `nums` 只有一个元素时，返回该元素。

## 11. 买卖股票的最佳时机 III

### 题目描述

给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。假设你在每一天均可买入和卖出一次股票。设计一个算法来计算你所能获取的最大利润。

### 输入

一个整数数组 `prices`。

### 输出

所能获取的最大利润。

### 示例

```
输入：prices = [3, 3, 6, 5, 0, 3, 1, 4]
输出：6

输入：prices = [1, 2, 3, 4, 5]
输出：4
```

### 解答

```python
def maxProfit(prices):
    if not prices:
        return 0
    
    k = 2
    dp = [[0] * len(prices) for _ in range(k + 1)]
    
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, len(prices)):
            max_diff = max(max_diff, dp[i - 1][j] - prices[j])
            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)
    
    return dp[k][len(prices) - 1]
```

### 解析

该问题可以使用动态规划来解决。定义一个三维数组 `dp`，其中 `dp[i][j]` 表示在第 `i` 天进行第 `j` 次交易后可以获取的最大利润。状态转移方程为：

```
dp[i][j] = max(
    dp[i][j - 1],  # 不进行第 j 次交易
    prices[j] + dp[i - 1][j - 1]  # 进行第 j 次交易
)
```

其中，`max_diff` 表示从最后一次交易开始到第 `j` 天的最大利润差。

## 12. 搜索二维矩阵 II

### 题目描述

编写一个高效的算法来搜索一个二维矩阵。矩阵中的整数按升序排列，每行中的整数从左到右按升序排列，每列中的整数从上到下按升序排列。

### 输入

二维矩阵 `matrix` 和目标值 `target`

### 输出

布尔值，如果矩阵中存在目标值，返回 `true`；否则返回 `false`。

### 示例

```
输入：matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], target = 3
输出：true

输入：matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], target = 13
输出：false
```

### 解答

```python
def search_matrix(matrix, target):
    row, col = 0, len(matrix[0]) - 1
    while row < len(matrix) and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] < target:
            row += 1
        else:
            col -= 1
    return False
```

### 解析

该函数使用一个类似于二分查找的算法来搜索矩阵。从左下角（`row = 0, col = len(matrix[0]) - 1`）开始，如果当前元素等于目标值，返回 `true`。如果当前元素小于目标值，说明目标值可能在下一行，因此行指针 `row` 向上移动。如果当前元素大于目标值，说明目标值可能在上一列，因此列指针 `col` 向左移动。遍历结束后，如果未找到目标值，返回 `false`。

## 13. 盛最多水的容器

### 题目描述

给定一个二维矩阵 `height`，其中 `height[i][j]` 表示矩阵中第 `i` 行和第 `j` 列的单元格的高度。每个单元格至少有一个水滴。计算水的总量。

### 输入

二维矩阵 `height`

### 输出

水的总量。

### 示例

```
输入：
height = [
    [1, 8, 6, 2, 5, 4, 8, 3, 7],
    [3, 7, 8, 6, 1, 2, 9, 4, 1],
    [7, 1, 3, 9, 2, 4, 6, 7, 8],
    [4, 1, 2, 6, 7, 3, 8, 9, 5],
    [9, 2, 6, 5, 1, 7, 8, 2, 6],
    [4, 7, 8, 6, 2, 1, 6, 2, 6],
    [5, 9, 1, 4, 6, 7, 3, 8, 2],
    [8, 3, 6, 2, 6, 2, 1, 4, 7],
    [1, 4, 7, 3, 6, 2, 6, 2, 4]
]

输出：
6178
```

### 解答

```python
def max_area_of_island(height):
    m, n = len(height), len(height[0])
    visited = set()
    
    def dfs(i, j):
        if (i, j) in visited or i < 0 or i >= m or j < 0 or j >= n or height[i][j] == 0:
            return 0
        visited.add((i, j))
        area = height[i][j]
        area += dfs(i + 1, j)
        area += dfs(i - 1, j)
        area += dfs(i, j + 1)
        area += dfs(i, j - 1)
        return area
    
    max_area = 0
    for i in range(m):
        for j in range(n):
            max_area = max(max_area, dfs(i, j))
    return max_area
```

### 解析

该函数使用深度优先搜索（DFS）来计算岛屿的面积。定义一个二维数组 `visited` 来记录已访问的单元格。对于每个未访问的单元格，调用 `dfs` 函数计算岛屿的面积。`dfs` 函数遍历单元格的四个相邻单元格，如果相邻单元格未被访问且高度大于 0，则将面积增加相应的高度。遍历结束后，返回岛屿的面积。最终，遍历整个矩阵，找到最大的岛屿面积。

## 14. 删除链表的倒数第 N 个结点

### 题目描述

给定一个链表，删除链表的倒数第 N 个结点，并且返回链表的新头结点。

### 输入

链表的头结点和整数 `N`。

### 输出

链表的新头结点。

### 示例

```
输入：head = [1, 2, 3, 4, 5], N = 2
输出：[1, 2, 3, 5]

输入：head = [1], N = 1
输出：[]
```

### 解答

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def remove_nth_from_end(head, N):
    dummy = ListNode(0)
    dummy.next = head
    fast = slow = dummy
    for _ in range(N):
        fast = fast.next
    while fast:
        slow = slow.next
        fast = fast.next
    slow.next = slow.next.next
    return dummy.next
```

### 解析

该函数使用两个指针 `fast` 和 `slow`，其中 `fast` 指针先移动 `N` 步，然后 `fast` 和 `slow` 同时移动。当 `fast` 到达链表末尾时，`slow` 正好指向倒数第 `N` 个节点。此时，将 `slow` 的 `next` 指针指向 `slow` 的 `next` 的 `next`，即可删除倒数第 `N` 个节点。

## 15. 三数之和

### 题目描述

给定一个整数数组 `nums` 和一个目标值 `target`，找出三个数使得它们的和与 `target` 最接近。

### 输入

整数数组 `nums` 和目标值 `target`。

### 输出

最接近 `target` 的三个数的和。

### 示例

```
输入：nums = [-1, 2, 1, -4], target = 1
输出：2

输入：nums = [0, 0, 0], target = 0
输出：0
```

### 解答

```python
def three_sum_closest(nums, target):
    nums.sort()
    result = nums[0] + nums[1] + nums[2]
    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if abs(total - target) < abs(result - target):
                result = total
            if total < target:
                left += 1
            elif total > target:
                right -= 1
            else:
                return result
    return result
```

### 解析

该函数首先对数组进行排序。然后遍历数组，对于每个元素 `nums[i]`，使用双指针 `left` 和 `right` 扫描其余的元素。如果三个元素的和小于目标值，则移动左指针 `left`；如果三个元素的和大于目标值，则移动右指针 `right`。如果三个元素的和等于目标值，则直接返回结果。遍历结束后，返回最接近目标值的三个数的和。

## 16. 打家劫舍 II

### 题目描述

在第一题的基础上，如果整个区间的最后一个房子（或第一个房子）不能被抢，计算最多能偷窃多少金额。

### 输入

一个整数数组 `nums`。

### 输出

最多能偷窃的金额。

### 示例

```
输入：nums = [2, 3, 2]
输出：3

输入：nums = [1, 2, 3, 1]
输出：4
```

### 解答

```python
def rob2(nums):
    n = len(nums)
    if n == 1:
        return nums[0]
    return max(rob(nums[:-1]), rob(nums[1:]))
```

### 解析

该函数首先判断数组长度。如果数组长度为 1，则直接返回该元素。否则，计算两个值：

1. 不抢最后一个房子，即抢前 `n-1` 个房子的最大金额。
2. 不抢第一个房子，即抢从第二个房子开始的 `n-1` 个房子的最大金额。

返回这两个值的最大值。

## 17. 买卖股票的最佳时机 IV

### 题目描述

给定一个整数数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。假设你最多只能同时持有 `k` 只股票，设计一个算法来计算你最多可以获取多少利润。

### 输入

整数数组 `prices` 和整数 `k`。

### 输出

最多可以获取的利润。

### 示例

```
输入：prices = [3, 2, 6, 5, 0, 3], k = 2
输出：9

输入：prices = [2, 2, 2, 2, 6], k = 2
输出：10
```

### 解答

```python
def maxProfit(k, prices):
    n = len(prices)
    if n < 2 or k >= n // 2:
        return sum(max(prices[i], prices[i - 1]) for i in range(1, n))
    
    buy = [[0] * n for _ in range(k + 1)]
    sell = [[0] * n for _ in range(k + 1)]
    
    for i in range(1, k + 1):
        max_diff = -prices[0]
        for j in range(1, n):
            max_diff = max(max_diff, sell[i - 1][j - 1] - prices[j])
            sell[i][j] = max(sell[i][j - 1], prices[j] + max_diff)
            buy[i][j] = max(buy[i][j - 1], sell[i - 1][j - 1] - prices[j])
    
    return sell[k][n - 1]
```

### 解析

该函数使用动态规划来解决。定义两个二维数组 `buy` 和 `sell`，其中 `buy[i][j]` 表示在第 `i` 次交易中持有第 `j` 只股票后的最大利润，`sell[i][j]` 表示在第 `i` 次交易中卖出第 `j` 只股票后的最大利润。状态转移方程为：

```
sell[i][j] = max(sell[i][j - 1], prices[j] + buy[i][j - 1])
buy[i][j] = max(buy[i][j - 1], sell[i - 1][j - 1] - prices[j])
```

其中，`max_diff` 表示从最后一次交易开始到第 `j` 天的最大利润差。

## 18. 股票买卖交易的最佳时机

### 题目描述

给定一个整数数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。假设你只能最多同时持有一只股票，设计一个算法来计算你最大利润。

### 输入

整数数组 `prices`。

### 输出

最大利润。

### 示例

```
输入：prices = [7, 1, 5, 3, 6, 4]
输出：5

输入：prices = [7, 6, 4, 3, 1]
输出：0
```

### 解答

```python
def maxProfit(prices):
    max_profit = 0
    for i in range(1, len(prices)):
        profit = prices[i] - prices[i - 1]
        if profit > 0:
            max_profit += profit
    return max_profit
```

### 解析

该函数遍历数组，计算相邻两天的价格差。如果价格差大于 0，说明可以获利，将利润累加到 `max_profit`。遍历结束后，返回 `max_profit`。

## 19. 合并区间

### 题目描述

给定一组区间，合并所有有交集的区间。

### 输入

一组区间，以列表形式给出。

### 输出

合并后的区间列表。

### 示例

```
输入：intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
输出：[[1, 6], [8, 10], [15, 18]]

输入：intervals = [[1, 4], [4, 5]]
输出：[[1, 5]]
```

### 解答

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for interval in intervals[1:]:
        last = merged[-1]
        if last[1] >= interval[0]:
            merged[-1] = [last[0], max(last[1], interval[1])]
        else:
            merged.append(interval)
    return merged
```

### 解析

该函数首先对区间列表进行排序，然后遍历区间列表。对于当前区间，如果它与前一个区间有交集（即前一个区间的结束时间大于或等于当前区间的开始时间），则合并两个区间。如果它们没有交集，则将当前区间添加到结果列表中。最终，返回合并后的区间列表。

## 20. 检查两个字符串是否交换可形成相同的数组

### 题目描述

给定两个字符串 `s1` 和 `s2`，请编写一个函数来检查它们是否可以相互交换某些字符，使其结果相同。

### 输入

字符串 `s1` 和 `s2`。

### 输出

布尔值，如果可以交换字符使两个字符串相同，返回 `true`；否则返回 `false`。

### 示例

```
输入：s1 = "ab", s2 = "ba"
输出：true

输入：s1 = "ab", s2 = "ab"
输出：true

输入：s1 = "aa", s2 = "ab"
输出：false
```

### 解答

```python
def are_equivalent_strings(s1, s2):
    return sorted(s1) == sorted(s2)
```

### 解析

该函数使用排序来判断两个字符串是否可以交换字符使其相同。如果两个字符串的排序后的字符序列相同，则它们可以相互交换字符形成相同的字符串。

## 21. 拼接最大数

### 题目描述

给定一个长度为 `n` 的数字数组 `nums`，请你从中提取所有大于 `5` 的整数并将它们累加起来。

### 输入

整数数组 `nums`。

### 输出

累加后的整数。

### 示例

```
输入：nums = [6, 8, 1, 5, 9, 7]
输出：46

输入：nums = [2, 3, 5, 7]
输出：0
```

### 解答

```python
def maxNumber(nums):
    max_sum = 0
    for i in range(1, len(nums) + 1):
        for j in range(len(nums) - i + 1):
            num = nums[j:j + i]
            max_sum = max(max_sum, sum(num))
    return max_sum
```

### 解析

该函数使用两层循环枚举所有子数组，计算每个子数组的和，并更新 `max_sum`。遍历结束后，返回 `max_sum`。

## 22. 有效的字母异位词

### 题目描述

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `s` 是否是 `t` 的字母异位词。

### 输入

字符串 `s` 和 `t`。

### 输出

布尔值，如果 `s` 是 `t` 的字母异位词，返回 `true`；否则返回 `false`。

### 示例

```
输入：s = "anagram", t = "nagaram"
输出：true

输入：s = "rat", t = "car"
输出：false
```

### 解答

```python
def isAnagram(s, t):
    return sorted(s) == sorted(t)
```

### 解析

该函数使用排序来判断两个字符串是否是字母异位词。如果两个字符串的排序后的字符序列相同，则它们是字母异位词。

## 23. 盒子堆叠

### 题目描述

给定一个由若干个盒子组成的数组。每个盒子 `boxes[i]` = `[widthi, lengthi, heighti]` 表示盒子的宽度，长度和高度。

你需要将所有盒子堆叠在一起，最下面的盒子最大的面积应该朝下，上面每个盒子朝下的面积应该大于下面的盒子。在满足这个条件下，返回可以堆叠的盒子的最大层数。

### 输入

整数数组 `boxes`。

### 输出

可以堆叠的盒子的最大层数。

### 示例

```
输入：boxes = [[3, 2, 5], [2, 2, 4], [5, 1, 2]]
输出：3

输入：boxes = [[1, 2, 2], [2, 2, 3], [2, 3, 3]]
输出：4
```

### 解答

```python
def max_height(boxes):
    boxes.sort(key=lambda x: (x[2], x[1], x[0]))
    n = len(boxes)
    dp = [1] * n
    for i in range(1, n):
        for j in range(i):
            if boxes[i][0] <= boxes[j][0] and boxes[i][1] <= boxes[j][1] and boxes[i][2] <= boxes[j][2]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

### 解析

该函数使用动态规划来计算可以堆叠的盒子的最大层数。首先对盒子数组进行排序，然后定义一个动态规划数组 `dp`，其中 `dp[i]` 表示以盒子 `boxes[i]` 为顶层的最大堆叠层数。遍历数组，对于每个盒子 `i`，遍历之前的盒子 `j`，如果 `boxes[i]` 小于等于 `boxes[j]`，则更新 `dp[i]`。

## 24. 合并同类项

### 题目描述

给定一个含有重复数字的字符串，找出其中不含有重复数字的最长子串的长度。

### 输入

字符串 `s`。

### 输出

不含有重复数字的最长子串的长度。

### 示例

```
输入：s = "abcabcbb"
输出：3

输入：s = "bbbbb"
输出：1

输入：s = "pwwkew"
输出：3
```

### 解答

```python
def length_of_longest_substring(s):
    start = 0
    max_len = 0
    seen = {}
    for end in range(len(s)):
        if s[end] in seen:
            start = max(start, seen[s[end]] + 1)
        max_len = max(max_len, end - start + 1)
        seen[s[end]] = end
    return max_len
```

### 解析

该函数使用滑动窗口来计算不含有重复字符的最长子串的长度。定义一个字典 `seen` 来记录已遍历的字符及其索引。遍历字符串时，如果当前字符已存在于字典中，更新 `start` 指针为当前字符上次出现位置的下一个位置。每次更新 `max_len` 为当前窗口长度。遍历结束后，返回 `max_len`。

## 25. 最长公共子序列

### 题目描述

给定两个字符串 `text1` 和 `text2`，请编写一个函数来计算它们的最长公共子序列的长度。

### 输入

字符串 `text1` 和 `text2`。

### 输出

最长公共子序列的长度。

### 示例

```
输入：text1 = "abcde", text2 = "ace"
输出：3

输入：text1 = "abc", text2 = "abc"
输出：3

输入：text1 = "abc", text2 = "def"
输出：0
```

### 解答

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

### 解析

该函数使用动态规划来计算最长公共子序列的长度。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。状态转移方程为：

```
if text1[i - 1] == text2[j - 1]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```

遍历结束后，返回 `dp[m][n]`。

## 26. 最小路径和

### 题目描述

给定一个包含非负整数的二维数组 `grid`，找出从左上角到右下角的最小路径和。

### 输入

二维数组 `grid`。

### 输出

最小路径和。

### 示例

```
输入：
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]

输出：
7

输入：
grid = [
    [1, 2, 3],
    [4, 5, 6]
]

输出：
12
```

### 解答

```python
def min_path_sum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j - 1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    return grid[-1][-1]
```

### 解析

该函数使用动态规划来计算最小路径和。首先将第一行和第一列的每个元素累加前一个元素的值，然后遍历其他元素，将每个元素的值累加最小路径和。遍历结束后，返回右下角的元素值。

## 27. 螺旋矩阵

### 题目描述

给定一个 `n x n` 的二维矩阵 `matrix`，按照顺时针螺旋顺序返回矩阵中的所有元素。

### 输入

二维矩阵 `matrix`。

### 输出

螺旋矩阵中的所有元素，以列表形式给出。

### 示例

```
输入：
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

输出：
[1, 2, 3, 6, 9, 8, 7, 4, 5]

输入：
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

输出：
[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]
```

### 解答

```python
def spiral_order(matrix):
    if not matrix:
        return []
    m, n = len(matrix), len(matrix[0])
    seen = [[False] * n for _ in range(m)]
    ans = []
    top, bottom, left, right = 0, m - 1, 0, n - 1
    while len(ans) < m * n:
        for j in range(left, right + 1):
            if not seen[top][j]:
                ans.append(matrix[top][j])
                seen[top][j] = True
        top += 1
        for i in range(top, bottom + 1):
            if not seen[i][right]:
                ans.append(matrix[i][right])
                seen[i][right] = True
        right -= 1
        for j in range(right, left - 1, -1):
            if not seen[bottom][j]:
                ans.append(matrix[bottom][j])
                seen[bottom][j] = True
        bottom -= 1
        for i in range(bottom, top - 1, -1):
            if not seen[i][left]:
                ans.append(matrix[i][left])
                seen[i][left] = True
        left += 1
    return ans
```

### 解析

该函数使用四个指针 `top`、`bottom`、`left` 和 `right` 来定义矩阵的四个边界。首先遍历最上方的行，然后遍历最右侧的列，接着遍历最下方的行，最后遍历最左侧的列。每次遍历结束后，更新边界指针。遍历结束后，返回螺旋矩阵中的所有元素。

## 28. 打家劫舍 III

### 题目描述

在第一题的基础上，给定一个树形的房屋结构。每个节点表示一个房间，节点的值是该房间的偷窃金额。你需要在不触动警报装置的情况下，计算出你能够偷窃到的最大金额。

### 输入

树形结构的节点数组。

### 输出

最大偷窃金额。

### 示例

```
输入：
[3, 2, 3, nil, 3, 1, 3, nil, nil, nil, nil]

输出：
7

解释：
    偷窃房屋的结构如下：
    [
        [3, 2, 3, nil, 3, 1, 3],
        [nil, nil, nil, nil, nil],
        [3, 3, nil]
    ]
    在这个例子中，你可以从房子 3 开始，先偷窃 3，然后偷窃 3（在中间房子），最后偷窃 3（在最后房子）。
```

### 解答

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def rob(root):
    def dfs(root):
        if root is None:
            return 0, 0
        left, right = dfs(root.left), dfs(root.right)
        return max(root.val + left + right, left, right)

    return dfs(root)[0]
```

### 解析

该函数使用递归和动态规划来计算最大偷窃金额。定义一个辅助函数 `dfs`，它接受一个节点作为输入，返回两个值：

1. 如果选择偷窃当前节点，则当前节点和子节点的偷窃金额之和。
2. 如果不选择偷窃当前节点，则子节点的偷窃金额之和。

递归遍历整个树，返回根节点的第一个值，即最大偷窃金额。

## 29. 最长回文子串

### 题目描述

给定一个字符串 `s`，找到其最长的回文子串。

### 输入

字符串 `s`。

### 输出

最长的回文子串。

### 示例

```
输入：s = "babad"
输出："bab"

解释："bab" 是一个回文串，而 "aba" 不是。

输入：s = "cbbd"
输出："bb"

解释："bb" 是一个回文串，而 "cc" 不是。
```

### 解答

```python
def longest_palindromic_substring(s):
    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1: right]

    start, end = 0, 0
    for i in range(len(s)):
        len1 = expand_around_center(i, i)
        len2 = expand_around_center(i, i + 1)
        max_len = max(len1, len2)
        if max_len > end - start:
            start = i - (max_len - 1) // 2
            end = i + max_len // 2

    return s[start: end + 1]
```

### 解析

该函数使用中心扩散法来寻找最长的回文子串。定义一个辅助函数 `expand_around_center`，它接受两个索引 `left` 和 `right`，然后向两边扩展，直到不再匹配。主函数遍历字符串，对于每个字符，分别考虑它作为中心点的情况（奇数长度的回文子串）和它和下一个字符作为中心点的情况（偶数长度的回文子串）。更新 `start` 和 `end` 指针以跟踪最长回文子串的起始和结束位置。

## 30. 合并两个有序链表

### 题目描述

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

### 输入

两个有序链表 `l1` 和 `l2`。

### 输出

合并后的有序链表。

### 示例

```
输入：l1 = [1, 2, 4], l2 = [1, 3, 4]
输出：[1, 1, 2, 3, 4, 4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

### 解答

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode()
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

### 解析

该函数使用虚拟头节点（`dummy`）来构建新的链表。定义一个当前节点（`current`），在两个链表中遍历并比较当前节点的值。将较小的值添加到新链表中，并移动相应链表的指针。遍历结束后，将剩余的一个链表连接到新链表的末尾。返回新链表的头节点。

## 题库总结

通过上述题库示例，我们可以看到，这些题目覆盖了数据结构、算法、动态规划、递归、排序等多个领域，具有代表性且在实际面试中高频出现。这些题目不仅考查了候选人的编程能力，还考察了对数据结构和算法的理解和应用能力。在面试中，解决这些题目需要良好的逻辑思维、代码实现能力和对时间复杂度和空间复杂度的分析能力。希望这些题目能够帮助候选人更好地准备面试。同时，这些题目的解答和解析也提供了详细的思路和实现方法，有助于候选人深入理解和掌握。|markdown|<|json dismantle|>:
```json
[
  {
    "title": "判断字符串是否唯一",
    "description": "请实现一个函数，判断字符串中的所有字符是否只出现一次。",
    "input": "字符串 `s`",
    "output": "布尔值，如果字符串中的所有字符只出现一次，返回 `true`；否则返回 `false`。",
    "example": {
      "input1": "abracadabra",
      "output1": "false",
      "input2": "abcdef",
      "output2": "true"
    },
    "answer": "```python\ndef is_unique(s: str) -> bool:\n    char_set = set()\n    for char in s:\n        if char in char_set:\n            return False\n        char_set.add(char)\n    return True\n```",
    "explanation": "该函数使用一个集合（`set`）来存储已遍历的字符。遍历字符串时，如果当前字符已存在于集合中，说明字符串中的字符不唯一，直接返回 `false`。如果遍历完整个字符串后，集合中的字符数量等于字符串长度，则说明字符串中的所有字符只出现一次，返回 `true`。"
  },
  {
    "title": "两数之和",
    "description": "给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。",
    "input": "整数数组 `nums` 和目标值 `target`",
    "output": "整数数组，包含两个元素，分别表示两个数的位置，如果找不到满足条件的两个数，返回空数组。",
    "example": {
      "input1": "[2, 7, 11, 15], 9",
      "output1": "[0, 1]",
      "input2": "[3, 2, 4], 6",
      "output2": "[1, 2]"
    },
    "answer": "```python\ndef two_sum(nums, target):\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []\n```",
    "explanation": "该函数使用一个字典（`num_dict`）来存储已遍历的数字及其索引。遍历数组时，计算目标值与当前数的差值（`complement`），如果差值存在于字典中，说明已经找到了满足条件的两个数，返回差值在字典中的索引和当前索引。如果遍历完整个数组后仍未找到满足条件的两个数，返回空数组。"
  },
  {
    "title": "无重复字符的最长子串",
    "description": "给定一个字符串 `s` ，请你找出其中不含有重复字符的最长子串 `T` 的长度。",
    "input": "字符串 `s`",
    "output": "整数，表示不含有重复字符的最长子串的长度。",
    "example": {
      "input1": "abcabcbb",
      "output1": "3",
      "input2": "bbbbb",
      "output2": "1",
      "input3": "pwwkew",
      "output3": "3"
    },
    "answer": "```python\ndef length_of_longest_substring(s: str) -> int:\n    start = 0\n    max_len = 0\n    seen = {}\n    for end in range(len(s)):\n        if s[end] in seen:\n            start = max(start, seen[s[end]] + 1)\n        max_len = max(max_len, end - start + 1)\n        seen[s[end]] = end\n    return max_len\n```",
    "explanation": "该函数使用一个滑动窗口（由 `start` 和 `end` 指针定义）来遍历字符串。通过一个字典（`seen`）来记录已遍历的字符及其索引。如果当前字符已存在于字典中，更新 `start` 指针为当前字符上次出现位置的下一个位置。每次更新 `max_len` 为当前窗口长度。遍历完整个字符串后，返回 `max_len`。"
  },
  {
    "title": "合并两个有序链表",
    "description": "将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。",
    "input": "两个有序链表 `l1` 和 `l2`",
    "output": "合并后的有序链表。",
    "example": {
      "input1": "[1, 2, 4], [1, 3, 4]",
      "output1": "[1, 1, 2, 3, 4, 4]",
      "input2": "[], []",
      "output2": "[]",
      "input3": "[], [0]",
      "output3": "[0]"
    },
    "answer": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_sorted_lists(l1, l2):\n    dummy = ListNode()\n    current = dummy\n    while l1 and l2:\n        if l1.val < l2.val:\n            current.next = l1\n            l1 = l1.next\n        else:\n            current.next = l2\n            l2 = l2.next\n        current = current.next\n    current.next = l1 or l2\n    return dummy.next\n```",
    "explanation": "该函数使用虚拟头节点（`dummy`）和一个当前节点（`current`）来构建新的链表。遍历两个链表，每次比较两个链表当前节点的值，将较小的值添加到新链表中。遍历结束后，将剩余的一个链表连接到新链表的末尾。返回新链表的头节点。"
  },
  {
    "title": "反转链表",
    "description": "定义一个函数，该函数接收一个链表的头节点，并返回链表反转后的头节点。",
    "input": "链表的头节点",
    "output": "反转后的链表的头节点。",
    "example": {
      "input1": "[1, 2, 3, 4, 5]",
      "output1": "[5, 4, 3, 2, 1]",
      "input2": "[1]",
      "output2": "[1]"
    },
    "answer": "```python\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_linked_list(head):\n    prev = None\n    current = head\n    while current:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n```",
    "explanation": "该函数使用一个虚拟头节点（`prev`）和一个当前节点（`current`）来反转链表。遍历链表时，每次将当前节点的 `next` 指针指向前一个节点（`prev`），然后将 `prev` 和 `current` 分别向前移动一位。遍历结束后，返回 `prev`，即新的链表头节点。"
  },
  {
    "title": "字符串相乘",
    "description": "给定两个字符串表示的非负整数 `num1` 和 `num2`，返回由它们相乘得到的字符串表示的非负整数。",
    "input": "字符串 `num1` 和 `num2`",
    "output": "字符串表示的非负整数。",
    "example": {
      "input1": "\"2\", \"3\"",
      "output1": "\"6\"",
      "input2": "\"123\", \"456\"",
      "output2": "\"56088\""
    },
    "answer": "```python\ndef multiply(num1, num2):\n    m, n = len(num1), len(num2)\n    if m > n:\n        num1, num2 = num2, num1\n        m, n = n, m\n    res = [0] * (m + n)\n    i, j = 0, 0\n    while i < m and j < n:\n        res[i + j] += int(num1[i]) * int(num2[j])\n        res[i + j + 1] += res[i + j] // 10\n        res[i + j] %= 10\n        i += 1\n        j += 1\n    while i < m:\n        res[i + j] += int(num1[i]) * int(num2[0])\n        res[i + j + 1] += res[i + j] // 10\n        res[i + j] %= 10\n        i += 1\n    while j < n:\n        res[i + j] += int(num1[0]) * int(num2[j])\n        res[i + j + 1] += res[i + j] // 10\n        res[i + j] %= 10\n        j += 1\n    while res[-1] == 0:\n        res.pop()\n    return ''.join(map(str, res[::-1]))\n```",
    "explanation": "该函数将两个字符串转换为整数，然后按照整数乘法的规则进行计算。将乘积的每一位存储在一个列表（`res`）中，从最低位到最高位。在计算过程中，如果乘积超过 10，则向前进位。最后，将列表转换为字符串并返回。"
  },
  {
    "title": "搜索二维矩阵",
    "description": "编写一个高效的算法来搜索一个二维矩阵。矩阵中的整数按升序排列，每行中的整数从左到右按升序排列，每列中的整数从上到下按升序排列。",
    "input": "二维矩阵 `matrix` 和目标值 `target`",
    "output": "布尔值，如果矩阵中存在目标值，返回 `true`；否则返回 `false`。",
    "example": {
      "input1": "[[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 3",
      "output1": "true",
      "input2": "[[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]], 13",
      "output2": "false"
    },
    "answer": "```python\ndef search_matrix(matrix, target):\n    row, col = 0, len(matrix[0]) - 1\n    while row < len(matrix) and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col] < target:\n            row += 1\n        else:\n            col -= 1\n    return False\n```",
    "explanation": "该函数使用一个类似于二分查找的算法来搜索矩阵。从左下角（`row = 0, col = len(matrix[0]) - 1`）开始，如果当前元素等于目标值，返回 `true`。如果当前元素小于目标值，说明目标值可能在下一行，因此行指针 `row` 向上移动。如果当前元素大于目标值，说明目标值可能在上一列，因此列指针 `col` 向左移动。遍历结束后，如果未找到目标值，返回 `false`。"
  },
  {
    "title": "盘点收获",
    "description": "假设你是一名农场主人，有一块面积为 `N x M` 的田地，你需要在田地上种植作物。田地上的每个位置都有一个收获值，你可以选择任意形状的田地来种植作物，但每种植一次，田地上的收获值就会减半。你的目标是最大化总收获值。",
    "input": "一个二维数组 `grid`，表示田地上的收获值。",
    "output": "一个整数，表示最大收获值。",
    "example": {
      "input1": "[
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
      ]",
      "output1": "9"
    },
    "answer": "```python\ndef max_profit(grid):\n    m, n = len(grid), len(grid[0])\ndp = [[0] * (n+1) for _ in range(m+1)]\n    
    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = max(\n                dp[i-1][j],  # 不种植当前行\n                dp[i][j-1],  # 不种植当前列\n                dp[i-1][j-1] + grid[i-1][j-1]  # 种植当前行和列\n            )\n    return dp[-1][-1]\n```",
    "explanation": "该问题可以使用动态规划来解决。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示种植到第 `i` 行和第 `j` 列时的最大收获值。状态转移方程为：\n```\n    dp[i][j] = max(\n        dp[i-1][j],  # 不种植当前行\n        dp[i][j-1],  # 不种植当前列\n        dp[i-1][j-1] + grid[i-1][j-1]  # 种植当前行和列\n    )\n```\n最终，`dp[m][n]` 就是最大收获值。"
  },
  {
    "title": "合并区间",
    "description": "给定一组区间，请合并所有有交集的区间。",
    "input": "一组区间，以列表形式给出。",
    "output": "合并后的区间列表。",
    "example": {
      "input1": "[[1, 3], [2, 6], [8, 10], [15, 18]]",
      "output1": "[[1, 6], [8, 10], [15, 18]]",
      "input2": "[[1, 4], [4, 5]]",
      "output2": "[[1, 5]]"
    },
    "answer": "```python\ndef merge(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for interval in intervals[1:]\n        last = merged[-1]\n        if last[1] >= interval[0]:\n            merged[-1] = [last[0], max(last[1], interval[1])]\n        else:\n            merged.append(interval)\n    return merged\n```",
    "explanation": "该函数首先对区间列表进行排序，然后遍历区间列表。对于当前区间，如果它与前一个区间有交集（即前一个区间的结束时间大于或等于当前区间的开始时间），则合并两个区间。如果它们没有交集，则将当前区间添加到结果列表中。最终，返回合并后的区间列表。"
  },
  {
    "title": "打家劫舍",
    "description": "你是一个小偷，计划偷窃沿街的房屋。每间房屋装有防盗系统，如果你相邻的房屋被盗窃，系统会自动报警。计算你最多能偷窃多少金额。",
    "input": "一个整数数组 `nums`，表示每间房屋的金额。",
    "output": "最多能偷窃的金额。",
    "example": {
      "input1": "[1, 2, 3, 1]",
      "output1": "4",
      "input2": "[2, 7, 9, 3, 1]",
      "output2": "12"
    },
    "answer": "```python\ndef rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    return max(rob(nums[:-1]), rob(nums[:-2]) + nums[-1])\n```",
    "explanation": "该问题可以使用递归和记忆化搜索来解决。定义一个函数 `rob`，它接受一个整数数组 `nums` 作为输入，返回最多能偷窃的金额。状态转移方程为：\n```\n    rob(nums) = max(\n        rob(nums[:-1]),  # 不偷取最后一个元素\n        rob(nums[:-2]) + nums[-1]  # 偷取最后一个元素\n    )\n```\n递归的基例是当 `nums` 为空时，返回 0；当 `nums` 只有一个元素时，返回该元素。"
  },
  {
    "title": "买卖股票的最佳时机 III",
    "description": "给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。假设你在每一天均可买入和卖出一次股票。设计一个算法来计算你所能获取的最大利润。",
    "input": "整数数组 `prices`",
    "output": "所能获取的最大利润。",
    "example": {
      "input1": "[3, 3, 6, 5, 0, 3, 1, 4]",
      "output1": "6",
      "input2": "[1, 2, 3, 4, 5]",
      "output2": "4"
    },
    "answer": "```python\n
```

