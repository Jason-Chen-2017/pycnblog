                 

### 主题：像数学家一样思考：模拟原则

### 1. 数组中重复的数字

**题目：** 在一个长度为 n 的数组 nums 中，所有的数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，需要找出所有重复的数字。

**答案：** 使用哈希表记录每个数字出现的次数，遍历数组，将每个数字及其出现次数加入哈希表。如果哈希表中已存在该数字，则将其添加到结果列表中。

**示例代码：**

```python
def findDuplicates(nums):
    counts = {}
    duplicates = []
    for num in nums:
        if num in counts:
            duplicates.append(num)
        else:
            counts[num] = 1
    return duplicates
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)。

### 2. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，找出它们的最长公共子序列。

**答案：** 使用动态规划求解。定义一个二维数组 dp，其中 dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度。

**示例代码：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]
```

**解析：** 该算法的时间复杂度为 O(m*n)，空间复杂度为 O(m*n)。

### 3. 删除链表的节点

**题目：** 给定一个单链表的头节点 head 和一个整数 val，删除链表中值为 val 的节点。

**答案：** 使用快慢指针遍历链表，找到值为 val 的节点，将其前一个节点的 next 指针指向当前节点的下一个节点。

**示例代码：**

```python
def deleteNode(head, val):
    if not head or head.val == val:
        return head

    prev = head
    curr = head.next
    while curr:
        if curr.val == val:
            prev.next = curr.next
            break
        prev = curr
        curr = curr.next

    return head
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

### 4. 二分查找

**题目：** 给定一个无重复元素的有序数组 nums，找到目标值 target 的索引。

**答案：** 使用二分查找算法。初始化左边界 left 和右边界 right，当 left 小于等于 right 时，计算中间索引 mid，比较 target 与 nums[mid] 的大小关系，更新 left 或 right。

**示例代码：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 该算法的时间复杂度为 O(logn)，空间复杂度为 O(1)。

### 5. 合并两个有序链表

**题目：** 给定两个有序链表 list1 和 list2，合并它们为一个新的有序链表。

**答案：** 使用递归或迭代方法，比较两个链表的头节点，选择较小的一个作为新的头节点，将另一个链表的剩余部分递归或迭代地合并到新链表中。

**示例代码（递归）：**

```python
def mergeTwoLists(list1, list2):
    if not list1:
        return list2
    if not list2:
        return list1
    if list1.val < list2.val:
        list1.next = mergeTwoLists(list1.next, list2)
        return list1
    else:
        list2.next = mergeTwoLists(list1, list2.next)
        return list2
```

**示例代码（迭代）：**

```python
def mergeTwoLists(list1, list2):
    dummy = ListNode(0)
    prev = dummy
    while list1 and list2:
        if list1.val < list2.val:
            prev.next = list1
            list1 = list1.next
        else:
            prev.next = list2
            list2 = list2.next
        prev = prev.next
    prev.next = list1 or list2
    return dummy.next
```

**解析：** 该算法的时间复杂度为 O(n+m)，空间复杂度为 O(1)。

### 6. 判断二叉树是否对称

**题目：** 给定一棵二叉树 root，判断它是否对称。

**答案：** 使用递归或迭代方法，比较左右子树是否镜像对称。递归方法可以递归地比较当前节点的左右子节点，迭代方法可以使用栈或队列实现。

**示例代码（递归）：**

```python
def isSymmetric(root):
    if not root:
        return True
    return isMirror(root.left, root.right)

def isMirror(left, right):
    if not left and not right:
        return True
    if not left or not right:
        return False
    if left.val != right.val:
        return False
    return isMirror(left.left, right.right) and isMirror(left.right, right.left)
```

**示例代码（迭代）：**

```python
def isSymmetric(root):
    if not root:
        return True
    stack = [(root.left, root.right)]
    while stack:
        left, right = stack.pop()
        if not left and not right:
            continue
        if not left or not right:
            return False
        if left.val != right.val:
            return False
        stack.append((left.left, right.right))
        stack.append((left.right, right.left))
    return True
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)。

### 7. 求最大子序和

**题目：** 给定一个整数数组 nums，找出整个数组的最大和。

**答案：** 使用动态规划或贪心算法。动态规划方法定义一个数组 dp，其中 dp[i] 表示以 nums[i] 为结尾的最大子序和。贪心算法方法在遍历数组时维护一个变量 sum，记录当前子序和的最大值。

**示例代码（动态规划）：**

```python
def maxSubArray(nums):
    dp = [0] * len(nums)
    dp[0] = nums[0]
    max_sum = dp[0]
    for i in range(1, len(nums)):
        dp[i] = max(nums[i], dp[i-1] + nums[i])
        max_sum = max(max_sum, dp[i])
    return max_sum
```

**示例代码（贪心算法）：**

```python
def maxSubArray(nums):
    max_sum = nums[0]
    sum = 0
    for num in nums:
        sum = max(num, sum + num)
        max_sum = max(max_sum, sum)
    return max_sum
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n) 或 O(1)。

### 8. 排序算法

**题目：** 实现快速排序、归并排序、堆排序等排序算法。

**答案：** 快速排序、归并排序和堆排序都是常见的排序算法，它们的实现方式如下：

**快速排序：**

```python
def quicksort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]
    return quicksort(left) + middle + quicksort(right)
```

**归并排序：**

```python
def mergeSort(nums):
    if len(nums) <= 1:
        return nums
    mid = len(nums) // 2
    left = mergeSort(nums[:mid])
    right = mergeSort(nums[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

**堆排序：**

```python
def heapify(nums, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and nums[left] > nums[largest]:
        largest = left

    if right < n and nums[right] > nums[largest]:
        largest = right

    if largest != i:
        nums[i], nums[largest] = nums[largest], nums[i]
        heapify(nums, n, largest)

def heapSort(nums):
    n = len(nums)

    for i in range(n // 2 - 1, -1, -1):
        heapify(nums, n, i)

    for i in range(n - 1, 0, -1):
        nums[i], nums[0] = nums[0], nums[i]
        heapify(nums, i, 0)

    return nums
```

**解析：** 快速排序的时间复杂度为 O(nlogn)，归并排序的时间复杂度为 O(nlogn)，堆排序的时间复杂度为 O(nlogn)。空间复杂度分别为 O(logn)、O(n) 和 O(1)。

### 9. 求二进制表示中 1 的个数

**题目：** 给定一个无符号整数 n，求其二进制表示中 1 的个数。

**答案：** 使用位操作。将 n 与 1 进行按位与操作，如果结果为 1，则计数器加 1，然后将 n 右移 1 位。重复这个过程，直到 n 为 0。

**示例代码：**

```python
def hammingWeight(n):
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count
```

**解析：** 该算法的时间复杂度为 O(logn)，空间复杂度为 O(1)。

### 10. 最长公共前缀

**题目：** 给定一个字符串数组 strs，找出其中最长的公共前缀。

**答案：** 使用横向比较法。从第一个字符串的每个字符开始，与其他字符串的对应位置的字符进行比较，如果所有字符串在该位置的字符相同，则继续比较下一个字符；否则，返回当前公共前缀。

**示例代码：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        ch = strs[0][i]
        for j in range(1, len(strs)):
            if i >= len(strs[j]) or strs[j][i] != ch:
                return prefix
        prefix += ch
    return prefix
```

**解析：** 该算法的时间复杂度为 O(m*n)，空间复杂度为 O(1)，其中 m 是最短字符串的长度，n 是字符串的个数。

### 11. 字符串替换

**题目：** 给定一个字符串 s 和一个字符串列表 words，将 words 中的每个字符串替换为它出现的第一个字母的大写形式，并返回新的字符串。

**答案：** 使用哈希表记录每个单词出现的第一个字母，遍历字符串 s，将每个字符替换为其对应的字母大写形式。

**示例代码：**

```python
def replaceWords(words, s):
    first_letters = {}
    for word in words:
        first_letters[word[0].upper()] = word
    result = []
    i = 0
    while i < len(s):
        ch = s[i].upper()
        if ch in first_letters:
            result.append(first_letters[ch])
            i += len(first_letters[ch])
        else:
            result.append(s[i])
            i += 1
    return ''.join(result)
```

**解析：** 该算法的时间复杂度为 O(n+m)，空间复杂度为 O(m)，其中 n 是字符串 s 的长度，m 是单词列表 words 的长度。

### 12. 股票买卖

**题目：** 给定一个整数数组 prices，其中 prices[i] 是第 i 天股票的价格。如果可以在第 i 天买入股票并在第 j 天（i < j）卖出股票，且能获得利润，返回最大的利润。如果不能获得利润，返回 0。

**答案：** 使用动态规划方法。定义一个数组 dp，其中 dp[i] 表示在第 i 天结束时的最大利润。每次更新 dp[i] 时，遍历前面的所有天数，找出最小的价格 dp[j]，计算 dp[i] = max(dp[i-1], prices[i]-dp[j])。

**示例代码：**

```python
def maxProfit(prices):
    n = len(prices)
    dp = [0] * n
    min_price = prices[0]
    for i in range(1, n):
        dp[i] = max(dp[i-1], prices[i]-min_price)
        min_price = min(min_price, prices[i])
    return dp[-1]
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)。

### 13. 二叉树的层序遍历

**题目：** 给定一个二叉树，按层序遍历它的节点值。

**答案：** 使用广度优先搜索（BFS）方法。初始化一个队列，将根节点入队。然后遍历队列，依次将每个节点的子节点入队，并记录当前层的节点值。

**示例代码：**

```python
from collections import deque

def levelOrder(root):
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        result.append(level)
    return result
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是二叉树的节点数。

### 14. 合并两个有序链表

**题目：** 给定两个有序链表 list1 和 list2，合并它们为一个新的有序链表。

**答案：** 使用递归或迭代方法。比较两个链表的头节点，选择较小的一个作为新的头节点，将另一个链表的剩余部分递归或迭代地合并到新链表中。

**示例代码（递归）：**

```python
def mergeTwoLists(list1, list2):
    if not list1:
        return list2
    if not list2:
        return list1
    if list1.val < list2.val:
        list1.next = mergeTwoLists(list1.next, list2)
        return list1
    else:
        list2.next = mergeTwoLists(list1, list2.next)
        return list2
```

**示例代码（迭代）：**

```python
def mergeTwoLists(list1, list2):
    dummy = ListNode(0)
    prev = dummy
    while list1 and list2:
        if list1.val < list2.val:
            prev.next = list1
            list1 = list1.next
        else:
            prev.next = list2
            list2 = list2.next
        prev = prev.next
    prev.next = list1 or list2
    return dummy.next
```

**解析：** 该算法的时间复杂度为 O(n+m)，空间复杂度为 O(1)，其中 n 和 m 分别是两个链表的长度。

### 15. 最长回文子串

**题目：** 给定一个字符串 s，找到其中最长的回文子串。

**答案：** 使用动态规划方法。定义一个二维数组 dp，其中 dp[i][j] 表示 s 的第 i 个字符到第 j 个字符的子串是否为回文串。初始化 dp[i][i] 为 True，dp[i][i+1] 为 s[i] == s[i+1]。

**示例代码：**

```python
def longestPalindrome(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    start = 0
    max_len = 1
    for i in range(n):
        dp[i][i] = True
        if i < n - 1 and s[i] == s[i+1]:
            dp[i][i+1] = True
            start = i
            max_len = 2
    for i in range(n-1, -1, -1):
        for j in range(i+1, n):
            if s[i] == s[j]:
                if j - i == 1 or dp[i+1][j-1]:
                    dp[i][j] = True
                    if j - i + 1 > max_len:
                        start = i
                        max_len = j - i + 1
    return s[start:start+max_len]
```

**解析：** 该算法的时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。

### 16. 找出第 k 个最大的元素

**题目：** 给定一个整数数组 nums 和一个整数 k，找出数组中第 k 个最大的元素。

**答案：** 使用快速选择算法。从数组中随机选择一个索引 p，如果 p 的位置上的元素是第 k 个最大的元素，则返回它；否则，如果 p 的位置上的元素大于第 k 个最大的元素，则在数组的前 p 个元素中继续查找；否则，在数组的后 n-p 个元素中继续查找。

**示例代码：**

```python
import random

def findKthLargest(nums, k):
    n = len(nums)
    while True:
        p = random.randint(0, n-1)
        if nums[p] >= nums[k-1]:
            left = 0
            right = k-1
            while left < right:
                mid = (left + right) // 2
                if nums[mid] >= nums[p]:
                    right = mid
                else:
                    left = mid + 1
            if left == k-1:
                return nums[p]
            else:
                k = k - (left + 1)
        else:
            n = p
    return None
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

### 17. 最小路径和

**题目：** 给定一个整数矩阵 grid，从左上角开始，找到达到右下角的最小路径和。每个元素只能向右或向下移动一次。

**答案：** 使用动态规划方法。定义一个二维数组 dp，其中 dp[i][j] 表示从 (0,0) 到 (i,j) 的最小路径和。初始化 dp[0][0] 为 grid[0][0]，然后根据 dp[i-1][j] 和 dp[i][j-1] 的值更新 dp[i][j]。

**示例代码：**

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i-1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j-1] + grid[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    return dp[-1][-1]
```

**解析：** 该算法的时间复杂度为 O(m*n)，空间复杂度为 O(m*n)。

### 18. 盛水最多的容器

**题目：** 给定一个整数数组 height，表示容器的高度，求容器能容纳的最大水量。

**答案：** 使用双指针方法。初始化两个指针 left 和 right，分别指向容器的左右边界。然后根据 height[left] 和 height[right] 的值更新最大水量。如果 height[left] 小于 height[right]，则移动 left 指针；否则，移动 right 指针。

**示例代码：**

```python
def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(height[left], height[right]) * (right - left))
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

### 19. 拼接最大数

**题目：** 给定一个整数数组 nums 和一个整数 k，拼接 nums 中的连续 k 个数字，找出拼接后得到最大数字。如果拼接后的数字不存在，返回 -1。

**答案：** 使用贪心算法。从最大的数字开始拼接，每次拼接 k-1 个数字。如果拼接后的数字比当前最大数字小，则继续拼接；否则，记录当前最大数字，并继续拼接。

**示例代码：**

```python
from functools import cmp_to_key

def maxNumber(nums1, nums2, k):
    def merge(nums1, nums2):
        result = []
        i, j = 0, 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] > nums2[j]:
                result.append(nums1[i])
                i += 1
            elif nums1[i] < nums2[j]:
                result.append(nums2[j])
                j += 1
            else:
                if len(nums1) - i > len(nums2) - j:
                    result.append(nums1[i])
                    i += 1
                else:
                    result.append(nums2[j])
                    j += 1
        result.extend(nums1[i:])
        result.extend(nums2[j:])
        return ''.join(map(str, result))

    def compare(nums1, nums2):
        return (int(merge(nums1, nums2)) > int(merge(nums2, nums1))) - (int(merge(nums1, nums2)) < int(merge(nums2, nums1)))

    max_num = -1
    for i in range(max(0, len(nums1)-k), min(len(nums1), k)+1):
        for j in range(max(0, len(nums2)-k), min(len(nums2), k)+1):
            cur = merge(nums1[:i], nums2[:j])
            if compare(cur, str(max_num)) > 0:
                max_num = cur
    return max_num
```

**解析：** 该算法的时间复杂度为 O((m+n)^(k-1))，空间复杂度为 O(k)。

### 20. 删除链表的节点

**题目：** 给定一个单链表的头节点 head 和一个整数 val，删除链表中值为 val 的节点。

**答案：** 使用快慢指针遍历链表，找到值为 val 的节点，将其前一个节点的 next 指针指向当前节点的下一个节点。

**示例代码：**

```python
def deleteNode(head, val):
    if not head or head.val == val:
        return head

    prev = head
    curr = head.next
    while curr:
        if curr.val == val:
            prev.next = curr.next
            break
        prev = curr
        curr = curr.next

    return head
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

### 21. 寻找两个正序数组的中位数

**题目：** 给定两个已经排序好的整数数组 nums1 和 nums2，找出这两个数组的中位数。

**答案：** 使用二分查找法。在两个数组中分别查找中位数，然后比较中位数的大小，根据比较结果继续在其中一个数组中查找。

**示例代码：**

```python
def findMedianSortedArrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2 = nums2, nums1
        m, n = n, m

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j-1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j-1]
            elif j == 0:
                max_of_left = nums1[i-1]
            else:
                max_of_left = max(nums1[i-1], nums2[j-1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m:
                min_of_right = nums2[j]
            elif j == n:
                min_of_right = nums1[i]
            else:
                min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2
```

**解析：** 该算法的时间复杂度为 O(log(min(m, n)))，空间复杂度为 O(1)。

### 22. 两个数组的交集 II

**题目：** 给定两个整数数组 nums1 和 nums2，返回 nums1 和 nums2 的交集。每个元素最多出现在交集里两次。

**答案：** 使用哈希表记录 nums2 中每个元素出现的次数，然后遍历 nums1，根据哈希表更新交集的结果。

**示例代码：**

```python
def intersect(nums1, nums2):
    counts = {}
    for num in nums2:
        counts[num] = counts.get(num, 0) + 1

    result = []
    for num in nums1:
        if counts.get(num, 0) > 0:
            result.append(num)
            counts[num] -= 1
    return result
```

**解析：** 该算法的时间复杂度为 O(m+n)，空间复杂度为 O(n)，其中 m 和 n 分别是 nums1 和 nums2 的长度。

### 23. 两数相加

**题目：** 给定两个非空链表，表示两个非负整数，每个节点包含一个数字。对这两个链表进行求和，返回结果链表。

**答案：** 使用链表法。定义一个哑节点作为结果链表的头节点，然后遍历两个链表，逐位相加，并更新进位。

**示例代码：**

```python
def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        curr.next = ListNode((val1 + val2 + carry) % 10)
        carry = (val1 + val2 + carry) // 10
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
        curr = curr.next

    return dummy.next
```

**解析：** 该算法的时间复杂度为 O(max(m, n))，空间复杂度为 O(1)，其中 m 和 n 分别是 l1 和 l2 的长度。

### 24. 有效的括号

**题目：** 给定一个包含括号的字符串，判断其是否有效。有效括号的定义是：左括号必须用相同类型的右括号闭合，左右括号必须正确闭合。

**答案：** 使用栈。遍历字符串，如果遇到左括号，将其入栈；如果遇到右括号，检查栈顶元素是否与之匹配，如果不匹配则返回 False。遍历结束后，如果栈为空，则返回 True。

**示例代码：**

```python
def isValid(s):
    stack = []
    pairs = {')': '(', ']': '[', '}': '{'}
    for ch in s:
        if ch in pairs.values():
            if not stack or stack.pop() != pairs[ch]:
                return False
        else:
            stack.append(ch)
    return not stack
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是字符串的长度。

### 25. 合并两个有序链表

**题目：** 给定两个已排序的非空链表，合并它们为一个新的有序链表。

**答案：** 使用递归或迭代方法。比较两个链表的头节点，选择较小的一个作为新的头节点，将另一个链表的剩余部分递归或迭代地合并到新链表中。

**示例代码（递归）：**

```python
def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**示例代码（迭代）：**

```python
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    while l1 and l2:
        if l1.val < l2.val:
            prev.next = l1
            l1 = l1.next
        else:
            prev.next = l2
            l2 = l2.next
        prev = prev.next
    prev.next = l1 or l2
    return dummy.next
```

**解析：** 该算法的时间复杂度为 O(n+m)，空间复杂度为 O(1)，其中 n 和 m 分别是两个链表的长度。

### 26. 两数相加

**题目：** 给定两个整数数组 nums1 和 nums2，表示两个非空链表，每个节点包含一个数字。对这两个链表进行求和，返回结果链表。

**答案：** 使用链表法。定义一个哑节点作为结果链表的头节点，然后遍历两个链表，逐位相加，并更新进位。

**示例代码：**

```python
def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        curr.next = ListNode((val1 + val2 + carry) % 10)
        carry = (val1 + val2 + carry) // 10
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
        curr = curr.next

    return dummy.next
```

**解析：** 该算法的时间复杂度为 O(max(m, n))，空间复杂度为 O(1)，其中 m 和 n 分别是 l1 和 l2 的长度。

### 27. 有效的括号

**题目：** 给定一个包含括号的字符串，判断其是否有效。有效括号的定义是：左括号必须用相同类型的右括号闭合，左右括号必须正确闭合。

**答案：** 使用栈。遍历字符串，如果遇到左括号，将其入栈；如果遇到右括号，检查栈顶元素是否与之匹配，如果不匹配则返回 False。遍历结束后，如果栈为空，则返回 True。

**示例代码：**

```python
def isValid(s):
    stack = []
    pairs = {')': '(', ']': '[', '}': '{'}
    for ch in s:
        if ch in pairs.values():
            if not stack or stack.pop() != pairs[ch]:
                return False
        else:
            stack.append(ch)
    return not stack
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是字符串的长度。

### 28. 合并两个有序链表

**题目：** 给定两个已排序的非空链表，合并它们为一个新的有序链表。

**答案：** 使用递归或迭代方法。比较两个链表的头节点，选择较小的一个作为新的头节点，将另一个链表的剩余部分递归或迭代地合并到新链表中。

**示例代码（递归）：**

```python
def mergeTwoLists(l1, l2):
    if not l1:
        return l2
    if not l2:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**示例代码（迭代）：**

```python
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    while l1 and l2:
        if l1.val < l2.val:
            prev.next = l1
            l1 = l1.next
        else:
            prev.next = l2
            l2 = l2.next
        prev = prev.next
    prev.next = l1 or l2
    return dummy.next
```

**解析：** 该算法的时间复杂度为 O(n+m)，空间复杂度为 O(1)，其中 n 和 m 分别是两个链表的长度。

### 29. 寻找两个正序数组的中位数

**题目：** 给定两个已经排序好的整数数组 nums1 和 nums2，找出这两个数组的中位数。

**答案：** 使用二分查找法。在两个数组中分别查找中位数，然后比较中位数的大小，根据比较结果继续在其中一个数组中查找。

**示例代码：**

```python
def findMedianSortedArrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2 = nums2, nums1
        m, n = n, m

    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j-1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j-1]
            elif j == 0:
                max_of_left = nums1[i-1]
            else:
                max_of_left = max(nums1[i-1], nums2[j-1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m:
                min_of_right = nums2[j]
            elif j == n:
                min_of_right = nums1[i]
            else:
                min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2
```

**解析：** 该算法的时间复杂度为 O(log(min(m, n)))，空间复杂度为 O(1)。

### 30. 无重复字符的最长子串

**题目：** 给定一个字符串 s，找出其中不含有重复字符的最长子串的长度。

**答案：** 使用滑动窗口。定义两个指针 left 和 right，表示窗口的左右边界。当 right 指针移动时，如果窗口中不存在重复字符，则更新 left 指针；否则，移动 left 指针，直到窗口中不存在重复字符。

**示例代码：**

```python
def lengthOfLongestSubstring(s):
    left = 0
    right = 0
    max_len = 0
    seen = set()
    while right < len(s):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        seen.add(s[right])
        max_len = max(max_len, right - left + 1)
        right += 1
    return max_len
```

**解析：** 该算法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是字符串的长度。

