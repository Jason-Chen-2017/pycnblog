                 

### 1. 计算字符串中单词数

**题目：** 编写一个函数，用于计算一个字符串中的单词数。字符串中的单词以空格分隔，且可能包含前导和尾随空格。

**示例：**
```
输入："  Hello, world!  "
输出：5
```

**答案：** 可以通过遍历字符串，使用计数器来记录单词数。需要注意处理空格、前导空格和尾随空格。

```go
func countWords(s string) int {
    count := 0
    inWord := false
    for _, char := range s {
        if char != ' ' {
            if !inWord {
                count++
                inWord = true
            }
        } else {
            inWord = false
        }
    }
    return count
}
```

**解析：** 在遍历字符串时，如果当前字符不是空格且之前没有在单词中，则计数器增加，表示发现了一个新单词。否则，当前字符被忽略。

### 2. 判断一个字符串是否为回文字符串

**题目：** 编写一个函数，用于判断一个字符串是否为回文字符串。

**示例：**
```
输入："madam"
输出：true
```

**答案：** 可以使用双指针法，分别从字符串的两端开始比较字符，直到中间相遇。

```go
func isPalindrome(s string) bool {
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

**解析：** 双指针从字符串的两端开始，如果两个指针指向的字符相同，则继续移动；如果不同，则字符串不是回文字符串。

### 3. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少包含一个数）。

**示例：**
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**答案：** 可以使用动态规划的方法，维护一个当前子序列的最大和 `maxCurrent` 和全局最大和 `maxGlobal`。

```go
func maxSubArray(nums []int) int {
    maxGlobal := nums[0]
    maxCurrent := nums[0]
    for i := 1; i < len(nums); i++ {
        maxCurrent = max(nums[i], maxCurrent+nums[i])
        maxGlobal = max(maxGlobal, maxCurrent)
    }
    return maxGlobal
}
```

**解析：** 遍历数组时，每个元素都可能是新的子序列的开始，因此更新 `maxCurrent` 为当前元素和前一个最大子序列的和中的较大值。同时，更新 `maxGlobal` 为全局最大值。

### 4. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：** 可以使用递归或迭代的方法来合并两个链表。

递归方法：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代方法：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    prev := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            prev.Next = l1
            l1 = l1.Next
        } else {
            prev.Next = l2
            l2 = l2.Next
        }
        prev = prev.Next
    }
    if l1 != nil {
        prev.Next = l1
    } else if l2 != nil {
        prev.Next = l2
    }
    return dummy.Next
}
```

**解析：** 通过比较两个链表当前节点的值，选择较小的值作为下一个节点，并移动相应的链表指针。

### 5. 两个链表的第一个公共节点

**题目：** 给出两个表示链表的指针，找出两个链表的第一个公共节点。

**示例：**
```
输入：headA = [4,1,8,4,5], headB = [5,0,1,8,4,5]
输出：2 -> 8 -> 4
解释：两个链表的第一个公共节点是节点 4。
```

**答案：** 可以先求出两个链表的长度，然后让较长的链表先移动差值个节点，然后两个链表同时遍历，直到找到第一个公共节点。

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    lenA, lenB := 0, 0
    pA, pB := headA, headB
    for pA != nil {
        lenA++
        pA = pA.Next
    }
    for pB != nil {
        lenB++
        pB = pB.Next
    }
    pA, pB = headA, headB
    if lenA > lenB {
        for i := 0; i < lenA-lenB; i++ {
            pA = pA.Next
        }
    } else {
        for i := 0; i < lenB-lenA; i++ {
            pB = pB.Next
        }
    }
    while pA != nil && pB != nil {
        if pA == pB {
            return pA
        }
        pA = pA.Next
        pB = pB.Next
    }
    return nil
}
```

**解析：** 首先计算两个链表的长度，然后让较长的链表先移动差值个节点，两个链表同时遍历，直到找到第一个公共节点或遍历结束。

### 6. 两数相加

**题目：** 给定两个非空链表表示的两个非负整数，每个节点包含一个数字，返回这两个数字表示的整数之和。

**示例：**
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
解释：342 + 465 = 807.
```

**答案：** 可以使用逆序遍历链表的方法，将链表中的数字转换为整数，然后相加。

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    var num1, num2, carry int
    for l1 != nil || l2 != nil {
        if l1 != nil {
            num1 = num1*10 + l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            num2 = num2*10 + l2.Val
            l2 = l2.Next
        }
    }
    sum := num1 + num2 + carry
    carry = sum / 1000
    sum %= 1000
    dummy := &ListNode{Val: sum}
    curr := dummy
    for carry > 0 {
        curr.Next = &ListNode{Val: carry % 1000}
        carry /= 1000
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：** 遍历两个链表，将链表中的数字转换为整数，然后相加。将结果存储在新的链表中。

### 7. 两个数组的交集 II

**题目：** 给定两个整数数组 `nums1` 和 `nums2` ，返回两个数组中的公共元素。

**示例：**
```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

**答案：** 可以使用哈希表的方法，记录数组 `nums1` 中的元素及其出现次数，然后遍历数组 `nums2` ，查找是否存在对应的元素。

```go
func intersect(nums1 []int, nums2 []int) []int {
    cnt := make(map[int]int)
    for _, v := range nums1 {
        cnt[v]++
    }
    ans := make([]int, 0)
    for _, v := range nums2 {
        if cnt[v] > 0 {
            cnt[v]--
            ans = append(ans, v)
        }
    }
    return ans
}
```

**解析：** 使用哈希表记录数组 `nums1` 中每个元素的出现次数，然后遍历数组 `nums2` ，查找是否存在对应的元素，并将其添加到结果数组 `ans` 中。

### 8. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：** 可以使用分治法，将字符串数组分成两半，然后递归地查找最长公共前缀。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    mid := len(strs) / 2
    left := longestCommonPrefix(strs[:mid])
    right := longestCommonPrefix(strs[mid:])
    return commonPrefix(left, right)
}

func commonPrefix(s1, s2 string) string {
    minLen := min(len(s1), len(s2))
    for i := 0; i < minLen; i++ {
        if s1[i] != s2[i] {
            return s1[:i]
        }
    }
    return s1[:minLen]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 将字符串数组分成两半，递归地查找最长公共前缀。当两个子字符串相同时，继续查找其子字符串。

### 9. 合并两个有序数组

**题目：** 给定两个已排序的整数数组 `nums1` 和 `nums2` ，将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案：** 可以从后端开始，将两个数组中的元素依次比较并插入到 `nums1` 的相应位置。

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p := m-1, n-1, m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    for p2 >= 0 {
        nums1[p] = nums2[p2]
        p2--
        p--
    }
}
```

**解析：** 从后端开始，比较两个数组中的元素，将较大的元素放入 `nums1` 的相应位置。如果 `nums2` 还有剩余元素，则继续放入。

### 10. 最长回文子串

**题目：** 给定一个字符串 `s` ，找到其最长的回文子串。

**示例：**
```
输入：s = "babad"
输出："bab" 或 "aba"
```

**答案：** 可以使用动态规划的方法，创建一个二维数组 `dp` ，其中 `dp[i][j]` 表示字符串 `s` 从索引 `i` 到 `j` 的子串是否为回文。

```go
func longestPalindrome(s string) string {
    n := len(s)
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        dp[i][i] = true
    }
    for i := 0; i < n-1; i++ {
        if s[i] == s[i+1] {
            dp[i][i+1] = true
            start = i
            maxLen = 2
        }
    }
    for l := 3; l <= n; l++ {
        for i := 0; i < n-l+1; i++ {
            j := i + l - 1
            if s[i] == s[j] && dp[i+1][j-1] {
                dp[i][j] = true
                start = i
                maxLen = l
            }
        }
    }
    return s[start : start+maxLen]
}
```

**解析：** 首先初始化一个二维数组 `dp` ，其中 `dp[i][j]` 表示字符串 `s` 从索引 `i` 到 `j` 的子串是否为回文。然后使用动态规划的方法，更新 `dp` 数组。最后，找到最长的回文子串。

### 11. 螺旋矩阵

**题目：** 给定一个 `m x n` 的矩阵，按照螺旋顺序返回矩阵中的元素。

**示例：**
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**答案：** 可以模拟螺旋矩阵的旋转过程，逐层旋转。

```go
func spiralOrder(matrix [][]int) []int {
    ans := []int{}
    if len(matrix) == 0 {
        return ans
    }
    rowBegin, rowEnd := 0, len(matrix)-1
    colBegin, colEnd := 0, len(matrix[0])-1
    for {
        // 渐行
        for col := colBegin; col <= colEnd; col++ {
            ans = append(ans, matrix[rowBegin][col])
        }
        rowBegin++
        if rowBegin > rowEnd {
            break
        }
        // 垂直列
        for row := rowBegin; row <= rowEnd; row++ {
            ans = append(ans, matrix[row][colEnd])
        }
        colEnd--
        if colBegin > colEnd {
            break
        }
        // 渐行
        for col := colEnd; col >= colBegin; col-- {
            ans = append(ans, matrix[rowEnd][col])
        }
        rowEnd--
        if rowBegin > rowEnd {
            break
        }
        // 垂直列
        for row := rowEnd; row >= rowBegin; row-- {
            ans = append(ans, matrix[row][colBegin])
        }
        colBegin++
        if colBegin > colEnd {
            break
        }
    }
    return ans
}
```

**解析：** 逐层模拟螺旋矩阵的旋转过程，首先从右上角开始，然后顺时针旋转。

### 12. 存在重复元素

**题目：** 给定一个整数数组，判断是否存在重复元素。

**示例：**
```
输入：nums = [1,2,3,1]
输出：true
```

**答案：** 可以使用哈希表的方法，记录数组中的元素。

```go
func containsDuplicate(nums []int) bool {
    cnt := make(map[int]int)
    for _, v := range nums {
        if cnt[v] > 0 {
            return true
        }
        cnt[v]++
    }
    return false
}
```

**解析：** 使用哈希表记录每个元素的计数，如果发现某个元素的计数大于 1，则返回 `true`。

### 13. 存在重复元素 III

**题目：** 给定一个整数数组 `nums` 和两个整数 `k` 和 `t` ，判断是否存在两个不同的下标 `i` 和 `j` ，使得 `abs(nums[i] - nums[j]) <= t` ，并且 `abs(i - j) <= k` 。

**示例：**
```
输入：nums = [1,2,3,1], k = 3, t = 0
输出：true
```

**答案：** 可以使用双指针的方法，维护一个滑动窗口，保持窗口中的元素满足距离不超过 `k` ，并判断是否存在元素的差值不超过 `t` 。

```go
func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {
    mp := map[int]int{}
    for i, v := range nums {
        nearVal := v - t
        if val, ok := mp[nearVal]; ok && (i-val <= k) {
            return true
        }
        nearVal = v + t
        if val, ok := mp[nearVal]; ok && (i-val <= k) {
            return true
        }
        mp[v] = i
    }
    return false
}
```

**解析：** 遍历数组，对于每个元素，计算与其差值不超过 `t` 的两个值，判断它们是否在哈希表中且与当前元素的距离不超过 `k` 。

### 14. 前K个高频元素

**题目：** 给定一个整数数组 `nums` 和一个整数 `k` ，返回数组中频率前 `k` 高的元素。

**示例：**
```
输入：nums = [1,1,1,2,2,3], k = 2
输出：[1,2]
```

**答案：** 可以使用哈希表和优先队列（最大堆）的方法，记录每个元素的频率，并将频率最高的 `k` 个元素存储在结果数组中。

```go
import (
    "container/heap"
)

type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(v interface{}) {
    *h = append(*h, v.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func topKFrequent(nums []int, k int) []int {
    cnt := make(map[int]int)
    for _, v := range nums {
        cnt[v]++
    }
    h := &IntHeap{}
    heap.Init(h)
    for v, freq := range cnt {
        heap.Push(h, freq)
        if h.Len() > k {
            heap.Pop(h)
        }
    }
    ans := make([]int, k)
    for i := 0; i < k; i++ {
        ans[i] = h.Data()[i]
    }
    return ans
}
```

**解析：** 使用哈希表记录每个元素的频率，然后使用优先队列（最大堆）存储频率最高的元素。如果堆的大小超过 `k` ，则弹出堆顶元素。

### 15. 有效括号字符串

**题目：** 给定一个只包含 '('、')' 和 '.' 的字符串 `s` ，判断是否存在有效的括号字符串解法。

**示例：**
```
输入：s = "()()"
输出：true
```

**答案：** 可以使用栈的方法，遍历字符串，根据当前字符进行相应的操作。

```go
func isValidParathesis(s string) bool {
    stack := []rune{}
    for _, v := range s {
        if v == '(' || v == ')' {
            if len(stack) == 0 {
                return false
            }
            top := stack[len(stack)-1]
            if (v == ')' && top != '(') || (v == '(' && top != ')') {
                return false
            }
            stack = stack[:len(stack)-1]
        } else {
            stack = append(stack, v)
        }
    }
    return len(stack) == 0
}
```

**解析：** 使用栈存储左括号，当遇到右括号时，检查栈顶元素是否匹配。如果匹配，则弹出栈顶元素；如果不匹配，则返回 `false` 。最后检查栈是否为空。

### 16. 三数之和

**题目：** 给定一个整数数组 `nums` ，返回所有不包含重复元素的三元组。

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案：** 可以使用排序和双指针的方法，首先对数组进行排序，然后固定一个元素，使用两个指针分别指向其左右两侧。

```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    sort.Ints(nums)
    n := len(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return ans
}
```

**解析：** 遍历数组，固定一个元素，然后使用双指针法查找其余两个元素，避免重复元素。

### 17. 有效的数字

**题目：** 给定一个字符串 `s` ，判断它可以表示一个有效的数字。

**示例：**
```
输入：s = "0"
输出：true
```

**答案：** 可以使用状态机的方法，定义多个状态来处理字符串。

```go
type State int

const (
    STATE_INITIAL State = iota
    STATE_INT_SIGN
    STATE_INT
    STATE_FRAC
    STATE_EXP
    STATE_EXP_SIGN
    STATE_END
)

var transitions = map[State][7]State{
    STATE_INITIAL:  {STATE_INT_SIGN, STATE_INT, STATE_END, STATE_END, STATE_END, STATE_END, STATE_END},
    STATE_INT_SIGN: {STATE_INT, STATE_END, STATE_END, STATE_END, STATE_END, STATE_END, STATE_END},
    STATE_INT:      {STATE_INT, STATE_POINT, STATE_END, STATE_EXP, STATE_END, STATE_END, STATE_END},
    STATE_FRAC:     {STATE_END, STATE_INT, STATE_END, STATE_EXP, STATE_END, STATE_END, STATE_END},
    STATE_EXP:      {STATE_EXP_SIGN, STATE_EXP, STATE_END, STATE_END, STATE_POINT, STATE_END, STATE_END},
    STATE_EXP_SIGN: {STATE_EXP, STATE_END, STATE_END, STATE_END, STATE_POINT, STATE_INT, STATE_FRAC},
}

func isValidNumber(s string) bool {
    state := STATE_INITIAL
    for _, ch := range s {
        state = transitions[state][ch-'0']
        if state == STATE_END {
            return false
        }
    }
    return state == STATE_INT || state == STATE_FRAC || state == STATE_EXP
}
```

**解析：** 根据字符串中的字符，更新当前状态。如果最终状态不是 `STATE_END` ，则字符串不是有效的数字。

### 18. 寻找旋转排序数组中的最小值

**题目：** 给你一个数组 `nums` ，其中可能包含重复元素。返回数组中的最小元素。

**示例：**
```
输入：nums = [3,4,5,1,2]
输出：1
```

**答案：** 可以使用二分查找的方法，找到最小元素。

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}
```

**解析：** 如果 `nums[mid] > nums[right]` ，则最小值在 `mid + 1` 到 `right` 之间；否则，最小值在 `left` 到 `mid` 之间。

### 19. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2` ，返回它们的 **最长公共子序列** 的长度。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
```

**答案：** 可以使用动态规划的方法，定义一个二维数组 `dp` ，其中 `dp[i][j]` 表示 `text1[0...i]` 和 `text2[0...j]` 的最长公共子序列长度。

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 根据动态规划的状态转移方程，更新 `dp` 数组。最后返回 `dp[m][n]` 作为最长公共子序列的长度。

### 20. 长度最小的子数组

**题目：** 给定一个整数数组 `nums` 和一个整数 `target` ，返回一个长度最小的子数组，使得子数组的和大于或等于 `target` 。

**示例：**
```
输入：nums = [1,2,3,4], target = 7
输出：2
解释：子数组 [4] 是该条件下的长度最小的子数组。
```

**答案：** 可以使用前缀和和双指针的方法，找到长度最小的子数组。

```go
func lengthOfShortestSubarray(nums []int, target int) int {
    n := len(nums)
    preSum := make([]int, n+1)
    for i := 1; i <= n; i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    ans := n
    for i := 1; i <= n; i++ {
        // [i, j]
        if preSum[i] >= target {
            ans = min(ans, i-j+1)
        }
        if preSum[i]-preSum[i-1] >= target {
            ans = min(ans, i-i+1)
        }
    }
    return ans
}
```

**解析：** 计算前缀和数组 `preSum` ，然后遍历数组，使用双指针法找到满足条件的子数组，并更新答案。

### 21. 两数之和 II - 输入有序数组

**题目：** 给定一个已按照升序排列的整数数组 `numbers` ，和一个目标值 `target` 。从 `numbers` 中找出两个数，使得它们的和等于 `target` 。返回这两个下标的索引值。

**示例：**
```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标值 9 。因此返回 [1,2]。
```

**答案：** 可以使用双指针的方法，从数组的两端开始遍历。

```go
func twoSum(numbers []int, target int) []int {
    left, right := 0, len(numbers)-1
    for left < right {
        sum := numbers[left] + numbers[right]
        if sum == target {
            return []int{left + 1, right + 1}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return nil
}
```

**解析：** 根据当前和与目标值的关系，移动左指针或右指针，直到找到满足条件的两个数。

### 22. 判断子序列

**题目：** 给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。

**示例：**
```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**答案：** 可以使用双指针的方法，遍历字符串 `t` ，检查是否包含字符串 `s` 的所有字符。

```go
func isSubsequence(s string, t string) bool {
    i, j := 0, 0
    for j < len(t) && i < len(s) {
        if s[i] == t[j] {
            i++
        }
        j++
    }
    return i == len(s)
}
```

**解析：** 遍历字符串 `t` ，如果当前字符与 `s` 的当前字符匹配，则移动 `s` 的指针。如果 `s` 的指针移动到末尾，则表示 `s` 是 `t` 的子序列。

### 23. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：** 可以使用递归或迭代的方法来合并两个链表。

递归方法：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

迭代方法：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }
    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }
    return dummy.Next
}
```

**解析：** 通过比较两个链表当前节点的值，选择较小的值作为下一个节点，并移动相应的链表指针。

### 24. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**示例：**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部节点值为 0 ，哪

