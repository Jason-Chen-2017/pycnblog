                 

### 意法半导体2025社招MCU开发工程师面试攻略：典型面试题与算法编程题解析

#### 一、面试题库

##### 1. 什么是MCU？它与DSP的区别是什么？

**答案：** MCU（Microcontroller Unit，微控制器单元）是一种专门为特定应用设计的嵌入式处理器，通常具有内置的内存、输入/输出端口和时钟等基本功能。MCU主要用于控制和监视各种外围设备。

DSP（Digital Signal Processor，数字信号处理器）是一种专门用于处理数字信号的计算设备，它可以对数字信号进行各种数学运算，如滤波、压缩、放大等。

区别在于：

- **用途：** MCU主要用于控制应用，如智能家居、汽车电子等；DSP主要用于信号处理应用，如音频、视频和通信等领域。
- **架构：** MCU通常采用冯·诺依曼架构，而DSP通常采用哈佛架构。
- **处理能力：** DSP通常具有更强的处理能力和更高的时钟频率。

##### 2. 请解释中断和定时器的概念及其在MCU中的应用。

**答案：** 中断是一种信号，用于通知MCU执行特定的操作。中断可以由外部设备（如按键、传感器等）触发，也可以由MCU内部硬件（如定时器、DMA等）触发。

定时器是一种用于计时的硬件设备，可以用于生成精确的时间延迟、定时触发中断或计算时间间隔。

在MCU中的应用包括：

- **实时操作系统（RTOS）：** 中断和定时器用于实现任务的调度和同步。
- **传感器数据采集：** 定时器用于控制采样周期，中断用于处理传感器数据。
- **通信协议：** 中断和定时器用于实现通信协议的时间同步和流量控制。

##### 3. 解释ADC（模数转换器）和DAC（数模转换器）的工作原理及其在MCU中的应用。

**答案：** ADC（Analog-to-Digital Converter，模拟-数字转换器）用于将模拟信号转换为数字信号，以便MCU进行处理。DAC（Digital-to-Analog Converter，数字-模拟转换器）用于将数字信号转换为模拟信号，以便驱动模拟设备。

工作原理：

- **ADC：** 通过采样和保持模拟信号，然后将其转换为数字值。
- **DAC：** 通过数字信号生成一个近似于原始模拟信号的电信号。

在MCU中的应用：

- **数据采集：** ADC用于将传感器数据转换为数字值，以便MCU进行处理。
- **信号生成：** DAC用于将数字信号转换为模拟信号，以驱动扬声器、LCD显示屏等模拟设备。

##### 4. 请描述MCU中的输入/输出（I/O）端口及其控制方式。

**答案：** 输入/输出（I/O）端口是MCU与外部设备进行通信的接口。每个I/O端口由一个或多个引脚组成，可以配置为输入或输出模式。

控制方式：

- **输入模式：** I/O端口接收来自外部设备（如按键、传感器等）的电信号。
- **输出模式：** I/O端口发送电信号到外部设备（如LED灯、电机等）。

控制方式：

- **配置寄存器：** 通过配置寄存器设置I/O端口的模式（输入或输出）和引脚状态（高或低）。
- **指令操作：** 通过执行特定的指令来读取或写入I/O端口的引脚状态。

##### 5. 解释MCU中的中断优先级及其如何实现。

**答案：** 中断优先级是指多个中断同时发生时，系统根据中断的优先级来确定执行顺序。优先级越高，中断处理程序越先执行。

实现方法：

- **硬件优先级：** 中断控制器根据硬件信号确定中断优先级。
- **软件优先级：** 通过中断服务程序（ISR）中的顺序来确定中断优先级。

实现步骤：

1. 配置中断控制器设置中断优先级。
2. 编写中断服务程序，按照优先级顺序处理中断。

##### 6. 请描述MCU中的电源管理机制。

**答案：** 电源管理机制是指MCU在空闲或低功耗状态下降低功耗的功能。电源管理机制包括以下几种模式：

- **待机模式（Sleep Mode）：** 关闭所有时钟和I/O端口，将MCU置于低功耗状态。
- **空闲模式（Idle Mode）：** 关闭某些时钟，但保持I/O端口和中断功能。
- **低功耗模式（Low Power Mode）：** 减少时钟频率，降低功耗。

实现方法：

- **硬件控制：** 通过配置寄存器设置MCU的电源管理模式。
- **软件控制：** 通过执行特定的指令将MCU切换到电源管理模式。

##### 7. 请解释MCU中的时钟系统及其在系统定时中的应用。

**答案：** 时钟系统是指为MCU提供定时信号的硬件组件。时钟系统通常包括以下部分：

- **时钟源（Clock Source）：** 提供基本时钟信号，如晶振、RC振荡器等。
- **时钟分频器（Clock Divider）：** 用于将时钟源频率分频，得到不同的时钟频率。
- **时钟控制器（Clock Controller）：** 管理时钟源、时钟分频器和时钟使能。

在系统定时中的应用：

- **定时器：** 利用时钟控制器提供的定时信号，实现精确的时间计数。
- **时钟中断：** 利用时钟中断实现系统定时功能，如定时任务调度、定时器触发等。

##### 8. 请解释MCU中的SPI和I2C通信协议。

**答案：** SPI（Serial Peripheral Interface）和I2C（Inter-Integrated Circuit）是两种常用的串行通信协议。

- **SPI：** 是一种高速、全双工的通信协议，采用主从模式，数据传输速率较高。SPI通信协议包括四个信号线：SCK（时钟信号）、MOSI（主设备输出从设备输入）、MISO（主设备输入从设备输出）、SS（从设备选择信号）。
- **I2C：** 是一种低速、半双工的通信协议，也采用主从模式，数据传输速率较低。I2C通信协议包括三个信号线：SCL（时钟信号）、SDA（数据信号）、地址信号。

在MCU中的应用：

- **外围设备通信：** 用于连接各种外围设备，如传感器、LCD显示屏、存储器等。
- **系统扩展：** 用于实现MCU与其他微控制器或计算机的通信。

##### 9. 请描述MCU中的串行通信接口及其在系统中的应用。

**答案：** 串行通信接口是一种用于实现MCU与外部设备之间的串行数据传输的接口。常见的串行通信接口包括UART（Universal Asynchronous Receiver/Transmitter，通用异步收发器/传输器）、SPI、I2C等。

在系统中的应用：

- **通信扩展：** 用于实现MCU与其他设备（如计算机、传感器、通信模块等）之间的通信。
- **数据采集：** 用于将传感器数据传输到MCU进行处理。
- **系统监控：** 用于实现系统状态监控和故障报警。

##### 10. 解释MCU中的内存管理及其重要性。

**答案：** 内存管理是指对MCU中的内存资源进行分配、使用和保护的过程。MCU的内存资源包括ROM（只读存储器）、RAM（随机存取存储器）、EEPROM（电可擦可编程只读存储器）等。

重要性：

- **资源优化：** 合理管理内存资源，避免资源浪费。
- **系统稳定性：** 正确使用内存，防止内存泄露和越界访问。
- **代码优化：** 减少代码大小，提高系统运行效率。

内存管理方法：

- **静态分配：** 在编译时分配内存，适用于固定大小的数据结构。
- **动态分配：** 在运行时分配内存，适用于不确定大小的数据结构。

##### 11. 请解释MCU中的中断处理机制。

**答案：** 中断处理机制是指MCU在接收到中断信号时，暂停当前执行的任务，转而执行中断服务程序（ISR）的过程。中断处理机制包括以下部分：

- **中断控制器：** 管理中断信号和中断优先级。
- **中断向量表：** 存储中断服务程序的入口地址。
- **中断服务程序（ISR）：** 用于处理中断事件。

中断处理步骤：

1. 中断信号触发。
2. 中断控制器保存当前程序状态。
3. 转换到中断服务程序。
4. 执行中断服务程序。
5. 恢复程序状态。
6. 返回到原始任务。

##### 12. 请解释MCU中的电源管理及其在系统中的应用。

**答案：** 电源管理是指MCU在空闲或低功耗状态下降低功耗的功能。电源管理包括以下几种模式：

- **待机模式（Sleep Mode）：** 关闭所有时钟和I/O端口，将MCU置于低功耗状态。
- **空闲模式（Idle Mode）：** 关闭某些时钟，但保持I/O端口和中断功能。
- **低功耗模式（Low Power Mode）：** 减少时钟频率，降低功耗。

在系统中的应用：

- **节省能源：** 降低系统功耗，延长电池寿命。
- **提高性能：** 在空闲状态下关闭不必要的时钟和模块，提高系统性能。
- **延长设备寿命：** 降低设备温度，减少热量产生，延长设备寿命。

##### 13. 请解释MCU中的定时器及其在系统中的应用。

**答案：** 定时器是指用于实现精确定时功能的MCU硬件组件。定时器通常具有以下功能：

- **定时计数：** 计算时钟信号的周期数，实现定时功能。
- **定时中断：** 在计时结束时触发中断，通知MCU执行特定任务。

在系统中的应用：

- **实时时钟：** 用于记录系统运行时间，实现定时任务调度。
- **周期性任务：** 用于实现周期性任务的执行，如传感器数据采集、系统状态监控等。
- **定时触发：** 用于实现外部设备控制，如PWM（脉宽调制）信号生成。

##### 14. 请解释MCU中的看门狗定时器及其在系统中的应用。

**答案：** 看门狗定时器（Watchdog Timer，WDT）是一种用于监控系统运行状态的安全机制。看门狗定时器在系统正常运行时定期复位，如果在预定时间内未收到复位信号，看门狗定时器将触发系统复位。

在系统中的应用：

- **故障检测：** 检测系统是否正常运行，防止系统崩溃。
- **系统恢复：** 在系统故障时自动复位，恢复系统正常运行。
- **程序调试：** 在程序调试过程中，用于检测和定位程序错误。

##### 15. 请解释MCU中的GPIO（通用输入输出）端口及其在系统中的应用。

**答案：** GPIO（General Purpose Input/Output，通用输入输出）端口是MCU提供的可编程I/O端口，用于实现与外部设备的通信和控制。

在系统中的应用：

- **输入：** 读取外部设备（如按键、传感器等）的状态。
- **输出：** 控制外部设备（如LED灯、电机等）的行为。
- **复用：** 实现GPIO端口的多种功能，如模拟信号输入、中断输入等。

##### 16. 请解释MCU中的存储器映射及其在系统中的应用。

**答案：** 存储器映射是指将存储器地址映射到MCU的I/O端口或特殊功能模块，以便实现数据存储和传输。

在系统中的应用：

- **数据存储：** 将数据存储在存储器中，如ROM、RAM、EEPROM等。
- **I/O操作：** 通过存储器映射实现与外部设备的通信，如串行通信接口、SPI接口等。
- **程序加载：** 通过存储器映射实现程序加载和执行，如程序下载、调试等。

##### 17. 请解释MCU中的中断向量表及其在系统中的应用。

**答案：** 中断向量表是一种存储中断服务程序入口地址的数据结构。每个中断源都有一个对应的中断向量表项，存储其中断服务程序的入口地址。

在系统中的应用：

- **中断管理：** 管理中断请求和处理过程，如中断优先级、中断屏蔽等。
- **程序调试：** 在程序调试过程中，用于调试和定位中断服务程序。
- **系统扩展：** 在系统扩展时，用于添加新的中断源和处理程序。

##### 18. 请解释MCU中的复位信号及其在系统中的应用。

**答案：** 复位信号是一种用于将MCU从正常工作状态切换到初始状态的信号。复位信号可以由外部设备（如按键、看门狗定时器等）触发，也可以由MCU内部硬件（如电源故障、时钟故障等）触发。

在系统中的应用：

- **系统初始化：** 在系统启动时，将MCU从复位状态切换到正常工作状态。
- **系统恢复：** 在系统故障时，通过复位信号将MCU从错误状态切换到正常状态。
- **程序调试：** 在程序调试过程中，用于强制复位MCU，以便重新执行程序。

##### 19. 请解释MCU中的时钟树及其在系统中的应用。

**答案：** 时钟树是指MCU内部用于产生不同时钟信号的结构。时钟树包括时钟源、时钟分频器、时钟控制器等组件。

在系统中的应用：

- **时钟分配：** 将时钟信号分配给不同的模块，如CPU核心、存储器、I/O端口等。
- **时钟同步：** 保证系统内部各个模块的时钟信号同步，防止时钟偏差导致系统错误。
- **时钟控制：** 通过时钟控制器实现对时钟信号的使能和禁用，实现系统的时钟管理。

##### 20. 请解释MCU中的时钟信号及其在系统中的应用。

**答案：** 时钟信号是一种用于控制MCU内部操作节拍的周期性信号。时钟信号通常由外部时钟源（如晶振、RC振荡器等）提供。

在系统中的应用：

- **时钟周期：** 用于计算系统操作节拍，实现定时功能。
- **时钟频率：** 用于计算系统操作速度，影响系统性能。
- **时钟同步：** 用于保证系统内部各个模块的时钟信号同步，防止时钟偏差导致系统错误。

##### 21. 请解释MCU中的SPI通信协议及其在系统中的应用。

**答案：** SPI（Serial Peripheral Interface，串行外围设备接口）是一种高速、全双工、同步的通信协议，用于实现MCU与外部设备之间的数据传输。

在系统中的应用：

- **外围设备通信：** 用于连接各种外围设备，如传感器、存储器、通信模块等。
- **系统扩展：** 用于实现MCU与其他微控制器或计算机之间的通信。
- **数据采集：** 用于将传感器数据传输到MCU进行处理。

##### 22. 请解释MCU中的I2C通信协议及其在系统中的应用。

**答案：** I2C（Inter-Integrated Circuit，内部集成电路）是一种低速、半双工、同步的通信协议，用于实现MCU与外部设备之间的数据传输。

在系统中的应用：

- **外围设备通信：** 用于连接各种外围设备，如传感器、存储器、通信模块等。
- **系统扩展：** 用于实现MCU与其他微控制器或计算机之间的通信。
- **数据采集：** 用于将传感器数据传输到MCU进行处理。

##### 23. 请解释MCU中的UART通信协议及其在系统中的应用。

**答案：** UART（Universal Asynchronous Receiver/Transmitter，通用异步收发器/传输器）是一种异步串行通信协议，用于实现MCU与外部设备之间的数据传输。

在系统中的应用：

- **通信扩展：** 用于实现MCU与其他设备（如计算机、传感器、通信模块等）之间的通信。
- **数据采集：** 用于将传感器数据传输到MCU进行处理。
- **系统监控：** 用于实现系统状态监控和故障报警。

##### 24. 请解释MCU中的PWM通信协议及其在系统中的应用。

**答案：** PWM（Pulse Width Modulation，脉宽调制）是一种用于控制模拟信号的通信协议，通过调整脉冲宽度来模拟模拟信号的幅值。

在系统中的应用：

- **信号生成：** 用于生成模拟信号，如控制LED灯的亮度、电机速度等。
- **信号调节：** 用于调节传感器信号的幅值和频率，提高信号质量。
- **通信扩展：** 用于实现MCU与其他设备之间的通信，如无线通信、传感器网络等。

##### 25. 请解释MCU中的定时中断及其在系统中的应用。

**答案：** 定时中断是一种由MCU内部定时器触发的中断，用于实现系统的定时功能。

在系统中的应用：

- **实时时钟：** 用于记录系统运行时间，实现定时任务调度。
- **周期性任务：** 用于实现周期性任务的执行，如传感器数据采集、系统状态监控等。
- **定时触发：** 用于实现外部设备控制，如PWM信号生成。

##### 26. 请解释MCU中的中断优先级及其在系统中的应用。

**答案：** 中断优先级是指MCU在接收到多个中断请求时，根据中断的优先级来确定执行顺序。

在系统中的应用：

- **实时响应：** 确保关键中断（如紧急信号、故障报警等）优先执行。
- **资源优化：** 避免低优先级中断占用系统资源，影响关键任务执行。
- **任务调度：** 根据中断优先级实现任务调度，提高系统运行效率。

##### 27. 请解释MCU中的看门狗定时器及其在系统中的应用。

**答案：** 看门狗定时器（Watchdog Timer，WDT）是一种用于监控系统运行状态的安全机制，用于检测系统是否正常运行。

在系统中的应用：

- **故障检测：** 检测系统是否正常运行，防止系统崩溃。
- **系统恢复：** 在系统故障时自动复位，恢复系统正常运行。
- **程序调试：** 在程序调试过程中，用于检测和定位程序错误。

##### 28. 请解释MCU中的GPIO（通用输入输出）端口及其在系统中的应用。

**答案：** GPIO（General Purpose Input/Output，通用输入输出）端口是MCU提供的可编程I/O端口，用于实现与外部设备的通信和控制。

在系统中的应用：

- **输入：** 读取外部设备（如按键、传感器等）的状态。
- **输出：** 控制外部设备（如LED灯、电机等）的行为。
- **复用：** 实现GPIO端口的多种功能，如模拟信号输入、中断输入等。

##### 29. 请解释MCU中的存储器映射及其在系统中的应用。

**答案：** 存储器映射是指将存储器地址映射到MCU的I/O端口或特殊功能模块，以便实现数据存储和传输。

在系统中的应用：

- **数据存储：** 将数据存储在存储器中，如ROM、RAM、EEPROM等。
- **I/O操作：** 通过存储器映射实现与外部设备的通信，如串行通信接口、SPI接口等。
- **程序加载：** 通过存储器映射实现程序加载和执行，如程序下载、调试等。

##### 30. 请解释MCU中的中断向量表及其在系统中的应用。

**答案：** 中断向量表是一种存储中断服务程序入口地址的数据结构。每个中断源都有一个对应的中断向量表项，存储其中断服务程序的入口地址。

在系统中的应用：

- **中断管理：** 管理中断请求和处理过程，如中断优先级、中断屏蔽等。
- **程序调试：** 在程序调试过程中，用于调试和定位中断服务程序。
- **系统扩展：** 在系统扩展时，用于添加新的中断源和处理程序。

#### 二、算法编程题库

##### 1. 快速排序算法实现

**题目：** 实现一个快速排序算法，对数组进行升序排序。

**答案：** 

```c
#include <stdio.h>

void quicksort(int arr[], int low, int high) {
    if (low < high) {
        int pivot = arr[high];
        int i = (low - 1);

        for (int j = low; j <= high - 1; j++) {
            if (arr[j] < pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        int pi = i + 1;

        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    quicksort(arr, 0, n - 1);

    printf("Sorted array: \n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```

##### 2. 冒泡排序算法实现

**题目：** 实现一个冒泡排序算法，对数组进行降序排序。

**答案：**

```c
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] < arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);

    bubbleSort(arr, n);

    printf("Sorted array in descending order: \n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```

##### 3. 求最大子序和

**题目：** 给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（至少包含一个数），返回其最大和。

**答案：**

```c
#include <stdio.h>

int maxSubArraySum(int* nums, int numsSize) {
    int maxSum = nums[0];
    int currSum = nums[0];

    for (int i = 1; i < numsSize; i++) {
        currSum = (nums[i] > currSum + nums[i]) ? nums[i] : currSum + nums[i];
        maxSum = (maxSum > currSum) ? maxSum : currSum;
    }

    return maxSum;
}

int main() {
    int nums[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
    int size = sizeof(nums) / sizeof(nums[0]);

    printf("Maximum subarray sum is %d\n", maxSubArraySum(nums, size));

    return 0;
}
```

##### 4. 寻找两个有序数组的中位数

**题目：** 给定两个大小分别为 `m` 和 `n` 的有序数组 `nums1` 和 `nums2`，请找到并返回这两个有序数组的第 `k` 小的元素。

**答案：**

```c
#include <stdio.h>

int findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size, int k) {
    int i = 0, j = 0;
    while (i + j < k) {
        if (i == nums1Size) {
            j += k - i - 1;
        } else if (j == nums2Size) {
            i += k - j - 1;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    if (i == nums1Size) {
        return nums2[j - 1];
    } else if (j == nums2Size) {
        return nums1[i - 1];
    } else {
        if (i + j == k) {
            return (nums1[i - 1] > nums2[j - 1]) ? nums1[i - 1] : nums2[j - 1];
        } else {
            return (nums1[i] + nums2[j]) / 2;
        }
    }
}

int main() {
    int nums1[] = {1, 3};
    int nums2[] = {2};
    int k = 2;

    printf("The %d-th element is %d\n", k, findMedianSortedArrays(nums1, 2, nums2, 1, k));

    return 0;
}
```

##### 5. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**答案：**

```c
#include <stdio.h>
#include <string.h>

int longestCommonSubsequence(char* text1, char* text2) {
    int len1 = strlen(text1);
    int len2 = strlen(text2);

    int dp[len1 + 1][len2 + 1];
    memset(dp, 0, sizeof(dp));

    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = (dp[i - 1][j] > dp[i][j - 1]) ? dp[i - 1][j] : dp[i][j - 1];
            }
        }
    }

    return dp[len1][len2];
}

int main() {
    char text1[] = "ABCD";
    char text2[] = "ACDF";

    printf("The length of the longest common subsequence is %d\n", longestCommonSubsequence(text1, text2));

    return 0;
}
```

##### 6. 反转链表

**题目：** 实现一个函数，用于反转单链表。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* reverseList(ListNode* head) {
    ListNode* prev = NULL;
    ListNode* curr = head;
    ListNode* next = NULL;

    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* head = (ListNode*)malloc(sizeof(ListNode));
    head->val = 1;
    head->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->val = 2;
    head->next->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->next->val = 3;

    printf("Original list: ");
    printList(head);

    ListNode* reversed = reverseList(head);

    printf("Reversed list: ");
    printList(reversed);

    return 0;
}
```

##### 7. 二分查找

**题目：** 给定一个有序数组 `nums`，找出 `target` 的索引。如果不存在，返回 `-1`。

**答案：**

```c
#include <stdio.h>

int binarySearch(int* nums, int target, int left, int right) {
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}

int main() {
    int nums[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int target = 7;

    int index = binarySearch(nums, target, 0, 9);

    printf("Index of %d is %d\n", target, index);

    return 0;
}
```

##### 8. 回文数

**题目：** 判断一个整数是否是回文数。

**答案：**

```c
#include <stdio.h>

int isPalindrome(int x) {
    if (x < 0 || (x % 10 == 0 && x != 0)) {
        return 0;
    }
    int reversed = 0;
    while (x > reversed) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    return x == reversed || x == reversed / 10;
}

int main() {
    int num = 12321;

    if (isPalindrome(num)) {
        printf("%d is a palindrome number.\n", num);
    } else {
        printf("%d is not a palindrome number.\n", num);
    }

    return 0;
}
```

##### 9. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新的链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummy = (ListNode*)malloc(sizeof(ListNode));
    ListNode* tail = dummy;
    while (list1 && list2) {
        if (list1->val < list2->val) {
            tail->next = list1;
            list1 = list1->next;
        } else {
            tail->next = list2;
            list2 = list2->next;
        }
        tail = tail->next;
    }
    tail->next = list1 ? list1 : list2;
    return dummy->next;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* list1 = (ListNode*)malloc(sizeof(ListNode));
    list1->val = 1;
    list1->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->val = 3;
    list1->next->next = NULL;

    ListNode* list2 = (ListNode*)malloc(sizeof(ListNode));
    list2->val = 2;
    list2->next = (ListNode*)malloc(sizeof(ListNode));
    list2->next->val = 4;
    list2->next->next = NULL;

    ListNode* merged = mergeTwoLists(list1, list2);

    printf("Merged list: ");
    printList(merged);

    return 0;
}
```

##### 10. 爬楼梯

**题目：** 假设你正在爬楼梯。需要 `n` 阶台阶才能到达楼顶。每次可以爬 1 或 2 个台阶。请编写一个函数，返回到达楼顶共有多少种不同的方法。

**答案：**

```c
#include <stdio.h>

int climbStairs(int n) {
    if (n <= 2) {
        return n;
    }
    int a = 1, b = 2, sum;
    for (int i = 3; i <= n; i++) {
        sum = a + b;
        a = b;
        b = sum;
    }
    return b;
}

int main() {
    int n = 5;

    printf("Number of ways to climb %d stairs: %d\n", n, climbStairs(n));

    return 0;
}
```

##### 11. 益虫与害虫

**题目：** 有一个整数数组 `bugs`，表示某个区域内的虫子数量，其中 1 表示益虫，-1 表示害虫。给定一个整数 `k`，表示允许喷洒农药的最大面积。请编写一个函数，返回在不超过 `k` 的条件下，最多可以消灭多少只害虫。

**答案：**

```c
#include <stdio.h>

int killBugs(int* bugs, int size, int k) {
    int maxKill = 0;
    int left = 0;
    int right = 0;

    while (right < size) {
        int kill = 0;
        while (right < size && k >= 0) {
            if (bugs[right] == -1) {
                k += bugs[right];
                kill++;
            }
            right++;
        }

        maxKill = (maxKill > kill) ? maxKill : kill;

        k -= bugs[left];
        left++;
    }

    return maxKill;
}

int main() {
    int bugs[] = {1, -1, 1, -1, 1, -1, 1, -1, 1, -1};
    int k = 2;

    printf("Maximum number of bugs killed: %d\n", killBugs(bugs, 10, k));

    return 0;
}
```

##### 12. 最长递增子序列

**题目：** 给定一个整数数组 `nums`，返回其最长严格递增子序列的长度。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

int lengthOfLIS(int* nums, int numsSize) {
    int* dp = (int*)calloc(numsSize, sizeof(int));
    int len = 0;

    for (int i = 0; i < numsSize; i++) {
        dp[i] = 1;
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = (dp[i] > dp[j] + 1) ? dp[i] : dp[j] + 1;
                len = (len > dp[i]) ? len : dp[i];
            }
        }
    }

    free(dp);

    return len;
}

int main() {
    int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};
    int size = sizeof(nums) / sizeof(nums[0]);

    printf("Length of the longest increasing subsequence is %d\n", lengthOfLIS(nums, size));

    return 0;
}
```

##### 13. 删除链表的节点

**题目：** 给定一个单链表的头节点 `head` 和一个整数 `val`，请删除链表中值为 `val` 的节点。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* deleteNode(ListNode* head, int val) {
    if (head == NULL) {
        return NULL;
    }
    if (head->val == val) {
        return head->next;
    }
    ListNode* curr = head;
    while (curr->next != NULL && curr->next->val != val) {
        curr = curr->next;
    }
    if (curr->next != NULL) {
        curr->next = curr->next->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* head = (ListNode*)malloc(sizeof(ListNode));
    head->val = 1;
    head->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->val = 2;
    head->next->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->next->val = 3;
    head->next->next->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->next->next->val = 4;

    head = deleteNode(head, 3);

    printf("List after deleting node with value 3: ");
    printList(head);

    return 0;
}
```

##### 14. 有效的括号

**题目：** 给定一个字符串 `s` ，判断 `s` 是否为有效的括号字符串，即它开始和结束的匹配。

**答案：**

```c
#include <stdio.h>
#include <stdbool.h>

bool isValid(char* s) {
    int stackSize = 0;
    int stack[1000] = {0};
    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '(' || s[i] == '{' || s[i] == '[') {
            stack[stackSize++] = s[i];
        } else if (stackSize == 0 || (stack[stackSize - 1] != '(' && s[i] != ')') ||
                   (stack[stackSize - 1] != '{' && s[i] != '}') ||
                   (stack[stackSize - 1] != '[' && s[i] != ']')) {
            return false;
        } else {
            stackSize--;
        }
    }
    return stackSize == 0;
}

int main() {
    char s1[] = "()";
    char s2[] = "()[]{}";
    char s3[] = "(]";
    char s4[] = "({[})";
    char s5[] = "([)]";
    char s6[] = "{[]}";
    char s7[] = "[]";

    printf("%s is valid: %d\n", s1, isValid(s1));
    printf("%s is valid: %d\n", s2, isValid(s2));
    printf("%s is valid: %d\n", s3, isValid(s3));
    printf("%s is valid: %d\n", s4, isValid(s4));
    printf("%s is valid: %d\n", s5, isValid(s5));
    printf("%s is valid: %d\n", s6, isValid(s6));
    printf("%s is valid: %d\n", s7, isValid(s7));

    return 0;
}
```

##### 15. 合并两个有序链表

**题目：** 给定两个有序链表 `l1` 和 `l2`，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    if (list1 == NULL) {
        return list2;
    }
    if (list2 == NULL) {
        return list1;
    }

    ListNode* dummy = (ListNode*)malloc(sizeof(ListNode));
    ListNode* tail = dummy;
    ListNode* curr1 = list1;
    ListNode* curr2 = list2;

    while (curr1 != NULL && curr2 != NULL) {
        if (curr1->val < curr2->val) {
            tail->next = curr1;
            curr1 = curr1->next;
        } else {
            tail->next = curr2;
            curr2 = curr2->next;
        }
        tail = tail->next;
    }

    if (curr1 == NULL) {
        tail->next = curr2;
    } else {
        tail->next = curr1;
    }

    return dummy->next;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* list1 = (ListNode*)malloc(sizeof(ListNode));
    list1->val = 1;
    list1->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->val = 3;
    list1->next->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->next->val = 5;
    list1->next->next->next = NULL;

    ListNode* list2 = (ListNode*)malloc(sizeof(ListNode));
    list2->val = 2;
    list2->next = (ListNode*)malloc(sizeof(ListNode));
    list2->next->val = 4;
    list2->next->next = (ListNode*)malloc(sizeof(ListNode));
    list2->next->next->val = 6;
    list2->next->next->next = NULL;

    ListNode* merged = mergeTwoLists(list1, list2);

    printf("Merged list: ");
    printList(merged);

    return 0;
}
```

##### 16. 二叉树的层序遍历

**题目：** 给你一个二叉树，请你返回其按层序遍历后的节点值。 （即逐层地，从左到右访问所有节点）

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

void addNode(TreeNode** root, int val) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;

    if (*root == NULL) {
        *root = newNode;
    } else {
        TreeNode* curr = *root;
        while (curr) {
            if (val < curr->val) {
                if (curr->left == NULL) {
                    curr->left = newNode;
                    break;
                } else {
                    curr = curr->left;
                }
            } else {
                if (curr->right == NULL) {
                    curr->right = newNode;
                    break;
                } else {
                    curr = curr->right;
                }
            }
        }
    }
}

void levelOrderTraversal(TreeNode* root) {
    if (root == NULL) {
        return;
    }

    TreeNode** nodes = (TreeNode**)malloc(sizeof(TreeNode*) * 1000);
    int size = 0;
    nodes[size++] = root;

    while (size > 0) {
        TreeNode* curr = nodes[--size];
        printf("%d ", curr->val);

        if (curr->left != NULL) {
            nodes[size++] = curr->left;
        }
        if (curr->right != NULL) {
            nodes[size++] = curr->right;
        }
    }

    printf("\n");
}

int main() {
    TreeNode* root = NULL;

    addNode(&root, 3);
    addNode(&root, 9);
    addNode(&root, 20);
    addNode(&root, 15);
    addNode(&root, 7);

    printf("Level order traversal: ");
    levelOrderTraversal(root);

    return 0;
}
```

##### 17. 计数二进制数中1的数量

**题目：** 给你一个整数 `n` ，统计并返回其中不含前导 0 的非负整数组合的总数。

**答案：**

```c
#include <stdio.h>
#include <math.h>

int countNumbersWithUniqueDigits(int n) {
    if (n == 0) {
        return 1;
    }
    if (n <= 9) {
        return pow(10, n);
    }

    int uniqueDigits = (int)log10(n) + 1;
    int count = pow(10, n - uniqueDigits) * factorial(9);
    for (int i = uniqueDigits; i < n; i++) {
        count *= (10 - i);
    }

    return count;
}

int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main() {
    int n = 5;

    printf("Number of unique digit combinations is %d\n", countNumbersWithUniqueDigits(n));

    return 0;
}
```

##### 18. 字符串的排列组合

**题目：** 给定一个字符串 `s` ，请你返回所有包含它的排列组合。

**答案：**

```c
#include <stdio.h>
#include <string.h>

void permute(char* s, int start, int end, char** result, int* size) {
    if (start == end) {
        strcpy(result[*size], s);
        (*size)++;
        return;
    }

    for (int i = start; i <= end; i++) {
        char temp = s[start];
        s[start] = s[i];
        s[i] = temp;

        permute(s, start + 1, end, result, size);

        temp = s[start];
        s[start] = s[i];
        s[i] = temp;
    }
}

int main() {
    char s[] = "abc";
    int size = 0;
    char** result = (char**)malloc(sizeof(char*) * 1000);

    permute(s, 0, strlen(s) - 1, result, &size);

    printf("Permutations of %s: \n", s);
    for (int i = 0; i < size; i++) {
        printf("%s\n", result[i]);
    }

    free(result);

    return 0;
}
```

##### 19. 删除链表的中间节点

**题目：** 给你一个单链表的节点 `head` 和一个整数 `val` ，请你删除链表中节点值等于 `val` 的节点，并返回修改后的链表。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* deleteNode(ListNode* head, int val) {
    if (head == NULL) {
        return NULL;
    }
    if (head->val == val) {
        return head->next;
    }
    ListNode* curr = head;
    while (curr->next != NULL && curr->next->val != val) {
        curr = curr->next;
    }
    if (curr->next != NULL) {
        curr->next = curr->next->next;
    }
    return head;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* head = (ListNode*)malloc(sizeof(ListNode));
    head->val = 1;
    head->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->val = 2;
    head->next->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->next->val = 3;
    head->next->next->next = (ListNode*)malloc(sizeof(ListNode));
    head->next->next->next->val = 4;

    head = deleteNode(head, 3);

    printf("List after deleting node with value 3: ");
    printList(head);

    return 0;
}
```

##### 20. 求和最大路径

**题目：** 给你一个整数数组 `nums` ，请你找出所有该数组中不含有 1 的最长路径。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

void buildTree(int* nums, int start, int end, TreeNode** root) {
    if (start > end) {
        *root = NULL;
        return;
    }
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->val = nums[start];
    newNode->left = NULL;
    newNode->right = NULL;
    *root = newNode;
    buildTree(nums, start + 1, end, &((*root)->left));
    buildTree(nums, start + 1, end, &((*root)->right));
}

int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    int dfs(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        int leftSum = dfs(root->left);
        int rightSum = dfs(root->right);
        int currSum = root->val + (leftSum > 0 ? leftSum : 0) + (rightSum > 0 ? rightSum : 0);
        maxSum = (maxSum > currSum ? maxSum : currSum);
        return (root->val + (leftSum > rightSum ? leftSum : rightSum));
    }
    dfs(root);
    return maxSum;
}

int main() {
    int nums[] = {1, 2, 3};
    TreeNode* root = NULL;

    buildTree(nums, 0, sizeof(nums) / sizeof(nums[0]) - 1, &root);

    printf("Maximum path sum is %d\n", maxPathSum(root));

    return 0;
}
```

##### 21. 二分查找树

**题目：** 实现一个二叉查找树，实现以下功能：

1. 插入一个节点。
2. 删除一个节点。
3. 查找最小节点。
4. 查找最大节点。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

TreeNode* createNode(int val) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

TreeNode* insertNode(TreeNode* root, int val) {
    if (root == NULL) {
        return createNode(val);
    }
    if (val < root->val) {
        root->left = insertNode(root->left, val);
    } else if (val > root->val) {
        root->right = insertNode(root->right, val);
    }
    return root;
}

TreeNode* findMin(TreeNode* root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

TreeNode* findMax(TreeNode* root) {
    while (root->right != NULL) {
        root = root->right;
    }
    return root;
}

TreeNode* deleteNode(TreeNode* root, int val) {
    if (root == NULL) {
        return root;
    }
    if (val < root->val) {
        root->left = deleteNode(root->left, val);
    } else if (val > root->val) {
        root->right = deleteNode(root->right, val);
    } else {
        if (root->left == NULL && root->right == NULL) {
            free(root);
            root = NULL;
        } else if (root->left == NULL) {
            TreeNode* temp = root;
            root = root->right;
            free(temp);
        } else if (root->right == NULL) {
            TreeNode* temp = root;
            root = root->left;
            free(temp);
        } else {
            TreeNode* temp = findMin(root->right);
            root->val = temp->val;
            root->right = deleteNode(root->right, temp->val);
        }
    }
    return root;
}

void inorderTraversal(TreeNode* root) {
    if (root == NULL) {
        return;
    }
    inorderTraversal(root->left);
    printf("%d ", root->val);
    inorderTraversal(root->right);
}

int main() {
    TreeNode* root = NULL;
    root = insertNode(root, 5);
    root = insertNode(root, 3);
    root = insertNode(root, 7);
    root = insertNode(root, 2);
    root = insertNode(root, 4);
    root = insertNode(root, 6);
    root = insertNode(root, 8);

    printf("Inorder traversal: ");
    inorderTraversal(root);

    root = deleteNode(root, 4);

    printf("\nInorder traversal after deleting node with value 4: ");
    inorderTraversal(root);

    return 0;
}
```

##### 22. 链表相交

**题目：** 给定两个链表 `headA` 和 `headB` ，请编写一个函数来查找链表相交的起始节点。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* getIntersectionNode(ListNode *headA, ListNode *headB) {
    if (headA == NULL || headB == NULL) {
        return NULL;
    }
    ListNode *a = headA, *b = headB;
    while (a != b) {
        a = a == NULL ? headB : a->next;
        b = b == NULL ? headA : b->next;
    }
    return a;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* list1 = (ListNode*)malloc(sizeof(ListNode));
    list1->val = 1;
    list1->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->val = 2;
    list1->next->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->next->val = 3;
    list1->next->next->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->next->next->val = 4;

    ListNode* list2 = (ListNode*)malloc(sizeof(ListNode));
    list2->val = 5;
    list2->next = (ListNode*)malloc(sizeof(ListNode));
    list2->next->val = 6;
    list2->next->next = list1->next->next;

    printf("List 1: ");
    printList(list1);

    printf("List 2: ");
    printList(list2);

    ListNode* intersection = getIntersectionNode(list1, list2);

    printf("Intersection node: ");
    if (intersection != NULL) {
        printf("%d\n", intersection->val);
    } else {
        printf("None\n");
    }

    return 0;
}
```

##### 23. 最短路径

**题目：** 给定一个加权无向图，找到从源点到每个节点的最短路径。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Graph {
    int V;
    struct Edge** edges;
} Graph;

typedef struct Edge {
    int src;
    int dest;
    int weight;
} Edge;

Graph* createGraph(int V) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->V = V;
    graph->edges = (Edge**)malloc(V * sizeof(Edge*));
    for (int i = 0; i < V; i++) {
        graph->edges[i] = (Edge*)malloc(V * sizeof(Edge));
        graph->edges[i] = NULL;
    }
    return graph;
}

void addEdge(Graph* graph, int src, int dest, int weight) {
    Edge* newEdge = (Edge*)malloc(sizeof(Edge));
    newEdge->src = src;
    newEdge->dest = dest;
    newEdge->weight = weight;
    graph->edges[src][dest] = newEdge;
}

int* dijkstra(Graph* graph, int src) {
    int* dist = (int*)malloc(sizeof(int) * graph->V);
    bool* visited = (bool*)malloc(sizeof(bool) * graph->V);

    for (int i = 0; i < graph->V; i++) {
        dist[i] = INT_MAX;
        visited[i] = false;
    }

    dist[src] = 0;

    for (int count = 0; count < graph->V - 1; count++) {
        int min = INT_MAX;
        int minIndex = -1;

        for (int i = 0; i < graph->V; i++) {
            if (!visited[i] && dist[i] < min) {
                min = dist[i];
                minIndex = i;
            }
        }

        visited[minIndex] = true;

        for (int i = 0; i < graph->V; i++) {
            if (!visited[i]) {
                int edgeWeight = graph->edges[minIndex][i]->weight;
                if (dist[minIndex] + edgeWeight < dist[i]) {
                    dist[i] = dist[minIndex] + edgeWeight;
                }
            }
        }
    }

    return dist;
}

int main() {
    Graph* graph = createGraph(5);
    addEdge(graph, 0, 1, 2);
    addEdge(graph, 0, 3, 6);
    addEdge(graph, 1, 2, 3);
    addEdge(graph, 1, 3, 8);
    addEdge(graph, 2, 4, 5);
    addEdge(graph, 3, 4, 7);

    int* distances = dijkstra(graph, 0);

    printf("Shortest distances from node 0:\n");
    for (int i = 0; i < 5; i++) {
        printf("Node %d: %d\n", i, distances[i]);
    }

    return 0;
}
```

##### 24. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```c
#include <stdio.h>
#include <string.h>

char* longestCommonPrefix(char** strs, int strsSize) {
    if (strs == NULL || strsSize == 0) {
        return "";
    }
    int minLen = strlen(strs[0]);
    for (int i = 1; i < strsSize; i++) {
        if (strlen(strs[i]) < minLen) {
            minLen = strlen(strs[i]);
        }
    }
    char* prefix = (char*)malloc((minLen + 1) * sizeof(char));
    for (int i = 0; i < minLen; i++) {
        int isCommon = 1;
        for (int j = 1; j < strsSize; j++) {
            if (strs[0][i] != strs[j][i]) {
                isCommon = 0;
                break;
            }
        }
        if (!isCommon) {
            prefix[i] = '\0';
            break;
        }
        prefix[i] = strs[0][i];
    }
    prefix[minLen] = '\0';
    return prefix;
}

int main() {
    char* words[] = {"flower", "flow", "flight"};
    char* commonPrefix = longestCommonPrefix(words, 3);
    printf("Longest common prefix: %s\n", commonPrefix);
    return 0;
}
```

##### 25. 求两个数组的交集

**题目：** 给定两个数组 `nums1` 和 `nums2` ，返回 `nums1` 和 `nums2` 的交集。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize) {
    int* result = (int*)malloc(sizeof(int) * (nums1Size > nums2Size ? nums2Size : nums1Size));
    *returnSize = 0;

    int i = 0, j = 0;
    while (i < nums1Size && j < nums2Size) {
        if (nums1[i] == nums2[j]) {
            result[*returnSize] = nums1[i];
            (*returnSize)++;
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }

    return result;
}

int main() {
    int nums1[] = {1, 2, 2, 1};
    int nums2[] = {2, 2};
    int returnSize = 0;
    int* intersection = intersect(nums1, 4, nums2, 2, &returnSize);

    printf("Intersection of nums1 and nums2: ");
    for (int i = 0; i < returnSize; i++) {
        printf("%d ", intersection[i]);
    }
    printf("\n");

    free(intersection);

    return 0;
}
```

##### 26. 合并两个有序链表

**题目：** 给定两个有序链表 `l1` 和 `l2` ，将它们合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummy = (ListNode*)malloc(sizeof(ListNode));
    ListNode* tail = dummy;
    ListNode* curr1 = list1;
    ListNode* curr2 = list2;

    while (curr1 != NULL && curr2 != NULL) {
        if (curr1->val < curr2->val) {
            tail->next = curr1;
            curr1 = curr1->next;
        } else {
            tail->next = curr2;
            curr2 = curr2->next;
        }
        tail = tail->next;
    }

    tail->next = curr1 ? curr1 : curr2;

    return dummy->next;
}

void printList(ListNode* head) {
    while (head != NULL) {
        printf("%d ", head->val);
        head = head->next;
    }
    printf("\n");
}

int main() {
    ListNode* list1 = (ListNode*)malloc(sizeof(ListNode));
    list1->val = 1;
    list1->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->val = 3;
    list1->next->next = (ListNode*)malloc(sizeof(ListNode));
    list1->next->next->val = 5;

    ListNode* list2 = (ListNode*)malloc(sizeof(ListNode));
    list2->val = 2;
    list2->next = (ListNode*)malloc(sizeof(ListNode));
    list2->next->val = 4;
    list2->next->next = (ListNode*)malloc(sizeof(ListNode));
    list2->next->next->val = 6;

    printf("List 1: ");
    printList(list1);

    printf("List 2: ");
    printList(list2);

    ListNode* merged = mergeTwoLists(list1, list2);

    printf("Merged list: ");
    printList(merged);

    return 0;
}
```

##### 27. 搜索二维矩阵

**题目：** 编写一个高效的算法来搜索 `matrix` 中的一个目标值。该矩阵具有以下特性：

- 每行中的整数从左到右升序排列。
- 每个元素的值都大于其左下角的值。
- 每个元素的值都小于其右上角的值。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {
    int row = 0, col = matrixColSize[0] - 1;
    while (row < matrixSize && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] < target) {
            row++;
        } else {
            col--;
        }
    }
    return false;
}

int main() {
    int matrix[][] = {
        {1,   3,  5,  7},
        {10, 11, 16, 20},
        {23, 30, 34, 50}
    };
    int target = 3;
    int matrixColSize = 4;

    printf("Is %d in the matrix? %s\n", target, searchMatrix((int**)matrix, 3, &matrixColSize, target) ? "Yes" : "No");

    return 0;
}
```

##### 28. 合并区间

**题目：** 给出一个区间的列表，请合并所有重叠的区间。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct Interval {
    int start;
    int end;
} Interval;

bool compareIntervals(const void* a, const void* b) {
    Interval* intervalA = (Interval*)a;
    Interval* intervalB = (Interval*)b;
    return intervalA->start < intervalB->start;
}

Interval** merge(Interval* intervals[], int intervalsSize, int* returnSize) {
    if (intervalsSize == 0) {
        *returnSize = 0;
        return NULL;
    }

    qsort(intervals, intervalsSize, sizeof(Interval*), compareIntervals);

    Interval** merged = (Interval**)malloc(sizeof(Interval*) * (intervalsSize * 2));
    int j = 0;

    for (int i = 0; i < intervalsSize; i++) {
        if (j == 0 || intervals[i]->start > merged[j - 1]->end) {
            merged[j++] = intervals[i];
        } else {
            merged[j - 1]->end = intervals[i]->end;
        }
    }

    *returnSize = j;
    return merged;
}

void printIntervals(Interval** intervals, int size) {
    for (int i = 0; i < size; i++) {
        printf("(%d, %d)", intervals[i]->start, intervals[i]->end);
    }
    printf("\n");
}

int main() {
    Interval intervals[] = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
    int size = sizeof(intervals) / sizeof(intervals[0]);

    Interval** merged = merge(intervals, size, &size);

    printf("Merged intervals: ");
    printIntervals(merged, size);

    return 0;
}
```

##### 29. 二分查找

**题目：** 给定一个排序数组和一个目标值，找到数组中目标值的位置。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int search(int* nums, int numsSize, int target) {
    int left = 0;
    int right = numsSize - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

int main() {
    int nums[] = {4, 5, 6, 7, 0, 1, 2};
    int target = 0;

    printf("Index of target: %d\n", search(nums, 7, target));

    return 0;
}
```

##### 30. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个搜索算法，搜索给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1。

**答案：**

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

int search(int* nums, int numsSize, int target) {
    int left = 0;
    int right = numsSize - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            if (nums[right] >= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        } else {
            if (nums[left] <= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
    }

    return -1;
}

int main() {
    int nums[] = {4, 5, 6, 7, 0, 1, 2};
    int target = 0;

    printf("Index of target: %d\n", search(nums, 7, target));

    return 0;
}
```

### 总结

本文为您提供了意法半导体2025社招MCU开发工程师面试攻略，涵盖了典型面试题与算法编程题的详细解析与示例代码。通过对这些面试题的深入分析，您将更好地了解MCU开发工程师所需的技术知识和编程能力。希望本文能对您的面试准备提供帮助，祝您面试顺利！

