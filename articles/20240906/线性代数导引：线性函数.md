                 

### 线性代数导引：线性函数主题

#### 典型问题/面试题库和算法编程题库

1. **线性函数的定义及性质**
2. **矩阵的基本运算**
3. **矩阵的行列式**
4. **矩阵的逆**
5. **线性方程组的求解**
6. **向量空间与基**
7. **线性变换**
8. **特征值与特征向量**
9. **正交矩阵与对称矩阵**
10. **矩阵的正定性**

#### 极致详尽丰富的答案解析说明和源代码实例

##### 1. 线性函数的定义及性质

**面试题：** 简述线性函数的定义及性质。

**答案解析：**

线性函数是数学中一类非常基础的函数，其形式为 f(x) = ax + b，其中 a 和 b 是常数，x 是变量。线性函数具有以下几个性质：

1. **可加性**：对于任意的 x1 和 x2，线性函数满足 f(x1 + x2) = f(x1) + f(x2)。
2. **齐次性**：对于任意的 x 和任意常数 k，线性函数满足 f(kx) = kf(x)。
3. **图像为一条直线**：线性函数的图像是一条斜率为 a，截距为 b 的直线。

**源代码实例：**

```python
def linear_function(a, b, x):
    return a * x + b

# 测试线性函数的可加性和齐次性
assert linear_function(1, 2, 3) + linear_function(1, 2, 4) == linear_function(1, 2, 7)
assert linear_function(1, 2, 2 * 3) == 2 * linear_function(1, 2, 3)
```

##### 2. 矩阵的基本运算

**面试题：** 简述矩阵的加法、减法、数乘、矩阵乘法及其性质。

**答案解析：**

1. **矩阵加法**：对于任意两个大小相同的矩阵 A 和 B，其加法运算定义为 A + B = [aij + bij]，其中 i 和 j 分别表示行和列的索引。
2. **矩阵减法**：对于任意两个大小相同的矩阵 A 和 B，其减法运算定义为 A - B = [aij - bij]。
3. **数乘**：对于任意矩阵 A 和任意常数 k，其数乘运算定义为 kA = [kaij]。
4. **矩阵乘法**：对于任意两个矩阵 A（m×n）和 B（n×p），其乘法运算定义为 AB = [cij]，其中 cij = ∑(k=1 to n) aik * bkj。

这些运算是线性代数中基本且重要的运算，具有以下性质：

- **矩阵加法和减法**满足交换律、结合律和分配律。
- **数乘**满足结合律和分配律。
- **矩阵乘法**满足结合律和左分配律。

**源代码实例：**

```python
import numpy as np

# 创建矩阵
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# 矩阵加法
C = A + B

# 矩阵减法
D = A - B

# 数乘
k = 2
E = k * A

# 矩阵乘法
F = A @ B

# 测试性质
assert np.array_equal(C, B + A)
assert np.array_equal(D, A - B)
assert np.array_equal(E, 2 * A)
assert np.array_equal(F, A @ B)
```

##### 3. 矩阵的行列式

**面试题：** 简述矩阵行列式的定义、性质以及计算方法。

**答案解析：**

1. **定义**：矩阵行列式是矩阵元素按特定规则相乘后得到的一个标量值。对于 n×n 矩阵 A，其行列式记作 det(A) 或 |A|。
2. **性质**：
   - 行列式满足乘法法则：det(AB) = det(A) * det(B)。
   - 行列式满足交换律：det(AB) = det(BA)。
   - 行列式满足拉普拉斯展开定理：对于任意 k×k 子矩阵，其行列式可以展开为原矩阵每行（或每列）元素与对应 k×k 子矩阵行列式的乘积之和。
3. **计算方法**：可以使用拉普拉斯展开定理或高斯消元法来计算行列式。

**源代码实例：**

```python
import numpy as np

# 创建矩阵
A = np.array([[1, 2], [3, 4]])

# 计算行列式
det_A = np.linalg.det(A)

# 测试性质
assert np.isclose(np.linalg.det(A @ B), np.linalg.det(A) * np.linalg.det(B))
assert np.isclose(np.linalg.det(B @ A), np.linalg.det(A) * np.linalg.det(B))

# 使用拉普拉斯展开定理计算行列式
def determinant(A):
    n = A.shape[0]
    if n == 1:
        return A[0, 0]
    det = 0
    for j in range(n):
        det += ((-1) ** j) * A[0, j] * determinant(np.delete(A, 0, axis=0))
    return det

det_A_custom = determinant(A)
assert np.isclose(det_A, det_A_custom)
```

##### 4. 矩阵的逆

**面试题：** 简述矩阵逆的定义、性质以及计算方法。

**答案解析：**

1. **定义**：如果矩阵 A 的行列式不为零，那么存在唯一的矩阵 A^(-1)，使得 AA^(-1) = A^(-1)A = I，其中 I 是单位矩阵。
2. **性质**：
   - 矩阵的逆是唯一的。
   - 矩阵与其逆的乘积等于单位矩阵。
   - 如果矩阵 A 可逆，那么其伴随矩阵 adj(A) 的逆等于 A 的逆的伴随矩阵：adj(A^(-1)) = (adj(A))^(-1)。
3. **计算方法**：
   - 高斯消元法：通过高斯消元得到矩阵的逆。
   - 伴随矩阵法：计算伴随矩阵，然后取伴随矩阵的逆。
   - 迭代法：使用迭代算法逐步逼近矩阵的逆。

**源代码实例：**

```python
import numpy as np

# 创建矩阵
A = np.array([[1, 2], [3, 4]])

# 计算逆矩阵
A_inv = np.linalg.inv(A)

# 测试性质
assert np.array_equal(A @ A_inv, np.eye(2))
assert np.array_equal(A_inv @ A, np.eye(2))

# 使用伴随矩阵法计算逆矩阵
def inverse(A):
    n = A.shape[0]
    if n == 1:
        return 1 / A[0, 0]
    det = np.linalg.det(A)
    adj = np.linalg.inv(np.transpose(A))
    return (1 / det) * adj

A_inv_custom = inverse(A)
assert np.isclose(np.linalg.norm(A @ A_inv_custom - np.eye(2)), 0)
```

##### 5. 线性方程组的求解

**面试题：** 简述线性方程组的求解方法，如高斯消元法、矩阵逆法等。

**答案解析：**

1. **高斯消元法**：
   - 通过初等行变换将线性方程组转化为上三角或下三角形式。
   - 对上三角或下三角形式的线性方程组进行回代，求解变量。
2. **矩阵逆法**：
   - 如果线性方程组可以表示为 AX = B 的形式，且矩阵 A 可逆，则可以通过 X = A^(-1)B 直接求解。
3. **迭代法**：
   - 对于大型稀疏线性方程组，可以使用迭代法（如雅可比迭代法、高斯-赛德尔迭代法等）逐步逼近解。

**源代码实例：**

```python
import numpy as np

# 创建线性方程组
A = np.array([[2, -1], [-3, 2]])
B = np.array([1, 3])

# 使用高斯消元法求解
X = np.linalg.solve(A, B)

# 使用矩阵逆法求解
A_inv = np.linalg.inv(A)
X_inv = A_inv @ B

# 测试迭代法
def jacobi(A, b, x, tol=1e-10, max_iter=1000):
    n = A.shape[0]
    for _ in range(max_iter):
        x_new = np.copy(x)
        for i in range(n):
            s = np.dot(A[i, :], x) - b[i]
            x_new[i] = x[i] - (A[i, :].dot(x) - b[i]) / A[i, i]
        if np.linalg.norm(x_new - x) < tol:
            return x_new
        x = x_new
    return None

X_jacobi = jacobi(A, B, np.zeros(n))

print("X (solve):", X)
print("X (inv):", X_inv)
print("X (jacobi):", X_jacobi)
```

##### 6. 向量空间与基

**面试题：** 简述向量空间、基以及坐标变换。

**答案解析：**

1. **向量空间**：向量空间是一个集合，其中的元素是向量，并且定义了向量加法和标量乘法。
2. **基**：向量空间中一组线性无关的向量可以构成该向量空间的基。
3. **坐标变换**：通过基向量，可以将一个向量在不同基下表示，从而实现坐标变换。

**源代码实例：**

```python
import numpy as np

# 创建向量空间
V = np.array([[1, 0], [0, 1]])

# 选择基向量
B = np.array([[1, 1], [1, 0]])

# 坐标变换
def transform(v, B):
    return np.dot(B.T, v)

v = np.array([2, 1])
v_B = transform(v, B)

print("Original vector:", v)
print("Transformed vector in basis B:", v_B)
```

##### 7. 线性变换

**面试题：** 简述线性变换的定义、性质以及矩阵表示。

**答案解析：**

1. **定义**：线性变换是一个将向量空间中的向量映射到另一个向量空间中的函数，满足以下性质：
   - 对任意向量 x 和标量 k，线性变换 L 满足 L(kx) = kL(x)。
   - 对任意向量 x 和 y，线性变换 L 满足 L(x + y) = L(x) + L(y)。
2. **性质**：线性变换保持向量加法和标量乘法的运算。
3. **矩阵表示**：线性变换可以通过矩阵表示，即 L(x) = Ax，其中 A 是线性变换的矩阵。

**源代码实例：**

```python
import numpy as np

# 创建线性变换
def linear_transformation(A):
    def L(x):
        return np.dot(A, x)
    return L

# 创建矩阵
A = np.array([[1, 2], [3, 4]])

# 应用线性变换
L = linear_transformation(A)
x = np.array([1, 0])
y = np.array([0, 1])

print("Original vector x:", x)
print("Transformed vector x:", L(x))
print("Original vector y:", y)
print("Transformed vector y:", L(y))
```

##### 8. 特征值与特征向量

**面试题：** 简述特征值与特征向量的定义、性质以及求解方法。

**答案解析：**

1. **定义**：对于方阵 A，如果存在非零向量 x，使得 Ax = λx，其中 λ 是一个标量，那么 λ 是 A 的特征值，x 是 A 的特征向量。
2. **性质**：
   - 特征值是矩阵 A 的多项式特征方程的根。
   - 特征向量对应于特征值的线性无关。
3. **求解方法**：
   - 通过求解矩阵 A 的特征方程 det(A - λI) = 0，得到特征值。
   - 通过求解 (A - λI)x = 0，得到特征向量。

**源代码实例：**

```python
import numpy as np

# 创建矩阵
A = np.array([[2, 1], [1, 2]])

# 求解特征值和特征向量
eigenvalues, eigenvectors = np.linalg.eig(A)

print("Eigenvalues:", eigenvalues)
print("Eigenvectors:", eigenvectors)

# 验证特征值和特征向量
for i in range(len(eigenvalues)):
    x = eigenvectors[:, i]
    assert np.isclose(np.dot(A, x), eigenvalues[i] * x).all()
```

##### 9. 正交矩阵与对称矩阵

**面试题：** 简述正交矩阵与对称矩阵的定义、性质及其关系。

**答案解析：**

1. **定义**：
   - **正交矩阵**：如果一个方阵 A 的逆矩阵等于其转置矩阵，即 A^T = A^(-1)，则 A 是一个正交矩阵。
   - **对称矩阵**：如果一个方阵 A 的转置矩阵等于其本身，即 A^T = A，则 A 是一个对称矩阵。
2. **性质**：
   - 正交矩阵保持向量的长度和角度，即对任意向量 x，有 ||Ax|| = ||x|| 且 <Ax, Ay> = <x, y>。
   - 对称矩阵的特征值都是实数，且其特征向量可以正交化。
3. **关系**：
   - 对称矩阵可以通过正交矩阵对角化，即存在正交矩阵 P 和对角矩阵 D，使得 A = PDP^T。

**源代码实例：**

```python
import numpy as np

# 创建矩阵
A = np.array([[1, 2], [2, 3]])

# 判断是否为正交矩阵
is_orthogonal = np.allclose(A @ A.T, np.eye(2))

# 判断是否为对称矩阵
is_symmetric = np.allclose(A, A.T)

print("Is orthogonal:", is_orthogonal)
print("Is symmetric:", is_symmetric)

# 创建正交矩阵
P = np.random.rand(2, 2)
P = (P + P.T) / 2

# 创建对称矩阵
D = np.random.rand(2)
D = np.diag(D)

# 验证关系
A_orthogonal = P @ D @ P.T
A_symmetric = P @ D @ P.T

print("Orthogonal matrix:", P)
print("Diagonal matrix:", D)
print("Symmetric matrix:", A_orthogonal)
```

##### 10. 矩阵的正定性

**面试题：** 简述矩阵正定性的定义、性质以及判别方法。

**答案解析：**

1. **定义**：
   - **正定矩阵**：对于方阵 A，如果对于任意非零向量 x，都有 x^T A x > 0，则 A 是一个正定矩阵。
   - **半正定矩阵**：对于方阵 A，如果对于任意非零向量 x，都有 x^T A x ≥ 0，则 A 是一个半正定矩阵。
2. **性质**：
   - 正定矩阵的特征值都是正数。
   - 半正定矩阵的特征值都是非负数。
3. **判别方法**：
   - 使用行列式判别：对于 n×n 矩阵 A，如果对于任意的 k = 1, 2, ..., n，都有 det(A_k) > 0，则 A 是正定矩阵，其中 A_k 是 A 的 k 阶主子式。
   - 使用特征值判别：如果 A 的所有特征值都是正数，则 A 是正定矩阵。

**源代码实例：**

```python
import numpy as np

# 创建矩阵
A = np.array([[2, -1], [-1, 2]])

# 判断是否为正定矩阵
is_positive_definite = np.all(np.linalg.eigvals(A) > 0)

# 判断是否为半正定矩阵
is_positive_semidefinite = np.all(np.linalg.eigvals(A) ≥ 0)

print("Is positive definite:", is_positive_definite)
print("Is positive semidefinite:", is_positive_semidefinite)

# 验证判别方法
def is_positive_definite_by_det(A):
    n = A.shape[0]
    for k in range(1, n+1):
        if np.linalg.det(np.delete(np.delete(A, i, axis=0), j, axis=1)) <= 0:
            return False
    return True

for i in range(n):
    for j in range(n):
        if is_positive_definite_by_det(A):
            break
    else:
        break

if is_positive_definite_by_det(A):
    print("Positive definite by determinant method")
else:
    print("Not positive definite by determinant method")
```

### 11. 二分查找

**面试题：** 实现二分查找算法，并分析其时间复杂度。

**答案解析：**

二分查找算法是一种在有序数组中查找特定元素的算法。其基本思想是通过不断地将搜索范围缩小一半来查找目标元素。

**步骤：**

1. 将数组中间的元素与目标元素比较。
2. 如果中间元素等于目标元素，则查找成功。
3. 如果中间元素大于目标元素，则在数组的左半部分继续查找。
4. 如果中间元素小于目标元素，则在数组的右半部分继续查找。
5. 重复步骤1-4，直到找到目标元素或确定数组中不存在目标元素。

**源代码实例：**

```python
def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1

# 测试二分查找
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 5
result = binary_search(arr, target)
print(f"Element {target} is at index {result}.")
```

**时间复杂度分析：**

二分查找算法的时间复杂度为 O(log n)，其中 n 是数组的长度。这是因为每次搜索都会将搜索范围缩小一半，所以搜索次数是对数级别的。

### 12. 快速排序

**面试题：** 实现快速排序算法，并分析其平均时间复杂度和最坏时间复杂度。

**答案解析：**

快速排序算法是一种高效的排序算法，其基本思想是通过一趟排序将数组分为两部分，其中一部分的所有元素都比另一部分的所有元素小，然后递归地对这两部分进行排序。

**步骤：**

1. 选择一个基准元素。
2. 将数组中小于基准元素的元素移动到基准元素的左侧，大于基准元素的元素移动到基准元素的右侧。
3. 递归地对左右两部分进行快速排序。

**源代码实例：**

```python
def quicksort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quicksort(left) + middle + quicksort(right)

# 测试快速排序
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = quicksort(arr)
print("Sorted array:", sorted_arr)
```

**时间复杂度分析：**

- 平均时间复杂度：O(n log n)，因为每次划分都能大致将数组分为两个大小相近的部分。
- 最坏时间复杂度：O(n^2)，发生在每次划分时基准元素都位于数组的最小值或最大值处，导致划分效果不佳。

### 13. 堆排序

**面试题：** 实现堆排序算法，并分析其时间复杂度。

**答案解析：**

堆排序算法是一种利用堆这种数据结构的排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。

**步骤：**

1. 将数组构造成大顶堆（或小顶堆）。
2. 交换堆顶元素（最大或最小元素）与堆的最后一个元素，然后调整堆，使其重新满足堆的性质。
3. 重复步骤2，直到堆的大小为1。

**源代码实例：**

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapsort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

# 测试堆排序
arr = [12, 11, 13, 5, 6, 7]
heapsort(arr)
print("Sorted array:", arr)
```

**时间复杂度分析：**

堆排序的时间复杂度为 O(n log n)，因为构建堆需要 O(n) 的时间，而每次调整堆需要 O(log n) 的时间，总共需要进行 n 次调整。

### 14. 广度优先搜索（BFS）

**面试题：** 实现广度优先搜索算法，并分析其时间复杂度。

**答案解析：**

广度优先搜索（BFS）是一种用于图遍历的算法，其基本思想是从起始节点开始，依次遍历其所有邻居节点，然后再依次遍历邻居节点的邻居节点，以此类推。

**步骤：**

1. 使用一个队列存储已遍历的节点。
2. 将起始节点加入队列。
3. 当队列不为空时，循环执行以下操作：
   - 从队列中取出队首节点。
   - 访问该节点，并将其所有未遍历的邻居节点加入队列。

**源代码实例：**

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])

    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node)
            visited.add(node)
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)

# 测试广度优先搜索
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
bfs(graph, 'A')
```

**时间复杂度分析：**

广度优先搜索的时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数。这是因为每个节点和每条边都会被访问一次。

### 15. 深度优先搜索（DFS）

**面试题：** 实现深度优先搜索算法，并分析其时间复杂度。

**答案解析：**

深度优先搜索（DFS）是一种用于图遍历的算法，其基本思想是从起始节点开始，沿着某一路径不断深入直到该路径的尽头，然后回溯到上一个节点，再寻找新的路径。

**步骤：**

1. 使用一个递归函数遍历节点，并在每次遍历结束时回溯。
2. 对于当前节点，访问该节点，并将其所有未遍历的邻居节点加入递归函数的参数列表。

**源代码实例：**

```python
def dfs(graph, node, visited):
    if node not in visited:
        print(node)
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)

# 测试深度优先搜索
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
dfs(graph, 'A', set())
```

**时间复杂度分析：**

深度优先搜索的时间复杂度为 O(V+E)，其中 V 是节点数，E 是边数。这是因为每个节点和每条边都会被访问一次。

### 16. 归并排序

**面试题：** 实现归并排序算法，并分析其时间复杂度。

**答案解析：**

归并排序是一种分治算法，其基本思想是将数组划分为两个子数组，分别对两个子数组进行排序，然后将排序后的子数组合并成一个有序的数组。

**步骤：**

1. 将数组划分为两个子数组，分别对两个子数组进行递归排序。
2. 将两个已排序的子数组合并成一个有序的数组。

**源代码实例：**

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# 测试归并排序
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = merge_sort(arr)
print("Sorted array:", sorted_arr)
```

**时间复杂度分析：**

归并排序的时间复杂度为 O(n log n)，因为每次划分需要 O(log n) 次，每次合并需要 O(n) 次。

### 17. 快速选择算法

**面试题：** 实现快速选择算法，并分析其平均时间复杂度和最坏时间复杂度。

**答案解析：**

快速选择算法是一种用于选择第 k 个最小元素的算法，其基本思想是利用快速排序的划分步骤，选择一个基准元素，将数组划分为两部分，然后根据 k 的值决定递归地搜索哪一部分。

**步骤：**

1. 选择一个基准元素。
2. 将数组中小于基准元素的元素移动到基准元素的左侧，大于基准元素的元素移动到基准元素的右侧。
3. 根据基准元素的位置判断是否找到第 k 个最小元素：
   - 如果基准元素的位置等于 k，则找到第 k 个最小元素。
   - 如果基准元素的位置大于 k，则在左侧子数组中递归地寻找第 k 个最小元素。
   - 如果基准元素的位置小于 k，则在右侧子数组中递归地寻找第 k + i 个最小元素，其中 i 是基准元素左侧的元素个数。

**源代码实例：**

```python
def quickselect(arr, k):
    if len(arr) == 1:
        return arr[0]

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    if k < len(left):
        return quickselect(left, k)
    elif k < len(left) + len(middle):
        return arr[k]
    else:
        return quickselect(right, k - len(left) - len(middle))

# 测试快速选择算法
arr = [3, 6, 8, 10, 1, 2, 1]
k = 2
result = quickselect(arr, k - 1)
print(f"The {k}th smallest element is {result}.")
```

**时间复杂度分析：**

- 平均时间复杂度：O(n)，因为每次划分都能较好地将数组划分为两个大小相近的部分。
- 最坏时间复杂度：O(n^2)，发生在每次划分时基准元素都位于数组的最小值或最大值处，导致划分效果不佳。

### 18. 计数排序

**面试题：** 实现计数排序算法，并分析其时间复杂度。

**答案解析：**

计数排序是一种非比较型排序算法，其基本思想是统计数组中每个元素的个数，然后将每个元素按照其出现的次数依次放入原数组中。

**步骤：**

1. 找出数组的最大值和最小值，计算它们的差值 d。
2. 创建一个计数数组 count，长度为 d+1，初始化为0。
3. 遍历原数组，将每个元素在计数数组中的对应位置加1。
4. 遍历计数数组，将每个元素的值设置为它的前一个元素的值加1，即 count[i] = count[i-1] + 1。
5. 遍历原数组，将每个元素放入其在计数数组中的对应位置，并将计数数组中的值减1。

**源代码实例：**

```python
def counting_sort(arr):
    max_val = max(arr)
    min_val = min(arr)
    range_val = max_val - min_val + 1

    count = [0] * range_val
    output = [0] * len(arr)

    for num in arr:
        count[num - min_val] += 1

    for i in range(1, range_val):
        count[i] += count[i - 1]

    for num in arr:
        output[count[num - min_val] - 1] = num
        count[num - min_val] -= 1

    return output

# 测试计数排序
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = counting_sort(arr)
print("Sorted array:", sorted_arr)
```

**时间复杂度分析：**

计数排序的时间复杂度为 O(n+k)，其中 n 是数组长度，k 是数组的范围（最大值和最小值的差值）。这是因为需要遍历原数组两次，分别计算计数和构建输出数组，而计算计数需要遍历数组的范围。

### 19. 哈希表

**面试题：** 简述哈希表的工作原理及其优点和缺点。

**答案解析：**

哈希表是一种基于哈希函数的数据结构，用于快速查找、插入和删除操作。其基本原理如下：

1. **哈希函数**：将关键字（键）映射到哈希表中的一个索引。
2. **冲突处理**：当两个或多个关键字映射到同一个索引时，通过特定的策略处理冲突。
3. **链表或开放地址法**：常见的冲突处理方法有链表法和开放地址法。

**优点：**

- **查找速度快**：平均时间复杂度为 O(1)。
- **动态扩展**：可以根据需要动态调整大小。

**缺点：**

- **哈希冲突**：可能导致性能下降。
- **内存开销**：需要额外的空间存储哈希表和链表。

**源代码实例：**

```python
class HashTable:
    def __init__(self):
        self.size = 10
        self.table = [None] * self.size

    def hash(self, key):
        return key % self.size

    def insert(self, key, value):
        index = self.hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            self.table[index].append((key, value))

    def search(self, key):
        index = self.hash(key)
        if self.table[index] is None:
            return None
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

    def delete(self, key):
        index = self.hash(key)
        if self.table[index] is None:
            return
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                break

# 测试哈希表
hash_table = HashTable()
hash_table.insert(1, "one")
hash_table.insert(2, "two")
hash_table.insert(3, "three")
print(hash_table.search(2))  # 输出 "two"
hash_table.delete(2)
print(hash_table.search(2))  # 输出 None
```

### 20. 常见的排序算法时间复杂度对比

**面试题：** 比较常见的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序）的时间复杂度，并分析它们的适用场景。

**答案解析：**

| 排序算法 | 时间复杂度（平均）/（最坏） | 时间复杂度（最好） | 适用场景 |
| --- | --- | --- | --- |
| 冒泡排序 | O(n^2) / O(n^2) | O(n) | 数据几乎是有序的情况下，小规模数据集 |
| 选择排序 | O(n^2) / O(n^2) | O(n^2) | 数据几乎是无序的情况下，小规模数据集 |
| 插入排序 | O(n^2) / O(n) | O(n) | 数据部分有序，小规模数据集 |
| 快速排序 | O(n log n) / O(n^2) | O(n log n) | 大规模数据集 |
| 归并排序 | O(n log n) / O(n log n) | O(n log n) | 大规模数据集 |
| 堆排序 | O(n log n) / O(n log n) | O(n log n) | 大规模数据集 |

**适用场景：**

- **冒泡排序**：适用于小规模数据集，特别是数据几乎是有序的情况下，因为其实现简单且性能较稳定。
- **选择排序**：适用于小规模数据集，特别是数据几乎是无序的情况下，因为其实现简单且性能较稳定。
- **插入排序**：适用于数据部分有序，特别是小规模数据集，因为其实现简单且性能较稳定。
- **快速排序**：适用于大规模数据集，因为其平均性能优秀，但最坏情况下的性能较差。
- **归并排序**：适用于大规模数据集，因为其性能稳定，但实现较复杂。
- **堆排序**：适用于大规模数据集，因为其性能稳定且实现简单。

