                 

### 百度2024社招面试真题与算法题解

#### 1. 单链表反转

**题目描述：** 实现一个函数，对单链表进行反转。

**输入：** 一个单链表的头节点。

**输出：** 反转后的单链表的头节点。

**题目链接：** [LeetCode - 206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    var curr = head

    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**解析：** 该算法采用迭代的方式，依次遍历链表中的每个节点，将当前节点的 `next` 指针指向前一个节点，从而实现链表的反转。

#### 2. 二分查找

**题目描述：** 实现一个二分查找函数，在有序数组中查找某个元素。

**输入：** 有序数组 `nums` 和目标值 `target`。

**输出：** 目标值在数组中的索引，如果不存在则返回 `-1`。

**题目链接：** [LeetCode - 704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

**答案：**

```go
func search(nums []int, target int) int {
    low, high := 0, len(nums)-1
    for low <= high {
        mid := (low + high) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}
```

**解析：** 该算法通过不断缩小区间的方式查找目标值，时间复杂度为 O(log n)。

#### 3. 快排

**题目描述：** 实现快速排序算法。

**输入：** 数组 `nums`。

**输出：** 排序后的数组。

**题目链接：** [LeetCode - 215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

**答案：**

```go
func quickSort(nums []int) {
    quickSortHelper(nums, 0, len(nums)-1)
}

func quickSortHelper(nums []int, left, right int) {
    if left >= right {
        return
    }
    pivot := partition(nums, left, right)
    quickSortHelper(nums, left, pivot-1)
    quickSortHelper(nums, pivot+1, right)
}

func partition(nums []int, left, right int) int {
    pivot := nums[right]
    i := left
    for j := left; j < right; j++ {
        if nums[j] > pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    nums[i], nums[right] = nums[right], nums[i]
    return i
}
```

**解析：** 快排是一种不稳定的排序算法，通过选取一个基准元素，将数组分成两部分，然后递归地对两部分进行排序。

#### 4. 二叉树遍历

**题目描述：** 实现二叉树的先序、中序和后序遍历。

**输入：** 二叉树的根节点。

**输出：** 遍历结果数组。

**题目链接：** [LeetCode - 94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**答案：**

```go
// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    var result []int
    traversal(root, &result)
    return result
}

func traversal(root *TreeNode, result *[]int) {
    if root == nil {
        return
    }
    traversal(root.Left, result)
    *result = append(*result, root.Val)
    traversal(root.Right, result)
}

// 先序遍历
func preorderTraversal(root *TreeNode) []int {
    var result []int
    traversalPreorder(root, &result)
    return result
}

func traversalPreorder(root *TreeNode, result *[]int) {
    if root == nil {
        return
    }
    *result = append(*result, root.Val)
    traversalPreorder(root.Left, result)
    traversalPreorder(root.Right, result)
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    var result []int
    traversalPostorder(root, &result)
    return result
}

func traversalPostorder(root *TreeNode, result *[]int) {
    if root == nil {
        return
    }
    traversalPostorder(root.Left, result)
    traversalPostorder(root.Right, result)
    *result = append(*result, root.Val)
}
```

**解析：** 二叉树的遍历可以分为先序、中序和后序三种。先序遍历先访问根节点，然后递归地遍历左子树和右子树；中序遍历先递归地遍历左子树，然后访问根节点，最后递归地遍历右子树；后序遍历先递归地遍历左子树，然后递归地遍历右子树，最后访问根节点。

#### 5. 最长公共前缀

**题目描述：** 找出字符串数组中的最长公共前缀。

**输入：** 字符串数组 `strs`。

**输出：** 最长公共前缀。

**题目链接：** [LeetCode - 14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 该算法通过比较字符串数组中的每个字符串，找到它们的最长公共前缀。时间复杂度为 O(mn)，其中 m 是字符串的平均长度，n 是字符串的数量。

#### 6. 两数相加

**题目描述：** 给出两个非空链表表示的两个非负整数，分别位于链表节点的.val中，将这两个数相加并返回一个新的链表。

**输入：** 链表 l1 和 l2。

**输出：** 相加后的链表。

**题目链接：** [LeetCode - 2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }

    return dummy.Next
}
```

**解析：** 该算法通过模拟加法运算，依次处理链表中的每个节点，将两个链表的对应节点的值相加，再加上前一位的进位，得到当前位的和。如果和大于等于10，则会产生进位。时间复杂度为 O(max(m, n))，其中 m 和 n 分别是两个链表的长度。

#### 7. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。

**输入：** 链表 l1 和 l2。

**输出：** 合并后的链表。

**题目链接：** [LeetCode - 21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该算法通过比较两个链表的当前节点值，选择较小值作为下一个节点，递归地合并两个链表。时间复杂度为 O(m+n)，其中 m 和 n 分别是两个链表的长度。

#### 8. 字符串匹配

**题目描述：** 实现字符串匹配算法，找出字符串 `s` 中第一个与 `pattern` 匹配的子串。

**输入：** 字符串 `s` 和 `pattern`。

**输出：** 子串的起始索引，如果不存在则返回 `-1`。

**题目链接：** [LeetCode - 28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

**答案：**

```go
func strStr(s string, pattern string) int {
    if pattern == "" {
        return 0
    }
    for i := 0; i < len(s)-len(pattern)+1; i++ {
        j := 0
        for j < len(pattern) && s[i+j] == pattern[j] {
            j++
        }
        if j == len(pattern) {
            return i
        }
    }
    return -1
}
```

**解析：** 该算法通过遍历字符串 `s`，对每个子串与 `pattern` 进行比较，直到找到匹配的子串。时间复杂度为 O(n*m)，其中 n 是字符串 `s` 的长度，m 是字符串 `pattern` 的长度。

#### 9. 汇总计算器

**题目描述：** 实现一个计算器，能够解析并计算包含加、减、乘、除等运算符的表达式。

**输入：** 字符串表达式。

**输出：** 计算结果。

**题目链接：** [LeetCode - 224. 实现基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

**答案：**

```go
func calculate(s string) int {
    var (
        num    int
        sign   = '+'
        stack  []int
    )
    for i, c := range s {
        if c >= '0' && c <= '9' {
            num = num*10 + int(c-'0')
        }
        if c == '+' || c == '-' || c == '*' || c == '/' || i == len(s)-1 {
            switch sign {
            case '+':
                stack = append(stack, num)
            case '-':
                stack = append(stack, -num)
            case '*':
                stack = append(stack, stack[len(stack)-2]*num)
            case '/':
                stack = append(stack, stack[len(stack)-2]/num)
            }
            sign = string(c)
            num = 0
        }
    }
    for i := 1; i < len(stack); i += 2 {
        stack[i] = stack[i-1]*stack[i]
    }
    for i := 0; i < len(stack); i += 2 {
        stack[i] += stack[i+1]
    }
    return stack[0]
}
```

**解析：** 该算法采用逆波兰表达式（后缀表达式）的方式，将表达式转换为栈运算。通过遍历表达式，将数字和运算符分别入栈，根据运算符进行相应的计算。

#### 10. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。

**输入：** 字符串 `text1` 和 `text2`。

**输出：** 最长公共子序列的长度。

**题目链接：** [LeetCode - 1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 该算法使用动态规划求解最长公共子序列，创建一个二维数组 `dp` 存储子序列的长度。通过比较两个字符串的对应字符，更新 `dp` 数组的值。

#### 11. 最小路径和

**题目描述：** 给定一个包含非负整数的二维数组 `grid`，找出从左上角到右下角的最小路径和。

**输入：** 二维数组 `grid`。

**输出：** 最小路径和。

**题目链接：** [LeetCode - 64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 1; i < m; i++ {
        grid[i][0] += grid[i-1][0]
    }
    for j := 1; j < n; j++ {
        grid[0][j] += grid[0][j-1]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            grid[i][j] += min(grid[i-1][j], grid[i][j-1])
        }
    }
    return grid[m-1][n-1]
}
```

**解析：** 该算法采用动态规划的方法，从右下角到左上角更新路径和。每次更新当前节点的值为其上方和左方节点的最小值加上当前节点的值。

#### 12. 合并两个有序数组

**题目描述：** 将两个有序数组合并为一个有序数组。

**输入：** 有序数组 `nums1` 和 `nums2`。

**输出：** 合并后的有序数组。

**题目链接：** [LeetCode - 88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        k--
        j--
    }
}
```

**解析：** 该算法从两个数组的尾部开始比较，将较大的值放入新的数组 `nums1` 的尾部，最后剩下的元素就是合并后的有序数组。

#### 13. 爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 `n` 阶才能到达楼顶，每次你可以爬 1 或 2 个台阶。编写一个函数，返回到达楼顶共有多少种不同的方法。

**输入：** `n`。

**输出：** 到达楼顶的方法数。

**题目链接：** [LeetCode - 70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

**答案：**

```go
func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    if n == 2 {
        return 2
    }
    dp := make([]int, n+1)
    dp[1] = 1
    dp[2] = 2
    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

**解析：** 该算法使用动态规划求解，`dp[i]` 表示到达第 `i` 阶的方法数。根据状态转移方程 `dp[i] = dp[i-1] + dp[i-2]`，计算出每个阶的方法数。

#### 14. 二进制中1的个数

**题目描述：** 编写一个函数，计算一个无符号整数二进制表示中 1 的个数。

**输入：** 无符号整数 `n`。

**输出：** 1 的个数。

**题目链接：** [LeetCode - 191. 二进制中1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

**答案：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count += int(num & 1)
        num >>= 1
    }
    return count
}
```

**解析：** 该算法通过不断右移操作，检查二进制表示的每一位是否为 1，并计数。

#### 15. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**输入：** 字符串数组 `strs`。

**输出：** 最长公共前缀。

**题目链接：** [LeetCode - 14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 该算法通过逐个比较字符串数组中的每个字符串，找到它们的最长公共前缀。

#### 16. 搜索插入位置

**题目描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它应当被按顺序插入的位置。

**输入：** 排序数组 `nums` 和目标值 `target`。

**输出：** 目标值的索引或插入位置。

**题目链接：** [LeetCode - 35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

**答案：**

```go
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return left
}
```

**解析：** 该算法使用二分查找的方法，在排序数组中查找目标值，如果目标值不存在，返回应该插入的位置。

#### 17. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。

**输入：** 有序链表 `l1` 和 `l2`。

**输出：** 合并后的有序链表。

**题目链接：** [LeetCode - 21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该算法通过比较两个链表的当前节点值，选择较小值作为下一个节点，递归地合并两个链表。

#### 18. 最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到其中最长子数组的和。

**输入：** 整数数组 `nums`。

**输出：** 最大子序和。

**题目链接：** [LeetCode - 53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

**答案：**

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    maxSum := nums[0]
    curSum := nums[0]
    for i := 1; i < len(nums); i++ {
        curSum = max(nums[i], curSum+nums[i])
        maxSum = max(maxSum, curSum)
    }
    return maxSum
}
```

**解析：** 该算法使用动态规划的方法，维护当前子序列的和，更新最大子序列的和。

#### 19. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**输入：** 链表的头节点。

**输出：** 是否存在环。

**题目链接：** [LeetCode - 141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

**答案：**

```go
func hasCycle(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return false
    }
    slow := head
    fast := head.Next
    for slow != fast {
        if fast == nil || fast.Next == nil {
            return false
        }
        slow = slow.Next
        fast = fast.Next.Next
    }
    return true
}
```

**解析：** 该算法使用快慢指针的方法，如果链表中存在环，那么快指针最终会追上慢指针。

#### 20. 最小栈

**题目描述：** 实现一个具有最小栈功能的栈。

**输入：** 栈的元素。

**输出：** 栈的最小元素。

**题目链接：** [LeetCode - 155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

**答案：**

```go
type MinStack struct {
    stack   []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack:   []int{},
        minStack: []int{},
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if len(this.minStack) == 0 || val <= this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    }
}

func (this *MinStack) Pop() {
    if this.stack[len(this.stack)-1] == this.minStack[len(this.minStack)-1] {
        this.minStack = this.minStack[:len(this.minStack)-1]
    }
    this.stack = this.stack[:len(this.stack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

**解析：** 该算法通过维护一个辅助栈 `minStack` 来记录当前栈的最小元素，实现最小栈功能。

#### 21. 扰乱字符串

**题目描述：** 给定一个字符串 `s`，将 `s` 扰乱并返回其扰乱后的字符串。扰乱字符串的定义是：将字符串的一半全部反转后再与另一半拼接。

**输入：** 字符串 `s`。

**输出：** 扰乱后的字符串。

**题目链接：** [LeetCode - 186. 扰乱字符串](https://leetcode-cn.com/problems/shuffle-string/)

**答案：**

```go
func shuffle(s string, indices []int) string {
    arr := []byte(s)
    for i, j := 0, len(s)/2-1; i < j; i++ {
        arr[i], arr[j] = arr[j], arr[i]
    }
    n := len(s) / 2
    for i, j := 0, n-1; i < j; i++ {
        arr[i+n], arr[j] = arr[j], arr[i+n]
    }
    return string(arr)
}
```

**解析：** 该算法通过反转前半部分和后半部分的字符串，然后交换对应位置的字符，实现字符串的扰乱。

#### 22. 翻转单词中的单词

**题目描述：** 给定一个字符串 `s`，逐个翻转字符串中的单词。

**输入：** 字符串 `s`。

**输出：** 翻转后的字符串。

**题目链接：** [LeetCode - 151. 翻转单词中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

**答案：**

```go
func reverseWords(s string) string {
    words := strings.Fields(s)
    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
        words[i], words[j] = words[j], words[i]
    }
    return strings.Join(words, " ")
}
```

**解析：** 该算法通过两次遍历，首先反转整个字符串，然后反转每个单词。

#### 23. 找到字符串中所有字母异位词

**题目描述：** 给定一个字符串 `s` 和一个字符串 `word`，找出 `s` 中所有 `word` 的字母异位词。

**输入：** 字符串 `s` 和 `word`。

**输出：** 字母异位词的索引列表。

**题目链接：** [LeetCode - 242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

**答案：**

```go
func findAnagrams(s string, p string) []int {
    countS, countP := [26]int{}, [26]int{}
    for _, c := range s {
        countS[c - 'a']++
    }
    for _, c := range p {
        countP[c - 'a']++
    }
    var ans []int
    n := len(s)
    for i := 0; i <= n-len(p); i++ {
        cnt := [26]int{}
        for j := 0; j < len(p); j++ {
            cnt[p[j]-'a']++
        }
        if equal(cnt, countS[i:i+len(p)]) {
            ans = append(ans, i)
        }
    }
    return ans
}

func equal(a, b [26]int) bool {
    for i := 0; i < 26; i++ {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

**解析：** 该算法使用哈希表统计字符串 `s` 和 `p` 中每个字符的频次，然后对 `s` 的子串进行遍历，判断每个子串是否与 `p` 的字符频次相同。

#### 24. 删除链表的节点

**题目描述：** 给定一个单链表的头节点 `head` 和一个整数 `val`，删除链表中所有值为 `val` 的节点。

**输入：** 单链表的头节点 `head` 和整数 `val`。

**输出：** 删除节点后的链表。

**题目链接：** [LeetCode - 203. 删除链表中等于给定值的节点](https://leetcode-cn.com/problems/remove-linked-list-elements/)

**答案：**

```go
func removeElements(head *ListNode, val int) *ListNode {
    dummy := &ListNode{Val: -1, Next: head}
    prev, curr := dummy, head
    for curr != nil {
        if curr.Val == val {
            prev.Next = curr.Next
        } else {
            prev = curr
        }
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：** 该算法通过虚拟头节点，遍历链表，删除所有值为 `val` 的节点。

#### 25. 螺旋矩阵

**题目描述：** 给定一个 `m x n` 的矩阵 `matrix`，按照螺旋顺序返回矩阵中的所有元素。

**输入：** 矩阵 `matrix`。

**输出：** 螺旋矩阵的元素。

**题目链接：** [LeetCode - 54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

**答案：**

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    m, n := len(matrix), len(matrix[0])
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }
    ans := make([]int, 0, m*n)
    t, b, l, r := 0, m-1, 0, n-1
    for len(ans) < m*n {
        for j := l; j <= r && len(ans) < m*n; j++ {
            ans = append(ans, matrix[t][j])
            visited[t][j] = true
        }
        t++
        for i := t; i <= b && len(ans) < m*n; i++ {
            ans = append(ans, matrix[i][r])
            visited[i][r] = true
        }
        r--
        for j := r; j >= l && len(ans) < m*n; j-- {
            ans = append(ans, matrix[b][j])
            visited[b][j] = true
        }
        b--
        for i := b; i >= t && len(ans) < m*n; i-- {
            ans = append(ans, matrix[i][l])
            visited[i][l] = true
        }
        l++
    }
    return ans
}
```

**解析：** 该算法通过模拟螺旋路径，逐层遍历矩阵的所有元素。

#### 26. 合并两个有序链表

**题目描述：** 给定两个有序链表 `l1` 和 `l2`，将它们合并为一个新的有序链表并返回。

**输入：** 有序链表 `l1` 和 `l2`。

**输出：** 合并后的有序链表。

**题目链接：** [LeetCode - 21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 该算法通过比较两个链表的当前节点值，选择较小值作为下一个节点，递归地合并两个链表。

#### 27. 调整数组顺序使奇数位于偶数之前

**题目描述：** 给定一个整数数组 `nums`，请调整数组中的元素顺序，将所有奇数位于偶数之前。

**输入：** 整数数组 `nums`。

**输出：** 调整后的整数数组。

**题目链接：** [LeetCode - 926. 调整数组顺序使奇数位于偶数之前](https://leetcode-cn.com/problems/transpose-matrix/)

**答案：**

```go
func exchange(nums []int) []int {
    j := 0
    for i := 0; i < len(nums); i++ {
        if nums[i]%2 == 1 {
            nums[i], nums[j] = nums[j], nums[i]
            j++
        }
    }
    return nums
}
```

**解析：** 该算法通过双指针的方法，将奇数和偶数进行交换，实现奇数位于偶数之前。

#### 28. 合并区间

**题目描述：** 给定一组区间，将它们合并为不相交的区间。

**输入：** 一组区间。

**输出：** 合并后的区间。

**题目链接：** [LeetCode - 56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

**答案：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return [][]int{}
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{intervals[0]}
    for i := 1; i < len(intervals); i++ {
        prev := ans[len(ans)-1]
        if intervals[i][0] <= prev[1] {
            prev[1] = max(prev[1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}
```

**解析：** 该算法通过排序和双指针的方法，将重叠的区间合并。

#### 29. 搜索旋转排序数组

**题目描述：** 给定一个旋转排序的数组，找出一个给定的目标值。

**输入：** 旋转排序的数组 `nums` 和目标值 `target`。

**输出：** 目标值的索引，如果不存在则返回 `-1`。

**题目链接：** [LeetCode - 33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 该算法通过二分查找的方法，在旋转排序的数组中找到目标值。

#### 30. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**输入：** 整数数组 `nums` 和目标值 `target`。

**输出：** 数组下标。

**题目链接：** [LeetCode - 1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

**答案：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

**解析：** 该算法使用哈希表记录每个数字出现的索引，通过查找补数来实现两数之和。

