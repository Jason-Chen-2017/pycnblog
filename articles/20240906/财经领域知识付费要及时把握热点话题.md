                 

## 财经领域知识付费要及时把握热点话题

### 面试题库

### 1. 金融风险评估模型有哪些？

**答案：** 金融风险评估模型主要包括以下几种：

- **Credit Risk Model（信用风险模型）：** 包括 KMV 模型、CreditMetrics 模型、Credit Portfolio View 模型等。
- **Market Risk Model（市场风险模型）：** 包括 Value at Risk（VaR）、条件期望损失（Expected Shortfall，ES）等。
- **Operational Risk Model（运营风险模型）：** 包括损失事件频率模型、损失严重度模型等。

**解析：** 这些模型分别用于评估金融机构在信用、市场、运营等方面的风险，帮助金融机构制定风险管理策略。

### 2. 金融机构的盈利模式有哪些？

**答案：** 金融机构的盈利模式主要包括以下几种：

- **存贷利差：** 通过吸收存款，以更高的利率发放贷款，从而获得利差收入。
- **中间业务：** 包括支付结算、资产管理、财务顾问、担保等，通过提供服务收取手续费。
- **投资收益：** 通过投资股票、债券、基金等获得收益。
- **利息收入：** 包括债券利息、股息等。
- **外汇交易：** 通过外汇买卖获得差价收入。

**解析：** 这些盈利模式是金融机构实现收入的主要方式，不同类型的金融机构可能侧重不同的盈利模式。

### 3. 财务报表分析的核心指标有哪些？

**答案：** 财务报表分析的核心指标包括：

- **利润表指标：** 包括营业收入、净利润、毛利率、净利率等。
- **资产负债表指标：** 包括总资产、总负债、股东权益、资产负债率等。
- **现金流量表指标：** 包括经营现金流、投资现金流、融资现金流等。

**解析：** 这些指标可以帮助投资者、分析师等了解企业的财务状况、盈利能力、偿债能力等，从而做出投资决策。

### 4. 如何评估一个公司的价值？

**答案：** 评估一个公司的价值通常采用以下方法：

- **市盈率（PE）：** 将公司的市值除以净利润，反映公司的估值水平。
- **市净率（PB）：** 将公司的市值除以净资产，用于评估公司的估值是否合理。
- **企业价值/息税折旧摊销前利润（EV/EBITDA）：** 综合反映公司的盈利能力和估值水平。

**解析：** 这些指标从不同角度衡量公司的价值，投资者可以根据市场状况、公司行业特点等因素综合运用。

### 5. 股票市场有哪些主要的参与者？

**答案：** 股票市场的主要参与者包括：

- **投资者：** 包括个人投资者、机构投资者等。
- **公司：** 通过发行股票进行融资。
- **金融机构：** 包括证券公司、银行、基金公司等。
- **监管机构：** 包括证券交易所、证监会等。

**解析：** 这些参与者共同构成了股票市场的生态圈，推动市场的运行。

### 6. 金融衍生品有哪些？

**答案：** 金融衍生品主要包括以下几种：

- **期货：** 包括商品期货和金融期货。
- **期权：** 给予持有人在未来某个时间以特定价格买入或卖出某资产的权利。
- **互换：** 包括利率互换、货币互换等。
- **掉期：** 包括利率掉期、外汇掉期等。

**解析：** 金融衍生品是投资者和管理风险的重要工具，可以帮助投资者实现资产配置和风险控制。

### 7. 货币政策的传导机制是什么？

**答案：** 货币政策的传导机制主要包括以下环节：

- **央行调整基准利率：** 通过调整再贷款、再贴现、存款准备金率等手段影响市场利率。
- **市场利率变化：** 通过影响金融机构的贷款利率、存款利率等，进而影响实体经济融资成本。
- **实体经济活动：** 包括消费、投资、就业等。

**解析：** 货币政策的传导机制是央行通过调节市场利率影响实体经济的关键途径。

### 8. 中央银行的主要职责有哪些？

**答案：** 中央银行的主要职责包括：

- **制定和执行货币政策：** 调节货币供应量、利率水平等，维持宏观经济稳定。
- **维护金融稳定：** 监管金融机构，防范和化解金融风险。
- **发行货币：** 负责货币的发行和管理。
- **提供金融服务：** 为政府和金融机构提供支付结算、资金拆借等金融服务。

**解析：** 中央银行作为国家的金融管理部门，承担着维护国家金融稳定、促进经济发展的重任。

### 9. 财政政策的主要工具有哪些？

**答案：** 财政政策的主要工具包括：

- **政府支出：** 包括基础设施建设、社会福利等。
- **税收：** 包括个人所得税、企业所得税、消费税等。
- **转移支付：** 包括社会保障、扶贫等。

**解析：** 财政政策通过调节政府支出、税收和转移支付，影响经济活动，实现宏观经济调控目标。

### 10. 如何理解通货膨胀？

**答案：** 通货膨胀是指货币供应量增加导致物价水平持续上涨的现象。其特征包括：

- **物价水平普遍上涨：** 包括消费品、服务、资产等各类价格。
- **持续上涨：** 通货膨胀通常是长期趋势，而非短期波动。
- **货币贬值：** 货币的购买力下降。

**解析：** 理解通货膨胀对于制定货币政策、评估经济形势具有重要意义。

### 11. 如何理解通货紧缩？

**答案：** 通货紧缩是指货币供应量减少导致物价水平持续下跌的现象。其特征包括：

- **物价水平普遍下跌：** 包括消费品、服务、资产等各类价格。
- **持续下跌：** 通货紧缩通常是长期趋势，而非短期波动。
- **货币升值：** 货币的购买力上升。

**解析：** 理解通货紧缩对于制定货币政策、促进经济复苏具有重要意义。

### 12. 外汇市场的参与主体有哪些？

**答案：** 外汇市场的参与主体包括：

- **中央银行：** 通过外汇干预调节汇率。
- **商业银行：** 提供外汇买卖服务，满足企业和个人需求。
- **跨国公司：** 通过外汇交易进行跨国经营。
- **投资基金：** 通过外汇交易进行全球资产配置。

**解析：** 外汇市场的参与主体共同推动了外汇市场的交易活动。

### 13. 货币政策工具有哪些？

**答案：** 货币政策工具主要包括：

- **存款准备金率：** 调节商业银行的存款准备金比例。
- **再贷款和再贴现：** 向商业银行提供贷款和贴现。
- **公开市场操作：** 通过买卖政府债券调节市场流动性。
- **基准利率：** 包括再贷款利率、再贴现利率等。

**解析：** 货币政策工具是央行调控货币供应量和市场利率的重要手段。

### 14. 财政赤字和盈余的含义是什么？

**答案：** 财政赤字和盈余的含义如下：

- **财政赤字：** 政府支出超过收入，导致财政赤字。
- **财政盈余：** 政府收入超过支出，导致财政盈余。

**解析：** 财政赤字和盈余是衡量政府财政状况的重要指标。

### 15. 金融监管的主要目标是什么？

**答案：** 金融监管的主要目标包括：

- **保护投资者利益：** 确保金融市场公平、透明。
- **维护金融稳定：** 防范和化解金融风险。
- **促进金融创新：** 鼓励金融机构在合法合规的基础上开展业务。

**解析：** 金融监管旨在保障金融市场的健康发展。

### 16. 金融市场的参与者有哪些？

**答案：** 金融市场的参与者包括：

- **金融机构：** 包括商业银行、证券公司、保险公司等。
- **政府机构：** 包括财政部、中央银行等。
- **投资者：** 包括个人投资者、机构投资者等。
- **企业：** 通过金融市场进行融资。

**解析：** 金融市场的参与者共同构成了金融市场的运行主体。

### 17. 金融风险的主要类型有哪些？

**答案：** 金融风险的主要类型包括：

- **信用风险：** 金融机构无法按时收回贷款或投资。
- **市场风险：** 资产价格波动导致损失。
- **流动性风险：** 无法在合理时间内以合理价格出售资产。
- **操作风险：** 由于内部流程、系统缺陷等原因导致损失。

**解析：** 金融风险的分类有助于金融机构识别和管理风险。

### 18. 财政政策和货币政策的区别是什么？

**答案：** 财政政策和货币政策的区别如下：

- **主体不同：** 财政政策由政府制定和实施，货币政策由央行制定和实施。
- **工具不同：** 财政政策的工具包括政府支出、税收等，货币政策的工具包括存款准备金率、利率等。
- **影响范围不同：** 财政政策直接影响实体经济，货币政策通过影响市场利率和流动性来影响实体经济。

**解析：** 财政政策和货币政策是宏观经济调控的两大手段，各有侧重，但共同目标是为实现经济稳定增长。

### 19. 什么是金融周期？

**答案：** 金融周期是指金融市场的波动周期，通常包括繁荣、衰退、萧条和复苏四个阶段。

**解析：** 金融周期反映了金融市场的波动规律，对于投资者和管理者具有重要意义。

### 20. 金融市场的功能有哪些？

**答案：** 金融市场的功能包括：

- **资金融通：** 为资金需求者和资金提供者提供交易平台。
- **价格发现：** 通过市场交易，形成资产价格。
- **风险管理：** 投资者可以通过金融工具对冲风险。
- **资源配置：** 通过金融市场，优化社会资源的配置。

**解析：** 金融市场的功能对于经济发展具有重要意义。

### 算法编程题库

### 1. 给定一个整数数组 nums，判断是否存在三个下标 i、j 和 k 使得 nums[i] + nums[j] + nums[k] = 0，返回 true 或 false。

**答案：**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        ans = []
        for i in range(n):
            if i > 0 and nums[i] == nums[i-1]:
                continue
            j, k = i+1, n-1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s == 0:
                    ans.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j+1]:
                        j += 1
                    while j < k and nums[k] == nums[k-1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    k -= 1
        return ans
```

**解析：** 对数组进行排序后，固定第一个元素，然后使用双指针法查找剩余两个元素，避免重复计算。

### 2. 给定一个整数数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。返回获取该股票最大利润的买卖时间组合。您可能无法同时参与多笔交易（即，您必须先卖出股票才能买入）。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            ans += max(0, prices[i] - prices[i-1])
        return ans
```

**解析：** 通过遍历数组，计算每天的价格变化，累加得到最大利润。

### 3. 给定一个二叉树 root，请你采用前序遍历的方式，将一个树的遍历序列转换为双端队列。

**答案：**

```python
from collections import deque

class Solution:
    def treeToDoublyList(self, root: TreeNode) -> Node:
        if not root:
            return
        queue = deque()
        prev = None
        cur = root
        while cur or queue:
            while cur:
                queue.appendleft(cur)
                cur = cur.left
            cur = queue.popleft()
            cur.left = prev
            if prev:
                prev.right = cur
            prev = cur
            cur = cur.right
        prev.right = root
        root.left = prev
        return root
```

**解析：** 使用前序遍历，将树的节点插入到队列的头部和尾部，构建双向链表。

### 4. 给定一个整数数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。请设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**答案：**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                ans += prices[i] - prices[i - 1]
        return ans
```

**解析：** 遍历数组，计算相邻两天的价格差，累加得到最大利润。

### 5. 请实现一个函数，用于计算两个日期之间的天数差异。

**答案：**

```python
class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        def days(y, m, d):
            if m in [1, 3, 5, 7, 8, 10, 12]:
                return d
            if m in [4, 6, 9, 11]:
                return d - 1
            if m == 2:
                return d - 2 if y % 4 == 0 and (y % 100 != 0 or y % 400 == 0) else d - 3
            return -1

        y1, m1, d1 = map(int, date1.split('-'))
        y2, m2, d2 = map(int, date2.split('-'))
        d1 += days(y1, m1, d1)
        d2 += days(y2, m2, d2)
        return abs(d2 - d1)
```

**解析：** 分别计算两个日期对应的天数，然后计算差值。

### 6. 给定一个整数数组 nums，请你返回当前情况下， nums 的块最大且相等的一块大小 maxEqualPoints。

**答案：**

```python
class Solution:
    def largestBlock(self, nums: List[int]) -> int:
        n = len(nums)
        cnt = [0] * (n + 1)
        for i in range(1, n + 1):
            cnt[i] = cnt[i - 1]
        for i in range(n):
            cnt[i + 1] += nums[i]
        ans = 0
        for i in range(n):
            j = i + 1
            while cnt[j] - cnt[i] == j - i:
                if cnt[j] - cnt[i] == 0:
                    ans = max(ans, j - i)
                j += 1
        return ans
```

**解析：** 使用前缀和计算块的大小，然后遍历找出最大块。

### 7. 给定一个包含 n 个整数的数组 `nums` 和一个目标值 `target`，找出 `nums` 中的三个整数，使得它们的和与 `target` 最接近。

**答案：**

```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        nums.sort()
        ans = float('inf')
        for i in range(len(nums) - 2):
            j, k = i + 1, len(nums) - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if abs(s - target) < abs(ans - target):
                    ans = s
                if s < target:
                    j += 1
                elif s > target:
                    k -= 1
                else:
                    return ans
        return ans
```

**解析：** 使用排序和双指针法，找出与目标值最接近的三数之和。

### 8. 给定一个整数数组 `nums` 和一个整数 `k`，请你返回数对 `(num1, num2)` 的数目，使得 `num1 + num2 = k` 且 `num1 != num2`。

**答案：**

```python
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        cnt = Counter(nums)
        ans = 0
        for num in nums:
            if k + num in cnt:
                ans += 1
            if k - num in cnt and num != k - num:
                ans += 1
        return ans
```

**解析：** 使用哈希表统计数对的数量，注意排除重复的情况。

### 9. 给定一个字符串 `s` 和一个字符 `c`，请转换字符串中的所有 `c` 为 `t`，并且不对字符串进行分割。

**答案：**

```python
class Solution:
    def transformString(self, s: str, c: str, t: str) -> str:
        return t.join([x if x != c else c for x in s])
```

**解析：** 使用列表推导式将字符串中的 `c` 替换为 `t`，然后使用 `join` 方法连接成字符串。

### 10. 给定一个整数数组 `nums`，请你返回最长等差数组的长度，最大差为 `1`。

**答案：**

```python
class Solution:
    def longestSubsequenceBySplitting(self, nums: List[int]) -> int:
        m = Counter(nums)
        ans = 0
        n = len(nums)
        if n > 2:
            a, b = nums[0], nums[1]
            if abs(a - b) <= 1:
                ans = 2
            for i in range(2, n):
                c = nums[i]
                if abs(a - c) <= 1:
                    a = c
                    ans = max(ans, i - m[c] + 1)
                elif abs(b - c) <= 1:
                    b = c
                    ans = max(ans, i - m[c] + 1)
        return ans
```

**解析：** 从左到右遍历数组，维护两个相邻元素的差值，更新最长等差数组的长度。

### 11. 给定一个包含 n 个整数的数组 `nums` 和一个整数 `k`，你需要从数组中找出所有不同的子序列的长度，其中这个子序列的和可以被 `k` 整除，然后返回这些子序列的长度的和。

**答案：**

```python
class Solution:
    def sumSubseqSizes(self, nums: List[int], k: int) -> int:
        ans = 0
        cnt = Counter()
        for x in nums:
            cnt[x] += 1
            v = (x % k) * (1 << cnt[x])
            ans += v
            for j in range(1, 20):
                if (x - (1 << j) * (1 << (j - 1)) % k) == 0:
                    ans += ((1 << j) - 1) * (1 << (cnt[x] - 1))
        return ans
```

**解析：** 通过预处理计算每个剩余数除以 `k` 的余数出现的次数，然后使用动态规划计算每个余数对应的子序列数量。

### 12. 给定一个由小写字母组成的字符串 `s`，你需要处理各种请求：

- `"U x"`：将字符串 `s` 中的 `x` 移动到最左边。
- `"D x"`：将字符串 `s` 中的 `x` 移动到最右边。
- `"C x"`：如果字符串 `s` 中有两个相邻且相同的字符，则删除它们。
- `"F"`：将字符串 `s` 中第一个出现的小写字母 'f' 替换为 'a'，如果字符串中不包含 'f'，则什么也不做。

**答案：**

```python
class Solution:
    def processRequests(self, s: str, requests: List[str]) -> str:
        i = 0
        n = len(s)
        arr = [0] * 26
        for r in requests:
            if r[0] == 'U':
                x = ord(r[2]) - ord('a')
                arr[x] ^= 1 << i
                i -= 1
            elif r[0] == 'D':
                x = ord(r[2]) - ord('a')
                arr[x] ^= 1 << i
                i += 1
            elif r[0] == 'C':
                x = ord(r[2]) - ord('a')
                if (arr[x] >> i) & 1:
                    i -= 1
            else:
                if i >= 0 and s[i] == 'f':
                    s = s[:i] + 'a' + s[i+1:]
                    i -= 1
        j = 0
        ans = []
        while i >= 0:
            x = arr[ord(s[i]) - ord('a')]
            if x >> i & 1:
                ans.append(s[i])
                j = i
            i -= 1
        while j >= 0:
            ans.append(s[j])
            j -= 1
        return ''.join(ans)
```

**解析：** 使用位运算模拟请求操作，然后从左到右重建字符串。

### 13. 给定一个包含 n 个整数的数组 `nums` 和一个整数 `k`。在完成所有收集请求后，找出 `nums` 中的含有最多数值元素且和最大的子数组（子数组最少包含一个元素）。返回包含这些数字的子数组的和。

**答案：**

```python
from collections import defaultdict

class Solution:
    def maxSumSubarray(nums: List[int], k: int) -> int:
        cnt = defaultdict(int)
        arr = defaultdict(list)
        ans = 0
        for x in nums:
            cnt[x] += 1
            arr[x].append(x)
        for i in range(1 << k):
            s = 0
            x = None
            for j in range(k):
                if (i >> j) & 1:
                    s += arr[x := x or 0][-(j + 1)]
            ans = max(ans, s)
        return ans
```

**解析：** 枚举所有可能的子集，计算每个子集的和，找出最大值。

### 14. 给定一个包含 n 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 a，b，c ，使得 `a + b + c = 0`？请你找出所有满足条件且不重复的三元组。

**答案：**

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        n = len(nums)
        for i in range(n - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            j, k = i + 1, n - 1
            while j < k:
                s = nums[i] + nums[j] + nums[k]
                if s == 0:
                    ans.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j + 1]:
                        j += 1
                    while j < k and nums[k] == nums[k - 1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif s < 0:
                    j += 1
                else:
                    k -= 1
        return ans
```

**解析：** 使用排序和双指针法，避免重复计算。

### 15. 给定一个包含 n 个整数的数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {v: i for i, v in enumerate(nums)}
        for i, v in enumerate(nums):
            j = target - v
            if j in d and d[j] != i:
                return [i, d[j]]
        return []
```

**解析：** 使用哈希表存储数组元素及其索引，然后遍历数组，查找与当前元素互补的元素。

### 16. 给定一个长度为 `n` 的数组 `nums` 和一个特定元素 `x`，返回数组中元素 `x` 的所有出现位置的列表。如果数组中不存在元素 `x`，返回空列表。

**答案：**

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        ans = [-1, -1]
        j = bisect_left(nums, target)
        if j < n and nums[j] == target:
            ans[0] = j
        for i in range(j, n):
            if nums[i] != target:
                break
            ans[1] = i
        return ans
```

**解析：** 使用二分查找找到目标元素的第一个和最后一个位置。

### 17. 给定一个二进制数组 `nums`，你需要将数组中的所有 0 移动到数组的末尾，同时保持其相对顺序。

**答案：**

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        n = len(nums)
        j = 0
        for i in range(n):
            if nums[i]:
                nums[i], nums[j] = nums[j], nums[i]
                j += 1
```

**解析：** 使用两个指针分别维护非零数和新旧指针的位置。

### 18. 给定一个字符串 `s`，找到它的最长重复子串，输出重复子串的最小长度。

**答案：**

```python
class Solution:
    def findTheLongestSubstring(self, s: str) -> str:
        cnt = Counter()
        ans = 0
        j = 0
        for i, c in enumerate(s):
            cnt[c] += 1
            t = sum(v > 0 for v in cnt.values())
            if t == i - j + 1:
                if i - j + 1 > ans:
                    ans = i - j + 1
                cnt[c] -= 1
                j = i + 1
                cnt[c] += 1
        return s[ans - 1:ans]
```

**解析：** 通过计数器统计每个字符的次数，当出现长度等于遍历长度时，更新最长重复子串的长度。

### 19. 给定一个二进制字符串 `s`，你需要将字符串转换为整数。字符串中不会含有前导 0。

**答案：**

```python
class Solution:
    def myAtoi(self, s: str) -> int:
        i = 0
        ans = 0
        sign = 1
        while i < len(s) and s[i] == ' ':
            i += 1
        if i < len(s) and (s[i] == '+' or s[i] == '-'):
            sign = -1 if s[i] == '-' else 1
            i += 1
        while i < len(s) and s[i].isdigit():
            ans = ans * 10 + int(s[i])
            i += 1
        return max(min(ans * sign, 2**31 - 1), -2**31)
```

**解析：** 遍历字符串，判断正负号，然后计算整数，注意整数溢出。

### 20. 给定一个包含 n 个整数的数组 `nums` 和一个整数 `k`，判断是否存在两个不同的下标 i 和 j，使得 `nums[i] + nums[j] = k`？找出这两个下标的位置，返回 `[i, j]`。

**答案：**

```python
class Solution:
    def twoSum(self, nums: List[int], k: int) -> List[int]:
        d = {v: i for i, v in enumerate(nums)}
        for i, v in enumerate(nums):
            j = k - v
            if j in d and d[j] != i:
                return [i, d[j]]
        return []
```

**解析：** 使用哈希表存储数组元素及其索引，然后遍历数组，查找与当前元素互补的元素。

### 21. 给定一个整数数组 `nums`，请编写一个能够返回数组 “中心下标” 的方法。

**答案：**

```python
class Solution:
    def getZeroSumSubarrays(self, nums: List[int]) -> List[int]:
        cnt = 0
        ans = []
        s = sum(nums)
        for i, v in enumerate(nums):
            s -= v
            if s == cnt:
                ans.append(i + 1)
            cnt += v
        return ans
```

**解析：** 通过前缀和计算每个元素左侧和右侧的元素和，判断是否存在中心下标。

### 22. 给定一个字符串 `s`，你需要反转字符串中从下标 `start` 到下标 `end`（包含两端的字符）之间的段。

**答案：**

```python
class Solution:
    def reverseSubstring(self, s: str, start: int, end: int) -> str:
        return s[:start] + s[start:end][::-1] + s[end:]
```

**解析：** 通过切片操作，反转指定区间的字符串。

### 23. 给定一个字符串 `s`，找出 s 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        ans = ""
        f = [[False] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = True
            ans = s[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                f[i][j] = s[i] == s[j] and (l == 2 or f[i + 1][j - 1])
                if f[i][j] and len(ans) < l:
                    ans = s[i : j + 1]
        return ans
```

**解析：** 通过动态规划计算每个区间的回文长度，更新最长回文子串。

### 24. 给定一个整数数组 `nums`，请编写一个能够返回数组 “中心下标” 的方法。

**答案：**

```python
class Solution:
    def getZeroSumSubarrays(self, nums: List[int]) -> List[int]:
        cnt = 0
        ans = []
        s = sum(nums)
        for i, v in enumerate(nums):
            s -= v
            if s == cnt:
                ans.append(i + 1)
            cnt += v
        return ans
```

**解析：** 通过前缀和计算每个元素左侧和右侧的元素和，判断是否存在中心下标。

### 25. 给定一个字符串 `s`，找出 s 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        ans = ""
        f = [[False] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = True
            ans = s[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                f[i][j] = s[i] == s[j] and (l == 2 or f[i + 1][j - 1])
                if f[i][j] and len(ans) < l:
                    ans = s[i : j + 1]
        return ans
```

**解析：** 通过动态规划计算每个区间的回文长度，更新最长回文子串。

### 26. 给定一个整数数组 `nums`，请编写一个能够返回数组 “中心下标” 的方法。

**答案：**

```python
class Solution:
    def getZeroSumSubarrays(self, nums: List[int]) -> List[int]:
        cnt = 0
        ans = []
        s = sum(nums)
        for i, v in enumerate(nums):
            s -= v
            if s == cnt:
                ans.append(i + 1)
            cnt += v
        return ans
```

**解析：** 通过前缀和计算每个元素左侧和右侧的元素和，判断是否存在中心下标。

### 27. 给定一个字符串 `s`，找出 s 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        ans = ""
        f = [[False] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = True
            ans = s[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                f[i][j] = s[i] == s[j] and (l == 2 or f[i + 1][j - 1])
                if f[i][j] and len(ans) < l:
                    ans = s[i : j + 1]
        return ans
```

**解析：** 通过动态规划计算每个区间的回文长度，更新最长回文子串。

### 28. 给定一个字符串 `s`，找出 s 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        ans = ""
        f = [[False] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = True
            ans = s[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                f[i][j] = s[i] == s[j] and (l == 2 or f[i + 1][j - 1])
                if f[i][j] and len(ans) < l:
                    ans = s[i : j + 1]
        return ans
```

**解析：** 通过动态规划计算每个区间的回文长度，更新最长回文子串。

### 29. 给定一个字符串 `s`，找出 s 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        ans = ""
        f = [[False] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = True
            ans = s[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                f[i][j] = s[i] == s[j] and (l == 2 or f[i + 1][j - 1])
                if f[i][j] and len(ans) < l:
                    ans = s[i : j + 1]
        return ans
```

**解析：** 通过动态规划计算每个区间的回文长度，更新最长回文子串。

### 30. 给定一个字符串 `s`，找出 s 中最长的回文子串。

**答案：**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        ans = ""
        f = [[False] * n for _ in range(n)]
        for i in range(n):
            f[i][i] = True
            ans = s[i]
        for l in range(2, n + 1):
            for i in range(n - l + 1):
                j = i + l - 1
                f[i][j] = s[i] == s[j] and (l == 2 or f[i + 1][j - 1])
                if f[i][j] and len(ans) < l:
                    ans = s[i : j + 1]
        return ans
```

**解析：** 通过动态规划计算每个区间的回文长度，更新最长回文子串。

