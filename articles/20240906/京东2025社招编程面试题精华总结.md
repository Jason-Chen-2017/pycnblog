                 

### 京东2025社招编程面试题精华总结

#### 一、算法和数据结构

**1. 请解释时间复杂度和空间复杂度的概念，并举例说明。**

**答案：** 时间复杂度指的是算法执行时间与输入数据规模之间的增长关系，通常用大O符号表示，如O(1)、O(n)、O(n^2)等。空间复杂度指的是算法在执行过程中所需要的内存空间与输入数据规模之间的增长关系。

**解析：** 时间复杂度和空间复杂度是评价算法性能的重要指标。例如，一个排序算法的时间复杂度为O(n^2)，表示随着输入数据规模n的增加，算法执行时间会呈平方关系增长；而空间复杂度为O(n)，表示所需的内存空间会与输入数据规模相同。

**2. 实现一个快排算法。**

**答案：** 快排算法的基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后再按此方法对这两部分记录继续进行排序，直至整个序列有序。

```java
public void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}

public int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return i + 1;
}
```

**解析：** 这个示例实现了一个基于C语言的快排算法。通过递归调用`partition`函数，将数组分成两部分，然后分别对这两部分进行排序。

#### 二、编程实践

**1. 实现一个简单的缓存系统。**

**答案：** 缓存系统通常用来存储最近访问的数据，以减少对后端系统的访问压力。

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class CacheSystem {
    private int capacity;
    private Map<String, String> cache;

    public CacheSystem(int capacity) {
        this.capacity = capacity;
        this.cache = new LinkedHashMap<String, String>(capacity, 0.75f, true) {
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > capacity;
            }
        };
    }

    public void set(String key, String value) {
        cache.put(key, value);
    }

    public String get(String key) {
        return cache.get(key);
    }
}
```

**解析：** 这个示例使用Java中的`LinkedHashMap`实现了一个简单的缓存系统，具有指定缓存容量。当缓存容量超过限制时，自动删除最旧的条目。

**2. 实现一个LRU缓存。**

**答案：** LRU（Least Recently Used）缓存是一种常见的缓存算法，根据最近访问顺序来替换缓存中的条目。

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache {
    private int capacity;
    private Map<Integer, Integer> cache;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new LinkedHashMap<>(capacity, 0.75f, true) {
            protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
                return size() > capacity;
            }
        };
    }

    public void set(int key, int value) {
        cache.put(key, value);
    }

    public int get(int key) {
        return cache.getOrDefault(key, -1);
    }
}
```

**解析：** 这个示例使用Java中的`LinkedHashMap`实现了一个LRU缓存。当缓存容量超过限制时，自动删除最旧的条目。

#### 三、前端面试题

**1. 请解释React中的组件生命周期。**

**答案：** React组件生命周期是指组件从创建到销毁的过程。以下是React组件的生命周期方法：

* **构造函数（constructor）：** 初始化状态和绑定方法。
* **挂载阶段（Mounting）：**
  * `componentWillMount`：组件挂载前调用。
  * `render`：渲染组件。
  * `componentDidMount`：组件挂载后调用。
* **更新阶段（Updating）：**
  * `componentWillReceiveProps`：组件接收到新属性时调用。
  * `shouldComponentUpdate`：判断组件是否需要更新。
  * `componentWillUpdate`：组件更新前调用。
  * `render`：渲染更新后的组件。
  * `componentDidUpdate`：组件更新后调用。
* **卸载阶段（Unmounting）：**
  * `componentWillUnmount`：组件卸载前调用。

**2. 请解释Vue中的指令。**

**答案：** Vue中的指令是一段特殊的JavaScript代码，用于绑定数据到DOM元素上。常见的Vue指令包括：

* `v-model`：用于创建双向数据绑定。
* `v-bind`：用于绑定属性。
* `v-for`：用于渲染列表。
* `v-if`：用于条件渲染。
* `v-else`：用于条件渲染的备用内容。
* `v-on`：用于绑定事件。

**示例：**

```html
<input v-model="message">
<div v-bind:title="title">
    {{ message }}
</div>
<ul v-for="item in items">
    <li>{{ item }}</li>
</ul>
<button v-if="visible" @click="onClick">点击我</button>
```

**解析：** 这些指令用于将数据绑定到DOM元素上，从而实现动态更新和交互。例如，`v-model`用于创建一个双向数据绑定，使得输入框中的值与数据模型保持一致。

