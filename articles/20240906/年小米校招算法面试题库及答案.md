                 

### 小米校招算法面试题库及答案解析

#### 1. 简单的单链表操作

**题目：** 实现一个单链表，支持插入、删除、查找等基本操作。

**答案：**

单链表的基本结构如下：

```go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

实现操作：

```go
// 创建链表
func createList(nums []int) *ListNode {
    head := &ListNode{Val: nums[0]}
    current := head
    for i := 1; i < len(nums); i++ {
        current.Next = &ListNode{Val: nums[i]}
        current = current.Next
    }
    return head
}

// 插入操作
func insertNode(head *ListNode, val int) *ListNode {
    newNode := &ListNode{Val: val}
    if head == nil {
        return newNode
    }
    current := head
    for current.Next != nil {
        current = current.Next
    }
    current.Next = newNode
    return head
}

// 删除操作
func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    current := head
    for current.Next != nil && current.Next.Val != val {
        current = current.Next
    }
    if current.Next != nil {
        current.Next = current.Next.Next
    }
    return head
}

// 查找操作
func searchNode(head *ListNode, val int) bool {
    for head != nil {
        if head.Val == val {
            return true
        }
        head = head.Next
    }
    return false
}
```

#### 2. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

#### 3. 盛最多水的容器

**题目：** 给定一个二位数组 matrix，找出其中最大的那个子矩形，其面积最大，并返回该面积。

**答案：**

```go
func maxArea(heights []int) int {
    l, r := 0, len(heights)-1
    ans := 0
    for l < r {
        m := l + (r - l) / 2
        if heights[l] < heights[r] {
            if heights[l] > ans {
                ans = heights[l]
            }
            l = m + 1
        } else {
            if heights[r] > ans {
                ans = heights[r]
            }
            r = m
        }
    }
    return ans
}
```

#### 4. 二进制中 1 的个数

**题目：** 编写函数，实现计算一个整数的二进制表示中 1 的个数。

**答案：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}
```

#### 5. 最长回文子串

**题目：** 给定一个字符串 s，找到其最长的回文子串。

**答案：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, mx := 0, 1
    for i := 0; i < n; i++ {
        l, r := i, i
        for l >= 0 && r < n && s[l] == s[r] {
            l--
            r++
        }
        l++
        r--
        len1 := r - l - 1
        if len1 > mx {
            mx = len1
            start = l + 1
        }
        l = i
        r = i + 1
        for l >= 0 && r < n && s[l] == s[r] {
            l--
            r++
        }
        l++
        r--
        len2 := r - l - 1
        if len2 > mx {
            mx = len2
            start = l + 1
        }
    }
    return s[start : start+mx]
}
```

#### 6. 删除链表的倒数第 N 个节点

**题目：** 给定一个链表，删除链表的倒数第 n 个节点，并返回链表的头节点。

**答案：**

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    fast, slow := dummy, dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

#### 7. 最小的 k 个数

**题目：** 在未排序的数组中，找到最小的 k 个数。

**答案：**

```go
func getLeastNumbers(arr []int, k int) []int {
    sort.Ints(arr[:k])
    return arr[:k]
}
```

#### 8. 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组。

**答案：**

```go
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        m := l + (r - l) / 2
        if nums[m] == target {
            return m
        }
        if nums[l] <= nums[m] {
            if target >= nums[l] && target < nums[m] {
                r = m - 1
            } else {
                l = m + 1
            }
        } else {
            if target > nums[r] || target < nums[m] {
                l = m + 1
            } else {
                r = m - 1
            }
        }
    }
    return -1
}
```

#### 9. 合并两个有序链表

**题目：** 合并两个排序后的链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 10. 数据流的中位数

**题目：** 设计一个算法来找出数据流中的中位数。

**答案：**

```go
type MedianFinder struct {
    nums []int
}

func Constructor() MedianFinder {
    return MedianFinder{}
}

func (this *MedianFinder) AddNum(num int) {
    this.nums = append(this.nums, num)
    sort.Ints(this.nums)
}

func (this *MedianFinder) findMedian() float64 {
    n := len(this.nums)
    if n % 2 == 0 {
        return float64(this.nums[n/2-1]+this.nums[n/2]) / 2.0
    }
    return float64(this.nums[n/2])
}
```

#### 11. 寻找两个正序数组的中位数

**题目：** 给定两个大小分别为 m 和 n 的正序数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

**答案：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    n := len(nums1) + len(nums2)
    if n%2 == 1 {
        return float64(findKth(nums1, nums2, (n+1)/2)) 
    }
    return float64(findKth(nums1, nums2, n/2) + findKth(nums1, nums2, n/2+1)) / 2.0
}

func findKth(nums1, nums2 []int, k int) int {
    if len(nums1) == 0 {
        return nums2[k-1]
    }
    if len(nums2) == 0 {
        return nums1[k-1]
    }
    if k == 1 {
        return min(nums1[0], nums2[0])
    }
    iMin := min(k/2, len(nums1))
    iMax := min(k/2, len(nums2))
    i := (iMin + iMax) / 2
    j := k - i
    if nums1[i-1] > nums2[j-1] {
        return findKth(nums1[i:], nums2, k-i)
    } else if nums1[i-1] < nums2[j-1] {
        return findKth(nums1, nums2[j:], k-j)
    } else {
        return nums1[i-1]
    }
}
```

#### 12. 字符串转换大写字母

**题目：** 实现A类，包含一个方法`toUpper`，该函数可以将字符串全部转换成大写。

**答案：**

```go
package main

import "fmt"

type A struct {
    s string
}

func (a *A) toUpper() {
    a.s = strings.ToUpper(a.s)
}

func main() {
    a := A{s: "hello world"}
    fmt.Println(a.s) // 输出 hello world
    a.toUpper()
    fmt.Println(a.s) // 输出 HELLO WORLD
}
```

#### 13. 合并两个有序数组

**题目：** 给你两个整数数组 `nums1` 和 `nums2` ，按升序合并两个数组，**并用数组 `nums1`代替初始数组**。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    p1, p2, p := m-1, n-1, m+n-1
    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p] = nums1[p1]
            p1--
        } else {
            nums1[p] = nums2[p2]
            p2--
        }
        p--
    }
    for p2 >= 0 {
        nums1[p] = nums2[p2]
        p2--
        p--
    }
}
```

#### 14. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

#### 15. 顺时针打印矩阵

**题目：** 输入一个 n × n 的矩阵，按照顺时针的顺序遍历。

**答案：**

```go
func printMatrix(matrix [][]int) {
    n := len(matrix)
    top, bottom, left, right := 0, n-1, 0, n-1
    for {
        // 打印最上面一行
        for i := left; i <= right; i++ {
            fmt.Print(matrix[top][i], " ")
        }
        top++
        if top > bottom {
            break
        }
        // 打印最右边一列
        for i := top; i <= bottom; i++ {
            fmt.Print(matrix[i][right], " ")
        }
        right--
        if left > right {
            break
        }
        // 打印最下面一行
        for i := right; i >= left; i-- {
            fmt.Print(matrix[bottom][i], " ")
        }
        bottom--
        if top > bottom {
            break
        }
        // 打印最左边一列
        for i := bottom; i >= top; i-- {
            fmt.Print(matrix[i][left], " ")
        }
        left++
    }
}
```

#### 16. 翻转单词顺序

**题目：** 输入一个字符串，按单词的逆序打印出每个单词。

**答案：**

```go
func reverseWords(s string) string {
    words := strings.Fields(s)
    for i, j := 0, len(words)-1; i < j; i, j = i+1, j-1 {
        words[i], words[j] = words[j], words[i]
    }
    return strings.Join(words, " ")
}
```

#### 17. 链表中的两数相加

**题目：** 给出两个 **非空** 链表 **表示两个非负整数**，它们每位数字都是按照 **逆序** 的方式存储的，请将它们相加并返回链表形式。

**答案：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        x := 0
        if l1 != nil {
            x = l1.Val
            l1 = l1.Next
        }
        y := 0
        if l2 != nil {
            y = l2.Val
            l2 = l2.Next
        }
        sum := x + y + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

#### 18. 合并多个有序链表

**题目：** 合并 `k` 个升序链表，返回合并后的链表。

**答案：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if lists == nil || len(lists) == 0 {
        return nil
    }
    for len(lists) > 1 {
        lists = mergeTwoLists(lists[0], lists[1])
        lists = lists[1:]
    }
    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) []*ListNode {
    if l1 == nil {
        return []*ListNode{l2}
    }
    if l2 == nil {
        return []*ListNode{l1}
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return []*ListNode{l1}
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return []*ListNode{l2}
}
```

#### 19. 找到字符串中所有字母异位词

**题目：** 给定一个字符串 `s` 和一个字符串 `word`，返回字符串 `s` 中确实是 `word` 的字母异位词的子串的起始索引。你可以按任意顺序返回答案。

**答案：**

```go
func findAnagrams(s string, p string) []int {
    ans := []int{}
    mp, np := make(map[rune]int), make(map[rune]int)
    for i := range p {
        np[rune(p[i])]++;
    }
    for i := 0; i < len(s); i++ {
        ch := rune(s[i])
        np[ch]++
        if i >= len(p) {
            ch := rune(s[i-len(p)])
            np[ch]--;
        }
        if len(mp) == 0 {
            mp = np
        }
        if mp == np {
            ans = append(ans, i-len(p)+1)
        }
    }
    return ans
}
```

#### 20. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到其中最长连续递增序列的长度。

**答案：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

#### 21. 递增子序列

**题目：** 给你一个整数数组 `nums` ，返回数组 nums 的所有可能的递增子序列（升序排序）。

**答案：**

```go
func increasingSubsequences(nums []int) [][]int {
    ans := [][]int{}
    var dfs func([]int)
    dfs = func(t []int) {
        if len(t) > 0 {
            ans = append(ans, append([]int{}, t...))
        }
        for _, v := range nums {
            if len(t) == 0 || v > t[len(t)-1] {
                dfs(append(t, v))
            }
        }
    }
    dfs([]int{})
    return ans
}
```

#### 22. 合并区间

**题目：** 以数组 intervals 表示若干个区间的集合，其中 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖所有给定的区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] < intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })

    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

#### 23. 删除有序数组中的重复项

**题目：** 给你一个有序数组 `nums` ，设计一个算法来删除数组中的重复项，使每个元素只出现一次，返回移除后数组的新长度。

**答案：**

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    j := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[i-1] {
            nums[j] = nums[i]
            j++
        }
    }
    return j
}
```

#### 24. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### 25. 快乐数

**题目：** 编写一个函数，确定是否可能通过重复进行某些操作从整数 `n` 变到 1。若可以，返回 true ；否则返回 false。

**答案：**

```go
func isHappy(n int) bool {
    seen := map[int]bool{}
    for n != 1 {
        if seen[n] {
            return false
        }
        seen[n] = true
        m := 0
        for n > 0 {
            n, m = n/10, m+int((n%10)*int(3+4*(n%10)))
        }
        n = m
    }
    return true
}
```

#### 26. 快排

**题目：** 实现快速排序算法，并对数组进行升序排序。

**答案：**

```go
func quickSort(arr []int, low int, high int) {
    if low >= high {
        return
    }
    pivot := arr[high]
    i := low
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[high] = arr[high], arr[i]
    quickSort(arr, low, i-1)
    quickSort(arr, i+1, high)
}
```

#### 27. 数据流的中位数

**题目：** 设计一个算法来找出数据流的中位数。

**答案：**

```go
type MedianFinder struct {
    maxHeap, minHeap *heap.IntHeap
}

func Constructor() MedianFinder {
    return MedianFinder{
        maxHeap: heap.NewIntHeap(),
        minHeap: heap.NewIntHeap(),
    }
}

func (this *MedianFinder) AddNum(num int) {
    if this.maxHeap.Len() == 0 || num <= this.maxHeap.Top() {
        heap.Push(this.maxHeap, num)
    } else {
        heap.Push(this.minHeap, num)
    }
    if this.maxHeap.Len() > this.minHeap.Len() {
        v := heap.Pop(this.maxHeap)
        heap.Push(this.minHeap, v)
    } else if this.minHeap.Len() > this.maxHeap.Len() {
        v := heap.Pop(this.minHeap)
        heap.Push(this.maxHeap, v)
    }
}

func (this *MedianFinder) findMedian() float64 {
    if this.maxHeap.Len() == this.minHeap.Len() {
        return float64(this.maxHeap.Top() + this.minHeap.Top()) / 2
    }
    return float64(this.maxHeap.Top())
}
```

#### 28. 打家劫舍

**题目：** 你是一个专业的小偷，计划偷窃一整条街上的房屋。每间房内都藏有一定的现金，影响你偷窃能量的值。计算你 Tonight 最多能偷窃多少现金？

**答案：**

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    dp := make([]int, len(nums))
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[len(nums)-1]
}
```

#### 29. 有效的括号

**题目：** 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

**答案：**

```go
func isValid(s string) bool {
    m := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }
    st := []rune{}
    for _, v := range s {
        if _, ok := m[v]; ok {
            top := len(st) - 1
            if st[top] != m[v] {
                return false
            }
            st = st[:top]
        } else {
            st = append(st, v)
        }
    }
    return len(st) == 0
}
```

#### 30. 环形链表

**题目：** 给定一个链表，判断链表中是否有环。

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

