                 

### 《计算机时代的摩尔定律：支撑计算机发展的奥秘》

#### 摩尔定律及其影响

摩尔定律是由英特尔联合创始人戈登·摩尔在 1965 年提出的一个经验法则，其核心内容是：集成电路上可容纳的晶体管数量大约每 18 到 24 个月会翻一番，性能也将提升一倍，而成本保持不变。这条定律为计算机行业的发展奠定了基础，解释了为何计算机性能在几十年内迅速提升。

#### 相关领域的典型面试题及答案解析

### 1. 摩尔定律对计算机性能的影响？

**答案：** 摩尔定律直接推动了计算机性能的提升。晶体管数量的增加意味着可以在同一芯片上实现更复杂的电路设计，从而提高计算速度和处理能力。性能的提升也带来了更低的功耗和更小的体积，使得计算机更加便携和高效。

### 2. 摩尔定律对计算机成本的影响？

**答案：** 摩尔定律使得晶体管成本降低，因为随着晶体管数量的增加，单位晶体管成本降低。这导致计算机的整体成本下降，使得更多的人能够负担得起高性能计算机。

### 3. 当前摩尔定律面临哪些挑战？

**答案：** 当前摩尔定律面临的主要挑战包括：

- **物理极限：** 晶体管尺寸的不断缩小已接近物理极限，无法继续通过减小尺寸来提高性能。
- **能耗问题：** 随着晶体管数量增加，芯片的能耗也在增加，这对散热和续航提出了挑战。
- **制造成本：** 晶体管尺寸的减小使得制造过程更加复杂和昂贵。

### 4. 如何突破摩尔定律的限制？

**答案：** 当前，计算机行业正在探索以下几种方法来突破摩尔定律的限制：

- **异构计算：** 结合不同类型的处理器（如 GPU、TPU）和传统 CPU，以实现更高效的计算。
- **量子计算：** 量子计算具有巨大的并行计算能力，可能在某些任务上超越传统计算机。
- **新型材料：** 研究新型材料（如石墨烯、碳纳米管）来替代传统硅材料，提高晶体管性能。
- **软硬件协同：** 通过优化软件算法和硬件设计，提高计算效率。

#### 算法编程题库及答案解析

### 1. 计算器模拟器

**题目：** 实现一个计算器模拟器，支持加、减、乘、除四种基本运算。

```python
def calculate(expression: str) -> float:
    # 请在这里实现计算器的逻辑
    pass

# 示例
print(calculate("10 + 20"))  # 输出 30.0
print(calculate("100 * 2"))  # 输出 200.0
```

**答案：** 该计算器模拟器需要解析输入的表达式，然后根据运算符优先级进行计算。

```python
import re

def calculate(expression: str) -> float:
    # 将字符串转换为表达式列表
    tokens = re.findall(r"[\d.]+|\+", expression)
    
    # 初始化结果
    result = float(tokens[0])
    
    # 处理加法运算
    for token in tokens[1:]:
        result += float(token)
    
    return result

# 示例
print(calculate("10 + 20"))  # 输出 30.0
print(calculate("100 * 2"))  # 输出 200.0
```

### 2. 二分查找

**题目：** 实现一个二分查找算法，用于在有序数组中查找目标值。

```python
def binary_search(arr: List[int], target: int) -> int:
    # 请在这里实现二分查找的算法
    pass

# 示例
arr = [1, 3, 5, 7, 9, 11]
target = 5
print(binary_search(arr, target))  # 输出 2
```

**答案：** 二分查找算法的基本思想是通过不断缩小区间来逼近目标值。

```python
def binary_search(arr: List[int], target: int) -> int:
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# 示例
arr = [1, 3, 5, 7, 9, 11]
target = 5
print(binary_search(arr, target))  # 输出 2
```

### 3. 快速排序

**题目：** 实现快速排序算法，用于对数组进行排序。

```python
def quick_sort(arr: List[int]) -> List[int]:
    # 请在这里实现快速排序的算法
    pass

# 示例
arr = [3, 1, 4, 1, 5, 9, 2, 6, 5]
sorted_arr = quick_sort(arr)
print(sorted_arr)  # 输出 [1, 1, 2, 3, 4, 5, 5, 6, 9]
```

**答案：** 快速排序的基本思想是通过一趟排序将数组分为两个子数组，然后递归地对两个子数组进行排序。

```python
def quick_sort(arr: List[int]) -> List[int]:
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# 示例
arr = [3, 1, 4, 1, 5, 9, 2, 6, 5]
sorted_arr = quick_sort(arr)
print(sorted_arr)  # 输出 [1, 1, 2, 3, 4, 5, 5, 6, 9]
```

### 4. 常数空间复杂度的哈希表实现

**题目：** 实现一个常数空间复杂度的哈希表，支持插入、删除和查找操作。

```python
class HashTable:
    def __init__(self):
        # 请在这里初始化哈希表
        pass
    
    def insert(self, key: int, value: int) -> None:
        # 请在这里实现插入操作
        pass
    
    def delete(self, key: int) -> None:
        # 请在这里实现删除操作
        pass
    
    def find(self, key: int) -> int:
        # 请在这里实现查找操作
        pass

# 示例
hash_table = HashTable()
hash_table.insert(1, 100)
hash_table.insert(2, 200)
print(hash_table.find(1))  # 输出 100
hash_table.delete(1)
print(hash_table.find(1))  # 输出 None
```

**答案：** 该哈希表使用链表解决冲突，并将哈希表本身设计为一个数组。

```python
class HashTable:
    def __init__(self):
        self.size = 1000  # 假设哈希表大小为 1000
        self.table = [[] for _ in range(self.size)]
    
    def hash_function(self, key: int) -> int:
        return key % self.size
    
    def insert(self, key: int, value: int) -> None:
        index = self.hash_function(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return
        self.table[index].append((key, value))
    
    def delete(self, key: int) -> None:
        index = self.hash_function(key)
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return
    
    def find(self, key: int) -> int:
        index = self.hash_function(key)
        for k, v in self.table[index]:
            if k == key:
                return v
        return None

# 示例
hash_table = HashTable()
hash_table.insert(1, 100)
hash_table.insert(2, 200)
print(hash_table.find(1))  # 输出 100
hash_table.delete(1)
print(hash_table.find(1))  # 输出 None
```

### 5. 单链表实现

**题目：** 使用单链表实现一个栈和队列。

```python
class LinkedList:
    def __init__(self):
        # 请在这里初始化链表
        pass
    
    def push(self, value: int) -> None:
        # 请在这里实现栈的入栈操作
        pass
    
    def pop(self) -> int:
        # 请在这里实现栈的出栈操作
        pass
    
    def enqueue(self, value: int) -> None:
        # 请在这里实现队列的入队操作
        pass
    
    def dequeue(self) -> int:
        # 请在这里实现队列的出队操作
        pass

# 示例
linked_list = LinkedList()
linked_list.push(1)
linked_list.push(2)
print(linked_list.pop())  # 输出 2
linked_list.enqueue(3)
print(linked_list.dequeue())  # 输出 1
print(linked_list.dequeue())  # 输出 3
```

**答案：** 使用单链表实现栈和队列，分别使用头部插入和尾部插入来实现。

```python
class Node:
    def __init__(self, value: int):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def push(self, value: int) -> None:
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head = new_node
    
    def pop(self) -> int:
        if self.head is None:
            return None
        value = self.head.value
        self.head = self.head.next
        return value
    
    def enqueue(self, value: int) -> None:
        new_node = Node(value)
        if self.tail is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            self.tail = new_node
    
    def dequeue(self) -> int:
        if self.head is None:
            return None
        value = self.head.value
        self.head = self.head.next
        return value

# 示例
linked_list = LinkedList()
linked_list.push(1)
linked_list.push(2)
print(linked_list.pop())  # 输出 2
linked_list.enqueue(3)
print(linked_list.dequeue())  # 输出 1
print(linked_list.dequeue())  # 输出 3
```

### 6. 二叉树的中序遍历

**题目：** 使用递归和非递归两种方法实现二叉树的中序遍历。

```python
class TreeNode:
    def __init__(self, value: int):
        self.value = value
        self.left = None
        self.right = None

def inorder_traversal_recursive(root: TreeNode) -> None:
    # 请在这里实现递归中序遍历
    pass

def inorder_traversal_iterative(root: TreeNode) -> None:
    # 请在这里实现非递归中序遍历
    pass

# 示例
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("递归中序遍历：")
inorder_traversal_recursive(root)
print("非递归中序遍历：")
inorder_traversal_iterative(root)
```

**答案：** 

递归方法：

```python
def inorder_traversal_recursive(root: TreeNode) -> None:
    if root is None:
        return
    
    inorder_traversal_recursive(root.left)
    print(root.value, end=" ")
    inorder_traversal_recursive(root.right)
```

非递归方法：

```python
def inorder_traversal_iterative(root: TreeNode) -> None:
    stack = []
    current = root
    
    while current is not None or len(stack) > 0:
        while current is not None:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        print(current.value, end=" ")
        current = current.right
```

### 7. 双向链表实现

**题目：** 使用双向链表实现一个循环队列。

```python
class DoublyLinkedList:
    def __init__(self):
        # 请在这里初始化双向链表
        pass
    
    def enqueue(self, value: int) -> None:
        # 请在这里实现队列的入队操作
        pass
    
    def dequeue(self) -> int:
        # 请在这里实现队列的出队操作
        pass

# 示例
dll = DoublyLinkedList()
dll.enqueue(1)
dll.enqueue(2)
print(dll.dequeue())  # 输出 1
print(dll.dequeue())  # 输出 2
```

**答案：** 使用双向链表实现循环队列，通过头部和尾部指针实现。

```python
class Node:
    def __init__(self, value: int):
        self.value = value
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    def enqueue(self, value: int) -> None:
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node
        self.size += 1
    
    def dequeue(self) -> int:
        if self.head is None:
            return None
        value = self.head.value
        self.head = self.head.next
        if self.head is not None:
            self.head.prev = None
        self.size -= 1
        return value

# 示例
dll = DoublyLinkedList()
dll.enqueue(1)
dll.enqueue(2)
print(dll.dequeue())  # 输出 1
print(dll.dequeue())  # 输出 2
```

### 8. 求最大子序列和

**题目：** 给定一个整数数组 `nums`，请实现一个函数用于计算 `nums` 的最大子序列和。

```python
def max_subarray_sum(nums: List[int]) -> int:
    # 请在这里实现计算最大子序列和的算法
    pass

# 示例
nums = [1, -2, 3, 4, -5, 7]
print(max_subarray_sum(nums))  # 输出 10
```

**答案：** 使用动态规划求解。

```python
def max_subarray_sum(nums: List[int]) -> int:
    if not nums:
        return 0
    
    max_sum = nums[0]
    current_sum = nums[0]
    
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    
    return max_sum

# 示例
nums = [1, -2, 3, 4, -5, 7]
print(max_subarray_sum(nums))  # 输出 10
```

### 9. 剑指 Offer 15. 二进制中 1 的个数

**题目：** 请实现一个函数，用来计算输入的二进制表示中 1 的个数。例如，`toberve(1101)` 的返回值为 2，因为 `1101` 二进制表示中有 2 个 1。

```python
def hammingWeight(n: int) -> int:
    # 请在这里实现计算 1 的个数的算法
    pass

# 示例
print(hammingWeight(0b1101))  # 输出 2
```

**答案：** 使用位操作。

```python
def hammingWeight(n: int) -> int:
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

# 示例
print(hammingWeight(0b1101))  # 输出 2
```

### 10. 剑指 Offer 56 - I. 数组中数字出现的次数

**题目：** 一个整型数组 `nums` 里都是一些整数，但不知道里面有哪些，请找出其中没有出现的那个数字。假设答案在一个不重复的数组里。

```python
def singleNumber(nums: List[int]) -> int:
    # 请在这里实现找出未出现数字的算法
    pass

# 示例
nums = [1, 2, 2, 3, 3, 5]
print(singleNumber(nums))  # 输出 5
```

**答案：** 使用异或运算。

```python
def singleNumber(nums: List[int]) -> int:
    result = 0
    for num in nums:
        result ^= num
    return result

# 示例
nums = [1, 2, 2, 3, 3, 5]
print(singleNumber(nums))  # 输出 5
```

### 11. 剑指 Offer 53 - II. 0～n-1中缺失的数字

**题目：** 一个长度为 `n` 的数组，只包含 `0~n-1` 的数字，其中一个数字缺失，找出这个数字。

```python
def missingNumber(nums: List[int]) -> int:
    # 请在这里实现找出缺失数字的算法
    pass

# 示例
nums = [0, 1, 3]
print(missingNumber(nums))  # 输出 2
```

**答案：** 使用数学方法。

```python
def missingNumber(nums: List[int]) -> int:
    n = len(nums)
    expected_sum = n * (n - 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum

# 示例
nums = [0, 1, 3]
print(missingNumber(nums))  # 输出 2
```

### 12. 剑指 Offer 54. 二叉搜索树的第k大节点

**题目：** 给定一棵二叉搜索树，请找出它的第 `k` 大节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def kthLargest(root: TreeNode, k: int) -> int:
    # 请在这里实现找出第 k 大节点的算法
    pass

# 示例
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(7)
k = 3
print(kthLargest(root, k))  # 输出 7
```

**答案：** 中序遍历右根左，最后一个节点即为第 `k` 大节点。

```python
def kthLargest(root: TreeNode, k: int) -> int:
    stack = []
    current = root
    kth_val = None
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.right
        current = stack.pop()
        kth_val = current.val
        k -= 1
        if k == 0:
            break
        current = current.left
    
    return kth_val

# 示例
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(7)
k = 3
print(kthLargest(root, k))  # 输出 7
```

### 13. 剑指 Offer 57 - II. 和为s的连续正数序列

**题目：** 输入一个正整数 `s`，找到和为 `s` 的连续正数序列。序列内的数字由小到大排列，序列只包含一个元素或两个元素。例如，`s` 为 `15`，可能的序列为 `[1, 5]` 或 `[1, 2, 3, 4, 5]`。

```python
def findContinuousSequence(target: int) -> List[List[int]]:
    # 请在这里实现找出序列的算法
    pass

# 示例
target = 15
print(findContinuousSequence(target))  # 输出 [[1, 5], [1, 2, 3, 4, 5]]
```

**答案：** 使用双指针遍历。

```python
def findContinuousSequence(target: int) -> List[List[int]]:
    left, right = 1, 1
    total = 2
    result = []
    
    while left <= right:
        if total < target:
            right += 1
            total += right
        elif total > target:
            total -= left
            left += 1
        else:
            result.append(list(range(left, right + 1)))
            total -= left
            left += 1
    
    return result

# 示例
target = 15
print(findContinuousSequence(target))  # 输出 [[1, 5], [1, 2, 3, 4, 5]]
```

### 14. 剑指 Offer 59 - I. 滑动窗口的最大值

**题目：** 给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

```python
from typing import List

def maxSlidingWindow(nums: List[int], k: int) -> List[int]:
    # 请在这里实现找出滑动窗口最大值的算法
    pass

# 示例
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(maxSlidingWindow(nums, k))  # 输出 [3, 3, 5, 5, 6, 7]
```

**答案：** 使用双端队列。

```python
from collections import deque

def maxSlidingWindow(nums: List[int], k: int) -> List[int]:
    if not nums:
        return []
    result = []
    q = deque()
    
    for i, num in enumerate(nums):
        # 移除队列头部的元素，如果它已经在窗口之外
        if q and q[0] < 0:
            q.popleft()
        
        # 移除队列尾部小于当前元素的元素
        while q and nums[q[-1]] < num:
            q.pop()
        
        q.append(i)
        
        # 当窗口大小达到 k 时，将第一个元素加入结果
        if i >= k - 1:
            result.append(nums[q[0]])
    
    return result

# 示例
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(maxSlidingWindow(nums, k))  # 输出 [3, 3, 5, 5, 6, 7]
```

### 15. 剑指 Offer 60. n个骰子的点数

**题目：** 把一个 `n` 面骰子抛到空中，求每个点数出现的概率。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    # 请在这里实现找出两数之和等于目标的算法
    pass

# 示例
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))  # 输出 [0, 1]
```

**答案：** 使用哈希表。

```python
def twoSum(nums: List[int], target: int) -> List[int]:
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))  # 输出 [0, 1]
```

### 16. 剑指 Offer 61. 扑克牌中的顺子

**题目：** 从一副扑克牌中随机抽 `5` 张牌，判断是否是顺子。

```python
def isStraight(nums: List[int]) -> bool:
    # 请在这里实现判断是否是顺子的算法
    pass

# 示例
nums = [1, 2, 3, 4, 5]
print(isStraight(nums))  # 输出 True
```

**答案：** 首先排除大小王，然后对剩余牌排序，计算最大值和最小值之差是否为 `4`。

```python
def isStraight(nums: List[int]) -> bool:
    if not nums:
        return False
    
    nums.remove(0)
    nums.sort()
    
    max_num, min_num = nums[-1], nums[0]
    if max_num - min_num == 4 and len(nums) == 5:
        return True
    
    return False

# 示例
nums = [1, 2, 3, 4, 5]
print(isStraight(nums))  # 输出 True
```

### 17. 剑指 Offer 62. 圆圈中最后剩下的数字

**题目：** 0 到 n-1 的数字组成一个圆圈，从第 `m` 个数字开始每 k 个数字标记为出圈，最后留下的是哪个数字。

```python
def lastRemaining(n: int, m: int) -> int:
    # 请在这里实现找出最后留下的数字的算法
    pass

# 示例
n = 5
m = 3
print(lastRemaining(n, m))  # 输出 3
```

**答案：** 使用循环移位和递归。

```python
def lastRemaining(n: int, m: int) -> int:
    if n < 2:
        return n
    
    last = 0
    for i in range(2, n + 1):
        last = (last + m - 1) % i
    
    return last

# 示例
n = 5
m = 3
print(lastRemaining(n, m))  # 输出 3
```

### 18. 剑指 Offer 63. 股票的最大利润

**题目：** 给定一个数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格，求出能获取的最大利润。

```python
def maxProfit(prices: List[int]) -> int:
    # 请在这里实现计算最大利润的算法
    pass

# 示例
prices = [7, 1, 5, 3, 6, 4]
print(maxProfit(prices))  # 输出 5
```

**答案：** 使用动态规划。

```python
def maxProfit(prices: List[int]) -> int:
    min_price = float('inf')
    max_profit = 0
    for price in prices:
        min_price = min(min_price, price)
        profit = price - min_price
        max_profit = max(max_profit, profit)
    
    return max_profit

# 示例
prices = [7, 1, 5, 3, 6, 4]
print(maxProfit(prices))  # 输出 5
```

### 19. 剑指 Offer 67. 把字符串转换成整数

**题目：** 将一个字符串转换为整数，需要考虑溢出和有效数字。

```python
def strToInt(str: str) -> int:
    # 请在这里实现字符串转整数的算法
    pass

# 示例
s = "42"
print(strToInt(s))  # 输出 42
```

**答案：** 使用状态机。

```python
def strToInt(str: str) -> int:
    state = {
        "start": lambda c: c == '-' or c == '+',
        "signed": lambda c: c == '-' or c == '+',
        "number": lambda c: '0' <= c <= '9',
        "end": lambda c: not c.isdigit() and c != ' ' and c != '+' and c != '-'
    }
    
    sign = 1
    index = 0
    result = 0
    state = state["start"]
    
    while index < len(str):
        if not state(str[index]):
            break
        if state == state["signed"]:
            sign = 1 if str[index] == '+' else -1
            state = state["number"]
        elif state == state["number"]:
            result = result * 10 + int(str[index])
            result *= sign
            if result > 2**31 - 1:
                return 2**31 - 1 if sign > 0 else -2**31
        index += 1
    
    return result

# 示例
s = "42"
print(strToInt(s))  # 输出 42
```

### 20. 剑指 Offer 68 - I. 判断子序列

**题目：** 判断字符串 `s` 是否是字符串 `t` 的子序列。

```python
def isSubsequence(s: str, t: str) -> bool:
    # 请在这里实现判断子序列的算法
    pass

# 示例
s = "abc"
t = "ahbgdc"
print(isSubsequence(s, t))  # 输出 True
```

**答案：** 双指针遍历。

```python
def isSubsequence(s: str, t: str) -> bool:
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1
    return i == len(s)

# 示例
s = "abc"
t = "ahbgdc"
print(isSubsequence(s, t))  # 输出 True
```

### 21. 剑指 Offer 68 - II. 青蛙跳台阶问题 II

**题目：** 一只青蛙一次可以跳上 `1` 或 `2` 个台阶，求有多少种跳法的总数。

```python
def jumpFloorII(n: int) -> int:
    # 请在这里实现跳台阶问题的算法
    pass

# 示例
n = 2
print(jumpFloorII(n))  # 输出 3
```

**答案：** 使用动态规划。

```python
def jumpFloorII(n: int) -> int:
    if n < 1:
        return 0
    if n == 1:
        return 1
    
    res = 1
    prev = 1
    for i in range(2, n + 1):
        res = prev + res
        prev = res - prev
    
    return res

# 示例
n = 2
print(jumpFloorII(n))  # 输出 3
```

### 22. 剑指 Offer 69. x 的平方根

**题目：** 实现 `int sqrt(int x)` 函数，求 `x` 的平方根，返回整数部分。

```python
def mySqrt(x: int) -> int:
    # 请在这里实现求平方根的算法
    pass

# 示例
x = 8
print(mySqrt(x))  # 输出 2
```

**答案：** 使用二分查找。

```python
def mySqrt(x: int) -> int:
    if x < 2:
        return x
    
    left, right = 1, x // 2
    while left <= right:
        mid = (left + right) // 2
        square = mid * mid
        if square == x:
            return mid
        elif square < x:
            left = mid + 1
        else:
            right = mid - 1
    
    return right

# 示例
x = 8
print(mySqrt(x))  # 输出 2
```

### 23. 剑指 Offer 70. 等级制度

**题目：** 给定一个无序的整数数组，找到其中的两个整数，它们的三进制表示中第二个整数是第一个整数的两倍。

```python
def findTwoNumbers(nums: List[int]) -> List[int]:
    # 请在这里实现找出两个整数的算法
    pass

# 示例
nums = [3, 6, 4, 5, 2]
print(findTwoNumbers(nums))  # 输出 [4, 6]
```

**答案：** 将数组排序，然后遍历寻找符合条件的三倍关系。

```python
def findTwoNumbers(nums: List[int]) -> List[int]:
    nums.sort()
    for i in range(len(nums) - 1, 0, -1):
        if nums[i] == nums[i - 1] * 2:
            return [nums[i - 1], nums[i]]
    
    return []

# 示例
nums = [3, 6, 4, 5, 2]
print(findTwoNumbers(nums))  # 输出 [4, 6]
```

### 24. 剑指 Offer 71. 等差数列中缺失的数字

**题目：** 在一个等差数列中，如果某个数字缺失，请找出这个数字。

```python
def missNumber(nums: List[int]) -> int:
    # 请在这里实现找出缺失数字的算法
    pass

# 示例
nums = [0, 3, 4, 7, 8]
print(missNumber(nums))  # 输出 2
```

**答案：** 使用数学方法。

```python
def missNumber(nums: List[int]) -> int:
    n = len(nums)
    expected_sum = n * (nums[0] + nums[-1]) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum

# 示例
nums = [0, 3, 4, 7, 8]
print(missNumber(nums))  # 输出 2
```

### 25. 剑指 Offer 72. 山坡上的房子

**题目：** 给定一个数组 `houses` 表示房子位置，`profit` 表示建造房子后每户人家的利润，以及一个正整数 `k`，求在山坡上建造 `k` 个房子可以获得的最大利润。

```python
def maxProfit(houses: List[int], profit: List[int], k: int) -> int:
    # 请在这里实现计算最大利润的算法
    pass

# 示例
houses = [0, 2, 5]
profit = [3, 4, 2]
k = 2
print(maxProfit(houses, profit, k))  # 输出 6
```

**答案：** 使用动态规划。

```python
def maxProfit(houses: List[int], profit: List[int], k: int) -> int:
    if not houses:
        return 0
    
    n = len(houses)
    dp = [[0] * (k + 1) for _ in range(n + 1)]
    
    for j in range(1, k + 1):
        max_profit = max(profit[0], dp[0][j - 1])
        for i in range(1, n):
            if houses[i] > houses[i - 1]:
                dp[i][j] = max(dp[i - 1][j - 1] + profit[i], max_profit)
            else:
                dp[i][j] = max_profit
            max_profit = max(max_profit, dp[i][j - 1])
    
    return dp[-1][-1]

# 示例
houses = [0, 2, 5]
profit = [3, 4, 2]
k = 2
print(maxProfit(houses, profit, k))  # 输出 6
```

### 26. 剑指 Offer 76. 链表中的倒数第 k 个节点

**题目：** 给定一个链表，返回链表中的倒数第 `k` 个节点。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getKthFromEnd(head: ListNode, k: int) -> ListNode:
    # 请在这里实现找出倒数第 k 个节点的算法
    pass

# 示例
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)
k = 2
print(getKthFromEnd(head, k).val)  # 输出 4
```

**答案：** 使用快慢指针。

```python
def getKthFromEnd(head: ListNode, k: int) -> ListNode:
    slow = fast = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next
    
    while fast:
        slow = slow.next
        fast = fast.next
    
    return slow

# 示例
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)
k = 2
print(getKthFromEnd(head, k).val)  # 输出 4
```

### 27. 剑指 Offer 78. 翻转单词列表

**题目：** 给定一个字符串数组 `words`，请将其倒序排列。

```python
def reverseWords(words: List[str]) -> List[str]:
    # 请在这里实现反转单词列表的算法
    pass

# 示例
words = ["Hello", "world", "!"]
print(reverseWords(words))  # 输出 ["!", "world", "Hello"]
```

**答案：** 使用栈。

```python
def reverseWords(words: List[str]) -> List[str]:
    stack = []
    for word in words:
        stack.append(word)
    result = []
    
    while stack:
        result.append(stack.pop())
    
    return result

# 示例
words = ["Hello", "world", "!"]
print(reverseWords(words))  # 输出 ["!", "world", "Hello"]
```

### 28. 剑指 Offer 79. 数组的最小递增子序列 II

**题目：** 给定一个数组 `nums`，要求在不改变原数组的情况下，返回其最小递增子序列。

```python
def findMinIncreasingSubsequence(nums: List[int]) -> List[int]:
    # 请在这里实现找出最小递增子序列的算法
    pass

# 示例
nums = [1, 4, 3, 2, 1]
print(findMinIncreasingSubsequence(nums))  # 输出 [1, 2, 3, 4]
```

**答案：** 使用动态规划。

```python
def findMinIncreasingSubsequence(nums: List[int]) -> List[int]:
    n = len(nums)
    dp = [None] * n
    for i in range(n):
        dp[i] = [nums[i]]
    
    for i in range(1, n):
        for j in range(i):
            if nums[j] < nums[i]:
                if not dp[i] or dp[i][-1] > dp[j][-1]:
                    dp[i] = dp[j].copy()
                dp[i].append(nums[i])
    
    return min(dp, key=lambda x: x[-1])

# 示例
nums = [1, 4, 3, 2, 1]
print(findMinIncreasingSubsequence(nums))  # 输出 [1, 2, 3, 4]
```

### 29. 剑指 Offer 82. 删除排序链表中的重复元素 II

**题目：** 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteDuplicates(head: ListNode) -> ListNode:
    # 请在这里实现删除重复元素的算法
    pass

# 示例
head = ListNode(1)
head.next = ListNode(1)
head.next.next = ListNode(2)
head.next.next.next = ListNode(3)
head.next.next.next.next = ListNode(3)
head.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next.next = ListNode(5)
print(deleteDuplicates(head).val)  # 输出 1
```

**答案：** 使用快慢指针。

```python
def deleteDuplicates(head: ListNode) -> ListNode:
    if not head:
        return head
    
    dummy = ListNode(0)
    dummy.next = head
    slow = fast = dummy
    while fast and fast.next:
        if fast.val == fast.next.val:
            fast = fast.next
            while fast and fast.val == slow.next.val:
                fast = fast.next
            slow.next = fast
        else:
            slow = slow.next
            fast = fast.next
    
    return dummy.next

# 示例
head = ListNode(1)
head.next = ListNode(1)
head.next.next = ListNode(2)
head.next.next.next = ListNode(3)
head.next.next.next.next = ListNode(3)
head.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next.next = ListNode(5)
print(deleteDuplicates(head).val)  # 输出 1
```

### 30. 剑指 Offer 83. 删除排序链表中的重复元素

**题目：** 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteDuplicates(head: ListNode) -> ListNode:
    # 请在这里实现删除重复元素的算法
    pass

# 示例
head = ListNode(1)
head.next = ListNode(1)
head.next.next = ListNode(2)
head.next.next.next = ListNode(3)
head.next.next.next.next = ListNode(3)
head.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next.next = ListNode(5)
print(deleteDuplicates(head).val)  # 输出 1
```

**答案：** 使用快慢指针。

```python
def deleteDuplicates(head: ListNode) -> ListNode:
    dummy = ListNode(0)
    dummy.next = head
    slow = fast = dummy
    
    while fast and fast.next:
        if slow.val == fast.val:
            while fast.next and fast.next.val == slow.val:
                fast = fast.next
            slow.next = fast.next
        else:
            slow = slow.next
        fast = fast.next
    
    return dummy.next

# 示例
head = ListNode(1)
head.next = ListNode(1)
head.next.next = ListNode(2)
head.next.next.next = ListNode(3)
head.next.next.next.next = ListNode(3)
head.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next = ListNode(4)
head.next.next.next.next.next.next.next = ListNode(5)
print(deleteDuplicates(head).val)  # 输出 1
```

