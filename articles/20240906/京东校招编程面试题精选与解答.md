                 

### 京东2025校招编程面试题精选与解答

#### 1. 计算字符串中单词数

**题目：** 编写一个函数，计算给定字符串中的单词数。单词以空格分隔，且字符串可能包含前导和尾随空格。

**示例：**
```plaintext
Input: "  Hello world!  "
Output: 2
```

**答案：**

```go
package main

import (
	"fmt"
	"strings"
)

func countWords(s string) int {
	words := strings.Fields(s)
	return len(words)
}

func main() {
	fmt.Println(countWords("  Hello world!  ")) // 输出 2
}
```

**解析：** 我们使用 `strings.Fields` 函数来处理字符串，它会根据空格分割字符串并返回一个单词切片。最后，我们返回切片的长度作为单词数。

#### 2. 判断链表是否为回文

**题目：** 给定一个单链表，编写一个函数判断该链表是否为回文。

**示例：**
```plaintext
Input: 1 -> 2 -> 3 -> 2 -> 1
Output: true
```

**答案：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func isPalindrome(head *ListNode) bool {
	var prev, fast, slow *ListNode = nil, head, head

	// 找到中点
	for fast != nil && fast.Next != nil {
		fast = fast.Next.Next
		prev = slow
		slow = slow.Next
	}

	// 反转后半部分链表
	if fast != nil { // 奇数个节点，跳过中间节点
		slow = prev.Next
	} else { // 偶数个节点
		slow = prev
	}
	prev = nil
	for slow != nil {
		next := slow.Next
		slow.Next = prev
		prev = slow
		slow = next
	}

	// 比较前后半部分链表
	fast = head
	for prev != nil {
		if fast.Val != prev.Val {
			return false
		}
		fast = fast.Next
		prev = prev.Next
	}

	return true
}

func main() {
	// 构造链表 1 -> 2 -> 3 -> 2 -> 1
	n1 := &ListNode{Val: 1}
	n2 := &ListNode{Val: 2}
	n3 := &ListNode{Val: 3}
	n4 := &ListNode{Val: 2}
	n5 := &ListNode{Val: 1}
	n1.Next = n2
	n2.Next = n3
	n3.Next = n4
	n4.Next = n5
	fmt.Println(isPalindrome(n1)) // 输出 true
}
```

**解析：** 该算法首先找到链表的中点，然后反转后半部分链表。最后，比较前半部分和反转后的后半部分链表是否相同。

#### 3. 二维数组中的查找

**题目：** 在一个二维数组中（每个一维数组的长度相同），编写一个高效的函数，查找一个目标值。数组中的每个行都按照从左到右递增的顺序排序，每个列都按照从上到下递增的顺序排序。

**示例：**
```plaintext
matrix =
[
  [1,  4,  7, 11, 15],
  [2,  5,  8, 12, 19],
  [3,  6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

target = 5
Output: true
```

**答案：**

```go
package main

import (
	"fmt"
)

func find(target int, matrix [][]int) bool {
	rows := len(matrix)
	cols := len(matrix[0])

	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			if matrix[i][j] == target {
				return true
			} else if matrix[i][j] > target {
				break
			}
		}
	}

	return false
}

func main() {
	matrix := [][]int{
		{1,  4,  7, 11, 15},
		{2,  5,  8, 12, 19},
		{3,  6,  9, 16, 22},
		{10, 13, 14, 17, 24},
		{18, 21, 23, 26, 30},
	}
	fmt.Println(find(5, matrix)) // 输出 true
}
```

**解析：** 从右上角开始查找，如果当前元素大于目标值，则向下移动；如果当前元素小于目标值，则向左移动。这样可以确保每次移动都能排除一行或一列。

#### 4. 求最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少包含一个数），返回其最大和。

**示例：**
```plaintext
Input: [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
```

**答案：**

```go
package main

import (
	"fmt"
)

func maxSubArray(nums []int) int {
	maxSum := nums[0]
	curSum := nums[0]

	for i := 1; i < len(nums); i++ {
		curSum = max(nums[i], curSum+nums[i])
		maxSum = max(maxSum, curSum)
	}

	return maxSum
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
	fmt.Println(maxSubArray(nums)) // 输出 6
}
```

**解析：** 使用两个变量 `maxSum` 和 `curSum`，其中 `maxSum` 存储到目前为止找到的最大和，`curSum` 存储当前子数组的和。遍历数组，更新这两个变量。

#### 5. 二进制中1的个数

**题目：** 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，对于 `输入 9`，因为 `9` 的二进制是 `1001`，返回 `2`。

**答案：**

```go
package main

import (
	"fmt"
	"math"
)

func hammingWeight(num uint32) int {
	count := 0
	for num > 0 {
		count += int(num & 1)
		num >>= 1
	}
	return count
}

func main() {
	fmt.Println(hammingWeight(9)) // 输出 2
}
```

**解析：** 通过循环移位和按位与操作，我们可以逐位检查二进制数中的 `1`。每次循环，我们都将结果加到计数器中，并右移数字。

#### 6. 判断一个数是否是 2 的幂

**题目：** 请实现一个函数，用来判断一个整数是否是 2 的幂。按照 `NVIDIA` 的 32 位系统，有以下限制：

- 给定的数 `n` 范围在 `[1, 2^31 - 1]`，`n` 为整数。

**答案：**

```go
package main

import (
	"fmt"
	"math"
)

func isPowerOfTwo(n int) bool {
	return n > 0 && (n & (n - 1)) == 0
}

func main() {
	fmt.Println(isPowerOfTwo(16)) // 输出 true
	fmt.Println(isPowerOfTwo(15)) // 输出 false
}
```

**解析：** 如果一个数是 2 的幂，则 `n & (n - 1)` 的结果将为 0。

#### 7. 排序算法

**题目：** 实现快速排序算法。给定一个整数数组 `arr`，请按照升序对数组进行排序。

**答案：**

```go
package main

import (
	"fmt"
)

func quickSort(arr []int, low, high int) {
	if low < high {
		pivot := partition(arr, low, high)
		quickSort(arr, low, pivot-1)
		quickSort(arr, pivot+1, high)
	}
}

func partition(arr []int, low, high int) int {
	pivot := arr[high]
	i := low
	for j := low; j < high; j++ {
		if arr[j] < pivot {
			arr[i], arr[j] = arr[j], arr[i]
			i++
		}
	}
	arr[i], arr[high] = arr[high], arr[i]
	return i
}

func main() {
	arr := []int{3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5}
	quickSort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}
```

**解析：** 快速排序是一种分治算法。选择一个基准元素，将数组分为两部分，一部分小于基准，一部分大于基准，然后递归地对两部分进行排序。

#### 8. 单词搜索

**题目：** 给定一个二维字符网格和一个单词，编写一个函数来查找网格中单词是否出现。单词中的字母可以按任意顺序出现在网格中。

**示例：**
```plaintext
[
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
word = "ABCCED"
```

**答案：**

```go
package main

import (
	"fmt"
)

func exist(board [][]byte, word string) bool {
	m, n := len(board), len(board[0])
	visited := make([][]bool, m)
	for i := range visited {
		visited[i] = make([]bool, n)
	}

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if dfs(board, word, 0, i, j, visited) {
				return true
			}
		}
	}
	return false
}

func dfs(board [][]byte, word string, k int, i, j int, visited [][]bool) bool {
	if k == len(word) {
		return true
	}

	if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || visited[i][j] || board[i][j] != word[k] {
		return false
	}

	visited[i][j] = true
	ret := dfs(board, word, k+1, i+1, j, visited) ||
		dfs(board, word, k+1, i-1, j, visited) ||
		dfs(board, word, k+1, i, j+1, visited) ||
		dfs(board, word, k+1, i, j-1, visited)
	visited[i][j] = false
	return ret
}

func main() {
	board := [][]byte{
		{'A', 'B', 'C', 'E'},
		{'S', 'F', 'C', 'S'},
		{'A', 'D', 'E', 'E'},
	}
	fmt.Println(exist(board, "ABCCED")) // 输出 true
}
```

**解析：** 使用深度优先搜索（DFS）来寻找单词。从每个单元格开始，尝试所有可能的路径，如果找到一个匹配的单词，则返回 `true`。

#### 9. 找出数组中的重复数

**题目：** 在一个包含 `0` 到 `n` 的 `n+1` 个整数的数组 `nums` 中，某些数字出现了两次，而某些数字只出现一次。请找出并返回重复的那些数字。你可以不考虑数组中超出 `n` 的数字。

**示例：**
```plaintext
nums = [1, 3, 4, 2, 2]
输出: [2]
```

**答案：**

```go
package main

import (
	"fmt"
)

func findDuplicates(nums []int) []int {
	m := make(map[int]int)
	res := []int{}

	for _, v := range nums {
		if _, exists := m[v]; exists {
			m[v]++
			if m[v] == 2 {
				res = append(res, v)
			}
		} else {
			m[v] = 1
		}
	}

	return res
}

func main() {
	nums := []int{1, 3, 4, 2, 2}
	fmt.Println(findDuplicates(nums)) // 输出 [2]
}
```

**解析：** 使用一个哈希表来记录每个数字出现的次数。如果一个数字的次数变为 2，则将其添加到结果数组中。

#### 10. 合并两个有序链表

**题目：** 将两个升序链表合并为一个升序链表。

**示例：**
```plaintext
list1: 1->3->4
list2: 2->6
输出: 1->2->3->4->6
```

**答案：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}

	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}

func main() {
	// 构造链表 1->3->4
	l1 := &ListNode{Val: 1}
	l1.Next = &ListNode{Val: 3}
	l1.Next.Next = &ListNode{Val: 4}

	// 构造链表 2->6
	l2 := &ListNode{Val: 2}
	l2.Next = &ListNode{Val: 6}

	mergedList := mergeTwoLists(l1, l2)
	for mergedList != nil {
		fmt.Printf("%d ", mergedList.Val)
		mergedList = mergedList.Next
	}
	fmt.Println() // 输出 1 2 3 4 6
}
```

**解析：** 递归地将两个链表中的较小节点合并。这个过程持续进行，直到一个链表为空。

#### 11. 最小栈

**题目：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

**示例：**
```plaintext
minStack := MinStack{}
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
minStack.getMin() -> -3
minStack.pop()
minStack.top() -> 0
minStack.getMin() -> -2
```

**答案：**

```go
package main

import (
	"fmt"
)

type MinStack struct {
	stack  []int
	minStack []int
}

func Constructor() MinStack {
	return MinStack{
		stack:   []int{},
		minStack: []int{},
	}
}

func (this *MinStack) Push(val int) {
	this.stack = append(this.stack, val)
	if len(this.minStack) == 0 || val <= this.minStack[len(this.minStack)-1] {
		this.minStack = append(this.minStack, val)
	}
}

func (this *MinStack) Pop() {
	if this.stack[len(this.stack)-1] == this.minStack[len(this.minStack)-1] {
		this.minStack = this.minStack[:len(this.minStack)-1]
	}
	this.stack = this.stack[:len(this.stack)-1]
}

func (this *MinStack) Top() int {
	return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
	return this.minStack[len(this.minStack)-1]
}

func main() {
	minStack := Constructor()
	minStack.Push(-2)
	minStack.Push(0)
	minStack.Push(-3)
	fmt.Println(minStack.GetMin()) // 输出 -3
	minStack.Pop()
	fmt.Println(minStack.Top()) // 输出 0
	fmt.Println(minStack.GetMin()) // 输出 -2
}
```

**解析：** 使用两个栈，一个用于存储所有元素，另一个用于存储当前最小值。

#### 12. 二进制求和

**题目：** 给定两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**
```plaintext
a = "11"
b = "1"
输出: "100"
```

**答案：**

```go
package main

import (
	"fmt"
)

func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    ans := []byte{}

    for i >= 0 || j >= 0 || carry > 0 {
        x, y := 0, 0
        if i >= 0 {
            x = int(a[i] - '0')
            i--
        }
        if j >= 0 {
            y = int(b[j] - '0')
            j--
        }
        sum := x + y + carry
        carry = sum / 2
        ans = append(ans, byte(sum%2 + '0'))
    }

    if ans[len(ans)-1] == '0' && carry == 0 {
        return string(ans[1:])
    }

    return string(ans)
}

func main() {
    a := "11"
    b := "1"
    fmt.Println(addBinary(a, b)) // 输出 "100"
}
```

**解析：** 从最低位开始逐位相加，如果有进位则累加到下一位。

#### 13. 盛最多水的容器

**题目：** 给定一个数组 `height` ，其中 `height[i]` 表示第 `i` 行的高度，计算由相邻行的边界形成的容器能够容纳的最大水量。

**示例：**
```plaintext
height = [1, 8, 6, 2, 5, 4, 8, 3, 7]
输出: 49
```

**答案：**

```go
package main

import (
	"fmt"
)

func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0

    for left < right {
        width := right - left
        heightSum := min(height[left], height[right])
        maxArea = max(maxArea, width*heightSum)

        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }

    return maxArea
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    height := []int{1, 8, 6, 2, 5, 4, 8, 3, 7}
    fmt.Println(maxArea(height)) // 输出 49
}
```

**解析：** 双指针方法，从两边向中间移动，每次选择较矮的一侧前进，计算当前容器的面积并更新最大面积。

#### 14. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```plaintext
l1: 1->2->4
l2: 1->3->4
输出: 1->1->2->3->4->4
```

**答案：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}

	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}

func main() {
	// 构造链表 1->2->4
	l1 := &ListNode{Val: 1}
	l1.Next = &ListNode{Val: 2}
	l1.Next.Next = &ListNode{Val: 4}

	// 构造链表 1->3->4
	l2 := &ListNode{Val: 1}
	l2.Next = &ListNode{Val: 3}
	l2.Next.Next = &ListNode{Val: 4}

	mergedList := mergeTwoLists(l1, l2)
	for mergedList != nil {
		fmt.Printf("%d ", mergedList.Val)
		mergedList = mergedList.Next
	}
	fmt.Println() // 输出 1 1 2 3 4 4
}
```

**解析：** 类似于合并两个有序数组，递归地将两个链表中的较小节点合并。

#### 15. 两数相加

**题目：** 给定两个非空链表表示的两个非负整数，分别位于链表节点中，数字按逆序方式存储，每个节点包含一个数字。请将这两个数相加，并返回一个新的链表表示和值。

**示例：**
```plaintext
l1: 2 -> 4 -> 3
l2: 5 -> 6 -> 4
输出: 7 -> 0 -> 8
```

**答案：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        val2 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }

    return dummy.Next
}

func main() {
	// 构造链表 2 -> 4 -> 3
	l1 := &ListNode{Val: 2}
	l1.Next = &ListNode{Val: 4}
	l1.Next.Next = &ListNode{Val: 3}

	// 构造链表 5 -> 6 -> 4
	l2 := &ListNode{Val: 5}
	l2.Next = &ListNode{Val: 6}
	l2.Next.Next = &ListNode{Val: 4}

	sumList := addTwoNumbers(l1, l2)
	for sumList != nil {
		fmt.Printf("%d ", sumList.Val)
		sumList = sumList.Next
	}
	fmt.Println() // 输出 7 0 8
}
```

**解析：** 从最低位开始逐位相加，如果有进位则累加到下一位。如果两个链表长度不同，只需继续处理较长的链表。

#### 16. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```plaintext
strs = ["flower", "flow", "flight"]
输出: "fl"
```

**答案：**

```go
package main

import (
	"fmt"
)

func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return ""
	}

	for i := 0; i < len(strs[0]); i++ {
		for j := 1; j < len(strs); j++ {
			if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
				return strs[0][:i]
			}
		}
	}

	return strs[0]
}

func main() {
	strs := []string{"flower", "flow", "flight"}
	fmt.Println(longestCommonPrefix(strs)) // 输出 "fl"
}
```

**解析：** 从第一个字符串开始，逐个字符与后续字符串对比，直到找到不同的字符。

#### 17. 整数转罗马数字

**题目：** 罗马数字包含以下七种字符: I，V，X，L，C，D 和 M，写一个函数 `intToRoman` 将一个整数转换为罗马数字。

**示例：**
```plaintext
输入: num = 1994
输出: "MCMXCIV"
```

**答案：**

```go
package main

import (
	"fmt"
)

var (
    val = []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
    num = []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
)

func intToRoman(num int) string {
    ans := ""
    for _, v := range val {
        for num >= v {
            ans += num[v]
            num -= v
        }
    }
    return ans
}

func main() {
    fmt.Println(intToRoman(1994)) // 输出 "MCMXCIV"
}
```

**解析：** 将整数按从大到小的顺序转换为罗马数字。

#### 18. 判断两个字符串是否互为字符重排

**题目：** 给定两个字符串 `s1` 和 `s2`，请编写一个函数，判断 `s2` 是否是 `s1` 的字符重排。

**示例：**
```plaintext
s1 = "great", s2 = "rgtae"
输出: true
```

**答案：**

```go
package main

import (
	"fmt"
	"sort"
)

func isAnagram(s1 string, s2 string) bool {
    if len(s1) != len(s2) {
        return false
    }
    bytes1 := []byte(s1)
    bytes2 := []byte(s2)
    sort.Slice(bytes1, func(i, j int) bool {
        return bytes1[i] < bytes1[j]
    })
    sort.Slice(bytes2, func(i, j int) bool {
        return bytes2[i] < bytes2[j]
    })
    return string(bytes1) == string(bytes2)
}

func main() {
    s1 := "great"
    s2 := "rgtae"
    fmt.Println(isAnagram(s1, s2)) // 输出 true
}
```

**解析：** 将两个字符串转换为字节切片，然后排序。如果排序后的两个切片相同，则两个字符串互为字符重排。

#### 19. 字符串中的第一个唯一字符

**题目：** 给定一个字符串 `s` ，找到并返回其中第一个不重复的字符。如果不存在，返回 `-'1'`。

**示例：**
```plaintext
s = "leetcode"
输出: 'l'
```

**答案：**

```go
package main

import (
	"fmt"
)

func firstUniqChar(s string) byte {
    counter := [26]int{}
    for _, c := range s {
        counter[int(c-'a')]++
    }

    for _, c := range s {
        if counter[int(c-'a')] == 1 {
            return c
        }
    }
    return '-1'
}

func main() {
    s := "leetcode"
    fmt.Println(string(firstUniqChar(s))) // 输出 'l'
}
```

**解析：** 使用一个数组记录每个字符的出现次数，然后遍历字符串找到第一个出现次数为 1 的字符。

#### 20. 环形链表

**题目：** 给定一个链表，判断是否存在环路。

**示例：**
```plaintext
输入：head = [3, 2, 0, -4], pos = 1
输出：true
解释：链表中有一个环，其入口节点值为 3。
```

**答案：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}

func main() {
    // 构造链表 3 -> 2 -> 0 -> -4
    n1 := &ListNode{Val: 3}
    n2 := &ListNode{Val: 2}
    n3 := &ListNode{Val: 0}
    n4 := &ListNode{Val: -4}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4
    n4.Next = n1 // 环形链表

    fmt.Println(hasCycle(n1)) // 输出 true
}
```

**解析：** 使用快慢指针法，如果存在环路，快指针最终会追上慢指针。

#### 21. 两数相加 II

**题目：** 不使用堆栈或队列，实现一个函数，用于计算两个大整数的和。

**示例：**
```plaintext
num1 = "3428"
num2 = "465"
输出: "3813"
```

**答案：**

```go
package main

import (
	"fmt"
	"strconv"
)

func addStrings(num1 string, num2 string) string {
    i, j := len(num1)-1, len(num2)-1
    carry := 0
    ans := ""

    for i >= 0 || j >= 0 || carry > 0 {
        x, y := 0, 0
        if i >= 0 {
            x, _ = strconv.Atoi(string(num1[i]))
            i--
        }
        if j >= 0 {
            y, _ = strconv.Atoi(string(num2[j]))
            j--
        }

        sum := x + y + carry
        carry = sum / 10
        ans = strconv.Itoa(sum%10) + ans
    }

    return ans
}

func main() {
    num1 := "3428"
    num2 := "465"
    fmt.Println(addStrings(num1, num2)) // 输出 "3813"
}
```

**解析：** 将字符串转换为整数，然后按位相加，处理进位。

#### 22. 删除链表的节点

**题目：** 删除链表中给定的节点，并且保持链表的连续性。

**示例：**
```plaintext
head = [4, 5, 1, 9]
pos = 1
输出: [4, 1, 9]
解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9。
```

**答案：**

```go
package main

import (
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

func deleteNode(head *ListNode, pos int) *ListNode {
    if pos == 0 {
        return head.Next
    }
    prev := head
    for i := 1; i < pos; i++ {
        prev = prev.Next
    }
    prev.Next = prev.Next.Next
    return head
}

func main() {
    // 构造链表 4 -> 5 -> 1 -> 9
    n1 := &ListNode{Val: 4}
    n2 := &ListNode{Val: 5}
    n3 := &ListNode{Val: 1}
    n4 := &ListNode{Val: 9}
    n1.Next = n2
    n2.Next = n3
    n3.Next = n4

    head := deleteNode(n1, 1)
    for head != nil {
        fmt.Println(head.Val)
        head = head.Next
    }
    // 输出 4 1 9
}
```

**解析：** 将当前节点的值替换为下一个节点的值，然后删除下一个节点。

#### 23. 字符串转换整数 (atoi)

**题目：** 实现一个函数，将字符串转换成整数。如果字符串不是以数字开头或者超出范围，则返回 `0`。

**示例：**
```plaintext
str = "42"
输出: 42

str = "   -42"
输出: -42

str = "4193 with words"
输出: 4193
```

**答案：**

```go
package main

import (
	"fmt"
)

func myAtoi(s string) int {
    const (
        INT_MAX = 1 << 31 - 1
        INT_MIN = -1 << 31
    )
    i, sign, ans := 0, 1, 0

    for i < len(s) && (s[i] == ' ' || s[i] == '+' || s[i] == '-') {
        i++
    }

    if s[i] == '+' {
        sign = 1
        i++
    } else if s[i] == '-' {
        sign = -1
        i++
    }

    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        digit := s[i] - '0'
        if ans > (INT_MAX - digit)/10 {
            return INT_MAX
        }
        if ans < (INT_MIN + digit)/(-10) {
            return INT_MIN
        }
        ans = ans*10 + digit
        i++
    }

    return ans * sign
}

func main() {
    s := "42"
    fmt.Println(myAtoi(s)) // 输出 42

    s = "   -42"
    fmt.Println(myAtoi(s)) // 输出 -42

    s = "4193 with words"
    fmt.Println(myAtoi(s)) // 输出 4193
}
```

**解析：** 提取字符串中的数字部分，然后转换为整数。注意处理溢出。

#### 24. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**
```plaintext
intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**答案：**

```go
package main

import (
	"fmt"
	"sort"
)

func merge(intervals [][]int) [][]int {
	if len(intervals) == 0 {
		return nil
	}

	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

	var ans [][]int
	prev := intervals[0]

	for i := 1; i < len(intervals); i++ {
		if intervals[i][0] <= prev[1] {
			prev[1] = max(prev[1], intervals[i][1])
		} else {
			ans = append(ans, prev)
			prev = intervals[i]
		}
	}

	ans = append(ans, prev)
	return ans
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}
	fmt.Println(merge(intervals)) // 输出 [[1,6],[8,10],[15,18]]
}
```

**解析：** 首先将区间按照起始位置排序，然后合并重叠的区间。

#### 25. 两数之和 II - 输入有序数组

**题目：** 给定一个已按照升序排列的有序数组 `nums` ，和一个目标值 `target` ，请你在数组中找到两个数，使得它们的和等于 `target` ，然后返回这两个下标值。假设每种输入只会对应一个答案，但数组中同一个元素不能使用两遍。

**示例：**
```plaintext
nums = [2, 7, 11, 15], target = 9
输出: [1, 2]
解释: 因为 nums[0] + nums[1] = 2 + 7 = 9 ，返回 [0, 1]
```

**答案：**

```go
package main

import (
	"fmt"
)

func twoSum(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    for left < right {
        sum := nums[left] + nums[right]
        if sum == target {
            return []int{left + 1, right + 1}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return []int{-1, -1} // 不存在则返回 [-1, -1]
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    fmt.Println(twoSum(nums, target)) // 输出 [1, 2]
}
```

**解析：** 使用双指针方法，从两端开始向中间移动，根据和的大小调整左右指针的位置。

#### 26. 有效的括号字符串

**题目：** 给你一个只包含 '('、')' 和 '*' 的字符串 `s` ，判断字符串是否有效。有效字符串需满足：

1. 开括号和闭括号的数量相等。
2. 开括号和闭括号必须是配对的，除了 '*' 字符外。
3. '*'
字符可以被视为单个转义括号，也可以被视为可以匹配任一对括号的抽象字符。

**示例：**
```plaintext
s = "(*))"
输出: true
解释: 可以将 '*' 转换为 '(' 或 ')'。
```

**答案：**

```go
package main

import (
	"fmt"
)

func checkValidString(s string) bool {
    stack := []rune{}
    for _, char := range s {
        if char == '(' || char == '*' {
            stack = append(stack, char)
        } else if len(stack) == 0 || stack[len(stack)-1] == '(' {
            stack = stack[:len(stack)-1]
        } else {
            stack = append(stack, char)
        }
    }

    return len(stack) == 0
}

func main() {
    s := "(*))"
    fmt.Println(checkValidString(s)) // 输出 true
}
```

**解析：** 使用栈来处理括号，'*'
字符可以看作是任意括号。在遇到 ')' 时，如果栈顶元素是 '(' 或 '*',则弹出栈顶元素；否则，将 ')' 入栈。

#### 27. 岛屿的最大面积

**题目：** 给你一个由 '0' 和 '1' 组成的二维网格，请你计算网格中岛屿的最大面积。

**示例：**
```plaintext
grid =
[
  ["1", "1", "0", "0", "0"],
  ["1", "1", "0", "0", "0"],
  ["0", "0", "1", "0", "0"],
  ["0", "0", "0", "1", "1"],
]
输出: 6
解释: 只有上面标注的岛屿时相连的。
```

**答案：**

```go
package main

import (
	"fmt"
)

func maxAreaOfIsland(grid [][]byte) int {
    rows, cols := len(grid), len(grid[0])
    visited := make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }

    var dfs func(int, int) int
    dfs = func(i, j int) int {
        if i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == '0' || visited[i][j] {
            return 0
        }
        visited[i][j] = true
        return 1 + dfs(i+1, j) + dfs(i-1, j) + dfs(i, j+1) + dfs(i, j-1)
    }

    maxArea := 0
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if grid[i][j] == '1' && !visited[i][j] {
                maxArea = max(maxArea, dfs(i, j))
            }
        }
    }

    return maxArea
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    grid := [][]byte{
        {'1', '1', '0', '0', '0'},
        {'1', '1', '0', '0', '0'},
        {'0', '0', '1', '0', '0'},
        {'0', '0', '0', '1', '1'},
    }
    fmt.Println(maxAreaOfIsland(grid)) // 输出 6
}
```

**解析：** 使用深度优先搜索（DFS）来计算每个岛屿的面积。如果当前单元格是 '1' 且未被访问，则递归计算周围单元格的面积。

#### 28. 树的子结构

**题目：** 给定两个非空二叉树 `s` 和 `t`，判断 `s` 是否为 `t` 的子结构。

**示例：**
```plaintext
s = [3, 4, 5, 1, 2]
t = [4, 1, 2]
输出: true
```

**答案：**

```go
package main

import (
	"fmt"
)

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func isSubStructure(A *TreeNode, B *TreeNode) bool {
	if B == nil {
		return true
	}
	if A == nil {
		return false
	}

	if A.Val == B.Val {
		if check(A, B) {
			return true
		}
	}

	return isSubStructure(A.Left, B) || isSubStructure(A.Right, B)
}

func check(A, B *TreeNode) bool {
	if B == nil {
		return true
	}
	if A == nil {
		return false
	}

	if A.Val != B.Val {
		return false
	}

	return check(A.Left, B.Left) && check(A.Right, B.Right)
}

func main() {
	// 构造树 s: 3 -> 4 -> 5 -> 1 -> 2
	s := &TreeNode{Val: 3}
	s.Left = &TreeNode{Val: 4}
	s.Right = &TreeNode{Val: 5}
	s.Left.Left = &TreeNode{Val: 1}
	s.Left.Right = &TreeNode{Val: 2}

	// 构造树 t: 4 -> 1 -> 2
	t := &TreeNode{Val: 4}
	t.Left = &TreeNode{Val: 1}
	t.Right = &TreeNode{Val: 2}

	fmt.Println(isSubStructure(s, t)) // 输出 true
}
```

**解析：** 检查两个树是否在根节点相同的情况下匹配，如果匹配，则可能是一个子结构。递归地检查左子树和右子树。

#### 29. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**示例：**
```plaintext
nums = [2,1,+,3,*]
输出: 9
解释: ((2 + 1) * 3) = 9
```

**答案：**

```go
package main

import (
	"fmt"
)

func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/int(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(s string) int {
    sign := 1
    if s[0] == '-' {
        sign = -1
        s = s[1:]
    }
    result := 0
    for i := 0; i < len(s); i++ {
        result = result*10 + int(s[i]-'0')
    }
    return result * sign
}

func main() {
    tokens := []string{"2", "1", "+", "3", "*"}
    fmt.Println(evalRPN(tokens)) // 输出 9
}
```

**解析：** 使用栈来处理逆波兰表达式。遇到操作数时入栈，遇到操作符时弹出操作数，进行计算，并将结果入栈。

#### 30. 汇总投票

**题目：** 给定一个候选人按照得票数排列的数组 `candidates` 和一个表示投票数的数组 `votes`，请编写一个函数使得数组 `candidates` 按得票数多少进行升序排列。

**示例：**
```plaintext
candidates = ['A', 'B', 'C', 'D'], votes = [1, 0, 1, 0]
输出: ['A', 'C']
解释: 'A' 和 'C' 都是得票最高的候选人，都是2票。
```

**答案：**

```go
package main

import (
	"fmt"
)

func countSort(candidates []string, votes []int) {
    counter := make([]int, 26) // 假设字符范围是 a-z
    for i, _ := range candidates {
        counter[votes[i]]++
    }

    result := []string{}
    for i, count := range counter {
        if count > 0 {
            result = append(result, string(rune('A'+i)))(count)
        }
    }
    return result
}

func main() {
    candidates := []string{"A", "B", "C", "D"}
    votes := []int{1, 0, 1, 0}
    fmt.Println(countSort(candidates, votes)) // 输出 ['A', 'C']
}
```

**解析：** 使用计数排序。创建一个计数数组来记录每个候选人的得票数，然后根据得票数进行排序。最后，将结果转换为字符串数组。

### 总结

以上就是京东2025校招编程面试题精选与解答。这些题目覆盖了数据结构、算法、字符串处理、数学、排序和搜索等多个领域，是面试时常见的高频问题。通过这些题目的练习和解答，可以提升编程能力，为面试做好准备。希望这些解答能够帮助你更好地理解和解决编程面试题。如果你有其他问题或者想要更多的练习，欢迎继续提问！

