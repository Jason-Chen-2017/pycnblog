
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 1.1 什么是动态规划？
动态规划(Dynamic Programming，DP)是一种解决复杂问题的有效方式。其核心思想是将原问题分解成子问题，从而逐层求解。在求解过程中，通过对每个子问题的解的组合，构造出原问题的解。动态规划经常用于最优化问题，即求得目标函数极小值的问题。

## 1.2 为何要用动态规划？
- 将一个大问题分解成一系列相互关联的小问题，可以减少时间和空间复杂度；
- 可以利用已知结果，快速找到特定问题的解；
- 有利于剪枝，避免不必要的计算。

## 1.3 动态规划与回溯法的区别？
动态规划一般用来求最值，而回溯法一般用来求所有可行解或所有可能的解，但两者有本质上的不同。动态规划是建立在自底向上递归的基础上的，而回溯法则是基于自顶向下迭代的。因此，动态规划通常比回溯法效率更高。而且，动态规划更适合于求最值问题，而回溯法更适合于求解组合问题。

## 1.4 DP分类及代表题目
动态规划一般分为最优子结构、重叠子问题和状态转移三种类型，其中最优子结构表示状态的转移只依赖于当前状态，不会涉及到前面的状态。重叠子问题表示存在相同的子问题。状态转移方程一般具有如下形式:
```
dp[i][j] = max{dp[i-1][k]+f(i,j,k)} (1<=k<j)，
```
其中，`dp[i][j]` 表示状态 `i` 时，包含 `j` 个元素的组合中能够取得的最大值；`i` 是位置 `j` 的第几个数（下标从 1 开始），`j` 是 `n` 个元素中的第几个；`f(i,j,k)` 表示元素 `i` 和元素 `k` 在位置 `j` 之前是否被选取，如果选取，则值为 `nums[i]+max{dp[i-1][l]}`，否则为 `dp[i-1][l]`；`l=0...k-1`。

### 求解矩阵连乘问题：
```python
def matrix_multiply(A, B):
    m, n = len(B), len(B[0])
    C = [[0 for _ in range(m)] for _ in range(len(A))]

    def multiply(a, b):
        if not a or not b:
            return []

        c = [0]*m
        i = j = k = 0

        while i < len(a) and j < n:
            if a[i] == b[j]:
                c[k] += a[i+1]*b[j+1]
                i += 1
                j += 1

            elif a[i] > b[j]:
                j += 1
            
            else:
                i += 1
        
        return c
    
    for i in range(len(C)):
        row = A[i]
        col = multiply([r[0] for r in B], row)
        C[i][:m] = col
    
    return C
```

### 背包问题：
```python
def backpack(N, weight, value):
    dp = [[float('-inf')] * (N + 1) for _ in range(weight + 1)]

    for w in range(weight + 1):
        for i in range(N + 1):
            if w >= weight[i - 1]:
                dp[w][i] = max(value[i - 1] + dp[w - weight[i - 1]][i - 1], dp[w][i - 1])
                
    return dp[-1][-1]
```

### 最大子序和问题：
```python
def maxSubArraySum(arr):
    N = len(arr)
    dp = [-float('inf')]*N
    dp[0] = arr[0]

    for i in range(1, N):
        dp[i] = max(dp[i-1]+arr[i], arr[i])

    return dp[-1]
```

### 括号匹配问题：
```python
def isMatch(s, p):
    m, n = len(s), len(p)
    dp = [[False] * (n + 1) for _ in range(m + 1)]

    dp[0][0] = True

    for i in range(m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == '*' and p[j - 1]!= '*':
                dp[i][j] |= dp[i - 1][j - 1] | dp[i][j - 1]
            elif p[j - 1] == '.' or p[j - 1] == s[i - 1]:
                dp[i][j] |= dp[i - 1][j - 1]
    
    return dp[-1][-1]
```