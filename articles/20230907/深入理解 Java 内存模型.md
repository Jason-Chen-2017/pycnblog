
作者：禅与计算机程序设计艺术                    

# 1.简介
  

Java Memory Model（JMM）是Java语言规范中定义的一套规则和机制，通过它可以保证在并发环境下程序的可见性、一致性和持久性。Java的内存模型决定了线程之间如何通信、数据如何共享，以及发生什么样的同步、锁、Volatile变量等内存访问行为。通过阅读本文，你可以全面了解JMM的内容、用途和机制，并且掌握如何正确地使用Volatile关键字和 synchronized 锁保证应用的正确运行。

# 2. Java内存模型概述
首先，我们先来看一下Java内存模型的相关概念和术语。

## 2.1 对象、作用域与生命周期

对象在JVM中的生命周期包括如下三个阶段：

1. **创建阶段：** 对象在堆上被分配内存空间并初始化。
2. **可达性分析阶段：** JVM会对堆中的所有对象进行可达性分析，当一个对象不再有任何对它的引用或者该对象的 finalize()方法已经被调用后，这个对象就会被回收掉。
3. **不可达阶段：** 当某个对象不可达时，它占用的内存空间就可以被释放，其他对象的引用不会影响到该对象。

**对象**： 在JMM中，对象指的是存储在堆上的Java实体。在JVM中，堆可以看作是一个大的二维数组，数组的每个元素代表一个内存位置。所有对象都需要通过堆内存创建，对象创建之后可以通过栈上的指针变量或者寄存器变量引用到堆上的对象。

**作用域**： 在JMM中，作用域是指一段程序或声明语句的上下文范围，主要包括类、方法、循环结构等。作用域内定义的对象，只有在其作用域及子作用域内才可以被访问。

**生命周期**： 在JMM中，生命周期是指从内存中诞生到消亡的一个过程。一个对象的生命周期包含两个方面，第一个是对象的创建与销毁，第二个是在整个生命周期中对其状态的改变。

## 2.2 程序顺序与happens-before关系

程序执行时有序，由控制流顺序执行。JMM通过happens-before规则来明确定义并发情况下的执行顺序。

Happens-before关系的意义在于使得程序更加易读，易懂，容易验证，进而提高了代码的正确性。通过happens-before关系，JVM能够推导出正确的并行执行方案，为程序员提供更多的可能性。例如，程序员可以使用happens-before规则来指定一个变量在更新前后的依赖关系，进而帮助编译器和处理器生成高效的代码。

根据happens-before关系，可以在不同的线程间通信，还可以用来实现显式同步，减少隐式锁的出现。通过这种方式，开发者无需考虑锁的各种细节，只需要简单地通过标识共享资源即可。

## 2.3 同步与volatile变量

### 2.3.1 Synchronized关键字

在多线程编程中，同步是一种在多个线程之间进行协作的机制，在某些情况下，为了防止竞争条件，需要对共享资源进行同步。

在JMM中，synchronized 关键字用来确保一段代码片段只能有一个线程执行，也即排他性同步。当一个线程试图获取一个被另一个线程持有的对象的同步锁时，就会阻塞住该线程，直到同步锁被释放。

通过将临界区的代码包裹在 synchronized 关键字中，就可以确保临界区代码只能由一个线程执行，从而避免竞争条件。但是，在实际使用中，可能会遇到一些性能问题，例如，同步机制引入额外的互斥开销、过度使用锁会导致死锁等。因此，在必要的时候，应当善用锁来提升程序的并发度。

### 2.3.2 Volatile关键字

在多线程环境下，由于指令重排序、线程调度、缓存等因素的影响，程序执行的结果可能跟我们预期的不一致。为了解决这个问题，提出了Volatile关键字。Volatile是轻量级的同步机制，通过它保证对变量的修改可见性，在某些情况下，使用 volatile 可以比使用锁更优雅地实现并发。

通过将变量申明为 volatile 关键字，表明此变量可能会被其他线程修改，JVM就不会将该变量存在缓冲 cache 里，每次都会直接从主内存读写，从而可以保证变量的可见性，而且不会造成不必要的阻塞。另外，volatile 关键字还提供了禁止指令重排序的功能，程序执行时的内存访问顺序与代码的顺序一致，这就保证了程序执行的正确性。

## 2.4 final、static字段与重排序

final 关键字用于修饰变量，表示它们的值不能被修改。如果一个对象被标记为 final 的话，则其实例字段的值一旦被初始化完成，便无法更改。

static 关键字用于修饰静态成员变量和静态方法，表示这些成员属于类的全局状态而不是对象的状态。当多个线程同时访问同一个 static 变量的时候，需要保证该变量的一致性。因此，在访问 static 变量时，要注意不要让多个线程一起进入临界区，否则会引起数据不一致的问题。

由于指令重排序的存在，volatile、final、static关键字的使用可以影响程序的执行，甚至可能导致一些未知的错误。为了确保程序的正确性，建议在开发过程中要小心谨慎。

## 2.5 方法调用与happens-before规则

在JMM中，方法调用属于原子操作，因为方法调用会涉及到栈帧的切换和类的加载，所以一般来说，两个方法之间没有什么happens-before关系。不过，有一些方法调用具有happens-before关系，比如volatile变量的写操作happens-before volatile变量的读操作、对一个volatile变量的写操作happens-before随后对这个变量的读操作等。

## 2.6 对象发布与初始化

在Java中，对象的发布（发布对象到某个变量）分为两步：第一步，对象的引用变量指向对象的起始地址；第二步，对象构造函数中的代码执行完毕。这两步不是一个原子操作，在JIT编译器或热点探测优化中，可以将两步合成为一步。

在JMM中，对象发布具有 happens-before 关系。对象构造函数完成后，所有的对这个对象的操作之前都是发布这个对象的操作。换句话说，对于一个 volatile 变量来说，它的发布保证了在当前线程之前对它的所有操作的可见性，后续线程将能看到这些操作的效果。

对于一个类的实例化对象来说，它的构造函数执行过程中，需要将成员变量都设定好，然后才能对这个对象进行操作。这说明，对于同一个类的不同实例来说，他们的成员变量在发布之前可能是不一样的，因此对同一个类的不同实例进行操作可能出现不一致的情况。这时候，需要对每个实例变量进行发布，确保成员变量的一致性。