
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 什么是EVM？
以太坊虚拟机（Ethereum Virtual Machine，简称EVM）是一个运行在以太坊区块链网络上执行智能合约、存储数据的软件。它负责部署、验证、执行智能合约的代码，并维护所有账户信息。用户可以通过发送交易数据到网络中请求执行智能合约。EVM是一个层级结构，包括硬件指令集和栈操作以及状态树数据库。

## 为什么需要EVM？
当前以太坊智能合约平台支持Solidity语言，可以进行编译成字节码文件，部署到区块链上运行。但是字节码只能由解释器执行，效率较低；同时多个智能合约之间存在相互调用，执行效率低下。因此，人们希望能够有一个高性能、轻量化、安全、易于扩展的EVM虚拟机，来实现智能合约的快速执行。而且EVM可以在不同编程语言间共享共同的状态树数据库，保证多种编程语言的一致性。

## EVM有哪些特性？
目前，以太坊生态中已经支持的主要的智能合约编程语言有Solidity、Vyper、LLL和Serpent。除此之外，还有Plasma Cash、EOS VM等其他虚拟机平台正在推进。那么，这些虚拟机平台中的每一个，都有哪些特性呢？
### Solidity
- 源语言：Solidity是EVM上的一种最流行的智能合约编程语言。
- 字节码：Solidity编译器将Solidity代码编译生成四个字节码文件：<contract name>.abi.json、<contract name>.bin、<contract name>_metadata.json和<contract name>.ast.json。前两个文件分别对应的是编译后的合约接口描述文件和编译后的字节码文件，后两个文件则是可选项。
- 执行过程：当发起交易时，Solidity编译器会根据指定版本的编译器，对输入源代码进行编译，生成相应的字节码。然后，节点接收到交易数据之后，就会解析字节码，从而执行相关的智能合约逻辑。
- 执行环境：当智能合约被部署或调用时，Solidity执行环境主要有以下几个方面：
    - Message call：调用其他智能合约，这种情况可以使用EVM通过消息传递的方式实现，也即使得被调用的智能合约的内部代码也可以被执行。
    - Execution cost：由于EVM的执行机制，一个智能合约的代码的执行成本可能会比较高，这是由EVM指令所消耗的时间和内存资源决定的。为了降低合约执行成本，智能合约开发者需要遵循一些可优化的方式，如设置合理的参数类型、调整合约代码大小、优化外部函数调用等。
    - Gas limit：智能合约执行过程中会消耗Gas，Gas limit是指最大的Gas消耗限制值。如果Gas消耗超过了这个限制值，就无法继续执行了。Gas limit可以通过GAS opcode来设置。
    - Stack size：EVM运行时操作栈的大小是固定的，默认情况下，栈的大小为1024。因此，在编写智能合约的时候，需要注意不要出现超出这个限制的操作。另外，栈的大小还受制于智能合约被部署时的Gas费用，并且随着智能合约的执行，栈也会逐渐增长。
### Vyper
- 源语言：Vyper是基于Python语言的一种新的类似Solidity的智能合约语言，用于构建动态、静态类型、强类型和安全的智能合约。它的目标是作为Python在区块链领域的首选语言。
- 字节码：Vyper编译器将Vyper代码编译成字节码文件，该文件可以直接在EVM上执行。但其字节码文件没有与Solidity兼容。
- 执行过程：当智能合约被部署或者调用时，Vyper会将输入源代码编译成字节码文件，再将其上传至EVM上执行。
- 执行环境：当智能合约被部署或者调用时，Vyper执行环境与Solidity基本相同。只是Vyper对Gas limit的限制更加严格。
### LLL
- 源语言：LLL是一种简单方便的编程语言，旨在用更少的编码完成复杂功能。LLL结合了像C++和Java这样的强类型的编程语言的一些特点，让智能合约的开发变得更加灵活。
- 字节码：LLL的字节码与Solidity兼容。
- 执行过程：当智能合约被部署或者调用时，LLL会先将输入源代码编译成字节码文件，再将其上传至EVM上执行。
- 执行环境：与其他三种虚拟机平台基本一致。
### Serpent
- 源语言：Serpent是一种类似Python的编程语言，但与Python不同的是，Serpent是为EVM设计的高性能脚本语言。
- 字节码：Serpent编译器将Serpent代码编译成字节码文件，该文件可以直接在EVM上执行。
- 执行过程：当智能合约被部署或者调用时，Serpent会将输入源代码编译成字节码文件，再将其上传至EVM上执行。
- 执行环境：与其他三种虚拟机平台基本一致。

除了以上四种虚拟机平台，还有其他的一些虚拟机平台正在推进，例如Plasma Cash、EOS VM等。这些虚拟机平台与EVM一样，都是为了提升智能合约的执行效率、增加Turing completeness等。

# 2.核心概念与联系
## 虚拟机
EVM是一个抽象计算机，它模拟了真实世界的计算设备。每个人类可以认为他是一个虚拟机，它拥有自己的指令集和内存空间，可以运行任意的软件程序。但是，为了让智能合约运行在EVM上，首先需要了解一下EVM的架构。

EVM有两种类型的处理器：虚拟机处理器（EVM processor）和指令集处理器（ISA processor）。EVM处理器模仿了现有的CPU，执行虚拟机程序；ISA处理器直接通过指令集指令执行计算任务，与EVM processor配合工作。

EVM中还有一种特殊的处理器——Storage Processor（SP），它的作用是在EVM外部保存状态树的数据。状态树是EVM上所有智能合约共享的一个数据存储区域。它存储智能合约创建或修改的数据，使得不同的智能合约之间可以访问这些数据。

EVM包含三层：
- 操作系统层：负责管理机器资源和提供系统调用接口，也就是系统级调用接口，是对底层硬件的封装，屏蔽掉硬件细节，向上提供统一的接口。
- 虚拟机层：负责对程序指令及数据进行解释执行，是真正的执行引擎，是EVM的核心。
- 状态存储层：存放智能合约的状态数据，包括智能合约的字节码、存储数据、账户数据等。每个智能合约都有自己的状态数据存储。

图1展示了EVM的结构。
图1 EVM结构

## 帧（Frame）
EVM中，每个线程执行的代码段就是一个帧（Frame），它是一个独立的执行环境。当某个帧开始执行时，就可以为其分配一些资源，比如内存、堆栈、计数器等。线程执行结束后，释放掉对应的资源，并返回主调函数继续执行。

## 调用栈（Call stack）
EVM的执行需要涉及到函数调用，所以需要一个调用栈来记录当前执行的函数调用关系。

## 消息（Message）
EVM中，消息是指在EVM外部与智能合约交互的数据。它由三部分组成：消息调用者地址、消息调用者的签名、消息内容。其中消息内容又分为：方法标识符、参数列表。消息调用者的地址就是该消息的发送方地址。消息调用者的签名是使用私钥对消息的哈希值的签名结果。

## 转账（Transfer）
转账是指智能合约发起的一次交易行为。交易中一般包含一个发送方地址、一个接收方地址、金额等信息。交易的执行分两步：第一步是调用智能合约的fallback函数，它用于在合约尚无方法执行的情况下处理未知的消息。第二步是调用合约中的某个方法，执行交易中指定的操作。只有当执行成功才会给接收方转账。

## 账户（Account）
在EVM中，账户是指智能合约的存储容器，用来存储智能合约创建或修改的数据。每个账户都有一个唯一的地址，并且具有一定数量的Ether的余额。

## Gas（燃料）
EVM的执行过程中，会消耗Gas。Gas的单位是万亿分之一，即Gas = 1 / 1e9。Gas不仅影响执行效率，也会决定智能合约是否能够被执行。如果Gas消耗完毕仍然不能执行完所有的指令，则交易不会被提交。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## EVM运算单位
- Word：词汇单位，通常是32位的整数。
- Bytecode：二进制代码。
- Instruction：一条虚拟机指令，由Opcode和Operands构成。
- Opcode：虚拟机指令的名称，表示指令的功能。
- Operand：指令操作数，可以是立即数、寄存器索引、堆栈指针偏移等。
- Memory：虚拟机运行时使用的临时内存，可以用来存放变量、代码片段、数据结构等。
- Storage：EVM外部保存状态树的数据，用于存储智能合约创建或修改的数据。
- Stack：栈，用来存储数据、参数、返回地址等。
- Call Data：包含合约调用参数的一段内存。
- Return Data：合约执行后返回的结果数据。

## EVM寻址方式
EVM提供了三种寻址方式：
- 直接寻址：EVM通过直接寻址的方式，直接访问某一个单元的内存数据。
- 寄存器寻址：EVM通过寄存器索引的方式，定位寄存器的值。
- 堆栈寻址：EVM通过堆栈指针的方式，定位堆栈上的某一位置的数据。

## EVM指令集
EVM的指令集包括三种类型：
- 算术指令：包括ADD、SUB、MUL、DIV等。
- 比较指令：包括LT、GT、EQ等。
- 控制指令：包括JUMP、JUMPI、CALL、RETURN等。

## ADD指令
ADD指令可以把两个Word数相加，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄存器的内容为0x200，则执行ADD X Y命令后，X寄存器的内容变为0x300。

## SUB指令
SUB指令可以把两个Word数相减，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄register器的内容为0x200，则执行SUB X Y命令后，X寄存器的内容变为0xFFF。

## MUL指令
MUL指令可以把两个Word数相乘，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄存器的内容为0x200，则执行MUL X Y命令后，X寄存器的内容变为0x20000。

## DIV指令
DIV指令可以把两个Word数相除，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄存器的内容为0x200，则执行DIV X Y命令后，X寄存器的内容变为0。

## LT指令
LT指令可以判断第一个操作数是否小于第二个操作数，如果小于则置1，否则置0，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄存器的内容为0x200，则执行LT X Y命令后，X寄存器的内容变为0x1。

## GT指令
GT指令可以判断第一个操作数是否大于第二个操作数，如果大于则置1，否则置0，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x200，Y寄存器的内容为0x100，则执行GT X Y命令后，X寄存器的内容变为0x1。

## EQ指令
EQ指令可以判断两个操作数是否相等，如果相等则置1，否则置0，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1、src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄存器的内容为0x100，则执行EQ X Y命令后，X寄存器的内容变为0x1。

## JUMP指令
JUMP指令可以跳转到目的地的指令位置执行，它的一般格式如下：
```
OPCODE [addr]
```
- addr：目的地的指令位置。

举例：假设当前指令地址为0x100，指令序列为：`0x100 ADD  0x200  0x100`，则执行JUMP 0x300命令后，PC寄存器指向地址0x300处开始执行指令。

## JUMPI指令
JUMPI指令可以根据条件跳转到目的地的指令位置执行，它的一般格式如下：
```
OPCODE [addr] [cond]
```
- addr：目的地的指令位置。
- cond：跳转的条件。

举例：假设当前指令地址为0x100，指令序列为：`0x100 LT   0x100  0x200`，则执行JUMPI 0x300 0x1命令后，PC寄存器指向地址0x300处开始执行指令。

## CALL指令
CALL指令可以调用另一个帧执行代码，它有两种形式：
```
CALL address
```
- address：调用函数的地址。

```
CALL address args offset len
```
- address：调用函数的地址。
- args：传入的参数数量。
- offset：参数在调用函数里面的偏移位置。
- len：参数长度。

举例：假设当前指令地址为0x100，指令序列为：`0x100 CALL 0x100`，则执行CALL 0x100命令后，调用函数地址为0x100处的指令，并进入函数。

## RETURN指令
RETURN指令可以退出当前帧的执行，并返回数据给调用者。它的一般格式如下：
```
RETURN retoffset retsiz
```
- retoffset：返回值在堆栈里面的偏移位置。
- retsiz：返回值的长度。

举例：假设当前指令地址为0x100，指令序列为：`0x100 CALL 0x100`, `0x100 RET 0x0 0x0`，则执行CALL 0x100命令后，返回函数的执行结果给调用者。

## SHA3指令
SHA3指令可以计算keccak256哈希值，并把结果写入目的地。它的一般格式如下：
```
OPCODE [dest] [src1] [src2]
```
- dest：目的地。
- src1：源操作数。
- src2：源操作数。

举例：假设X寄存器的内容为0x100，Y寄存器的内容为0x200，则执行SHA3 X Y命令后，X寄存器的内容变为keccak256(M[0x100:0x200])的哈希值。

## SSTORE指令
SSTORE指令可以保存一个值到状态树里面。它的一般格式如下：
```
SSTORE [key] [val]
```
- key：键值。
- val：要保存的值。

举例：假设当前帧的帐户地址为0x100，调用方是0x200，指令序列为：`0x100 SSTORE 0x100 0x200`，则执行SSTORE 0x100 0x200命令后，将键值为0x100的值设置为0x200。

## SLOAD指令
SLOAD指令可以加载状态树里面的值。它的一般格式如下：
```
SLOAD [dest] [key]
```
- dest：目的地。
- key：键值。

举例：假设当前帧的帐户地址为0x100，调用方是0x200，指令序列为：`0x100 SLOAD 0x100`，则执行SLOAD 0x100 命令后，X寄存器的内容变为0x200。

## PUSHN指令
PUSHN指令可以把一个立即数推入栈顶。它的一般格式如下：
```
OPCODE N [imm]
```
- imm：立即数。

举例：假设当前指令地址为0x100，指令序列为：`0x100 PUSHN 0x01020304`，则X寄存器的内容变为0x1020304。

## DUP指令
DUP指令可以复制栈顶元素到栈顶。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 PUSH1 0x01 PUSH1 0x02 DUP2`，则X寄存器的内容变为0x0102。

## SWAP指令
SWAP指令可以交换两个栈顶元素的位置。它的一般格式如下：
```
OPCODE
```

举例：假设当前指令地址为0x100，指令序列为：`0x100 PUSH1 0x01 PUSH1 0x02 SWAP2`，则X寄存器的内容变为0x0201。

## MSIZE指令
MSIZE指令可以得到当前的内存占用的大小。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 PUSH1 0x01 PUSH1 0x02 MSIZE`，则X寄存器的内容变为0x04。

## ADDRESS指令
ADDRESS指令可以得到当前帧的帐户地址。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 ADDRESS`，则X寄存器的内容变为当前帧的帐户地址。

## BLOCKHASH指令
BLOCKHASH指令可以得到当前区块的哈希值。它的一般格式如下：
```
OPCODE [dest] [num]
```
- dest：目的地。
- num：区块高度。

举例：假设当前指令地址为0x100，指令序列为：`0x100 BLOCKHASH 0x0`，则X寄存器的内容变为当前区块的哈希值。

## TIMESTAMP指令
TIMESTAMP指令可以得到当前的时间戳。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 TIMESTAMP`，则X寄存器的内容变为当前时间戳。

## NUMBER指令
NUMBER指令可以得到当前区块高度。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 NUMBER`，则X寄存器的内容变为当前区块高度。

## COINBASE指令
COINBASE指令可以得到当前区块的矿工地址。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 COINBASE`，则X寄存器的内容变为当前区块的矿工地址。

## DIFFICULTY指令
DIFFICULTY指令可以得到当前区块的难度系数。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 DIFFICULTY`，则X寄存器的内容变为当前区块的难度系数。

## GASLIMIT指令
GASLIMIT指令可以得到当前帧的Gas Limit。它的一般格式如下：
```
OPCODE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 GASLIMIT`，则X寄存器的内容变为当前帧的Gas Limit。

## POP指令
POP指令可以弹出栈顶元素。它的一般格式如下：
```
OPCODE
```

举例：假设当前指令地址为0x100，指令序列为：`0x100 PUSH1 0x01 PUSH1 0x02 POP`，则栈顶元素为空。

## LOGN指令
LOGN指令可以记录日志。它的一般格式如下：
```
OPCODE [num]
```
- num：参数数量。

举例：假设当前指令地址为0x100，指令序列为：`0x100 LOG2 0x01 0x02`，则记录了两个参数为0x01和0x02的日志。

## SIGNEXTEND指令
SIGNEXTEND指令可以根据第三个操作数的符号，扩展第一个操作数。它的一般格式如下：
```
OPCODE [dest] [byte]
```
- dest：目的地。
- byte：字节序号。

举例：假设X寄存器的内容为0xFFFFFFFD，Y寄存器的内容为0x1，则执行SIGNEXTEND X Y命令后，X寄存器的内容变为0xFFFFFFFF。

## CREATE指令
CREATE指令可以创建一个新帐户，并获得它的地址。它的一般格式如下：
```
CREATE [value] [addr] [startgas] [memsize]
```
- value：转账金额。
- addr：调用方的地址。
- startgas：GasLimit。
- memsize：内存大小。

举例：假设当前指令地址为0x100，指令序列为：`0x100 CREATE 0x0 FFFFFFFF 0x0100`，则创建一个新帐户，并获得它的地址。

## CALLVALUE指令
CALLVALUE指令可以得到调用方传送的金额。它的一般格式如下：
```
CALLVALUE [dest]
```
- dest：目的地。

举例：假设当前指令地址为0x100，指令序列为：`0x100 CALLVALUE`，则X寄存器的内容变为调用方传送的金额。

## CALLDATALOAD指令
CALLDATALOAD指令可以读取调用方传递的参数。它的一般格式如下：
```
CALLDATALOAD [dest] [off]
```
- dest：目的地。
- off：参数偏移。

举例：假设当前指令地址为0x100，指令序列为：`0x100 CALLDATALOAD 0x0`，则X寄存器的内容变为调用方传递的参数。

## CODECOPY指令
CODECOPY指令可以拷贝当前帧的字节码到内存。它的一般格式如下：
```
CODECOPY [memOff] [codeOff] [len]
```
- memOff：目的内存偏移。
- codeOff：源字节码偏移。
- len：复制的长度。

举例：假设当前指令地址为0x100，指令序列为：`0x100 CODECOPY 0x0 0x0 0x100`，则将当前帧的字节码拷贝到内存。

## EXTCODESIZE指令
EXTCODESIZE指令可以得到帐户代码的长度。它的一般格式如下：
```
EXTCODESIZE [dest] [address]
```
- dest：目的地。
- address：帐户地址。

举例：假设当前指令地址为0x100，指令序列为：`0x100 EXTCODESIZE 0x200`，则X寄存器的内容变为帐户0x200的代码长度。

## EXTCODECOPY指令
EXTCODECOPY指令可以拷贝帐户代码到内存。它的一般格式如下：
```
EXTCODECOPY [memOff] [address] [codeOff] [len]
```
- memOff：目的内存偏移。
- address：帐户地址。
- codeOff：源代码偏移。
- len：复制的长度。

举例：假设当前指令地址为0x100，指令序列为：`0x100 EXTCODECOPY 0x0 0x200 0x0 0x100`，则将帐户0x200的代码拷贝到内存。

## REVERT指令
REVERT指令可以终止当前帧的执行并回滚状态树。它的一般格式如下：
```
REVERT [offset] [len]
```
- offset：回滚状态树的偏移位置。
- len：回滚状态树的字节数。

举例：假设当前指令地址为0x100，指令序列为：`0x100 REVERT 0x0 0x100`，则终止当前帧的执行并回滚状态树。