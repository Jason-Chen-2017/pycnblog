
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 概述
当多个线程同时对某个资源进行访问时，如果没有正确实现同步机制，就可能造成数据不同步、数据丢失等问题。典型的应用场景是多线程访问共享变量，当某个线程需要修改该变量时，其他线程也要等待当前线程释放锁或者完成相关操作，从而导致死锁甚至数据错误。如何有效避免这种问题，就是保障线程安全的重要措施之一。本文将介绍在Java编程中如何正确使用synchronized关键字来保证线程安全。
## synchronized的作用及原理
### synchronized修饰方法
synchronized修饰的方法可以确保同一时间只有一个线程可以执行该方法，并且其他线程只能等待当前线程执行完毕后才能继续执行。具体来说，当线程A调用一个带有synchronized关键字的方法m()时，JVM将记住这个线程A正在执行m()方法，并且阻塞其它所有试图调用m()方法的线程直到线程A执行完毕后才恢复他们的执行。这样就可以确保同一时间只有一个线程可以执行m()方法。此外，当线程A调用另一个synchronized方法n()时，JVM会确保线程A在执行完第一个方法后再执行第二个方法，这样就防止了两个线程同时进入同一个对象的方法中并竞争资源，提高了线程安全性。
### synchronized修饰静态方法
当synchronized修饰静态方法时，它可以确保整个类中的所有对象都拥有同一把锁，从而防止多个线程同时访问静态方法和修改静态变量，也能确保静态成员只被初始化一次，提升性能。
### synchronized修饰代码块
当synchronized修饰代码块时，它可以在同步语句块内的代码片段上加锁，使得同一时间只有一个线程在执行该代码块。但其限制比较苛刻，无法控制不同线程之间的同步，一般情况下不推荐使用该方式。
### synchronized的作用域
synchronized修饰的方法、静态方法和代码块默认作用于整个类，也可以通过制定加锁对象的范围（对象级别）来进一步指定同步范围。例如：
```java
public class Test {
   public static void main(String[] args) throws InterruptedException {
      Object obj = new Object();
      Thread t1 = new Thread(() -> {
         synchronized (obj) {
            try {
               System.out.println("Thread " + Thread.currentThread().getName());
               TimeUnit.SECONDS.sleep(3);
                for (int i=0;i<5;i++) {
                   System.out.print(i+", ");
                }
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
          }
       });

      Thread t2 = new Thread(() -> {
         synchronized (obj) {
            try {
               System.out.println("Thread " + Thread.currentThread().getName());
               TimeUnit.SECONDS.sleep(3);
                for (int i=0;i<5;i++) {
                   System.out.print(i+"*");
                }
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
          }
       });
      t1.start();
      t2.start();
   }
}
```
上面例子中，Test类里有一个普通方法main()，在该方法中定义了两个线程t1和t2，它们都要访问一个Object类型的静态成员obj。为了保证线程安全，这里使用了synchronized关键字，用obj作为同步锁。虽然在同一时间只有一个线程可以访问该对象，但是由于两个线程的操作没有交叉，所以仍然可以正常工作。
### synchronized的原理
#### Java虚拟机
在JVM内部，每一个对象都有对应的监视器或管程（monitor），当一个线程执行同步代码块的时候，该线程必须持有该对象的监视器；而执行完同步代码块后，该线程就会释放掉它的监视器，使得其它线程有机会获取该对象的监视器。当两个线程都企图获得同一个对象的监视器时，只有一个线程能成功地获取到，这时候线程调度器就会根据优先级或抢占策略等规则来选择运行哪个线程。获取了监视器的所有线程都需要等到锁释放后才能重新竞争，以避免出现死锁。因此，使用synchronized关键词比直接使用锁效率更高，而且在发生异常情况时不会影响其他线程的执行，因为锁一旦获取不到就不会自动释放。
#### 抢占
当两个或更多线程竞争同一把锁时，如果该锁已经被别的线程保持，那么前者线程就会处于阻塞状态，即暂停执行，待锁被释放后才能获取到该锁并继续执行。抢占可以通过设置超时参数来避免一直无限期地等待锁的释放，提升系统的吞吐量。另外，对于一个线程一直获取不到锁而一直在等待，也是一种资源浪费，因此应该给予适当的警告或抛出异常来解决。
#### 对锁的升级与降级
synchronized是通过字节码指令来实现锁的功能，锁的状态包括偏向锁、轻量级锁、重量级锁，每次都是由低到高的过程。当然，不同的平台和JVM实现也有所区别。在没有竞争的情况下，偏向锁是一个非常好的优化，它能降低请求锁的时间。对于竞争激烈的情况下，比如有多个线程都企图获得同一把锁，则可能会升级为重量级锁，它比轻量级锁的开销大很多，并且持有锁的线程也不能够减少。但是在这之后，锁的状态又会回退到前面的过程，如锁竞争激烈或处于休眠状态时。
## 线程间的通信
当多个线程需要共享某些信息或资源时，需要进行线程间的通信，最常用的方法就是共享变量。但是在复杂的多线程环境下，不同线程之间共享变量容易出现竞态条件（Race Condition）。例如，线程A和B同时修改变量x的值，结果可能不是预期的。为了避免竞态条件，通常采用如下两种方法：
### 可见性
可见性是指当一个线程修改了一个共享变量的值，其他线程能够立即感知到这个修改，并取到这个最新值。也就是说，当一个线程修改了共享变量，其他线程能够立即知道这个修改，并且能够使用这个新的值。在Java中，volatile关键字能够满足可见性。当一个变量声明为volatile时，读取它的线程总是能看到最近写入的值，而写入它的线程总是能看到最近读到的旧值。当一个volatile变量修改后，新值会被强制刷新到主存中，然后每个线程都会从主存中读取最新的值。因此，使用volatile能够保证数据的可见性。
### 有序性
有序性是指代码的执行顺序按照程序的逻辑来执行。如果一个线程观察其他线程的中间结果，只能看见一个有序的、一致的视图，这就是无序性。编译器和处理器能够重排序代码，但程序员编写的代码不能够随意乱序。为了禁止指令重排序，Java内存模型采取了先行发生原则。它允许编译器和处理器对指令进行重排序，但要求Volatile变量的写-读操作不被重排序。也就是说，当一个线程修改一个volatile变量，这个修改对其他线程可见之前，必须经过完整的指令序列。volatile的使用能够保证数据间的有序性。
### 本文结论
1. 在Java语言中，使用synchronized关键字可以保证线程安全，并且确保同一时间只有一个线程可以访问某个方法或代码块。
2. 如果多个线程对某个变量进行访问，使用volatile可以保证数据可见性，也就是说其他线程能够立即看到最新的数据。
3. 当多个线程对变量进行访问时，应该使用volatile和synchronized关键字共同确保线程安全。