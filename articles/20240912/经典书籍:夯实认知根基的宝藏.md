                 

### **经典书籍：夯实认知根基的宝藏**——面试题与算法编程题精选解析

#### **1. 二分查找**

**题目：** 给定一个排序数组，实现二分查找，找到目标元素并返回其索引。如果没有找到，返回 -1。

**代码示例：**

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

**解析：** 二分查找是一种高效的搜索算法，时间复杂度为 O(log n)。通过不断将搜索区间缩小一半，可以快速定位到目标元素。

#### **2. 最长公共前缀**

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**代码示例：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = ""
    for char in strs[0]:
        for s in strs[1:]:
            if len(s) < len(prefix) or s[:len(prefix)] != prefix:
                return prefix
        prefix += char
    return prefix
```

**解析：** 通过依次比较字符串数组中的每个字符，可以找到最长公共前缀。时间复杂度为 O(n*m)，其中 n 是字符串数组长度，m 是最长公共前缀长度。

#### **3. 逆波兰表达式求值**

**题目：** 根据逆波兰表示法，求表达式的值。

**代码示例：**

```python
def eval_rpn(tokens):
    stack = []
    for token in tokens:
        if token.isdigit():
            stack.append(int(token))
        else:
            right = stack.pop()
            left = stack.pop()
            if token == '+':
                stack.append(left + right)
            elif token == '-':
                stack.append(left - right)
            elif token == '*':
                stack.append(left * right)
            elif token == '/':
                stack.append(left / right)
    return stack[0]
```

**解析：** 逆波兰表达式（RPN）是一种后缀表示法，通过使用栈可以方便地计算表达式的值。时间复杂度为 O(n)，其中 n 是表达式的长度。

#### **4. 电话号码的字母组合**

**题目：** 给定一个字符串数字，返回所有可能的字母组合。

**代码示例：**

```python
def letter_combination(digits):
    def dfs(digits, index, path):
        if index == len(digits):
            combinations.append(''.join(path))
            return
        for letter in phone_map[digits[index]]:
            path.append(letter)
            dfs(digits, index + 1, path)
            path.pop()

    phone_map = {
        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
    }
    combinations = []
    dfs(digits, 0, [])
    return combinations
```

**解析：** 通过递归和深度优先搜索，可以生成所有可能的字母组合。时间复杂度为 O(3^n)，其中 n 是字符串数字的长度。

#### **5. 盗贼能否偷窃？**

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都按顺序排列，如果你相邻的两间房屋在同一晚上被小偷闯入，你会受到监控报警。计算你在一晚上能够偷窃的最大现金数。

**代码示例：**

```python
def rob(nums):
    if len(nums) == 1:
        return nums[0]
    prev1, prev2 = nums[0], max(nums[0], nums[1])
    for num in nums[2:]:
        curr = max(prev2, prev1+num)
        prev1, prev2 = prev2, curr
    return prev2
```

**解析：** 使用动态规划解决问题，通过维护前两个状态值，计算最大现金数。时间复杂度为 O(n)，其中 n 是房屋数量。

#### **6. 合并区间**

**题目：** 给定一个区间的列表，合并所有重叠的区间。

**代码示例：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if result[-1][1] >= interval[0]:
            result[-1][1] = max(result[-1][1], interval[1])
        else:
            result.append(interval)
    return result
```

**解析：** 通过对区间列表进行排序，然后逐个合并重叠的区间，可以找到所有不重叠的区间。时间复杂度为 O(nlogn)，其中 n 是区间数量。

#### **7. 搜索旋转排序数组**

**题目：** 给定一个旋转排序的数组，实现一个搜索函数，搜索给定的目标值是否存在于数组中。如果存在返回索引，否则返回 -1。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 通过二分查找的方法，考虑旋转数组的特点，可以在 O(log n) 时间内找到目标值。其中 n 是数组长度。

#### **8. 有效的括号**

**题目：** 给定一个字符串，判断它是否是有效的括号表示。

**代码示例：**

```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack
```

**解析：** 使用栈来存储左括号，遇到右括号时，判断其对应的左括号是否在栈顶。时间复杂度为 O(n)，其中 n 是字符串长度。

#### **9. 两数之和**

**题目：** 给定一个整数数组，返回两个数之和等于目标值的索引。

**代码示例：**

```python
def two_sum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

**解析：** 使用哈希表存储已遍历的数字及其索引，通过查找补数，可以在 O(n) 时间内找到两个数的索引。

#### **10. 多数元素**

**题目：** 给定一个整数数组，找出其中出现次数超过数组长度一半的元素。

**代码示例：**

```python
def majority_element(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate
```

**解析：** 使用投票算法，通过计数找出出现次数超过一半的元素。时间复杂度为 O(n)，其中 n 是数组长度。

#### **11. 旋转图像**

**题目：** 给定一个 n × n 的二维矩阵，将其旋转 90 度。

**代码示例：**

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n-i-1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n-j-1][i]
            matrix[n-j-1][i] = matrix[n-i-1][n-j-1]
            matrix[n-i-1][n-j-1] = matrix[j][n-i-1]
            matrix[j][n-i-1] = temp
    return matrix
```

**解析：** 通过层序遍历，将矩阵元素沿对角线翻转，可以实现旋转。时间复杂度为 O(n^2)，其中 n 是矩阵大小。

#### **12. 合并有序链表**

**题目：** 给定两个升序排列的链表，合并它们为一个新的升序链表。

**代码示例：**

```python
def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

**解析：** 通过迭代合并两个链表，可以创建一个新的有序链表。时间复杂度为 O(n+m)，其中 n 和 m 分别是两个链表长度。

#### **13. 字符串转换整数 (atoi)**

**题目：** 实现字符串转换整数的函数，将字符串转换为整数，并返回整数的结果。

**代码示例：**

```python
def myAtoi(s):
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    sign = 1
    i = 0
    result = 0
    while i < len(s) and s[i] == ' ':
        i += 1
    if i < len(s) and (s[i] == '+' or s[i] == '-'):
        sign = -1 if s[i] == '-' else 1
        i += 1
    while i < len(s) and s[i].isdigit():
        digit = ord(s[i]) - ord('0')
        if result > (INT_MAX - digit) // 10:
            return INT_MAX if sign > 0 else INT_MIN
        result = result * 10 + digit
        i += 1
    return sign * result
```

**解析：** 通过遍历字符串，处理符号位，逐位转换为整数，并考虑溢出情况。时间复杂度为 O(n)，其中 n 是字符串长度。

#### **14. 合并两个有序链表**

**题目：** 给定两个有序链表，合并它们为一个新的有序链表。

**代码示例：**

```python
def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

**解析：** 通过迭代合并两个链表，可以创建一个新的有序链表。时间复杂度为 O(n+m)，其中 n 和 m 分别是两个链表长度。

#### **15. 两数相加**

**题目：** 给出两个 非空 的链表用来表示两个非负的整数，其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

**代码示例：**

```python
def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    current = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        current.next = ListNode(sum % 10)
        current = current.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

**解析：** 通过迭代处理两个链表中的节点，计算和的每一位，并处理进位。时间复杂度为 O(max(n, m))，其中 n 和 m 分别是两个链表长度。

#### **16. 三数之和**

**题目：** 给你一个整数数组 nums ，判断是否存在三个数 nums[i] ，nums[j] 和 nums[k] 使得它们两两之和等于第三个数。

**代码示例：**

```python
def three_sum(nums):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return result
```

**解析：** 通过排序和双指针方法，可以找到所有三数之和为 0 的组合。时间复杂度为 O(n^2)，其中 n 是数组长度。

#### **17. 盛水最多的容器**

**题目：** 给定一个二维数组，求其中两个数列的最长连续子序列和。

**代码示例：**

```python
def max_area(heights):
    left, right = 0, len(heights) - 1
    max_area = 0
    while left < right:
        max_area = max(max_area, min(heights[left], heights[right]) * (right - left))
        if heights[left] < heights[right]:
            left += 1
        else:
            right -= 1
    return max_area
```

**解析：** 通过双指针遍历，计算每个边界点之间的面积，可以找到最大面积。时间复杂度为 O(n)，其中 n 是数组长度。

#### **18. 长度最小的子数组**

**题目：** 给定一个数组和一个目标值，找到最短不含重复数字的子数组，返回其长度。

**代码示例：**

```python
def min_sub_array_len(nums, target):
    left, right = 0, 0
    current_sum = nums[0]
    min_length = float('inf')
    while right < len(nums):
        if current_sum < target:
            right += 1
            if right < len(nums):
                current_sum += nums[right]
        else:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    return min_length if min_length != float('inf') else 0
```

**解析：** 使用滑动窗口方法，计算当前窗口和，调整窗口边界，可以找到最小窗口。时间复杂度为 O(n)，其中 n 是数组长度。

#### **19. 反转链表**

**题目：** 反转一个单链表。

**代码示例：**

```python
def reverse_linked_list(head):
    prev, curr = None, head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
```

**解析：** 通过迭代反转链表指针，可以反转链表。时间复杂度为 O(n)，其中 n 是链表长度。

#### **20. 快乐数**

**题目：** 编写一个算法来判断一个数是否是“快乐数”。

**代码示例：**

```python
def is_happy(num):
    def get_next(n):
        sum = 0
        while n > 0:
            sum += (n % 10) ** 2
            n //= 10
        return sum

    slow_runner, fast_runner = num, get_next(num)
    while fast_runner != 1 and slow_runner != fast_runner:
        slow_runner = get_next(slow_runner)
        fast_runner = get_next(get_next(fast_runner))
    return fast_runner == 1
```

**解析：** 使用快慢指针法，如果快指针最终指向 1，则该数为快乐数。时间复杂度为 O(log n)，其中 n 是输入数。

#### **21. 字符串相乘**

**题目：** 给定两个字符串表示的非负整数，实现一个算法来计算它们的乘积。

**代码示例：**

```python
def multiply_strings(num1, num2):
    len1, len2 = len(num1), len(num2)
    result = [0] * (len1 + len2)
    for i in range(len1 - 1, -1, -1):
        for j in range(len2 - 1, -1, -1):
            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            sum = mult + result[i + j + 1]
            result[i + j + 1] = sum % 10
            result[i + j] += sum // 10
    while len(result) > 1 and result[0] == 0:
        result.pop(0)
    return ''.join(map(str, result))
```

**解析：** 通过模拟乘法过程，逐位计算乘积，并处理进位，可以计算字符串表示的整数的乘积。时间复杂度为 O(m+n)，其中 m 和 n 分别是两个字符串长度。

#### **22. 缺失的数**

**题目：** 给定一个包含 0, 1, 2, ..., n 中一些数字的序列，找出缺失的数字。

**代码示例：**

```python
def missing_number(nums):
    n = len(nums) + 1
    total_sum = n * (n - 1) // 2
    for num in nums:
        total_sum -= num
    return total_sum
```

**解析：** 使用高斯求和公式计算序列中缺失的数字。时间复杂度为 O(n)，其中 n 是序列长度。

#### **23. 搜索旋转排序数组**

**题目：** 给定一个旋转排序的数组，实现一个搜索函数，搜索给定的目标值是否存在于数组中。

**代码示例：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 通过二分查找，考虑旋转数组的特点，可以在 O(log n) 时间内找到目标值。时间复杂度为 O(log n)，其中 n 是数组长度。

#### **24. 删除排序数组中的重复项**

**题目：** 给定一个排序数组，删除重复项，使得每个元素只出现一次，返回新的数组长度。

**代码示例：**

```python
def remove_duplicates(nums):
    if not nums:
        return 0
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    return slow + 1
```

**解析：** 使用双指针遍历数组，将不重复的元素移动到数组的开头。时间复杂度为 O(n)，其中 n 是数组长度。

#### **25. 缩小范围**

**题目：** 给定一个排序数组和一个目标值，找到两个数，使得它们的和最接近目标值。

**代码示例：**

```python
def closest_number(nums, target):
    left, right = 0, len(nums) - 1
    closest = nums[0]
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return target
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
        closest = min(closest, abs(target - nums[mid]))
    return closest
```

**解析：** 通过二分查找，找到最接近目标值的数。时间复杂度为 O(log n)，其中 n 是数组长度。

#### **26. 合并两个有序链表**

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**代码示例：**

```python
def merge_sorted_lists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = merge_sorted_lists(l1.next, l2)
        return l1
    else:
        l2.next = merge_sorted_lists(l1, l2.next)
        return l2
```

**解析：** 通过递归合并两个有序链表，可以创建一个新的有序链表。时间复杂度为 O(n+m)，其中 n 和 m 分别是两个链表长度。

#### **27. 最长公共子序列**

**题目：** 给定两个字符串，找出它们的 longest common subsequence。

**代码示例：**

```python
def longest_common_subsequence(s1, s2):
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**解析：** 使用动态规划计算最长公共子序列的长度。时间复杂度为 O(m*n)，其中 m 和 n 分别是两个字符串长度。

#### **28. 排序数组的中位数**

**题目：** 给定一个未排序的数组，找到其中位数。

**代码示例：**

```python
def find_median_sorted_arrays(nums1, nums2):
    m, n = len(nums1), len(nums2)
    if m > n:
        nums1, nums2, m, n = nums2, nums1, n, m
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j - 1]
            elif j == 0:
                max_of_left = nums1[i - 1]
            else:
                max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            if i == m:
                min_of_right = nums2[j]
            elif j == n:
                min_of_right = nums1[i]
            else:
                min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2
```

**解析：** 通过二分查找，找到有序数组的中位数。时间复杂度为 O(log(min(m, n)))，其中 m 和 n 分别是两个数组长度。

#### **29. 最小路径和**

**题目：** 给定一个二维数组，找到从左上角到右下角的最小路径和。

**代码示例：**

```python
def min_path_sum(grid):
    rows, cols = len(grid), len(grid[0])
    for i in range(1, rows):
        grid[i][0] += grid[i - 1][0]
    for j in range(1, cols):
        grid[0][j] += grid[0][j - 1]
    for i in range(1, rows):
        for j in range(1, cols):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    return grid[-1][-1]
```

**解析：** 通过动态规划，计算每个单元格的最小路径和。时间复杂度为 O(m*n)，其中 m 和 n 分别是二维数组的大小。

#### **30. 简化路径**

**题目：** 给定一个字符串表示的简化路径，返回原始路径。

**代码示例：**

```python
def simplify_path(path):
    stack = []
    parts = path.split('/')
    for part in parts:
        if part == '..':
            if stack:
                stack.pop()
        elif part:
            stack.append(part)
    return '/' + '/'.join(stack)
```

**解析：** 通过栈处理路径，简化重复的路径段。时间复杂度为 O(n)，其中 n 是路径长度。

