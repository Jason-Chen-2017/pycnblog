                 

### 2025年滴滴校招算法面试题库及答案

#### 1. 设计一个堆排序算法

**题目：** 实现一个堆排序算法，输入一个无序数组，输出排序后的数组。

**答案：** 

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
  
    if left < n and arr[i] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    for i in range(n, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

    return arr

arr = [12, 11, 13, 5, 6, 7]
heapSort(arr)
print("Sorted array is:", arr)
```

**解析：** 堆排序算法主要包括两个步骤：构造堆和排序。构造堆的过程通过递归实现，将数组调整为最大堆。排序过程通过反复将堆顶元素（最大值）与最后一个元素交换，并再次调整堆，直到整个数组有序。

#### 2. 如何用两个队列实现栈？

**题目：** 使用两个队列实现一个栈，要求栈的操作（push、pop、isEmpty）的时间复杂度均为 O(1)。

**答案：**

```python
from collections import deque

class Stack:
    def __init__(self):
        self.queue1 = deque()
        self.queue2 = deque()

    def push(self, x: int) -> None:
        self.queue2.append(x)
        while len(self.queue1):
            self.queue1.append(self.queue2.popleft())

    def pop(self) -> int:
        if not self.isEmpty():
            return self.queue1.popleft()

    def isEmpty(self) -> bool:
        return not bool(self.queue1 and self.queue2)
```

**解析：** 通过两个队列实现栈时，将元素 push 到 `queue2`，然后将 `queue1` 中的元素逐个移动到 `queue2`。这样，`queue2` 的最后一个元素就是栈顶元素。pop 操作时，直接从 `queue1` 中 pop 出栈顶元素。当 `queue1` 为空时，`queue2` 也为空，栈为空。

#### 3. 如何用栈实现一个队列？

**题目：** 使用两个栈实现一个队列，要求队列的操作（enqueue、dequeue）的时间复杂度均为 O(1)。

**答案：**

```python
class MyQueue:

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, x: int) -> None:
        self.stack1.append(x)

    def pop(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def empty(self) -> bool:
        return not self.stack1 and not self.stack2
```

**解析：** 使用两个栈实现队列时，`stack1` 用于入队操作，`stack2` 用于出队操作。当 `stack2` 为空时，将 `stack1` 的所有元素依次 push 到 `stack2`，这样 `stack2` 的栈顶元素就是队列的头部。出队操作时，直接从 `stack2` 中 pop 出元素。

#### 4. 如何用队列实现一个栈？

**题目：** 使用一个队列实现一个栈，要求栈的操作（push、pop）的时间复杂度均为 O(1)。

**答案：**

```python
from collections import deque

class MyStack:

    def __init__(self):
        self.queue = deque()

    def push(self, x: int) -> None:
        self.queue.append(x)
        for _ in range(len(self.queue) - 1):
            self.queue.append(self.queue.popleft())

    def pop(self) -> int:
        return self.queue.popleft()

    def empty(self) -> bool:
        return not bool(self.queue)
```

**解析：** 使用一个队列实现栈时，每次入队操作后，将队列中的所有元素依次出队并重新入队，这样最后一个入队的元素就会成为队列的头部，即栈顶。出队操作时，直接从队列头部 pop 出元素。

#### 5. 如何实现快速排序？

**题目：** 实现快速排序算法，输入一个无序数组，输出排序后的数组。

**答案：**

```python
def quickSort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quickSort(left) + middle + quickSort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print("Sorted array is:", quickSort(arr))
```

**解析：** 快速排序是一种分治算法。首先选择一个基准元素（这里选择中间元素），然后将数组分为小于基准元素、等于基准元素和大于基准元素的三个部分，递归地对小于和大于基准元素的数组进行快速排序，最后合并这三个部分。

#### 6. 如何实现归并排序？

**题目：** 实现归并排序算法，输入一个无序数组，输出排序后的数组。

**答案：**

```python
def mergeSort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = mergeSort(arr[:mid])
    right = mergeSort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

arr = [3, 6, 8, 10, 1, 2, 1]
print("Sorted array is:", mergeSort(arr))
```

**解析：** 归并排序是一种分治算法。首先将数组分为两个长度相等的子数组，递归地对每个子数组进行归并排序，然后将两个有序子数组合并为一个有序数组。

#### 7. 如何找出数组中的重复元素？

**题目：** 给定一个整数数组，找出其中重复的元素。

**答案：**

```python
def findDuplicate(nums):
    n = len(nums)
    for i in range(n):
        while nums[i] != i:
            if nums[i] == nums[nums[i]]:
                return nums[i]
            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]

    return -1

nums = [2, 3, 1, 0, 2, 5, 3]
print("Duplicate element is:", findDuplicate(nums))
```

**解析：** 通过交换元素到正确的位置，最终找到一个重复的元素。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 8. 如何找出数组中的最小元素？

**题目：** 给定一个整数数组，找出其中的最小元素。

**答案：**

```python
def findMinimum(nums):
    return min(nums)

nums = [3, 4, 2, 1]
print("Minimum element is:", findMinimum(nums))
```

**解析：** 使用 Python 内置的 min 函数，时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 9. 如何找出数组中的最大元素？

**题目：** 给定一个整数数组，找出其中的最大元素。

**答案：**

```python
def findMaximum(nums):
    return max(nums)

nums = [3, 4, 2, 1]
print("Maximum element is:", findMaximum(nums))
```

**解析：** 使用 Python 内置的 max 函数，时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 10. 如何找出数组中的第二小元素？

**题目：** 给定一个整数数组，找出其中的第二小元素。

**答案：**

```python
def findSecondMinimum(nums):
    min1 = min(nums)
    for num in nums:
        if num > min1:
            return num

    return -1

nums = [2, 1, 2]
print("Second minimum element is:", findSecondMinimum(nums))
```

**解析：** 遍历数组，找到第一个大于最小元素的数，即为第二小元素。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 11. 如何找出数组中的第二大元素？

**题目：** 给定一个整数数组，找出其中的第二大元素。

**答案：**

```python
def findSecondMaximum(nums):
    max1 = max(nums)
    for num in nums:
        if num > max1 and num < max(nums):
            return num

    return -1

nums = [3, 4, 2, 1]
print("Second maximum element is:", findSecondMaximum(nums))
```

**解析：** 遍历数组，找到第一个大于最大元素且小于第二大元素的数，即为第二大元素。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 12. 如何找出数组中的缺失元素？

**题目：** 给定一个整数数组，其中包含 1 到 n 的元素（可能重复），找出缺失的元素。

**答案：**

```python
def findMissing(nums):
    n = len(nums) + 1
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum

nums = [3, 4, 2, 1]
print("Missing element is:", findMissing(nums))
```

**解析：** 利用等差数列求和公式，计算数组中 1 到 n 的元素之和，然后减去实际数组之和，得到缺失的元素。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 13. 如何找出数组中的重复元素？

**题目：** 给定一个整数数组，找出其中的重复元素。

**答案：**

```python
def findDuplicates(nums):
    duplicates = []
    num_set = set()

    for num in nums:
        if num in num_set:
            duplicates.append(num)
        else:
            num_set.add(num)

    return duplicates

nums = [3, 4, 2, 1]
print("Duplicate elements are:", findDuplicates(nums))
```

**解析：** 使用哈希集合存储数组中的元素，遍历数组时，如果元素已存在，则将其添加到重复元素列表中。时间复杂度为 O(n)，空间复杂度为 O(n)。

#### 14. 如何找出数组中的唯一元素？

**题目：** 给定一个整数数组，其中包含 1 到 n 的元素（可能重复），找出其中的唯一元素。

**答案：**

```python
def findUnique(nums):
    unique = []
    num_count = [0] * (len(nums) + 1)

    for num in nums:
        num_count[num] += 1

    for i, count in enumerate(num_count):
        if count == 1:
            unique.append(i)

    return unique

nums = [3, 4, 2, 1]
print("Unique elements are:", findUnique(nums))
```

**解析：** 使用计数数组统计每个元素出现的次数，然后遍历计数数组，找到出现次数为 1 的元素。时间复杂度为 O(n)，空间复杂度为 O(n)。

#### 15. 如何找出数组中的最大子序列和？

**题目：** 给定一个整数数组，找出其中的最大子序列和。

**答案：**

```python
def findMaxSubarraySum(nums):
    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum

nums = [3, 4, -1, 2]
print("Maximum subarray sum is:", findMaxSubarraySum(nums))
```

**解析：** 使用动态规划的方法，遍历数组，更新当前子序列和的最大值。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 16. 如何找出数组中的最小子序列和？

**题目：** 给定一个整数数组，找出其中的最小子序列和。

**答案：**

```python
def findMinSubarraySum(nums):
    min_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = min(num, current_sum + num)
        min_sum = min(min_sum, current_sum)

    return min_sum

nums = [3, 4, -1, 2]
print("Minimum subarray sum is:", findMinSubarraySum(nums))
```

**解析：** 使用动态规划的方法，遍历数组，更新当前子序列和的最小值。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 17. 如何找出数组中的最大元素？

**题目：** 给定一个整数数组，找出其中的最大元素。

**答案：**

```python
def findMaxElement(nums):
    return max(nums)

nums = [3, 4, -1, 2]
print("Maximum element is:", findMaxElement(nums))
```

**解析：** 使用 Python 内置的 max 函数，时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 18. 如何找出数组中的最小元素？

**题目：** 给定一个整数数组，找出其中的最小元素。

**答案：**

```python
def findMinElement(nums):
    return min(nums)

nums = [3, 4, -1, 2]
print("Minimum element is:", findMinElement(nums))
```

**解析：** 使用 Python 内置的 min 函数，时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 19. 如何找出数组中的平均值？

**题目：** 给定一个整数数组，计算其中的平均值。

**答案：**

```python
def findAverage(nums):
    return sum(nums) / len(nums)

nums = [3, 4, -1, 2]
print("Average is:", findAverage(nums))
```

**解析：** 使用求和函数和长度，计算平均值。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 20. 如何找出数组中的众数？

**题目：** 给定一个整数数组，找出其中的众数。

**答案：**

```python
def findMode(nums):
    count = {}
    max_count = 0
    mode = []

    for num in nums:
        count[num] = count.get(num, 0) + 1
        if count[num] > max_count:
            max_count = count[num]
            mode = [num]
        elif count[num] == max_count:
            mode.append(num)

    return mode

nums = [3, 4, -1, 2, 3]
print("Mode is:", findMode(nums))
```

**解析：** 遍历数组，统计每个元素的计数，找到出现次数最多的元素。时间复杂度为 O(n)，空间复杂度为 O(n)。

#### 21. 如何找出数组中的中位数？

**题目：** 给定一个整数数组，找出其中的中位数。

**答案：**

```python
def findMedian(nums):
    nums.sort()
    n = len(nums)
    if n % 2 == 0:
        return (nums[n // 2 - 1] + nums[n // 2]) / 2
    else:
        return nums[n // 2]

nums = [3, 4, -1, 2]
print("Median is:", findMedian(nums))
```

**解析：** 首先将数组排序，然后根据数组长度判断是否为偶数，如果是偶数，则返回中间两个数的平均值；如果是奇数，则返回中间的数。时间复杂度为 O(nlogn)，空间复杂度为 O(1)（不考虑排序的额外空间）。

#### 22. 如何找出数组中的第 k 个最大元素？

**题目：** 给定一个整数数组，找出其中的第 k 个最大元素。

**答案：**

```python
def findKthLargest(nums, k):
    nums.sort()
    return nums[-k]

nums = [3, 4, -1, 2]
print("The kth largest element is:", findKthLargest(nums, 2))
```

**解析：** 首先将数组排序，然后返回数组倒数第 k 个元素。时间复杂度为 O(nlogn)，空间复杂度为 O(1)（不考虑排序的额外空间）。

#### 23. 如何找出数组中的第 k 个最小元素？

**题目：** 给定一个整数数组，找出其中的第 k 个最小元素。

**答案：**

```python
def findKthSmallest(nums, k):
    nums.sort()
    return nums[k - 1]

nums = [3, 4, -1, 2]
print("The kth smallest element is:", findKthSmallest(nums, 2))
```

**解析：** 首先将数组排序，然后返回数组第 k 个元素。时间复杂度为 O(nlogn)，空间复杂度为 O(1)（不考虑排序的额外空间）。

#### 24. 如何找出数组中的第 k 个最大和第 k 个最小元素的平均值？

**题目：** 给定一个整数数组，找出其中的第 k 个最大元素和第 k 个最小元素的平均值。

**答案：**

```python
def findKthAverage(nums, k):
    nums.sort()
    max_element = nums[-k]
    min_element = nums[k - 1]
    return (max_element + min_element) / 2

nums = [3, 4, -1, 2]
print("The average of the kth largest and kth smallest elements is:", findKthAverage(nums, 2))
```

**解析：** 首先将数组排序，然后找到第 k 个最大元素和第 k 个最小元素，计算它们的平均值。时间复杂度为 O(nlogn)，空间复杂度为 O(1)（不考虑排序的额外空间）。

#### 25. 如何找出数组中的众数（包含重复元素）？

**题目：** 给定一个包含重复元素的整数数组，找出其中的众数。

**答案：**

```python
def findMode(nums):
    count = {}
    max_count = 0
    mode = []

    for num in nums:
        count[num] = count.get(num, 0) + 1
        if count[num] > max_count:
            max_count = count[num]
            mode = [num]
        elif count[num] == max_count:
            mode.append(num)

    return mode

nums = [3, 4, -1, 2, 3]
print("Mode is:", findMode(nums))
```

**解析：** 遍历数组，统计每个元素的计数，找到出现次数最多的元素。时间复杂度为 O(n)，空间复杂度为 O(n)。

#### 26. 如何找出数组中的最大子序列和？

**题目：** 给定一个整数数组，找出其中的最大子序列和。

**答案：**

```python
def findMaxSubarraySum(nums):
    max_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum

nums = [3, 4, -1, 2]
print("Maximum subarray sum is:", findMaxSubarraySum(nums))
```

**解析：** 使用动态规划的方法，遍历数组，更新当前子序列和的最大值。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 27. 如何找出数组中的最小子序列和？

**题目：** 给定一个整数数组，找出其中的最小子序列和。

**答案：**

```python
def findMinSubarraySum(nums):
    min_sum = current_sum = nums[0]

    for num in nums[1:]:
        current_sum = min(num, current_sum + num)
        min_sum = min(min_sum, current_sum)

    return min_sum

nums = [3, 4, -1, 2]
print("Minimum subarray sum is:", findMinSubarraySum(nums))
```

**解析：** 使用动态规划的方法，遍历数组，更新当前子序列和的最小值。时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 28. 如何找出数组中的最大元素？

**题目：** 给定一个整数数组，找出其中的最大元素。

**答案：**

```python
def findMaxElement(nums):
    return max(nums)

nums = [3, 4, -1, 2]
print("Maximum element is:", findMaxElement(nums))
```

**解析：** 使用 Python 内置的 max 函数，时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 29. 如何找出数组中的最小元素？

**题目：** 给定一个整数数组，找出其中的最小元素。

**答案：**

```python
def findMinElement(nums):
    return min(nums)

nums = [3, 4, -1, 2]
print("Minimum element is:", findMinElement(nums))
```

**解析：** 使用 Python 内置的 min 函数，时间复杂度为 O(n)，空间复杂度为 O(1)。

#### 30. 如何找出数组中的平均值？

**题目：** 给定一个整数数组，计算其中的平均值。

**答案：**

```python
def findAverage(nums):
    return sum(nums) / len(nums)

nums = [3, 4, -1, 2]
print("Average is:", findAverage(nums))
```

**解析：** 使用求和函数和长度，计算平均值。时间复杂度为 O(n)，空间复杂度为 O(1)。

### 总结

以上题目涵盖了数组中的常见问题，包括找出最大/最小/重复/缺失元素、子序列和、众数、平均值等。每种问题都有多种解法，可以根据实际情况选择合适的方法。需要注意的是，在实现算法时，要考虑时间复杂度和空间复杂度，以便找到最有效的解决方案。

