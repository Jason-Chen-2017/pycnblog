                 

### 2025滴滴社招编程面试题精选与解答：算法编程篇

#### 一、链表问题

##### 1. 合并两个有序链表

**题目：** 将两个有序链表合并为一个有序链表。

**示例：** 输入：`l1 = [1,2,4], l2 = [1,3,4]`，输出：`[1,1,2,3,4,4]`。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 利用递归，依次比较两个链表的当前节点，将较小的节点链接到结果链表上。

##### 2. 删除链表的倒数第 N 个节点

**题目：** 给定一个链表，删除链表的倒数第 N 个节点。

**示例：** 输入：`head = [1,2,3,4,5], N = 2`，输出：`[1,2,3,5]`。

**答案：**

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    fast, slow := dummy, dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

**解析：** 使用快慢指针，快指针移动 N 步后，慢指针开始移动，当快指针到达链表末尾时，慢指针所在位置即为倒数第 N 个节点。

#### 二、树问题

##### 1. 二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树和一个目标值，判断目标值是否在二叉搜索树中。

**示例：** 输入：`root = [4,2,7,1,3], val = 2`，输出：`true`。

**答案：**

```go
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }
    if root.Val < val {
        return searchBST(root.Right, val)
    }
    return searchBST(root.Left, val)
}
```

**解析：** 递归遍历二叉搜索树，当节点值为目标值时返回节点，否则根据二叉搜索树的性质，向左或向右递归搜索。

##### 2. 二叉树的最近公共祖先

**题目：** 给定一个二叉树和一个目标值，找出二叉树中两个节点的最近公共祖先。

**示例：** 输入：`root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1`，输出：`3`。

**答案：**

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}
```

**解析：** 递归遍历二叉树，当当前节点为 p 或 q 时返回当前节点；当左右子节点都不为空时，返回当前节点；否则返回非空子节点的递归结果。

#### 三、图问题

##### 1. 单源最短路径

**题目：** 给定一个加权无向图和源点，求图中每个顶点的最短路径。

**示例：** 输入：`graph = [[2,7,6], [8,5,4], [5,2,8], [9,3,0]], source = 0`，输出：`[0,4,6,7]`。

**答案：**

```go
func dijkstra(graph [][]int, source int) []int {
    dist := make([]int, len(graph))
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[source] = 0
    priorityQueue := &heap.Heap{Items: []*heap.Item{}}
    item := &heap.Item{value: dist[source], key: source}
    priorityQueue.Push(item)
    for priorityQueue.Len() > 0 {
        item = priorityQueue.Pop()
        u := item.key
        for _, v := range graph[u] {
            distance := dist[u] + v
            if distance < dist[v] {
                dist[v] = distance
                item := &heap.Item{value: distance, key: v}
                priorityQueue.Push(item)
            }
        }
    }
    return dist
}
```

**解析：** 使用迪杰斯特拉算法，通过优先队列（小根堆）实现。

##### 2. 图的拓扑排序

**题目：** 给定一个无向图，进行拓扑排序。

**示例：** 输入：`graph = [[5,2], [5,0], [4,0], [4,1], [3,1], [3,2]]`，输出：`[4,5,2,3,0,1]`。

**答案：**

```go
func topologicalSort(graph [][]int) []int {
    n := len(graph)
    indegree := make([]int, n)
    for _, g := range graph {
        for _, v := range g {
            indegree[v]++
        }
    }
    result := make([]int, 0)
    queue := []int{}
    for i, d := range indegree {
        if d == 0 {
            queue = append(queue, i)
        }
    }
    for len(queue) > 0 {
        u := queue[0]
        queue = queue[1:]
        result = append(result, u)
        for _, v := range graph[u] {
            indegree[v]--
            if indegree[v] == 0 {
                queue = append(queue, v)
            }
        }
    }
    return result
}
```

**解析：** 使用 Kahn 算法进行拓扑排序。

#### 四、动态规划

##### 1. 最长上升子序列

**题目：** 给定一个无序数组，找出最长上升子序列的长度。

**示例：** 输入：`nums = [10,9,2,5,3,7,101,18]`，输出：`4`。

**答案：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

**解析：** 使用动态规划，dp[i] 表示以 nums[i] 结尾的最长上升子序列的长度。

##### 2. 0-1 背包问题

**题目：** 给定一个物品重量数组和一个价值数组，以及背包容量，求背包能获得的最大价值。

**示例：** 输入：`weights = [1,2,3], values = [1,6,10], capacity = 5`，输出：`16`。

**答案：**

```go
func knapsack(weights []int, values []int, capacity int) int {
    dp := make([][]int, len(weights)+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }
    for i := 1; i <= len(weights); i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[len(weights)][capacity]
}
```

**解析：** 使用动态规划，dp[i][w] 表示前 i 个物品，在容量为 w 的背包中能获得的最大价值。状态转移方程为：

```
dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
```

当 w >= weights[i-1] 时，考虑第 i 个物品；否则不考虑。

#### 五、高级算法

##### 1. 合并 k 个有序链表

**题目：** 给定 k 个有序链表，合并它们为一个新的有序链表。

**示例：** 输入：`lists = [[1,4,5], [1,3,4], [2,6]]`，输出：`[1,1,2,3,4,4,5,6]`。

**答案：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    for len(lists) > 1 {
        lists = mergeTwoLists(lists[0], lists[1])
        lists = lists[1:]
    }
    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) []*ListNode {
    if l1 == nil {
        return []*ListNode{l2}
    }
    if l2 == nil {
        return []*ListNode{l1}
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return []*ListNode{l1}
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return []*ListNode{l2}
}
```

**解析：** 使用分治思想，每次合并两个链表，直到合并完所有链表。

##### 2. 快速排序

**题目：** 实现快速排序算法。

**示例：** 输入：`arr = [3,2,1]`，输出：`[1,2,3]`。

**答案：**

```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    pivot := arr[len(arr)/2]
    left := []int{}
    middle := []int{}
    right := []int{}
    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }
    return append(quickSort(left), append(middle, quickSort(right...)...)...)
}
```

**解析：** 快速排序的基本思想是通过一趟排序将待排序的记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录继续进行排序，以达到整个序列有序。

### 总结

本文介绍了滴滴社招编程面试题精选与解答中的典型问题，包括链表、树、图、动态规划和高级算法等领域的面试题。通过对这些问题的解析，可以帮助求职者更好地理解和应对面试中的算法编程题目。希望本文对您的面试准备有所帮助！

