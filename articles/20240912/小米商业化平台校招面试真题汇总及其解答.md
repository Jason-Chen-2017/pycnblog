                 

## 2024小米商业化平台校招面试真题汇总及其解答

在2024年的校招季，小米商业化平台发布了多道面试真题，涵盖了算法、编程、逻辑思维等方面，以下是对这些题目的汇总及解答。通过对这些题目的深入解析，希望可以帮助即将面试的同学更好地准备。

### 面试题1：数组中的最大子序和

**题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例：** `nums = [-2,1,-3,4,-1,2,1,-5,4]`，返回 `6`。

**解答思路：** 使用动态规划中的“前缀和”方法。遍历数组，使用两个变量 `max_sum` 和 `cur_sum`，其中 `max_sum` 用于记录历史出现过的最大和，`cur_sum` 用于记录当前连续子数组的和。每遍历到一个元素，判断 `cur_sum + nums[i]` 是否大于 `nums[i]`，如果是，则将 `cur_sum` 更新为 `cur_sum + nums[i]`，否则将 `cur_sum` 重置为 `nums[i]`。同时，更新 `max_sum` 为 `max(max_sum, cur_sum)`。

**代码实现：**

```python
def maxSubArray(nums):
    max_sum = cur_sum = nums[0]
    for i in range(1, len(nums)):
        cur_sum = max(nums[i], cur_sum + nums[i])
        max_sum = max(max_sum, cur_sum)
    return max_sum
```

### 面试题2：旋转图像

**题目描述：** 给定一个二维矩阵 `matrix` ，原地旋转矩阵 90 度，使用顺时针方向旋转。

**示例：** `matrix = [[1,2,3],[4,5,6],[7,8,9]]`，返回 `[[7,4,1],[8,5,2],[9,6,3]]`。

**解答思路：** 分两步进行旋转：
1. 水平翻转矩阵。
2. 沿着主对角线进行翻转。

**代码实现：**

```python
def rotate(matrix):
    n = len(matrix)
    # 水平翻转
    matrix.reverse()
    # 沿主对角线翻转
    for i in range(n):
        for j in range(i, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
```

### 面试题3：合并区间

**题目描述：** 给定一个无序的区间列表，合并所有重叠的区间。

**示例：** `intervals = [[1,3],[2,6],[8,10],[15,18]]`，返回 `[[1,6],[8,10],[15,18]]`。

**解答思路：** 先对区间列表进行排序，然后遍历排序后的区间列表，合并重叠区间。

**代码实现：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    ans = [intervals[0]]
    for interval in intervals[1:]:
        if ans[-1][1] >= interval[0]:
            ans[-1][1] = max(ans[-1][1], interval[1])
        else:
            ans.append(interval)
    return ans
```

### 面试题4：单词搜索

**题目描述：** 给定一个二维字符网格和一个单词，判断该单词是否存在于网格中。

**示例：** `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]; word = "ABCCED"`，返回 `true`。

**解答思路：** 使用深度优先搜索（DFS）在网格中查找单词。

**代码实现：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        board[i][j] = '#'
        for a, b in [[0, 1], [0, -1], [1, 0], [-1, 0]]:
            if dfs(i + a, j + b, k + 1):
                return True
        board[i][j] = word[k]
        return False

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

### 面试题5：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** `strs = ["flower","flow","flight"]`，返回 `"fl"`。

**解答思路：** 从第一个字符串开始，依次与后面的字符串比较，找出它们的公共前缀。

**代码实现：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s) and prefix[i] == s[i]:
            i += 1
        prefix = prefix[:i]
    return prefix
```

### 面试题6：两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target` ，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：** `nums = [2, 7, 11, 15], target = 9`，返回 `[0, 1]`。

**解答思路：** 使用哈希表存储数组中的元素及其索引，遍历数组并检查目标值减去当前元素是否存在于哈希表中。

**代码实现：**

```python
def twoSum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

### 面试题7：爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：** `n = 3`，返回 `3`。

**解答思路：** 使用动态规划，定义 `dp[i]` 为到达第 `i` 阶的方法数。状态转移方程为 `dp[i] = dp[i-1] + dp[i-2]`。

**代码实现：**

```python
def climbStairs(n):
    if n <= 2:
        return n
    dp = [0] * (n + 1)
    dp[1], dp[2] = 1, 2
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

### 面试题8：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**示例：** `nums = [100, 4, 200, 1, 3, 2]`，返回 `4`。

**解答思路：** 使用哈希表记录每个数出现的次数，然后遍历数组，对于每个元素，判断其前一个数和后一个数是否出现，以此判断是否是连续序列的一部分。

**代码实现：**

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    num_set = set(nums)
    max_len = 0
    for num in nums:
        if num - 1 not in num_set:
            current_num = num
            current_len = 1
            while current_num + 1 in num_set:
                current_num += 1
                current_len += 1
            max_len = max(max_len, current_len)
    return max_len
```

### 面试题9：旋转数组的最小数字

**题目描述：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**示例：** `nums = [3,4,5,1,2]`，返回 `1`。

**解答思路：** 使用二分查找法，找到数组中最小的元素。

**代码实现：**

```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]
```

### 面试题10：验证二叉树的前序序列化

**题目描述：** 写一个函数来验证一个给定二叉树序列是否是一个有效的二叉树序列。

**示例：** `tree = [1,2,3,4,5]`，返回 `true`。

**解答思路：** 使用栈模拟二叉树的构建过程，对于每个节点，如果它的左右子树都未构建，则将左右子树的起始节点入栈。

**代码实现：**

```python
class Solution:
    def isValidSerialization(self, preorder: List[str]) -> bool:
        stk = []
        for node in preorder:
            stk.append(node)
            while len(stk) >= 2 and stk[-2] == '(' and stk[-1] == ')':
                stk.pop()
                stk.pop()
                stk.append('(...)')
            stk.append('(...)')
        return stk[-1] == '(...)'
```

### 面试题11：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** `l1 = [1,2,4], l2 = [1,3,4]`，返回 `[1,1,2,3,4,4]`。

**解答思路：** 使用递归或迭代的方法，将两个链表合并。

**代码实现：**

```python
# 递归实现
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

# 迭代实现
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

### 面试题12：回文数

**题目描述：** 判断一个整数是否是回文数。回文数是指正读和反读都一样的整数。

**示例：** `x = -121`，返回 `false`。

**解答思路：** 将整数反转，然后与原整数比较，如果相等则为回文数。

**代码实现：**

```python
def isPalindrome(x):
    if x < 0 or (x % 10 == 0 and x != 0):
        return False
    revertedNumber = 0
    while x > revertedNumber:
        revertedNumber = revertedNumber * 10 + x % 10
        x //= 10
    return x == revertedNumber or x == revertedNumber // 10
```

### 面试题13：两数相加

**题目描述：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且每个节点只存储单个数字。请将这两个数相加，并以相同方式返回一个表示和的链表。

**示例：** `l1 = [2,4,3], l2 = [5,6,4]`，返回 `[7,0,8]`。

**解答思路：** 遍历两个链表，逐位相加，处理进位。

**代码实现：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

### 面试题14：最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**示例：** `text1 = "abcde"，text2 = "ace"`，返回 `3`。

**解答思路：** 使用动态规划，定义 `dp[i][j]` 为 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度。

**代码实现：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

### 面试题15：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：** `strs = ["flower", "flow", "flight"]`，返回 `"fl"`。

**解答思路：** 分而治之，先找出两个字符串的最长公共前缀，再将这个公共前缀与下一个字符串比较，以此类推。

**代码实现：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for i in range(len(strs[0])):
        j = 0
        while j < len(strs[1:]) and i + j < len(strs[0]) and strs[0][i + j] == strs[j + 1][i + j]:
            j += 1
        if j == 0:
            return prefix
        prefix = strs[0][:i + 1]
    return prefix
```

### 面试题16：实现二分查找

**题目描述：** 给定一个 n 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回它的索引，否则返回 `-1`。

**示例：** `nums = [4,5,6,7,0,1,2]，target = 0`，返回 `4`。

**解答思路：** 使用二分查找算法，根据数组的有序性质，每次将中间元素与目标值比较，缩小查找范围。

**代码实现：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 面试题17：删除链表的节点

**题目描述：** 给定单向链表的头指针和一个节点，定义一个函数删除该节点。

**示例：** 单向链表 `1->2->3->4`，删除节点 `3`，返回 `1->2->4`。

**解答思路：** 使用“覆盖法”，将待删除节点的下一个节点的内容复制到待删除节点，然后删除下一个节点。

**代码实现：**

```python
def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

### 面试题18：LRU缓存机制

**题目描述：** 运用你所掌握的数据结构，设计和实现一个 LRU（最近最少使用）缓存机制。

**示例：** 输入 `["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]` `[[], [2, 1], [2, 3], [2], [2, 4], [2], [2, 5], [2], [2], [2]]`，返回 `[null, null, null, 3, null, 5, null, 4, 4, 4]`。

**解答思路：** 使用哈希表加双向链表实现。哈希表用于快速查找节点，双向链表用于快速删除节点。

**代码实现：**

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hash_map = {}
        self.dummy_head = ListNode(0)
        self.dummy_tail = ListNode(0)
        self.dummy_head.next = self.dummy_tail
        self.dummy_tail.next = None

    def get(self, key: int) -> int:
        if key not in self.hash_map:
            return -1
        node = self.hash_map[key]
        self.moveToHead(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.hash_map:
            node = self.hash_map[key]
            node.val = value
            self.moveToHead(node)
        else:
            if len(self.hash_map) == self.capacity:
                del_key = self.dummy_head.next.key
                self.deleteNode(self.dummy_head.next)
            new_node = ListNode(key, value)
            self.hash_map[key] = new_node
            self.appendNode(new_node)

    def moveToHead(self, node):
        self.deleteNode(node)
        self.appendNode(node)

    def appendNode(self, node):
        node.next = self.dummy_head.next
        self.dummy_head.next.prev = node
        self.dummy_head.next = node

    def deleteNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
```

### 面试题19：两数相加

**题目描述：** 给出两个非空 的链表表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且每个节点只存储单个数字。请将这两个数相加，并以相同方式返回一个表示和的链表。

**示例：** `l1 = [2,4,3]，l2 = [5,6,4]`，返回 `[7,0,8]`。

**解答思路：** 遍历两个链表，逐位相加，处理进位。

**代码实现：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

### 面试题20：最接近的三数之和

**题目描述：** 给你一个整数数组 `nums` 和一个目标值 `target`，请你想想如何在该数组中找出和为目标值且距离目标值最近的三个整数。

**示例：** `nums = [-1,2,1,-4]，target = 1`，返回 `[-1,2,1]`。

**解答思路：** 先对数组进行排序，然后使用双指针的方法。

**代码实现：**

```python
def threeSumClosest(nums, target):
    nums.sort()
    closest = nums[0] + nums[1] + nums[2]
    for i in range(len(nums) - 2):
        left, right = i + 1, len(nums) - 1
        while left < right:
            s = nums[i] + nums[left] + nums[right]
            if abs(s - target) < abs(closest - target):
                closest = s
            if s < target:
                left += 1
            elif s > target:
                right -= 1
            else:
                return s
    return closest
```

### 面试题21：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：** `l1 = [1,2,4]，l2 = [1,3,4]`，返回 `[1,1,2,3,4,4]`。

**解答思路：** 使用递归或迭代的方法，将两个链表合并。

**代码实现：**

```python
# 递归实现
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2

# 迭代实现
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next
```

### 面试题22：反转链表

**题目描述：** 反转一个单链表。

**示例：** `head = [1,2,3,4,5]`，返回 `[5,4,3,2,1]`。

**解答思路：** 使用递归或迭代的方法，将链表逐个节点反转。

**代码实现：**

```python
# 递归实现
def reverseList(head):
    if not head or not head.next:
        return head
    p = reverseList(head.next)
    head.next.next = head
    head.next = None
    return p

# 迭代实现
def reverseList(head):
    prev, curr = None, head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

### 面试题23：合并K个排序链表

**题目描述：** 合并 `k` 个排序链表，返回合并后的排序链表。

**示例：** `lists = [[1,4,5]，[1,3,4]，[2,6]]`，返回 `[1,1,2,3,4,4,5,6]`。

**解答思路：** 使用优先队列（小根堆）或者分治算法。

**代码实现：**

```python
import heapq

def mergeKLists(lists):
    if not lists:
        return None
    heap = [(node.val, node) for node in lists if node]
    heapq.heapify(heap)
    head = cur = ListNode(0)
    while heap:
        _, node = heapq.heappop(heap)
        cur.next = node
        cur = cur.next
        if node.next:
            heapq.heappush(heap, (node.next.val, node.next))
    return head.next
```

### 面试题24：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**示例：** `nums = [100, 4, 200, 1, 3, 2]`，返回 `4`。

**解答思路：** 使用哈希表记录每个数出现的次数，然后遍历数组，对于每个元素，判断其前一个数和后一个数是否出现，以此判断是否是连续序列的一部分。

**代码实现：**

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    num_set = set(nums)
    max_len = 0
    for num in nums:
        if num - 1 not in num_set:
            current_num = num
            current_len = 1
            while current_num + 1 in num_set:
                current_num += 1
                current_len += 1
            max_len = max(max_len, current_len)
    return max_len
```

### 面试题25：环形链表

**题目描述：** 给定一个链表，判断链表是否为环形。

**示例：** `head = [3,2,0,-4]，tail connects to node 1`，返回 `true`。

**解答思路：** 使用快慢指针法，快指针每次移动两个节点，慢指针每次移动一个节点，如果快指针追上慢指针，则链表为环形。

**代码实现：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def hasCycle(head: ListNode) -> bool:
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### 面试题26：删除链表的节点

**题目描述：** 给定一个单链表和一个节点，定义一个函数删除该节点。

**示例：** 单向链表 `1->2->3->4`，删除节点 `3`，返回 `1->2->4`。

**解答思路：** 使用“覆盖法”，将待删除节点的下一个节点的内容复制到待删除节点，然后删除下一个节点。

**代码实现：**

```python
def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

### 面试题27：LRU缓存机制

**题目描述：** 运用你所掌握的数据结构，设计和实现一个 `LRU`（最近最少使用）缓存机制。

**示例：** 输入 `["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]` `[[], [2, 1], [2, 3], [2], [2, 4], [2], [2, 5], [2], [2], [2]]`，返回 `[null, null, null, 3, null, 5, null, 4, 4, 4]`。

**解答思路：** 使用哈希表加双向链表实现。哈希表用于快速查找节点，双向链表用于快速删除节点。

**代码实现：**

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hash_map = {}
        self.dummy_head = ListNode(0)
        self.dummy_tail = ListNode(0)
        self.dummy_head.next = self.dummy_tail
        self.dummy_tail.next = None

    def get(self, key: int) -> int:
        if key not in self.hash_map:
            return -1
        node = self.hash_map[key]
        self.moveToHead(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.hash_map:
            node = self.hash_map[key]
            node.val = value
            self.moveToHead(node)
        else:
            if len(self.hash_map) == self.capacity:
                del_key = self.dummy_head.next.key
                self.deleteNode(self.dummy_head.next)
            new_node = ListNode(key, value)
            self.hash_map[key] = new_node
            self.appendNode(new_node)

    def moveToHead(self, node):
        self.deleteNode(node)
        self.appendNode(node)

    def appendNode(self, node):
        node.next = self.dummy_head.next
        self.dummy_head.next.prev = node
        self.dummy_head.next = node

    def deleteNode(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
```

### 面试题28：实现strStr()

**题目描述：** 实现 strStr() 函数。

**示例：** 输入 `haystack = "hello"，needle = "ll"`，返回 `2`。

**解答思路：** 使用暴力匹配或者KMP算法。

**代码实现：**

```python
# 暴力匹配
def strStr(haystack: str, needle: str) -> int:
    L = len(needle)
    R = len(haystack)
    for i in range(R - L + 1):
        if haystack[i:i + L] == needle:
            return i
    return -1

# KMP算法
def strStr(haystack: str, needle: str) -> int:
    def get部分匹配表(s):
        n = len(s)
        p = [0] * n
        j = 0
        i = 1
        while i < n:
            if s[i] == s[j]:
                j += 1
                p[i] = j
                i += 1
            elif j > 0:
                j = p[j - 1]
            else:
                i += 1
        return p

    p = get部分匹配表(needle)
    L = len(needle)
    R = len(haystack)
    j = 0
    for i in range(R):
        if j < L and haystack[i] == needle[j]:
            j += 1
        if j == L:
            return i - j + 1
        elif j > 0:
            j = p[j - 1]
    return -1
```

### 面试题29：两数相加

**题目描述：** 给出两个非空 的链表表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且每个节点只存储单个数字。请将这两个数相加，并以相同方式返回一个表示和的链表。

**示例：** `l1 = [2,4,3]，l2 = [5,6,4]`，返回 `[7,0,8]`。

**解答思路：** 遍历两个链表，逐位相加，处理进位。

**代码实现：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    return dummy.next
```

### 面试题30：最长上升子序列

**题目描述：** 给定一个无序的整数数组，返回它的最长上升子序列的长度。

**示例：** `nums = [10,9,2,5,3,7,101,18]`，返回 `4`。

**解答思路：** 动态规划。定义 `dp[i]` 为以 `nums[i]` 结尾的最长上升子序列的长度。

**代码实现：**

```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

### 面试题31：下一个排列

**题目描述：** 实现获取一个整数（32位有符号整数）的下一个排列的函数。

**示例：** `num = 123`，返回 `132`。

**解答思路：** 从后往前找到第一个下降的数字，然后交换这个数字和后面的第一个上升的数字，最后将后面的数字排序。

**代码实现：**

```python
def nextPermutation(num):
    num = list(num)
    i = len(num) - 2
    while i >= 0 and num[i] >= num[i + 1]:
        i -= 1
    if i >= 0:
        j = len(num) - 1
        while j > i and num[j] <= num[i]:
            j -= 1
        num[i], num[j] = num[j], num[i]
    i += 1
    num[i:] = reversed(num[i:])
    return int(''.join(num))
```

### 面试题32：最长有效括号

**题目描述：** 给定一个字符串 `s` ，找出其中不含有重复字符的 最长连续子字符串 的长度。

**示例：** `s = "bbbbb"`，返回 `1`。

**解答思路：** 使用哈希表记录当前字符的最新出现位置，遍历字符串，更新当前最大长度。

**代码实现：**

```python
def longestSubstring(s):
    max_len = left = 0
    last_pos = {}
    for i, c in enumerate(s):
        if c in last_pos and left <= last_pos[c]:
            left = last_pos[c] + 1
        last_pos[c] = i
        max_len = max(max_len, i - left + 1)
    return max_len
```

### 面试题33：搜索旋转排序数组

**题目描述：** 搜索一个旋转排序的数组。

**示例：** `nums = [4,5,6,7,0,1,2]`，`target = 0`，返回 `4`。

**解答思路：** 使用二分查找，判断中间元素是否为目标值，或者判断哪一半是有序的。

**代码实现：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] >= nums[left]:
            if target >= nums[left] and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if target > nums[mid] and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

### 面试题34：在排序数组中查找元素的第一个和最后一个位置

**题目描述：** 给定一个已经排序好的数组和一个目标值，找到数组中的第一个和最后一个目标的索引。

**示例：** `nums = [5,7,7,8,8,10]，target = 8`，返回 `[3,4]`。

**解答思路：** 使用二分查找，分别找到目标值的最小和最大索引。

**代码实现：**

```python
def searchRange(nums, target):
    left = binarySearch(nums, target, True)
    right = binarySearch(nums, target, False) - 1
    if left == len(nums) or nums[left] != target:
        return [-1, -1]
    return [left, right]

def binarySearch(nums, target, lower):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] > target or (lower and nums[mid] == target):
            right = mid - 1
        else:
            left = mid + 1
    return left if lower else right
```

### 面试题35：搜索插入位置

**题目描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**示例：** `nums = [1,3,5,6]，target = 5`，返回 `2`。

**解答思路：** 使用二分查找，找到目标值的位置或者目标值应该插入的位置。

**代码实现：**

```python
def searchInsert(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            return mid
    return left
```

### 面试题36：验证二叉搜索树

**题目描述：** 给定一个二叉树，判断其是否为有效的二叉搜索树。

**示例：** `root = [5,1,4,null,null,3,6]`，返回 `true`。

**解答思路：** 遍历二叉树，验证每个节点的值是否在其左子树的最大值和右子树的最小值之间。

**代码实现：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBST(root):
    def helper(node, lower, upper):
        if node is None:
            return True
        val = node.val
        if val <= lower or val >= upper:
            return False
        if not helper(node.right, val, upper):
            return False
        if not helper(node.left, lower, val):
            return False
        return True

    return helper(root, float('-inf'), float('inf'))
```

### 面试题37：序列化与反序列化二叉树

**题目描述：** 请实现两个函数，分别用来序列化和反序列化二叉树。

**示例：** `root = [1,2,3,null,null,4,5]`，返回 `[1,2,3,null,null,4,5]`。

**解答思路：** 使用前序遍历序列化，使用递归反序列化。

**代码实现：**

```python
class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string."""
        if not root:
            return '[]'
        return f'[{root.val},{self.serialize(root.left)},{self.serialize(root.right)}]'

    def deserialize(self, data):
        """Decodes your encoded data to tree."""
        def helper(data_list):
            if data_list[0] == '[]':
                return None, data_list[1:]
            val = data_list.pop(0)
            if val == 'None':
                root = None
            else:
                root = TreeNode(int(val))
                root.left, data_list = helper(data_list)
                root.right, data_list = helper(data_list)
            return root, data_list

        root, data_list = helper(data.split(']['))
        return root
```

### 面试题38：字符串的排列

**题目描述：** 输入一个字符串，打印出该字符串中字符的所有排列。

**示例：** 输入 `s = "abc"`，返回 `[["abc", "acb", "bac", "bca", "cab", "cba"]`。

**解答思路：** 使用回溯法，遍历字符串的每个字符，将其与前面的字符进行交换，然后递归处理剩余的字符。

**代码实现：**

```python
def permutation(s):
    def dfs(path, used):
        if len(path) == len(s):
            ans.append(''.join(path))
            return
        for i in range(len(s)):
            if used[i] or (i > 0 and s[i] == s[i - 1] and not used[i - 1]):
                continue
            used[i] = True
            path.append(s[i])
            dfs(path, used)
            path.pop()
            used[i] = False

    ans = []
    s = ''.join(sorted(s))
    used = [False] * len(s)
    dfs([], used)
    return ans
```

### 面试题39：数组中出现次数超过一半的数字

**题目描述：** 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

**示例：** `nums = [1,2,3,2,2,2,5,4,2]`，返回 `2`。

**解答思路：** 使用摩尔投票法，时间复杂度为O(n)。

**代码实现：**

```python
def majorityElement(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate
```

### 面试题40：最小递增序列

**题目描述：** 给你一个整数数组 `nums`，请你将该数组升序排列。

**示例：** `nums = [3,2,1,5]`，返回 `[1,2,3,5]`。

**解答思路：** 使用贪心算法，每次选择当前最小的不在最终序列中的数。

**代码实现：**

```python
def minNumber(nums):
    nums = ['0'] + nums
    for i in range(1, len(nums)):
        for j in range(len(nums) - 1, 0, -1):
            if nums[j-1] != '0' and nums[j] != '0' and nums[j-1] > nums[j]:
                nums[j-1], nums[j] = nums[j], nums[j-1]
                break
    return ''.join(nums[1:])
```

### 面试题41：数据流中的中位数

**题目描述：** 设计一个算法来找出中位数。中位数是有序数组中间的那个数，如果数组长度是偶数，则不存在中间那个数，中位数是中间两个数的平均数。

**示例：** `nums = [1, 2]`，返回 `1.5`。

**解答思路：** 使用两个堆，一个最大堆存放左侧元素，一个最小堆存放右侧元素，中位数由两个堆顶元素计算得到。

**代码实现：**

```python
import heapq

class MedianFinder:
    def __init__(self):
        self.max_heap = []
        self.min_heap = []

    def addNum(self, num: int) -> None:
        heapq.heappush(self.min_heap, -num)
        heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
        if len(self.max_heap) < len(self.min_heap):
            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))

    def findMedian(self) -> float:
        if len(self.max_heap) == len(self.min_heap):
            return (self.max_heap[0] - self.min_heap[0]) / 2
        else:
            return float(self.min_heap[0])
```

### 面试题42：接雨水

**题目描述：** 给定 `n` 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例：** `height = [0,1,0,2,1,0,1,3,2,1,2,1]`，返回 `6`。

**解答思路：** 遍历数组，对于每个位置，找出左侧最高和右侧最高，取两者的最小值，然后用当前位置的高度减去这个最小值。

**代码实现：**

```python
def trap(height):
    ans = left_max = right_max = 0
    for i, h in enumerate(height):
        left_max = max(left_max, h)
        right_max = max(right_max, height[-i - 1])
        ans += min(left_max, right_max) - h
    return ans
```

### 面试题43：等概率抽卡

**题目描述：** 设计一个随机数生成器，每次调用 `next()` 可以等概率地返回 `[1, n]` 区间内的任意整数。

**示例：** 输入 `n = 4`，返回 `[1, 4]`。

**解答思路：** 使用取模运算，将大范围的数字缩小到 `[1, n]` 范围内。

**代码实现：**

```python
import random

def next(n):
    return random.randint(1, n)
```

### 面试题44：最小路径和

**题目描述：** 给定一个包含非负整数的 `m x n` 网格，每一步可以向左、右、上、下移动。返回到达左下角的最小路径和。

**示例：** `grid = [[1,3,1]，[1，5，1]，[4，2，1]]`，返回 `7`。

**解答思路：** 动态规划，定义 `dp[i][j]` 为到达 `(i, j)` 的最小路径和。

**代码实现：**

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    for i in range(1, m):
        grid[i][0] += grid[i - 1][0]
    for j in range(1, n):
        grid[0][j] += grid[0][j - 1]
    for i in range(1, m):
        for j in range(1, n):
            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    return grid[-1][-1]
```

### 面试题45：填充每个节点的下一个右侧节点指针

**题目描述：** 给定一个完美二叉树，每个节点都有一个 `next` 指针指向其右下方的节点（即 `next` 指向下一个右侧节点，而右侧节点也具有相同的 `next` 指针）。

**示例：** 输入树 `[1,2,3,4,5,6,7]`，返回树 `[1 --> 2 --> 3]，` `[4 --> 5 --> 6]，` `[7 --> null --> null]`。

**解答思路：** 层次遍历，每次将当前层的节点链接到下一层。

**代码实现：**

```python
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

def connect(root):
    if not root:
        return None
    queue = [root]
    while queue:
        prev = None
        for _ in range(len(queue)):
            node = queue.pop(0)
            if prev:
                prev.next = node
            prev = node
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    return root
```

### 面试题46：全排列

**题目描述：** 给定一个没有重复数字的整数数组 `nums` ，返回该数组所有可能的排列。

**示例：** `nums = [1，2，3]`，返回 `[[1，2，3]，[1，3，2]，[2，1，3]，[2，3，1]，[3，1，2]，[3，2，1]]`。

**解答思路：** 使用回溯法，遍历数组每个数字，将其与前面的数字进行交换，然后递归处理剩余的数字。

**代码实现：**

```python
def permute(nums):
    def dfs(path, used):
        if len(path) == len(nums):
            ans.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            dfs(path, used)
            path.pop()
            used[i] = False

    ans = []
    used = [False] * len(nums)
    dfs([], used)
    return ans
```

### 面试题47：最小生成树

**题目描述：** 给定一个无向图的边集合，求出最小生成树。

**示例：** 边集合为 `[([0，1]，2)，([0，2]，3)，([1，2]，1)]`，最小生成树的权重总和为 `4`。

**解答思路：** 使用Prim算法或Kruskal算法。

**代码实现：**

```python
# Prim算法
def prim(edges, n):
    tree = []
    visited = [False] * n
    while len(tree) < n - 1:
        min_edge = float('inf')
        u, v, w = -1, -1, -1
        for i in range(n):
            if not visited[i]:
                for edge in edges:
                    if edge[0] == i and not visited[edge[1]]:
                        if edge[2] < min_edge:
                            min_edge = edge[2]
                            u, v, w = i, edge[1], edge[2]
        visited[u] = visited[v] = True
        tree.append((u, v, w))
    return tree

# Kruskal算法
def kruskal(edges):
    tree = []
    union = UnionFind(len(edges))
    edges.sort(key=lambda x: x[2])
    for edge in edges:
        u, v, w = edge
        if not union.isConnected(u, v):
            tree.append(edge)
            union.union(u, v)
    return tree
```

### 面试题48：单词搜索

**题目描述：** 给定一个二维网格和一个单词，判断单词是否存在于网格中。

**示例：** `board = [["A"，"B"，"C"，"E"]，["S"，"F"，"C"，"S"]，["A"，"D"，"E"，"E"]]; word = "ABCCED"`，返回 `true`。

**解答思路：** 使用深度优先搜索，从网格的每个位置开始搜索。

**代码实现：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        board[i][j] = '#'
        for a, b in [[0，1]，[0，-1]，[1，0]，[-1，0]]:
            if dfs(i + a, j + b, k + 1):
                return True
        board[i][j] = word[k]
        return False

    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False
```

### 面试题49：填充每个节点的下一个右侧节点指针

**题目描述：** 给定一个完美二叉树，每个节点都有一个 `next` 指针指向其右下方的节点（即 `next` 指向下一个右侧节点，而右侧节点也具有相同的 `next` 指针）。

**示例：** 输入树 `[1，2，3，4，5，6，7]`，返回树 `[1 --> 2 --> 3]，[4 --> 5 --> 6]，[7 --> null --> null]`。

**解答思路：** 层次遍历，每次将当前层的节点链接到下一层。

**代码实现：**

```python
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next

def connect(root):
    if not root:
        return None
    queue = [root]
    while queue:
        prev = None
        for _ in range(len(queue)):
            node = queue.pop(0)
            if prev:
                prev.next = node
            prev = node
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
    return root
```

### 面试题50：全排列

**题目描述：** 给定一个没有重复数字的整数数组 `nums` ，返回该数组所有可能的排列。

**示例：** `nums = [1，2，3]`，返回 `[[1，2，3]，[1，3，2]，[2，1，3]，[2，3，1]，[3，1，2]，[3，2，1]]`。

**解答思路：** 使用回溯法，遍历数组每个数字，将其与前面的数字进行交换，然后递归处理剩余的数字。

**代码实现：**

```python
def permute(nums):
    def dfs(path, used):
        if len(path) == len(nums):
            ans.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            dfs(path, used)
            path.pop()
            used[i] = False

    ans = []
    used = [False] * len(nums)
    dfs([], used)
    return ans
```

### 总结

通过以上对小米商业化平台校招面试真题的解析，我们可以看到，面试题涵盖了算法、数据结构、编程逻辑等多个方面。每一道题都有其独特的解法和思路，需要我们仔细分析和理解。这些题目不仅考察了我们的编程能力，还考察了我们的逻辑思维和解决问题的能力。

在准备面试时，我们需要：

1. **熟悉基本算法和数据结构**：这是解决算法题的基础。
2. **掌握常见的面试题解法**：了解每种题型的常见解法，比如回溯法、动态规划、贪心算法等。
3. **练习代码实现**：通过实际编写代码，加深对算法的理解和记忆。
4. **注意边界条件**：面试题往往考查我们处理边界情况的能力。
5. **优化代码**：在保证正确性的前提下，尽量优化代码的性能。

希望这些解析和代码实例能够帮助你在面试中取得好成绩！祝你好运！

