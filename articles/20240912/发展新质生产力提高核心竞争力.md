                 

### ã€Šå‘å±•æ–°è´¨ç”Ÿäº§åŠ›ï¼Œæé«˜æ ¸å¿ƒç«äº‰åŠ›ã€‹ä¸»é¢˜è§£æï¼šé¢è¯•é¢˜ä¸ç®—æ³•ç¼–ç¨‹é¢˜é›†é”¦

éšç€ç§‘æŠ€æ—¥æ–°æœˆå¼‚ï¼Œä¼ä¸šå‘å±•æ–°è´¨ç”Ÿäº§åŠ›ï¼Œæé«˜æ ¸å¿ƒç«äº‰åŠ›å·²æˆä¸ºå½“åŠ¡ä¹‹æ€¥ã€‚æœ¬æ–‡æ—¨åœ¨æ¢è®¨è¿™ä¸€ä¸»é¢˜ä¸‹çš„ä¸€äº›å…¸å‹é¢è¯•é¢˜å’Œç®—æ³•ç¼–ç¨‹é¢˜ï¼Œå¸®åŠ©è¯»è€…æ·±å…¥äº†è§£ç›¸å…³é¢†åŸŸçš„æŠ€æœ¯å’Œåº”ç”¨ã€‚

#### é¢è¯•é¢˜ä¸€ï¼šå¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜å¹¶å‘çš„ç¼“å­˜ç³»ç»Ÿï¼Ÿ

**é¢˜ç›®ï¼š** è¯·è®¾è®¡ä¸€ä¸ªé«˜å¹¶å‘çš„ç¼“å­˜ç³»ç»Ÿï¼Œæ”¯æŒå¸¸è§çš„ç¼“å­˜æ“ä½œï¼ˆå¦‚è·å–ã€è®¾ç½®ã€åˆ é™¤ç­‰ï¼‰ï¼Œå¹¶ç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’Œé«˜æ€§èƒ½ã€‚

**ç­”æ¡ˆè§£æï¼š**

1. **ç¼“å­˜æ•°æ®ç»“æ„ï¼š** ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨ç¼“å­˜æ•°æ®ï¼Œä»¥å®ç° O(1) çš„æŸ¥è¯¢æ—¶é—´ã€‚

2. **å¹¶å‘æ§åˆ¶ï¼š** åˆ©ç”¨äº’æ–¥é”ï¼ˆMutexï¼‰æˆ–è¯»å†™é”ï¼ˆRWMutexï¼‰ä¿æŠ¤ç¼“å­˜æ•°æ®ï¼Œç¡®ä¿å¹¶å‘è®¿é—®çš„å®‰å…¨æ€§ã€‚

3. **è¿‡æœŸç­–ç•¥ï¼š** ä½¿ç”¨å®šæ—¶å™¨æˆ–è¿‡æœŸæ—¶é—´æˆ³æ¥å¤„ç†ç¼“å­˜æ•°æ®çš„è¿‡æœŸï¼Œå®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®ã€‚

4. **æ•°æ®ä¸€è‡´æ€§ï¼š** åœ¨ç¼“å­˜å’Œåç«¯æ•°æ®æºä¹‹é—´å®ç°åŒå†™ä¸€è‡´æ€§ï¼Œç¡®ä¿ç¼“å­˜æ›´æ–°ä¸åç«¯æ•°æ®åŒæ­¥ã€‚

5. **ç¼“å­˜æ·˜æ±°ç­–ç•¥ï¼š** é‡‡ç”¨ LRUï¼ˆLeast Recently Usedï¼‰ç¼“å­˜æ·˜æ±°ç­–ç•¥ï¼Œä¼˜å…ˆæ·˜æ±°æœ€è¿‘æœªä½¿ç”¨çš„æ•°æ®ã€‚

**ç¤ºä¾‹ä»£ç ï¼š**

```go
type Cache struct {
    mu     sync.RWMutex
    cache  map[string]*entry
    capacity int
}

// entry represents a cache entry
type entry struct {
    value    interface{}
    expiration int64
}

func NewCache(capacity int) *Cache {
    return &Cache{
        cache:  make(map[string]*entry),
        capacity: capacity,
    }
}

func (c *Cache) Get(key string) (value interface{}, exists bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    if e, exists := c.cache[key]; exists {
        return e.value, true
    }
    return nil, false
}

func (c *Cache) Set(key string, value interface{}, expiration int64) {
    c.mu.Lock()
    defer c.mu.Unlock()
    if len(c.cache) >= c.capacity {
        // å®ç°ç¼“å­˜æ·˜æ±°ç­–ç•¥
    }
    c.cache[key] = &entry{
        value:    value,
        expiration: expiration,
    }
}

func (c *Cache) Delete(key string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    delete(c.cache, key)
}

// å®šæ—¶æ¸…ç†è¿‡æœŸæ•°æ®
func (c *Cache) Cleanup() {
    c.mu.Lock()
    defer c.mu.Unlock()
    for key, e := range c.cache {
        if e.expiration < time.Now().UnixNano() {
            delete(c.cache, key)
        }
    }
}
```

#### é¢è¯•é¢˜äºŒï¼šå¦‚ä½•å®ç°ä¸€ä¸ªç®€å•çš„åˆ†å¸ƒå¼é”ï¼Ÿ

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªç®€å•çš„åˆ†å¸ƒå¼é”ï¼Œæ”¯æŒå¤šä¸ªèŠ‚ç‚¹é—´çš„äº’æ–¥è®¿é—®ã€‚

**ç­”æ¡ˆè§£æï¼š**

1. **åˆ†å¸ƒå¼é”åè®®ï¼š** ä½¿ç”¨ç‰ˆæœ¬å·æˆ–æ—¶é—´æˆ³å®ç°åˆ†å¸ƒå¼é”ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹èƒ½å¤ŸæŒæœ‰é”ã€‚

2. **æ•°æ®ä¸€è‡´æ€§ï¼š** åˆ©ç”¨åˆ†å¸ƒå¼æ•°æ®å­˜å‚¨ï¼ˆå¦‚ Redisã€ZooKeeperï¼‰æ¥ä¿å­˜é”çŠ¶æ€ï¼Œç¡®ä¿å¤šä¸ªèŠ‚ç‚¹é—´çš„ä¸€è‡´æ€§ã€‚

3. **é”è¶…æ—¶ï¼š** ä¸ºåˆ†å¸ƒå¼é”è®¾ç½®è¶…æ—¶æ—¶é—´ï¼Œé¿å…æ°¸ä¹…é˜»å¡ã€‚

4. **é”é‡å…¥ï¼š** å…è®¸åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨æŒæœ‰é”çš„æƒ…å†µä¸‹å¤šæ¬¡è·å–é”ã€‚

**ç¤ºä¾‹ä»£ç ï¼š**

```go
// Redis åˆ†å¸ƒå¼é”
func acquireLock(redisClient *redis.Client, lockKey string, lockValue string, expireTime int) (bool, error) {
    err := redisClient.SetNX(lockKey, lockValue, time.Duration(expireTime)*time.Second).Err()
    if err != nil {
        return false, err
    }
    return true, nil
}

func releaseLock(redisClient *redis.Client, lockKey string, lockValue string) error {
    script := `
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    `
    _, err := redisClient.Eval(script, []string{lockKey}, lockValue).Result()
    return err
}
```

#### ç®—æ³•ç¼–ç¨‹é¢˜ä¸€ï¼šæœ€çŸ­å­æ•°ç»„æ»¡è¶³å’Œè‡³å°‘ K

**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ªæ•´æ•° `k`ï¼Œæ‰¾åˆ°è¯¥æ•°ç»„ä¸­æœ€çŸ­çš„ä¸€ä¸ªéç©ºå­æ•°ç»„ï¼Œä½¿å…¶å’Œè‡³å°‘ä¸º `k`ã€‚è¿”å›è¯¥å­æ•°ç»„çš„é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„å­æ•°ç»„ï¼Œè¿”å› `-1`ã€‚

**ç­”æ¡ˆè§£æï¼š**

1. **åŒæŒ‡é’ˆæ»‘åŠ¨çª—å£ï¼š** ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ `left` å’Œ `right`ï¼Œç»´æŠ¤ä¸€ä¸ªæ»‘åŠ¨çª—å£ã€‚å½“çª—å£å’Œå°äº `k` æ—¶ï¼Œå‘å³ç§»åŠ¨ `right` æŒ‡é’ˆï¼›å½“çª—å£å’Œå¤§äºç­‰äº `k` æ—¶ï¼Œæ›´æ–°æœ€å°çª—å£é•¿åº¦ï¼Œå¹¶å‘å³ç§»åŠ¨ `left` æŒ‡é’ˆã€‚

2. **å‰ç¼€å’Œï¼š** ä½¿ç”¨å‰ç¼€å’Œæ•°ç»„ `prefixSum`ï¼Œå¯ä»¥å¿«é€Ÿè®¡ç®—çª—å£å’Œã€‚

**ç¤ºä¾‹ä»£ç ï¼š**

```go
func shortestSubarray(nums []int, k int) int {
    n := len(nums)
    prefixSum := make([]int, n+1)
    for i := 0; i < n; i++ {
        prefixSum[i+1] = prefixSum[i] + nums[i]
    }
    left, right := 0, 0
    minLen := n + 1
    while right < n {
        while prefixSum[right+1]-prefixSum[left] < k {
            left++
        }
        minLen = min(minLen, right-left+1)
        right++
    }
    if minLen > n {
        return -1
    }
    return minLen
}
```

#### ç®—æ³•ç¼–ç¨‹é¢˜äºŒï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒä¸­åºéå†çš„åç¼€è¡¨è¾¾å¼æ ‘

**é¢˜ç›®ï¼š** è®¾è®¡ä¸€ä¸ªæ”¯æŒä¸­åºéå†çš„åç¼€è¡¨è¾¾å¼æ ‘ï¼Œèƒ½å¤Ÿè®¡ç®—å¹¶è¿”å›è¡¨è¾¾å¼çš„ç»“æœã€‚åç¼€è¡¨è¾¾å¼ï¼ˆé€†æ³¢å…°è¡¨è¾¾å¼ï¼‰æ˜¯ä¸€ç§å°†æ“ä½œç¬¦æ”¾åœ¨æ“ä½œæ•°ä¹‹åçš„è¡¨è¾¾å¼ï¼Œå¦‚ `(3+4)*5` å¯ä»¥è¡¨ç¤ºä¸º `3 4 + 5 *`ã€‚

**ç­”æ¡ˆè§£æï¼š**

1. **åç¼€è¡¨è¾¾å¼æ ‘ï¼š** ä½¿ç”¨é€’å½’çš„æ–¹å¼æ„å»ºåç¼€è¡¨è¾¾å¼æ ‘ã€‚æ¯ä¸ªèŠ‚ç‚¹å¯ä»¥æ˜¯æ“ä½œæ•°æˆ–æ“ä½œç¬¦ã€‚

2. **ä¸­åºéå†ï¼š** ä¸­åºéå†åç¼€è¡¨è¾¾å¼æ ‘ï¼Œè®¡ç®—å¹¶è¿”å›ç»“æœã€‚

3. **è®¡ç®—ç»“æœï¼š** å¯¹åç¼€è¡¨è¾¾å¼æ ‘è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œæ ¹æ®æ“ä½œç¬¦å’Œæ“ä½œæ•°è®¡ç®—ç»“æœã€‚

**ç¤ºä¾‹ä»£ç ï¼š**

```go
type TreeNode struct {
    Val    interface{}
    Left   *TreeNode
    Right  *TreeNode
}

func buildTree(infix string) *TreeNode {
    // çœç•¥æ„å»ºåç¼€è¡¨è¾¾å¼æ ‘çš„è¿‡ç¨‹
    // å‡è®¾å·²ç»æˆåŠŸæ„å»ºäº†åç¼€è¡¨è¾¾å¼æ ‘
    return root
}

func inorderTraversal(root *TreeNode) []int {
    var result []int
    var stack []*TreeNode
    cur := root
    for cur != nil || len(stack) > 0 {
        if cur != nil {
            stack = append(stack, cur)
            cur = cur.Left
        } else {
            cur = stack[len(stack)-1]
            result = append(result, cur.Val.(int))
            cur = cur.Right
            stack = stack[:len(stack)-1]
        }
    }
    return result
}

func evaluateTree(root *TreeNode) int {
    var stack []int
    for _, v := range inorderTraversal(root) {
        if _, ok := v.(int); ok {
            stack = append(stack, v.(int))
        } else {
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            switch v {
            case '+':
                stack = append(stack, a+b)
            case '-':
                stack = append(stack, a-b)
            case '*':
                stack = append(stack, a*b)
            case '/':
                stack = append(stack, a/b)
            }
        }
    }
    return stack[0]
}
```

### æ€»ç»“

æœ¬æ–‡ä»é¢è¯•é¢˜å’Œç®—æ³•ç¼–ç¨‹é¢˜çš„è§’åº¦ï¼Œæ¢è®¨äº†ã€Šå‘å±•æ–°è´¨ç”Ÿäº§åŠ›ï¼Œæé«˜æ ¸å¿ƒç«äº‰åŠ›ã€‹ä¸»é¢˜ä¸‹çš„ç›¸å…³é—®é¢˜ã€‚é€šè¿‡è¿™äº›ç¤ºä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¦‚ä½•è¿ç”¨æŠ€æœ¯æ‰‹æ®µæ¥åº”å¯¹å®é™…ä¸šåŠ¡éœ€æ±‚ï¼Œæé«˜ä¼ä¸šçš„æ ¸å¿ƒç«äº‰åŠ›ã€‚å¸Œæœ›æœ¬æ–‡èƒ½å¯¹è¯»è€…åœ¨é¢è¯•å’Œå®é™…å·¥ä½œä¸­æœ‰æ‰€å¸®åŠ©ã€‚å¦‚æœæ‚¨æœ‰å…¶ä»–ç›¸å…³é—®é¢˜æˆ–éœ€æ±‚ï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºç•™è¨€ï¼Œæˆ‘ä»¬å°†æŒç»­ä¸ºæ‚¨è§£ç­”ã€‚ğŸ‰ğŸ‰ğŸ‰

