                 

### 小米2024校招面试真题与算法题解

#### 1. 判断二叉树是否对称

**题目描述：** 给定一个二叉树，判断它是否对称。

**示例：**
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

**答案解析：**

首先，我们可以采用递归的方法来判断二叉树是否对称。对于任意一个节点，我们需要比较它的左子节点与右子节点是否对称。具体步骤如下：

1. 如果两个子节点都为 `null`，则它们对称；
2. 如果两个子节点只有一个为 `null`，则它们不对称；
3. 如果两个子节点的值不相等，则它们不对称；
4. 递归比较左子节点的左子节点与右子节点的右子节点，以及左子节点的右子节点与右子节点的左子节点。

以下是 Python 代码实现：

```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def is_mirror(t1, t2):
            if t1 is None and t2 is None:
                return True
            if t1 is None or t2 is None:
                return False
            if t1.val != t2.val:
                return False
            return is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left)

        return is_mirror(root.left, root.right)
```

**解析：** 通过递归比较左右子节点的对称性，我们可以判断二叉树是否对称。

#### 2. 合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

我们可以采用迭代的方式合并两个有序链表。首先，创建一个新的虚拟头节点作为合并后的链表的头节点。然后，遍历两个链表，每次取较小值的节点添加到新链表中。以下是 Python 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 通过迭代的方式，我们可以将两个有序链表合并为一个有序链表。

#### 3. 搜索旋转排序数组

**题目描述：** 搜索一个排序数组中的一个目标值，该数组已经进行了旋转。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**答案解析：**

我们可以使用二分查找的方法来解决这个问题。首先，找到数组的中间元素，然后比较中间元素与目标值的关系。如果中间元素等于目标值，则直接返回索引。如果中间元素小于目标值，则说明目标值可能在右半部分，否则可能在左半部分。以下是 Python 代码实现：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[left]:
                if target >= nums[left] and target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

**解析：** 通过二分查找的方法，我们可以快速找到目标值在旋转排序数组中的索引。

#### 4. 两数相加

**题目描述：** 给出两个非空链表表示两个非负的整数，每个节点包含一个数字，请计算它们表示的数字之和，并以链表形式返回结果。

**示例：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,7]
```

**答案解析：**

我们可以采用逆序遍历两个链表，逐位相加的方法。具体步骤如下：

1. 创建一个新的虚拟头节点作为结果链表的头节点；
2. 遍历两个链表，每次计算当前节点的和，并更新进位；
3. 如果当前节点的和大于等于10，则将和的个位数添加到结果链表中，并将十位数作为进位；
4. 如果当前节点的和小于10，则将和的个位数添加到结果链表中，进位为0；
5. 遍历结束后，如果进位不为0，则将进位添加到结果链表中。

以下是 Python 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

**解析：** 通过逆序遍历两个链表，我们可以计算两个数相加的结果并以链表形式返回。

#### 5. 有效的括号

**题目描述：** 给定一个字符串，判断字符串是否是有效的括号字符串。

**示例：**
```
输入："()"
输出：true
```

**答案解析：**

我们可以使用栈来解决这个问题。遍历字符串，对于每个字符：

1. 如果是左括号，则将其入栈；
2. 如果是右括号，则需要判断栈顶元素是否是与之匹配的左括号，如果是，则出栈，否则返回 false；
3. 遍历结束后，如果栈为空，则返回 true，否则返回 false。

以下是 Python 代码实现：

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        brackets = {')': '(', ']': '[', '}': '{'}
        for c in s:
            if c in brackets.values():
                stack.append(c)
            elif c in brackets and stack and stack[-1] == brackets[c]:
                stack.pop()
            else:
                return False
        return not stack
```

**解析：** 通过栈，我们可以判断字符串是否是有效的括号字符串。

#### 6. Z 字形变换

**题目描述：** 将一个给定字符串根据给定的行数，以从上到下、从左到右的顺序进行 Z 字形排列。

**示例：**
```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**答案解析：**

我们可以使用一个二维数组来存储 Z 字形排列的结果。遍历字符串，根据行数将字符存储到对应的行中。具体步骤如下：

1. 创建一个二维数组，大小为 `numRows` 行，初始化所有元素为空字符串；
2. 遍历字符串，根据当前行数将字符添加到对应的行中；
3. 如果当前行数等于 `numRows - 1` 或下一行数与当前行数相等，则反向遍历当前行，将字符添加到行末；
4. 将所有行的字符连接起来，作为最终结果。

以下是 Python 代码实现：

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        rows = [''] * numRows
        idx, step = 0, 1
        for c in s:
            rows[idx] += c
            if idx == 0 or idx == numRows - 1:
                step = -step
            idx += step
        return ''.join(rows)
```

**解析：** 通过二维数组，我们可以实现 Z 字形变换。

#### 7. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案解析：**

我们可以使用垂直遍历的方法来解决这个问题。首先，找到字符串数组中最短的字符串，然后遍历字符串的每个字符，比较所有字符串在该位置的字符是否相同。如果相同，则将当前字符添加到结果中；否则，停止遍历。以下是 Python 代码实现：

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for i, c in enumerate(zip(*strs)):
            if len(set(c)) == 1:
                prefix += c[0]
            else:
                break
        return prefix
```

**解析：** 通过垂直遍历，我们可以找到字符串数组中的最长公共前缀。

#### 8. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**示例：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。
```

**答案解析：**

我们可以使用哈希表来解决这个问题。遍历数组中的每个元素，对于当前元素 `x`，计算目标值 `target - x`。如果在哈希表中存在 `target - x`，则找到了和为 `target` 的两个数，返回它们的下标。以下是 Python 代码实现：

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash_table = {}
        for i, x in enumerate(nums):
            if target - x in hash_table:
                return [hash_table[target - x], i]
            hash_table[x] = i
        return []
```

**解析：** 通过哈希表，我们可以快速找到两数之和为目标值的两个数。

#### 9. 盛水最多的容器

**题目描述：** 给定一个整数数组 `height`，数组中的每个数表示两个板的宽度，计算容器的最大容量。

**示例：**
```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：容器的高度为 7，宽度为 8，容量为 49。
```

**答案解析：**

我们可以使用双指针的方法来解决这个问题。初始化两个指针 `left` 和 `right`，分别指向数组的起始和结束位置。每次比较 `left` 和 `right` 指针对应的数板的高度，取较小值作为容器的高度，计算容器的面积。然后移动高度较小的指针，尝试找到更大的面积。以下是 Python 代码实现：

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0
        while left < right:
            max_area = max(max_area, (right - left) * min(height[left], height[right]))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return max_area
```

**解析：** 通过双指针的方法，我们可以找到盛水最多的容器。

#### 10. 搜索旋转排序数组

**题目描述：** 给定一个旋转后按升序排列的整数数组 `nums` ，请编写一个函数来判断给定的目标值 `target` 是否存在于数组中。如果存在返回 true，否则返回 false。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：true
```

**答案解析：**

我们可以使用二分查找的方法来解决这个问题。首先，找到数组的中间元素，然后比较中间元素与目标值的关系。如果中间元素等于目标值，则直接返回 true。如果中间元素小于目标值，则说明目标值可能在右半部分，否则可能在左半部分。以下是 Python 代码实现：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return True
            if nums[mid] >= nums[left]:
                if target >= nums[left] and target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return False
```

**解析：** 通过二分查找的方法，我们可以判断目标值是否存在于旋转排序数组中。

#### 11. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**示例：**
```
输入：s = "anagram", t = "nagaram"
输出：true
```

**答案解析：**

我们可以使用哈希表来解决这个问题。遍历字符串 `s` 和 `t`，将每个字符的频率记录到哈希表中。然后比较两个哈希表是否相同，如果相同，则 `t` 是 `s` 的字母异位词。以下是 Python 代码实现：

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        s_freq = [0] * 26
        t_freq = [0] * 26
        for c in s:
            s_freq[ord(c) - ord('a')] += 1
        for c in t:
            t_freq[ord(c) - ord('a')] += 1
        return s_freq == t_freq
```

**解析：** 通过哈希表，我们可以判断两个字符串是否是字母异位词。

#### 12. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
```

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。根据状态转移方程：

```
dp[i][j] = dp[i - 1][j - 1] + 1，如果 text1[i - 1] == text2[j - 1]
dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])，如果 text1[i - 1] != text2[j - 1]
```

以下是 Python 代码实现：

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[m][n]
```

**解析：** 通过动态规划，我们可以计算最长公共子序列的长度。

#### 13. 两数相加 II

**题目描述：** 给出两个非空链表表示两个非负的整数，每个节点包含一个数字，请计算它们表示的数字之和，并以链表形式返回结果。

**示例：**
```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

**答案解析：**

我们可以采用逆序遍历两个链表，逐位相加的方法。具体步骤如下：

1. 创建一个新的虚拟头节点作为结果链表的头节点；
2. 遍历两个链表，每次计算当前节点的和，并更新进位；
3. 如果当前节点的和大于等于10，则将和的个位数添加到结果链表中，并将十位数作为进位；
4. 如果当前节点的和小于10，则将和的个位数添加到结果链表中，进位为0；
5. 遍历结束后，如果进位不为0，则将进位添加到结果链表中。

以下是 Python 代码实现：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

**解析：** 通过逆序遍历两个链表，我们可以计算两个数相加的结果并以链表形式返回。

#### 14. 链表中的倒数第k个节点

**题目描述：** 输入一个链表，输出该链表中倒数第k个节点。

**示例：**
```
输入：head = [1,2,3,4,5], k = 2
输出：2
```

**答案解析：**

我们可以使用双指针的方法来解决这个问题。初始化两个指针 `fast` 和 `slow`，分别指向链表的头部和第 k 个节点。然后同时移动两个指针，当 `fast` 到达链表末尾时，`slow` 即为倒数第 k 个节点。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def getKthFromEnd(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        fast = head
        slow = head
        for _ in range(k):
            if fast is None:
                return None
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        return slow
```

**解析：** 通过双指针的方法，我们可以找到链表中的倒数第 k 个节点。

#### 15. 反转链表

**题目描述：** 反转一个单链表。

**示例：**
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**答案解析：**

我们可以使用递归的方法来解决这个问题。首先，递归反转链表的剩余部分，然后让当前节点的 `next` 指向之前的反转链表的头部。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```

**解析：** 通过递归反转链表，我们可以实现链表的反转。

#### 16. 删除链表的节点

**题目描述：** 给定一个单链表的节点和一个目标值，删除该链表中值为目标值的节点。

**示例：**
```
输入：head = [4,5,1,9], val = 5
输出：[4,1,9]
```

**答案解析：**

我们可以使用迭代的方法来解决这个问题。首先，找到值为目标值的节点，然后让前一个节点的 `next` 指向当前节点的下一个节点，即可删除当前节点。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node: 'Optional[ListNode]') -> None:
        """
        Do not return anything, modify node itself in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

**解析：** 通过迭代的方法，我们可以删除链表中值为目标值的节点。

#### 17. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

我们可以使用迭代的方法来解决这个问题。创建一个新的虚拟头节点，然后比较两个链表的当前节点值，将较小的值添加到新链表中。如果当前节点为空，则将另一个链表的剩余部分添加到新链表中。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 通过迭代的方法，我们可以合并两个有序链表成为一个新的有序链表。

#### 18. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**答案解析：**

我们可以使用快慢指针的方法来解决这个问题。初始化两个指针 `fast` 和 `slow`，分别指向链表的头部和第二个节点。然后同时移动两个指针，每次 `fast` 移动两个节点，`slow` 移动一个节点。如果 `fast` 和 `slow` 相遇，则说明链表中存在环。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False
        fast = head.next
        slow = head
        while fast != slow:
            if fast is None or fast.next is None:
                return False
            fast = fast.next.next
            slow = slow.next
        return True
```

**解析：** 通过快慢指针的方法，我们可以判断链表中是否存在环。

#### 19. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案解析：**

我们可以使用垂直遍历的方法来解决这个问题。首先，找到字符串数组中最短的字符串，然后遍历字符串的每个字符，比较所有字符串在该位置的字符是否相同。如果相同，则将当前字符添加到结果中；否则，停止遍历。以下是 Python 代码实现：

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for i, c in enumerate(zip(*strs)):
            if len(set(c)) == 1:
                prefix += c[0]
            else:
                break
        return prefix
```

**解析：** 通过垂直遍历，我们可以找到字符串数组中的最长公共前缀。

#### 20. 三数之和

**题目描述：** 给定一个整数数组 `nums`，返回所有关于 `nums` 中三个数之和的组合。

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案解析：**

我们可以使用排序和双指针的方法来解决这个问题。首先，对数组进行排序，然后遍历数组中的每个元素，对于每个元素，使用双指针来找到与之相加等于目标值的两个元素。以下是 Python 代码实现：

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []
        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            left, right = i + 1, len(nums) - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total < 0:
                    left += 1
                elif total > 0:
                    right -= 1
                else:
                    ans.append([nums[i], nums[left], nums[right]])
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
        return ans
```

**解析：** 通过排序和双指针的方法，我们可以找到所有关于 `nums` 中三个数之和的组合。

#### 21. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

我们可以使用迭代的方法来解决这个问题。创建一个新的虚拟头节点，然后比较两个链表的当前节点值，将较小的值添加到新链表中。如果当前节点为空，则将另一个链表的剩余部分添加到新链表中。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 通过迭代的方法，我们可以合并两个有序链表成为一个新的有序链表。

#### 22. 存在重复元素

**题目描述：** 给定一个整数数组，判断是否存在重复元素。

**示例：**
```
输入：nums = [1,2,3,1]
输出：true
```

**答案解析：**

我们可以使用哈希表来解决这个问题。遍历数组中的每个元素，将其添加到哈希表中。如果哈希表中已经存在该元素，则说明存在重复元素，返回 true。否则，将元素添加到哈希表中。以下是 Python 代码实现：

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hash_set = set()
        for num in nums:
            if num in hash_set:
                return True
            hash_set.add(num)
        return False
```

**解析：** 通过哈希表，我们可以判断数组中是否存在重复元素。

#### 23. 路径总和

**题目描述：** 给定一个二叉树和一个目标值，判断是否存在从根节点到叶子节点的路径，使得路径上的节点值之和等于目标值。

**示例：**
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：true
解释：从根到叶子节点路径 5->4->11->2 代表一个总和为 22 的路径。
```

**答案解析：**

我们可以使用递归的方法来解决这个问题。对于任意一个节点，如果它是叶子节点，则判断节点的值是否等于目标值；否则，递归判断左子节点和右子节点的路径总和是否等于目标值。以下是 Python 代码实现：

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return root.val == targetSum
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

**解析：** 通过递归的方法，我们可以判断是否存在从根节点到叶子节点的路径，使得路径上的节点值之和等于目标值。

#### 24. 有效的括号

**题目描述：** 给定一个字符串，判断字符串是否是有效的括号字符串。

**示例：**
```
输入："()"
输出：true
```

**答案解析：**

我们可以使用栈来解决这个问题。遍历字符串，对于每个字符：

1. 如果是左括号，则将其入栈；
2. 如果是右括号，则需要判断栈顶元素是否是与之匹配的左括号，如果是，则出栈，否则返回 false；
3. 遍历结束后，如果栈为空，则返回 true，否则返回 false。

以下是 Python 代码实现：

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        brackets = {')': '(', ']': '[', '}': '{'}
        for c in s:
            if c in brackets.values():
                stack.append(c)
            elif c in brackets and stack and stack[-1] == brackets[c]:
                stack.pop()
            else:
                return False
        return not stack
```

**解析：** 通过栈，我们可以判断字符串是否是有效的括号字符串。

#### 25. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将两个数组合并为一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**

我们可以使用双指针的方法来解决这个问题。定义两个指针 `i` 和 `j`，分别指向两个数组的末尾，定义一个指针 `k`，指向合并后数组的末尾。每次比较两个指针指向的值，将较大的值放入合并后的数组中，并移动对应的指针。以下是 Python 代码实现：

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i, j, k = m - 1, n - 1, m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

**解析：** 通过双指针的方法，我们可以合并两个有序数组为一个有序数组。

#### 26. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

我们可以使用迭代的方法来解决这个问题。创建一个新的虚拟头节点，然后比较两个链表的当前节点值，将较小的值添加到新链表中。如果当前节点为空，则将另一个链表的剩余部分添加到新链表中。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

**解析：** 通过迭代的方法，我们可以合并两个有序链表成为一个新的有序链表。

#### 27. 环形链表 II

**题目描述：** 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

**示例：**
```
输入：head = [3,2,0,-4], pos = 1
输出：node 3
解释：链表的表示如下：
3 -> 2 -> 0 -> -4
```

**答案解析：**

我们可以使用快慢指针的方法来解决这个问题。首先，使用快慢指针找到环的入口节点。然后，将一个指针放在链表头部，另一个指针放在环的入口节点，每次同时移动两个指针，当两个指针相遇时，相遇点即为环的入口节点。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        if fast is None or fast.next is None:
            return None
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
```

**解析：** 通过快慢指针的方法，我们可以找到环形链表的入口节点。

#### 28. 反转链表 II

**题目描述：** 给定一个单链表 `head` 的头节点和两个整数 `left` 和 `right` ，反链表中从位置 `left` 到位置 `right` 的节点，返回反链表的头节点。

**示例：**
```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**答案解析：**

我们可以使用递归的方法来解决这个问题。首先，递归反转链表的剩余部分，然后反转指定区间的链表，最后将反转后的链表连接起来。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:
        def reverse(head, right):
            prev = None
            curr = head
            while curr and curr != right:
                next = curr.next
                curr.next = prev
                prev = curr
                curr = next
            return prev

        dummy = ListNode(0)
        dummy.next = head
        left_node = dummy
        right_node = dummy
        for _ in range(left):
            left_node = left_node.next
        for _ in range(right):
            right_node = right_node.next
        left_head = left_node.next
        right_tail = right_node.next
        left_node.next = None
        new_head = reverse(left_head, right_tail)
        left_node.next = new_head
        left_head.next = right_tail
        return dummy.next
```

**解析：** 通过递归反转链表的方法，我们可以反转链表中指定区间的节点。

#### 29. 最长公共子串

**题目描述：** 给定两个字符串 `s` 和 `t` ，返回两个字符串的最长公共子串。

**示例：**
```
输入：s = "abcde", t = "ace"
输出："ace"
```

**答案解析：**

我们可以使用动态规划的方法来解决这个问题。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s` 的前 `i` 个字符和 `t` 的前 `j` 个字符的最长公共子串的长度。根据状态转移方程：

```
dp[i][j] = dp[i - 1][j - 1] + 1，如果 s[i - 1] == t[j - 1]
dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])，如果 s[i - 1] != t[j - 1]
```

以下是 Python 代码实现：

```python
class Solution:
    def longestCommonSubstr
```


```python
class Solution:
    def longestCommonSubstr
```


```python
class Solution:
    def longestCommonSubstring(self, s1: str, s2: str) -> str:
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_len = 0
        end = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    if dp[i][j] > max_len:
                        max_len = dp[i][j]
                        end = i - 1
                else:
                    dp[i][j] = 0
        return s1[end - max_len + 1: end + 1]
```

**解析：** 通过动态规划的方法，我们可以找到两个字符串的最长公共子串。

#### 30. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将两个数组合并为一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**

我们可以使用双指针的方法来解决这个问题。定义两个指针 `i` 和 `j`，分别指向两个数组的末尾，定义一个指针 `k`，指向合并后数组的末尾。每次比较两个指针指向的值，将较大的值放入合并后的数组中，并移动对应的指针。以下是 Python 代码实现：

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i, j, k = m - 1, n - 1, m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

**解析：** 通过双指针的方法，我们可以合并两个有序数组为一个有序数组。

### 小米2024校招面试真题与算法题解

在本文中，我们为您准备了小米2024校招面试真题与算法题解，涵盖了数据结构与算法、编程技巧、系统设计等多个方面。以下是30道具有代表性的面试题及其解析：

#### 1. 判断二叉树是否对称

**题目描述：** 给定一个二叉树，判断它是否对称。

**示例：**
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

**答案解析：**

使用递归方法，对二叉树进行左右对称比较。具体步骤如下：

1. 如果两个子节点都为 `null`，则它们对称；
2. 如果两个子节点只有一个为 `null`，则它们不对称；
3. 如果两个子节点的值不相等，则它们不对称；
4. 递归比较左子节点的左子节点与右子节点的右子节点，以及左子节点的右子节点与右子节点的左子节点。

**代码实现：**
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def is_mirror(t1, t2):
            if not t1 and not t2:
                return True
            if not t1 or not t2:
                return False
            if t1.val != t2.val:
                return False
            return is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left)

        return is_mirror(root.left, root.right)
```

#### 2. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

采用迭代方法，从两个链表的头节点开始比较，选择较小值添加到新链表中，并移动对应的指针。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

#### 3. 搜索旋转排序数组

**题目描述：** 给定一个旋转后按升序排列的数组，找到目标值。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**答案解析：**

使用二分查找方法，找到目标值的位置。以下是 Python 代码实现：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] >= nums[left]:
                if target >= nums[left] and target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return -1
```

#### 4. 两数相加

**题目描述：** 给定两个非空链表表示两个非负的整数，计算它们表示的数字之和。

**示例：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,7]
```

**答案解析：**

采用逆序遍历链表，逐位相加。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

#### 5. 有效的括号

**题目描述：** 给定一个字符串，判断字符串是否是有效的括号字符串。

**示例：**
```
输入："()"
输出：true
```

**答案解析：**

使用栈判断括号是否匹配。以下是 Python 代码实现：

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        brackets = {')': '(', ']': '[', '}': '{'}
        for c in s:
            if c in brackets.values():
                stack.append(c)
            elif c in brackets and stack and stack[-1] == brackets[c]:
                stack.pop()
            else:
                return False
        return not stack
```

#### 6. Z 字形变换

**题目描述：** 将一个给定字符串根据给定的行数，以从上到下、从左到右的顺序进行 Z 字形排列。

**示例：**
```
输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"
```

**答案解析：**

使用二维数组存储 Z 字形排列的结果。以下是 Python 代码实现：

```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        rows = [''] * numRows
        idx, step = 0, 1
        for c in s:
            rows[idx] += c
            if idx == 0 or idx == numRows - 1:
                step = -step
            idx += step
        return ''.join(rows)
```

#### 7. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案解析：**

从第一个字符串开始，逐个比较后续字符串的前缀，直到找到不匹配的部分。以下是 Python 代码实现：

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = ""
        for i, c in enumerate(zip(*strs)):
            if len(set(c)) == 1:
                prefix += c[0]
            else:
                break
        return prefix
```

#### 8. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，在数组中找出和为目标值的那两个整数，并返回它们的数组下标。

**示例：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。
```

**答案解析：**

使用哈希表存储遍历过的数字及其索引，遍历数组，对于当前元素，计算目标值与当前元素的差，如果差在哈希表中存在，则找到和为目标值的那两个数。以下是 Python 代码实现：

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hash_map = {}
        for i, x in enumerate(nums):
            if target - x in hash_map:
                return [hash_map[target - x], i]
            hash_map[x] = i
        return []
```

#### 9. 盛水最多的容器

**题目描述：** 给定一个整数数组 `height`，数组中的每个数表示两个板的宽度，计算容器的最大容量。

**示例：**
```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：容器的高度为 7，宽度为 8，容量为 49。
```

**答案解析：**

使用双指针的方法，一个指针从数组的一端开始，另一个指针从另一端开始，计算两个指针指向的高度乘以两个指针之间的距离，然后移动高度较小的指针。以下是 Python 代码实现：

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        left, right = 0, len(height) - 1
        max_area = 0
        while left < right:
            max_area = max(max_area, (right - left) * min(height[left], height[right]))
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return max_area
```

#### 10. 搜索旋转排序数组

**题目描述：** 给定一个旋转后按升序排列的整数数组，请编写一个函数来判断给定的目标值是否存在于数组中。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：true
```

**答案解析：**

使用二分查找的方法，找到中间元素，比较中间元素与目标值的关系。以下是 Python 代码实现：

```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return True
            if nums[mid] >= nums[left]:
                if target >= nums[left] and target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if target > nums[mid] and target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1
        return False
```

#### 11. 有效的字母异位词

**题目描述：** 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**示例：**
```
输入：s = "anagram", t = "nagaram"
输出：true
```

**答案解析：**

使用哈希表统计字符串中每个字符的频率，然后比较两个字符串的字符频率是否相同。以下是 Python 代码实现：

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        s_freq = [0] * 26
        t_freq = [0] * 26
        for c in s:
            s_freq[ord(c) - ord('a')] += 1
        for c in t:
            t_freq[ord(c) - ord('a')] += 1
        return s_freq == t_freq
```

#### 12. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2` ，返回这两个字符串的最长公共子序列的长度。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
```

**答案解析：**

使用动态规划的方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。以下是 Python 代码实现：

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[m][n]
```

#### 13. 两数相加 II

**题目描述：** 给出两个非空链表表示两个非负的整数，计算它们表示的数字之和，并以链表形式返回结果。

**示例：**
```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

**答案解析：**

采用逆序遍历链表，逐位相加。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

#### 14. 删除链表的节点

**题目描述：** 给定一个链表和一个目标值，删除链表中值为目标值的节点。

**示例：**
```
输入：head = [4,5,1,9], val = 5
输出：[4,1,9]
```

**答案解析：**

使用迭代方法，找到目标值节点的前一个节点，将其指向目标节点的下一个节点。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node: 'Optional[ListNode]') -> None:
        """
        Do not return anything, modify node itself in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

#### 15. 反转链表

**题目描述：** 反转一个单链表。

**示例：**
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**答案解析：**

采用递归方法，递归反转链表的剩余部分，然后让当前节点的 `next` 指向之前的反转链表的头部。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        p = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return p
```

#### 16. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**答案解析：**

采用快慢指针方法，快指针每次走两步，慢指针每次走一步，如果快指针追上慢指针，则说明链表中存在环。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False
        fast = head.next
        slow = head
        while fast != slow:
            if fast is None or fast.next is None:
                return False
            fast = fast.next.next
            slow = slow.next
        return True
```

#### 17. 最长公共子串

**题目描述：** 给定两个字符串 `s` 和 `t` ，返回这两个字符串的最长公共子串。

**示例：**
```
输入：s = "abcde", t = "ace"
输出："ace"
```

**答案解析：**

采用动态规划的方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s` 的前 `i` 个字符和 `t` 的前 `j` 个字符的最长公共子串的长度。以下是 Python 代码实现：

```python
class Solution:
    def longestCommonSubstr(self, s: str, t: str) -> str:
        m, n = len(s), len(t)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_len = 0
        end = 0
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s[i - 1] == t[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                    if dp[i][j] > max_len:
                        max_len = dp[i][j]
                        end = i - 1
                else:
                    dp[i][j] = 0
        return s[end - max_len + 1: end + 1]
```

#### 18. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将两个数组合并为一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**

采用双指针的方法，从两个数组的末尾开始比较，将较大的值放入合并后的数组中，并移动对应的指针。以下是 Python 代码实现：

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i, j, k = m - 1, n - 1, m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

#### 19. 最长公共子序列

**题目描述：** 给定两个字符串 `text1` 和 `text2` ，返回这两个字符串的最长公共子序列的长度。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
```

**答案解析：**

采用动态规划的方法，定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。以下是 Python 代码实现：

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[m][n]
```

#### 20. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

采用迭代方法，从两个链表的头节点开始比较，选择较小值添加到新链表中，并移动对应的指针。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

#### 21. 存在重复元素

**题目描述：** 给定一个整数数组，判断是否存在重复元素。

**示例：**
```
输入：nums = [1,2,3,1]
输出：true
```

**答案解析：**

采用哈希表的方法，遍历数组，将每个元素添加到哈希表中，如果哈希表中已经存在该元素，则说明存在重复元素。以下是 Python 代码实现：

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hash_set = set()
        for num in nums:
            if num in hash_set:
                return True
            hash_set.add(num)
        return False
```

#### 22. 路径总和

**题目描述：** 给定一个二叉树和一个目标值，判断是否存在从根节点到叶子节点的路径，使得路径上的节点值之和等于目标值。

**示例：**
```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：true
解释：从根到叶子节点路径 5->4->11->2 代表一个总和为 22 的路径。
```

**答案解析：**

采用递归方法，对于每个节点，如果它是叶子节点，则判断节点的值是否等于目标值；否则，递归判断左子节点和右子节点的路径总和是否等于目标值。以下是 Python 代码实现：

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if root is None:
            return False
        if root.left is None and root.right is None:
            return root.val == targetSum
        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
```

#### 23. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

采用迭代方法，从两个链表的头节点开始比较，选择较小值添加到新链表中，并移动对应的指针。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

#### 24. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将两个数组合并为一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**

采用双指针的方法，从两个数组的末尾开始比较，选择较大值放入合并后的数组中，并移动对应的指针。以下是 Python 代码实现：

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i, j, k = m - 1, n - 1, m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

#### 25. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

采用迭代方法，从两个链表的头节点开始比较，选择较小值添加到新链表中，并移动对应的指针。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

#### 26. 删除链表的节点

**题目描述：** 给定一个链表和一个目标值，删除链表中值为目标值的节点。

**示例：**
```
输入：head = [4,5,1,9], val = 5
输出：[4,1,9]
```

**答案解析：**

采用迭代方法，找到目标值节点的前一个节点，将其指向目标节点的下一个节点。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node: 'Optional[ListNode]') -> None:
        """
        Do not return anything, modify node itself in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

#### 27. 合并两个有序链表

**题目描述：** 给出两个有序链表，合并两个链表成为一个新的有序链表。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案解析：**

采用迭代方法，从两个链表的头节点开始比较，选择较小值添加到新链表中，并移动对应的指针。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        curr.next = l1 or l2
        return dummy.next
```

#### 28. 环形链表

**题目描述：** 给定一个链表，判断链表中是否有环。

**示例：**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**答案解析：**

采用快慢指针方法，快指针每次走两步，慢指针每次走一步，如果快指针追上慢指针，则说明链表中存在环。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        if not head or not head.next:
            return False
        fast = head.next
        slow = head
        while fast != slow:
            if fast is None or fast.next is None:
                return False
            fast = fast.next.next
            slow = slow.next
        return True
```

#### 29. 删除链表的节点

**题目描述：** 给定一个链表和一个目标值，删除链表中值为目标值的节点。

**示例：**
```
输入：head = [4,5,1,9], val = 5
输出：[4,1,9]
```

**答案解析：**

采用迭代方法，找到目标值节点的前一个节点，将其指向目标节点的下一个节点。以下是 Python 代码实现：

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteNode(self, node: 'Optional[ListNode]') -> None:
        """
        Do not return anything, modify node itself in-place instead.
        """
        node.val = node.next.val
        node.next = node.next.next
```

#### 30. 合并两个有序数组

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，将两个数组合并为一个有序数组。

**示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**答案解析：**

采用双指针的方法，从两个数组的末尾开始比较，选择较大值放入合并后的数组中，并移动对应的指针。以下是 Python 代码实现：

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        i, j, k = m - 1, n - 1, m + n - 1
        while i >= 0 and j >= 0:
            if nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            else:
                nums1[k] = nums2[j]
                j -= 1
            k -= 1
        while j >= 0:
            nums1[k] = nums2[j]
            j -= 1
            k -= 1
```

### 小结

本文详细介绍了小米2024校招面试真题与算法题解，涵盖了数据结构与算法、编程技巧、系统设计等多个方面。通过这些题目和解析，您可以更好地准备小米的面试，提高自己的算法水平和编程能力。希望本文对您有所帮助！如果您有任何疑问或建议，欢迎在评论区留言讨论。谢谢！

