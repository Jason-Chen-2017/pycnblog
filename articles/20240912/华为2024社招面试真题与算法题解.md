                 

### 华为2024社招面试真题与算法题解

#### 一、编程算法题

##### 1. 字符串转换整数（atoi）

**题目描述：** 请实现一个函数，将字符串转换成整数。

```java
public int myAtoi(String str) {

}
```

**解题思路：** 首先过滤字符串开头的空白字符，然后判断字符串第一个字符是否为数字字符，如果不是，则返回 0。接着遍历字符串，将数字字符转换为整数，同时注意判断是否越界。

**满分答案：**

```java
public int myAtoi(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }

    long result = 0;
    int i = 0;
    boolean isNegative = false;

    // 过滤开头的空白字符
    while (i < str.length() && str.charAt(i) == ' ') {
        i++;
    }

    // 判断第一个字符是否为数字字符
    if (i < str.length() && (str.charAt(i) == '+' || str.charAt(i) == '-')) {
        isNegative = str.charAt(i) == '-';
        i++;
    }

    // 遍历字符串，将数字字符转换为整数
    while (i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9') {
        result = result * 10 + (str.charAt(i) - '0');
        if (result > 0 && result > Integer.MAX_VALUE) {
            return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        i++;
    }

    return (int) (isNegative ? -result : result);
}
```

##### 2. 寻找两个正序数组的中位数

**题目描述：** 给定两个大小为 m 和 n 的正序数组 nums1 和 nums2，请从两个数组中各选出 k 个数字，使构成数组 nums = [nums1[i], nums2[j]] ，找出并返回数组 nums 中的中位数。

**解题思路：** 可以使用二分查找的方法，分别对两个数组进行二分查找，找到中位数的位置。

**满分答案：**

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m

        imin, imax, half_len = 0, m, (m + n + 1) // 2
        while imin <= imax:
            i = (imin + imax) // 2
            j = half_len - i
            if i < m and nums2[j - 1] > nums1[i]:
                imin = i + 1
            elif i > 0 and nums1[i - 1] > nums2[j]:
                imax = i - 1
            else:
                if i == 0:
                    max_of_left = nums2[j - 1]
                elif j == 0:
                    max_of_left = nums1[i - 1]
                else:
                    max_of_left = max(nums1[i - 1], nums2[j - 1])
                if (m + n) % 2 == 1:
                    return max_of_left
                min_of_right = min(nums1[i], nums2[j])
                return (max_of_left + min_of_right) / 2
```

##### 3. 找出第 k 小的元素

**题目描述：** 在一个排序数组中找出第 k 小的元素。

```python
def findKthLargest(nums: List[int], k: int) -> int:
```

**解题思路：** 可以使用快速选择算法，类似于快速排序的过程。

**满分答案：**

```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def quickSelect(nums, left, right, k):
            if left == right:
                return nums[left]
            pivotIndex = self.partition(nums, left, right)
            if k == pivotIndex + 1:
                return nums[pivotIndex]
            elif k < pivotIndex + 1:
                return quickSelect(nums, left, pivotIndex - 1, k)
            else:
                return quickSelect(nums, pivotIndex + 1, right, k)

        def partition(nums, left, right):
            pivot = nums[right]
            i = left
            for j in range(left, right):
                if nums[j] < pivot:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
            nums[i], nums[right] = nums[right], nums[i]
            return i

        return quickSelect(nums, 0, len(nums) - 1, k)
```

##### 4. 逆波兰表达式求值

**题目描述：** 根据逆波兰表示法，求表达式的值。

```python
def evalRPN(tokens: List[str]) -> int:
```

**解题思路：** 使用栈实现。

**满分答案：**

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token in ["+", "-", "*", "/"]:
                b = stack.pop()
                a = stack.pop()
                if token == "+":
                    stack.append(a + b)
                elif token == "-":
                    stack.append(a - b)
                elif token == "*":
                    stack.append(a * b)
                elif token == "/":
                    stack.append(a // b)
            else:
                stack.append(int(token))
        return stack[-1]
```

##### 5. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

```python
def longestCommonPrefix(strs: List[str]) -> str:
```

**解题思路：** 从第一个字符串开始，逐个字符与前一个字符串进行比较，找出最长公共前缀。

**满分答案：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        prefix = strs[0]
        for s in strs[1:]:
            i = 0
            while i < len(prefix) and i < len(s):
                if prefix[i] != s[i]:
                    break
                i += 1
            prefix = prefix[:i]
        return prefix
```

##### 6. 旋转图像

**题目描述：** 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

```python
def rotate(matrix: List[List[int]]) -> None:
    """
    Do not return anything, modify matrix in-place instead.
    """
```

**解题思路：** 先将矩阵沿对角线翻转，然后再将每一行进行翻转。

**满分答案：**

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        # 沿对角线翻转
        for i in range(n):
            for j in range(i, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        # 每一行进行翻转
        for i in range(n):
            matrix[i].reverse()
```

##### 7. 字符串转换整数（atoi）

**题目描述：** 请实现一个函数，将字符串转换成整数。

```java
public int myAtoi(String str) {

}
```

**解题思路：** 首先过滤字符串开头的空白字符，然后判断字符串第一个字符是否为数字字符，如果不是，则返回 0。接着遍历字符串，将数字字符转换为整数，同时注意判断是否越界。

**满分答案：**

```java
public int myAtoi(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }

    long result = 0;
    int i = 0;
    boolean isNegative = false;

    // 过滤开头的空白字符
    while (i < str.length() && str.charAt(i) == ' ') {
        i++;
    }

    // 判断第一个字符是否为数字字符
    if (i < str.length() && (str.charAt(i) == '+' || str.charAt(i) == '-')) {
        isNegative = str.charAt(i) == '-';
        i++;
    }

    // 遍历字符串，将数字字符转换为整数
    while (i < str.length() && str.charAt(i) >= '0' && str.charAt(i) <= '9') {
        result = result * 10 + (str.charAt(i) - '0');
        if (result > 0 && result > Integer.MAX_VALUE) {
            return isNegative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        i++;
    }

    return (int) (isNegative ? -result : result);
}
```

##### 8. 合并两个有序数组

**题目描述：** 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

```python
def merge(nums1, m, nums2, n):

    i = j = 0
    for k in range(m):
        if j >= n or nums1[k] > nums2[j]:
            nums1[k + j] = nums2[j]
            j += 1
        else:
            nums1[k + j] = nums1[k]
            k += 1
    nums1[k + j:] = nums2[j:]
```

**解题思路：** 从后往前比较两个数组的元素，将较大的元素放入 nums1 的末尾。

**满分答案：**

```python
def merge(nums1, m, nums2, n):
    i, j = m - 1, n - 1
    p = m + n - 1

    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[p] = nums1[i]
            i -= 1
        else:
            nums1[p] = nums2[j]
            j -= 1
        p -= 1

    while j >= 0:
        nums1[p] = nums2[j]
        j -= 1
        p -= 1
```

##### 9. 有效的括号

**题目描述：** 给定一个字符串 s ，判断是否是有效的括号字符串。

```python
def isValid(s: str) -> bool:
```

**解题思路：** 使用栈实现。

**满分答案：**

```python
def isValid(s: str) -> bool:
    stack = []
    for c in s:
        if c in "({[}", stack.append(c)
        elif not stack or (c == ")" and stack[-1] != "(") or (c == "}" and stack[-1] != "{") or (c == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()
    return not stack
```

##### 10. 两数相加

**题目描述：** 给出两个非空链表表示两个非负整数，每个节点包含一个数字，请计算它们的和并返回一个新的链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
```

**解题思路：** 从链表头开始，逐个节点进行相加，并处理进位。

**满分答案：**

```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        p, q, curr = l1, l2, dummy
        carry = 0

        while p or q or carry:
            x = p.val if p else 0
            y = q.val if q else 0
            sum = carry + x + y
            carry = sum // 10
            curr.next = ListNode(sum % 10)
            curr = curr.next

            if p:
                p = p.next
            if q:
                q = q.next

        return dummy.next
```

##### 11. 合并两个有序链表

**题目描述：** 给定两个单链表，请将其合并为一个新的单链表并返回。要求链表中的元素保持升序。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
```

**解题思路：** 逐个比较两个链表节点的值，选择较小的节点加入新链表。

**满分答案：**

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1

        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

##### 12. 二叉树的层序遍历

**题目描述：** 请实现二叉树的层序遍历。

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
```

**解题思路：** 使用队列实现。

**满分答案：**

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        ans, q = [], [root]
        while q:
            t = []
            for _ in range(len(q)):
                node = q.pop(0)
                t.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            ans.append(t)
        return ans
```

##### 13. 二叉搜索树的第 k 个节点

**题目描述：** 给定一个二叉搜索树和一个整数 k，请找出该树中第 k 个最小的元素。

```python
from typing import Optional

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
```

**解题思路：** 中序遍历二叉搜索树，找到第 k 个节点。

**满分答案：**

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            self.ans, k = root.val, k - 1
            if not k:
                return
            dfs(root.right)

        self.ans = None
        dfs(root)
        return self.ans
```

##### 14. 两数之和

**题目描述：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

```python
def twoSum(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: List[int]
    """
```

**解题思路：** 使用哈希表存储已遍历过的元素及其索引。

**满分答案：**

```python
def twoSum(nums, target):
    hashmap = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hashmap:
            return [hashmap[complement], i]
        hashmap[num] = i
    return []
```

##### 15. 搜索旋转排序数组

**题目描述：** 给你一个整数数组 nums 按升序排列，请你在数组中找到从开始遍历 2 个数字的索引处的下标，并返回该下标。如果数组中存在下标处两个数字相等，则返回任意一个即可。

```python
def search(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
```

**解题思路：** 二分查找。

**满分答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) >> 1
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return left if nums[left] == target else -1
```

##### 16. 盲插排序

**题目描述：** 插入排序的优化算法，每次插入的元素是在待排序列中找到待插入位置最左侧的数大于待插入数的位置。

```python
def insertionSort(arr):
    """
    :type arr: List[int]
    :rtype: List[int]
    """
```

**解题思路：** 与插入排序类似，但需要找到待插入位置的最左侧的数大于待插入数的位置。

**满分答案：**

```python
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

##### 17. 快速选择

**题目描述：** 选择排序的优化算法，从未排序的数组中找出第 k 小的元素。

```python
def quickSelect(nums, k):
    """
    :type nums: List[int]
    :type k: int
    :rtype: int
    """
```

**解题思路：** 类似快速排序，但只需要找到第 k 小的元素。

**满分答案：**

```python
def quickSelect(nums, k):
    left, right = 0, len(nums) - 1
    while left < right:
        pivot = partition(nums, left, right)
        if pivot < k:
            left = pivot + 1
        elif pivot > k:
            right = pivot - 1
        else:
            return nums[pivot]
    return nums[left]
```

##### 18. 快速排序

**题目描述：** 给定一个整数数组 nums，将数组中的元素进行升序排序。

```python
def quickSort(nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
```

**解题思路：** 采用分治算法，将数组划分为较小和较大的两部分。

**满分答案：**

```python
def quickSort(nums):
    if len(nums) <= 1:
        return nums
    pivot = nums[len(nums) // 2]
    left = [x for x in nums if x < pivot]
    middle = [x for x in nums if x == pivot]
    right = [x for x in nums if x > pivot]
    return quickSort(left) + middle + quickSort(right)
```

##### 19. 二分查找

**题目描述：** 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```python
def binarySearch(nums, target):
    """
    :type nums: List[int]
    :type target: int
    :rtype: int
    """
```

**解题思路：** 采用二分查找算法。

**满分答案：**

```python
def binarySearch(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

##### 20. 合并两个有序链表

**题目描述：** 给定两个单链表，请将其合并为一个新的单链表并返回。要求链表中的元素保持升序。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
```

**解题思路：** 逐个比较两个链表节点的值，选择较小的节点加入新链表。

**满分答案：**

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1

        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

##### 21. 合并 k 个排序链表

**题目描述：** 给定 k 个排序后的链表，请你合并它们为一个新的排序后的链表并返回。

```python
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
```

**解题思路：** 使用优先队列（小根堆）实现。

**满分答案：**

```python
import heapq

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        q = []
        for head in lists:
            if head:
                heapq.heappush(q, head)

        while q:
            node = heapq.heappop(q)
            curr.next = node
            curr = curr.next
            if node.next:
                heapq.heappush(q, node.next)

        return dummy.next
```

##### 22. 最长公共子序列

**题目描述：** 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

```python
def longestCommonSubsequence(text1, text2):
    """
    :type text1: str
    :type text2: str
    :rtype: int
    """
```

**解题思路：** 动态规划。

**满分答案：**

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

##### 23. 最长回文子串

**题目描述：** 给你一个字符串 s，找到最长的回文子串。

```python
def longestPalindrome(s: str) -> str:
    """
    :type s: str
    :rtype: str
    """
```

**解题思路：** 动态规划。

**满分答案：**

```python
def longestPalindrome(s: str) -> str:
    if not s:
        return ""

    n = len(s)
    dp = [[False] * n for _ in range(n)]

    start = 0
    max_len = 1

    for i in range(n):
        dp[i][i] = True

    for j in range(1, n):
        if s[i] == s[i - 1]:
            dp[i - 1][i] = True
            start = i - 1
            max_len = 2
        for i in range(j - 2, -1, -1):
            if s[i] == s[j]:
                if j - i < 3:
                    dp[i][j] = True
                else:
                    dp[i][j] = dp[i + 1][j - 1]
                    if dp[i][j]:
                        start = i
                        max_len = j - i + 1

    return s[start: start + max_len]
```

##### 24. 递归

**题目描述：** 请使用递归实现一个函数，计算一个整数 n 的阶乘。

```python
def factorial(n):
    """
    :type n: int
    :rtype: int
    """
```

**解题思路：** 递归计算阶乘。

**满分答案：**

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

##### 25. 动态规划

**题目描述：** 请使用动态规划实现一个函数，计算斐波那契数列的第 n 项。

```python
def fibonacci(n):
    """
    :type n: int
    :rtype: int
    """
```

**解题思路：** 动态规划计算斐波那契数列的第 n 项。

**满分答案：**

```python
def fibonacci(n):
    if n == 0:
        return 0
    if n == 1:
        return 1
    dp = [0] * (n + 1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

##### 26. 背包问题

**题目描述：** 请使用动态规划实现一个函数，解决 0-1 背包问题。

```python
def knapsack(C, W):
    """
    :type C: List[int]
    :type W: List[int]
    :rtype: int
    """
```

**解题思路：** 动态规划解决 0-1 背包问题。

**满分答案：**

```python
def knapsack(C, W):
    n = len(C)
    dp = [[0] * (C + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, C + 1):
            if W[i - 1] <= j:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - W[i - 1]] + C[i - 1])
            else:
                dp[i][j] = dp[i - 1][j]

    return dp[n][C]
```

##### 27. 二进制加法

**题目描述：** 请实现一个函数，用于计算两个二进制数的和。

```python
def addBinary(a, b):
    """
    :type a: str
    :type b: str
    :rtype: str
    """
```

**解题思路：** 二进制加法。

**满分答案：**

```python
def addBinary(a, b):
    def get_binary(n):
        return bin(n)[2:]

    max_len = max(len(a), len(b))
    a = '0' * (max_len - len(a)) + a
    b = '0' * (max_len - len(b)) + b

    carry = 0
    result = []
    for i in range(max_len - 1, -1, -1):
        total = carry + int(a[i]) + int(b[i])
        result.append(str(total % 2))
        carry = total // 2

    if carry:
        result.append('1')

    return ''.join(result[::-1])
```

##### 28. 位运算

**题目描述：** 请实现一个函数，用于计算两个整数的和，但不使用加减运算符。

```python
def add(a, b):
    """
    :type a: int
    :type b: int
    :rtype: int
    """
```

**解题思路：** 位运算。

**满分答案：**

```python
def add(a, b):
    while b != 0:
        carry = a & b
        a = a ^ b
        b = carry << 1
    return a
```

##### 29. 二进制转换

**题目描述：** 请实现一个函数，用于将一个十进制数转换为二进制数。

```python
def toBinary(n):
    """
    :type n: int
    :rtype: str
    """
```

**解题思路：** 二进制转换。

**满分答案：**

```python
def toBinary(n):
    if n == 0:
        return '0'
    result = []
    while n > 0:
        result.append(str(n % 2))
        n = n // 2
    return ''.join(result[::-1])
```

##### 30. 快速幂

**题目描述：** 请实现一个函数，用于计算一个数的 n 次幂，快速幂。

```python
def power(x, n):
    """
    :type x: float
    :type n: int
    :rtype: float
    """
```

**解题思路：** 快速幂。

**满分答案：**

```python
def power(x, n):
    if n == 0:
        return 1
    if n < 0:
        x = 1 / x
        n = -n

    result = 1
    while n > 0:
        if n & 1:
            result *= x
        x *= x
        n >>= 1

    return result
```

