                 

### 《2025京东校招算法面试题汇总与解析》

### 引言

在2025年，京东作为国内领先的电商巨头，其校招算法面试题成为了广大求职者关注的焦点。本文将对京东校招算法面试中出现的典型问题进行汇总与解析，旨在帮助求职者更好地备战面试，提升自己的算法能力。

### 面试题库

#### 1. 计数排序

**题目描述：** 请实现一个计数排序算法，该算法能够对整数数组进行排序。

**答案：** 

```python
def counting_sort(arr):
    # 找到数组的最大值和最小值
    max_val, min_val = max(arr), min(arr)
    # 创建一个计数数组，大小为最大值和最小值的差值加一
    count_array = [0] * (max_val - min_val + 1)
    # 对数组中的每个元素进行计数
    for num in arr:
        count_array[num - min_val] += 1
    # 将计数数组中的元素累加
    for i in range(1, len(count_array)):
        count_array[i] += count_array[i - 1]
    # 创建一个结果数组
    result = [0] * len(arr)
    # 根据计数数组将元素放入结果数组
    for num in arr:
        result[count_array[num - min_val] - 1] = num
        count_array[num - min_val] -= 1
    return result
```

**解析：** 计数排序是一种非比较型排序算法，适用于整数数组。它通过计数来统计每个元素出现的次数，然后根据计数结果进行排序。

#### 2. 求最大子序和

**题目描述：** 给定一个整数数组，求出最大子序和。

**答案：**

```python
def max_subarray_sum(arr):
    max_sum = arr[0]
    current_sum = arr[0]
    for num in arr[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum
```

**解析：** 求最大子序和可以使用动态规划的方法，通过维护当前子序列和和历史最大子序列和来找到最大子序和。

#### 3. 判断二叉树是否平衡

**题目描述：** 请实现一个函数，判断给定的二叉树是否平衡。

**答案：**

```python
def is_balanced(root):
    def check_height(node):
        if not node:
            return 0
        left_height = check_height(node.left)
        right_height = check_height(node.right)
        if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
            return -1
        return max(left_height, right_height) + 1

    return check_height(root) != -1
```

**解析：** 判断二叉树是否平衡可以通过递归计算每个节点的左右子树的高度，并检查它们之间的差异是否大于1。

#### 4. 设计一个LRU缓存

**题目描述：** 请实现一个LRU（Least Recently Used）缓存，支持以下操作：get 和 put。

**答案：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：** LRU缓存可以通过使用OrderedDict来实现，其中元素按照插入顺序排序，最近使用的元素位于字典的末尾。

#### 5. 最长公共子序列

**题目描述：** 给定两个字符串，求它们的最长公共子序列。

**答案：**

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]
```

**解析：** 最长公共子序列可以通过动态规划求解，使用二维数组记录每个子问题的解。

#### 6. 设计堆

**题目描述：** 请实现一个小顶堆，支持插入和提取最小元素。

**答案：**

```python
import heapq

class MinHeap:
    def __init__(self):
        self.heap = []

    def insert(self, val):
        heapq.heappush(self.heap, val)

    def extract_min(self):
        return heapq.heappop(self.heap)
```

**解析：** Python中的heapq模块可以用来实现小顶堆。

#### 7. 单调栈

**题目描述：** 请实现一个单调栈，用于找到数组中的下一个更大元素。

**答案：**

```python
def next_greater_elements(arr):
    stack = []
    result = [-1] * len(arr)
    for i in range(len(arr) - 1, -1, -1):
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()
        if stack:
            result[i] = arr[stack[-1]]
        stack.append(i)
    return result
```

**解析：** 单调栈可以用来找到数组中每个元素的下一个更大元素。

#### 8. 设计一个双向链表

**题目描述：** 请实现一个双向链表，支持在中间插入和删除节点。

**答案：**

```python
class ListNode:
    def __init__(self, value=0, prev=None, next=None):
        self.value = value
        self.prev = prev
        self.next = next

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, value):
        new_node = ListNode(value)
        if not self.head:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node

    def delete(self, node):
        if node.prev:
            node.prev.next = node.next
        if node.next:
            node.next.prev = node.prev
        if node == self.head:
            self.head = node.next
        if node == self.tail:
            self.tail = node.prev
        node.prev = None
        node.next = None
```

**解析：** 双向链表可以通过维护prev和next指针来实现。

#### 9. 设计一个双向队列

**题目描述：** 请实现一个双向队列，支持在头部和尾部添加和删除元素。

**答案：**

```python
from collections import deque

class DoublyQueue:
    def __init__(self):
        self.queue = deque()

    def append(self, value):
        self.queue.append(value)

    def appendleft(self, value):
        self.queue.appendleft(value)

    def pop(self):
        return self.queue.pop()

    def popleft(self):
        return self.queue.popleft()
```

**解析：** Python的deque模块可以用来实现双向队列。

#### 10. 设计一个优先级队列

**题目描述：** 请实现一个优先级队列，支持插入和删除具有最高优先级的元素。

**答案：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def insert(self, item, priority):
        heapq.heappush(self.heap, (-priority, item))

    def delete_max(self):
        return heapq.heappop(self.heap)[1]
```

**解析：** 优先级队列可以通过使用堆来实现。

#### 11. 求解汉诺塔问题

**题目描述：** 请实现一个函数，求解汉诺塔问题。

**答案：**

```python
def hanoi(n, from_peg, to_peg, aux_peg):
    if n == 1:
        print(f"Move disk 1 from peg {from_peg} to peg {to_peg}")
        return
    hanoi(n - 1, from_peg, aux_peg, to_peg)
    print(f"Move disk {n} from peg {from_peg} to peg {to_peg}")
    hanoi(n - 1, aux_peg, to_peg, from_peg)
```

**解析：** 汉诺塔问题可以通过递归求解。

#### 12. 寻找峰值元素

**题目描述：** 请实现一个函数，寻找一个整型数组中的峰值元素。

**答案：**

```python
def find_peak_element(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] < nums[mid + 1]:
            left = mid + 1
        else:
            right = mid
    return left
```

**解析：** 通过二分查找，可以找到数组中的峰值元素。

#### 13. 环形链表

**题目描述：** 请实现一个函数，判断一个链表是否为环形链表。

**答案：**

```python
class ListNode:
    def __init__(self, value=0, next=None):
        self.value = value
        self.next = next

def has_cycle(head):
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**解析：** 使用快慢指针法可以判断链表是否为环形链表。

#### 14. 最长公共前缀

**题目描述：** 请实现一个函数，找出字符串数组中的最长公共前缀。

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while not s.startswith(prefix):
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

**解析：** 通过逐个比较字符串数组中的字符串，可以找到最长公共前缀。

#### 15. 有效括号

**题目描述：** 请实现一个函数，判断一个字符串中的括号是否有效。

**答案：**

```python
def is_valid(s):
    stack = []
    for c in s:
        if c == '(' or c == '[' or c == '{':
            stack.append(c)
        elif not stack:
            return False
        elif c == ')' and stack[-1] != '(':
            return False
        elif c == ']' and stack[-1] != '[':
            return False
        elif c == '}' and stack[-1] != '{':
            return False
        else:
            stack.pop()
    return not stack
```

**解析：** 使用栈可以判断字符串中的括号是否有效。

#### 16. 合并两个有序链表

**题目描述：** 请实现一个函数，合并两个有序链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    dummy = ListNode(0)
    current = dummy
    while l1 and l2:
        if l1.val < l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    current.next = l1 or l2
    return dummy.next
```

**解析：** 通过逐个比较两个有序链表的节点，可以将它们合并成一个有序链表。

#### 17. 反转链表

**题目描述：** 请实现一个函数，反转一个单链表。

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev
```

**解析：** 通过遍历链表，可以使用反转指针的方法实现链表反转。

#### 18. 设计一个哈希表

**题目描述：** 请实现一个哈希表，支持插入、删除和查询操作。

**答案：**

```python
class HashTable:
    def __init__(self):
        self.size = 10000
        self.table = [None] * self.size

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self._hash(key)
        if self.table[index] is None:
            self.table[index] = [(key, value)]
        else:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    self.table[index][i] = (key, value)
                    break
            else:
                self.table[index].append((key, value))

    def delete(self, key):
        index = self._hash(key)
        if self.table[index]:
            for i, (k, v) in enumerate(self.table[index]):
                if k == key:
                    del self.table[index][i]
                    break

    def get(self, key):
        index = self._hash(key)
        if self.table[index]:
            for k, v in self.table[index]:
                if k == key:
                    return v
        return None
```

**解析：** 哈希表可以通过数组实现，使用哈希函数计算键的哈希值，并存储对应的值。

#### 19. 设计一个缓存

**题目描述：** 请实现一个LRU缓存。

**答案：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
```

**解析：** LRU缓存可以使用OrderedDict实现，通过移动键到字典的末尾来更新最近使用时间。

#### 20. 设计一个栈

**题目描述：** 请实现一个栈，支持常规的push、pop和peek操作。

**答案：**

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.items:
            return None
        return self.items.pop()

    def peek(self):
        if not self.items:
            return None
        return self.items[-1]
```

**解析：** 栈可以通过列表实现，使用append和pop方法实现push和pop操作。

#### 21. 设计一个队列

**题目描述：** 请实现一个队列，支持常规的enqueue、dequeue和peek操作。

**答案：**

```python
from collections import deque

class Queue:
    def __init__(self):
        self.queue = deque()

    def enqueue(self, item):
        self.queue.append(item)

    def dequeue(self):
        if not self.queue:
            return None
        return self.queue.popleft()

    def peek(self):
        if not self.queue:
            return None
        return self.queue[0]
```

**解析：** 队列可以使用deque实现，使用append和popleft方法实现enqueue和dequeue操作。

#### 22. 设计一个优先级队列

**题目描述：** 请实现一个优先级队列，支持插入和删除具有最高优先级的元素。

**答案：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def insert(self, item, priority):
        heapq.heappush(self.heap, (-priority, item))

    def delete_max(self):
        return heapq.heappop(self.heap)[1]
```

**解析：** 优先级队列可以使用heapq实现，使用负优先级来实现最高优先级的删除。

#### 23. 设计一个双向队列

**题目描述：** 请实现一个双向队列，支持在头部和尾部添加和删除元素。

**答案：**

```python
from collections import deque

class DoublyQueue:
    def __init__(self):
        self.queue = deque()

    def append(self, value):
        self.queue.append(value)

    def appendleft(self, value):
        self.queue.appendleft(value)

    def pop(self):
        return self.queue.pop()

    def popleft(self):
        return self.queue.popleft()
```

**解析：** 双向队列可以使用deque实现，支持在头部和尾部添加和删除元素。

#### 24. 设计一个优先级栈

**题目描述：** 请实现一个优先级栈，支持常规的push、pop和peek操作。

**答案：**

```python
import heapq

class PriorityQueueStack:
    def __init__(self):
        self.heap = []

    def push(self, item, priority):
        heapq.heappush(self.heap, (-priority, item))

    def pop(self):
        return heapq.heappop(self.heap)[1]

    def peek(self):
        if self.heap:
            return -self.heap[0][0]
        return None
```

**解析：** 优先级栈可以使用heapq实现，通过存储负优先级来实现最高优先级的弹出。

#### 25. 设计一个位运算栈

**题目描述：** 请实现一个使用位运算的栈，支持push、pop和peek操作。

**答案：**

```python
class BitStack:
    def __init__(self):
        self.stack = 0

    def push(self, x):
        self.stack |= (1 << x)

    def pop(self):
        for i in range(31, -1, -1):
            if (self.stack >> i) & 1:
                self.stack ^= (1 << i)
                return i
        return -1

    def peek(self):
        for i in range(31, -1, -1):
            if (self.stack >> i) & 1:
                return i
        return -1
```

**解析：** 使用位运算可以实现栈的操作，通过位操作来存储和检索栈顶元素。

#### 26. 设计一个堆栈

**题目描述：** 请实现一个堆栈，支持push、pop和peek操作。

**答案：**

```python
class Stack:
    def __init__(self):
        self.stack = []

    def push(self, x):
        self.stack.append(x)

    def pop(self):
        if not self.stack:
            return -1
        return self.stack.pop()

    def peek(self):
        if not self.stack:
            return -1
        return self.stack[-1]
```

**解析：** 堆栈可以通过列表实现，使用append和pop方法实现push和pop操作。

#### 27. 设计一个循环队列

**题目描述：** 请实现一个循环队列，支持常规的enqueue、dequeue和peek操作。

**答案：**

```python
from collections import deque

class CircularQueue:
    def __init__(self, k):
        self.queue = deque(maxlen=k)

    def enqueue(self, value):
        self.queue.append(value)

    def dequeue(self):
        if not self.queue:
            return -1
        return self.queue.popleft()

    def peek(self):
        if not self.queue:
            return -1
        return self.queue[0]
```

**解析：** 循环队列可以使用deque实现，通过设置最大长度来模拟循环队列的行为。

#### 28. 设计一个哈希栈

**题目描述：** 请实现一个使用哈希表的栈，支持常规的push、pop和peek操作。

**答案：**

```python
class HashStack:
    def __init__(self):
        self.stack = []
        self.hash = {}

    def push(self, x):
        self.stack.append(x)
        self.hash[x] = len(self.stack) - 1

    def pop(self):
        if not self.stack:
            return -1
        x = self.stack.pop()
        del self.hash[x]
        return x

    def peek(self):
        if not self.stack:
            return -1
        return self.stack[-1]
```

**解析：** 哈希栈可以使用哈希表来存储元素的位置，以支持快速访问。

#### 29. 设计一个堆

**题目描述：** 请实现一个小顶堆，支持常规的insert和extract_min操作。

**答案：**

```python
import heapq

class MinHeap:
    def __init__(self):
        self.heap = []

    def insert(self, val):
        heapq.heappush(self.heap, val)

    def extract_min(self):
        return heapq.heappop(self.heap)
```

**解析：** 堆可以使用heapq实现，使用小顶堆来维护元素。

#### 30. 设计一个平衡二叉树

**题目描述：** 请实现一个平衡二叉树，支持插入和删除操作。

**答案：**

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def insert(self, root, key):
        if not root:
            return TreeNode(key)
        elif key < root.val:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))
        balance = self.get_balance(root)

        if balance > 1 and key < root.left.val:
            return self.right_rotate(root)
        if balance < -1 and key > root.right.val:
            return self.left_rotate(root)
        if balance > 1 and key > root.left.val:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
        if balance < -1 and key < root.right.val:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)

        return root

    def delete(self, root, key):
        if not root:
            return root
        elif key < root.val:
            root.left = self.delete(root.left, key)
        elif key > root.val:
            root.right = self.delete(root.right, key)
        else:
            if root.left is None:
                temp = root.right
                root = None
                return temp
            elif root.right is None:
                temp = root.left
                root = None
                return temp

        root.height = 1 + max(self.get_height(root.left), self.get_height(root.right))
        balance = self.get_balance(root)

        if balance > 1 and self.get_balance(root.left) >= 0:
            return self.right_rotate(root)
        if balance < -1 and self.get_balance(root.right) <= 0:
            return self.left_rotate(root)
        if balance > 1 and self.get_balance(root.left) < 0:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
        if balance < -1 and self.get_balance(root.right) > 0:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)

        return root

    def left_rotate(self, z):
        y = z.right
        T2 = y.left

        y.left = z
        z.right = T2

        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))

        return y

    def right_rotate(self, y):
        x = y.left
        T2 = x.right

        x.right = y
        y.left = T2

        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))

        return x

    def get_height(self, root):
        if not root:
            return 0
        return root.height

    def get_balance(self, root):
        if not root:
            return 0
        return self.get_height(root.left) - self.get_height(root.right)
```

**解析：** 平衡二叉树（AVL树）通过维护树的高度平衡来实现高效的插入和删除操作。通过左旋转和右旋转来保持树的高度平衡。

