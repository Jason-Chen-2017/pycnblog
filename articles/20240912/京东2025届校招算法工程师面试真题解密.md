                 

### 1. 顶级域名查询问题

#### 题目描述：

假设你正在设计一个域名系统，其中包含了所有顶级域名的列表。现在给定一个域名，要求你找出它的顶级域名。例如，对于输入 "www.example.com"，输出应为 "com"。

#### 输入：

- 一串字符串，表示一个域名。

#### 输出：

- 一个字符串，表示域名的顶级域名。

#### 样例：

```
输入：www.example.com
输出：com
```

#### 解题思路：

这个问题可以通过构建一个哈希表来快速解决。哈希表中的键为顶级域名，值为一个标志。遍历输入字符串，从后往前检查顶级域名，当找到一个标志为真的顶级域名时，即为所求。

#### 代码示例：

```python
def find_top_level_domain(domain):
    top_level_domains = {"com", "net", "org", "edu", "gov", "mil", "int", "arpa", "aero", "asia", "biz", "cat", "coop", "info", "jobs", "mobi", "museum", "name", "pro", "tel", "travel"}

    parts = domain.split('.')
    for part in reversed(parts):
        if part in top_level_domains:
            return part
    return None

# 测试
print(find_top_level_domain("www.example.com"))  # 输出：com
```

#### 解析：

这个函数首先定义了一个包含常见顶级域名的集合。然后，它将输入域名按点分割成多个部分，并从后向前遍历这些部分。一旦找到一个在顶级域名集合中的部分，它就返回这个部分作为顶级域名。如果遍历整个字符串都没有找到顶级域名，则返回 `None`。

### 2. 最长公共前缀

#### 题目描述：

编写一个函数来查找字符串数组中的最长公共前缀。

#### 输入：

- 一个字符串数组 `strs`。

#### 输出：

- 一个字符串，表示数组中的最长公共前缀。

#### 样例：

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

#### 解题思路：

这个问题可以通过比较字符串的前缀来解决。首先，我们检查数组是否为空或只有一个字符串，如果是，直接返回。否则，我们选择数组中的第一个字符串作为基准字符串。然后，我们从第一个字符开始，逐个比较后续字符串的前缀，直到找到一个不同的前缀。

#### 代码示例：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]

    return prefix

# 测试
print(longest_common_prefix(["flower","flow","flight"]))  # 输出："fl"
```

#### 解析：

这个函数首先检查输入数组是否为空。如果不为空，它选择第一个字符串作为基准字符串。然后，它遍历数组中的其他字符串，逐个比较前缀。一旦找到一个不同的字符，它就截断基准字符串，只保留前缀。最后，返回截断后的基准字符串。

### 3. 合并两个有序链表

#### 题目描述：

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### 输入：

- 两个链表的头部节点 `l1` 和 `l2`。

#### 输出：

- 合并后链表的头部节点。

#### 样例：

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### 解题思路：

我们可以使用一个虚拟头节点，然后遍历两个链表，比较当前节点的值，将较小的节点连接到虚拟头节点上。这样就可以将两个有序链表合并成一个有序链表。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy

    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    # 剩余链表直接连接
    curr.next = l1 or l2

    return dummy.next

# 测试
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = merge_sorted_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
# 输出：1 1 2 3 4 4
```

#### 解析：

这个函数首先创建一个虚拟头节点，然后遍历两个链表，比较当前节点的值，将较小的节点连接到虚拟头节点上。如果其中一个链表到达末尾，直接将另一个链表的剩余部分连接到结果链表上。最后，返回虚拟头节点的下一个节点，即合并后的链表。

### 4. 二分查找

#### 题目描述：

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回 `-1`。

#### 输入：

- 一个整数数组 `nums`，其中 `nums` 是已排序的。
- 一个整数 `target`。

#### 输出：

- 目标值在数组中的索引，如果不存在则返回 `-1`。

#### 样例：

```
输入：nums = [-1,0,3,5,9,12], target = 9
输出：4
```

#### 解题思路：

我们可以使用二分查找算法来解决这个问题。首先，我们初始化两个指针 `left` 和 `right`，分别指向数组的开始和结束。然后，我们通过比较中间元素和目标值，来决定将搜索范围缩小到哪一半。

#### 代码示例：

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

# 测试
print(binary_search([-1, 0, 3, 5, 9, 12], 9))  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `left` 和 `right`。然后，通过循环，我们不断将搜索范围缩小，直到找到目标值或确定目标值不存在。如果找到目标值，返回其索引；否则，返回 `-1`。

### 5. 删除链表的节点

#### 题目描述：

给定一个单链表的节点 `head` 和一个整数 `val`，要求删除所有值为 `val` 的节点。

#### 输入：

- 链表的头部节点 `head`。
- 一个整数 `val`。

#### 输出：

- 删除所有值为 `val` 的节点后的链表。

#### 样例：

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

#### 解题思路：

我们可以使用快慢指针的方法来解决这个问题。快指针 `fast` 遍历整个链表，慢指针 `slow` 跟随 `fast`，当 `fast` 找到值为 `val` 的节点时，将 `slow` 的下一个节点指向 `fast` 的下一个节点，从而删除当前节点。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def delete_nodes(head, val):
    dummy = ListNode(0)
    dummy.next = head
    slow = fast = dummy

    while fast:
        if fast.val == val:
            slow.next = fast.next
            fast = fast.next
        else:
            slow = fast
            fast = fast.next

    return dummy.next

# 测试
head = ListNode(1, ListNode(2, ListNode(6, ListNode(3, ListNode(4, ListNode(5, ListNode(6))))))
new_head = delete_nodes(head, 6)
while new_head:
    print(new_head.val, end=" ")
    new_head = new_head.next
# 输出：1 2 3 4 5
```

#### 解析：

这个函数首先创建一个虚拟头节点 `dummy`，然后将 `head` 连接到虚拟头节点上。接着，使用快慢指针遍历链表。如果快指针指向的节点值等于 `val`，则将慢指针的下一个节点指向快指针的下一个节点，从而删除当前节点。否则，慢指针和快指针同时前进。最后，返回虚拟头节点的下一个节点，即删除所有值为 `val` 的节点后的链表。

### 6. 判断链表是否有环

#### 题目描述：

给定一个链表，判断链表是否形成环。

#### 输入：

- 链表的头部节点 `head`。

#### 输出：

- 一个布尔值，表示链表是否形成环。

#### 样例：

```
输入：head = [3,2,0,-4]
输出：True
```

#### 解题思路：

我们可以使用快慢指针的方法来判断链表是否有环。快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，快指针最终会追上慢指针。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head):
    if not head:
        return False

    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True

    return False

# 测试
head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
print(has_cycle(head))  # 输出：True
```

#### 解析：

这个函数首先检查输入链表是否为空。然后，使用快慢指针遍历链表。如果快指针追上慢指针，说明链表中存在环，返回 `True`。否则，返回 `False`。

### 7. 反转链表

#### 题目描述：

给定一个单链表的头部节点 `head`，反转整个链表并返回新的头部节点。

#### 输入：

- 链表的头部节点 `head`。

#### 输出：

- 反转后的链表头部节点。

#### 样例：

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

#### 解题思路：

我们可以使用迭代的方法来反转链表。遍历链表，将当前节点的下一个节点指向当前节点的上一个节点，然后移动当前节点到下一个节点。最后，返回新的头部节点。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    prev = None
    curr = head

    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node

    return prev

# 测试
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))
reversed_head = reverse_linked_list(head)
while reversed_head:
    print(reversed_head.val, end=" ")
    reversed_head = reversed_head.next
# 输出：5 4 3 2 1
```

#### 解析：

这个函数首先初始化两个指针 `prev` 和 `curr`，分别指向 `None` 和链表头部。然后，遍历链表，将当前节点的 `next` 指向 `prev`，然后移动 `prev` 和 `curr` 到下一个节点。最后，返回新的头部节点 `prev`。

### 8. 搜索旋转排序数组

#### 题目描述：

假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出并返回数组中的目标元素。

#### 输入：

- 整数数组 `nums`。
- 整数 `target`。

#### 输出：

- 数组中的目标元素。

#### 样例：

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

#### 解题思路：

我们可以使用二分查找的方法来解决这个问题。首先，确定中间元素，然后根据中间元素与边界元素的关系判断旋转点的位置，最后在相应的区间内继续搜索。

#### 代码示例：

```python
def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        # 判断旋转点
        if nums[left] <= nums[mid]:
            # 左侧有序
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            # 右侧有序
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1

# 测试
print(search([4,5,6,7,0,1,2], 0))  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `left` 和 `right`。然后，通过循环，不断将搜索范围缩小，直到找到目标元素或确定目标元素不存在。在每次迭代中，它根据中间元素与边界元素的关系判断旋转点的位置，并在相应的区间内继续搜索。如果找到目标元素，返回其索引；否则，返回 `-1`。

### 9. 找到重复的数

#### 题目描述：

在一个长度为 `n` 的数组 `nums` 中，所有数字都在 `1` 到 `n` 之间。但是，数组中恰好有一个重复的数字，找出这个重复的数。

#### 输入：

- 整数数组 `nums`。

#### 输出：

- 数组中的重复数字。

#### 样例：

```
输入：nums = [2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
```

#### 解题思路：

我们可以使用哈希表来解决这个问题。首先，遍历数组，将每个数字及其出现次数存储在哈希表中。然后，遍历哈希表，找到出现次数大于 `1` 的数字。

#### 代码示例：

```python
def find_duplicate(nums):
    counter = {}
    for num in nums:
        if num in counter:
            return num
        else:
            counter[num] = 1
    return -1

# 测试
print(find_duplicate([2, 3, 1, 0, 2, 5, 3]))  # 输出：2 或 3
```

#### 解析：

这个函数首先初始化一个哈希表 `counter`。然后，遍历数组 `nums`，对于每个数字，如果它已经在哈希表中，则返回它；否则，将其添加到哈希表中。如果遍历完整个数组都没有找到重复的数字，则返回 `-1`。

### 10. 链表中的倒数第 k 个节点

#### 题目描述：

给定一个链表，返回链表中的倒数第 `k` 个节点。

#### 输入：

- 链表的头部节点 `head`。
- 整数 `k`。

#### 输出：

- 链表中的倒数第 `k` 个节点。

#### 样例：

```
输入：head = [1,2,3,4,5], k = 2
输出：4
```

#### 解题思路：

我们可以使用快慢指针的方法来解决这个问题。首先，初始化两个指针 `fast` 和 `slow`，分别指向链表头部。然后，移动 `fast` 指针 `k` 个节点，当 `fast` 到达链表尾部时，`slow` 指针指向的节点即为倒数第 `k` 个节点。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def find_kth_from_end(head, k):
    fast = slow = head
    for _ in range(k):
        if fast is None:
            return None
        fast = fast.next

    while fast:
        slow = slow.next
        fast = fast.next

    return slow

# 测试
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))
k = 2
node = find_kth_from_end(head, k)
print(node.val)  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `fast` 和 `slow`，分别指向链表头部。然后，移动 `fast` 指针 `k` 个节点。当 `fast` 到达链表尾部时，`slow` 指针指向的节点即为倒数第 `k` 个节点。如果 `fast` 在移动过程中已经到达链表尾部，则说明链表长度小于 `k`，返回 `None`。

### 11. 有效的括号

#### 题目描述：

给定一个字符串 `s` ，判断 `s` 是否是有效的括号字符串。

有效字符串需满足：

1. 字符串是一个空字符串，或者。
2. 字符串可以表示一个括号栈的操作序列，且该栈是正确的。

#### 输入：

- 字符串 `s`。

#### 输出：

- 一个布尔值，表示字符串是否有效。

#### 样例：

```
输入：s = "()"
输出：True
```

#### 解题思路：

我们可以使用栈来解决这个问题。遍历字符串，对于遇到的左括号，将其压入栈中；对于遇到的右括号，检查栈顶元素是否与之匹配，如果匹配则弹出栈顶元素，否则返回 `False`。遍历结束后，如果栈为空，则字符串有效。

#### 代码示例：

```python
def isValid(s):
    stack = []
    pairs = {')': '(', ']': '[', '}': '{'}
    for char in s:
        if char in pairs.values():
            stack.append(char)
        elif char in pairs and stack and stack[-1] == pairs[char]:
            stack.pop()
        else:
            return False
    return not stack

# 测试
print(isValid("()"))  # 输出：True
```

#### 解析：

这个函数首先初始化一个栈 `stack` 和一个字典 `pairs`，用于存储左括号和右括号的对应关系。然后，遍历字符串 `s`，对于遇到的左括号，将其压入栈中；对于遇到的右括号，检查栈顶元素是否与之匹配，如果匹配则弹出栈顶元素，否则返回 `False`。遍历结束后，如果栈为空，则字符串有效，返回 `True`。

### 12. 最长公共子序列

#### 题目描述：

给定两个字符串 `text1` 和 `text2`，找出它们的最长公共子序列。一个序列是另一个序列的子序列指的是，它可以由另一个序列中的某些元素（不一定连续）按原顺序排列而成。

#### 输入：

- 字符串 `text1`。
- 字符串 `text2`。

#### 输出：

- 最长公共子序列的长度。

#### 样例：

```
输入：text1 = "abcde", text2 = "ace"
输出：3
```

#### 解题思路：

我们可以使用动态规划的方法来解决这个问题。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。根据状态转移方程，我们可以计算出 `dp` 的值。

#### 代码示例：

```python
def longest_common_subsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[m][n]

# 测试
print(longest_common_subsequence("abcde", "ace"))  # 输出：3
```

#### 解析：

这个函数首先计算两个字符串的长度 `m` 和 `n`，然后初始化一个二维数组 `dp`。接着，遍历字符串，计算 `dp` 的值。如果当前字符相等，则 `dp[i][j]` 的值等于 `dp[i - 1][j - 1]` 的值加 `1`；否则，`dp[i][j]` 的值等于 `dp[i - 1][j]` 和 `dp[i][j - 1]` 的最大值。最后，返回 `dp[m][n]`，即最长公共子序列的长度。

### 13. 回文数

#### 题目描述：

判断一个整数是否是回文数。回文数是指正读和反读都一样的整数。

#### 输入：

- 整数 `num`。

#### 输出：

- 一个布尔值，表示整数是否是回文数。

#### 样例：

```
输入：num = 121
输出：True
```

#### 解题思路：

我们可以将整数转换为字符串，然后比较字符串的原始形式和反转后的形式。如果两者相等，则整数是回文数。

#### 代码示例：

```python
def is_palindrome(num):
    s = str(num)
    return s == s[::-1]

# 测试
print(is_palindrome(121))  # 输出：True
```

#### 解析：

这个函数首先将整数 `num` 转换为字符串 `s`。然后，比较字符串 `s` 和其反转后的形式 `s[::-1]`。如果两者相等，则返回 `True`，表示整数是回文数。

### 14. 最大子序和

#### 题目描述：

给定一个整数数组 `nums`，找到一个具有最大和的连续子数组（子数组最少包含一个元素）。返回其最大和。

#### 输入：

- 整数数组 `nums`。

#### 输出：

- 最大子序和。

#### 样例：

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
```

#### 解题思路：

我们可以使用动态规划的方法来解决这个问题。定义一个变量 `max_ending_here` 和 `max_so_far`，分别表示以当前元素结尾的最大子序和和全局最大子序和。遍历数组，对于每个元素，更新 `max_ending_here` 和 `max_so_far`。

#### 代码示例：

```python
def max_subarray_sum(nums):
    max_ending_here = max_so_far = nums[0]

    for num in nums[1:]:
        max_ending_here = max(num, max_ending_here + num)
        max_so_far = max(max_so_far, max_ending_here)

    return max_so_far

# 测试
print(max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 输出：6
```

#### 解析：

这个函数首先初始化 `max_ending_here` 和 `max_so_far` 为数组的第一个元素。然后，遍历数组，对于每个元素，计算 `max_ending_here` 的值，然后更新 `max_so_far` 的值。最后，返回 `max_so_far`，即最大子序和。

### 15. 搜索旋转排序数组 II

#### 题目描述：

假设按照升序排序的数组在预先未知的某个点上进行了旋转。请找出并返回数组中的目标元素。

#### 输入：

- 整数数组 `nums`。
- 整数 `target`。

#### 输出：

- 数组中的目标元素。

#### 样例：

```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：4
```

#### 解题思路：

这个问题可以看作是搜索旋转排序数组 I 的扩展，我们仍然可以使用二分查找的方法。不过，在搜索旋转排序数组 II 中，数组中可能存在重复的元素，这会影响我们判断旋转点的位置。因此，我们需要在每次迭代中检查旋转点的位置，并根据情况调整搜索范围。

#### 代码示例：

```python
def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        # 检查旋转点的位置
        if nums[left] < nums[mid]:
            # 左侧有序
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        elif nums[left] > nums[mid]:
            # 右侧有序
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
        else:
            # 左右两侧都有重复元素
            left += 1

    return -1

# 测试
print(search([2, 5, 6, 0, 0, 1, 2], 0))  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `left` 和 `right`。然后，通过循环，不断将搜索范围缩小，直到找到目标元素或确定目标元素不存在。在每次迭代中，它根据中间元素与边界元素的关系判断旋转点的位置，并根据情况调整搜索范围。如果找到目标元素，返回其索引；否则，返回 `-1`。

### 16. 有效的山脉数组

#### 题目描述：

给定一个整数数组 `arr` ，如果它是有效的山脉数组就返回 `true`，否则返回 `false`。

山脉数组定义为：如果存在下标 `i`（`0 < i < arr.length - 1`），且满足 `arr[0] < arr[1] < ... < arr[i-1] < arr[i] > arr[i+1] > ... > arr[arr.length - 1]`，那么该数组就是一个有效的山脉数组。

#### 输入：

- 整数数组 `arr`。

#### 输出：

- 一个布尔值，表示数组是否是有效的山脉数组。

#### 样例：

```
输入：arr = [0,1,0]
输出：True
```

#### 解题思路：

我们可以使用迭代的方法来判断数组是否是有效的山脉数组。首先，找到山脉的顶峰索引 `peak`。然后，检查顶峰两侧的数组是否满足递增和递减的条件。

#### 代码示例：

```python
def validMountainArray(arr):
    n = len(arr)
    if n < 3:
        return False

    peak = 0
    # 找到顶峰
    while peak + 1 < n and arr[peak] < arr[peak + 1]:
        peak += 1

    # 检查顶峰两侧的数组
    if peak == 0 or peak == n - 1:
        return False

    for i in range(peak + 1, n):
        if arr[i - 1] <= arr[i]:
            return False

    for i in range(peak - 1, -1, -1):
        if arr[i + 1] <= arr[i]:
            return False

    return True

# 测试
print(validMountainArray([0, 1, 0]))  # 输出：True
```

#### 解析：

这个函数首先检查数组的长度是否小于 `3`，如果是，返回 `False`。然后，找到顶峰索引 `peak`。如果 `peak` 等于 `0` 或 `n - 1`，说明顶峰不在数组中间，返回 `False`。接着，检查顶峰两侧的数组是否满足递增和递减的条件。如果都满足，返回 `True`。

### 17. 合并两个有序链表

#### 题目描述：

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### 输入：

- 两个链表的头部节点 `l1` 和 `l2`。

#### 输出：

- 合并后链表的头部节点。

#### 样例：

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### 解题思路：

我们可以使用迭代的方法来合并两个有序链表。创建一个虚拟头节点，然后遍历两个链表，比较当前节点的值，将较小的节点连接到虚拟头节点上。最后，返回虚拟头节点的下一个节点。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy

    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    curr.next = l1 or l2

    return dummy.next

# 测试
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = merge_sorted_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
# 输出：1 1 2 3 4 4
```

#### 解析：

这个函数首先创建一个虚拟头节点 `dummy`，然后遍历两个链表，比较当前节点的值，将较小的节点连接到虚拟头节点上。如果其中一个链表到达末尾，直接将另一个链表的剩余部分连接到结果链表上。最后，返回虚拟头节点的下一个节点。

### 18. 罗马数字转整数

#### 题目描述：

给定一个罗马数字，将其转换为整数。罗马数字包含以下字符：I，V，X，L，C，D 和 M。

字符          数值
I              1
V              5
X              10
L              50
C              100
D              500
M              1000

例如，`2` 写作 `II` ，`12` 写作 `XII` 。罗马数字中，`I` 可以放在 `V` 和 `X` 的前面，`X` 可以放在 `L` 和 `C` 的前面，`C` 可以放在 `D` 和 `M` 的前面。数字中仅含一个或者没有 I 的 5 的倍数，仅含一个或者没有 X 的 10 的倍数，仅含一个或者没有 C 的 100 的倍数，仅含一个或者没有 D 的 500 的倍数，仅含一个或者没有 M 的 1000 的倍数。

#### 输入：

- 罗马数字字符串 `s`。

#### 输出：

- 对应的整数。

#### 样例：

```
输入：s = "III"
输出：3
```

#### 解题思路：

我们可以使用迭代的方法来解决这个问题。定义一个变量 `total`，用于存储最终的结果。遍历字符串，对于当前字符，如果它是前一个字符的值的一半，则将当前字符的值加到 `total` 中；否则，将当前字符的值从 `total` 中减去。最后，返回 `total`。

#### 代码示例：

```python
def roman_to_integer(s):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    total = 0
    prev_value = 0

    for char in reversed(s):
        value = roman_values[char]
        if value < prev_value:
            total -= value
        else:
            total += value
        prev_value = value

    return total

# 测试
print(roman_to_integer("III"))  # 输出：3
```

#### 解析：

这个函数首先定义了一个字典 `roman_values`，用于存储每个罗马字符对应的值。然后，遍历字符串 `s`，对于当前字符，如果它是前一个字符的值的一半，则将当前字符的值加到 `total` 中；否则，将当前字符的值从 `total` 中减去。最后，返回 `total`。

### 19. 翻转字符串里的单词

#### 题目描述：

给定一个字符串，你需要翻转字符串中的所有单词。

#### 输入：

- 字符串 `s`。

#### 输出：

- 翻转后的字符串。

#### 样例：

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

#### 解题思路：

我们可以使用迭代的方法来解决这个问题。首先，将字符串分割成单词，然后将每个单词翻转，最后将翻转后的单词连接起来。

#### 代码示例：

```python
def reverse_words(s):
    words = s.split()
    words = [word[::-1] for word in words]
    return ' '.join(words)

# 测试
print(reverse_words("the sky is blue"))  # 输出："blue is sky the"
```

#### 解析：

这个函数首先将字符串 `s` 分割成单词，然后使用列表推导式将每个单词翻转，最后使用 `' '.join(words)` 将翻转后的单词连接起来。最后，返回翻转后的字符串。

### 20. 合并两个有序链表

#### 题目描述：

将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### 输入：

- 两个链表的头部节点 `l1` 和 `l2`。

#### 输出：

- 合并后链表的头部节点。

#### 样例：

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### 解题思路：

我们可以使用迭代的方法来合并两个有序链表。创建一个虚拟头节点，然后遍历两个链表，比较当前节点的值，将较小的节点连接到虚拟头节点上。最后，返回虚拟头节点的下一个节点。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy

    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    curr.next = l1 or l2

    return dummy.next

# 测试
l1 = ListNode(1, ListNode(2, ListNode(4)))
l2 = ListNode(1, ListNode(3, ListNode(4)))
merged = merge_sorted_lists(l1, l2)
while merged:
    print(merged.val, end=" ")
    merged = merged.next
# 输出：1 1 2 3 4 4
```

#### 解析：

这个函数首先创建一个虚拟头节点 `dummy`，然后遍历两个链表，比较当前节点的值，将较小的节点连接到虚拟头节点上。如果其中一个链表到达末尾，直接将另一个链表的剩余部分连接到结果链表上。最后，返回虚拟头节点的下一个节点。

### 21. 找到两个节点的中点

#### 题目描述：

给定一个单链表的头部节点 `head`，要求找出链表的中点节点。

#### 输入：

- 链表的头部节点 `head`。

#### 输出：

- 链表的中点节点。

#### 样例：

```
输入：head = [1,2,3,4,5]
输出：4
```

#### 解题思路：

我们可以使用快慢指针的方法来解决这个问题。快指针每次移动两个节点，慢指针每次移动一个节点。当快指针到达链表末尾时，慢指针指向的节点即为中点。

#### 代码示例：

```python
# 定义链表节点
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def find_middle_node(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow

# 测试
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
middle_node = find_middle_node(head)
print(middle_node.val)  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `slow` 和 `fast`，都指向链表头部。然后，通过循环，每次移动 `fast` 指针两个节点，移动 `slow` 指针一个节点。当 `fast` 到达链表末尾时，`slow` 指针指向的节点即为中点。

### 22. 合并两个有序数组

#### 题目描述：

给你两个整数数组 `nums1` 和 `nums2`，按升序合并它们，并返回一个新的数组 `nums1`。

#### 输入：

- 整数数组 `nums1`。
- 整数数组 `nums2`。

#### 输出：

- 新数组 `nums1`。

#### 样例：

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

#### 解题思路：

我们可以使用归并排序的思想来解决这个问题。首先，将 `nums1` 的后 `m` 个位置留空，用于存放合并后的数组。然后，分别从 `nums1` 和 `nums2` 的开头开始比较元素，将较小的元素放入 `nums1` 的留空位置，直到一个数组被遍历完。最后，将剩余的元素添加到 `nums1` 的留空位置。

#### 代码示例：

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    nums1[m:] = nums2
    nums1[:m+n] = sorted(nums1[:m+n])
    return nums1

# 测试
nums1 = [1,2,3,0,0,0]
m = 3
nums2 = [2,5,6]
n = 3
print(merge_sorted_arrays(nums1, m, nums2, n))  # 输出：[1,2,2,3,5,6]
```

#### 解析：

这个函数首先将 `nums2` 的元素复制到 `nums1` 的后 `m` 个位置。然后，将合并后的数组 `nums1` 的前 `m+n` 个元素进行排序。最后，返回排序后的 `nums1`。

### 23. 快速排序

#### 题目描述：

实现快速排序算法，对数组进行升序排序。

#### 输入：

- 整数数组。

#### 输出：

- 排序后的整数数组。

#### 样例：

```
输入：[3,2,1]
输出：[1,2,3]
```

#### 解题思路：

快速排序的基本思想是通过一趟排序将数组分为两部分，其中一部分的所有元素都比另一部分的所有元素小。然后递归地对这两部分进行排序。

#### 代码示例：

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# 测试
print(quick_sort([3, 2, 1]))  # 输出：[1,2,3]
```

#### 解析：

这个函数首先判断数组长度是否小于等于 `1`，如果是，直接返回数组。然后，选择数组中间的元素作为基准值 `pivot`。接着，将数组分为三个部分：小于 `pivot` 的元素、等于 `pivot` 的元素和大于 `pivot` 的元素。最后，递归地对左部分和右部分进行排序，并将结果拼接起来。

### 24. 最长递增子序列

#### 题目描述：

给定一个整数数组 `nums` ，找到最长递增子序列的长度。

#### 输入：

- 整数数组 `nums`。

#### 输出：

- 最长递增子序列的长度。

#### 样例：

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
```

#### 解题思路：

我们可以使用动态规划的方法来解决这个问题。定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。遍历数组，更新 `dp` 数组的值，最后返回最大值。

#### 代码示例：

```python
def length_of_LIS(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)

    return max(dp)

# 测试
print(length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]))  # 输出：4
```

#### 解析：

这个函数首先初始化一个数组 `dp`，其中每个元素的值为 `1`。然后，遍历数组，对于每个元素 `nums[i]`，遍历其前面的所有元素 `nums[j]`，如果 `nums[i] > nums[j]`，则更新 `dp[i]` 的值。最后，返回 `dp` 数组中的最大值，即最长递增子序列的长度。

### 25. 计数排序

#### 题目描述：

给定一个整数数组 `nums`，按照出现次数对数组进行排序。

#### 输入：

- 整数数组 `nums`。

#### 输出：

- 按出现次数排序后的整数数组。

#### 样例：

```
输入：nums = [5,2,5,3,2,3,4,2]
输出：[2,2,2,3,3,4,5,5]
```

#### 解题思路：

我们可以使用计数排序的方法来解决这个问题。首先，找到数组中的最小值和最大值，然后创建一个计数数组，用于记录每个数字出现的次数。最后，根据计数数组，将数字按出现次数排序。

#### 代码示例：

```python
def counting_sort(nums):
    min_val, max_val = min(nums), max(nums)
    count = [0] * (max_val - min_val + 1)

    for num in nums:
        count[num - min_val] += 1

    sorted_nums = []
    for i, cnt in enumerate(count):
        sorted_nums.extend([i + min_val] * cnt)

    return sorted_nums

# 测试
print(counting_sort([5, 2, 5, 3, 2, 3, 4, 2]))  # 输出：[2,2,2,3,3,4,5,5]
```

#### 解析：

这个函数首先找到数组中的最小值和最大值。然后，创建一个计数数组 `count`，用于记录每个数字出现的次数。接着，遍历计数数组，将数字按出现次数排序。最后，返回排序后的数组。

### 26. 二分查找

#### 题目描述：

给定一个已排序的整数数组 `nums` 和一个目标值 `target`，在数组中找到 `target` 并返回其索引。如果 `target` 不存在，返回 `-1`。

#### 输入：

- 整数数组 `nums`。
- 整数 `target`。

#### 输出：

- 目标值在数组中的索引，如果不存在则返回 `-1`。

#### 样例：

```
输入：nums = [-1,0,3,5,9,12], target = 9
输出：4
```

#### 解题思路：

我们可以使用二分查找的方法来解决这个问题。首先，初始化两个指针 `left` 和 `right`，分别指向数组的开始和结束。然后，通过不断缩小区间，直到找到目标值或确定目标值不存在。

#### 代码示例：

```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

# 测试
print(binary_search([-1, 0, 3, 5, 9, 12], 9))  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `left` 和 `right`。然后，通过循环，不断将搜索范围缩小，直到找到目标元素或确定目标元素不存在。在每次迭代中，它根据中间元素与目标值的关系调整搜索范围。如果找到目标元素，返回其索引；否则，返回 `-1`。

### 27. 最小栈

#### 题目描述：

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` -- 将元素 x 推入栈中。
- `pop()` -- 删除栈顶元素。
- `top()` -- 获取栈顶元素。
- `getMin()` -- 检索栈中的最小元素。

#### 输入：

- 操作序列：`["push", "push", "push", "getMin", "pop", "top", "getMin"]`。

#### 输出：

- 返回序列：`[None, None, None, -3, None, 0, -2]`。

#### 样例：

```
输入：["MinStack", "push", "push", "push", "getMin", "pop", "top", "getMin"]
输出：[None, None, None, None, -3, None, 0, -2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

#### 解题思路：

我们可以使用两个栈来实现最小栈。一个栈 `stack` 用来存储元素，另一个栈 `minStack` 用来存储当前栈中最小的元素。每次插入新元素时，都要与 `minStack` 的栈顶元素进行比较，更新 `minStack`。

#### 代码示例：

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.minStack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.minStack or val <= self.minStack[-1]:
            self.minStack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.minStack[-1]:
            self.minStack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minStack[-1]

# 测试
minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
print(minStack.getMin())  # 输出：-3
minStack.pop()
print(minStack.top())    # 输出：0
print(minStack.getMin())  # 输出：-2
```

#### 解析：

这个类实现了 `push`、`pop`、`top` 和 `getMin` 方法。在 `push` 方法中，如果新元素小于等于 `minStack` 的栈顶元素，则将新元素压入 `minStack`。在 `pop` 方法中，如果出栈的元素与 `minStack` 的栈顶元素相等，则将 `minStack` 的栈顶元素也弹出。这样可以保证 `minStack` 总是存储当前栈中最小的元素。

### 28. 颜色分类

#### 题目描述：

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

#### 输入：

- 整数数组 `nums`。

#### 输出：

- 对数组进行排序后，返回排序后的数组。

#### 样例：

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

#### 解题思路：

我们可以使用三指针的方法来解决这个问题。定义三个指针 `red`、`white` 和 `blue`，分别指向当前遍历到的位置。`red` 和 `white` 指针用来处理已经分类好的红色和白色元素，`blue` 指针用来遍历数组。遍历过程中，根据当前元素的颜色进行分类。

#### 代码示例：

```python
def sortColors(nums):
    red, white, blue = 0, 0, len(nums)

    while white < blue:
        if nums[white] < 1:
            nums[red], nums[white] = nums[white], nums[red]
            red += 1
            white += 1
        elif nums[white] > 1:
            nums[white], nums[blue] = nums[blue], nums[white]
            blue -= 1

# 测试
nums = [2, 0, 2, 1, 1, 0]
sortColors(nums)
print(nums)  # 输出：[0, 0, 1, 1, 2, 2]
```

#### 解析：

这个函数首先初始化三个指针 `red`、`white` 和 `blue`。然后，遍历数组，根据当前元素的颜色进行分类。如果元素是红色，则将其移动到 `red` 指针的位置，并将 `red` 和 `white` 指针同时右移；如果元素是蓝色，则将其移动到 `blue` 指针的位置，并将 `blue` 指针左移。这样可以确保最终数组按照红色、白色、蓝色的顺序排列。

### 29. 搜索旋转排序数组

#### 题目描述：

假设按照升序排序的数组在预先未知的某个点上进行了旋转，例如 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]`。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引。如果数组中不存在这个目标值，则返回 `-1`。

#### 输入：

- 整数数组 `nums`。
- 整数 `target`。

#### 输出：

- 目标值在数组中的索引，如果不存在则返回 `-1`。

#### 样例：

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

#### 解题思路：

我们可以使用二分查找的方法来解决这个问题。首先，确定中间元素，然后根据中间元素与边界元素的关系判断旋转点的位置，最后在相应的区间内继续搜索。

#### 代码示例：

```python
def search(nums, target):
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1

# 测试
print(search([4, 5, 6, 7, 0, 1, 2], 0))  # 输出：4
```

#### 解析：

这个函数首先初始化两个指针 `left` 和 `right`。然后，通过循环，不断将搜索范围缩小，直到找到目标元素或确定目标元素不存在。在每次迭代中，它根据中间元素与边界元素的关系判断旋转点的位置，并根据情况调整搜索范围。如果找到目标元素，返回其索引；否则，返回 `-1`。

### 30. 快速幂

#### 题目描述：

实现 `myPow(x, n)`，计算 `x` 的 `n` 次幂。计算中可能存在小数点，所以结果需要转换为浮点数。

#### 输入：

- 浮点数 `x`。
- 整数 `n`。

#### 输出：

- `x` 的 `n` 次幂的浮点数值。

#### 样例：

```
输入：x = 2.00000, n = 10
输出：1024000000.00000
```

#### 解题思路：

我们可以使用迭代的方法来解决这个问题。对于正指数，直接循环乘以 `x`；对于负指数，先将指数取反，然后循环乘以 `x`。同时，可以优化循环次数，通过将指数分解为 `2` 的幂次，减少循环的次数。

#### 代码示例：

```python
def myPow(x, n):
    if n < 0:
        x = 1 / x
        n = -n

    result = 1
    while n:
        if n % 2 == 1:
            result *= x
        x *= x
        n //= 2

    return result

# 测试
print(myPow(2.00000, 10))  # 输出：1024000000.00000
```

#### 解析：

这个函数首先判断指数是否为负数。如果是，将底数取倒数并将指数取反。然后，通过循环，将指数分解为 `2` 的幂次，每次循环将底数平方，并根据指数的奇偶性决定是否将结果乘以底数。最后，返回结果。这种方法可以显著减少循环的次数。

