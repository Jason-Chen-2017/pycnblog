                 

### 腾讯2025社招面试常见问题及答案全攻略：算法与数据结构篇

欢迎阅读本篇博客，本文将针对腾讯2025社招面试中常见的算法和数据结构问题，提供详尽的答案解析和源代码实例。以下是我们整理的典型问题/面试题库：

---

#### 1. 平衡二叉树判定

**题目：** 给定一棵二叉树，请编写一个函数，判断它是否为平衡二叉树。

**答案：** 可以通过递归遍历每个节点，计算其左子树和右子树的高度，如果任意一个子树的高度差大于1，则不是平衡二叉树。

**代码：**

```go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    leftHeight := getHeight(root.Left)
    rightHeight := getHeight(root.Right)
    if abs(leftHeight - rightHeight) > 1 {
        return false
    }
    return isBalanced(root.Left) && isBalanced(root.Right)
}

func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    return max(getHeight(node.Left), getHeight(node.Right)) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

**解析：** 在本题中，我们定义了一个辅助函数 `getHeight` 用于计算二叉树的高度。`isBalanced` 函数通过递归调用 `getHeight`，同时检查任意一个子树的高度差是否大于1，从而判断是否为平衡二叉树。

---

#### 2. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：** 使用哈希表存储数组中的元素及其索引，遍历数组，对于当前元素 `nums[i]`，计算 `target - nums[i]`，若该值在哈希表中存在，则返回 `[i, index]`。

**代码：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, v := range nums {
        complement := target - v
        if j, ok := m[complement]; ok {
            return []int{i, j}
        }
        m[v] = i
    }
    return nil
}
```

**解析：** 在本题中，我们使用一个哈希表 `m` 存储数组中的元素及其索引。遍历数组时，对于每个元素 `v`，我们计算 `target - v` 并检查该值是否在哈希表中。如果存在，则返回当前索引和对应的索引；否则，将 `v` 和其索引添加到哈希表中。

---

#### 3. 逆波兰表达式求值

**题目：** 根据逆波兰表示法，求表达式的值。

**答案：** 使用栈实现，遍历表达式，对于操作数直接入栈，对于运算符，弹出栈顶两个元素进行运算，并将结果入栈。

**代码：**

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = append(stack[:len(stack)-1], a/int64(b))
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(s string) int {
    i, ok := strconv.Atoi(s)
    if !ok {
        panic("invalid integer")
    }
    return i
}
```

**解析：** 在本题中，我们使用一个栈 `stack` 存储中间结果。遍历表达式时，对于操作数直接入栈，对于运算符，弹出栈顶两个元素进行运算，并将结果入栈。最终，栈顶元素即为表达式的值。

---

#### 4. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：** 使用递归或迭代方式，比较两个链表的头节点，选择较小的节点加入新链表，并递归或迭代处理剩余部分。

**代码：**

```go
// 递归方式
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}

// 迭代方式
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    prev := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            prev.Next = l1
            l1 = l1.Next
        } else {
            prev.Next = l2
            l2 = l2.Next
        }
        prev = prev.Next
    }
    if l1 != nil {
        prev.Next = l1
    }
    if l2 != nil {
        prev.Next = l2
    }
    return dummy.Next
}
```

**解析：** 在本题中，我们分别提供了递归和迭代两种实现方式。递归方式通过比较两个链表的头节点，选择较小的节点加入新链表，并递归处理剩余部分。迭代方式使用一个虚拟节点 `dummy`，遍历两个链表，将较小的节点加入新链表，直到处理完所有节点。

---

#### 5. 三数之和

**题目：** 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 使得 `nums[i] + nums[j] + nums[k] == 0` 。请

**答案：** 对数组进行排序，然后使用双指针技术在固定一个元素后，分别从其左右两侧寻找另外两个元素，使得三个元素之和为0。

**代码：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var result [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return result
}
```

**解析：** 在本题中，我们首先对数组进行排序。然后，遍历数组，固定一个元素 `nums[i]`，使用双指针技术在固定元素 `nums[i]` 的左右两侧寻找另外两个元素，使得三个元素之和为0。同时，为了避免重复，当 `nums[i]` 相同且与前一个 `nums[i-1]` 相同时，跳过当前循环。

---

#### 6. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 从第一个字符串开始，依次比较后续字符串的前缀，更新最长公共前缀。

**代码：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix) && j < len(strs[i]); j++ {
            if prefix[j] != strs[i][j] {
                prefix = prefix[:j]
                break
            }
        }
    }
    return prefix
}
```

**解析：** 在本题中，我们首先将第一个字符串作为初始的最长公共前缀。然后，遍历后续字符串，依次比较前缀，如果当前字符串的前缀与最长公共前缀不匹配，则更新最长公共前缀。最后返回最长公共前缀。

---

#### 7. 寻找旋转排序数组中的最小值

**题目：** 已知一个长度为 n 的数组，假设这个数组中的所有数字都已排好序，但在某一点上进行了旋转。例如， `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` 。请编写一个函数来找到并返回数组中的最小元素。

**答案：** 使用二分查找，比较中间元素和两端元素的关系，确定最小元素所在区间。

**代码：**

```go
func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else if nums[mid] < nums[right] {
            right = mid
        } else {
            right--
        }
    }
    return nums[left]
}
```

**解析：** 在本题中，我们使用二分查找，每次将数组分为三部分，比较中间元素和两端元素的关系。如果中间元素大于右侧元素，则最小元素一定在右侧部分；如果中间元素小于右侧元素，则最小元素可能在左侧部分或中间部分；如果中间元素和右侧元素相等，则最小元素可能在右侧部分或左侧部分，因此我们可以将右侧边界向左移动一位。

---

#### 8. 字符串转换大写字母

**题目：** 编写一个函数，将一个字符串转换成大写形式，要求时间复杂度为 O(n)，其中 n 是字符串的长度。

**答案：** 遍历字符串，对于每个字符，将其转换为大写形式。

**代码：**

```go
func toLowerCase(s string) string {
    bytes := []byte(s)
    for i, b := range bytes {
        if b >= 'a' && b <= 'z' {
            bytes[i] = b - 'a' + 'A'
        }
    }
    return string(bytes)
}
```

**解析：** 在本题中，我们首先将字符串转换为字节数组，然后遍历每个字符。如果字符在小写字母范围内，将其转换为对应的大写字母。

---

#### 9. 反转字符串

**题目：** 编写一个函数，实现字符串反转，要求时间复杂度为 O(n)，其中 n 是字符串的长度。

**答案：** 使用两个指针，一个从字符串头部开始，另一个从字符串尾部开始，交换两个指针指向的字符，直到两个指针相遇。

**代码：**

```go
func reverseString(s string) string {
    bytes := []byte(s)
    left, right := 0, len(bytes)-1
    for left < right {
        bytes[left], bytes[right] = bytes[right], bytes[left]
        left++
        right--
    }
    return string(bytes)
}
```

**解析：** 在本题中，我们首先将字符串转换为字节数组，然后使用两个指针从字符串头部和尾部开始，交换两个指针指向的字符，直到两个指针相遇。

---

#### 10. 验证回文串

**题目：** 编写一个函数，判断一个字符串是否为回文串。一个字符串是回文串，当它从后向前读和从前往后读是一样的。

**答案：** 使用两个指针，一个从字符串头部开始，另一个从字符串尾部开始，逐个比较两个指针指向的字符。

**代码：**

```go
func isPalindrome(s string) bool {
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

**解析：** 在本题中，我们使用两个指针从字符串头部和尾部开始，逐个比较两个指针指向的字符。如果两个字符不相等，说明字符串不是回文串。

---

#### 11. 秒杀系统设计

**题目：** 请设计一个秒杀系统，满足以下要求：

- 假设库存为 N，用户数为 M。
- 每个用户只能秒杀一次。
- 秒杀操作为：用户发起请求，系统检测库存是否充足，若充足，扣减库存并返回成功，否则返回失败。

**答案：** 使用分布式锁和乐观锁实现秒杀系统。

**代码：**

```go
// 假设使用 Redis 作为分布式锁
func secKill(productId int, userId int) bool {
    // 获取分布式锁
    lockKey := fmt.Sprintf("secKill:%d", productId)
    if !redis.Lock(lockKey) {
        return false
    }
    defer redis.Unlock(lockKey)

    // 检测库存
    stock := getStock(productId)
    if stock <= 0 {
        return false
    }

    // 扣减库存
    if updateStock(productId, -1) <= 0 {
        return false
    }

    // 记录秒杀记录
    insertSecKillRecord(productId, userId)

    return true
}

func getStock(productId int) int {
    // 查询库存
}

func updateStock(productId int, amount int) int {
    // 扣减库存
}

func insertSecKillRecord(productId int, userId int) {
    // 插入秒杀记录
}
```

**解析：** 在本题中，我们使用 Redis 的分布式锁来保证每个用户只能秒杀一次。首先，获取分布式锁，检测库存是否充足。如果库存充足，则扣减库存并插入秒杀记录。

---

#### 12. 线程池设计

**题目：** 请设计一个线程池，满足以下要求：

- 支持任务提交和线程回收。
- 线程数量不超过 100。
- 支持线程休眠和唤醒。

**答案：** 使用生产者-消费者模式实现线程池。

**代码：**

```go
type ThreadPool struct {
    tasks     chan Task
    workers   []*Worker
    shutdown  chan bool
}

func NewThreadPool() *ThreadPool {
    pool := &ThreadPool{
        tasks:     make(chan Task, 1000),
        workers:   make([]*Worker, 0),
        shutdown:  make(chan bool),
    }
    for i := 0; i < 10; i++ {
        worker := NewWorker(pool.tasks, pool.shutdown)
        pool.workers = append(pool.workers, worker)
        go worker.start()
    }
    return pool
}

func (pool *ThreadPool) Submit(task Task) {
    pool.tasks <- task
}

func (pool *ThreadPool) Shutdown() {
    close(pool.shutdown)
}
```

**解析：** 在本题中，我们使用生产者-消费者模式实现线程池。首先创建线程池，然后启动 10 个工作线程。每个工作线程从任务队列中获取任务并执行。当任务队列中没有任务时，工作线程休眠；当有新任务时，唤醒工作线程。

---

#### 13. 快排实现

**题目：** 请使用快速排序算法对数组进行排序。

**答案：** 快速排序的基本思想是选择一个基准元素，将数组分为两部分，左边的元素都比基准元素小，右边的元素都比基准元素大，然后递归地对两部分进行排序。

**代码：**

```go
func quickSort(arr []int) {
    quickSortHelper(arr, 0, len(arr)-1)
}

func quickSortHelper(arr []int, left int, right int) {
    if left >= right {
        return
    }
    pivot := arr[right]
    i := left
    for j := left; j < right; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[right] = arr[right], arr[i]
    quickSortHelper(arr, left, i-1)
    quickSortHelper(arr, i+1, right)
}
```

**解析：** 在本题中，我们使用递归实现快速排序。首先选择一个基准元素，然后将数组分为两部分，左边的元素都比基准元素小，右边的元素都比基准元素大。然后递归地对两部分进行排序。

---

#### 14. 双指针实现快排

**题目：** 请使用双指针算法实现快速排序。

**答案：** 双指针算法的基本思想是使用两个指针分别从数组的两端开始，一个向前遍历，一个向后遍历，交换不满足条件的元素，直到两个指针相遇。

**代码：**

```go
func quickSort(arr []int) {
    quickSortHelper(arr, 0, len(arr)-1)
}

func quickSortHelper(arr []int, left int, right int) {
    if left >= right {
        return
    }
    pivot := arr[right]
    i, j := left, right-1
    for {
        for i < j && arr[i] < pivot {
            i++
        }
        for i < j && arr[j] > pivot {
            j--
        }
        if i >= j {
            break
        }
        arr[i], arr[j] = arr[j], arr[i]
    }
    arr[i], arr[right] = arr[right], arr[i]
    quickSortHelper(arr, left, i-1)
    quickSortHelper(arr, i+1, right)
}
```

**解析：** 在本题中，我们使用双指针算法实现快速排序。首先选择一个基准元素，然后分别从数组的两端开始，一个向前遍历，一个向后遍历，交换不满足条件的元素，直到两个指针相遇。

---

#### 15. 堆排序实现

**题目：** 请使用堆排序算法对数组进行排序。

**答案：** 堆排序的基本思想是构建一个最大堆，然后依次将堆顶元素与最后一个元素交换，然后调整剩余元素的堆结构，直到堆为空。

**代码：**

```go
func heapSort(arr []int) {
    n := len(arr)
    buildMaxHeap(arr, n)
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, 0, i)
    }
}

func buildMaxHeap(arr []int, n int) {
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, i, n)
    }
}

func heapify(arr []int, i int, n int) {
    largest := i
    left := 2*i + 1
    right := 2*i + 2
    if left < n && arr[left] > arr[largest] {
        largest = left
    }
    if right < n && arr[right] > arr[largest] {
        largest = right
    }
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, largest, n)
    }
}
```

**解析：** 在本题中，我们使用堆排序算法对数组进行排序。首先构建一个最大堆，然后依次将堆顶元素与最后一个元素交换，然后调整剩余元素的堆结构，直到堆为空。

---

#### 16. 动态规划求最大子序和

**题目：** 请使用动态规划算法求最大子序和。

**答案：** 动态规划的基本思想是使用一个数组 `dp` 存储每个位置的最大子序和，状态转移方程为 `dp[i] = max(dp[i-1]+nums[i], nums[i])`。

**代码：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i])
        maxSum = max(maxSum, dp[i])
    }
    return maxSum
}
```

**解析：** 在本题中，我们使用动态规划算法求最大子序和。首先初始化 `maxSum` 和 `dp[0]`，然后遍历数组，更新 `dp[i]` 和 `maxSum`。

---

#### 17. 递归实现斐波那契数列

**题目：** 请使用递归算法实现斐波那契数列。

**答案：** 递归的基本思想是使用递归调用计算斐波那契数列的每一项。

**代码：**

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacci(n-1) + fibonacci(n-2)
}
```

**解析：** 在本题中，我们使用递归算法实现斐波那契数列。首先判断输入的 `n` 是否小于等于1，如果是，则直接返回 `n`；否则，递归调用 `fibonacci(n-1)` 和 `fibonacci(n-2)` 并返回它们的和。

---

#### 18. 循环结构实现斐波那契数列

**题目：** 请使用循环结构实现斐波那契数列。

**答案：** 循环结构的基本思想是使用循环迭代计算斐波那契数列的每一项。

**代码：**

```go
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 在本题中，我们使用循环结构实现斐波那契数列。首先初始化 `a` 和 `b` 为斐波那契数列的第一项和第二项，然后使用循环迭代计算斐波那契数列的每一项。

---

#### 19. 递归实现合并区间

**题目：** 给定一个无序的区间列表，请你合并所有的重叠区间。

**答案：** 递归的基本思想是首先对区间列表进行排序，然后递归合并相邻的区间。

**代码：**

```go
type Interval struct {
    Start int
    End   int
}

func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    var result []Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 在本题中，我们首先对区间列表进行排序，然后使用递归合并相邻的区间。如果当前区间的开始位置大于前一个区间的结束位置，则将当前区间添加到结果中；否则，将当前区间的结束位置更新为与前一个区间的结束位置的最大值。

---

#### 20. 动态规划实现合并区间

**题目：** 给定一个无序的区间列表，请你合并所有的重叠区间。

**答案：** 动态规划的基本思想是使用一个数组 `dp` 存储每个位置的最大区间长度，状态转移方程为 `dp[i] = max(dp[i-1]+nums[i], nums[i])`。

**代码：**

```go
func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    var result []Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 在本题中，我们使用动态规划算法合并所有的重叠区间。首先对区间列表进行排序，然后遍历区间列表，将当前区间的结束位置更新为与前一个区间的结束位置的最大值。

---

#### 21. 递归实现合并区间

**题目：** 给定一个区间列表，请你合并所有重叠的区间。

**答案：** 递归的基本思想是首先对区间列表进行排序，然后递归合并相邻的区间。

**代码：**

```go
type Interval struct {
    Start int
    End   int
}

func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })
    var result []Interval
    for _, interval := range intervals {
        if len(result) == 0 || result[len(result)-1].End < interval.Start {
            result = append(result, interval)
        } else {
            result[len(result)-1].End = max(result[len(result)-1].End, interval.End)
        }
    }
    return result
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 在本题中，我们首先对区间列表进行排序，然后使用递归合并相邻的区间。如果当前区间的开始位置大于前一个区间的结束位置，则将当前区间添加到结果中；否则，将当前区间的结束位置更新为与前一个区间的结束位置的最大值。

---

#### 22. 动态规划求最长公共子序列

**题目：** 给定两个字符串，请编写一个函数，使用动态规划算法求最长公共子序列。

**答案：** 动态规划的基本思想是使用一个二维数组 `dp` 存储子问题的最优解，状态转移方程为 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（当 `s1[i] != s2[j]`）或 `dp[i][j] = dp[i-1][j-1]`（当 `s1[i] == s2[j]`）。

**代码：**

```go
func longestCommonSubsequence(s1 string, s2 string) string {
    n, m := len(s1), len(s2)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[n][m]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 在本题中，我们使用动态规划算法求最长公共子序列。首先初始化一个二维数组 `dp`，然后遍历字符串 `s1` 和 `s2`，更新 `dp` 数组。最后返回 `dp[n][m]`，即最长公共子序列的长度。

---

#### 23. 递归实现最长公共子序列

**题目：** 给定两个字符串，请编写一个函数，使用递归算法求最长公共子序列。

**答案：** 递归的基本思想是定义一个递归函数，当字符串为空时返回空，否则比较字符串的第一个字符，分情况讨论。

**代码：**

```go
func longestCommonSubsequence(s1 string, s2 string) string {
    if len(s1) == 0 || len(s2) == 0 {
        return ""
    }
    if s1[0] == s2[0] {
        return string(s1[0]) + longestCommonSubsequence(s1[1:], s2[1:])
    } else {
        lcs1 := longestCommonSubsequence(s1, s2[1:])
        lcs2 := longestCommonSubsequence(s1[1:], s2)
        if len(lcs1) > len(lcs2) {
            return lcs1
        }
        return lcs2
    }
}
```

**解析：** 在本题中，我们使用递归算法求最长公共子序列。首先判断字符串是否为空，如果为空则返回空。如果字符串的第一个字符相同，则递归调用 `longestCommonSubsequence(s1[1:], s2[1:])` 并在结果前加上当前字符。如果字符串的第一个字符不同，则分别递归调用 `longestCommonSubsequence(s1, s2[1:])` 和 `longestCommonSubsequence(s1[1:], s2)`，并选择较长的一个。

---

#### 24. 动态规划求最长公共子串

**题目：** 给定两个字符串，请编写一个函数，使用动态规划算法求最长公共子串。

**答案：** 动态规划的基本思想是使用一个二维数组 `dp` 存储子问题的最优解，状态转移方程为 `dp[i][j] = dp[i-1][j-1] + 1`（当 `s1[i] == s2[j]`）或 `dp[i][j] = 0`（当 `s1[i] != s2[j]`）。

**代码：**

```go
func longestCommonSubstring(s1 string, s2 string) string {
    n, m := len(s1), len(s2)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    maxLen, maxI, maxJ := 0, 0, 0
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    maxI = i
                    maxJ = j
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return s1[maxI-maxLen : maxI]
}
```

**解析：** 在本题中，我们使用动态规划算法求最长公共子串。首先初始化一个二维数组 `dp`，然后遍历字符串 `s1` 和 `s2`，更新 `dp` 数组。最后返回从 `s1` 的第 `maxI-maxLen` 个字符开始的子串。

---

#### 25. 递归实现最长公共子串

**题目：** 给定两个字符串，请编写一个函数，使用递归算法求最长公共子串。

**答案：** 递归的基本思想是定义一个递归函数，当字符串为空时返回空，否则比较字符串的第一个字符，分情况讨论。

**代码：**

```go
func longestCommonSubstring(s1 string, s2 string) string {
    if len(s1) == 0 || len(s2) == 0 {
        return ""
    }
    if s1[0] == s2[0] {
        return string(s1[0]) + longestCommonSubstring(s1[1:], s2[1:])
    } else {
        lcs1 := longestCommonSubstring(s1, s2[1:])
        lcs2 := longestCommonSubstring(s1[1:], s2)
        if len(lcs1) > len(lcs2) {
            return lcs1
        }
        return lcs2
    }
}
```

**解析：** 在本题中，我们使用递归算法求最长公共子串。首先判断字符串是否为空，如果为空则返回空。如果字符串的第一个字符相同，则递归调用 `longestCommonSubstring(s1[1:], s2[1:])` 并在结果前加上当前字符。如果字符串的第一个字符不同，则分别递归调用 `longestCommonSubstring(s1, s2[1:])` 和 `longestCommonSubstring(s1[1:], s2)`，并选择较长的一个。

---

#### 26. 最小生成树算法实现

**题目：** 给定一个无向图，请使用最小生成树算法（如 Prim 算法或 Kruskal 算法）求出最小生成树的边权和。

**答案：** Prim 算法的基本思想是从一个顶点开始，逐渐添加边，直到所有顶点都被包含在最小生成树中。Kruskal 算法的基本思想是首先对边进行排序，然后依次选择边，如果选择某条边不会形成环，则将其添加到最小生成树中。

**代码：**

```go
// Prim 算法
func prim(edges [][]int) int {
    n := len(edges)
    uf := NewUnionFind(n)
    ans := 0
    for i := 0; i < n; i++ {
        if uf.Connected(i, i) {
            continue
        }
        u, v, w := edges[i][0], edges[i][1], edges[i][2]
        uf.Union(u, v)
        ans += w
    }
    return ans
}

// Kruskal 算法
func kruskal(edges [][]int) int {
    n := len(edges)
    uf := NewUnionFind(n)
    ans := 0
    for _, edge := range edges {
        u, v, w := edge[0], edge[1], edge[2]
        if uf.Connected(u, v) {
            continue
        }
        uf.Union(u, v)
        ans += w
    }
    return ans
}

type UnionFind struct {
    parent []int
    size   []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        parent: make([]int, n),
        size:   make([]int, n),
    }
    for i := range uf.parent {
        uf.parent[i] = i
        uf.size[i] = 1
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Connected(p int, q int) bool {
    return uf.Find(p) == uf.Find(q)
}

func (uf *UnionFind) Union(p int, q int) {
    rootP, rootQ := uf.Find(p), uf.Find(q)
    if rootP == rootQ {
        return
    }
    if uf.size[rootP] > uf.size[rootQ] {
        uf.parent[rootQ] = rootP
        uf.size[rootP] += uf.size[rootQ]
    } else {
        uf.parent[rootP] = rootQ
        uf.size[rootQ] += uf.size[rootP]
    }
}
```

**解析：** 在本题中，我们分别实现了 Prim 算法和 Kruskal 算法。Prim 算法使用并查集来维护最小生成树，每次选择权重最小的边并将其添加到最小生成树中。Kruskal 算法同样使用并查集，但每次选择权重最小的边，并判断是否与当前最小生成树形成环。

---

#### 27. 搜索算法实现

**题目：** 给定一个二维数组 `grid`，请编写一个函数，使用搜索算法找到目标值 `target` 的路径，路径必须由相同的元素组成。

**答案：** 搜索算法的基本思想是使用深度优先搜索（DFS）或广度优先搜索（BFS）遍历二维数组，找到目标值 `target` 的路径。

**代码：**

```go
// DFS 实现
func findPath(grid [][]int, target int) [][]int {
    rows, cols := len(grid), len(grid[0])
    path := make([][]int, 0)
    visited := make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }
    dfs(grid, target, 0, 0, path, visited)
    return path
}

func dfs(grid [][]int, target int, i int, j int, path [][]int, visited [][]bool) {
    if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) || grid[i][j] != target || visited[i][j] {
        return
    }
    path = append(path, []int{i, j})
    if i == 0 && j == 0 && grid[i][j] == target {
        return
    }
    visited[i][j] = true
    dfs(grid, target, i-1, j, path, visited)
    dfs(grid, target, i+1, j, path, visited)
    dfs(grid, target, i, j-1, path, visited)
    dfs(grid, target, i, j+1, path, visited)
}

// BFS 实现
func findPath(grid [][]int, target int) [][]int {
    rows, cols := len(grid), len(grid[0])
    path := make([][]int, 0)
    q := make([]*Position, 0)
    q = append(q, &Position{i: 0, j: 0})
    visited := make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }
    visited[0][0] = true
    for len(q) > 0 {
        pos := q[0]
        q = q[1:]
        if pos.i == 0 && pos.j == 0 && grid[pos.i][pos.j] == target {
            path = append(path, []int{pos.i, pos.j})
            return path
        }
        for _, dir := range [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} {
            nextI, nextJ := pos.i+dir[0], pos.j+dir[1]
            if nextI >= 0 && nextI < len(grid) && nextJ >= 0 && nextJ < len(grid[0]) && grid[nextI][nextJ] == target && !visited[nextI][nextJ] {
                q = append(q, &Position{i: nextI, j: nextJ})
                visited[nextI][nextJ] = true
            }
        }
    }
    return path
}

type Position struct {
    i int
    j int
}
```

**解析：** 在本题中，我们分别实现了 DFS 和 BFS 算法。DFS 算法使用递归遍历二维数组，找到目标值 `target` 的路径。BFS 算法使用队列实现，每次从队列中取出一个位置，并尝试向上下左右四个方向移动。

---

#### 28. 递归实现二分查找

**题目：** 给定一个有序数组 `nums` 和一个目标值 `target`，请编写一个函数，使用递归算法实现二分查找。

**答案：** 递归的基本思想是定义一个递归函数，当数组为空或目标值在数组范围内时，返回目标值的索引；否则，递归地在左侧或右侧子数组中查找。

**代码：**

```go
func binarySearch(nums []int, target int) int {
    return binarySearchHelper(nums, target, 0, len(nums)-1)
}

func binarySearchHelper(nums []int, target int, left int, right int) int {
    if left > right {
        return -1
    }
    mid := (left + right) / 2
    if nums[mid] == target {
        return mid
    } else if nums[mid] < target {
        return binarySearchHelper(nums, target, mid+1, right)
    } else {
        return binarySearchHelper(nums, target, left, mid-1)
    }
}
```

**解析：** 在本题中，我们使用递归实现二分查找。首先计算中间索引 `mid`，然后比较中间值与目标值的关系，递归地在左侧或右侧子数组中查找。

---

#### 29. 动态规划实现最长上升子序列

**题目：** 给定一个整数数组 `nums`，请编写一个函数，使用动态规划算法求最长上升子序列的长度。

**答案：** 动态规划的基本思想是使用一个数组 `dp` 存储子问题的最优解，状态转移方程为 `dp[i] = max(dp[j]+1)`（对于所有 `j < i` 且 `nums[j] < nums[i]`）。

**代码：**

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：** 在本题中，我们使用动态规划算法求最长上升子序列的长度。首先初始化一个数组 `dp`，然后遍历数组，更新 `dp` 数组。最后返回 `dp` 数组中的最大值。

---

#### 30. 双指针实现最长上升子序列

**题目：** 给定一个整数数组 `nums`，请编写一个函数，使用双指针算法求最长上升子序列的长度。

**答案：** 双指针的基本思想是使用两个指针 `left` 和 `right`，`left` 指向当前最长上升子序列的最后一个元素，`right` 指向当前遍历的元素。

**代码：**

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    left, right := 0, 0
    for i := 1; i < len(nums); i++ {
        if nums[i] >= nums[left] {
            right = i
            left = right
        } else {
            if nums[i] > nums[right] {
                right = i
            }
            left = max(left, right-i+1)
        }
    }
    return left + 1
}
```

**解析：** 在本题中，我们使用双指针算法求最长上升子序列的长度。遍历数组，根据当前元素与最长上升子序列的最后一个元素的关系，更新 `left` 和 `right`。最后返回 `left + 1`。

---

#### 总结

在本篇博客中，我们详细介绍了腾讯2025社招面试中常见的算法和数据结构问题，包括平衡二叉树判定、两数之和、逆波兰表达式求值、合并两个有序链表、三数之和、最长公共前缀、寻找旋转排序数组中的最小值、字符串转换大写字母、反转字符串、验证回文串、秒杀系统设计、线程池设计、快排实现、双指针实现快排、堆排序实现、动态规划求最大子序和、递归实现斐波那契数列、循环结构实现斐波那契数列、合并区间、动态规划求最长公共子序列、递归实现最长公共子序列、动态规划求最长公共子串、递归实现最长公共子串、最小生成树算法实现、搜索算法实现、递归实现二分查找、动态规划实现最长上升子序列、双指针实现最长上升子序列等。每个问题都提供了详细的答案解析和源代码实例，希望对您的面试准备有所帮助。祝您面试顺利！

