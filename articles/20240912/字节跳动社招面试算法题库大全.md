                 

### 2024字节跳动社招面试算法题库大全

#### 算法基础

##### 1. 爬楼梯问题

**题目：** 一个楼梯有 n 阶台阶，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

**答案：** 使用动态规划，定义 f(n) 为到达第 n 阶的方法数，有 f(n) = f(n-1) + f(n-2)。

```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    a, b := 1, 2
    for i := 2; i < n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 动态规划通过计算前两个状态来推导出当前状态，从而避免重复计算。

##### 2. 最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：** 使用动态规划，定义 dp[i][j] 为字符串 s1 的前 i 个字符和字符串 s2 的前 j 个字符的最长公共子序列长度。

```go
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 动态规划通过计算相邻状态的最优解来推导出当前状态的最优解。

#### 数据结构

##### 3. 合并两个有序链表

**题目：** 给定两个有序链表，合并它们为一个新的有序链表。

**答案：** 使用递归或迭代方法，比较两个链表的当前节点，选择较小的节点并移动相应的指针。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 合并链表时，需要比较当前节点，并选择较小的节点作为新的当前节点，同时移动相应的指针。

##### 4. 二叉搜索树中的搜索

**题目：** 给定一个二叉搜索树和目标值，查找树中是否存在该值。

**答案：** 使用递归或迭代方法，从根节点开始，比较当前节点的值与目标值，递归或迭代地搜索左子树或右子树。

```go
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }
    if root.Val < val {
        return searchBST(root.Right, val)
    }
    return searchBST(root.Left, val)
}
```

**解析：** 二叉搜索树的特点是左子树的所有节点值都小于当前节点值，右子树的所有节点值都大于当前节点值，因此可以根据这个特点来搜索目标值。

#### 算法与数据结构综合

##### 5. 最小栈

**题目：** 设计一个支持 push、pop、top 操作的栈，同时能够获取栈的最小值。

**答案：** 使用两个栈，一个用于存储元素，另一个用于存储最小值。

```go
type MinStack struct {
    stack1 []int
    stack2 []int
}

func Constructor() MinStack {
    return MinStack{
        stack1: []int{},
        stack2: []int{},
    }
}

func (this *MinStack) Push(val int) {
    this.stack1 = append(this.stack1, val)
    if len(this.stack2) == 0 || val <= this.stack2[len(this.stack2)-1] {
        this.stack2 = append(this.stack2, val)
    }
}

func (this *MinStack) Pop() {
    if this.stack1[len(this.stack1)-1] == this.stack2[len(this.stack2)-1] {
        this.stack2 = this.stack2[:len(this.stack2)-1]
    }
    this.stack1 = this.stack1[:len(this.stack1)-1]
}

func (this *MinStack) Top() int {
    return this.stack1[len(this.stack1)-1]
}

func (this *MinStack) GetMin() int {
    return this.stack2[len(this.stack2)-1]
}
```

**解析：** 使用两个栈来维护最小值，当新元素小于当前最小值时，将其加入第二个栈。

##### 6. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**答案：** 首先将区间按照起点排序，然后遍历区间，合并重叠的区间。

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 通过排序和遍历，合并重叠的区间，避免出现新的重叠。

#### 动态规划

##### 7. 最长公共子序列

**题目：** 给定两个字符串，求它们的最长公共子序列。

**答案：** 使用动态规划，定义 dp[i][j] 为字符串 s1 的前 i 个字符和字符串 s2 的前 j 个字符的最长公共子序列长度。

```go
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 动态规划通过计算前两个状态来推导出当前状态，从而避免重复计算。

##### 8. 最长上升子序列

**题目：** 给定一个整数数组，求最长上升子序列的长度。

**答案：** 使用动态规划，定义 dp[i] 为以第 i 个元素为结尾的最长上升子序列长度。

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

**解析：** 动态规划通过计算相邻状态的最优解来推导出当前状态的最优解。

#### 网络流

##### 9. 单源最短路径

**题目：** 给定一个有向图和无向图，求单源最短路径。

**答案：** 使用 Dijkstra 算法，从源点开始，逐步扩展到其他节点，计算出单源最短路径。

```go
func shortestPathGraph(graph [][]int, source int) []int {
    dist := make([]int, len(graph))
    dist[source] = 0
    visited := make([]bool, len(graph))
    for i := range visited {
        visited[i] = false
    }
    for !allVisited(visited) {
        minDist := int(^uint(0) >> 1)
        minIndex := -1
        for i, v := range dist {
            if !visited[i] && v < minDist {
                minDist = v
                minIndex = i
            }
        }
        if minIndex == -1 {
            break
        }
        visited[minIndex] = true
        for i, w := range graph[minIndex] {
            if !visited[i] && dist[i] > dist[minIndex]+w {
                dist[i] = dist[minIndex]+w
            }
        }
    }
    return dist
}
```

**解析：** Dijkstra 算法通过逐步扩展到其他节点，计算出单源最短路径。

##### 10. 最大流

**题目：** 给定一个网络图和源点、汇点，求网络的最大流。

**答案：** 使用 Ford-Fulkerson 算法，通过寻找增广路径来逐步增加流值，直到无法找到增广路径为止。

```go
func maxFlow(graph [][]int, source, sink int) int {
    flow := 0
    for {
        path := findAugmentingPath(graph, source, sink)
        if path == nil {
            break
        }
        bottleneck := int(^uint(0) >> 1)
        for _, edge := range path {
            bottleneck = min(bottleneck, graph[edge[0]][edge[1]])
        }
        for _, edge := range path {
            graph[edge[0]][edge[1]] -= bottleneck
            graph[edge[1]][edge[0]] += bottleneck
        }
        flow += bottleneck
    }
    return flow
}
```

**解析：** Ford-Fulkerson 算法通过寻找增广路径来逐步增加流值，直到无法找到增广路径为止。

#### 贪心算法

##### 11. 活动选择问题

**题目：** 给定一组活动，每个活动都有一个开始时间和结束时间，选择尽可能多的不相交的活动。

**答案：** 使用贪心算法，选择结束时间最早的活动，然后从下一个活动的开始时间开始继续选择。

```go
func activitySelection(activities [][]int) [][]int {
    sort.Slice(activities, func(i, j int) bool {
        return activities[i][1] < activities[j][1]
    })
    ans := [][]int{}
    lastEnd := -1
    for _, activity := range activities {
        if activity[0] >= lastEnd {
            ans = append(ans, activity)
            lastEnd = activity[1]
        }
    }
    return ans
}
```

**解析：** 贪心算法通过选择结束时间最早的活动来最大化选择的数量。

##### 12. 0-1 背包问题

**题目：** 给定一组物品，每个物品有一个重量和一个价值，选择一些物品使得总重量不超过给定限制，且总价值最大化。

**答案：** 使用贪心算法，选择价值与重量比最大的物品，直到总重量超过限制为止。

```go
func knapsack(values []int, weights []int, capacity int) int {
    items := make([][]int, len(values))
    for i := range items {
        items[i] = []int{values[i], weights[i]}
    }
    sort.Slice(items, func(i, j int) bool {
        return items[i][0]/items[i][1] > items[j][0]/items[j][1]
    })
    totalValue := 0
    for _, item := range items {
        if capacity >= item[1] {
            capacity -= item[1]
            totalValue += item[0]
        } else {
            totalValue += capacity * (item[0] / item[1])
            break
        }
    }
    return totalValue
}
```

**解析：** 贪心算法通过选择价值与重量比最大的物品来最大化总价值。

#### 字符串处理

##### 13. 最长公共前缀

**题目：** 给定一组字符串，求它们的最长公共前缀。

**答案：** 使用横向比较，逐个字符比较字符串，直到找到不同的字符为止。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, s := range strs[0] {
        for j, t := range strs[1] {
            if i >= j || s != t {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

**解析：** 最长公共前缀通过逐个字符比较字符串来找到公共前缀。

##### 14. 最长回文子串

**题目：** 给定一个字符串，求它的最长回文子串。

**答案：** 使用动态规划，定义 dp[i][j] 为字符串 s 的第 i 个字符到第 j 个字符是否为回文串。

```go
func longestPalindrome(s string) string {
    n := len(s)
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        dp[i][i] = true
    }
    for i := 0; i < n-1; i++ {
        if s[i] == s[i+1] {
            dp[i][i+1] = true
            start = i
            maxLen = 2
        }
    }
    for l := 3; l <= n; l++ {
        for i := 0; i < n-l+1; i++ {
            j := i + l - 1
            if s[i] == s[j] && dp[i+1][j-1] {
                dp[i][j] = true
                if l > maxLen {
                    start = i
                    maxLen = l
                }
            }
        }
    }
    return s[start : start+maxLen]
}
```

**解析：** 动态规划通过计算相邻子串是否为回文串来推导出当前子串是否为回文串。

#### 数学

##### 15. 素数生成器

**题目：** 给定一个整数 n，生成 n 以内的所有素数。

**答案：** 使用 Sieve of Eratosthenes 算法，通过不断标记非素数，得到所有素数。

```go
func sieveOfEratosthenes(n int) []int {
    primes := make([]bool, n+1)
    for i := range primes {
        primes[i] = true
    }
    primes[0], primes[1] = false, false
    for i := 2; i <= n; i++ {
        if primes[i] {
            for j := i * i; j <= n; j += i {
                primes[j] = false
            }
        }
    }
    ans := []int{}
    for i, prime := range primes {
        if prime {
            ans = append(ans, i)
        }
    }
    return ans
}
```

**解析：** Sieve of Eratosthenes 算法通过不断标记非素数，得到所有素数。

##### 16. 求最大公约数

**题目：** 给定两个整数，求它们的最大公约数。

**答案：** 使用辗转相除法，不断用较小数除以较大数，直到余数为 0 为止。

```go
func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

**解析：** 辗转相除法通过不断用较小数除以较大数，直到余数为 0 为止，求得最大公约数。

#### 贪心算法与排序

##### 17. 股票买卖

**题目：** 给定一个整数数组，其中每个元素代表一天的价格，每次买卖股票只能持有一次，求最大利润。

**答案：** 使用贪心算法，在上升段买入，在下降段卖出。

```go
func maxProfit(prices []int) int {
    maxProfit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            maxProfit += prices[i] - prices[i-1]
        }
    }
    return maxProfit
}
```

**解析：** 贪心算法通过在上升段买入，在下降段卖出，求得最大利润。

##### 18. 合并区间

**题目：** 给定一组区间，合并所有重叠的区间。

**答案：** 首先将区间按照起点排序，然后遍历区间，合并重叠的区间。

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}
```

**解析：** 合并区间时，需要比较当前节点，并选择较小的节点作为新的当前节点，同时移动相应的指针。

##### 19. 最小生成树

**题目：** 给定一组边，求最小生成树。

**答案：** 使用 Prim 算法或 Kruskal 算法，通过贪心选择最小的边，直到包含所有节点。

```go
func prim(graph [][]int) [][]int {
    m := len(graph)
    ans := [][]int{}
    visited := make([]bool, m)
    start := 0
    for len(ans) < m-1 {
        visited[start] = true
        for _, edge := range graph[start] {
            if !visited[edge[0]] {
                ans = append(ans, edge)
                break
            }
        }
        start = -1
        for i, v := range graph {
            if !visited[i] && (start == -1 || v[1] < graph[start][1]) {
                start = i
            }
        }
    }
    return ans
}
```

**解析：** Prim 算法通过贪心选择最小的边，直到包含所有节点。

##### 20. 旅行商问题

**题目：** 给定一组城市和它们之间的距离，求旅行商问题（TSP）的最短路径。

**答案：** 使用贪心算法，从任意一个城市开始，依次选择距离最近的未访问城市。

```go
func travelingSalesmanProblem(cities [][]int) int {
    m := len(cities)
    visited := make([]bool, m)
    ans := []int{0}
    for len(ans) < m {
        last := ans[len(ans)-1]
        next := -1
        for i, city := range cities {
            if !visited[i] && (next == -1 || cities[ans[len(ans)-2]][city] < cities[next][city]) {
                next = i
            }
        }
        visited[next] = true
        ans = append(ans, next)
    }
    totalDistance := 0
    for i := 1; i < len(ans); i++ {
        totalDistance += cities[ans[i-1]][ans[i]]
    }
    return totalDistance
}
```

**解析：** 贪心算法通过从任意一个城市开始，依次选择距离最近的未访问城市，求得旅行商问题（TSP）的最短路径。

#### 链表

##### 21. 合并两个有序链表

**题目：** 给定两个有序链表，合并它们为一个新的有序链表。

**答案：** 使用递归或迭代方法，比较两个链表的当前节点，选择较小的节点并移动相应的指针。

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：** 合并链表时，需要比较当前节点，并选择较小的节点作为新的当前节点，同时移动相应的指针。

##### 22. 反转链表

**题目：** 给定一个单链表，将其反转。

**答案：** 使用递归或迭代方法，逐个节点地反转指针。

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

**解析：** 反转链表时，需要逐个节点地反转指针。

##### 23. 删除链表的倒数第 n 个节点

**题目：** 给定一个链表和一个整数 n，删除链表的倒数第 n 个节点。

**答案：** 使用快慢指针方法，首先将快指针移动 n 个节点，然后慢指针和快指针同时移动，当快指针到达链表末尾时，慢指针指向的节点即为倒数第 n 个节点。

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    fast, slow := dummy, dummy
    for i := 0; i < n; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    slow.Next = slow.Next.Next
    return dummy.Next
}
```

**解析：** 使用快慢指针方法，通过移动快指针和慢指针来找到倒数第 n 个节点，然后删除该节点。

#### 栈与队列

##### 24. 用两个栈实现队列

**题目：** 使用两个栈实现一个队列，支持队列的基本操作（入队、出队、获取队头）。

**答案：** 使用两个栈，一个用于入队，一个用于出队。入队时，将元素压入栈1；出队时，如果栈2为空，将栈1中的所有元素依次压入栈2，然后弹出栈2的顶部元素作为队头。

```go
type MyQueue struct {
    inStack, outStack []int
}

func Constructor() MyQueue {
    return MyQueue{}
}

func (this *MyQueue) Push(x int) {
    this.inStack = append(this.inStack, x)
}

func (this *MyQueue) Pop() int {
    if len(this.outStack) == 0 {
        for len(this.inStack) > 0 {
            this.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])
            this.inStack = this.inStack[:len(this.inStack)-1]
        }
    }
    top := this.outStack[len(this.outStack)-1]
    this.outStack = this.outStack[:len(this.outStack)-1]
    return top
}

func (this *MyQueue) Peek() int {
    if len(this.outStack) == 0 {
        for len(this.inStack) > 0 {
            this.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])
            this.inStack = this.inStack[:len(this.inStack)-1]
        }
    }
    return this.outStack[len(this.outStack)-1]
}

func (this *MyQueue) Empty() bool {
    return len(this.inStack) == 0 && len(this.outStack) == 0
}
```

**解析：** 使用两个栈来实现队列，通过入队和出队操作来模拟队列的行为。

##### 25. 用两个队列实现栈

**题目：** 使用两个队列实现一个栈，支持栈的基本操作（入栈、出栈、获取栈顶）。

**答案：** 使用两个队列，一个用于入栈，一个用于出栈。入栈时，将元素压入队列1；出栈时，将队列1中的所有元素依次移动到队列2，然后弹出队列2的顶部元素作为栈顶。

```go
type MyStack struct {
    inQueue, outQueue []int
}

func Constructor() MyStack {
    return MyStack{}
}

func (this *MyStack) Push(x int) {
    this.inQueue = append(this.inQueue, x)
}

func (this *MyStack) Pop() int {
    for len(this.inQueue) > 1 {
        top := this.inQueue[0]
        this.inQueue = this.inQueue[1:]
        this.outQueue = append(this.outQueue, top)
    }
    top := this.inQueue[0]
    this.inQueue = this.inQueue[:1]
    return top
}

func (this *MyStack) Top() int {
    for len(this.inQueue) > 1 {
        top := this.inQueue[0]
        this.inQueue = this.inQueue[1:]
        this.outQueue = append(this.outQueue, top)
    }
    top := this.inQueue[0]
    this.inQueue = this.inQueue[:1]
    return top
}

func (this *MyStack) Empty() bool {
    return len(this.inQueue) == 0 && len(this.outQueue) == 0
}
```

**解析：** 使用两个队列来实现栈，通过入栈和出栈操作来模拟栈的行为。

##### 26. 滑动窗口最大值

**题目：** 给定一个数组和一个滑动窗口的大小 k，找出所有滑动窗口中的最大值。

**答案：** 使用双端队列实现滑动窗口，队列中的元素按照从大到小的顺序排列。窗口滑动时，移除队列中不在窗口内的元素，将新的元素添加到队列的尾部。

```go
func maxSlidingWindow(nums []int, k int) []int {
    deque := []int{}
    ans := []int{}
    for i := 0; i < len(nums); i++ {
        for len(deque) > 0 && nums[deque[len(deque)-1]] <= nums[i] {
            deque = deque[:len(deque)-1]
        }
        deque = append(deque, i)
        if i >= k-1 {
            if i-deque[0] == k-1 {
                ans = append(ans, nums[deque[0]])
            }
            if len(deque) > 0 && deque[0] < i-k+1 {
                deque = deque[1:]
            }
        }
    }
    return ans
}
```

**解析：** 使用双端队列实现滑动窗口，通过维护队列中元素的顺序来找到每个滑动窗口中的最大值。

##### 27. 分割等和子集

**题目：** 给定一个非负整数数组，判断是否可以将该数组分割成两个子集，使得两个子集的元素和相等。

**答案：** 使用动态规划，定义 dp[i][j] 为前 i 个元素是否能组成和为 j 的子集。如果可以，则 dp[i][j] = true，否则为 false。

```go
func canPartition(nums []int) bool {
    totalSum := 0
    for _, num := range nums {
        totalSum += num
    }
    if totalSum%2 != 0 {
        return false
    }
    target := totalSum / 2
    n := len(nums)
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, target+1)
        dp[i][0] = true
    }
    for i := 0; i < n; i++ {
        for j := 1; j <= target; j++ {
            if j >= nums[i] {
                dp[i+1][j] = dp[i][j] || dp[i][j-nums[i]]
            } else {
                dp[i+1][j] = dp[i][j]
            }
        }
    }
    return dp[n][target]
}
```

**解析：** 动态规划通过计算前 i 个元素是否能组成和为 j 的子集，来判断是否可以将数组分割成两个子集。

#### 并查集

##### 28. 判断二分图

**题目：** 给定一个无向图，判断它是否为二分图。

**答案：** 使用并查集，将图中的每个节点和它的邻居节点进行合并。如果在合并过程中出现了同一个集合中的节点，说明图不是二分图。

```go
func isBipartite(graph [][]int) bool {
    n := len(graph)
    color := make([]int, n)
    for i := 0; i < n; i++ {
        if color[i] == 0 {
            if !dfs(graph, i, color) {
                return false
            }
        }
    }
    return true
}

func dfs(graph [][]int, u int, color []int) bool {
    if color[u] != 0 {
        return color[u] == 2
    }
    color[u] = 1
    for _, v := range graph[u] {
        if !dfs(graph, v, color) {
            return false
        }
    }
    return true
}
```

**解析：** 使用并查集，通过递归地合并节点和邻居节点，并检查合并过程中的颜色是否冲突，来判断图是否为二分图。

##### 29. 连通网络的操作次数

**题目：** 给定一个无向图，每次可以合并两个节点，求最小合并次数使得图中所有节点连通。

**答案：** 使用并查集，每次合并两个连通节点，并记录合并的次数。

```go
func minOperations(numEdges int, edges [][]int) int {
    parent := make([]int, len(edges)+1)
    for i := range parent {
        parent[i] = i
    }
    for _, edge := range edges {
        u, v := edge[0], edge[1]
        pU, pV := find(u), find(v)
        if pU != pV {
            parent[pU] = pV
            numEdges--
        }
    }
    return len(edges) - numEdges
}

func find(u int) int {
    if parent[u] != u {
        parent[u] = find(parent[u])
    }
    return parent[u]
}
```

**解析：** 使用并查集，通过合并连通节点并记录合并次数，求得最小合并次数。

##### 30. 最短路径

**题目：** 给定一个无向图和两个节点，求它们之间的最短路径。

**答案：** 使用 Dijkstra 算法，从源点开始，逐步扩展到其他节点，计算出单源最短路径。

```go
func shortestPath(graph [][]int, start, end int) int {
    dist := make([]int, len(graph))
    for i := range dist {
        dist[i] = int(^uint(0) >> 1)
    }
    dist[start] = 0
    visited := make([]bool, len(graph))
    for i := range visited {
        visited[i] = false
    }
    for !allVisited(visited) {
        minDist := int(^uint(0) >> 1)
        minIndex := -1
        for i, v := range dist {
            if !visited[i] && v < minDist {
                minDist = v
                minIndex = i
            }
        }
        if minIndex == -1 {
            break
        }
        visited[minIndex] = true
        for i, w := range graph[minIndex] {
            if !visited[i] && dist[i] > dist[minIndex]+w {
                dist[i] = dist[minIndex]+w
            }
        }
    }
    return dist[end]
}
```

**解析：** 使用 Dijkstra 算法，通过逐步扩展到其他节点，计算出单源最短路径。

