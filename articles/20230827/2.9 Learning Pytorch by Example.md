
作者：禅与计算机程序设计艺术                    

# 1.简介
  
  
PyTorch是一个开源的、基于Python的科学计算包，提供一个灵活的张量计算接口。它具有以下优点：  
1）采用动态计算图机制，支持各种复杂的模型结构；  
2）高效的内存利用率，支持GPU加速运算；  
3）友好的API设计，易于上手，并可通过其生态圈扩展功能。  
本文从零到入门，带领大家学习PyTorch框架。文章主要包括如下几个部分：  
1.1 安装配置PyTorch  
1.2 使用PyTorch构建神经网络  
1.3 数据集加载与预处理  
1.4 模型训练、验证、测试以及部署  
1.5 PyTorch进阶  
# 1.安装配置PyTorch  
由于PyTorch目前仅支持Python2.7或Python3.5及以上版本，建议先创建好相应的Python虚拟环境。  
## Windows安装PyTorch
下载对应版本的Anaconda（推荐）或Miniconda安装包，安装后可以看到Miniconda(x86)或者Anaconda(x86)命令提示符，打开命令行窗口。输入：  
```
pip install torch torchvision
```
如果你的机器没有GPU，需要在命令后面添加`cpuonly=True`，如：  
```
pip install torch==1.0.1 cpuonly=True
```
如果安装成功，应该会显示出如下信息：
```
Collecting torch
  Downloading https://download.pytorch.org/whl/cpu/torch-1.0.1-cp36-cp36m-win_amd64.whl (592.0MB)
     |████████████████████████████████| 592.0MB 20kB/s
Requirement already satisfied: numpy in c:\users\xxx\.conda\envs\pytorch\lib\site-packages (from torch) (1.14.3)
Requirement already satisfied: pillow>=4.1.1 in c:\users\xxx\.conda\envs\pytorch\lib\site-packages (from torchvision) (5.0.0)
Installing collected packages: torch
Successfully installed torch-1.0.1
```
## Linux安装PyTorch
# 1.2 使用PyTorch构建神经网络
首先，引入必要的库：
```python
import torch
import torch.nn as nn
import torch.optim as optim
```
定义好模型：
```python
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(100, 50)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(50, 10)

    def forward(self, x):
        out = self.fc1(x)
        out = self.relu(out)
        out = self.fc2(out)
        return out
```
定义好数据集加载器：
```python
trainloader =... # 数据集加载器
testloader =... # 测试数据集加载器
```
定义好优化器：
```python
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)
```
训练过程：
```python
for epoch in range(num_epochs):
    running_loss = 0.0
    for i, data in enumerate(trainloader, 0):
        inputs, labels = data

        optimizer.zero_grad()

        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()
        if i % 100 == 99:
            print('[%d, %5d] loss: %.3f' %
                  (epoch + 1, i + 1, running_loss / 100))
            running_loss = 0.0
print('Finished Training')
```
测试过程：
```python
correct = 0
total = 0
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print('Accuracy of the network on the 10000 test images: %d %%' %
      (100 * correct / total))
```
训练完成之后，保存模型：
```python
PATH = './cifar_net.pth'
torch.save(net.state_dict(), PATH)
```

# 1.3 数据集加载与预处理
通常来说，图像分类任务的数据集都很复杂，比如CIFAR-10，需要做一些预处理工作才能使用。
## CIFAR-10数据集
CIFAR-10是一个用于图像识别的小型数据集，共10类，每类6000张32*32颜色图片。其中5000张图片作为训练集，1000张图片作为测试集。这里我们将用CIFAR-10作为例子演示如何加载CIFAR-10数据集。
首先，引入必要的库：
```python
import torch
import torchvision
import torchvision.transforms as transforms
```
然后定义好数据集加载器：
```python
transform = transforms.Compose([transforms.ToTensor()])
trainset = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)
trainloader = torch.utils.data.DataLoader(trainset, batch_size=4,
                                          shuffle=True, num_workers=2)

testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
testloader = torch.utils.data.DataLoader(testset, batch_size=4,
                                         shuffle=False, num_workers=2)
classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse','ship', 'truck')
```

# 1.4 模型训练、验证、测试以及部署
## 模型训练
```python
net = Net()
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)

for epoch in range(2):  # loop over the dataset multiple times

    running_loss = 0.0
    for i, data in enumerate(trainloader, 0):
        # get the inputs; data is a list of [inputs, labels]
        inputs, labels = data

        # zero the parameter gradients
        optimizer.zero_grad()

        # forward + backward + optimize
        outputs = net(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        # print statistics
        running_loss += loss.item()
        if i % 2000 == 1999:    # print every 2000 mini-batches
            print('[%d, %5d] loss: %.3f' %
                  (epoch + 1, i + 1, running_loss / 2000))
            running_loss = 0.0

print('Finished Training')
```
## 模型验证
```python
correct = 0
total = 0
with torch.no_grad():
    for data in testloader:
        images, labels = data
        outputs = net(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print('Accuracy of the network on the 10000 test images: %d %%' %
      (100 * correct / total))
```
## 模型测试
```python
dataiter = iter(testloader)
images, labels = dataiter.next()

# print images
imshow(torchvision.utils.make_grid(images))
print('GroundTruth: ',''.join('%5s' % classes[labels[j]] for j in range(4)))

net = Net()
net.load_state_dict(torch.load(PATH))
outputs = net(images)
_, predicted = torch.max(outputs, 1)

print('Predicted:     ',''.join('%5s' % classes[predicted[j]]
                              for j in range(4)))
```