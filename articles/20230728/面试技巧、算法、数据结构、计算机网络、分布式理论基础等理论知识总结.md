
作者：禅与计算机程序设计艺术                    

# 1.简介
         
互联网技术日新月异，各种框架层出不穷。掌握一些相关的基础理论对加强自身技术能力、应对复杂的开发环境和项目时有很大的帮助。本文将会详细介绍一些通用的面试技巧、算法、数据结构、计算机网络、分布式理论知识点。文章主要基于个人经验编写，难免有疏漏和错误之处，敬请指正！
## 一、面试技巧
### 1.简历的写作技巧
1）简历上线下至少提前一周出炉；

2）简历的内容应该包括自己的履历信息、工作经验、教育经历、联系方式等；

3）在简历中可以突出自己擅长的领域或技术能力，能够即刻反映自己的综合能力；

4）任何技术人员都应该具备良好的写作风格，能够清晰准确地表达自己的知识架构和工作经验，以及最重要的是表现自己的能力和潜力。

### 2.提问的技巧
1）首先，用简短的语言描述你的问题，尽量避免涉及太多细节；

2）准备好多种选择，排除万难，不止一次试错；

3）记录每一次的回答，充分思考别人的答案为什么正确或错误，分析原因；

4）当回答者无法提供可靠的答案，可以问他/她提供更多的信息或做出更好的猜测。

### 3.回答技巧
1）采用自然语言，尽量明了的表达自己的意思，清晰准确；

2）提供足够的资料支持和证据，能够指出自己的答案为什么正确，给出反驳的机会；

3）注意态度，尊重对方的需求，不作过多争执或打击报复；

4）按相关度和实际情况，在回答问题前先确认对方的资质、水平和技能是否匹配，避免引起误会。

## 二、算法
### 1.排序算法
#### （1）冒泡排序（Bubble Sort）
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
```python
def bubbleSort(arr):
    n = len(arr)
 
    # Traverse through all array elements
    for i in range(n):
 
        # Last i elements are already in place
        for j in range(0, n-i-1):
 
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```
#### （2）选择排序（Selection Sort）
选择排序是一种简单直观的排序算法。它的工作原理如下: 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
```python
def selectionSort(arr):
    n = len(arr)
 
    # One by one move boundary of unsorted subarray
    for i in range(n):
        min_idx = i
 
        # Find the minimum element in remaining unsorted array
        for j in range(i+1, n):
            if arr[min_idx] > arr[j]:
                min_idx = j
 
        # Swap the found minimum element with the first element         
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
```
#### （3）插入排序（Insertion Sort）
插入排序算法是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
```python
def insertionSort(arr):
    n = len(arr)
 
    # Traverse through 1 to len(arr)
    for i in range(1, n):
 
        key = arr[i]
 
        # Move elements of arr[0..i-1], that are
        # greater than key, to one position ahead
        # of their current position
        j = i-1
        while j >= 0 and key < arr[j] :
                arr[j+1] = arr[j]
                j -= 1
        arr[j+1] = key
```
#### （4）希尔排序（Shell Sort）
希尔排序是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。希尔排序又叫缩小增量排序算法，是把数组列成若干子表，分别对各子表进行插入排序。然后逐渐缩小增量，使得子表个数减半。直至增量为1时，即完成排序。
```python
def shellSort(arr):
    n = len(arr)
 
    # Start with a big gap, then reduce the gap
    d = n//2
    while d > 0:
 
        # Do a gapped insertion sort for this gap size.
        # The first gap elements come from the previous iteration,
        # the second gap elements come from the elements between
        # the first and second gap, and so on...
        for i in range(d,n):
 
            # add a[i] to the elements that have been gap sorted
            # save a[i] in temp and make a hole at position i
            temp = arr[i]
 
            # shift earlier gap-sorted elements up until the correct location for a[i] is found
            j = i
            while  j >= d and arr[j-d] >temp:
                arr[j] = arr[j-d]
                j -= d
 
            # put temp (the original a[i]) in its correct location
            arr[j] = temp
        d //= 2
```
#### （5）快速排序（Quick Sort）
快速排序是一个分治法的排序算法。该算法选取一个基准元素，然后将数组分割成两部分，一部分比基准元素小，一部分比基准元素大。然后，分别对这两部分递归排序。递归结束时，整个数组就排好序了。
```python
import random
 
def quickSort(arr, low, high):
     
    if low < high:
         
        # pi is partitioning index, arr[p] is now
        # at right place
        pi = partition(arr, low, high)
 
        # Separately sort elements before
        # partition and after partition
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
 
 
# This function takes last element as pivot, places
# the pivot element at its correct position in sorted
# array, and places all smaller (smaller than pivot)
# to left of pivot and all greater elements to right
# of pivot
def partition(arr, low, high):
     
     # pivot (Element to be placed at right position)
     pivot = arr[high]

     # Index of smaller element
     i = low - 1
     
     for j in range(low, high):
         if   arr[j] <= pivot:
             i += 1
             arr[i],arr[j]=arr[j],arr[i]
             
     arr[i+1],arr[high]=arr[high],arr[i+1]
     return i+1
 ```
#### （6）堆排序（Heap Sort）
堆排序是一种树形选择排序，也是应用广泛的排序算法。堆是一个近似完全二叉树的结构，并同时满足最大堆和最小堆的性质。在堆排序算法中，首先将待排序关键字序列构造成一个大根堆或者小根堆。然后重复以下过程：

1. 从堆顶取出最大值（最小值），移动到末尾；

2. 由于末尾元素最大（最小），因此不必再做调整；

3. 将剩下的n-1个元素重新构造成堆。 

所谓"堆"，是指一组同样的元素，按照其比较关系组合而成的数据结构。最大堆是一个每个节点的值都大于或等于其子树中的任何其他值的堆，即根节点的值是所有节点中最大的一个；最小堆则相反，每个节点的值都小于或等于其子树中的任何其他值的堆。