
作者：禅与计算机程序设计艺术                    

# 1.简介
  

SHA-1，Secure Hash Algorithm 1，由美国国家安全局设计标准化，命名符合FIPS 180-1，采用512位运算能力的消息摘要算法标准。其设计目标是在不破坏原始输入信息的情况下，生成一个固定长度的值作为信息摘要，该值基于输入数据生成消息摘要的一个函数。该算法输出的散列值可以用来验证数据的完整性、保证数据完整性或数据来源完整性等。SHA-1的主要应用场景包括数字签名、授权凭证、校验码生成、随机数生成、杂凑算法等。

在本文中，我们将详细阐述SHA-1算法的工作原理、特点及优缺点，并结合实际应用场景，通过实例讲解如何用Python语言实现SHA-1加密算法，以及在实践过程中应该注意到的一些陷阱和需要注意的问题。

# 2.基本概念术语说明
## 2.1 消息摘要（Digest）
消息摘要是一种编码方式，它将任意长度的数据转换成固定长度的值。这一过程称之为“摘要计算”，也叫做“哈希”或“散列”。消息摘要算法的功能就是产生一个固定长度的值（通常小于或等于原始数据的长度），这个值对原始数据来说是唯一的。通过消息摘要算法生成的摘要值可用于对比、校验数据的完整性、身份认证、防篡改、加解密等。

## 2.2 消息认证码（Message Authentication Code）
消息认证码（MAC）是一种电子标识符，用于确认接收者的身份和完整性。消息认证码是根据某种算法计算出的固定长度的值，而且这种值的变化不随发送者的不同而发生改变。它能够保护消息免受第三方的篡改和伪造。目前已有的消息认证码算法有MD5、HMAC_SHA1等。

## 2.3 分组密码算法（Block Cipher Algorithm）
分组密码算法（又称块密码算法），是指将明文分割成固定大小的多个数据块，并将每一数据块独立地加密。因此，其加密过程依赖于加密算法的可重复性。由于每个数据块只能被加密一次，所以它比连续加密速度快很多。分组密码算法有DES、AES、RSA等。

## 2.4 置换选择（Permutation Selection）
置换选择是指把输入的数据按一定规律重新排列，使其变得不容易预测。SHA-1采用的置换选择方法是MD5的秘诀——左移和位选取。

# 3.SHA-1基本原理
## 3.1 概览
SHA-1是一种单向散列函数，它的输出长度固定为160bit。

## 3.2 输入/输出模式
SHA-1以512位为基本单元，要求输入数据必须为512位整数倍，因此最后一块数据可能需要填充至64字节。

整个算法流程如下图所示：

首先，首先将输入数据进行分组，按照512位为一组。然后按照SHA-1算法规则进行处理。对于每一组数据，首先在末尾添加一个64位的填充位，即1个填充字节和若干个0。这个填充字节用某一算法计算出来的“填充位串”填充满。填充位串为第一个填充字节与后面所有的0的组合。例如，填充位串为10000…00。如果第一组数据不是64字节，则还需再增加一些字节。

然后，对每一组数据，先将512位数据分为16个字长为32位的数据块。这样每一块就变成了四个32位字。然后，对每个数据块进行以下操作：

1. 将各个32位字先串联起来成为一个64位字，记为M。
2. 对 M 进行初始置乱，得到新的变量 MT。
3. 将 MT 划分为 N 个 512 位的数据块，每个数据块包含 M 的每一半。
4. 对前 N-1 个数据块（从第0个开始计数）进行循环处理，每次循环对当前数据块与下一个数据块进行操作：
    a. 扩展成 80 个字长为 32 位的数据块，记为 W[i]。W[0]~W[19] 由上一轮处理结果直接拼接得到；W[20]~W[39] 为左移5次后的 W[19]；W[40]~W[59] 为左移30次后的 W[39]；W[60]~W[79] 为左移25次后的 W[59]。
    b. 对每个数据块进行扩展操作：
        i. 如果数据块的长度超过 160bit，则截取前 160bit，否则补全至160bit。
        ii. 将数据块划分为 16 个字长为 32 位的数据块，记为 TEMP(j)。TEMP(j) 包含 32bit 数据，每段数据按照 bitwise 相位的逆序重新排列，其中每段数据对应的位置就是逆序之前数据的起始位置。
        iii. 根据索引 j 确定 TEMP(j) 在前或后一个数据块中的位置 k，再利用左移位数确定 TEMP(k+1) 到 TEMP(k) 的移位方向。
        iv. 用 TEMP(k) 和 TEMP(j) 拼接形成新的 DATA(j)，并做相应的位移。
    c. 更新所有数据块的状态：MT=LEFTrotate(MT, 30)=LEFTrotate(TEMP(0), 1) ^ LEFTrotate(TEMP(1), 8) ^ LEFTrotate(TEMP(2), 7) ^... ^ TEMP(15)
   d. 当 N%16==0 时，进行消息压缩。对当前的数据块状态 MT 中的每一位，都与消息头 MESSAGE_HEAD 进行比较。

完成消息压缩后，得到的结果成为消息摘要 H。最后，对结果 H 进行最后的校验和填充，输出结果。

## 3.3 信息熵
信息熵（entropy）表示数据的无序程度，又称“随机性”，或者说，不确定性。若p(x)为随机变量X的概率分布函数，则E(X)=-sum(pi*log2(pi)), pi表示随机变量X的概率。

对任意一个有限的二进制串，其平均信息量为：
    E = -P(0)*log2(P(0))-(P(1)*log2(P(1)))/2+(P(n-1)*log2(P(n-1))/n+1)

设X是一个长度为n的二进制串，Y为X的n-r+1...n-1长度的部分，则
    P(y)=P(x[n-r+1...n])
    P(x[i...n])=P(y[i-l+1...i])*P(y[i-l]*y[i-l+1...i-1]), l为块长度。

假设信息量均衡时，Y所包含的信息量应达到最大，即E(Y)最高。显然，当块长度等于信息熵时，块间的相互独立。但是，如果不进行任何优化，块长度永远不会等于信息熵。块长度太小，那么信息传输效率很低；块长度太大，那么可能丢失了重要的信息。

在SHA-1中，块长度设置为512bit，即一个数据块包含64个字长为32位的数据。因为信息熵为160bit，因此此处采用这种块长度。

## 3.4 性能分析
SHA-1的性能分析依赖于两个主要因素：计算量和内存消耗。

1. 计算量：SHA-1的计算量可认为是512位整数运算的次数的多项式级数，即 O(N^2) 级别。
2. 内存消耗：SHA-1采用的是分组密码算法，即一次加密一个数据块，因此需要额外存储一些中间数据。但存储空间需求总体不超过512位，仅占用约2KB的内存。

## 3.5 SHA-1和MD5的比较
| |SHA-1|MD5|
|-|-|-|
|输入块长度|512bits|512bits|
|摘要长度|160bits|128bits|
|性能分析指标|时间复杂度O(N^2)|时间复杂度O(N)|
|碰撞概率|极小的碰撞概率，可以有效防止碰撞攻击|极大的碰撞概率，不能阻止碰撞攻击|
|文件校验|不支持|支持|

# 4.Python实现SHA-1算法
## 4.1 模块导入
```python
import binascii # Python3中用binascii模块，Python2中用hexlify()函数
from struct import *    # Python的struct模块提供高效的二进制数据打包和解包功能
```
## 4.2 定义sha1函数
```python
def sha1(msg):

    # 初始化参数
    h0 = 0x67452301        # 32位整数
    h1 = 0xEFCDAB89        # 32位整数
    h2 = 0x98BADCFE        # 32位整数
    h3 = 0x10325476        # 32位整数
    h4 = 0xC3D2E1F0        # 32位整数
    
    msg_bytearray = bytearray(msg,'utf-8')   # 转化成UTF-8编码的字节数组
    
    length = len(msg_bytearray)               # 获取消息长度
    message_head = pack('!I',length<<3)       # 生成消息头，最后3位不存数据
    total_message = message_head + msg_bytearray # 合并消息头和消息
    
    # 操作消息
    for i in range(0,len(total_message)-64,64):

        w = []
        
        # 扩展成 80 个字长为 32 位的数据块 W[i]
        for j in range(16):
            offset = i + (j << 2)
            w.append((ord(total_message[offset]) << 24) | 
                    (ord(total_message[offset+1]) << 16) | 
                    (ord(total_message[offset+2]) << 8) |
                    ord(total_message[offset+3]))
            
        for j in range(16,80):
            w.append(((w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16]) << 1) & 0xffffffff)
            
        # 更新参数
        a = h0
        b = h1
        c = h2
        d = h3
        e = h4
        
        for j in range(80):
            
            if j < 20:
                f = (b & c) | ((~b) & d)
                k = 0x5A827999
                
            elif j < 40:
                f = b ^ c ^ d
                k = 0x6ED9EBA1
                
            elif j < 60:
                f = (b & c) | (b & d) | (c & d) 
                k = 0x8F1BBCDC
                
            else:
                f = b ^ c ^ d
                k = 0xCA62C1D6
                
             # 左移运算
            temp = (a << 5) + f + e + k + w[j] & 0xffffffff
            a = d
            d = c
            c = (b << 30) & 0xffffffff
            b = b >> 2
            e = temp
            
        # 计算当前结果
        h0 = (h0 + a) & 0xffffffff
        h1 = (h1 + b) & 0xffffffff
        h2 = (h2 + c) & 0xffffffff
        h3 = (h3 + d) & 0xffffffff
        h4 = (h4 + e) & 0xffffffff
        
    return ''.join([('%08x'%i) for i in [h0,h1,h2,h3,h4]])
```
## 4.3 测试sha1函数
```python
print(sha1("abc"))      # 3c01bdbb 
print(sha1(""))         # da39a3ee 5e6b4b0d 3255bfef 95601890afd80709
print(sha1("The quick brown fox jumps over the lazy dog."))
                            # 2fd4e1c6 7a2d28fc ed849ee1 bb76e739 1b93eb12