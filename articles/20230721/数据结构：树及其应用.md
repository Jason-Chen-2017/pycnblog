
作者：禅与计算机程序设计艺术                    
                
                
在现代社会中，数据结构可以说是一个不可或缺的环节。数据结构是计算机科学最基础也是最重要的一门课程。由于数据的复杂性，各种类型的数据都需要用数据结构来进行组织管理。树是一种非常有效率的数据结构。它能够将复杂的数据进行分类、存储、检索等操作。它代表了一种非线性数据集合的集合，数据结构中树的应用非常广泛。因此，掌握树这种数据结构，是对算法工程师来说一个必备技能。

树（Tree）是指一组具有层次关系的数据元素。树是一种抽象数据类型，用来模拟具有树形结构的集合。树由节点和边组成，节点表示集合中的元素，边则表示节点之间的联系。通常树都是根部为根节点，而其他节点为子节点或者叶节点。树有三种基本的形态——完全二叉树、满二叉树和平衡二叉树。

树的主要特征如下：

1. 每个节点都只有一个父亲节点；
2. 没有回路；
3. 每个子树都是一棵互不相交的树；
4. 如果某一节点有两个子节点，那么这个节点一定是分支点。

树是一种重要的数据结构，在操作系统、数据库、文件系统、算法设计中均有所应用。树算法涉及很多的算法，如查找、排序、遍历等等。在本专栏中，我们将会详细介绍树的定义、树的相关术语、常用的树算法及其实现方法。希望通过我们的学习，能够让读者更好地理解树，并提升自己的编程能力。

# 2.基本概念术语说明
首先，我们需要了解树的一些基本概念、术语和术语的意义。

## （1）根节点(Root Node)

树的根节点或者称作根，是树中最高的一级节点，也就是说，它是树的入口。在一棵树中，除了根节点之外，每个节点都有一个唯一的父节点。树的根节点没有父节点。在实际生活中，树的根节点常常被称作“树”。

![image-20210719134917108](https://gitee.com/redtide/photo/raw/master//blog_img/20210719134917.png)

## （2）分支(Branch)

分支又称为支，是树的一条边，由一条线段连接两个结点。在树中，一条分支可能有多个分支，也可以没有分支。它与分支相邻的结点叫做该分支上的终端结点。在一棵树中，除根节点以外，每一个内部节点都至少有两个孩子。一个节点可以有多个孩子，但是只能有一个父节点。

## （3）子节点(Child Node)

子节点或者称作儿子，是在某个节点下面的节点。一个节点可以有零个、一个或多个孩子。子节点可以是任何类型的节点，包括子树。

## （4）父节点(Parent Node)

父节点或者称作父亲，是指当前节点的直接上级节点。一个节点只有一个父节点。

## （5）兄弟节点(Sibling Node)

兄弟节点是指具有相同父节点的节点。兄弟节点可以是任何类型的节点，包括子树。

## （6）高度(Height)

树的高度是指从树根节点到最远叶子节点的路径长。树的高度是指树中所有分支的最大长度。树的高度一般用一个整数来表示，并且满足树高>=1。

## （7）深度(Depth)

树的深度是指根节点到任意节点的路径长。树的深度是指树中分支的最大程度。树的深度一般用一个整数来表示，并且满足树深度>=1。

## （8）度(Degree)

树的度是指树中各节点的子节点个数称为度。度的取值范围是从0到无穷大。对于树，其度的大小反映了节点的特殊性。对于一般图，度也可认为是顶点的度序列，但对于树，其度就是树中各节点子节点的数量。

![image-20210719135104710](https://gitee.com/redtide/photo/raw/master//blog_img/20210719135105.png)

对于上述树的度，可以看到度的大小为3。

## （9）边(Edge)

边（edge）是树的一个重要概念，它是连接两个节点之间的一条连接线。树中每个节点都存在一条入度和一条出度。入度是指该节点指向它的边的个数；出度是指该节点被指向它的边的个数。

## （10）路径（Path）

路径是指从树的根节点到某个节点的中间节点的路径。路径上的每条边都是该节点的子孙节点。

## （11）层次(Level)

层次是指树的某一深度处的节点的集合。根节点处于第0层。如果某一节点处于第n层，那么它所有的后裔节点，它们的父节点也都处于第n层。

# 3.核心算法原理和具体操作步骤以及数学公式讲解

树的主要算法有插入、删除、搜索、遍历等。下面我将介绍这些算法的基本原理和具体操作步骤以及数学公式。

## （1）插入

插入是指向树中添加一个新的节点。插入新节点的方法可以有以下两种：

### a、普通插入法

普通插入法是指，将新节点插入到合适位置的叶子节点之前。首先找到插入位置的父节点，然后创建新节点，设置它的左右孩子指针，将新节点插入到父节点的左孩子节点中，同时更新父节点的左孩子指针。

例如，下面我们要在上图中插入节点6：

![image-20210719140632982](https://gitee.com/redtide/photo/raw/master//blog_img/20210719140633.png)

第一步：找到插入位置的父节点，即5。

第二步：创建一个新的节点6，设置它的左右孩子指针为空。

第三步：将新节点6插入到父节点5的左孩子节点中。

第四步：更新父节点5的左孩子指针为6。

最后得到结果树如下：

![image-20210719140748832](https://gitee.com/redtide/photo/raw/master//blog_img/20210719140749.png)

### b、分解与合并法

分解与合并法是指，先将树分解为两个子树，再分别插入到合适位置。其过程如下：

### ① 找出欲插入节点的适当位置。

假设我们要插入节点X，首先找到X的插入位置的父节点，并将X拆分为左右子树，其中X的左子树为T0，其右子树为T1。根据X的性质，确定T0和T1的结构。例如，如果X是B节点的左孩子，那么T0=D和T1=F，如果X是C节点的右孩子，那么T0=E和T1=G。

![image-20210719141016447](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141016.png)

### ② 在适当位置上分解树。

将整棵树切割成两颗子树，如图：

![image-20210719141125355](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141125.png)

### ③ 分别处理两颗子树。

将两棵子树分别进行普通插入法的插入，即将待插入节点插入到合适位置的叶子节点之前。

### ④ 将两颗子树合并成一棵树。

用T0的根节点替代X，用T1替换掉X的位置，就得到最终的树。

![image-20210719141252439](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141252.png)

例如，在B节点下插入节点Y：

![image-20210719141344202](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141344.png)

第一步：找到插入位置的父节点，即B。

第二步：拆分为左右子树。左子树为D，右子树为F。

第三步：分别对子树进行普通插入法的插入。

第四步：将左右子树合并成一棵树。

第五步：用D的根节点B替代X，用F替换掉X的位置，就得到最终的树。

![image-20210719141436990](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141437.png)

这种方法的时间复杂度为O(logN)，适用于树较大的情况。

## （2）删除

删除是指从树中移除一个节点。

### a、内删除

内删除是指从某个内部节点处删除节点，需要考虑该节点是否有两个孩子，以及它的孩子是否还有孩子。在内部删除的时候，可以选择将该节点替换为它的第一个孩子或者最后一个孩子。

例如，在上图中删除节点6：

![image-20210719141738332](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141738.png)

第一步：找到6的父节点，即5。

第二步：判断6是否有两个孩子。若没有，则只需将6置空即可。否则，则选择其左或右孩子作为6的后继节点，并将后继节点的值赋给6，然后删除后继节点。

第三步：更新父节点的左或右孩子指针。

最后得到结果树如下：

![image-20210719141920466](https://gitee.com/redtide/photo/raw/master//blog_img/20210719141920.png)

### b、外删除

外删除是指从树的外部删除节点。该方法分为三步：

### ① 查找和复制后继节点。

先查找待删除节点的后继节点，并复制后继节点的信息。可以选择前驱节点、后继节点或者与待删除节点等价的节点作为后继节点。

### ② 用后继节点替换待删除节点。

将后继节点的值赋给待删除节点，然后删除后继节点。

### ③ 更新节点的链接关系。

更新节点的链接关系，包括更新其父节点的链接、子节点的链接。

![image-20210719142028387](https://gitee.com/redtide/photo/raw/master//blog_img/20210719142028.png)

例如，在上图中删除节点E：

![image-20210719142111803](https://gitee.com/redtide/photo/raw/master//blog_img/20210719142111.png)

第一步：查找后继节点，即G。

第二步：用G的父节点C的值来替换E的父节点D的值。

第三步：删除G。

第四步：更新E的父节点的子节点指针。

最后得到结果树如下：

![image-20210719142230129](https://gitee.com/redtide/photo/raw/master//blog_img/20210719142230.png)

这种方法的时间复杂度为O(N)，因为每次查找和复制都需要遍历整棵树。

## （3）搜索

搜索是指在树中查找一个指定的值。搜索的方式有深度优先搜索和宽度优先搜索。

### 深度优先搜索DFS

深度优先搜索（Depth First Search，DFS）是一种迭代遍历树的方法。在深度优先搜索中，沿着树的深度遍历树的节点，尽可能深的搜索树的分支。如果目标节点被发现，则立刻结束搜索。

算法过程如下：

1. 创建一个栈，压入根节点。

2. 重复步骤3-5，直到栈为空：

   a. 从栈弹出一个节点。
   
   b. 检查该节点是否是目标值。
   
   c. 如果该节点有右孩子，则将右孩子压入栈。
   
   d. 如果该节点有左孩子，则将左孩子压入栈。
   
3. 当栈为空时，表示树中没有符合条件的节点。

![image-20210719142508985](https://gitee.com/redtide/photo/raw/master//blog_img/20210719142509.png)

例如，在上图中查找值为3的节点：

第一步：创建一个栈，压入根节点5。

第二步：从栈弹出节点5。

第三步：检测节点5是否等于3。

第四步：节点5不是目标节点，它没有右孩子，所以忽略该节点。

第五步：节点5没有左孩子，所以忽略该节点。

第六步：再次重复步骤2-5，栈为空，停止搜索。

### 宽度优先搜索BFS

宽度优先搜索（Breadth First Search，BFS）是一种广度优先搜索算法。它采用队列实现，按层次遍历树。算法过程如下：

1. 创建一个队列，加入根节点。

2. 重复步骤3-5，直到队列为空：

    a. 从队首弹出一个节点。
    
    b. 检查该节点是否是目标值。
    
    c. 如果该节点有左孩子，则将左孩子加入队列。
    
    d. 如果该节点有右孩子，则将右孩子加入队列。
    
3. 当队列为空时，表示树中没有符合条件的节点。

![image-20210719142738994](https://gitee.com/redtide/photo/raw/master//blog_img/20210719142739.png)

例如，在上图中查找值为3的节点：

第一步：创建一个队列，加入根节点5。

第二步：从队列弹出节点5。

第三步：检测节点5是否等于3。

第四步：节点5不是目标节点，它没有左孩子，所以忽略该节点。

第五步：节点5没有右孩子，所以忽略该节点。

第六步：再次重复步骤2-5，队列为空，停止搜索。

## （4）遍历

遍历是指从树的某个节点开始，依次访问其所有子节点。遍历的方法有前序遍历、中序遍历和后序遍历。

### 前序遍历

前序遍历是指先访问根节点，再先序遍历左子树，最后先序遍历右子树。其过程如下：

1. 访问根节点。

2. 对左子树进行先序遍历。

3. 对右子树进行先序遍历。

![image-20210719143217189](https://gitee.com/redtide/photo/raw/master//blog_img/20210719143217.png)

例如，对上图进行前序遍历：

第一步：访问根节点A。

第二步：对左子树进行先序遍历，即先访问B，然后访问D，然后访问E。

第三步：对右子树进行先序遍历，即先访问C，然后访问F。

第四步：遍历完成。

### 中序遍历

中序遍历是指先序遍历左子树，再访问根节点，最后先序遍历右子树。其过程如下：

1. 对左子树进行中序遍历。

2. 访问根节点。

3. 对右子树进行中序遍历。

![image-20210719143435498](https://gitee.com/redtide/photo/raw/master//blog_img/20210719143435.png)

例如，对上图进行中序遍历：

第一步：对左子树进行中序遍历，即先访问D，然后访问B，然后访问E。

第二步：访问根节点A。

第三步：对右子树进行中序遍历，即先访问C，然后访问F。

第四步：遍历完成。

### 后序遍历

后序遍历是指先序遍历左子树，再先序遍历右子树，最后访问根节点。其过程如下：

1. 对左子树进行后序遍历。

2. 对右子树进行后序遍历。

3. 访问根节点。

![image-20210719143601360](https://gitee.com/redtide/photo/raw/master//blog_img/20210719143601.png)

例如，对上图进行后序遍历：

第一步：对左子树进行后序遍历，即先访问D，然后访问E，然后访问B。

第二步：对右子树进行后序遍历，即先访问C，然后访问F。

第三步：访问根节点A。

第四步：遍历完成。

# 4.具体代码实例和解释说明

下面，我们结合代码实例介绍树的相关算法和数据结构的实现。这里为了方便阅读，使用python语言来实现树的操作。

## （1）树的实现

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        
class Tree:
    def __init__(self):
        self.root = None
        
    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            queue = [self.root]
            while len(queue)>0:
                node = queue[0]
                queue = queue[1:]
                
                if not node.left:
                    node.left = TreeNode(val)
                    return 
                elif not node.right:
                    node.right = TreeNode(val)
                    return 
                
                queue += [node.left, node.right]
    
    def search(self, val):
        if not self.root:
            print("Empty tree")
        else:
            queue = [self.root]
            visited = []
            
            while len(queue)>0:
                node = queue[0]
                queue = queue[1:]
                
                if node.val == val:
                    return True
                elif node.val in visited:
                    continue
                
                visited.append(node.val)
                
                queue += [node.left, node.right]
                
            print("Not found")
            
    def delete(self, val):
        if not self.root:
            print("Empty tree")
            return
        
        # find the target node to be deleted and its parent node 
        stack = [(self.root, None)]
        parent = None
        target_node = None
        
        while stack:
            node, pnode = stack.pop()
            
            if node is None or node.val == val:
                break
            
            if node.left and node.left.val!= val:
                stack.append((node.left, node))
                
            if node.right and node.right.val!= val:
                stack.append((node.right, node))
            
            if node.val == val:
                target_node = node
                parent = pnode
        
        if target_node is None:
            print("{} Not Found".format(val))
            return
        
        # case 1: target node has no child
        if not (target_node.left or target_node.right):
            if parent is None:
                self.root = None
            elif parent.left and parent.left.val == val:
                parent.left = None
            elif parent.right and parent.right.val == val:
                parent.right = None
                
        # case 2: target node has only one right child
        elif target_node.left is None:
            if parent is None:
                self.root = target_node.right
            elif parent.left and parent.left.val == val:
                parent.left = target_node.right
            elif parent.right and parent.right.val == val:
                parent.right = target_node.right
                
        # case 3: target node has only one left child
        elif target_node.right is None:
            if parent is None:
                self.root = target_node.left
            elif parent.left and parent.left.val == val:
                parent.left = target_node.left
            elif parent.right and parent.right.val == val:
                parent.right = target_node.left
                
        # case 4: target node has two children    
        else:
            successor = target_node.right
            
            # find successor
            while successor.left:
                successor = successor.left
            
            target_node.val = successor.val
            
            # update link between successor's parent and its child 
            if successor.parent.left and successor.parent.left.val == successor.val:
                successor.parent.left = successor.right
            else:
                successor.parent.right = successor.right
                
        # relink parents of all nodes below target node   
        for node in self._iter():
            if node.left and node.left.val > val:
                node.left = node.left.left or node.left.right  
                
            if node.right and node.right.val > val:
                node.right = node.right.left or node.right.right     
                    
    def preorderTraversal(self, root):
        """preorder traversal"""
        result = []
        if root is not None:
            result.append(root.val)
            result += self.preorderTraversal(root.left)
            result += self.preorderTraversal(root.right)
        return result
    
    def inorderTraversal(self, root):
        """inorder traversal"""
        result = []
        if root is not None:
            result += self.inorderTraversal(root.left)
            result.append(root.val)
            result += self.inorderTraversal(root.right)
        return result
    
    def postorderTraversal(self, root):
        """postorder traversal"""
        result = []
        if root is not None:
            result += self.postorderTraversal(root.left)
            result += self.postorderTraversal(root.right)
            result.append(root.val)
        return result
    
    def levelOrder(self):
        """level order traversal"""
        if not self.root:
            return []
        
        result = [[self.root]]
        q = [self.root]
        
        while q:
            nextq = []
            for i in range(len(q)):
                node = q.pop(0)
                if node.left:
                    nextq.append(node.left)
                if node.right:
                    nextq.append(node.right)
            if nextq:
                result.append(nextq)
                
        return [node.val for sublist in result for node in sublist]
            
    def _iter(self):
        if not self.root:
            yield None
        else:
            queue = [self.root]
            while queue:
                node = queue.pop(0)
                yield node
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)  
```

## （2）树的操作示例

```python
if __name__=="__main__":
    t = Tree()
    
    #insert
    t.insert(5)
    t.insert(3)
    t.insert(8)
    t.insert(1)
    t.insert(4)
    t.insert(7)
    t.insert(10)
    t.insert(12)
    t.insert(6)
    t.insert(9)
    
    #search
    assert t.search(1)==True
    assert t.search(13)==False
    
    #delete
    t.delete(6)
    t.delete(8)
    
    #print tree
    import pprint
    pp = pprint.PrettyPrinter(indent=4)
    pp.pprint([i for i in t._iter()])
    
''' output:
[{'left': {'left': None,
           'right': None,
           'val': 3},
  'right': {'left': {'left': None,
                     'right': None,
                     'val': 7},
            'right': {'left': None,
                      'right': None,
                      'val': 10},
            'val': 8},
  'val': 5},
 {'left': {'left': {'left': None,
                   'right': None,
                   'val': 1},
           'right': {'left': None,
                     'right': None,
                     'val': 4},
           'val': 3},
  'right': {'left': {'left': None,
                     'right': None,
                     'val': 6},
            'right': {'left': None,
                      'right': None,
                      'val': 9},
            'val': 7},
  'val': 10}]
'''
```

