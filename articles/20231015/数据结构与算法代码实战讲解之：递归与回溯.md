
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 递归（Recursion）
递归，指的是函数自己调用自己，这种特性使得函数可以解决一些复杂的问题。它的实现一般采用栈的数据结构，在计算机中称为“堆栈溢出”或“栈溢出”，即递归太多层而导致内存超出限制。

递归函数一般都存在以下特点：

1、函数体内嵌套调用自身；

2、函数返回值是由自身计算得到；

3、重复执行相同的子问题；

4、需要保存局部变量并对其进行恢复。

所以，递归函数的编程技巧主要是两个方面：一是明确边界条件，二是不断剥离无用重复调用。下面通过一道题目看一下如何将递归转换成非递归算法。
## 一道题目——连续子数组的最大和
### 描述
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

### 方法一：直接遍历
如果不能用分治法，只能用暴力穷举法。这里遍历数组，对于每一个位置i，求以i结尾的连续子数组的最大和，并记录到全局变量max_sum中。由于只需存储上一次的结果即可，因此不需要额外空间。

时间复杂度为O(N^2)，空间复杂度为O(1)。

```python
def maxSubArray(nums):
    n = len(nums)
    max_sum = float('-inf')
    for i in range(n):
        curr_sum = 0
        for j in range(i, n):
            curr_sum += nums[j]
            if curr_sum > max_sum:
                max_sum = curr_sum
    return max_sum
```

### 方法二：分治法
分治法能够把原问题划分成多个子问题，然后逐个解决子问题，最后再合并子问题的解得到原问题的解。分治法比直接穷举法效率高很多。

对于这个问题，将数组两端分别作为左右边界，并将中间一段拆成两半，分别求其最大和。然后比较两端和中间段的最大和，取最大的一个作为该区域的最大和。这样，能同时考虑左右两端的最大和，以及该区域内可能有的最大值。

时间复杂度为O(NlogN)，空间复杂度为O(logN)。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # base case
        if not nums:
            return None

        # divide array into two halves and find the maximum subarray sum of each half recursively
        left_sum = self.maxSubArrayHelper(nums[:len(nums)//2])
        right_sum = self.maxSubArrayHelper(nums[len(nums)//2:])
        
        # merge two halves to form a new subarray with crossing middle element
        mid_idx = (len(nums)-1) // 2
        cross_mid_sum = -float('inf')
        temp_sum = 0
        for idx in range(mid_idx+1)[::-1]:
            temp_sum += nums[idx]
            if temp_sum > cross_mid_sum:
                cross_mid_sum = temp_sum
        temp_sum = 0
        for idx in range(mid_idx-1, -1, -1):
            temp_sum += nums[idx]
            if temp_sum > cross_mid_sum:
                cross_mid_sum = temp_sum

        # combine three parts to get final result
        total_sum = max([left_sum, right_sum, cross_mid_sum + nums[mid_idx]])
        return total_sum

    def maxSubArrayHelper(self, nums):
        # recursive helper function to compute maximum subarray sum of given subarray
        if not nums:
            return None

        if len(nums) == 1:
            return nums[0]

        mid_idx = len(nums) // 2
        left_half_sum = self.maxSubArrayHelper(nums[:mid_idx])
        right_half_sum = self.maxSubArrayHelper(nums[mid_idx:])

        return max([left_half_sum, right_half_sum, self.crossMaxSum(nums)])
    
    def crossMaxSum(self, nums):
        # auxiliary function that computes the maximum subarray sum that crosses the middle point
        mid_idx = len(nums) // 2
        left_sum = right_sum = float('-inf')
        temp_sum = 0
        for i in reversed(range(mid_idx)):
            temp_sum += nums[i]
            if temp_sum > left_sum:
                left_sum = temp_sum
        temp_sum = 0
        for i in range(mid_idx, len(nums)):
            temp_sum += nums[i]
            if temp_sum > right_sum:
                right_sum = temp_sum
        return left_sum + right_sum
```