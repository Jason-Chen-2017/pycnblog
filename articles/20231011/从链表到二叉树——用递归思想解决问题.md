
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


很多数据结构都可以抽象成链表或者树形结构，比如数组、栈、队列、树等，本文通过用递归的方式实现将链表转化成二叉树来解决此问题，并分析时间复杂度、空间复杂度及其优化方法。


# 2.核心概念与联系
链表（Linked List）：是一种线性表数据结构，每个节点里存放着数据元素和一个指针域（或引用），指向下一个节点；若最后一个节点指向NULL，则表示该链表为空。

二叉树（Binary Tree）：是一种树形数据结构，它是由根结点和两个不相交的子树组成，左子树中的每个结点的值小于它的根结点的值，右子树中每个结点的值大于它的根结点的值。


链表转二叉树（Recursive Conversion）：假设已知一个带头结点的单向链表，需要将该链表转换成一棵二叉树，并且要求时间复杂度和空间复杂度低于O(n)。

一般来说，链表转二叉树的两种思路：迭代法和递归法。其中，迭代法比较简单，但耗费更多的内存空间；递归法较为复杂，但是更高效。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 算法流程

1. 创建空的根节点，设置尾指针tail指向根节点。

2. 将链表从头节点开始遍历，将每个节点插入到对应位置的子树中。

   - 如果当前节点的左孩子为空，则将当前节点作为左孩子插入到父节点所在的子树中。
   - 如果当前节点的左孩子不为空，则以该节点的左孩子为起点继续遍历链表，直至遇到第一个左孩子为空的节点为止。将该节点插入到父节点所在的子树的左孩子节点处。
   - 当没有空的左孩子时，将当前节点作为右孩子插入到父节点所在的子树中。
   
     ```
      // 链表遍历函数
      void insertNode(TreeNode* root, ListNode* node) {
          if (root == nullptr || node == nullptr) return;
          
          // 判断是否存在空的左孩子
          while (root->left!= nullptr && node->val > root->val)
              root = root->left;
              
          // 插入到对应的子树中
          TreeNode* new_node = new TreeNode(node->val);
          if (node->val < root->val) 
              root->left = new_node;
          else if (root->right == nullptr) 
              root->right = new_node;
          else {
              TreeNode* curr = root->right;
              while (curr->left!= nullptr && node->val >= curr->val)
                  curr = curr->left;
              curr->left = new_node;
          }
      }
      
      
      // 创建空的根节点
      TreeNode* root = new TreeNode(-1); // 这里设置根节点的值为负无穷值，方便后续判断
      tail = root;  // 设置尾指针
      
      // 链表遍历
      while (head!= NULL) {
          // 插入到对应子树中
          insertNode(tail, head);
          // 更新尾指针
          if (tail->right == nullptr) tail = tail->left;
          else tail = tail->right;
          // 删除处理过的节点
          ListNode* temp = head;
          head = head->next;
          delete temp;
      }
      
       // 返回根节点
      return root->right; 
     ```
     
## 时间复杂度分析

按照算法流程，每一个节点都会被访问一次，所以总的时间复杂度为O(n)，即为访问所有节点所需的最长路径长度。

## 空间复杂度分析

采用递归方式实现的链表转二叉树，算法本身的空间复杂度为O(h), h为树的高度，而树的高度取决于链表的长度，所以当链表变得很长时，空间复杂度会变得很大。所以，为了降低空间复杂度，可以采取以下策略：

1. 使用Morris遍历的方法，不需要维护一个额外的栈结构，只需要修改链表节点之间的链接关系即可，这样就可以在O(1)时间内删除已经处理完的节点。

   ```
   void inorderTraversal(TreeNode* root){
        MorrisTraversal(root);
   }
   
   TreeNode *MorrisTraversal(TreeNode* node){
        TreeNode *current = node, *predecessor = nullptr;
        while(current!=nullptr){
            if(current->left==nullptr){
                printf("%d ", current->val);
                predecessor=current;
                current=current->right;
            }else{
                //找到前驱节点
                predecessor=current->left;
                while(predecessor->right!=nullptr&&predecessor->right!=current){
                    predecessor=predecessor->right;
                }
                
                //建立连接
                if(predecessor->right==nullptr){
                    predecessor->right=current;
                    current=current->left;
                }else{
                    predecessor->right=nullptr;
                    printf("%d ", current->val);
                    current=current->right;
                }
            }
        }
        return nullptr;
   }
   ```
   
   
   
2. 在创建二叉树的过程中，可以不直接创建各个节点，而是先申请出足够的存储空间，然后再通过指针进行分配。这种方法比上面提到的Morris方法节省了一些内存。