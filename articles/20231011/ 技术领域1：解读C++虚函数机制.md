
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


C++语言是一个支持多重继承的面向对象编程语言，其中一个重要特性就是允许类的派生类重载基类中的虚函数，从而实现多态性（polymorphism）。但是当基类存在多个虚函数时，会出现虚函数的“虚假重载”现象。这是因为虚函数的调用过程由编译器进行优化，因此无法得知到底哪个虚函数被调用，只能根据实参类型找到最匹配的虚函数调用。在没有任何信息的情况下，编译器只能在虚函数表中顺序搜索找到第一个匹配的函数，这样就会造成“虚假重载”。为了解决这个问题，C++引入了虚函数解析（Virtual Function Dispatch）技术。

# 2.核心概念与联系
## 什么是虚函数？为什么要用虚函数？
所谓虚函数（Virtual function），是指派生类可以重新定义其父类的虚方法，也称为方法覆盖（Override）或方法重写。比如，基类Animal有一个虚方法eat()，派生类Dog继承自Animal，可以重新定义eat()方法，使其变成狗独有的。这时，如果创建了一个对象指针指向Animal类型的变量p，指向它的派生类Dog的对象指针d，则可以通过p->eat()直接调用派生类的eat()方法，而不是基类的eat()方法。这样，我们就实现了多态性（Polymorphism）。通过虚函数，我们可以在运行期间根据实际对象的类型调用相应的方法。

原因：1、隐藏继承关系，将派生类对基类方法的调用转移给基类处理；

　　2、减少代码冗余，只需定义一次基类方法，就可以应用到所有子类；

　　3、提高代码灵活性，可以通过改变虚函数的指向来改变运行时的行为；

　　4、实现基于接口而不是实现的抽象机制，确保子类和客户端都遵循同一协议。

## 虚函数表
虚函数表（Virtual Function Table，VFT）是一种数据结构，用来存储虚函数相关的信息，包括虚函数的地址、偏移量等。每一个类都有一个虚函数表，它记录了该类及其派生类的每个虚函数的地址。编译器维护着一个全局的虚函数表，所有的类实例共用这个表。通过虚函数表，编译器能够定位到正确的虚函数，并调用到相应的代码段。

## 函数调用流程
以下是函数调用的基本流程：

　　　　　　　首先，编译器根据被调函数的名字在当前作用域查找对应的函数符号，并把相关的信息放入栈帧内，包括函数参数，返回地址等。然后，计算被调函数的内存地址并存入指令指针寄存器IP。

　　　　　　　接下来，CPU从栈帧中取出相关的参数，进行必要的计算后，跳转到被调函数代码的起始位置执行。执行过程中，可能需要进行一些检查工作，例如检查函数参数是否合法，分配或释放内存等。

　　　　　　　函数执行完毕后，CPU根据函数的返回值类型，把结果存回栈帧中，并更新堆栈指针ESP的值。

　　　　　　　最后，CPU根据返回地址的内容，决定是否继续执行下一条待执行的指令，或者转移到其他地方继续执行。如果函数正常退出，返回地址一般是调用函数处的下一条指令；如果函数异常退出，返回地址一般指向某个错误处理代码，帮助程序员排查错误。

在虚拟机系统中，类和对象并不真正存在于内存中，而是作为对象的一部分存在于运行时堆区。每当创建一个新的对象，就对应在堆区创建一个实体（Object Entity）。对象实体除了保存对象的状态（成员变量），还包含指向类的虚函数表的指针，用于动态绑定。

## C++的虚函数解析规则
虚函数表中的每一项是一个函数指针，指向一个虚函数在内存中的首地址。在构造函数，析构函数，拷贝构造函数，赋值运算符等特殊成员函数的解析上，C++遵循一套特殊的解析规则：

　　　　　　　　　　　　　　　编译器在编译时，根据类继承关系，生成虚函数表，并按照一定规则确定虚函数的顺序。

　　　　　　　　　　　　　　　在虚函数表中，基类虚函数的位置永远在派生类虚函数之前。

　　　　　　　　　　　　　　　编译器根据调用者类型和函数签名，在虚函数表中找到适合的虚函数，并将其函数指针放入栈帧中。

　　　　　　　　　　　　　　　若虚函数不存在于当前类中，则按照继承链往上搜索。

　　　　　　　　　　　　　　　若依然找不到符合条件的虚函数，则调用的是非虚函数的版本。

　　　　　　　　　　　　　　　若调用静态函数，则调用的是虚函数表中的第一个虚函数指针。