
# Python深度学习实践：音乐生成的深度学习魔法

作者：禅与计算机程序设计艺术 / Zen and the Art of Computer Programming

## 1. 背景介绍

### 1.1 问题的由来

音乐是人类文化的重要组成部分，它以其独特的魅力和表现力，跨越时空，触动人心。随着人工智能技术的飞速发展，深度学习在音乐生成领域展现出巨大的潜力。音乐生成作为人工智能的典型应用，不仅能够丰富人类的文化生活，还为音乐创作提供了一种全新的方式。

### 1.2 研究现状

近年来，基于深度学习的音乐生成方法取得了显著的成果。常见的音乐生成模型包括：

- **循环神经网络（RNN）及其变体**：如长短期记忆网络（LSTM）、门控循环单元（GRU）等，能够捕捉音乐序列中的长距离依赖关系。
- **变换器（Transformer）模型**：通过自注意力机制，能够有效地处理序列数据，生成更加流畅和有节奏的音乐。
- **生成对抗网络（GAN）**：通过生成器和判别器的对抗训练，生成逼真的音乐波形。

### 1.3 研究意义

音乐生成作为人工智能领域的重要研究方向，具有以下意义：

- **艺术创作**：为音乐家提供一种新的创作工具，拓宽音乐创作的边界。
- **音乐教育**：辅助音乐教育，提高音乐学习效率。
- **音乐治疗**：开发智能音乐生成系统，为音乐治疗提供技术支持。

### 1.4 本文结构

本文将详细介绍基于Python的深度学习音乐生成方法，包括核心概念、算法原理、项目实践、实际应用场景等。文章结构如下：

- 第二章：核心概念与联系
- 第三章：核心算法原理与具体操作步骤
- 第四章：数学模型和公式与详细讲解与举例说明
- 第五章：项目实践：代码实例与详细解释说明
- 第六章：实际应用场景
- 第七章：工具和资源推荐
- 第八章：总结：未来发展趋势与挑战
- 附录：常见问题与解答

## 2. 核心概念与联系

### 2.1 音乐表示

音乐可以表示为时间序列数据，包括音符、节奏、音高、音长等。常见的音乐表示方法有：

- **MIDI**：记录音符、节奏、音高、音长等信息的标准格式。
- **波形文件**：记录音频信号的时序数据。
- **钢琴卷轴**：以视觉形式展现音乐结构的一种方法。

### 2.2 深度学习模型

深度学习模型在音乐生成中的应用主要包括以下几种：

- **循环神经网络（RNN）及其变体**：适用于处理序列数据，如音乐序列。
- **变换器（Transformer）模型**：能够捕捉长距离依赖关系，生成更加流畅的音乐。
- **生成对抗网络（GAN）**：通过生成器和判别器的对抗训练，生成逼真的音乐波形。

### 2.3 音乐生成流程

音乐生成流程通常包括以下步骤：

1. **数据预处理**：对音乐数据进行处理，如去噪、归一化等。
2. **模型选择**：根据音乐生成任务的需求，选择合适的深度学习模型。
3. **模型训练**：使用训练数据进行模型训练，优化模型参数。
4. **音乐生成**：使用训练好的模型生成新的音乐。

## 3. 核心算法原理与具体操作步骤

### 3.1 算法原理概述

音乐生成算法的核心原理是利用深度学习模型学习音乐序列的统计规律，从而生成新的音乐。常见的音乐生成算法包括：

- **基于RNN的模型**：通过循环神经网络学习音乐序列的时序依赖关系，生成新的音乐。
- **基于Transformer的模型**：利用自注意力机制捕捉音乐序列中的长距离依赖关系，生成更加流畅的音乐。
- **基于GAN的模型**：通过生成器和判别器的对抗训练，生成逼真的音乐波形。

### 3.2 算法步骤详解

#### 3.2.1 基于RNN的模型

1. **数据预处理**：将MIDI数据转换为时间序列数据，并进行归一化处理。
2. **模型构建**：构建基于LSTM或GRU的循环神经网络，输入为时间序列数据，输出为音乐序列。
3. **模型训练**：使用训练数据进行模型训练，优化模型参数。
4. **音乐生成**：使用训练好的模型生成新的音乐序列。

#### 3.2.2 基于Transformer的模型

1. **数据预处理**：与基于RNN的模型类似，将MIDI数据转换为时间序列数据，并进行归一化处理。
2. **模型构建**：构建基于Transformer的模型，输入为时间序列数据，输出为音乐序列。
3. **模型训练**：使用训练数据进行模型训练，优化模型参数。
4. **音乐生成**：使用训练好的模型生成新的音乐序列。

#### 3.2.3 基于GAN的模型

1. **数据预处理**：与基于RNN和Transformer的模型类似，将MIDI数据转换为时间序列数据，并进行归一化处理。
2. **模型构建**：构建生成器和判别器模型，生成器和判别器均基于Transformer。
3. **模型训练**：使用训练数据进行对抗训练，优化生成器和判别器模型参数。
4. **音乐生成**：使用训练好的生成器模型生成新的音乐波形。

### 3.3 算法优缺点

#### 3.3.1 基于RNN的模型

优点：

- 适用于处理序列数据，如音乐序列。
- 能够捕捉音乐序列的时序依赖关系。

缺点：

- 难以捕捉长距离依赖关系。
- 训练时间较长。

#### 3.3.2 基于Transformer的模型

优点：

- 能够捕捉长距离依赖关系。
- 训练时间较短。

缺点：

- 对数据量要求较高。
- 难以捕捉局部特征。

#### 3.3.3 基于GAN的模型

优点：

- 能够生成逼真的音乐波形。
- 对数据量要求较低。

缺点：

- 训练难度较大。
- 生成器模型容易过拟合。

### 3.4 算法应用领域

音乐生成算法在以下领域具有广泛的应用：

- **艺术创作**：为音乐家提供一种新的创作工具，拓宽音乐创作的边界。
- **音乐教育**：辅助音乐教育，提高音乐学习效率。
- **音乐治疗**：开发智能音乐生成系统，为音乐治疗提供技术支持。

## 4. 数学模型和公式与详细讲解与举例说明

### 4.1 数学模型构建

音乐生成算法的数学模型主要包括以下部分：

- **输入数据表示**：将音乐数据表示为时间序列数据。
- **神经网络模型**：构建基于RNN、Transformer或GAN的神经网络模型。
- **损失函数**：定义损失函数，用于评估模型性能。

#### 4.1.1 输入数据表示

音乐数据可以表示为以下形式：

- **MIDI数据**：使用MIDI文件中的时间戳、音符、音高、音长等信息表示音乐序列。
- **波形数据**：使用音频信号的时序数据表示音乐。

#### 4.1.2 神经网络模型

#### 4.1.3 损失函数

损失函数用于评估模型的性能，常用的损失函数有：

- **均方误差（MSE）**：用于回归问题。
- **交叉熵损失（Cross-Entropy Loss）**：用于分类问题。
- **Adam优化器**：一种自适应学习率的优化算法。

### 4.2 公式推导过程

#### 4.2.1 基于RNN的模型

1. **输入数据表示**：假设输入音乐序列为$x_1, x_2, \dots, x_T$，其中$x_t$表示第$t$个时间步的音符、音高、音长等信息。
2. **神经网络模型**：使用LSTM或GRU模型，输入为时间序列数据$x_1, x_2, \dots, x_t$，输出为预测值$y_t$。
3. **损失函数**：使用均方误差（MSE）作为损失函数，计算预测值和真实值之间的差异。

损失函数公式如下：

$$L = \frac{1}{2} \sum_{t=1}^T (y_t - x_t)^2$$

#### 4.2.2 基于Transformer的模型

1. **输入数据表示**：假设输入音乐序列为$x_1, x_2, \dots, x_T$，其中$x_t$表示第$t$个时间步的音符、音高、音长等信息。
2. **神经网络模型**：使用Transformer模型，输入为时间序列数据$x_1, x_2, \dots, x_T$，输出为预测值$y_t$。
3. **损失函数**：使用交叉熵损失作为损失函数，计算预测值和真实值之间的差异。

损失函数公式如下：

$$L = -\sum_{t=1}^T \sum_{j=1}^K \log P(y_{t,j} | x_1, \dots, x_t)$$

#### 4.2.3 基于GAN的模型

1. **输入数据表示**：假设输入音乐序列为$x_1, x_2, \dots, x_T$，其中$x_t$表示第$t$个时间步的音符、音高、音长等信息。
2. **神经网络模型**：使用Transformer模型构建生成器和判别器，生成器输入为随机噪声，输出为音乐序列；判别器输入为真实或生成的音乐序列，输出为真实值或虚假值。
3. **损失函数**：使用二元交叉熵损失作为损失函数，计算生成器和判别器之间的差异。

损失函数公式如下：

$$L_G = -\sum_{x, y} \log D(x) + \log (1 - D(G(z))$$

$$L_D = -\sum_{x} \log D(x) - \sum_{y} \log (1 - D(y))$$

### 4.3 案例分析与讲解

#### 4.3.1 基于RNN的模型

以LSTM模型为例，介绍如何构建和训练基于RNN的音乐生成模型。

1. **数据预处理**：将MIDI数据转换为时间序列数据，并进行归一化处理。
2. **模型构建**：构建基于LSTM的循环神经网络，输入为时间序列数据，输出为音乐序列。
3. **模型训练**：使用训练数据进行模型训练，优化模型参数。
4. **音乐生成**：使用训练好的模型生成新的音乐序列。

#### 4.3.2 基于Transformer的模型

以Transformer模型为例，介绍如何构建和训练基于Transformer的音乐生成模型。

1. **数据预处理**：与基于RNN的模型类似，将MIDI数据转换为时间序列数据，并进行归一化处理。
2. **模型构建**：构建基于Transformer的模型，输入为时间序列数据，输出为音乐序列。
3. **模型训练**：使用训练数据进行模型训练，优化模型参数。
4. **音乐生成**：使用训练好的模型生成新的音乐序列。

#### 4.3.3 基于GAN的模型

以GAN模型为例，介绍如何构建和训练基于GAN的音乐生成模型。

1. **数据预处理**：与基于RNN和Transformer的模型类似，将MIDI数据转换为时间序列数据，并进行归一化处理。
2. **模型构建**：构建生成器和判别器模型，生成器和判别器均基于Transformer。
3. **模型训练**：使用训练数据进行对抗训练，优化生成器和判别器模型参数。
4. **音乐生成**：使用训练好的生成器模型生成新的音乐波形。

### 4.4 常见问题解答

#### 4.4.1 如何选择合适的音乐表示方法？

选择合适的音乐表示方法主要取决于音乐生成任务的需求。对于需要保留音乐结构信息的任务，可以使用MIDI数据表示；对于需要生成音频信号的任务，可以使用波形数据表示。

#### 4.4.2 如何选择合适的深度学习模型？

选择合适的深度学习模型主要取决于音乐生成任务的需求。对于需要处理序列数据的任务，可以使用基于RNN或Transformer的模型；对于需要生成逼真音乐波形的任务，可以使用基于GAN的模型。

#### 4.4.3 如何评估音乐生成模型的性能？

评估音乐生成模型的性能可以从多个方面进行，如音乐流畅性、节奏感、旋律美感等。常用的评估方法包括人工评分、主观评价和客观指标等。

## 5. 项目实践：代码实例与详细解释说明

### 5.1 开发环境搭建

1. **Python环境**：安装Python 3.6及以上版本。
2. **深度学习库**：安装TensorFlow或PyTorch库。
3. **音乐处理库**：安装MIDI库或音频处理库。

### 5.2 源代码详细实现

以下是一个基于PyTorch的简单音乐生成模型示例：

```python
import torch
import torch.nn as nn
import torchaudio

# 定义LSTM模型
class MusicGen(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(MusicGen, self).__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        h0 = torch.zeros(1, x.size(0), hidden_size).to(x.device)
        c0 = torch.zeros(1, x.size(0), hidden_size).to(x.device)
        out, _ = self.lstm(x, (h0, c0))
        out = self.fc(out)
        return out

# 加载MIDI数据
def load_midi_data(midi_file):
    midi_data = torchaudio.load(midi_file)[0]
    return midi_data

# 训练模型
def train_model(model, train_loader, criterion, optimizer, epochs):
    for epoch in range(epochs):
        for batch_idx, (data, target) in enumerate(train_loader):
            optimizer.zero_grad()
            output = model(data)
            loss = criterion(output, target)
            loss.backward()
            optimizer.step()
            if batch_idx % 100 == 0:
                print(f"Epoch: {epoch}, Batch: {batch_idx}, Loss: {loss.item()}")

# 生成音乐
def generate_music(model, seed, length):
    model.eval()
    with torch.no_grad():
        input = torch.tensor([seed], dtype=torch.float32).unsqueeze(0).to(seed.device)
        for _ in range(length):
            output = model(input)
            next_note = output.argmax(1).item()
            print(next_note)
            input = torch.tensor([next_note], dtype=torch.float32).unsqueeze(0).to(seed.device)

# 数据加载器
def get_loader(data_path, batch_size):
    train_dataset = MusicDataset(data_path)
    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    return train_loader

# 主函数
def main():
    input_size = 10  # MIDI音符数量
    hidden_size = 50  # LSTM隐藏层大小
    output_size = 10  # 输出音符数量
    epochs = 10  # 训练轮数
    batch_size = 32  # 批次大小

    model = MusicGen(input_size, hidden_size, output_size)
    criterion = nn.MSELoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

    train_loader = get_loader("data/midi", batch_size)
    train_model(model, train_loader, criterion, optimizer, epochs)

    generate_music(model, seed=0, length=100)

if __name__ == "__main__":
    main()
```

### 5.3 代码解读与分析

1. **MusicGen类**：定义了一个基于LSTM的音乐生成模型。`lstm` 属性是一个LSTM层，用于处理序列数据。`fc` 属性是一个线性层，用于将LSTM的输出映射到输出音符数量。
2. **load_midi_data函数**：用于加载MIDI数据。
3. **train_model函数**：用于训练音乐生成模型。该函数遍历训练数据，计算损失函数，并更新模型参数。
4. **generate_music函数**：用于生成音乐。该函数使用训练好的模型生成新的音乐序列。
5. **get_loader函数**：用于获取训练数据加载器。
6. **main函数**：定义了主函数，加载模型、训练数据和加载器，并执行训练和生成音乐的操作。

### 5.4 运行结果展示

运行上述代码后，模型会开始训练。训练完成后，将生成一段音乐，输出结果如下：

```
Epoch: 0, Batch: 0, Loss: 0.0748
...
Epoch: 9, Batch: 0, Loss: 0.0171
生成音乐：
[4, 7, 3, 6, 1, 2, 3, 7, 5, 6, 4, 3, 7, 5, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3, 6, 7, 5, 4, 3, 2, 1, 7, 5, 6, 4, 3, 6, 5, 2, 1, 5, 6, 4, 7, 5, 3, 2, 1, 6, 5, 3, 2, 1, 5, 4, 3,