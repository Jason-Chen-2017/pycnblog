
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1 。
注意：你可以认为每种硬币的数量是无限的。

 ## 2. 基本概念术语说明
### （1）硬币币值数组coins
> 一维整数数组，代表不同面额的硬币币值。假设其长度为n，其中n表示不同面额硬币的种类数目。coins[i]表示第i个面值的硬币的面值。
### （2）目标金额amount
> 表示要凑成的总金额。
### （3）状态定义dp
```python
dp = [[] * (amount+1) for _ in range(len(coins))] # dp矩阵初始化，dp[i][j]表示从coins中取出的前i种硬币能组成总额为j时的最少数量
```
`dp[i][j]`表示从coins中取出的前i种硬币能组成总额为j时的最少数量。
### （4）子问题划分
> 如果目标金额amount为0，那么此时不需要用硬币组成钱，可以直接返回0；而如果目标金额amount小于0，则不可能组成钱，返回-1。对于大于等于1的目标金额amount，我们希望找到一个最小的数量k，使得coins数组中取出前i-1种硬币（即硬币币值为0到i-2之间的硬币）能够组成总金额j-coins[i-1]。此时，我们只需要考虑取出的最后一枚硬币（即coins[i-1]枚），而不需要对前面的硬币进行限制。这样，求解问题可以转化为求解子问题：找出取出的最后一枚硬币coins[i-1]（硬币币值为coins[i-1])，是否可以在区间j-(coins[i-1]-1)到j之间凑出。因此，子问题就变成了"是否可以在区间j-(coins[i-1]-1)到j之间凑出"。
## 3. 核心算法原理及具体操作步骤
### （1）初始化dp[][]数组
```python
for i in range(len(dp)):
    dp[i][0] = 1 # 当amount=0时，可取的硬币数量只有0，因此dp[i][0]=1
```
当目标金额amount为0时，即钱已经凑齐，所以无法再取硬币，dp[i][0]置为1。
### （2）递推求解dp[][]数组
```python
for j in range(1, len(dp[0])): 
    for i in range(1, len(dp)):
        if j < coins[i]:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = min(dp[i], dp[i-1][j-coins[i]]) + 1
```
这里使用的是“状态压缩”的方法，将原本的二维dp数组压缩至一维，方便求解。根据子问题划分，我们先遍历目标金额amount的所有值j（包括0），然后从左到右依次遍历所有种类硬币的索引i（从1开始，因为前i-1种硬币都可以使用）。如果硬币i的值coins[i-1]大于当前目标金额j，则不能取，可以跳过，继续遍历下一个硬币。如果硬币i的值coins[i-1]小于或等于当前目标金额j，则可以尝试取或者不取。两种情况的结果取决于之前已经求解的子问题的解。具体来说，如果硬币i未被使用，则之前已经用掉的硬币可以组成总金额j-coins[i-1]；如果硬币i已被使用，则之前已经用掉的硬币也可以组成总金额j-coins[i-1]，但还需要取走另外一枚硬币coins[i-1]才能得到新的目标金额j。因此，我们只需要选取两种情况下的最小值作为最终解。
### （3）输出最优解
```python
if dp[-1][-1] == float('inf'):
    return -1
else:
    return dp[-1][-1]
```
在求解完dp[][]数组后，我们可以通过遍历dp[][]数组的最后一行最后一列，获取到最优解。如果dp[][]数组中任意一个位置的值不是float('inf')，说明存在着一种方案可以满足目标金额amount，并且该方案中的硬币数目最少，因此返回dp[][]数组最后一行的最后一个值即可。否则，说明不存在这种方案，返回-1。