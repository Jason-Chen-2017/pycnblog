
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


在实际应用中，很多时候需要从一个长字符串或者文本中查找出另一个短字符串或者子串。最简单的查找方式就是暴力匹配法，即逐个字符地依次比较，直到找到所有符合条件的子串，这种方法效率非常低下。另外一种高效的方法则是采用算法，例如KMP、BM、AC自动机等，这些算法将字符串匹配的时间复杂度降至线性级别或更低，所以通常性能比暴力匹配要好很多。然而，如果遇到特殊情况，比如规模较大、字符串特征明显等，一般都是自定义实现一些匹配算法。今天，我们就以字符串匹配算法为例，讲述如何通过代码来理解字符串匹配算法的工作原理、优缺点及常用变种算法，帮助读者理解字符串匹配背后的算法思想，快速掌握字符串匹配技巧。
# 2.核心概念与联系
## 字符串匹配算法
### 概念
字符串匹配（string matching）是一个计算机科学领域中很重要的问题。它是指找寻两个或多个字符串之间的相同或相似片段，并定位其位置的技术。字符串匹配算法可以用于诸如DNA序列分析、关键词搜索、文献检索、生物序列比对、压缩文件搜索等各种应用场景。传统上，字符串匹配算法一般分为两类——朴素的字符串匹配算法和改进的字符串匹配算法。本文重点讨论的是字符串匹配的改进算法，包括后缀树（suffix tree）、Boyer-Moore（Boyer-Moore-Horspool）算法、KMP算法和Z-algorithm。
### 定义
**串匹配(string matching)** 是一种模式匹配问题，它假设有一个大串`T[0...n−1]`和一个小串`P[0...m−1]`，其中n>=m>0。串匹配问题的目标是找出所有的`i (0≤i≤n-m)`使得`T[i:i+m]=P`。串匹配问题可以用来在大串中找出子串、数据库查询或替换字符串等功能。

串匹配问题属于字符串算法，也就是研究如何从大量的文本中快速查找或识别目标字符串的问题。传统的串匹配算法由三个步骤组成：预处理、匹配过程和回溯过程。预处理阶段建立字典树；匹配过程中利用字典树进行匹配；回溯过程用于输出所有匹配结果。当然，还有一些其他的算法，如Knuth-Morris-Pratt算法、基于改进的BWT算法、Sunday算法等。本文主要关注改进的串匹配算法。

## 核心算法原理及操作步骤
### KMP算法
#### 基本思想
KMP算法（ Knuth-Morris-Pratt algorithm ）的基本思路是根据已经出现过的某些字符，反向来预测当前字符是否也会出现，然后再一次性跳过这一段可能存在的相同前缀。这样一来，算法避免了重复检查同样的字符，因此运行速度更快。

#### 操作步骤
1. 先求出最长的公共前后缀子串，长度为 lcp（longest common prefix）。
2. 根据 lcp 的长度构造一个 pi 数组，其中 pi[k] 表示失配时移到右边界的距离， pi[k] = max{pi[j]} + k - j ，当且仅当 p[j:j+k] 为公共前缀时，j 是一个合法的下标，注意此处 j 是长度为 k-1 的公共前缀，对于长度大于等于 k 的公共前缀，相应的 pi 值均为最大值。
3. 用 pi 数组来进行匹配，在模式串 P 中从左往右扫描，在主串 T 中对应的位置 i ，如果模式串 P 中的第 k 个字符等于 T 中的第 i 个字符，则继续进行匹配；否则，根据 pi 数组来判断是否应该跳过一些字符，若 pi[k-1] 不等于 −1 ，则令 i += pi[k-1] ，继续匹配；否则，重新匹配。

#### 时间复杂度
KMP 算法的时间复杂度为 O(|T| + |P|)，其中 |T| 和 |P| 分别为待匹配文本和模式串的长度。由于预处理的时间复杂度为 O(|P|^2) ，所以 KMP 算法的平均时间复杂度为 O(|T|+|P|) 。

#### 空间复杂度
KMP 算法的空间复杂度为 O(|P|) ，其中 |P| 为模式串的长度。但为了保证稳定性，在计算 pi 时还需要额外的一个数组 pi' 来存储每一步的 pi 值，空间复杂度为 O(|P|) 。

### Boyer-Moore-Horspool算法
#### 基本思想
Boyer-Moore-Horspool算法是由Boyer和Moore发明的一种快速匹配算法。该算法用两个指针，其中一个指针指向待匹配文本中的第一个字符，另一个指针指向模式串中的第一个字符。如果两个指针所指向的字符相同，则分别移动两个指针；否则，如果模式串中的字符已经被完全匹配，则直接跳转回模式串开头重新匹配；否则，如果待匹配文本中的字符已被完全匹配，则不匹配。这样，算法在最坏情况下只需进行一次完整匹配即可，匹配成功率接近百分之百。

#### 操作步骤
1. 对模式串 P 和文本 T 进行初始化，设 m 和 n 分别为模式串和文本的长度。
2. 在模式串 P 上设置好辅助函数 shiftTable。shiftTable[x] 存放了 x 对应字母的偏移值。例如，当 x=“a” 时，shiftTable[x]=0；当 x=“b” 时，shiftTable[x]=1，以此类推。
3. 使用 shiftTable 数组对模式串 P 进行预处理，得到 sa 数组。sa[i] 存放着模式串 P 的第 i 个后缀（包括自身）在 P 中的第一个位置。
4. 当待匹配文本 T 与模式串 P 匹配时，使用 BMH 算法。首先，将模式串 P 设置为空串。令指针 i，j 都从尾部开始，在模式串 P 的每个位置 j 下，计算偏移值 delta，delta = min(shiftTable[text[i]]，len(P)-j)。i 开始向前滑动 delta 步，直到模式串 P 的第 j 个字符匹配 text[i]。然后，将模式串 P 的第 j 个字符移动到第 i 个位置，然后以此为中心向右扩展 k 个字符。重复以上过程，直到模式串 P 的末尾。如果模式串 P 的最后一个字符与待匹配文本的最后一个字符匹配，则完成匹配。

#### 时间复杂度
BMH 算法的平均时间复杂度为 O(|T|/m)，其中 m 为模式串的长度。但是，在最坏情况下，算法的时间复杂度为 O(|T|) 。

#### 空间复杂度
BMH 算法的空间复杂度为 O(min(|T|, m)) ，因为模式串 P 和 sa 数组需要存放所有后缀和首位置。