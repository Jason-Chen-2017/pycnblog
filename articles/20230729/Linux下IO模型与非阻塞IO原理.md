
作者：禅与计算机程序设计艺术                    

# 1.简介
         
Linux是一个开源、免费、可靠的类Unix系统。在Linux平台上运行着大量的服务器软件，比如Apache、MySQL、PostgreSQL、Redis等。这些软件都是多进程/线程模型，一个服务进程负责监听并接收用户请求，而后由该进程fork出多个子进程进行处理。当遇到网络I/O时，由于硬件及OS性能限制，一般都采用同步模式，即父进程必须等待子进程完成后才能继续处理其他事情。然而，对于某些特殊场景，比如高并发短连接服务，如果采用同步模式就会导致严重的延迟。因此，异步I/O模式应运而生。
同步I/O和异步I/O模型有什么区别？它们分别适用于什么场景？接下来，我们将详细阐述Linux下的IO模型及异步I/O模型原理。
## Linux IO 模型
Linux操作系统从设计之初就采用了异步I/O模型，它允许应用程序直接访问磁盘，不需要等待实际设备的读写操作。基于异步I/O模型的Linux操作系统可以提供更好的并发性，提升服务的响应能力，特别是在高负载情况下。但是，Linux异步I/O模型也存在一些局限性，例如缓冲区大小限制、只能针对文件描述符实现非阻塞IO等。本文将主要介绍Linux下常用的IO模型（blocking I/O、non-blocking I/O、IO multiplexing和signal driven I/O）和非阻塞IO原理。
### Blocking I/O模型
Blocking I/O模型是传统的IO模型，在应用层调用recvfrom函数的时候，若没有收到数据，则进程会一直被阻塞，直到数据到达或者超时才返回。其实现方法如下：
```c++
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);
```
首先，应用层进程调用recvfrom()函数，指定要接收数据的套接口文件描述符sockfd、接收缓冲区地址buf、接收数据长度len、设置标志flags等参数；然后，操作系统kernel接受到的数据存放在指定的缓冲区buf中；最后，应用层进程得到从socket接收到的数据，并且处理数据。但在这个过程中，如果应用进程的调用时间超过一定阈值（如1s），则会触发超时机制，返回一个错误EAGAIN。

举个例子，假设有一个程序，它通过TCP连接向服务器发送一个HTTP请求，期望收到服务器的响应。用Blocking I/O模型，流程如下所示：

1. 应用层进程创建TCP socket，并发起connect连接请求；
2. 操作系统kernel分配资源，完成三次握手建立TCP连接；
3. 应用层进程调用send函数发送HTTP请求；
4. 操作系统kernel把HTTP请求发送给对端的服务器；
5. 对端的服务器收到请求并处理，并把响应返回给操作系统kernel；
6. 操作系统kernel把HTTP响应复制到应用进程指定的缓冲区buf里；
7. 应用层进程得到HTTP响应数据，并且处理数据。

这样，整个过程耗时比较长。所以，Blocking I/O模型适用于一些实时的通信协议，比如HTTP。

### Non-blocking I/O模型
Non-blocking I/O模型就是在传统的Blocking I/O模型基础上引入了等待状态。在应用层进程调用recvfrom()函数之后，若没有收到数据，则不会阻塞进程，而是立刻返回一个EWOULDBLOCK错误码。应用进程需要不断轮询socket状态，直到收到数据或超时才结束阻塞状态。非阻塞I/O模型在不同的系统上实现方式不同，但大体类似，基本原理就是应用层进程发起系统调用之后，如果不能立即得到结果，就先返回一个错误码，表示"我还没准备好，你再过会儿吧"。轮询的方式可以通过select、poll、epoll等系统调用完成。

举个例子，假设有一个程序，它需要从多个TCP连接接收数据。用Non-blocking I/O模型，流程如下所示：

1. 应用层进程创建多个TCP socket，并发起连接请求；
2. 操作系统kernel为每个socket分配资源，完成TCP三次握手建立连接；
3. 每个应用层进程启动一个循环，不断地调用recvfrom()函数尝试接收数据；
4. 如果某个socket处于可读状态（即已有数据到达），则kernel复制数据到应用进程指定的缓冲区buf；
5. 如果某个socket处于异常状态（错误或对方关闭连接），则删除该socket，释放相关资源；
6. 应用层进程获取到完整的数据包，就可以进行后续的处理。

这样，程序可以同时处理多个连接上的请求，提升吞吐率。

### IO Multiplexing模型
IO Multiplexing模型是利用单个线程或者进程管理多个文件描述符，让内核在满足所有套接字的文件描述符条件下，只通知一次主进程，这样就减少了通知频率，从而降低了系统开销。其实现方法可以使用select、poll、epoll等系统调用。

select、poll都是IO Multiplexing模型的实现方法，区别在于效率不同。

select调用后立刻检查就绪情况，select支持的文件描述符数量有限制，默认是1024。所以，如果需要处理的文件描述符数量太多，建议改用epoll。

poll调用后立刻检查就绪情况，也支持文件描述符数量有限制，而且poll可以设置超时时间。

select、poll、epoll都使用了回调函数，并注册相应事件到事件表中，然后进入等待状态，等待IO事件的发生。当对应的事件发生时，内核会将事件通知到主进程，调用回调函数，进行相应的处理。

IO Multiplexing模型最大的优点是，单个线程/进程可以同时管理多个连接，降低系统的开销，提升了性能。

### Signal-Driven I/O模型
Signal-driven I/O模型属于同步IO模型，它依赖于操作系统提供的信号机制。当有数据到达某个套接字时，操作系统发送SIGIO信号通知应用进程，应用进程再根据套接字的状态和需要，决定是否读取数据。此种模型的优点是简单、易于理解、可以跨平台使用。缺点是不可靠、容易丢失数据。

举个例子，假设有一个程序，它需要通过UDP socket接收数据，并将数据包中的特定字段进行修改。用Signal-Driven I/O模型，流程如下所示：

1. 应用层进程创建一个UDP socket，绑定本地IP和端口号；
2. 当应用进程启动之后，调用recvmsg()函数尝试接收数据包；
3. 如果数据包到达，则kernel复制数据到应用进程指定的缓冲区buf；
4. 数据包处理完毕，调用sendto()函数向对端发送数据；
5. 操作系统kernel将修改后的HTTP请求发送给对端的服务器；
6. 对端的服务器收到请求并处理，并把响应返回给操作系统kernel；
7. 应用进程得到HTTP响应数据，进行后续的处理。

这里，应用进程并不知道数据包何时到达，也不知道哪个socket的数据到达。只有当recvmsg()函数返回EAGAIN时，应用进程才会读取数据。所以，这种模型也叫做Event Driven I/O模型。

## Linux非阻塞IO原理
为了更好地理解Linux下的非阻塞IO模型原理，本节将分两部分进行介绍。第一部分介绍一下非阻塞IO如何处理I/O事件。第二部分则进一步探讨Linux下IO复用模型epoll的工作原理。

### 非阻塞I/O原理
在Linux下，非阻塞I/O模型依赖于操作系统提供的readiness指示器，这一指示器能够告诉应用进程，某个套接字是否已经准备好接收数据。应用进程可以轮询套接字是否就绪，也可以注册事件回调函数，等待事件的发生。Linux提供了四种IO模型：blocking I/O、non-blocking I/O、IO multiplexing、signal-driven I/O。

对于blocking I/O模型，当应用进程调用recvfrom()函数等待数据时，若无数据到达，则进程会一直被阻塞，直到数据到达或者超时才返回。对于non-blocking I/O模型，当应用进程调用recvfrom()函数等待数据时，若无数据到达，则进程不会被阻塞，而是立刻返回一个EWOULDBLOCK错误码，通知应用进程数据暂时不可用。对于IO multiplexing模型和signal-driven I/O模型，应用程序通过相应的系统调用通知操作系统，当相应事件发生时，操作系统通知应用程序，应用程序再根据需要读取数据。这些模型的共同特征是，当某个I/O操作不可取时，系统不会阻塞进程，而是立刻返回错误信息或一个空的数据包。

### epoll模型原理
在Linux中，IO multiplexing模型的实现方法有三种：select、poll和epoll。前两种方法使用轮询的方式检测每个套接字是否就绪，效率较低。epoll提供了一种完全独立于其他I/O活动的方法，通过对文件描述符进行监视，并注册相应的回调函数，当事件发生时，epoll可以通知应用程序进行相应的处理。epoll支持水平触发（level trigger）和边缘触发（edge trigger）两种工作模式，还可以指定水平触发的边界，使得性能和内存占用更加优化。

epoll模型包括三个重要的函数：epoll_create，epoll_ctl和epoll_wait。

epoll_create用来创建一个epoll句柄，标识epoll对象。其唯一的参数是表示最大待监测描述符数量的一个整数。返回值为整数类型，作为epoll对象的唯一标识。

epoll_ctl用来注册新的事件、修改已有的事件或删除事件。其第一个参数为epoll句柄，第二个参数为要注册的事件类型，第三个参数为要注册的描述符，第四个参数为回调函数。注册成功则返回0，失败则返回-1。

epoll_wait用来等待事件的产生，并将发生的事件通知到应用进程。其第一个参数为epoll句柄，第二个参数为等待事件的数组，第三个参数为等待事件的个数，第四个参数为超时时间。该函数返回所发生事件的数目，若超时则返回-1。

epoll模型的优点是：

1. 没有最大连接数限制，即可以处理更多的连接；
2. 只管感兴趣的事件，减少了内存占用；
3. 采用mmap()减少复制开销；
4. 支持多线程并发。