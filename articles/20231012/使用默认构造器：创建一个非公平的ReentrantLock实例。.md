
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


在并发编程中，锁机制是一个非常重要的工具，它可以用来确保并发访问共享资源时只能有一个线程对其进行访问，从而保证数据的完整性和一致性。Java中的Lock接口提供了多种类型的锁，如读写锁（ReadWriteLock）、条件变量（Condition）、栅栏（Barrier）等，除此之外，它还包括基于AQS框架实现的同步锁——ReentrantLock。

在使用ReentrantLock类的时候，一般都需要调用它的构造方法来创建新的锁对象。但是，当我们只需要一个普通的非公平锁的时候，该怎么办呢？难道要么重写ReentrantLock类的构造函数，从而取消公平锁属性；要么直接调用它的父类AbstractOwnableSynchronizer的构造函数，然后再调用super()方法设置一些属性来生成一个非公平锁。这样做显然不是很优雅，并且会增加理解上的困难。

另外，作为并发领域中的一名专家，除了使用自己熟悉的技术外，更应该了解一些理论知识。在很多时候，用最简单的方法解决问题往往会得到更好的结果。本文将探讨如何通过使用默认构造器来创建一个非公平的ReentrantLock实例，并深入探索它的内部原理。

# 2.核心概念与联系
## ReentrantLock类及其相关类
首先，让我们看一下ReentrantLock类。ReentrantLock类是基于AQS（AbstractQueuedSynchronizer）框架实现的一个可重入锁，它具有独占和共享两种模式，通过调用lock()和unlock()方法来获取和释放锁，也可以获取尝试非阻塞地获取锁。它的状态变化有两种模式：公平锁和非公平锁。公平锁指的是按照请求的顺序获得锁；非公平锁则不按顺序获得锁。

ReentrantLock类继承了AbstractOwnableSynchronizer抽象类，它实现了一些公共功能，比如使用一个ThreadLocal维护锁持有者信息。同时，它还有一个内部类Sync实现了同步锁的主要逻辑。Sync负责管理同步状态，并维护等待获取锁的线程队列。

ReentrantLock既支持独占锁也支持共享锁，这取决于调用方式不同。如果没有其他线程正在执行同步块或方法，则可以在任意多个线程之间共享使用同一个锁。否则，则只能被一个线程独占使用。

下面看一下它的重要成员变量：

- state: 当前锁的状态，表示锁可以被几个线程所拥有。默认为0表示没有线程拥有锁，如果state>0表示有线程拥有锁。
- sync: 这是ReentrantLock类的核心类，它继承了AbstractQueuedSynchronizer抽象类，通过封装一个CLH队列（Craig,Landin and Hagersten queue），实现同步锁的主要功能。sync字段保存了锁的同步状态信息。
- lock: 这个字段保存了当前线程的锁信息。即使是被阻塞的线程也能获取到锁信息，帮助其在被唤醒后恢复同步状态。
- isHeldExclusively: 如果这个字段为true，表示当前线程独占了锁，且没有任何其他线程在争夺锁。

## Sync类
Sync类实现了ReentrantLock类的核心功能。它的重要成员变量如下：

- outerLock: 保存了用于管理同步状态的外部锁，即由ReentrantLock实例化的那个Lock类。
- queuedThreads: 保存了所有请求但未被授予锁的线程，它们都处于同步队列中。
- exclusiveOwnerThread: 保存了拥有独占锁的线程。只有拥有独占锁的线程才能够修改同步状态。

Sync类中最重要的方法就是acquire(int arg)方法，它的作用是尝试获取锁，如果成功则返回true，失败则返回false。 acquire(arg)方法的流程如下：

1. 如果同步锁可用（即state=0），则尝试获取锁，成功则直接返回true。否则，把当前线程添加到同步队列队尾。
2. 如果同步锁不可用（即state>0)，则判断当前线程是否可以获取同步锁。只有持有独占锁的线程才能获取同步锁，且只能是唯一的独占锁持有者。因此，如果exclusiveOwnerThread==current线程，则表示当前线程是唯一的独占锁持有者，可以获取同步锁。否则，则判断当前线程是否已经在同步队列中。如果在队列中，则表示当前线程在排队等待，无法获取同步锁。返回false。
3. 如果获取同步锁成功，则更新state值，记录exclusiveOwnerThread值，设置isHeldExclusively为true，表示当前线程持有独占锁。
4. 返回true。

接着，我们看一下release()方法。release()方法用于释放锁。release()方法的流程如下：

1. 如果当前线程不是持有独占锁的线程，则抛出IllegalMonitorStateException异常。
2. 如果当前线程是唯一的独占锁持有者，则将state设置为0，清空exclusiveOwnerThread，isHeldExclusively，将所有在同步队列中等待的线程都唤�ChangeTimes条件，唤醒其中一个线程（随机选举）。
3. 如果当前线程不是唯一的独占锁持有者，则将state的值减去1，表示锁可被其他线程拥有。
4. 如果有某个线程因为等待超过超时时间而被唤醒，则将该线程移除同步队列。
5. 返回true。

总结来说，Sync类维护了ReentrantLock类的主要逻辑，如获取锁和释放锁；同步队列和同步状态信息；独占锁和共享锁等。

## AQS框架简介
AQS框架是基于Reactor模式设计的一套高效、通用的并发框架。其核心思想是在并发编程中，将共享资源以类似“生产者-消费者”模型的方式处理，每个线程提交任务到共享缓冲区（同步器），然后由另一个线程来消费这些任务并执行。由于共享资源有限，所以当资源忙时，生产者线程就被阻塞，直到消费者线程完成任务后，再将生产者的任务加入同步器中，使得生产者可以继续工作。相比于传统的互斥锁或者信号量机制，AQS框架提供了一种更加灵活的并发方案。

其中，同步器（Sync）就是AQS框架中的核心类。Sync类主要职责是维护同步状态，并且定义了获取同步状态和释放同步状态的方法。对于使用同步器来构建锁的ReentrantLock类来说，它依赖外部锁（outerLock）来获取和释放同步状态，外部锁可以是一个普通同步锁，也可以是一个抽象类，如ReadWriteLock类。