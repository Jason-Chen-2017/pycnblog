
作者：禅与计算机程序设计艺术                    

# 1.简介
         
 在 C++ 中，内存管理是一个非常复杂的问题。包括堆栈、自由存储区、堆和全局变量等几个方面。下面将逐一讨论每一种类型内存的管理方式。
           - 堆栈（stack）：栈内存用来存储函数的参数值，局部变量，返回地址等。程序运行时，编译器自动分配和释放栈内存。
           - 自由存储区（heap）：堆内存一般用于动态地创建数组和其他动态分配的数据结构。在 C++ 中，可以使用 new 和 delete 操作符来申请和释放堆内存。
           - 全局变量（global variable）：全局变量通常位于静态数据或堆上。全局变量的生命周期和整个程序一样长。
           - 段（segment）：段可以理解成是堆、栈或者数据段中的一个区域。不同类型的段对应着不同的内存空间。
          下面我们用图示的方式来更直观地表示每个内存管理方式之间的关系。
         ![image](https://user-images.githubusercontent.com/22379898/69835683-d07a8f80-129e-11ea-9b6c-77dc217cf5c0.png)
          从上图可知，堆栈、自由存储区、堆和全局变量之间存在这样的关系：
          + 全局变量位于静态数据或堆上，随着程序运行，它们的生命周期和整个程序一致。
          + 函数调用的时候，如果要传递参数，一般通过寄存器来传递；如果参数过多，则需要分配堆内存，再通过指针传递。
          + 当一个局部变量超出作用域后，其所占用的内存就被回收了。对于栈上的局部变量来说，只要函数结束，局部变量就自动消失。
          + 如果一个程序不断申请和释放堆内存，最终会造成内存泄漏，导致内存溢出。因此，应该尽量避免频繁地申请和释放堆内存。
         # 2.堆栈(stack)
          堆栈是由编译器实现的一种数据结构，它可以在程序运行时自动分配和释放。它的特点如下：
          + 先进后出（Last In First Out，LIFO）。栈顶元素最先出栈，栈底元素最后入栈。
          + 无需用户干预。程序运行中，编译器负责分配和释放栈内存。
          + 无需考虑内存大小和位置。栈内存分配和回收都是自动完成的。
          ### 栈内存分配
          栈内存分配是自动进行的，编译器在执行过程中维护一个栈指针，指向当前栈顶。当向栈中 push 一个数据时，栈指针向下移动，指向新添加数据的位置；当 pop 一个数据时，栈指针向上移动，指向剩余数据的位置。
          栈内存的分配和释放效率都很高，速度也很快。因此，栈通常被用来存储函数的参数、局部变量、返回地址等信息。
          ### 栈内存分配策略
          当一个新的栈帧被创建时，编译器为其分配一块连续的内存，这块内存大小由编译器决定，一般比函数本身大一些。编译器为每一个函数分配一个新的栈帧，然后从这个帧开始为该函数中的局部变量分配空间。
          函数执行完毕后，编译器释放栈帧，回收其所占用的内存，使得该函数的栈帧不再有效。当程序调用其它函数时，又会为这些函数创建一个新的栈帧，并依次类推。这种分配和释放的方式保证了函数调用的顺利进行，而不会出现栈溢出的现象。
          ### 栈内存分配过程
          下面以 printf 函数为例，阐述栈内存的分配过程。
          ```c++
          int main() {
              int a = 1;   // 变量声明和初始化
              float b = 2.0;
              
              return 0;
          }
          ```
          执行到这里时，main 函数只有两个局部变量 `a` 和 `b`。由于整数占用 4 个字节，浮点数占用 4 个字节，所以 main 函数需要分配 8 个字节的栈空间。下面是内存分布图：
          |               |                          |                  |           |
          | :-----------: | ------------------------ | ---------------- | --------- |
          |     start     |                          |       main       |    ret    |
          |               |                          |                  |           |
          |   ...        |                          |                  |           |
          | stack pointer |     old values (b, a)     | local variables  | old value |
          |               |                          |                  |           |
          通过图示可以看到，main 函数的栈帧已经被建立，main 函数中的 `a` 和 `b` 分别占据了第一个和第二个 slot 的内存。接着分配了一个返回地址，指向 main 函数的返回语句。此时的栈空间布局如下所示：
          |               |              |                 |                     |          |                |           |
          | :-----------: | ----------- | --------------- | ------------------- | -------- | -------------- | --------- |
          |     start     |             |      main       |                    | ret addr |     arg_n      | var_n=2.0|
          |               |             |                 |                    |          |                |           |
          |   ...        |             |                 |                    |          |                |           |
          | stack pointer |   arg_1     |  local vars     |  old value of 'b'   | var_1=1  | unused memory | undefined |
          为了显示清晰，图中省略了一些列主存中的其他信息。
          ### 栈内存管理
          栈内存虽然被分配给函数，但是当函数执行结束后，栈内存不能立即释放。编译器会保留一小部分的栈内存供其它函数调用，所以栈内存的释放不能完全依赖于函数的执行。也就是说，栈内存的管理不是由程序员控制的，而是交给编译器自动完成的。
          
          下面以 printf 函数为例，来看一下栈内存管理的过程。当程序调用 printf 时，printf 函数的栈帧已经在内存中准备好，但是其返回地址还没有被设置。当 printf 函数终止时，编译器需要释放它的栈帧，同时恢复调用它的那个栈帧，使得程序的正常流转可以继续进行。
          ## 自由存储区(heap)
          自由存储区（heap）就是指程序运行时可以动态分配和释放的内存区。它的特点如下：
          + 可根据需要动态分配和释放内存，因此大小和位置是不固定的。
          + 自由存储区的内存分配和释放是由程序员控制的。
          + 需要通过 new 和 delete 来申请和释放自由存储区内存。
          ### new 和 delete 运算符
          在 C++ 中，new 和 delete 运算符用来动态分配和释放自由存储区内存。new 运算符负责从堆内存中为对象开辟一块足够大的内存空间，并返回一个指向该对象的指针。delete 运算符则负责释放堆内存中刚才申请的内存，并使得其指向的内存空间可以被重新利用。
          new 和 delete 运算符都带有一个额外的参数——一个“大小”参数，用来指定要申请的内存的大小。一般情况下，这“大小”参数的值就是 sizeof(Object)，其中 Object 是申请内存的类型。比如：
          ```c++
          int *pInt = new int;            // 为 int 类型申请内存
          double *pDouble = new double[10];// 为 double 数组申请 10 个元素
          MyClass *pMyClass = new MyClass();// 为自定义类的对象申请内存
          ```
          ### 自由存储区分配策略
          自由存储区内存的分配和释放也是由程序员控制的。一般来说，程序员采用两种方法来分配自由存储区内存：
          + 使用 malloc 函数来直接向系统申请一整块内存。
          + 使用 new 运算符来分配内存。
          ### 内存管理算法
          #### 首次适应算法（First Fit）
          首次适应算法是最简单的内存分配算法。它从空闲链表的头开始扫描，直到找到满足大小要求的内存块。如果没有找到这样的内存块，就增加所需的内存大小，直到找到合适的内存。
          #### 最优适应算法（Best Fit）
          最优适应算法是另一种内存分配算法。它先按顺序查找空闲链表，找不到大小合适的内存块后，就增加所需的内存大小，直到找到合适的内存。
          #### 上下文切片算法（Worst Fit）
          上下文切片算法是一种折衷方案。它首先按照相同大小的内存块分割空闲链表，然后从分割后的子链表中选择最大的可用内存块，作为最佳内存块。如果没有找到这样的内存块，就增加所需的内存大小，直到找到合适的内存。

