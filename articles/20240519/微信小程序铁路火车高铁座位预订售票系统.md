# 微信小程序铁路火车高铁座位预订售票系统

作者：禅与计算机程序设计艺术

## 1. 背景介绍
### 1.1 铁路运输在中国的重要地位
### 1.2 微信小程序的发展现状
### 1.3 开发微信小程序铁路售票系统的意义

## 2. 核心概念与联系
### 2.1 微信小程序开发基础
#### 2.1.1 小程序框架
#### 2.1.2 WXML与WXSS
#### 2.1.3 JavaScript逻辑层
### 2.2 铁路售票系统业务流程
#### 2.2.1 用户注册与登录
#### 2.2.2 车次查询与座位选择
#### 2.2.3 订单生成与支付
### 2.3 小程序与后端服务交互
#### 2.3.1 API设计原则
#### 2.3.2 数据请求与响应
#### 2.3.3 异常处理机制

## 3. 核心算法原理具体操作步骤
### 3.1 铁路网络图的构建
#### 3.1.1 车站节点与线路边
#### 3.1.2 邻接表存储结构
#### 3.1.3 图的遍历算法
### 3.2 最短路径查询算法
#### 3.2.1 Dijkstra算法原理
#### 3.2.2 优先队列优化
#### 3.2.3 多目标最短路径
### 3.3 座位分配算法
#### 3.3.1 席别与座位编码
#### 3.3.2 区间更新线段树
#### 3.3.3 座位分配策略

## 4. 数学模型和公式详细讲解举例说明
### 4.1 铁路网络图模型
#### 4.1.1 有向加权图定义
$$G=(V,E), V为车站集合, E为线路集合$$
#### 4.1.2 邻接表存储
$$Adj[u]=\{(v,w)|(u,v)\in E, w为边权\}$$
### 4.2 最短路径模型
#### 4.2.1 Dijkstra算法
设$d[i]$为起点$s$到$i$的最短距离，$p[i]$为最短路径上$i$的前驱节点，算法流程：
$$
\begin{aligned}
&d[s] \leftarrow 0 \\
&\textbf{for}\ u \in V-\{s\}:\\
&\qquad d[u] \leftarrow \infty \\
&S \leftarrow \emptyset \\
&Q \leftarrow V \\
&\textbf{while}\ Q \neq \emptyset:\\
&\qquad u \leftarrow \arg\min_{v\in Q}d[v]\\
&\qquad S \leftarrow S \cup \{u\}\\
&\qquad \textbf{for}\ (u,v) \in E:\\
&\qquad\qquad \textbf{if}\ d[v]>d[u]+w(u,v):\\
&\qquad\qquad\qquad d[v] \leftarrow d[u]+w(u,v)\\
&\qquad\qquad\qquad p[v] \leftarrow u
\end{aligned}
$$

#### 4.2.2 多目标最短路径
考虑票价、旅行时间等多个目标，设$d_i[u]$为起点$s$到$u$的第$i$个目标的最短路径长度：
$$d_i[u]=\min_{P:s\rightsquigarrow u}\sum_{e\in P}w_i(e)$$

### 4.3 座位分配模型
#### 4.3.1 区间更新线段树
设$A[l,r]$表示区间$[l,r]$内可用的座位数，$tag[p]$为懒惰标记，$p$为线段树节点，则：
$$
\begin{aligned}
&\textbf{function}\ \text{PushDown}(p):\\
&\qquad \textbf{if}\ tag[p] \neq 0:\\
&\qquad\qquad A[p] \leftarrow A[p]-tag[p]\\
&\qquad\qquad tag[p\times 2] \mathrel{+}= tag[p]\\
&\qquad\qquad tag[p\times 2+1] \mathrel{+}= tag[p]\\
&\qquad\qquad tag[p] \leftarrow 0\\
&\textbf{function}\ \text{Update}(l,r,p,v):\\
&\qquad \textbf{if}\ [l,r]\subseteq [L_p,R_p]:\\
&\qquad\qquad tag[p] \mathrel{+}= v\\
&\qquad\qquad A[p] \leftarrow A[p]-v\times (R_p-L_p+1)\\
&\qquad\qquad \textbf{return}\\
&\qquad m \leftarrow \lfloor (L_p+R_p)/2 \rfloor\\
&\qquad \text{PushDown}(p)\\
&\qquad \textbf{if}\ l\leq m:\\
&\qquad\qquad \text{Update}(l,r,p\times 2,v)\\
&\qquad \textbf{if}\ r>m:\\
&\qquad\qquad \text{Update}(l,r,p\times 2+1,v)\\
&\qquad A[p] \leftarrow A[p\times 2]+A[p\times 2+1]
\end{aligned}
$$

## 5. 项目实践：代码实例和详细解释说明
### 5.1 小程序页面布局
#### 5.1.1 首页
```xml
<!-- index.wxml -->
<view class="container">
  <view class="search-bar">
    <input placeholder="输入出发地" bindinput="onFromInput"/>
    <input placeholder="输入目的地" bindinput="onToInput"/>
    <picker mode="date" bindchange="onDateChange">
      <view>{{date}}</view>
    </picker>
    <button bindtap="onSearch">搜索</button>
  </view>
  <view class="history">
    <view wx:for="{{history}}" wx:key="index" bindtap="onHistoryTap" data-item="{{item}}">
      {{item.from}} → {{item.to}}
    </view>
  </view>
</view>
```
```javascript
// index.js
Page({
  data: {
    from: '',
    to: '',
    date: '',
    history: [],
  },
  onFromInput(e) {
    this.setData({from: e.detail.value});
  },
  onToInput(e) {
    this.setData({to: e.detail.value});
  },
  onDateChange(e) {
    this.setData({date: e.detail.value});
  },
  onSearch() {
    let {from, to, date} = this.data;
    // 查询车次
    // ...
    this.data.history.unshift({from, to});
    this.setData({history: this.data.history.slice(0, 10)});
  },
  onHistoryTap(e) {
    let {from, to} = e.currentTarget.dataset.item;
    this.setData({from, to});
  },
})
```

#### 5.1.2 车次列表页
```xml
<!-- train-list.wxml -->
<view class="container">
  <view class="train-list">
    <view wx:for="{{trains}}" wx:key="index" class="train-item" bindtap="onItemTap" data-train="{{item}}">
      <view class="train-name">{{item.name}}</view>
      <view class="train-time">{{item.from.time}} → {{item.to.time}}</view>
      <view class="train-seat">
        <text>一等座：{{item.seatTypes.zy_num}}张</text>
        <text>二等座：{{item.seatTypes.ze_num}}张</text>
        <text>无座：{{item.seatTypes.wz_num}}张</text>
      </view>
    </view>
  </view>
</view>
```
```javascript
// train-list.js
Page({
  data: {
    trains: [],
  },
  onLoad(query) {
    let {from, to, date} = query;
    // 查询车次
    // ...
    this.setData({trains});
  },
  onItemTap(e) {
    let train = e.currentTarget.dataset.train;
    wx.navigateTo({
      url: `/pages/seat-select/seat-select?train=${JSON.stringify(train)}`,
    });
  },
})
```

#### 5.1.3 选座页面
```xml
<!-- seat-select.wxml -->
<view class="container">
  <view class="seat-map">
    <view wx:for="{{seats}}" wx:key="row" class="seat-row">
      <view wx:for="{{item}}" wx:for-item="seat" wx:key="index" class="seat {{seat===1?'':'unavailable'}}" bindtap="onSeatTap" data-position="{{[index,index2]}}"></view>
    </view>
  </view>
  <view class="selected-seats">
    已选座位：
    <text wx:for="{{selectedSeats}}" wx:key="index">{{item}}</text>
  </view>
  <view class="controls">
    <button bindtap="onOrder">提交订单</button>
  </view>
</view>
```
```javascript
// seat-select.js
Page({
  data: {
    train: {},
    seats: [],
    selectedSeats: [],
  },
  onLoad(query) {
    let train = JSON.parse(query.train);
    this.setData({train});
    // 获取座位图
    // ...
  },
  onSeatTap(e) {
    let position = e.currentTarget.dataset.position;
    let [row, col] = position;
    let {seats, selectedSeats} = this.data;
    if (seats[row][col] === 0) return;
    seats[row][col] = seats[row][col]===1 ? 2 : 1;
    let seatName = `${row+1}排${col+1}号`;
    let idx = selectedSeats.indexOf(seatName);
    if (idx > -1) {
      selectedSeats.splice(idx, 1);
    } else {
      selectedSeats.push(seatName);
    }
    this.setData({seats, selectedSeats});
  },
  onOrder() {
    let {train, selectedSeats} = this.data;
    // 提交订单
    // ...
  },
})
```

### 5.2 后端接口设计
#### 5.2.1 查询车次
- 请求方法：GET
- 请求路径：/train/query
- 请求参数：
  - from：出发地
  - to：目的地
  - date：出发日期
- 响应格式：
```json
{
  "code": 0,
  "message": "success",
  "data": [{
    "name": "G101",
    "from": {
      "name": "北京南",
      "time": "07:00"
    },
    "to": {
      "name": "上海虹桥", 
      "time": "12:00"
    },
    "seatTypes": {
      "zy_num": 50,
      "ze_num": 100,
      "wz_num": 10
    }
  }]
}
```

#### 5.2.2 查询座位图
- 请求方法：GET 
- 请求路径：/seat/query
- 请求参数：
  - train：车次
  - date：出发日期
- 响应格式：
```json
{
  "code": 0,
  "message": "success",
  "data": [
    [1, 1, 1, 1, 0, 0],
    [1, 1, 0, 1, 1, 1],
    [1, 1, 1, 1, 1, 0]
  ]
}
```

#### 5.2.3 提交订单
- 请求方法：POST
- 请求路径：/order/submit
- 请求参数：
  - train：车次
  - date：出发日期
  - seats：座位号数组
- 响应格式：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "orderNo": "202305190001",
    "amount": 100.50, 
    "payUrl": "https://..."
  }
}
```

### 5.3 关键代码实现
#### 5.3.1 最短路径查询
```cpp
struct Station {
  int id;
  string name;
};

struct Train {
  string name;
  vector<Station> stations;
  vector<int> prices;
  vector<int> durations;
};

struct Edge {
  int to;
  int price;
  int duration; 
};

int dijkstra(int s, int t, vector<vector<Edge>>& adj) {
  int n = adj.size();
  vector<int> dist(n, INT_MAX);
  vector<bool> vis(n, false);
  priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
  
  dist[s] = 0;
  pq.push({0, s});
  
  while (!pq.empty()) {
    int u = pq.top().second;
    pq.pop();
    if (vis[u]) continue;
    vis[u] = true;
    if (u == t) break;
    
    for (auto& e : adj[u]) {
      int v = e.to, price = e.price, duration = e.duration;
      if (dist[u] + price < dist[v]) {
        dist[v] = dist[u] + price;
        pq.push({dist[v], v});
      }
    }
  }
  
  return dist[t];
}
```

#### 5.3.2 座位分配
```cpp
class SeatAllocator {
  int n;
  vector<int> tree;
  vector<int> tag;
  
public:
  SeatAllocator(int n): n(n) {
    tree.resize(4*n);
    tag.resize(4*n);
  }
  
  void pushdown(int p) {
    if (tag[p] != 0) {
      tree[p] -=