
作者：禅与计算机程序设计艺术                    

# 1.简介
  

堆是一个非常重要的数据结构，因为它可以用来实现优先级队列、调度任务以及很多其他应用场景。在堆中最常用的操作就是建堆（build heap）和删除最大元素（extract maximum）。这两者的主要区别在于，建堆的时间复杂度为O(n)，而删除最大元素的时间复杂度为O(log n)。为了提高效率，大多数应用都希望能将这些操作的时间复杂度降低到O(1)以便快速处理数据。因此，为了达到这一目标，堆需要满足一些性质，如最大堆性质和完全二叉树性质等。

建堆一般使用数组来表示，并且通过不断下沉调整使得父节点的值始终大于或等于子节点的值来实现。而删除最大元素则相反，从根节点开始上浮，直到找到一个比其大的节点并交换位置，然后再对其下沉调整。这个过程的时间复杂度为O(log n)。

本文将着重介绍建堆的过程及其时间复杂度分析。由于已经存在比较详细的相关介绍，我们将只关注算法的实现和数学证明。

# 2.基本概念术语说明
## 2.1 数组和堆
首先，我们要有一个数组，也就是说，就是一系列数据组成的序列。不过，这里假设此序列中只有一种数据类型，如整数或者实数。除此之外，对于堆来说，还有一个额外的属性叫做大小（size），它记录了堆中数据的个数。

## 2.2 父节点和子节点
我们要考虑的是二叉树，因此每个节点只能连接两个子节点，即左右子节点。那么对于数组来说，它可以表示为完全二叉树。在这种情况下，任何非叶子节点都有且仅有一个左孩子。比如，下图的节点2有左孩子3，节点7也有左孩子11。而节点9没有左孩子，但它也是第四层的最后一个节点，因此它也是一个叶子节点。

所以，对于堆来说，它要求数组中的每个节点都是一个二叉树节点，并且它的子节点的顺序不能乱。

对于一个有n个节点的堆来说，其高度为log n。即树的宽度等于n。如下图所示:

## 2.3 大顶堆和小顶堆
如果一棵树是完全二叉树，那么它是一棵大顶堆，否则它可能是一棵小顶堆。根据左儿子还是右儿子来决定谁是父亲，因此每个节点的值总是不大于（不小于）其所有儿子的值。当某个节点大于（小于）其所有儿子的时候，就称该节点为“盲点”。当某个节点的值等于其所有儿子的值的时候，我们说它是“全节点”。

举例来说，下面的树是一棵大顶堆。每个节点都大于或等于其所有子节点。

```
        6
      /   \
    3      8
  / | \     \
 1   4 5     9
```

而下面的树不是一棵大顶堆。注意到第五行的第三个元素是第四行的两个元素和第六行第一个元素的和。因此，第二个元素大于三个元素之和。

```
        6
      /   \
    3      8
  / | \     \
 1   4 9     7
``` 

一般情况下，堆都是用数组来表示，但是在图形展示时，通常会用树状图来表示。对于二叉堆来说，它是一个完全二叉树，其中每个节点的值都不小于（不大于）其所有子节点的值。父节点的值始终大于（小于）其子节点的值。这种数据结构能够有效地进行插入和删除操作，使得它具有很好的性能。另外，二叉堆可以被用来实现堆排序，这是一个比归并排序更高效的排序算法。

# 3.核心算法原理
## 3.1 建堆
堆的建立有两种方式：先序遍历和后序遍历。前序遍历从上至下访问节点，后序遍历则从下至上访问节点。前序遍历过程是按照“根左右”的顺序访问节点，而后序遍历过程则是按照“左右根”的顺序访问节点。前序遍历用于建立最大堆，后序遍历用于建立最小堆。

我们现在选用后序遍历的方式建立堆，后序遍历的基本过程如下：

1. 把数组的末尾元素作为根节点；
2. 从第一个非叶子节点开始往上遍历，每次比较该节点和它的两个子节点中的较大者；
3. 如果父节点的值小于或等于较大儿子的值，则交换父节点和较大儿子的值；
4. 重复步骤2和3，直到所有节点都经过此过程；
5. 此时，整个数组的根节点就处于最大值。

比如，假设有以下数组{5, 4, 9, 2, 7}:

```
    5
   / \
 4   9
 / \ 
2   7
```

第一步把数组的末尾元素作为根节点，得到{9, 4, 7}。现在开始迭代：

```
     9
    / 
   / \ 
 4   7
/ 
...
```

第一次迭代时，根节点9和它的两个子节点4和7作比较。由于9大于4和7，所以不需要改变它们的位置。接下来比较节点4和节点7：由于4大于7，所以交换他们的位置，变成：

```
     9
    / 
   4   
   / \ 
 ...  7
```

第二次迭代时，节点4和它的两个子节点1和3作比较。由于4大于1和3，所以不需要改变它们的位置。接下来比较节点4和节点7：由于4大于7，所以不需要改变它们的位置。重复步骤2~4，直到数组的所有元素都经过这种比较之后，就得到一个最大堆。

```
          9
        / 
       4
       /\
      2 7
``` 

对于输入数组，我们可以使用插入排序的方法，在每个元素插入完毕之后执行一次建堆操作，这样就可以保证每次插入都是一颗完全二叉树。当然，也可以选择用快速排序的方法来实现建堆操作，但是建堆操作本身的复杂度为O(nlogn)，故而插入排序方法在实际应用中更加适合。

## 3.2 删除最大元素

删除最大元素的过程同样需要借助后序遍历的方式。在后序遍历的过程中，我们逐渐减少数组的长度，并把数组首部的元素放到最后一个非叶子节点中。然后，对比父节点和它的两个子节点，发现较大的子节点的位置和父节点的位置相同，则不用进行调整，继续迭代；否则，对比父节点的值和两个较大儿子的值，然后交换位置；若此时父节点的值仍然大于或等于较大儿子的值，则停止迭代。

举例来说，假设有以下堆{9, 4, 7}:

    9
   / \
 4   7

如果要删除最大元素，首先确定根节点9。我们知道树是完全二叉树，所以其高度为log n，即数组的长度。所以，先将数组首部的元素移动到最后一个非叶子节点，再把根节点9放在数组的末尾，然后对比父节点和它的两个子节点：

```
     4
    / \
   9   7
```

由于父节点4大于等于较大儿子9，因此无需调整。继续迭代：

```
        4
       / 
     ... 7
```

第二次迭代时，父节点4和它的两个子节点1和3作比较。由于4大于1和3，所以不需要改变它们的位置。继续迭代，直到数组的长度为1，即堆的大小减1。此时，数组的首元素已经是删除的最大元素。

```
        7
```