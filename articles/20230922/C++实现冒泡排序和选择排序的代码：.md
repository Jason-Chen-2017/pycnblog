
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在《数据结构与算法分析》这本书中，作者将排序算法分成了两个主要类别——“比较排序”和“非比较排序”。其中比较排序中最著名的有冒泡排序、插入排序、快速排序、归并排序等，而非比较排序则有计数排序、基数排序等。

今天，我将重点介绍两种排序算法——冒泡排序和选择排序，并通过C++语言描述其具体的操作流程和步骤。这两种排序算法是计算机编程领域的基础，也是最容易理解和实现的排序算法。

# 2.基本概念及术语
## 2.1 数组（Array）
数组是一种线性的数据结构，其中的元素按照一定顺序存储。数组可以是一个一维数组，也可以是一个多维数组。数组的下标从0到n-1，n代表数组的长度。

例如，假设有如下数组：`int arr[] = {7, -1, 9, 3};`，则：

1. `arr[0]` 表示数组的第一个元素；
2. `arr[1]` 表示数组的第二个元素；
3. `arr[-1]` 表示数组的倒数第一个元素；
4. `arr[3]` 表示数组的第四个元素；
5. `arr[arr.length() - 1]` 表示数组的最后一个元素。

## 2.2 比较排序算法（Comparison Sorting Algorithms）
比较排序算法，又称作稳定排序算法，其工作原理是在要排序的一组记录或者数据序列中，对每个元素进行比较，然后再按照规定的关系（一般小于或等于或大于某一元素）重新排列。这样做的结果是使得对于一个给定的关键字来说，它左边的所有元素都比它小，右边的所有元素都比它大。

常用的比较排序算法有冒泡排序、插入排序、选择排序、归并排序、快速排序、希尔排序、堆排序、桶排序等。

## 2.3 内置函数（Built-in Functions）
C++中提供了一些内置函数用于排序，比如`sort()`、`max_element()`、`min_element()`等，这些函数都会调用各种排序算法。

# 3.冒泡排序（Bubble Sort）
冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

### 3.1 操作步骤
1. 比较相邻的元素，如果第一个比第二个大，就交换他们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的；
3. 针对所有的元素重复以上的步骤，除了最后一个；
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


图示过程：(1 -> 4 -> 2 -> 3)，即第一个元素大于第二个元素，则交换位置，变成了 (1 -> 4 -> 3 -> 2)。经过两次循环，整个序列已排好序。

### 3.2 C++代码实现
```cpp
void bubbleSort(int arr[], int n){
    for(int i=0;i<n-1;i++){
        // Last i elements are already sorted
        for(int j=0;j<n-i-1;j++){
            if(arr[j] > arr[j+1]){
                swap(arr[j], arr[j+1]);
            }
        }
    }
}
```

### 3.3 时间复杂度分析
冒泡排序最坏情况时间复杂度是O(n^2)。原因是当序列反复无序时，算法会不断的进行交换，导致最后需要进行n-1轮遍历才能得到一个有序序列。

# 4.选择排序（Selection Sort）
选择排序是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。

### 4.1 操作步骤
1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；
3. 以此类推，直到所有元素均排序完毕。


图示过程：从第一个元素开始，最小值就是第一个，那么就放到前面，把后面的元素依次与这个最小值比较，发现最小的值那里，这样将其与最小值交换，最小值变动，再次比较、交换，知道最后的序列排列正确。

### 4.2 C++代码实现
```cpp
void selectionSort(int arr[], int n){
    for(int i=0;i<n-1;i++){
        int minIndex = i;
        for(int j=i+1;j<n;j++){
            if(arr[j] < arr[minIndex]){
                minIndex = j;
            }
        }
        swap(arr[i], arr[minIndex]);
    }
}
```

### 4.3 时间复杂度分析
选择排序的平均时间复杂度和最好情况时间复杂度都是O(n^2)， worst case是O(n^2)。原因是因为在最差的情况下，每次都只能确定一个元素是最小的，因此需要进行n-1次，且第i次需要扫描一遍之前的元素才知道自己是否最小，因此总时间复杂度是O(n^2)。