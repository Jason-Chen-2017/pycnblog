
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在计算机科学中，链表（Linked List）是一种动态数据结构，每个元素由一个存储块（通常是一个地址）加上该元素的值组成。链表中的每一个元素都有一个链接，指向下一个元素。首尾两端的链接指向特殊值，表示这是头或尾的结尾，以此类推。
在现实生活中，例如快递公司的货物运输，就用到了链表。在很多情况下，一条链路上的货物需要经过多个中转点才能到达目的地，所以需要依次记录各个途径中的信息。
但当一条链路上的所有货物都处理完了，链路也就废弃掉了，因此一般情况都需要删除该链表，或者保留该链表用于下次使用。把当前链表的尾结点指向新的节点，就是链表删除的过程。
2.基本概念及术语
- 单向链表(Singly Linked List)
> 在单向链表中，只有一个方向的指针用来从一个节点指向另一个节点。这种数据结构最适合用于处理具有唯一前驱元素的任务。例如：栈、队列等。

- 双向链表(Doubly Linked List)
> 在双向链表中，每个节点都包含两个指针，分别指向该节点的后继节点和前驱节点。通过前驱指针可以访问链表中的任何一个元素，通过后继指针可以找到它的下一个节点。这种数据结构最适合于处理那些具有上下关系的数据，例如链表、树等。

- 空链表
> 空链表指的是链表中没有任何元素，其表头指针为空。在C/C++语言中，可以将head指针置为NULL，表示空链表。

- 头结点
> 头结点就是链表中的第一个节点。对于双向链表，头结点的前驱指针指向NULL，而对单向链表而言，无前驱指针。

- 尾节点
> 尾节点就是链表中的最后一个节点。由于没有后继节点，所以它不包含有效数据。

3.核心算法原理
要实现链表删除操作，首先定位到待删除的节点。如果该节点为头结点，则将头结点指向它的下一个节点。如果该节点为中间节点或尾节点，则需要修改它的前驱节点的next指针，使其指向待删除节点的后继节点。修改后的链表如下图所示：


- 删除头结点：

如果链表非空，则删除头结点时，只需改变头指针的指向即可，即头指针指向头结点的下一个节点。
```c++
void deleteHeadNode() {
    if (head!= NULL && head->next!= NULL) {
        Node *p = head;
        head = p->next;
        free(p);
    }
}
```

- 删除中间或尾结点：

为了删除中间或尾节点，需要知道它的前驱节点。如果该节点有前驱节点，则直接修改它的前驱节点的next指针，使其指向待删除节点的后继节点。否则，将头指针指向待删除节点的下一个节点。
```c++
void deleteMiddleOrTailNode(int data) {
    // 如果链表为空，直接返回
    if (head == NULL) return ;
 
    // 如果待删除的节点为头结点
    if (data == head->data) {
        Node *p = head;
        head = p->next;
        free(p);
        return ;
    }
 
    // 查找待删除节点的前驱节点
    Node *prev = NULL;
    for (Node *curr=head; curr!=NULL; prev=curr, curr=curr->next) {
        if (curr->data == data) break;
    }
 
    // 如果待删除的节点不存在，则返回
    if (curr == NULL) return ;
 
    // 修改前驱节点的next指针
    prev->next = curr->next;
 
    // 释放内存
    free(curr);
}
```

注意：以上代码仅是演示如何删除链表中的节点。实际应用中还应考虑其他因素，如内存回收、边界条件判断等。