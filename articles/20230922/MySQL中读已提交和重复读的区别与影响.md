
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 1.1背景介绍
随着互联网网站的流量越来越大，网站的用户访问量增加，在高并发情况下数据库事务处理效率显得尤为重要。而传统数据库系统大多采用的是基于锁的并发控制机制，包括行级锁、表级锁等，但随着互联网的快速发展和普及，分布式部署架构越来越多，对数据库系统性能要求也越来越高。因此，随着NoSQL数据库发展，如HBase、MongoDB等出现，基于锁的并发控制机制逐渐失去了市场份额。相反地，为了提高数据库系统的并发性能，目前很多数据库系统都采用了基于MVCC（多版本并发控制）的并发控制机制。

通常情况下，MVCC支持多个事务同时执行，并保证每个事务能够看到自己应该看到的数据版本。但是由于MVCC只能提供数据视图的一致性，不支持事务的隔离性和一致性，因而引起了一些性能上的问题。一种典型的场景就是，一个事务的更新操作被另一个事务的查询操作阻塞，导致整个系统无法正常运行。

MySQL数据库目前支持多种类型的事务隔离级别，例如读未提交、读已提交、可重复读、串行化。但是对于“读已提交”、“重复读”这些级别的定义，各个厂商之间存在细微差别，可能导致不同的实现方式。因此，本文首先将对“读已提交”和“重复读”这两个级别进行一下背景介绍，然后再讨论它们之间的区别和联系，最后给出MySQL数据库“读已提交”和“重复读”的实现原理及其不同之处。

## 1.2基本概念术语说明
### （1）事务
事务(Transaction)是一个完整的工作单元，由一个或多个SQL语句组成，并作为一个整体被提交或者回滚到数据库。事务具有4个属性，分别是原子性、一致性、隔离性、持久性。通过事务管理可以避免多个事务并发执行时由于交叉执行而导致数据不一致的问题。

### （2）并发控制
并发控制是指多个事务同时访问同一资源，并在争夺临界资源时作出限制，防止彼此干扰，确保数据的一致性和正确性。

### （3）读已提交（Read Committed）
是最低的隔离级别，它表示一个事务从开始直到提交之前，其它事务不能对该事务所做的修改进行读取。换句话说，就是一个事务只能看见已经提交的事务所做的修改。

举例来说，如果一个事务对一行记录做了更新操作，那么其他事务不能立即看到这个更新，除非第一个事务被提交。

### （4）重复读（Repeatable Read）
该隔离级别保证一个事务开始读取某个数据期间，不会再产生新的符合条件的记录。因此，该隔离级别允许对同一字段的并发读。但是，当第二次读取某些记录时，又会生成最新快照。REPEATABLE READ隔离级别主要用于读取历史记录，并且不需要获得共享锁。

举例来说，一个事务在读取某些记录前，先创建一个当前快照。当第二次读取相同记录时，就不会再新增或者删除符合条件的记录，只会对已有记录进行更新。

### （5）串行化（Serializable）
这是最高的隔离级别，它确保事务按照事务请求的顺序执行，这样也就排除了并发执行带来的任何隐患。

串行化隔离级别最严格，并发性能较差，一般仅在需要保证绝对数据一致性时才使用，比如银行转账事务。