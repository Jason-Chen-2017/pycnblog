
作者：禅与计算机程序设计艺术                    

# 1.简介
  

观察者模式（Observer Pattern）又叫做发布-订阅模式，定义了一种一对多依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时会通知所有观察者，使它们能够自动更新自己。通过这种方式，观察者对象能够实时接收到主题对象发送过来的消息。观察者模式属于行为型设计模式，它解决的是对象之间的一对多依赖关系，并在运行时确定和执行相应的动作。

观察者模式在现实生活中广泛存在，如：招聘信息发布系统、新闻更新推送、股票行情更新、投资组合实时监控等。

本文将详细阐述观察者模式的基本原理及应用。

# 2.背景介绍
## 2.1 什么是观察者模式
观察者模式（Observer Pattern）是一个反应性编程的设计模式。它定义了一种一对多依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时会通知所有观察者，使它们能够自动更新自己。通过这种方式，观察者对象能够实时接收到主题对象发送过来的消息。观察者模式属于行为型设计模式，它解决的是对象之间的一对多依赖关系，并在运行时确定和执行相应的动作。

## 2.2 为何要使用观察者模式？
观察者模式主要用于以下几个方面：

1. 对象间的低耦合关系

   - 观察者模式可以降低目标对象和观察者之间的耦合度，两者之间只需要知道如何交互，而不需要相互了解。

2. 易于扩展

   - 通过观察者模式可以向已有的对象添加新的观察者，而无需修改其源代码。

3. 异步通信

   - 由于观察者模式中观察者和被观察者之间是一对多的依赖关系，所以观察者对象不必等到事件发生再采取行动，从而提高了系统的灵活性。

4. 支持广播通信

   - 在观察者模式中，观察者对象并不直接收到通知，而是由 Subject 对象转发到各个观察者进行处理，这样就可以实现广播通信。

## 2.3 适用场景

观察者模式通常适用于以下场景：

1. 当一个对象改变状态时，需要给其他对象发送通知；
2. 当一个对象（目标对象）的内部状态改变时，希望通知其他对象；
3. 当一个对象（目标对象）的行为切片复杂时，希望将行为分布到不同的对象中去，而不是集中在一个对象上；
4. 当一个对象（目标对象）的属性值有不同的值时，希望能够管理依赖它的对象集合，然后自动通知它们进行更新。

# 3.核心概念

## 3.1 观察者模式结构

观察者模式包含如下四个角色：

1. Subject（主题对象）: 它是目标对象，所有观察者对象都订阅它，当目标对象状态改变时，观察者对象都会得到通知。Subject 对象提供registerObserver()方法用来注册观察者对象，deregisterObserver()方法用来注销观察者对象，notifyObservers()方法用来通知所有的观察者对象。

2. Observer（观察者对象）：它观察目标对象，并且实现更新接口，以便状态变更时得到通知。Observer 对象需要持有 subject 对象，以获取状态信息。

3. ConcreteSubject （具体主题对象）：它是主题对象，用来保存相关的状态。ConcreteSubject 可以增加或删除观察者对象，也可以设置状态，从而影响所有观察者的行为。

4. ConcreteObserver（具体观察者对象）：它是观察者对象，关注目标对象，并且实现更新接口。ConcreteObserver 的 update() 方法实现状态的更新。


## 3.2 时序图

下面给出一个时序图描述一下具体的流程：


### 3.2.1 Subject类

Subject 是目标对象，即 Observable 对象，提供了 registerObserver(), deregisterObserver() 和 notifyObservers() 三个方法。其中，registerObserver() 方法用于注册观察者对象，deregisterObserver() 方法用于注销观察者对象，notifyObservers() 方法用于通知所有的观察者对象。

```java
public abstract class Subject {
    private List<Observer> observers = new ArrayList<>();

    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update();
        }
    }

    protected Object getState(){ // 获取目标对象的状态信息
        return null;
    }
}
```

### 3.2.2 Observer类

Observer 是观察者对象，实现了 update() 方法，该方法用于状态更新时获得通知。

```java
public interface Observer {
    public void update();
}
```

### 3.2.3 ConcreteSubject类

ConcreteSubject 是具体主题对象，用于保存相关的状态。具体主题对象可增加或删除观察者对象，也可以设置状态，从而影响所有观察者的行为。

```java
public class ConcreteSubject extends Subject {
    private String state;

    @Override
    public void registerObserver(Observer observer) {
        super.registerObserver(observer);
        System.out.println("Subject added a new observer");
    }

    @Override
    public void removeObserver(Observer observer) {
        super.removeObserver(observer);
        System.out.println("Subject removed an existing observer");
    }

    @Override
    public void notifyObservers() {
        System.out.println("Notifying all observers of change in state");
        super.notifyObservers();
    }

    public void setState(String state){
        this.state = state;
        System.out.println("New State set: "+this.state);
        notifyObservers();
    }
}
```

### 3.2.4 ConcreteObserver类

ConcreteObserver 是具体观察者对象，关注目标对象，并且实现了 update() 方法。

```java
public class ConcreteObserver implements Observer{
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void update() {
        System.out.println(name + " received notification from subject.");
    }
}
```


# 4.具体实例

假设有一个界面（GUI），包括按钮、文本框、列表框，点击按钮触发点击事件，输入框输入内容触发文本改变事件，选中列表项触发选择事件。这些事件可能触发其他的事件，比如刷新表单事件、弹出提示框事件等。如何实现事件的同步通知，可以使用观察者模式。

## 4.1 模拟场景

模拟一个简单的例子，创建一个 GUI，包括一个按钮、一个输入框、一个文本框、一个列表框。按钮触发点击事件，输入框输入内容触发文本改变事件，选中列表项触发选择事件。三个事件分别使用三个不同的观察者（ClickListener、TextChangeListener、SelectionListener）。

## 4.2 创建主题对象

首先，创建主题对象 ConcreteSubject。用于保存相关的状态信息。

```java
public class ConcreteSubject extends Subject {
    private String buttonText; // 按钮显示文本
    private String inputText; // 输入框显示文本
    private int selectionIndex; // 列表项索引
    
    public ConcreteSubject() {}
    
    /**
     * 设置按钮显示文本
     */
    public void setButtonText(String text) {
        this.buttonText = text;
        this.notifyObservers(); // 通知观察者
    }
    
    /**
     * 设置输入框显示文本
     */
    public void setInputText(String text) {
        this.inputText = text;
        this.notifyObservers();
    }
    
    /**
     * 设置列表项索引
     */
    public void setSelectionIndex(int index) {
        this.selectionIndex = index;
        this.notifyObservers();
    }
    
    /**
     * 获取当前按钮显示文本
     */
    public String getButtonText() {
        return this.buttonText;
    }
    
    /**
     * 获取当前输入框显示文本
     */
    public String getInputText() {
        return this.inputText;
    }
    
    /**
     * 获取当前列表项索引
     */
    public int getSelectionIndex() {
        return this.selectionIndex;
    }
    
    /**
     * 获取目标对象的状态信息
     */
    @Override
    protected Object getState(){ 
        Map<String,Object> map = new HashMap<>();
        map.put("buttonText", this.buttonText);
        map.put("inputText", this.inputText);
        map.put("selectionIndex", this.selectionIndex);
        return map;
    }
}
```

## 4.3 创建观察者对象

然后，创建观察者对象 ClickListener、TextChangeListener、SelectionListener。分别用于响应点击事件、输入框内容改变事件、列表项选择事件。

```java
public class ClickListener implements Observer {
    private String name;

    public ClickListener(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void update() {
        System.out.println(name + " received click event from subject!");
    }
}

public class TextChangeListener implements Observer {
    private String name;

    public TextChangeListener(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void update() {
        System.out.println(name + " received text changed event from subject!");
    }
}

public class SelectionListener implements Observer {
    private String name;

    public SelectionListener(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void update() {
        System.out.println(name + " received selection changed event from subject!");
    }
}
```

## 4.4 注册观察者对象

接着，注册观察者对象。

```java
public static void main(String[] args) {
    ConcreteSubject subject = new ConcreteSubject();

    ClickListener listener1 = new ClickListener("listener1");
    subject.registerObserver(listener1);

    TextChangeListener listener2 = new TextChangeListener("listener2");
    subject.registerObserver(listener2);

    SelectionListener listener3 = new SelectionListener("listener3");
    subject.registerObserver(listener3);
}
```

## 4.5 绑定事件监听器

最后，绑定事件监听器，实现相应的响应。

```java
public static void main(String[] args) {
    final JFrame frame = new JFrame("Observer Example");
    JPanel panel = new JPanel(new GridLayout(4, 1));

    JButton button = new JButton("Click Me!");
    JTextField inputField = new JTextField(15);
    JLabel label = new JLabel("");
    JList list = new JList(new String[]{"Item1","Item2","Item3"});

    // 注册观察者对象
    ConcreteSubject subject = new ConcreteSubject();

    ClickListener listener1 = new ClickListener("listener1") {
        @Override
        public void update() {
            System.out.println("Button clicked.");

            // 更新按钮显示文本
            subject.setButtonText("Button Pressed!");

            // 刷新界面
            SwingUtilities.invokeLater(() -> {
                button.setText(subject.getButtonText());
            });
        }
    };
    subject.registerObserver(listener1);

    TextChangeListener listener2 = new TextChangeListener("listener2") {
        @Override
        public void update() {
            System.out.println("Input field text changed.");

            // 更新输入框显示文本
            subject.setInputText(inputField.getText().trim());

            // 刷新界面
            SwingUtilities.invokeLater(() -> {
                label.setText("<html><body><p style='color:#FF0000'>"
                        + subject.getInputText() + "</p></body></html>");
            });
        }
    };
    subject.registerObserver(listener2);

    SelectionListener listener3 = new SelectionListener("listener3") {
        @Override
        public void update() {
            System.out.println("List item selected.");

            // 更新列表项索引
            subject.setSelectionIndex(list.getSelectedIndex());
        }
    };
    subject.registerObserver(listener3);

    // 添加组件到Panel中
    panel.add(button);
    panel.add(inputField);
    panel.add(label);
    panel.add(list);

    // 设置Frame的内容Pane
    frame.setContentPane(panel);

    // 设置Frame大小和位置
    frame.setSize(300, 300);
    frame.setLocationRelativeTo(null);

    // 设置关闭窗口时的行为
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

    // 显示Frame
    frame.setVisible(true);
}
```

# 5.总结

本文以一个简单的示例，展示了观察者模式的基本原理及应用。从简单的场景到实际的开发案例，观察者模式涉及的角色、构成、角色职责、时序图、注意事项等，都有深入浅出的呈现。文章中所示代码非常简单易懂，良好的命名、注释，能够帮助读者理解观察者模式的设计思路和运用。

观察者模式是一个优秀的设计模式，虽然在实际开发中可能会遇到一些坑，但是掌握了观察者模式的基本原理和运用，对于后续的开发工作也有很大的帮助。