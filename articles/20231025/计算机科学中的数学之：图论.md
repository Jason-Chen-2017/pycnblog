
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 图（Graph）
> A graph is a structure consisting of vertices and edges that can be connected in various ways to form different shapes or structures called graphs. The graph data type consists of two components: the set of vertices (or nodes) and the set of edges connecting these vertices (also known as links or arcs). These sets are represented by mathematical objects such as points or lines and their connections are defined through pairs of endpoints. Graphs can have multiple representations depending on how they are drawn or displayed. For example, the simplest representation of a graph is a list of its vertices and the edges between them. This representation has a clear and simple visual style but it is not particularly useful for complex networks with large numbers of vertices and edges. Other common graph representations include matrices, adjacency lists, and incidence matrices. In this article, we will focus mainly on simple, undirected graphs using an adjacency matrix representation.

## 图的定义
图由顶点（Node）和边（Edge）组成，一个图由顶点集V和边集E表示。其中，顶点集V是一个非空集合，边集E也是一个非空集合；每条边都有一个起始顶点和终止顶点，表示该边连接两个顶点。通过将两顶点之间的所有边所形成的集合，来建立顶点之间的邻接关系。图的边也可以有方向性，即边可以从起始顶点指向终止顶点或反向指向。在无向图中，一条边不会被同时存储在两个顶点的邻接列表中。如果图是有向的，那么每条边都有一个方向，表示从一个顶点到另一个顶点的方向。

## 图的种类
根据边的数量、权值的大小、是否存在环路等特点，图分为不同的类型。最简单的图就是无向连通图(Undirected Connected Graph)。它是一个简单而灵活的模型，可以用来描述物质世界的结构，如交通网络、人际关系、组织架构等。

除此之外，还有包括有向图、带权重边图、带负权重边图、多重图等不同类型的图。

## 图的表示形式
图可以用不同的表示形式来表示。其中，最常用的两种图的表示形式为邻接矩阵（Adjacency Matrix）和邻接表（Adjacency List）。

### 邻接矩阵（Adjacency Matrix）
邻接矩阵是一种比较直观的表示方式，它是一个方阵。方阵的每个元素代表了图中的一条边的存在情况。如果方阵中第i行第j列的元素的值为w，则意味着从顶点vi到顶点vj的边权值为w。

### 邻接表（Adjacency List）
邻接表是一种更加抽象的表示方式。它采用数组或链表的形式存储图的信息。对于每个顶点，邻接表中保存的是以该顶点为头的边集。每条边由三个元素构成：该边的尾节点、该边的权值和下标。下标指出了该边的位置，方便进行删除、插入、查找等操作。

```c++
// Adjacency List representation of a directed unweighted graph
struct Node {
    int dest; // destination vertex
    struct Edge* next; // pointer to next edge node
};

struct Edge {
    int weight; // weight of the edge
    Node* head; // pointer to head node
    struct Edge* next; // pointer to next adjacent edge node
};

struct Graph {
    int V; // number of vertices
    vector<vector<int>> adj; // adjacency list
};

void add_edge(Graph& G, int u, int v, int w) {
    Node* nu = new Node();
    nu->dest = v;

    Edge* ne = new Edge();
    ne->weight = w;
    ne->head = nu;
    ne->next = NULL;

    if (!G.adj[u].empty())
        G.adj[u][-1]->next = ne;
    else
        G.adj[u].push_back(ne);

    G.adj[u].push_back(nu);
}

void print_graph(Graph G) {
    for (int i = 0; i < G.V; ++i) {
        cout << "Vertex " << i << ": ";

        auto it = G.adj[i].begin();
        while (it!= G.adj[i].end()) {
            cout << (*it)->head->dest << "(" << (*it)->weight << ") ";
            it++;
        }
        cout << endl;
    }
}
```