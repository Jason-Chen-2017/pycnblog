
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


> 本课程将从基础的数据结构（数组、链表、栈、队列、散列表等）入手，带领读者了解并掌握常用的复杂数据结构（树、图、堆、集合等）的实现及其应用。通过熟练掌握这些数据结构的特性和运用方式，读者能够更好地理解并解决实际问题，提升编程能力和业务能力。本课程是基于实际工程项目开发需求，结合开源库、语言特性及数据结构原理等多种视角，逐步提升复杂数据结构的理解与应用技巧，帮助读者真正具备面试的通用素质。

# 2.核心概念与联系
## （1）树（Tree）
树是一种重要的非线性数据结构，它由结点（node）和边（edge）组成，边表示结点之间的关联关系。每个结点可以有零个或多个子节点，称为孩子，子节点的数量称为度。树的根节点称为跟节点。树的高度为树中最长简单路径的长度。

常见的树结构包括二叉树、满二叉树、完全二叉树和堆。

- **二叉树**（Binary Tree）：是每个结点最多有两个子树的树结构。最简单的二叉树就是链表，其中每个元素都只有左或者右孩子结点，这种树也称为链式存储结构。另外，由于满二叉树的每一层上都有叶子节点，因此用途非常广泛。

- **满二叉树**（Full Binary Tree）：除最后一层外，其他所有层都达到最大宽度。所有的非终端结点均有两个子女，并且所有叶子都在同一层上。

- **完全二叉树**（Complete Binary Tree）：对于一棵有n个结点的完全二叉树，除了第i层外，其它各层 (1～i-1) 的结点数都达到最大值，而第 i 层上的结点都连续集中在最左边，这是一个特点。

- **堆**（Heap）：堆是一种特殊的完全二叉树，满足特定的数据结构，即最大堆和最小堆。最小堆中的父节点的值一定不大于任何一个子节点，而最大堆则刚好相反。

## （2）图（Graph）
图是由顶点（vertex）和边（edge）组成的抽象数据类型，用来描述具有相互连接的对象之间的某些事情。一般来说，图被用于描述计算机科学中的很多领域，比如电路网络、计算网络、人际关系网络、信息流网络、生物进化网络等等。

图分为两种基本结构——无向图（Undirected Graph）和有向图（Directed Graph）。前者表示任意两个顶点之间都可能有边相连；后者则是指定了一条边的起始顶点和结束顶点，只有指定的方向才会存在边相连。

常见的图结构包括邻接矩阵、邻接表、十字链表、边集数组和邻接多重表。

- **邻接矩阵**（Adjacency Matrix）：邻接矩阵是一种比较简单的图表示方法。在邻接矩阵中，一个 n × n 的布尔矩阵，其中 n 是图中顶点的个数。如果存在一条从顶点 i 到顶点 j 的边，那么 A[i][j] 和 A[j][i] 就置为 true。这种方式简单直观，但是空间复杂度较高，当顶点个数 n 很大时，占用的内存很大。

- **邻接表**（Adjacency List）：邻接表是另一种常用的图表示方法。邻接表中的每个顶点对应一个链表，链表中的每个元素是一个与该顶点相连接的顶点。这种方式可以支持 O(1) 时间复杂度的插入和删除操作，但是需要额外的存储空间。

- **十字链表**（Cross Linked List）：十字链表是另一种较为复杂的图表示方法，它把图的边按上下顺序链接起来。每个顶点除了有一个指针指向它的后继顶点，还有一个指针指向它的前驱顶点。这样就可以方便地进行迭代遍历，例如 DFS 中。

- **边集数组**（Edge Set Array）：边集数组是在邻接矩阵的基础上对矩阵进行压缩，只存储与边相关的信息。这种方式下，每个顶点的出度或入度直接可用数组索引计算出来。对于稀疏图，节省空间。

- **邻接多重表**（Adjacency MultiList）：邻接多重表也是一种常用的图表示方法，它维护了每个顶点的所有出边和入边。出边和入边的边权可以使用不同的数据结构进行维护。例如，对于无向图，边权可以是一个布尔值，表示是否存在。对于带权图，边权可以是一个整数，表示边的权重。这种方式维护了每条边的信息，适合有多个边的情况，如网络拓扑图。

## （3）栈（Stack）
栈是一种线性数据结构，只能在一端进行插入和删除操作，先进入的元素最后一个被释放（LIFO）。栈可以作为一种容器，用于保存和处理数据。常见的栈结构包括列表栈、链栈和共享栈。

- **列表栈**（Array Stack）：列表栈其实就是一个数组，数组中的元素作为栈的元素，栈顶索引（top）表示栈顶元素的位置，栈底索引（bottom）表示栈底元素的位置。栈为空时，top = bottom + 1，栈满时，top = capacity - 1，此时溢出错误。

- **链栈**（Linked Stack）：链栈是一个双向链表，每个结点存储元素值和指针。栈顶指针 head 表示栈顶元素，栈底指针 tail 表示栈底元素。入栈时，新元素加入尾部，出栈时，从头部弹出。链栈也可称为链表栈。

- **共享栈**（Shared Stacks）：共享栈采用共享内存的方式实现多个进程间的数据共享。进程通过系统调用将自己的栈缓冲区映射到主存地址空间，使得进程之间可以访问相同的栈内存。共享栈与线程安全有关。

## （4）队列（Queue）
队列是一种线性数据结构，只能在一端进行插入操作，另一端进行删除操作，先进入的元素第一个被释放（FIFO）。队列可以作为一种容器，用于保存和处理排队任务。常见的队列结构包括循环队列、链表队列和共享队列。

- **循环队列**（Circular Queue）：循环队列类似于链表，但是队尾的链接指向队首。队尾指针rear指向队列最后一个有效元素，队头指针front指向下一个待删除的元素。当队列为空时，front=rear=-1；当队列已满时，在 rear 后面再加入新的元素，则覆盖旧元素。

- **链表队列**（Linked Queue）：链表队列是一个双向链表，队尾指针tail指向队列最后一个元素，队头指针head指向下一个待删除的元素。入队时，新元素加入尾部；出队时，从头部弹出。

- **共享队列**（Shared Queues）：共享队列采用共享内存的方式实现多个进程间的数据共享。进程通过系统调用将自己的消息队列缓冲区映射到主存地址空间，使得进程之间可以访问相同的消息队列内存。共享队列与线程安全有关。

## （5）散列表（Hash Table）
散列表是一种存储键值对的抽象数据类型。其工作原理是利用一个散列函数将关键字映射到表中一个位置来存储或查找元素。散列表最主要的优点是平均情况下的查询时间为 O(1)，缓存命中率高，在解决 hash 冲突问题时也有不同的解决方案。

常见的散列函数有简单哈希法、开放寻址法、链表法和双哈希法等。

- **简单哈希法**（Simple Hash Function）：假设关键字有 m 个取值范围 [0,m-1], 用散列函数 f() 将关键字 k 映射到范围 [0, m-1] 中的某个位置 i, 则 hash(k) = f(k)。简单哈希法的缺点是易产生冲突，导致均匀分布，失去效率。

- **开放寻址法**（Open Addressing）：开放寻址法是解决冲突的方法之一。当关键字冲突时，通过选择另一个空闲位置代替当前位置。开放寻址法有多种策略，包括线性探测、平方探测、折半探测等。线性探测指的是按照固定间隔搜索，即每次探测距离上一次探测的下标加上探测间隔。

- **链表法**（Chaining）：链表法是解决冲突的方法之一。对于出现冲突的关键字，将冲突的记录存储在一个链表中，然后依次探测下一个空闲位置直至找到可用的位置。这种方法解决了简单哈希法容易产生聚集的问题，但链表过长会造成内存浪费。

- **双哈希法**（Double Hashing）：双哈希法是一种改进的开放寻址法。其基本思想是，根据关键字的某一部分进行一次散列得到索引位置，然后再根据关键字的其他部分进行第二次散列得到另一个索引位置。当发生冲突时，则将元素插入相应的位置。

## （6）集合（Set）
集合是一种无序且唯一的元素集合。其最主要的功能是确定元素之间的关系。集合的两种主要形式——集合和族——都可以表示。

- **集合**（Set）：集合是指无序且唯一的元素的集合。通常，集合的内容可以通过添加和移除元素来动态变化。

- **族**（Family）：族是由元素的集合组成的一个抽象集合。集合族是一种灵活的工具，因为它可以容纳不同的类型和大小的集合。族提供了一种结构，可以将属于不同集合的元素划分成不同的组，这对于管理复杂的关系网非常有用。

## （7）堆（Priority Queue）
堆是一个典型的优先队列数据结构，可以维持元素的优先级顺序。堆可以实现插入和删除操作的时间复杂度都是 O(logN)，其中 N 为堆中元素的个数。一般来说，堆通常是用数组实现的，但也可以用其他数据结构如链表实现。

堆的两种基本形式——最小堆和最大堆——都可以表示。

- **最小堆**（Min Heap）：最小堆中的父结点的值一定不大于它的子结点的值。最小堆的性质是：任意节点值都不小于（或者说不大于）其子结点值的任意节点。最小堆的根节点的值是整个堆的最小值。

- **最大堆**（Max Heap）：最大堆中的父结点的值一定不小于它的子结点的值。最大堆的性质是：任意节点值都不大于（或者说不小于）其子结点值的任意节点。最大堆的根节点的值是整个堆的最大值。