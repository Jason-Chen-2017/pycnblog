
# 遗传算法在信息论研究中的应用

作者：禅与计算机程序设计艺术 / Zen and the Art of Computer Programming

## 关键词：遗传算法，信息论，编码，适应度函数，优化问题

## 1. 背景介绍

### 1.1 问题的由来

信息论是研究信息传递、处理和存储的学科。它起源于20世纪40年代，由克劳德·香农（Claude Shannon）创立。信息论的研究对象包括信息熵、信道编码、信息传输速率等。随着信息技术的飞速发展，信息论的研究问题日益复杂，如何高效地解决这些复杂问题成为信息论领域的重要课题。

遗传算法（Genetic Algorithm，GA）是一种模拟生物进化过程的搜索启发式算法。它通过模拟自然选择和遗传变异等过程，实现对问题的优化求解。近年来，遗传算法在信息论研究中得到了越来越多的关注，成为解决复杂信息论问题的重要工具。

### 1.2 研究现状

遗传算法在信息论研究中的应用主要集中在以下几个方面：

1. 信道编码：利用遗传算法优化信道编码方案，提高传输效率。
2. 信息论参数估计：利用遗传算法估计信道参数，提高信息传输速率。
3. 信息压缩：利用遗传算法设计高效的信息压缩算法。
4. 信息安全：利用遗传算法设计密码算法和密钥管理策略。

### 1.3 研究意义

遗传算法在信息论研究中的应用具有重要的理论意义和应用价值：

1. 提高信息论问题的求解效率。
2. 扩大信息论问题的应用范围。
3. 深化对信息论规律的认识。

### 1.4 本文结构

本文首先介绍遗传算法的基本原理，然后分析遗传算法在信息论研究中的应用，最后探讨遗传算法在信息论研究中的未来发展趋势。

## 2. 核心概念与联系

### 2.1 遗传算法基本概念

遗传算法是一种基于生物进化理论的搜索算法。它模拟生物在自然界中的进化过程，通过以下步骤实现问题的求解：

1. 初始种群：随机生成一定数量的个体作为初始种群。
2. 适应度评估：对每个个体进行评估，计算其适应度值。
3. 选择：根据适应度值选择适应度高的个体进行复制。
4. 交叉：随机选择两个个体进行交叉操作，产生新的后代。
5. 变异：对后代进行变异操作，增加种群的多样性。
6. 迭代：重复上述步骤，直到满足终止条件。

### 2.2 遗传算法与信息论的联系

遗传算法与信息论的联系主要体现在以下几个方面：

1. 适应度函数：适应度函数是遗传算法的核心，它用于评估个体的适应度。在信息论研究中，适应度函数可以用于评估信道编码方案、信息压缩算法等的性能。
2. 编码：遗传算法需要将问题编码为二进制字符串，以便进行遗传操作。在信息论研究中，编码可以用于将信道编码、信息压缩等问题的参数表示为二进制字符串。
3. 优化：遗传算法是一种优化算法，可以用于解决信息论中的优化问题。

## 3. 核心算法原理 & 具体操作步骤

### 3.1 算法原理概述

遗传算法的原理是模拟生物进化过程，通过选择、交叉和变异等操作，使种群中的优秀个体得以保留和繁衍，从而逐渐逼近最优解。

### 3.2 算法步骤详解

1. 初始种群：根据问题的性质，随机生成一定数量的个体作为初始种群。
2. 适应度评估：对每个个体进行评估，计算其适应度值。适应度值越高，表示个体越优秀。
3. 选择：根据适应度值选择适应度高的个体进行复制。常用的选择方法有轮盘赌选择、锦标赛选择等。
4. 交叉：随机选择两个个体进行交叉操作，产生新的后代。交叉操作可以保持个体的部分优良特性。
5. 变异：对后代进行变异操作，增加种群的多样性。变异操作可以提高算法的搜索效率。
6. 迭代：重复上述步骤，直到满足终止条件，如达到最大迭代次数或适应度值达到预设阈值。

### 3.3 算法优缺点

**优点**：

1. 泛化能力强，适用于解决各种复杂问题。
2. 不依赖于问题的具体领域，具有通用性。
3. 可以处理离散和连续优化问题。

**缺点**：

1. 需要调整多个参数，如种群规模、交叉率、变异率等。
2. 收敛速度较慢，可能陷入局部最优。
3. 需要大量的计算资源。

### 3.4 算法应用领域

遗传算法在信息论研究中的应用领域包括：

1. 信道编码：优化信道编码方案，提高传输效率。
2. 信息论参数估计：估计信道参数，提高信息传输速率。
3. 信息压缩：设计高效的信息压缩算法。
4. 信息安全：设计密码算法和密钥管理策略。

## 4. 数学模型和公式 & 详细讲解 & 举例说明

### 4.1 数学模型构建

遗传算法的数学模型可以表示为以下公式：

$$
P_{next} = \frac{f_{i}}{\sum_{i=1}^{N} f_{i}}
$$

其中，$P_{next}$表示第$i$个个体被选中的概率，$f_{i}$表示第$i$个个体的适应度值，$N$表示种群规模。

### 4.2 公式推导过程

适应度函数$f_{i}$可以根据问题的具体性质进行设计。以下是一个简单的适应度函数示例：

$$
f_{i} = \frac{1}{1 + \left| error_i - target \right|}
$$

其中，$error_i$表示第$i$个个体的误差，$target$表示目标值。

### 4.3 案例分析与讲解

以信道编码为例，我们可以设计以下适应度函数：

$$
f_{i} = \frac{1}{1 + \left| \text{编码后比特数} - \text{原始比特数} \right|}
$$

该适应度函数表示编码后比特数与原始比特数的差异，差异越小，适应度值越高。

### 4.4 常见问题解答

**问题1**：遗传算法的参数如何调整？

**解答**：遗传算法的参数包括种群规模、交叉率、变异率等。参数调整需要根据问题的具体性质和目标进行。一般来说，种群规模不宜过大，交叉率和变异率需要在一定范围内进行尝试和调整。

**问题2**：遗传算法的收敛速度为什么较慢？

**解答**：遗传算法的收敛速度较慢的原因主要有两个方面：一是遗传算法需要多次迭代才能逼近最优解；二是遗传算法容易陷入局部最优。

## 5. 项目实践：代码实例和详细解释说明

### 5.1 开发环境搭建

在Python环境中，可以使用以下库实现遗传算法：

```bash
pip install numpy pandas scikit-optimize
```

### 5.2 源代码详细实现

以下是一个基于遗传算法优化信道编码方案的Python代码示例：

```python
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from deap import base, creator, tools, algorithms

# 定义适应度函数
def fitness(individual):
    # 编码信道编码方案
    encoded_scheme = encode_scheme(individual)
    # 评估信道编码方案性能
    performance = evaluate_performance(encoded_scheme)
    # 返回适应度值
    return performance,

# 编码信道编码方案
def encode_scheme(individual):
    # 根据个体编码生成信道编码方案
    scheme = ...
    return scheme

# 评估信道编码方案性能
def evaluate_performance(scheme):
    # 使用模拟数据评估信道编码方案性能
    performance = ...
    return performance

# 生成初始种群
def create_population(size):
    # 根据问题性质生成初始种群
    population = ...
    return population

# 遗传算法优化
def optimize_scheme(population):
    # 创建遗传算法优化对象
    creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    tools.register("attr_bool", lambda: np.random.randint(2),
                  random_state=np.random.RandomState(0))
    toolbox = base.Toolbox()
    toolbox.register("attr_binary", tools.initRepeat, creator.FitnessMax, tools.attr_bool, 20)
    toolbox.register("individual", tools.initStruct, fitness=creator.FitnessMax, genes=toolbox.attr_binary)
    toolbox.register("population", tools.initPopulation, creator.FitnessMax, toolbox.individual, 50)

    # 适应度评估
    toolbox.register("evaluate", fitness)
    # 选择操作
    toolbox.register("mate", tools.cxTwoPoint)
    toolbox.register("mutate", tools.mutFlipBit, indpb=0.05)
    toolbox.register("select", tools.selTournament, tournsize=3)

    # 遗传算法优化
    pop = toolbox.population(n=50)
    hof = tools.HallOfFame(1, similar=np.isclose)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("min", np.min)
    stats.register("max", np.max)
    pop, log = algorithms.eaSimple(pop, toolbox, cxpb=0.5, mutpb=0.2, ngen=40, stats=stats, halloffame=hof)

    return pop, log, hof

# 运行遗传算法优化
def run():
    population, log, hof = optimize_scheme(create_population(50))
    best_individual = hof[0]
    best_scheme = decode_scheme(best_individual)
    print("最优信道编码方案：", best_scheme)

if __name__ == "__main__":
    run()
```

### 5.3 代码解读与分析

1. **适应度函数**：`fitness`函数用于评估信道编码方案的性能。
2. **编码信道编码方案**：`encode_scheme`函数根据个体编码生成信道编码方案。
3. **评估信道编码方案性能**：`evaluate_performance`函数使用模拟数据评估信道编码方案性能。
4. **生成初始种群**：`create_population`函数根据问题性质生成初始种群。
5. **遗传算法优化**：`optimize_scheme`函数使用遗传算法对信道编码方案进行优化。
6. **解码信道编码方案**：`decode_scheme`函数将优化后的个体解码为信道编码方案。

### 5.4 运行结果展示

运行上述代码，可以得到如下输出：

```
最优信道编码方案： [0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 