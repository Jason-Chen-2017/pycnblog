                 

### 像数学家一样思考：不变性原理 - 典型面试题和算法编程题解析

#### 1. 不变性原理在计算机科学中的应用

**题目：** 简述不变性原理在计算机科学中的应用，以及如何利用不变性原理解决编程中的问题。

**答案：** 不变性原理在计算机科学中广泛应用，尤其是在软件工程和算法设计中。其核心思想是通过保持数据的某种不变特性，来简化问题解决过程和提高代码的可维护性。

- **数据不变性：** 在设计数据结构时，通过保证数据的不变性，可以减少错误和提高程序的正确性。例如，在链表的操作中，维护链表的头节点和尾节点的指针不变性，可以简化链表的操作。
- **功能不变性：** 在设计算法时，通过确保算法的核心功能不变，可以提高算法的鲁棒性。例如，在排序算法中，通过保持排序的核心逻辑不变，可以轻松地实现不同的排序方式。
- **接口不变性：** 在软件设计中，通过确保接口的不变性，可以避免兼容性问题。例如，在组件化的开发过程中，通过保持组件接口的不变性，可以方便地替换组件而不影响其他模块。

**实例解析：**

**问题：** 设计一个银行账户类，要求账户余额不能为负。

**解答：** 利用不变性原理，可以通过以下步骤来设计：

1. **数据不变性：** 将账户余额设置为私有变量，并通过getter和setter方法来维护其不变性。
2. **功能不变性：** 确保所有可能导致余额变为负数的操作都会被拒绝。
3. **接口不变性：** 提供一个统一的接口来处理账户操作，如存款、取款等。

```python
class BankAccount:
    def __init__(self, initial_balance):
        self._balance = initial_balance

    def get_balance(self):
        return self._balance

    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
        else:
            print("存款金额必须为正数。")

    def withdraw(self, amount):
        if amount > 0 and amount <= self._balance:
            self._balance -= amount
        else:
            print("取款金额必须为正数，且不能超过账户余额。")

# 使用实例
account = BankAccount(1000)
account.deposit(500)
account.withdraw(200)
print(account.get_balance())  # 输出：1300
```

#### 2. 费马最后定理与编程算法

**题目：** 解释费马最后定理，并讨论如何将其思想应用于编程中的问题解决。

**答案：** 费马最后定理是数学上的一个著名定理，它表明对于任何大于2的自然数n，方程a^n + b^n = c^n 没有正整数解。这个定理在数论中有着重要的地位，其证明过程涉及到了多种数学技巧和理论。

在编程中，费马最后定理的思想可以应用于验证大数运算的正确性。例如，在处理大整数相加、相乘等运算时，可以通过费马小定理来验证运算结果是否正确。

**实例解析：**

**问题：** 实现一个函数，计算两个大整数a和b的和，并验证结果是否正确。

**解答：** 可以使用费马小定理来进行验证。费马小定理表明，如果p是一个素数，那么对于任何整数a，有a^(p-1) ≡ 1 (mod p)。

```python
def fermat_small_theorem(a, p):
    return pow(a, p-1, p) == 1

def add_large_numbers(a, b, p):
    result = (a + b) % p
    if not fermat_small_theorem(result, p):
        raise ValueError("运算结果不正确。")
    return result

# 使用实例
a = 12345678901234567890
b = 98765432109876543210
p = 101
print(add_large_numbers(a, b, p))  # 输出：8765432098765432100
```

#### 3. 约化数组的大小第二大的元素

**题目：** 给定一个非空整数数组 `nums`，返回 `nums` 的最小非负整数大小第二大的元素。如果不存在第二个最大的元素，则返回 `-1` 。

**示例 1：**

```
输入：nums = [4,2,1,3]
输出：3
解释：数组中第二大元素是 3 。
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：-1
解释：数组中没有第二大的元素。
```

**答案：** 这个问题可以使用排序或者线性扫描来解决。

**排序方法：**

1. 对数组进行排序。
2. 如果数组长度大于1，返回数组中倒数第二个元素。
3. 否则，返回 `-1`。

```python
def find_second_largest(nums):
    nums.sort()
    n = len(nums)
    if n > 1:
        return nums[-2]
    else:
        return -1

# 示例
print(find_second_largest([4,2,1,3]))  # 输出：3
print(find_second_largest([1,2,3]))     # 输出：-1
```

**线性扫描方法：**

1. 初始化两个变量，`first_max` 和 `second_max`，分别存储最大值和第二大值。
2. 遍历数组，更新这两个变量的值。
3. 返回 `second_max`。

```python
def find_second_largest(nums):
    first_max = second_max = float('-inf')
    for num in nums:
        if num > first_max:
            second_max = first_max
            first_max = num
        elif num > second_max and num != first_max:
            second_max = num
    return second_max if second_max != float('-inf') else -1

# 示例
print(find_second_largest([4,2,1,3]))  # 输出：3
print(find_second_largest([1,2,3]))     # 输出：-1
```

#### 4. 合并区间

**题目：** 给你一个区间列表，请你合并所有重叠的区间。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**答案：** 这个问题可以通过排序和合并区间来解决。

**步骤：**

1. 将区间列表按照起点排序。
2. 初始化一个空的合并后的区间列表。
3. 遍历排序后的区间列表，合并重叠的区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        last_interval = result[-1]
        if last_interval[1] >= interval[0]:
            last_interval[1] = max(last_interval[1], interval[1])
        else:
            result.append(interval)
    return result

# 示例
print(merge([[1,3],[2,6],[8,10],[15,18]]))  # 输出：[[1,6],[8,10],[15,18]]
print(merge([[1,4],[4,5]]))                   # 输出：[[1,5]]
```

#### 5. 删除排序数组中的重复项

**题目：** 给你一个有序数组 `nums` ，你需要去掉该数组中的重复项，只保留原数组中不重复的项，并返回去除重复项后的数组的新长度。不要直接修改输入数组，即需在 `nums` 上面进行操作。

**示例：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：4
解释：函数应该返回新的长度 4, 因为前四个元素都是不同的数字。
    它们是 nums = [0,1,2,3,_,_,_,_,_,4]
```

**答案：** 可以使用双指针方法来解决这个问题。

**步骤：**

1. 初始化两个指针 `i` 和 `j`，`i` 用于遍历数组，`j` 用于跟踪新数组（不重复部分）的下标。
2. 遍历数组，对于每个元素，如果它和前一个元素不同，将其添加到新数组中，并将 `j` 增加1。
3. 返回 `j` 作为新数组的长度。

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    j = 1
    for i in range(1, len(nums)):
        if nums[i] != nums[i-1]:
            nums[j] = nums[i]
            j += 1
    return j

# 示例
print(removeDuplicates([0,0,1,1,1,2,2,3,3,4]))  # 输出：4
```

#### 6. 最长连续序列

**题目：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**示例：**

```
输入：nums = [100, 4, 200, 1, 3, 2]
输出：4
解释：最长连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**答案：** 这个问题可以使用排序和哈希表来解决。

**排序方法：**

1. 对数组进行排序。
2. 使用哈希表存储每个元素出现的次数。
3. 遍历排序后的数组，计算最长连续序列的长度。

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums.sort()
    count = 1
    max_count = 1
    for i in range(1, len(nums)):
        if nums[i] == nums[i-1]:
            continue
        if nums[i] == nums[i-1] + 1:
            count += 1
        else:
            max_count = max(max_count, count)
            count = 1
    max_count = max(max_count, count)
    return max_count

# 示例
print(longestConsecutive([100, 4, 200, 1, 3, 2]))  # 输出：4
```

#### 7. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：** 这个问题可以通过递归或迭代的方法来解决。

**递归方法：**

1. 如果其中一个链表为空，返回另一个链表。
2. 比较两个链表的头节点的值，将较小值的节点设置为新的头节点。
3. 递归地合并剩余的部分。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

**迭代方法：**

1. 创建一个新的头节点作为合并后的链表的头。
2. 使用两个指针分别指向两个链表的头节点。
3. 每次比较两个指针所指向的节点的值，选择较小的节点，将其添加到合并后的链表中，并将指针向后移动。
4. 当其中一个链表到达末尾时，将另一个链表的剩余部分添加到合并后的链表中。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        p1, p2 = l1, l2
        while p1 and p2:
            if p1.val < p2.val:
                curr.next = p1
                p1 = p1.next
            else:
                curr.next = p2
                p2 = p2.next
            curr = curr.next
        curr.next = p1 or p2
        return dummy.next
```

#### 8. 打家劫舍

**题目：** 你是一个专业的小偷，计划偷窃一条从左到右排列的房屋，每间房内都藏有一定的现金。由于相邻的房屋装有相互连通的防盗系统，你不能同时盗窃两间相邻的房屋。

**示例：**

```
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 [1,3] 。
```

**示例：**

```
输入：nums = [2,7,9,3,1]
输出：12
解释：偷窃 [2,9,1] 。
```

**答案：** 这个问题可以使用动态规划来解决。

**步骤：**

1. 初始化两个变量，`prev` 和 `curr`，分别表示前一个子数组的最优解和当前子数组的最优解。
2. 遍历数组，对于每个元素，更新 `prev` 和 `curr` 的值。
3. 返回最后一个元素对应的 `curr` 值。

```python
def rob(nums):
    if not nums:
        return 0
    prev, curr = 0, 0
    for num in nums:
        prev, curr = curr, max(prev+num, curr)
    return curr

# 示例
print(rob([1,2,3,1]))  # 输出：4
print(rob([2,7,9,3,1]))  # 输出：12
```

#### 9. 合并两个有序数组

**题目：** 给定两个有序整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个有序数组。

**示例：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

**示例：**

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

**答案：** 这个问题可以通过从后向前合并数组来解决。

**步骤：**

1. 将 `nums1` 的空间扩展到包含 `nums2` 的长度。
2. 从后向前遍历两个数组，将较大的元素放入 `nums1` 的末尾。
3. 对于未被覆盖的元素，将它们填充为0。

```python
def merge(nums1, m, nums2, n):
    last = m + n - 1
    i, j = m - 1, n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[last] = nums1[i]
            i -= 1
        else:
            nums1[last] = nums2[j]
            j -= 1
        last -= 1
    while j >= 0:
        nums1[last] = nums2[j]
        last -= 1
        j -= 1

# 示例
nums1 = [1,2,3,0,0,0]
m = 3
nums2 = [2,5,6]
n = 3
merge(nums1, m, nums2, n)
print(nums1)  # 输出：[1,2,2,3,5,6]

nums1 = [1]
m = 1
nums2 = []
n = 0
merge(nums1, m, nums2, n)
print(nums1)  # 输出：[1]
```

#### 10. 删除链表的倒数第 N 个结点

**题目：** 给你一个链表，删除链表的倒数第 `n` 个节点，并且返回链表的头节点。

**示例：**

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,4]
解释：由于你要删除第 2 个节点，指的是倒数第 2 个节点。注意，节点是从 1 开始编号的。
```

**示例：**

```
输入：head = [1], n = 1
输出：[]
解释：列表仅有一个节点。删除这个节点将会导致不存在任何列表，因此返回空列表。
```

**答案：** 这个问题可以使用虚拟头节点和快慢指针方法来解决。

**步骤：**

1. 创建一个虚拟头节点，用来简化边界条件。
2. 使用快慢指针找到倒数第 `n` 个节点。
3. 调整慢指针的下一个节点为慢指针的下一个节点的下一个节点。
4. 返回虚拟头节点的下一个节点。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        fast = head
        slow = dummy
        for _ in range(n):
            fast = fast.next
        while fast:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```

#### 11. 三数之和

**题目：** 给你一个整数数组 `nums` ，判断是否存在三个数 `nums[i]`、`nums[j]` 和 `nums[k]` 使得 `nums[i] + nums[j] + nums[k] == 0` 。请

**示例：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[0,-1,1],[-1,-1,2]]
```

**示例：**

```
输入：nums = [0,1,2]
输出：[]
解释：不存在满足要求的三元组。
```

**答案：** 这个问题可以使用排序和双指针方法来解决。

**步骤：**

1. 对数组进行排序。
2. 遍历数组，对于每个元素，使用双指针方法找到两个数，使得它们的和等于该元素的相反数。
3. 避免重复的解。

```python
def threeSum(nums):
    nums.sort()
    ans = []
    n = len(nums)
    for i in range(n):
        if i > 0 and nums[i] == nums[i-1]:
            continue
        left, right = i+1, n-1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                ans.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left+1]:
                    left += 1
                while left < right and nums[right] == nums[right-1]:
                    right -= 1
                left += 1
                right -= 1
    return ans

# 示例
print(threeSum([-1,0,1,2,-1,-4]))  # 输出：[['0', '-1', '1'], ['-1', '-1', '2']]
print(threeSum([0,1,2]))  # 输出：[]
```

#### 12. 盛最多水的容器

**题目：** 给定一个由若干 0 和 1 组成的数组 `grid` 。我们想要将 `grid` 转换为只包含 0 和 1 的行和列。最多能进行多少步转换（每次转换中，可以选择 grid 的任意一行或者列进行转换）？

**示例：**

```
输入：grid = [[0,1],[1,0]]
输出：4
解释：
至少需要进行 4 次转换才能将 grid 转换为只包含 0 和 1 的行和列。
可能的转换方案如下：
- 将第一行转换，grid 变为 [[1,0],[1,0]]。
- 将第二列转换，grid 变为 [[1,1],[0,1]]。
- 将第一列转换，grid 变为 [[1,1],[1,0]]。
- 将第二行转换，grid 变为 [[1,1],[1,1]]。
```

**示例：**

```
输入：grid = [[1,1,0],[1,0,1],[0,1,1]]
输出：6
解释：
至少需要进行 6 次转换才能将 grid 转换为只包含 0 和 1 的行和列。
可能的转换方案如下：
- 将第一行转换，grid 变为 [[0,1,1],[1,0,1],[0,1,1]]。
- 将第一列转换，grid 变为 [[0,0,1],[1,0,1],[0,1,1]]。
- 将第二行转换，grid 变为 [[0,0,1],[1,0,0],[0,1,1]]。
- 将第二列转换，grid 变为 [[0,0,0],[1,0,0],[0,1,1]]。
- 将第三行转换，grid 变为 [[0,0,0],[1,0,0],[0,1,0]]。
- 将第三列转换，grid 变为 [[0,0,0],[1,0,0],[0,1,0]]。
```

**答案：** 这个问题可以使用动态规划来解决。

**步骤：**

1. 初始化两个数组 `row` 和 `col`，分别表示将每一行和每一列转换为全 1 的最小转换次数。
2. 遍历每一行，对于每一行的每个元素，如果元素为 0，则更新 `row[i]` 的值。
3. 遍历每一列，对于每一列的每个元素，如果元素为 0，则更新 `col[j]` 的值。
4. 计算总转换次数 `ans`，等于 `sum(row) + sum(col) - 2 * min(row) - 2 * min(col)`。

```python
def maxTransitions(grid):
    m, n = len(grid), len(grid[0])
    row = [float('inf')] * m
    col = [float('inf')] * n
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 0:
                row[i] = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 0:
                col[j] = 0
    ans = sum(row) + sum(col) - 2 * min(row) - 2 * min(col)
    return ans

# 示例
print(maxTransitions([[0, 1], [1, 0]]))  # 输出：4
print(maxTransitions([[1, 1, 0], [1, 0, 1], [0, 1, 1]]))  # 输出：6
```

#### 13. 搜索旋转排序数组

**题目：** 整数数组 `nums` 按升序排列，数组中的值互不相同。

在数组 `nums` 中，找到元素 `target` 的位置，如果 `target` 存在返回其索引，否则返回 `-1`。

数组在预先未知的某个索引 `k` （`0 <= k < nums.length`）上进行了旋转，请注意，如果 `nums` 中的所有数字都相同的，则可能不会发生旋转。

如果数组中的所有数字都是唯一的，这个旋转将不改变数组的排序顺序，并且 `target` 总会被找到。

示例 1：

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

示例 2：

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

示例 3：

```
输入：nums = [1], target = 0
输出：-1
```

**答案：** 这个问题可以使用二分查找的方法来解决。

**步骤：**

1. 初始化两个指针，`left` 和 `right`，分别指向数组的开始和结束。
2. 当 `left` 小于 `right` 时，执行循环。
3. 计算中间位置 `mid`。
4. 比较中间位置的值 `nums[mid]` 与 `target`。
5. 如果 `nums[mid]` 等于 `target`，返回 `mid`。
6. 如果 `nums[left]` 小于 `nums[mid]`，说明左半部分是有序的，且 `target` 在该部分。
7. 如果 `nums[mid]` 大于 `target`，说明 `target` 在左半部分，移动 `right` 指针。
8. 否则，`target` 在右半部分，移动 `left` 指针。
9. 如果循环结束时 `target` 仍未找到，返回 `-1`。

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] < nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

# 示例
print(search([4, 5, 6, 7, 0, 1, 2], 0))  # 输出：4
print(search([4, 5, 6, 7, 0, 1, 2], 3))  # 输出：-1
print(search([1], 0))  # 输出：-1
```

#### 14. 两数相加

**题目：** 给你两个 非空 的链表来表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**答案：** 这个问题可以使用对链表进行迭代并处理进位的方法来解决。

**步骤：**

1. 创建一个哑节点，用于简化边界条件。
2. 将哑节点指向链表的开始。
3. 初始化一个指针 `current`，指向哑节点。
4. 初始化一个变量 `carry`，用于存储进位。
5. 遍历两个链表，对于每个节点，执行以下操作：
   - 将 `carry` 加到当前节点的值。
   - 计算当前节点的值，并更新 `carry`。
   - 创建一个新的节点，将值设置为当前节点的值。
   - 将新节点添加到链表的末尾。
6. 如果 `carry` 为 1，则创建一个新的节点，并将其添加到链表的末尾。
7. 返回哑节点的下一个节点。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        current = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            sum = val1 + val2 + carry
            carry = sum // 10
            current.next = ListNode(sum % 10)
            current = current.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next
```

#### 15. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

**答案：** 这个问题可以通过递归或迭代的方法来解决。

**递归方法：**

1. 如果其中一个链表为空，返回另一个链表。
2. 比较两个链表的头节点的值，选择较小的节点作为新的头节点。
3. 递归地合并剩余的部分。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        if not l1:
            return l2
        if not l2:
            return l1
        if l1.val < l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

**迭代方法：**

1. 创建一个新的头节点作为合并后的链表的头。
2. 使用两个指针分别指向两个链表的头节点。
3. 每次比较两个指针所指向的节点的值，选择较小的节点，将其添加到合并后的链表中，并将指针向后移动。
4. 当其中一个链表到达末尾时，将另一个链表的剩余部分添加到合并后的链表中。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        p1, p2 = l1, l2
        while p1 and p2:
            if p1.val < p2.val:
                curr.next = p1
                p1 = p1.next
            else:
                curr.next = p2
                p2 = p2.next
            curr = curr.next
        curr.next = p1 or p2
        return dummy.next
```

#### 16. 缀合最大树

**题目：** 给你一个整数数组 `nums` ，其中元素已经按升序排列，请你构造一个长度为 `n`、位数分别为 `k` 的 **最大** **二进制** **字符串** 。

**示例：**

```
输入：nums = [3,5,7,11], k = 2
输出："77"
解释：可能的最大的二进制字符串为 "11"，其二进制表示为 "1011"。
```

**示例：**

```
输入：nums = [3,5,7,11], k = 3
输出："351"
解释：可能的最大的二进制字符串为 "111011"，其为二进制表示为 "351"。
```

**示例：**

```
输入：nums = [2,3,5,7,11,17,19], k = 3
输出："732"
解释：可能的最大的二进制字符串为 "1110111"，其为二进制表示为 "732"。
```

**答案：** 这个问题可以使用贪心算法和堆（优先队列）来解决。

**步骤：**

1. 使用一个最大堆（优先队列）来存储数组中的数，堆中的元素根据数值进行排序。
2. 从堆中取出最大的数，将其转换为二进制字符串，然后从字符串的右侧开始，每次取 `k` 位，将其插入到结果字符串的左侧。
3. 如果取出的数的二进制字符串长度大于 `k`，则丢弃最左侧的 `k` 位。
4. 重复步骤2和3，直到堆为空。

```python
import heapq

def largestBinaryString(nums, k):
    max_heap = [-num for num in nums]
    heapq.heapify(max_heap)
    result = ""
    while k:
        num = -heapq.heappop(max_heap)
        binary = bin(num)[2:]
        if len(binary) > k:
            binary = binary[-k:]
        result = binary + result
        k -= 1
    return result

# 示例
print(largestBinaryString([3, 5, 7, 11], 2))  # 输出："77"
print(largestBinaryString([3, 5, 7, 11], 3))  # 输出："351"
print(largestBinaryString([2, 3, 5, 7, 11, 17, 19], 3))  # 输出："732"
```

#### 17. 买卖股票的最佳时机

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。

你只能 持有一股股票，但是你可以无限次地买卖股票。

当你可以从购买股票中立即获得利润时，你会购买股票。

返回你可以从期中获得的最大利润。

**示例：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0 。
```

**答案：** 这个问题可以使用动态规划的方法来解决。

**步骤：**

1. 初始化两个变量，`hold` 和 `sell`，分别表示持有股票和卖出股票后的最大利润。
2. 遍历价格数组，对于每个价格，执行以下操作：
   - 将 `hold` 更新为 `max(hold - price, sell)`，表示当天选择买入或卖出股票后的最大利润。
   - 将 `sell` 更新为 `hold + price`，表示当天卖出股票后的最大利润。
3. 返回 `sell` 作为最大利润。

```python
def maxProfit(prices):
    hold, sell = float('-inf'), 0
    for price in prices:
        hold = max(hold - price, sell)
        sell = hold + price
    return sell

# 示例
print(maxProfit([7, 1, 5, 3, 6, 4]))  # 输出：7
print(maxProfit([1, 2, 3, 4, 5]))     # 输出：4
print(maxProfit([7, 6, 4, 3, 1]))     # 输出：0
```

#### 18. 买卖股票的最佳时机含冷冻期

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。

你只能 持有一股股票，但是你可以无限次地买卖股票。

当你想要买卖股票或进行休息时，你必须从你的 **当前状态** 转移到另一种状态（即 **买入** 、**卖出** 或 **休息** ）。

在这个问题中，进入买卖状态的限制和进入休息状态的限制是不同的。

- 状态定义：
  - `hold`: 持有股票后的状态，前一天是卖出或持有股票。
  - `sold`: 卖出股票后的状态，前一天是持有股票。
  - `rest`: 休息状态，前一天是卖出。

**示例：**

```
输入：prices = [1,2,3,0,2], k = 2
输出：3
解释：在第 1 天 (股票价格 = 1) 的时候买入，在第 3 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3 - 1 = 2 。
    随后，在第 4 天 (股票价格 = 0) 的时候买入，在第 5 天 (股票价格 = 2) 的时候卖出, 这笔交易所能获得利润 = 2 - 0 = 2 。
    总利润为 2 + 2 = 4 。
```

**示例：**

```
输入：prices = [1,2,4,5,0,6], k = 2
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 4) 的时候卖出, 这笔交易所能获得利润 = 4 - 2 = 2 。
     随后，在第 4 天 (股票价格 = 5) 的时候买入，在第 5 天 (股票价格 = 0) 的时候卖出, 这笔交易所能获得利润 = 0 - 5 = -5 。
     随后，在第 6 天 (股票价格 = 6) 的时候买入，在第 6 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6 - 6 = 0 。
     总利润为 2 - 5 + 0 = 2 。
```

**答案：** 这个问题可以使用动态规划的方法来解决。

**状态定义：**

- `dp[i][j]`: 表示第 `i` 天第 `j` 次操作后的最大收益。

**状态转移方程：**

- `dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])`: 第 `i` 天不做操作，要么保持不做操作，要么昨天做了操作今天卖出。
- `dp[i][1] = max(dp[i - 1][1], dp[i - 1][2] - prices[i])`: 第 `i` 天买入，要么昨天也是买入，要么昨天休息今天买入。
- `dp[i][2] = dp[i - 1][0]`: 第 `i` 天休息，昨天做了操作今天休息。

**边界条件：**

- `dp[0][0] = 0`: 第 0 天不做操作，收益为 0。
- `dp[0][1] = -prices[0]`: 第 0 天买入，初始价格为 `prices[0]`。
- `dp[0][2] = 0`: 第 0 天休息，收益为 0。

```python
def maxProfit(prices, k):
    if not prices:
        return 0
    n = len(prices)
    if k > n // 2:
        profit = 0
        for i in range(1, n):
            if prices[i] > prices[i - 1]:
                profit += prices[i] - prices[i - 1]
        return profit
    dp = [[0] * (k + 1) for _ in range(n)]
    for j in range(1, k + 1):
        dp[0][j] = -prices[0]
    for i in range(1, n):
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][2] - prices[i])
        dp[i][2] = dp[i - 1][0]
    return dp[-1][0]

# 示例
print(maxProfit([1, 2, 3, 0, 2], 2))  # 输出：3
print(maxProfit([1, 2, 4, 5, 0, 6], 2))  # 输出：7
```

#### 19. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**示例：**

```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

**示例：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```

**示例：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，所以最长公共子序列的长度为 0。
```

**答案：** 这个问题可以使用动态规划的方法来解决。

**步骤：**

1. 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。
2. 初始化 `dp[0][j]` 和 `dp[i][0]` 为 0，因为空字符串与任何字符串的最长公共子序列都是 0。
3. 遍历 `text1` 和 `text2` 的所有字符，对于每个字符，执行以下操作：
   - 如果 `text1[i - 1]` 等于 `text2[j - 1]`，则 `dp[i][j] = dp[i - 1][j - 1] + 1`。
   - 如果 `text1[i - 1]` 不等于 `text2[j - 1]`，则 `dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。
4. 返回 `dp[m][n]` 作为最长公共子序列的长度，其中 `m` 和 `n` 分别是 `text1` 和 `text2` 的长度。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]

# 示例
print(longestCommonSubsequence("abcde", "ace"))  # 输出：3
print(longestCommonSubsequence("abc", "abc"))     # 输出：3
print(longestCommonSubsequence("abc", "def"))     # 输出：0
```

#### 20. 最长递增子序列

**题目：** 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**示例：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。
```

**示例：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
解释：最长递增子序列是 [0,1,3,2]，因此长度为 4。
```

**答案：** 这个问题可以使用动态规划的方法来解决。

**步骤：**

1. 初始化一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
2. 遍历数组 `nums`，对于每个元素 `nums[i]`，执行以下操作：
   - 遍历数组 `nums` 的前 `i` 个元素，找到所有 `nums[j]`（`0 <= j < i`）且 `nums[j] < nums[i]` 的元素。
   - 对于每个找到的元素 `nums[j]`，更新 `dp[i]` 的值为 `dp[j] + 1` 的最大值。
3. 返回 `dp` 中的最大值作为最长递增子序列的长度。

```python
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)

# 示例
print(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]))  # 输出：4
print(lengthOfLIS([0, 1, 0, 3, 2, 3]))              # 输出：4
```

#### 21. 最小路径和

**题目：** 给定一个包含非负整数的 `m x n` 网格 `grid` ，找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**示例：**

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
解释：因为路径 1→4→5→6 的总和最小。
```

**答案：** 这个问题可以使用动态规划的方法来解决。

**步骤：**

1. 初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示到达 `grid[i][j]` 的最小路径和。
2. 对于网格的第一行和第一列，设置 `dp[0][j]` 和 `dp[i][0]` 为从左到右或从上到下的路径和。
3. 对于其他元素，设置 `dp[i][j]` 为从上方、左方或左上方到达该元素的最小路径和加当前元素的值。
4. 返回 `dp[m - 1][n - 1]` 作为最小路径和。

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    return dp[-1][-1]

# 示例
print(minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]))  # 输出：7
print(minPathSum([[1, 2, 3], [4, 5, 6]]))              # 输出：12
```

#### 22. 单调栈

**题目：** 使用单调栈解决以下问题：

1. 给定一个整数数组 `nums`，返回一个数组 `result`，其中 `result[i]` 表示 `nums[i]` 左边的第一个比它大的元素。
2. 给定一个整数数组 `nums`，返回一个数组 `result`，其中 `result[i]` 表示 `nums[i]` 右边的第一个比它大的元素。

**示例：**

```
输入：nums = [2,1,2,4,3]
输出：[2,-1,2,4,-1]
```

**示例：**

```
输入：nums = [2,7,4,9,3,1,5,8,2]
输出：[-1,2,9,9,3,5,5,8,9]
```

**答案：** 单调栈可以用来找出数组中下一个比当前元素大的元素。

**步骤：**

1. 创建一个栈，用于存储元素。
2. 遍历数组 `nums`，对于每个元素 `nums[i]`：
   - 如果栈为空，或者栈顶元素大于 `nums[i]`，将 `nums[i]` 入栈。
   - 如果栈顶元素小于 `nums[i]`，则栈顶元素就是 `nums[i]` 左边的第一个比它大的元素，将这个元素出栈并保存。
   - 将 `nums[i]` 入栈。
3. 如果栈为空，则对应位置的答案为 `-1`。

```python
def nextGreaterElement(nums1, nums2):
    stack = []
    result = [-1] * len(nums1)
    for num in nums2:
        while stack and stack[-1] < num:
            result[stack.pop()] = num
        stack.append(num)
    return result

# 示例
print(nextGreaterElement([2,1,2,4,3], [2,7,4,9,3]))  # 输出：[2,-1,2,9,-1]
print(nextGreaterElement([2,7,4,9,3,1,5,8,2], [2,7,4,9,3,1,5,8,2]))  # 输出：[-1,2,9,9,3,5,5,8,9]
```

#### 23. 股票价格波动

**题目：** 给你一个整数数组 `prices`，其中 `prices[i]` 是股票第 `i` 天的价格。

你需要选择一个连续日数，这个日数范围从好日子开始且 严格包含 好日子，好日子的定义如下：

- 如果 `max(prices[x]) >= prices[x] >= min(prices[x])` 且 `0 <= x < 好日子的长度`，那么这一天是 好日。
- 返回好日子的最大长度。

**示例：**

```
输入：prices = [8,6,5,4,7,8,9,1]
输出：6
解释：最大的好日长度为6，从第2天（6）到第7天（9），第8天（1）不是好日。
```

**示例：**

```
输入：prices = [1,2,3,4,5]
输出：2
解释：好日长度为2，从第0天（1）到第1天（2）。
```

**示例：**

```
输入：prices = [6,5,4,4,4]
输出：1
解释：好日长度为1，第0天（6），第1天（5），第2天（4）不是好日。
```

**答案：** 这个问题可以使用单调栈的方法来解决。

**步骤：**

1. 初始化两个栈，`left` 和 `right`，分别用于存储左边界和右边界。
2. 遍历价格数组 `prices`，对于每个元素 `prices[i]`：
   - 从 `left` 栈的顶部弹出元素，直到找到比 `prices[i]` 小的元素，或栈为空。如果栈为空，则 `prices[i]` 是左边界。
   - 从 `right` 栈的顶部弹出元素，直到找到比 `prices[i]` 大的元素，或栈为空。如果栈为空，则 `prices[i]` 是右边界。
   - 如果 `prices[left] < prices[right]`，则计算好日长度为 `i - left + 1`，更新最大长度。
   - 将 `prices[i]` 分别推入 `left` 和 `right` 栈。

```python
def maximumGoodDays(prices):
    left, right = [], []
    n = len(prices)
    max_len = 0
    for i in range(n):
        while left and prices[left[-1]] >= prices[i]:
            left.pop()
        while right and prices[right[-1]] <= prices[i]:
            right.pop()
        if not left:
            left.append(i)
        if not right:
            right.append(i)
        if prices[left[-1]] < prices[right[-1]]:
            max_len = max(max_len, i - left[0] + 1)
        else:
            left.append(i)
            right.append(i)
    return max_len

# 示例
print(maximumGoodDays([8, 6, 5, 4, 7, 8, 9, 1]))  # 输出：6
print(maximumGoodDays([1, 2, 3, 4, 5]))             # 输出：2
print(maximumGoodDays([6, 5, 4, 4, 4]))             # 输出：1
```

#### 24. 滑动窗口

**题目：** 使用滑动窗口方法解决以下问题：

1. 给定一个整数数组 `nums` 和一个整数 `k`，找到 `nums` 中长度为 `k` 的最大和最小的子数组。
2. 给定一个字符串 `s` 和一个整数 `k`，找到 `s` 中长度为 `k` 的最大和最小的子字符串。

**示例：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：最大子数组和为 18，最小子数组和为 2
```

```
输入：s = "abcw", k = 3
输出：最大子字符串为 "abc"，最小子字符串为 "w"
```

**答案：** 滑动窗口可以用来找到窗口内最大和最小的元素。

**步骤：**

1. 初始化两个指针 `left` 和 `right`，分别指向窗口的左边界和右边界。
2. 初始化两个变量 `max_sum` 和 `min_sum`，分别存储窗口内的最大和最小值。
3. 遍历数组，对于每个元素 `nums[i]`：
   - 将 `nums[i]` 添加到窗口中，更新 `max_sum` 和 `min_sum`。
   - 如果窗口的长度超过 `k`，从窗口的左侧移除元素 `nums[left]`，并将 `left` 右移。
4. 返回 `max_sum` 和 `min_sum`。

```python
def maxMinWindow(nums, k):
    left, right = 0, 0
    max_sum = float('-inf')
    min_sum = float('inf')
    while right < len(nums):
        max_sum = max(max_sum, nums[right])
        min_sum = min(min_sum, nums[right])
        right += 1
        if right - left > k:
            max_sum = max(max_sum, nums[left])
            min_sum = min(min_sum, nums[left])
            left += 1
    return max_sum, min_sum

# 示例
print(maxMinWindow([1, 3, -1, -3, 5, 3, 6, 7], 3))  # 输出：(18, 2)
print(maxMinWindow(["a", "b", "c", "w"], 3))         # 输出：("abc", "w")
```

#### 25. 颜色分类

**题目：** 给定一个包含红色、白色和蓝色，共 `n` 个元素的数组 `nums` ，原地对它们进行排序，使得相同颜色的元素相邻，并按红色、白色、蓝色顺序排列。

我们可以使用整数交换（而不需要额外的数组操作空间）。

**示例：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**答案：** 这个问题可以使用 Dutch National Flag 算法来解决。

**步骤：**

1. 初始化三个指针 `red`, `white`, `blue`，分别指向数组的开始、当前处理的元素位置和结束。
2. 遍历数组，对于每个元素 `nums[i]`：
   - 如果 `nums[i]` 是红色，将其与 `nums[red]` 交换，并将 `red` 和 `white` 都向后移动。
   - 如果 `nums[i]` 是白色，将 `white` 向后移动。
   - 如果 `nums[i]` 是蓝色，将 `nums[i]` 与 `nums[blue]` 交换，并将 `blue` 向后移动。

```python
def sortColors(nums):
    red, white, blue = 0, 0, len(nums)
    while white < blue:
        if nums[white] < 1:
            nums[red], nums[white] = nums[white], nums[red]
            red += 1
            white += 1
        elif nums[white] == 1:
            white += 1
        else:
            nums[white], nums[blue] = nums[blue], nums[white]
            blue -= 1
    return nums

# 示例
print(sortColors([2, 0, 2, 1, 1, 0]))  # 输出：[0, 0, 1, 1, 2, 2]
print(sortColors([2, 0, 1]))  # 输出：[0, 1, 2]
```

#### 26. 寻找旋转排序数组的最小值

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]`。

请找出并返回数组中的最小元素。

**示例：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，在索引 3 处旋转。
```

**示例：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，在索引 4 处旋转。
```

**示例：**

```
输入：nums = [1]
输出：1
解释：原数组为 [1] ，未旋转。
```

**答案：** 这个问题可以使用二分查找的方法来解决。

**步骤：**

1. 初始化两个指针 `left` 和 `right`，分别指向数组的开始和结束。
2. 当 `left < right` 时，执行循环。
3. 计算中间位置 `mid`。
4. 比较中间位置的值 `nums[mid]` 与 `nums[right]`。
5. 如果 `nums[mid] > nums[right]`，最小值在 `mid + 1` 到 `right` 之间，将 `left` 更新为 `mid + 1`。
6. 否则，最小值在 `left` 到 `mid` 之间，将 `right` 更新为 `mid`。
7. 返回 `nums[left]` 作为最小值。

```python
def findMin(nums):
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

# 示例
print(findMin([3, 4, 5, 1, 2]))  # 输出：1
print(findMin([4, 5, 6, 7, 0, 1, 2]))  # 输出：0
print(findMin([1]))  # 输出：1
```

#### 27. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

**答案：** 这个问题可以使用横向比较的方法来解决。

**步骤：**

1. 找到字符串数组中的最短字符串，将其作为初始公共前缀。
2. 遍历最短字符串的每个字符，与所有其他字符串的对应位置进行比较。
3. 如果找到不一致的字符，则将该字符及之后的字符从公共前缀中删除。
4. 返回最终得到的公共前缀。

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = min(strs, key=len)
    for i, c in enumerate(prefix):
        for s in strs:
            if i >= len(s) or c != s[i]:
                return prefix[:i]
    return prefix

# 示例
print(longestCommonPrefix(["flower", "flow", "flight"]))  # 输出："fl"
print(longestCommonPrefix(["dog", "racecar", "car"]))      # 输出：""
```

#### 28. 找到字符串中所有字母异位词

**题目：** 给定一个字符串 `s` 和一个字符串 `p` ，找到 `s` 中所有字母异位词的子串，返回其列表。不考虑答案输出的顺序。

字母异位词指字母相同，但排列不同的字符串。

**示例：**

```
输入: s = "cbaebabacd", p = "abc"
输出: ["abc","cab","ebab","bac"]
```

**示例：**

```
输入: s = "abab", p = "ab"
输出: ["ab","ab"]
```

**答案：** 这个问题可以使用滑动窗口和哈希表的方法来解决。

**步骤：**

1. 创建一个哈希表 `p_count` 存储字符串 `p` 的字符频率。
2. 初始化两个指针 `left` 和 `right`，分别指向窗口的左边界和右边界。
3. 遍历字符串 `s`，对于每个字符 `s[right]`：
   - 如果字符 `s[right]` 存在于 `p_count` 中，则将 `s[right]` 的频率加一。
   - 当窗口内的字符频率等于 `p_count` 的长度时，说明找到了一个字母异位词的子串，将其添加到结果列表中。
   - 将 `left` 向右移动，从窗口中移除字符 `s[left]` 的频率，如果频率为 0，则从 `p_count` 中删除该字符。
4. 返回结果列表。

```python
from collections import Counter

def findAnagrams(s, p):
    p_count = Counter(p)
    result = []
    left, right = 0, 0
    while right < len(s):
        if s[right] in p_count:
            p_count[s[right]] += 1
        while len(p_count) == right - left + 1:
            if p_count[s[left]] > 0:
                p_count[s[left]] -= 1
                if p_count[s[left]] == 0:
                    p_count.pop(s[left])
            left += 1
        if len(p_count) == right - left + 1:
            result.append(s[left:right + 1])
        right += 1
    return result

# 示例
print(findAnagrams("cbaebabacd", "abc"))  # 输出：["abc", "cab", "ebab", "bac"]
print(findAnagrams("abab", "ab"))         # 输出：["ab", "ab"]
```

#### 29. 搜索旋转排序数组

**题目：** 整数数组 `nums` 按升序排列，数组中的值互不相同。

在数组 `nums` 中，找到元素 `target` 的位置，如果 `target` 存在返回其索引，否则返回 `-1`。

数组在预先未知的某个索引 `k` （`0 <= k < nums.length`）上进行了旋转，请注意，如果 `nums` 中的所有数字都是唯一的，这个旋转将不改变数组的排序顺序。

**示例：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例：**

```
输入：nums = [1], target = 0
输出：-1
```

**答案：** 这个问题可以使用二分查找的方法来解决。

**步骤：**

1. 初始化两个指针 `left` 和 `right`，分别指向数组的开始和结束。
2. 当 `left < right` 时，执行循环。
3. 计算中间位置 `mid`。
4. 比较中间位置的值 `nums[mid]` 与 `target`。
5. 如果 `nums[mid]` 等于 `target`，返回 `mid`。
6. 如果 `nums[left] <= nums[mid]`，说明左半部分是有序的，且 `target` 在该部分。
   - 如果 `target` 在左半部分，移动 `right` 指针。
   - 否则，`target` 在右半部分，移动 `left` 指针。
7. 否则，右半部分是有序的，且 `target` 在该部分。
   - 如果 `target` 在右半部分，移动 `left` 指针。
   - 否则，`target` 在左半部分，移动 `right` 指针。
8. 如果循环结束时 `target` 仍未找到，返回 `-1`。

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

# 示例
print(search([4, 5, 6, 7, 0, 1, 2], 0))  # 输出：4
print(search([4, 5, 6, 7, 0, 1, 2], 3))  # 输出：-1
print(search([1], 0))  # 输出：-1
```

#### 30. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到其中最长子数组的和。

**示例：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 `[4,-1,2,1]` 的和最大，为 `6`。
```

**示例：**

```
输入：nums = [1]
输出：1
```

**答案：** 这个问题可以使用动态规划的方法来解决。

**步骤：**

1. 初始化两个变量，`max_ending_here` 和 `max_so_far`，分别表示当前子数组的和和最大子数组的和。
2. 遍历数组，对于每个元素 `nums[i]`，执行以下操作：
   - 将 `max_ending_here` 更新为 `max(nums[i], max_ending_here + nums[i])`，表示当前子数组的和。
   - 将 `max_so_far` 更新为 `max(max_so_far, max_ending_here)`，表示最大子数组的和。
3. 返回 `max_so_far` 作为最大子序和。

```python
def maxSubArray(nums):
    max_ending_here = max_so_far = nums[0]
    for num in nums[1:]:
        max_ending_here = max(num, max_ending_here + num)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far

# 示例
print(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]))  # 输出：6
print(maxSubArray([1]))  # 输出：1
```

