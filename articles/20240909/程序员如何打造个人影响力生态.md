                 

### æ ‡é¢˜

ã€Šç¨‹åºå‘˜å¦‚ä½•æž„å»ºä¸ªäººå½±å“åŠ›ç”Ÿæ€ï¼šé¢è¯•é¢˜ä¸Žç®—æ³•ç¼–ç¨‹æŒ‘æˆ˜è¯¦è§£ã€‹

---

#### é¢è¯•é¢˜åº“ä¸Žç­”æ¡ˆè§£æž

### 1. å­—ç¬¦ä¸²å¤„ç†

**é¢˜ç›®ï¼š** å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå›žæ–‡ã€‚

**ç­”æ¡ˆï¼š** 

```python
def is_palindrome(s: str) -> bool:
    return s == s[::-1]
```

**è§£æžï¼š** åˆ©ç”¨ Python çš„åˆ‡ç‰‡æ“ä½œï¼Œå°†å­—ç¬¦ä¸²åè½¬å¹¶ä¸ŽåŽŸå­—ç¬¦ä¸²æ¯”è¾ƒï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå›žæ–‡ã€‚

---

### 2. æ•°æ®ç»“æž„

**é¢˜ç›®ï¼š** å®žçŽ°ä¸€ä¸ªæ ˆæ•°æ®ç»“æž„ï¼Œæ”¯æŒåŸºæœ¬çš„å…¥æ ˆã€å‡ºæ ˆã€æŸ¥çœ‹æ ˆé¡¶å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š**

```python
class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None

    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None

    def is_empty(self):
        return len(self.items) == 0
```

**è§£æžï¼š** ä½¿ç”¨åˆ—è¡¨æ¥å®žçŽ°æ ˆçš„åŸºæœ¬æ“ä½œã€‚

---

### 3. ç®—æ³•ä¸Žæ•°æ®ç»“æž„

**é¢˜ç›®ï¼š** å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼ŒæŸ¥æ‰¾æ•°ç»„ä¸­çš„ç¬¬ k ä¸ªæœ€å¤§å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š**

```python
def find_kth_largest(nums: List[int], k: int) -> int:
    nums.sort(reverse=True)
    return nums[k - 1]
```

**è§£æžï¼š** å¯¹æ•°ç»„è¿›è¡ŒæŽ’åºï¼Œç„¶åŽè¿”å›žç¬¬ k ä¸ªæœ€å¤§å…ƒç´ ã€‚

---

#### ç®—æ³•ç¼–ç¨‹é¢˜åº“ä¸Žç­”æ¡ˆè§£æž

### 1. æ•°ç»„

**é¢˜ç›®ï¼š** ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œæ‰¾å‡ºæ‰€æœ‰å‡ºçŽ°æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦ä¸€åŠçš„å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š**

```python
def majority_element(nums):
    count = 0
    candidate = None
    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    return candidate
```

**è§£æžï¼š** åˆ©ç”¨æ‘©å°”æŠ•ç¥¨ç®—æ³•ï¼Œæ‰¾åˆ°è¶…è¿‡ä¸€åŠæ•°é‡çš„å…ƒç´ ã€‚

---

### 2. é“¾è¡¨

**é¢˜ç›®ï¼š** åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ã€‚

**ç­”æ¡ˆï¼š**

```python
def remove_nth_from_end(head, n):
    dummy = ListNode(0)
    dummy.next = head
    slow = fast = dummy
    for _ in range(n + 1):
        fast = fast.next
    while fast:
        slow = slow.next
        fast = fast.next
    slow.next = slow.next.next
    return dummy.next
```

**è§£æžï¼š** ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆå…ˆèµ° n æ­¥ï¼Œç„¶åŽæ…¢æŒ‡é’ˆå’Œå¿«æŒ‡é’ˆåŒæ—¶å‰è¿›ï¼Œç›´åˆ°å¿«æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨æœ«å°¾ï¼Œæ­¤æ—¶æ…¢æŒ‡é’ˆæ‰€æŒ‡èŠ‚ç‚¹å³ä¸ºå€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ã€‚

---

### 3. å›¾

**é¢˜ç›®ï¼š** æœ€çŸ­è·¯å¾„é—®é¢˜ï¼šç»™å®šä¸€ä¸ªåŠ æƒæ— å‘å›¾ï¼Œæ±‚å›¾ä¸­ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ã€‚

**ç­”æ¡ˆï¼š**

```python
import heapq

def shortest_path(graph, start, end):
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        if current_node == end:
            return current_distance

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight

            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return None
```

**è§£æžï¼š** ä½¿ç”¨ Dijkstra ç®—æ³•æ±‚è§£æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œåˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰æ¥é€‰æ‹©ä¸‹ä¸€ä¸ªè®¿é—®çš„èŠ‚ç‚¹ã€‚

---

é€šè¿‡è§£å†³è¿™äº›é¢è¯•é¢˜å’Œç®—æ³•ç¼–ç¨‹é¢˜ï¼Œç¨‹åºå‘˜å¯ä»¥æ›´å¥½åœ°ç†è§£æ•°æ®ç»“æž„å’Œç®—æ³•çš„åŸºæœ¬åŽŸç†ï¼ŒåŒæ—¶ä¹Ÿèƒ½å¤Ÿæé«˜è‡ªå·±åœ¨å®žé™…ç¼–ç¨‹ä¸­çš„é—®é¢˜è§£å†³èƒ½åŠ›ã€‚åœ¨æ‰“é€ ä¸ªäººå½±å“åŠ›ç”Ÿæ€çš„è¿‡ç¨‹ä¸­ï¼ŒæŽŒæ¡è¿™äº›æ ¸å¿ƒæŠ€èƒ½æ˜¯è‡³å…³é‡è¦çš„ã€‚å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¤Ÿå¸®åŠ©åˆ°ä½ ã€‚å¦‚æžœä½ æœ‰ä»»ä½•ç–‘é—®ï¼Œæ¬¢è¿Žåœ¨è¯„è®ºåŒºç•™è¨€è®¨è®ºã€‚è®©æˆ‘ä»¬ä¸€èµ·è¿›æ­¥ï¼Œå…±åŒæˆé•¿ï¼ðŸš€

### ç»“è¯­

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ·±å…¥æŽ¢è®¨äº†ç¨‹åºå‘˜å¦‚ä½•é€šè¿‡è§£å†³é¢è¯•é¢˜å’Œç®—æ³•ç¼–ç¨‹é¢˜æ¥æ‰“é€ ä¸ªäººå½±å“åŠ›ç”Ÿæ€ã€‚é€šè¿‡è§£å†³è¿™äº›é—®é¢˜ï¼Œç¨‹åºå‘˜ä¸ä»…èƒ½å¤Ÿæå‡è‡ªå·±çš„æŠ€æœ¯æ°´å¹³ï¼Œè¿˜èƒ½å¤Ÿå‘ä»–äººå±•ç¤ºè‡ªå·±çš„è§£å†³é—®é¢˜çš„èƒ½åŠ›ã€‚

åœ¨è§£å†³è¿™äº›é—®é¢˜çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† Python ä½œä¸ºç¤ºä¾‹è¯­è¨€ï¼Œæä¾›äº†è¯¦å°½çš„ä»£ç è§£é‡Šå’Œç­”æ¡ˆè§£æžã€‚ç„¶è€Œï¼Œè¿™äº›æ¦‚å¿µå’Œç®—æ³•æ˜¯é€šç”¨çš„ï¼Œæ— è®ºä½¿ç”¨å“ªç§ç¼–ç¨‹è¯­è¨€ï¼Œå…¶æ ¸å¿ƒæ€æƒ³éƒ½æ˜¯ä¸€è‡´çš„ã€‚

åœ¨å‡†å¤‡é¢è¯•æˆ–ç¼–å†™ç®—æ³•ç¼–ç¨‹é¢˜æ—¶ï¼Œä»¥ä¸‹å‡ ç‚¹å»ºè®®å¯èƒ½ä¼šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š

1. **ç†è§£åŸºæœ¬æ¦‚å¿µ**ï¼šç¡®ä¿ä½ æ·±å…¥ç†è§£åŸºæœ¬çš„æ•°æ®ç»“æž„å’Œç®—æ³•ï¼Œå¦‚æ•°ç»„ã€é“¾è¡¨ã€æ ˆã€é˜Ÿåˆ—ã€æŽ’åºç®—æ³•ç­‰ã€‚
2. **åŠ¨æ‰‹å®žè·µ**ï¼šé€šè¿‡å®žé™…ç¼–å†™ä»£ç æ¥è§£å†³é¢˜ç›®ï¼Œè€Œä¸æ˜¯ä»…ä»…ä¾èµ–ç†è®ºã€‚
3. **ä¼˜åŒ–ä»£ç **ï¼šå°è¯•ä¼˜åŒ–ä½ çš„ä»£ç ï¼Œæé«˜å…¶æ€§èƒ½å’Œå¯è¯»æ€§ã€‚
4. **é˜…è¯»ä»–äººä»£ç **ï¼šç ”ç©¶å…¶ä»–äººçš„è§£å†³æ–¹æ¡ˆï¼Œå­¦ä¹ ä¸åŒçš„ç¼–ç¨‹é£Žæ ¼å’Œä¼˜åŒ–æŠ€å·§ã€‚
5. **æŒç»­å­¦ä¹ **ï¼šæŠ€æœ¯é¢†åŸŸæ—¥æ–°æœˆå¼‚ï¼ŒæŒç»­å­¦ä¹ å’Œé€‚åº”æ–°çš„æŠ€æœ¯å’Œå·¥å…·æ˜¯éžå¸¸é‡è¦çš„ã€‚

æœ€åŽï¼Œæˆ‘å¸Œæœ›è¿™ç¯‡æ–‡ç« èƒ½å¤Ÿä¸ºä½ æä¾›ä¸€äº›å¯å‘å’Œå¸®åŠ©ã€‚å¦‚æžœä½ åœ¨è§£å†³é¢è¯•é¢˜æˆ–ç®—æ³•ç¼–ç¨‹é¢˜çš„è¿‡ç¨‹ä¸­é‡åˆ°äº†å›°éš¾ï¼Œæˆ–è€…æœ‰ä»»ä½•ç–‘é—®ï¼Œè¯·éšæ—¶åœ¨è¯„è®ºåŒºç•™è¨€ã€‚è®©æˆ‘ä»¬ä¸€èµ·å­¦ä¹ ï¼Œå…±åŒè¿›æ­¥ï¼

æ„Ÿè°¢ä½ çš„é˜…è¯»ï¼Œç¥ä½ åœ¨ç¼–ç¨‹çš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œï¼Œæˆä¸ºé¢†åŸŸå†…çš„ä½¼ä½¼è€…ï¼ðŸŒŸðŸŒŸðŸŒŸ

