                 

### 1. 算法题：寻找两数组的交集

#### **题目描述：** 给定两个整数数组 `nums1` 和 `nums2` ，返回 `nums1` 和 `nums2` 的交集。输出结果中的每个元素一定是唯一的。我们可以不考虑输出结果的顺序。

#### **示例：**
```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

#### **示例：**
```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

#### **答案解析：** 

这道题目可以通过哈希表来高效地解决。以下是一种简单的实现方式：

```go
func intersection(nums1 []int, nums2 []int) []int {
    // 创建一个哈希表来存储数组 nums1 的元素
    hashTable := map[int]bool{}
    for _, num := range nums1 {
        hashTable[num] = true
    }

    // 创建一个切片来存储交集结果
    var result []int
    for _, num := range nums2 {
        // 如果哈希表中存在当前元素，且之前没有添加到结果中，则添加到结果中
        if _, exist := hashTable[num]; exist {
            result = append(result, num)
            // 从哈希表中删除，确保每个元素只添加一次
            delete(hashTable, num)
        }
    }
    return result
}
```

#### **解析：**

1. **哈希表创建与填充：** 遍历数组 `nums1`，将每个元素作为键存入哈希表 `hashTable` 中。
2. **交集结果收集：** 遍历数组 `nums2`，如果当前元素在哈希表中存在，并且之前没有添加到结果中，则将其添加到结果切片 `result` 中，并从哈希表中删除该元素，以确保每个元素只被添加一次。
3. **返回结果：** 最终返回结果切片 `result`。

这种方法的时间复杂度为 O(n+m)，其中 n 和 m 分别为数组 `nums1` 和 `nums2` 的长度。空间复杂度为 O(n)，用于存储哈希表。

#### **完整代码：**

```go
func intersection(nums1 []int, nums2 []int) []int {
    hashTable := map[int]bool{}
    result := []int{}

    for _, num := range nums1 {
        hashTable[num] = true
    }

    for _, num := range nums2 {
        if _, exist := hashTable[num]; exist {
            result = append(result, num)
            delete(hashTable, num)
        }
    }

    return result
}
```

### 2. 面试题：实现二叉树的层序遍历

#### **题目描述：** 给你一个二叉树，请你返回其按层序遍历的结果。即逐层地，从左到右访问所有节点。

#### **示例：**
```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

#### **示例：**
```
输入：root = [1]
输出：[[1]]
```

#### **示例：**
```
输入：root = []
输出：[]
```

#### **答案解析：**

我们可以使用广度优先搜索（BFS）来解决这个问题。以下是使用队列实现的层序遍历：

```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        level := []int{}
        nextLevel := []*TreeNode{}

        for _, node := range queue {
            level = append(level, node.Val)

            if node.Left != nil {
                nextLevel = append(nextLevel, node.Left)
            }
            if node.Right != nil {
                nextLevel = append(nextLevel, node.Right)
            }
        }

        result = append(result, level)
        queue = nextLevel
    }

    return result
}
```

#### **解析：**

1. **初始化：** 如果根节点为空，则返回空切片。初始化结果切片 `result` 和队列 `queue`，并将根节点加入队列。
2. **层序遍历：** 当队列不为空时，进行以下操作：
   - 创建当前层节点值切片 `level` 和下一层节点指针切片 `nextLevel`。
   - 遍历当前队列中的每个节点，将其值添加到 `level` 切片中，并检查其左右子节点，如果存在则添加到 `nextLevel` 切片中。
   - 将当前层节点值切片 `level` 添加到结果切片 `result` 中。
   - 将下一层节点指针切片 `nextLevel` 作为新的队列 `queue`。
3. **返回结果：** 最终返回结果切片 `result`。

#### **完整代码：**

```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        level := []int{}
        nextLevel := []*TreeNode{}

        for _, node := range queue {
            level = append(level, node.Val)

            if node.Left != nil {
                nextLevel = append(nextLevel, node.Left)
            }
            if node.Right != nil {
                nextLevel = append(nextLevel, node.Right)
            }
        }

        result = append(result, level)
        queue = nextLevel
    }

    return result
}
```

### 3. 算法题：最大子序和

#### **题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少包含一个数），返回其最大和。

#### **示例：**
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

#### **示例：**
```
输入：nums = [1]
输出：1
```

#### **示例：**
```
输入：nums = [5,4,-1,7,8]
输出：23
```

#### **答案解析：**

这是一个非常经典的问题，通常被称为“最大子序和”。以下是一个简单的动态规划解决方案：

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    maxSum := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }

    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### **解析：**

1. **初始化：** 使用两个变量 `maxSum` 和 `currSum`，分别表示当前最大子序和和当前子序和。初始时，`maxSum` 和 `currSum` 均为 `nums[0]`。
2. **遍历数组：** 从第二个元素开始遍历数组 `nums`，每次更新 `currSum` 为当前元素与 `currSum+当前元素` 中的最大值。
3. **更新最大子序和：** 如果 `currSum` 大于 `maxSum`，则更新 `maxSum`。
4. **返回结果：** 最终返回 `maxSum`。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。

#### **完整代码：**

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    maxSum := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }

    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 4. 面试题：最长公共前缀

#### **题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

#### **示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

#### **示例：**
```
输入：strs = ["dog","racecar","car"]
输出：""
```

#### **答案解析：**

我们可以使用垂直扫描的方法来解决这个问题。以下是实现的代码：

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    // 从第一个字符串开始，逐个比较
    for i, ch := 0, strs[0][0]; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            // 如果当前字符不相等，或者已经越界，返回当前公共前缀
            if i >= len(strs[j]) || ch != strs[j][i] {
                return strs[0][:i]
            }
        }
        ch = strs[0][i]
    }
    return strs[0]
}
```

#### **解析：**

1. **初始化：** 从第一个字符串的字符开始，作为公共前缀的初始字符。
2. **垂直扫描：** 从第一个字符开始，对于每个字符，检查其他字符串是否也具有相同的字符。
3. **返回结果：** 如果所有字符串都至少有一个公共前缀，返回这个公共前缀；否则，返回空字符串。

这种方法的时间复杂度为 O(S)，其中 S 是所有字符串的总长度；空间复杂度为 O(1)。

#### **完整代码：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    for i, ch := 0, strs[0][0]; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || ch != strs[j][i] {
                return strs[0][:i]
            }
        }
        ch = strs[0][i]
    }
    return strs[0]
}
```

### 5. 算法题：两数相加

#### **题目描述：** 给定两个非空链表表示的两个非负整数，每个节点包含一个数字。将这两个数相加并返回一个新的链表。

#### **示例：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,7]
```

#### **示例：**
```
输入：l1 = [0], l2 = [0]
输出：[0]
```

#### **答案解析：**

以下是实现的代码：

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{sum % 10, nil}
        current = current.Next
    }

    return dummy.Next
}
```

#### **解析：**

1. **初始化：** 创建一个哑节点 `dummy`，用于简化节点操作。同时初始化两个指针 `current` 和 `carry`，分别指向当前节点和进位。
2. **遍历两个链表：** 当两个链表中的任一节点不为空或者进位 `carry` 不为 0 时，进行以下操作：
   - 取出两个链表当前节点的值 `val1` 和 `val2`。
   - 计算当前位的和 `sum`。
   - 计算新的进位 `carry`。
   - 创建新的节点，并将和的个位数设置为节点的值。
3. **返回结果：** 返回哑节点的下一个节点，即新的链表的头节点。

这种方法的时间复杂度为 O(max(m, n))，其中 m 和 n 分别为两个链表的长度；空间复杂度为 O(1)。

#### **完整代码：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{sum % 10, nil}
        current = current.Next
    }

    return dummy.Next
}
```

### 6. 算法题：加一

#### **题目描述：** 给定一个由整数组成的非空数组所表示的非负整数，在数组的每个元素前面添加 `0` 来保证其最左边的元素不会消失。返回确保数字正确增一的最终数组。

#### **示例：**
```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

#### **示例：**
```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
```

#### **答案解析：**

以下是实现的代码：

```go
func plusOne(digits []int) []int {
    n := len(digits)
    for i := n - 1; i >= 0; i-- {
        if digits[i] < 9 {
            digits[i]++
            return digits
        }
        digits[i] = 0
    }
    return append([]int{1}, digits...)
}
```

#### **解析：**

1. **从右向左遍历：** 从数组的最后一个元素开始遍历，检查每个元素是否小于 9。
2. **如果当前元素小于 9：** 将当前元素加一，返回结果。
3. **如果当前元素等于 9：** 将当前元素设置为 0，并继续遍历下一个元素。
4. **如果所有元素都等于 9：** 这意味着需要进位到最高位，创建一个新的数组，将 1 添加到新数组的开头，并将原数组作为新数组的剩余部分。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组 `digits` 的长度。

#### **完整代码：**

```go
func plusOne(digits []int) []int {
    n := len(digits)
    for i := n - 1; i >= 0; i-- {
        if digits[i] < 9 {
            digits[i]++
            return digits
        }
        digits[i] = 0
    }
    return append([]int{1}, digits...)
}
```

### 7. 面试题：最长公共子序列

#### **题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

#### **示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace" ，它的长度为 3。
```

#### **示例：**
```
输入：text1 = "abc", text2 = "abc"
输出：3
```

#### **答案解析：**

我们可以使用动态规划来解决这个问题。以下是实现的代码：

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### **解析：**

1. **初始化：** 创建一个二维数组 `dp`，用于存储子问题的解。数组的大小为 `m+1` 和 `n+1`，其中 `m` 和 `n` 分别为 `text1` 和 `text2` 的长度。
2. **动态规划：** 遍历 `text1` 和 `text2` 的每个字符，对于每个字符，根据以下条件更新 `dp` 数组：
   - 如果 `text1[i-1]` 等于 `text2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 如果 `text1[i-1]` 不等于 `text2[j-1]`，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
3. **返回结果：** 返回 `dp[m][n]`，即最长公共子序列的长度。

这种方法的时间复杂度为 O(m*n)，空间复杂度为 O(m*n)，其中 `m` 和 `n` 分别为 `text1` 和 `text2` 的长度。

#### **完整代码：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 8. 算法题：合并两个有序链表

#### **题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### **示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### **示例：**
```
输入：l1 = [], l2 = []
输出：[]
```

#### **答案解析：**

以下是实现的代码：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### **解析：**

1. **比较头节点：** 如果第一个链表的头节点的值小于第二个链表的头节点的值，那么将第一个链表的下一个节点与第二个链表进行递归合并，并返回第一个链表作为新的头节点。
2. **否则：** 将第二个链表的下一个节点与第一个链表进行递归合并，并返回第二个链表作为新的头节点。

这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 `m` 和 `n` 分别为两个链表的长度。

#### **完整代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

### 9. 面试题：整数转换为罗马数字

#### **题目描述：** 罗马数字包含以下七种字符：I，V，X，L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII，即为 X + II。36 写做 XXXVI。

#### **示例：**
```
输入：num = 3
输出："III"
```

#### **示例：**
```
输入：num = 4
输出："IV"
```

#### **示例：**
```
输入：num = 9
输出："IX"
```

#### **答案解析：**

以下是实现的代码：

```go
func intToRoman(num int) string {
    val := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
    nums := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}

    result := ""
    for i, num := range nums {
        for num <= num/10*num {
            result += val[i]
            num += num/10
        }
    }
    return result
}
```

#### **解析：**

1. **初始化：** 定义两个数组 `val` 和 `nums`，分别存储罗马数字的字符串和对应的数值。
2. **循环遍历：** 对于每个 `num`，如果当前 `num` 小于等于其十倍（例如，1000 小于等于 10000），则将对应的罗马数字字符串添加到结果中，并将 `num` 更新为其十倍（例如，1000 更新为 10000）。
3. **返回结果：** 最终返回结果字符串。

这种方法的时间复杂度为 O(1)，空间复杂度为 O(1)。

#### **完整代码：**

```go
func intToRoman(num int) string {
    val := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
    nums := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}

    result := ""
    for i, num := range nums {
        for num <= num/10*num {
            result += val[i]
            num += num/10
        }
    }
    return result
}
```

### 10. 算法题：两数相加 II

#### **题目描述：** 给定两个非空链表表示的两个非负整数，每个节点包含一个数字。将这两个数相加并返回一个新的链表。

#### **示例：**
```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

#### **示例：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,7]
```

#### **答案解析：**

以下是实现的代码：

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{sum % 10, nil}
        current = current.Next
    }

    return dummy.Next
}
```

#### **解析：**

1. **初始化：** 创建一个哑节点 `dummy`，用于简化节点操作。同时初始化两个指针 `current` 和 `carry`，分别指向当前节点和进位。
2. **遍历两个链表：** 当两个链表中的任一节点不为空或者进位 `carry` 不为 0 时，进行以下操作：
   - 取出两个链表当前节点的值 `val1` 和 `val2`。
   - 计算当前位的和 `sum`。
   - 计算新的进位 `carry`。
   - 创建新的节点，并将和的个位数设置为节点的值。
3. **返回结果：** 返回哑节点的下一个节点，即新的链表的头节点。

这种方法的时间复杂度为 O(max(m, n))，空间复杂度为 O(1)，其中 m 和 n 分别为两个链表的长度。

#### **完整代码：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{sum % 10, nil}
        current = current.Next
    }

    return dummy.Next
}
```

### 11. 算法题：买卖股票的最佳时机 II

#### **题目描述：** 给定一个数组 `prices`，其中 `prices[i]` 是在第 `i` 天 stock 的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一只股票）。

#### **示例：**
```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
```

#### **示例：**
```
输入：prices = [1,2,3,4,5]
输出：4
```

#### **示例：**
```
输入：prices = [7,6,4,3,1]
输出：0
```

#### **答案解析：**

我们可以使用贪心算法来解决这个问题。以下是实现的代码：

```go
func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}
```

#### **解析：**

1. **初始化：** 初始化一个变量 `profit` 用于存储总利润。
2. **遍历数组：** 从第二个元素开始遍历数组 `prices`，如果当前元素大于前一个元素，则说明股票价格上涨，我们可以进行一次买卖操作。将本次买卖的利润（当前元素减去前一个元素）加到总利润中。
3. **返回结果：** 返回总利润。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组 `prices` 的长度。

#### **完整代码：**

```go
func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}
```

### 12. 算法题：有效括号

#### **题目描述：** 给定一个字符串 `s` ，当 `s` 是一个有效的括号字符串时返回 `true`，否则返回 `false`。

一个有效括号字符串定义如下：

1. 它是一个空字符串，或者
2. 它是一个非空字符串，并且它可以用以下方法变为一个有效括号字符串：
   - 它是一个小括号 `()` 的闭合，或者
   - 它是一个有效括号字符串，并且左右两边的部分都是有效括号字符串。

例如，`()`、`()`()` 和 `(())()` 都是有效括号字符串，而 `(`、`)`、`(())` 和 `()``()` 都不是有效括号字符串。

#### **示例：**
```
输入："()"
输出：true
```

#### **示例：**
```
输入："()"
输出：true
```

#### **示例：**
```
输入："((()"
输出：false
```

#### **答案解析：**

我们可以使用栈来实现这个算法。以下是实现的代码：

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || rune(stack[len(stack)-1]) != char {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

#### **解析：**

1. **初始化：** 初始化一个空栈 `stack` 用于存储括号。
2. **遍历字符串：** 对于字符串 `s` 的每个字符：
   - 如果字符是开括号 `(`、`{` 或 `[`，将对应的闭括号 `)`、`}` 或 `]` 入栈。
   - 如果字符是闭括号，检查栈顶元素是否与之匹配：
     - 如果不匹配或栈为空，说明字符串不是有效括号字符串，返回 `false`。
     - 如果匹配，将栈顶元素弹出。
3. **检查栈：** 遍历完成后，如果栈为空，说明字符串是有效括号字符串，返回 `true`；否则返回 `false`。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是字符串 `s` 的长度。

#### **完整代码：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(':
            stack = append(stack, ')')
        case '{':
            stack = append(stack, '}')
        case '[':
            stack = append(stack, ']')
        default:
            if len(stack) == 0 || rune(stack[len(stack)-1]) != char {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

### 13. 面试题：合并两个有序链表

#### **题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### **示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### **示例：**
```
输入：l1 = [], l2 = []
输出：[]
```

#### **答案解析：**

以下是实现的代码：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### **解析：**

1. **比较头节点：** 如果第一个链表的头节点的值小于第二个链表的头节点的值，那么将第一个链表的下一个节点与第二个链表进行递归合并，并返回第一个链表作为新的头节点。
2. **否则：** 将第二个链表的下一个节点与第一个链表进行递归合并，并返回第二个链表作为新的头节点。

这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 `m` 和 `n` 分别为两个链表的长度。

#### **完整代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

### 14. 算法题：最长公共前缀

#### **题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

#### **示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

#### **示例：**
```
输入：strs = ["dog","racecar","car"]
输出：""
```

#### **答案解析：**

我们可以使用垂直扫描的方法来解决这个问题。以下是实现的代码：

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    for i, ch := 0, strs[0][0]; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            // 如果当前字符不相等，或者已经越界，返回当前公共前缀
            if i >= len(strs[j]) || ch != strs[j][i] {
                return strs[0][:i]
            }
        }
        ch = strs[0][i]
    }
    return strs[0]
}
```

#### **解析：**

1. **初始化：** 从第一个字符串的字符开始，作为公共前缀的初始字符。
2. **垂直扫描：** 从第一个字符开始，对于每个字符，检查其他字符串是否也具有相同的字符。
3. **返回结果：** 如果所有字符串都至少有一个公共前缀，返回这个公共前缀；否则，返回空字符串。

这种方法的时间复杂度为 O(S)，其中 S 是所有字符串的总长度；空间复杂度为 O(1)。

#### **完整代码：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    for i, ch := 0, strs[0][0]; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || ch != strs[j][i] {
                return strs[0][:i]
            }
        }
        ch = strs[0][i]
    }
    return strs[0]
}
```

### 15. 算法题：盛最多水的容器

#### **题目描述：** 给定一个二维度数组 matrix ，返回矩阵中的最大元素。

#### **示例：**
```
输入：matrix = [[1,2],[3,4]]
输出：7
解释：最大的元素是 7 ，位于 matrix 的左下角。
```

#### **示例：**
```
输入：matrix = [[1,2,3,4]]
输出：4
```

#### **示例：**
```
输入：matrix = [[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]]
输出：45
```

#### **答案解析：**

我们可以使用双指针方法来解决这个问题。以下是实现的代码：

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    for left < right {
        leftHeight, rightHeight := height[left], height[right]
        maxArea = max(maxArea, (right-left)*min(leftHeight, rightHeight))
        if leftHeight < rightHeight {
            left++
        } else {
            right--
        }
    }
    return maxArea
}
```

#### **解析：**

1. **初始化：** 初始化两个指针 `left` 和 `right`，分别指向数组的第一个和最后一个元素。
2. **循环遍历：** 当 `left` 小于 `right` 时，进行以下操作：
   - 计算当前容器的面积，即 `(right-left) * min(leftHeight, rightHeight)`。
   - 如果 `leftHeight` 小于 `rightHeight`，将 `left` 加一；否则，将 `right` 减一。
3. **返回结果：** 返回最大面积。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组 `height` 的长度。

#### **完整代码：**

```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    for left < right {
        leftHeight, rightHeight := height[left], height[right]
        maxArea = max(maxArea, (right-left)*min(leftHeight, rightHeight))
        if leftHeight < rightHeight {
            left++
        } else {
            right--
        }
    }
    return maxArea
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 16. 算法题：最长公共子序列

#### **题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

#### **示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

#### **示例：**
```
输入：text1 = "abc", text2 = "abc"
输出：3
```

#### **答案解析：**

我们可以使用动态规划来解决这个问题。以下是实现的代码：

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### **解析：**

1. **初始化：** 创建一个二维数组 `dp`，用于存储子问题的解。数组的大小为 `m+1` 和 `n+1`，其中 `m` 和 `n` 分别为 `text1` 和 `text2` 的长度。
2. **动态规划：** 遍历 `text1` 和 `text2` 的每个字符，对于每个字符，根据以下条件更新 `dp` 数组：
   - 如果 `text1[i-1]` 等于 `text2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 如果 `text1[i-1]` 不等于 `text2[j-1]`，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
3. **返回结果：** 返回 `dp[m][n]`，即最长公共子序列的长度。

这种方法的时间复杂度为 O(m*n)，空间复杂度为 O(m*n)，其中 `m` 和 `n` 分别为 `text1` 和 `text2` 的长度。

#### **完整代码：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 17. 面试题：两数相加

#### **题目描述：** 给定两个非空链表表示的两个非负整数，每个节点包含一个数字。将这两个数相加并返回一个新的链表。

#### **示例：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,7]
```

#### **示例：**
```
输入：l1 = [0], l2 = [0]
输出：[0]
```

#### **答案解析：**

以下是实现的代码：

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{sum % 10, nil}
        current = current.Next
    }

    return dummy.Next
}
```

#### **解析：**

1. **初始化：** 创建一个哑节点 `dummy`，用于简化节点操作。同时初始化两个指针 `current` 和 `carry`，分别指向当前节点和进位。
2. **遍历两个链表：** 当两个链表中的任一节点不为空或者进位 `carry` 不为 0 时，进行以下操作：
   - 取出两个链表当前节点的值 `val1` 和 `val2`。
   - 计算当前位的和 `sum`。
   - 计算新的进位 `carry`。
   - 创建新的节点，并将和的个位数设置为节点的值。
3. **返回结果：** 返回哑节点的下一个节点，即新的链表的头节点。

这种方法的时间复杂度为 O(max(m, n))，空间复杂度为 O(1)，其中 m 和 n 分别为两个链表的长度。

#### **完整代码：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{0, nil}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{sum % 10, nil}
        current = current.Next
    }

    return dummy.Next
}
```

### 18. 算法题：合并两个有序数组

#### **题目描述：** 给你两个整数数组 `nums1` 和 `nums2` ，按升序整理数组 `nums1` 和 `nums2` ，并将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

#### **示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

#### **示例：**
```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

#### **答案解析：**

我们可以使用双指针方法来合并两个数组。以下是实现的代码：

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    idx := m+n-1

    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[idx] = nums1[p1]
            p1--
        } else {
            nums1[idx] = nums2[p2]
            p2--
        }
        idx--
    }

    for p2 >= 0 {
        nums1[idx] = nums2[p2]
        p2--
        idx--
    }
}
```

#### **解析：**

1. **初始化：** 定义两个指针 `p1` 和 `p2`，分别指向两个数组的最后一个元素。定义一个指针 `idx`，指向合并后数组的最后一个位置。
2. **比较并合并：** 当 `p1` 和 `p2` 都大于等于 0 时，比较 `nums1[p1]` 和 `nums2[p2]`，将较大的元素放到 `nums1[idx]`，并相应地移动指针 `p1`、`p2` 和 `idx`。
3. **处理剩余元素：** 如果 `p2` 大于等于 0，说明 `nums2` 中还有未合并的元素，将这些元素放到 `nums1` 中，并相应地移动指针 `p2` 和 `idx`。

这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 `m` 和 `n` 分别为数组 `nums1` 和 `nums2` 的长度。

#### **完整代码：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    idx := m+n-1

    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[idx] = nums1[p1]
            p1--
        } else {
            nums1[idx] = nums2[p2]
            p2--
        }
        idx--
    }

    for p2 >= 0 {
        nums1[idx] = nums2[p2]
        p2--
        idx--
    }
}
```

### 19. 算法题：有效的括号字符串

#### **题目描述：** 给定一个只包含 '('、')' 和 '-' 的字符串 `s` ，其中 '(' 和 ')' 表示匹配的左右括号，'-' 只会出现在括号字符串的开头或者结尾之间。两个括号字符串 `x` 和 `y` 合并的结果，只有当 `x` 和 `y` 为有效括号字符串时才是有效的。请注意，空括号字符串是有效的。

例如，考虑以下字符串：
- `"(()"` 是有效括号字符串。
- `"())"` 是无效括号字符串。
- `"(("-"` 是有效括号字符串。
- `")("-"` 是无效括号字符串。

有效括号字符串可以被合并为一个新的有效括号字符串，当且仅当合并后字符串中的所有括号都是有效的。

#### **示例：**
```
输入：s = "(()())"
输出："(()())"
```

#### **示例：**
```
输入：s = "()(})"
输出："()"
```

#### **答案解析：**

我们可以使用贪心算法来解决这个问题。以下是实现的代码：

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

#### **解析：**

1. **初始化：** 初始化一个变量 `count` 用于存储括号的数量。
2. **遍历字符串：** 对于字符串 `s` 的每个字符：
   - 如果字符是 `'('`，将 `count` 加一。
   - 如果字符是 `')'`，将 `count` 减一。
   - 如果字符是 `'-'`，且 `count` 大于零，将 `count` 减一。
3. **检查括号数量：** 如果 `count` 小于零，说明字符串不是有效括号字符串，返回空字符串。
4. **返回结果：** 如果字符串是有效括号字符串，返回一个空括号字符串。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是字符串 `s` 的长度。

#### **完整代码：**

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

### 20. 面试题：最接近的三数之和

#### **题目描述：** 给你一个整数数组 `nums` 和一个目标值 `target`，请你计算并返回 `nums` 中，三个数的和与 `target` 最接近的值。

#### **示例：**
```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：最接近 target 的三个数的和为 2 (-1 + 2 + 1 = 2)。
```

#### **示例：**
```
输入：nums = [0,0,0], target = 0
输出：0
```

#### **答案解析：**

我们可以使用三指针方法来解决这个问题。以下是实现的代码：

```go
func threeSumClosest(nums []int, target int) int {
    sort.Ints(nums)
    closest := nums[0] + nums[1] + nums[2]
    for i := 0; i < len(nums)-2; i++ {
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if abs(sum-target) < abs(closest-target) {
                closest = sum
            }
            if sum == target {
                return target
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return closest
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

#### **解析：**

1. **初始化：** 对数组 `nums` 进行排序。
2. **遍历数组：** 对于数组中的每个元素 `nums[i]`，设置两个指针 `left` 和 `right`，分别指向 `nums[i]` 的下一个元素和最后一个元素。
3. **双指针移动：** 对于当前 `nums[i]`，根据 `nums[left] + nums[right] + nums[i]` 与 `target` 的比较结果，移动 `left` 和 `right`：
   - 如果 `sum == target`，直接返回 `target`。
   - 如果 `sum < target`，将 `left` 指针右移。
   - 如果 `sum > target`，将 `right` 指针左移。
4. **更新最接近的和：** 如果当前 `sum` 更接近 `target`，更新 `closest`。

这种方法的时间复杂度为 O(n^2)，空间复杂度为 O(1)，其中 n 是数组 `nums` 的长度。

#### **完整代码：**

```go
func threeSumClosest(nums []int, target int) int {
    sort.Ints(nums)
    closest := nums[0] + nums[1] + nums[2]
    for i := 0; i < len(nums)-2; i++ {
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if abs(sum-target) < abs(closest-target) {
                closest = sum
            }
            if sum == target {
                return target
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return closest
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

### 21. 算法题：合并二叉树

#### **题目描述：** 给你两棵二叉树 `root1` 和 `root2` ，想象 yourself 是站在二叉树的根节点处，当从上到下遍历这棵树时， `root1` 的每条右边的路径都应该添加到 `root2` 中。返回 `root2` 。

#### **示例：**
```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[2,2,3,5,4,null,7]
解释：
在上图中，红色节点的路径被添加到绿色节点上。
```

#### **答案解析：**

我们可以使用递归方法来解决这个问题。以下是实现的代码：

```go
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}
```

#### **解析：**

1. **初始化：** 如果 `t1` 为 `nil`，则返回 `t2`；如果 `t2` 为 `nil`，则返回 `t1`。
2. **合并节点值：** 将 `t1` 和 `t2` 的节点值相加，更新 `t1` 的节点值。
3. **递归合并子节点：** 分别递归合并 `t1` 和 `t2` 的左子节点和右子节点，并将结果赋给 `t1` 的对应子节点。
4. **返回结果：** 返回合并后的二叉树。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是二叉树的节点数。

#### **完整代码：**

```go
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}
```

### 22. 算法题：最长公共子序列

#### **题目描述：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

#### **示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

#### **示例：**
```
输入：text1 = "abc", text2 = "abc"
输出：3
```

#### **答案解析：**

我们可以使用动态规划来解决这个问题。以下是实现的代码：

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### **解析：**

1. **初始化：** 创建一个二维数组 `dp`，用于存储子问题的解。数组的大小为 `m+1` 和 `n+1`，其中 `m` 和 `n` 分别为 `text1` 和 `text2` 的长度。
2. **动态规划：** 遍历 `text1` 和 `text2` 的每个字符，对于每个字符，根据以下条件更新 `dp` 数组：
   - 如果 `text1[i-1]` 等于 `text2[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 如果 `text1[i-1]` 不等于 `text2[j-1]`，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
3. **返回结果：** 返回 `dp[m][n]`，即最长公共子序列的长度。

这种方法的时间复杂度为 O(m*n)，空间复杂度为 O(m*n)，其中 `m` 和 `n` 分别为 `text1` 和 `text2` 的长度。

#### **完整代码：**

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 23. 算法题：最小栈

#### **题目描述：** 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。
#### **示例：**
```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[(-2)],[ 0], [3],[],[],[],[]]

输出：
[null,null,null,null,-2,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(3);
minStack.getMin(); // 返回 -2。
minStack.pop();
minStack.top();    // 返回 0。
minStack.getMin(); // 返回 -2。
```

#### **答案解析：**

我们可以使用两个栈来实现最小栈。以下是实现的代码：

```go
type MinStack struct {
    stack []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack: []int{},
        minStack: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if val < this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    } else {
        this.minStack = append(this.minStack, this.minStack[len(this.minStack)-1])
    }
}

func (this *MinStack) Pop() {
    this.stack = this.stack[:len(this.stack)-1]
    this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

#### **解析：**

1. **初始化：** 创建一个 `MinStack` 结构体，包含一个栈 `stack` 和一个最小栈 `minStack`。初始化时，最小栈只包含一个最大值 `math.MaxInt64`。
2. **push(val) 操作：** 将元素 `val` 推入栈 `stack` 中。如果 `val` 小于当前最小值，则将 `val` 推入最小栈 `minStack` 中；否则，将当前最小值重新推入最小栈。
3. **pop() 操作：** 将栈顶元素弹出，同时最小栈也弹出对应的元素。
4. **top() 操作：** 返回栈顶元素。
5. **getMin() 操作：** 返回最小栈的栈顶元素。

这种方法的时间复杂度为 O(1)，空间复杂度为 O(n)，其中 n 是栈中的元素数量。

#### **完整代码：**

```go
type MinStack struct {
    stack []int
    minStack []int
}

func Constructor() MinStack {
    return MinStack{
        stack: []int{},
        minStack: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int) {
    this.stack = append(this.stack, val)
    if val < this.minStack[len(this.minStack)-1] {
        this.minStack = append(this.minStack, val)
    } else {
        this.minStack = append(this.minStack, this.minStack[len(this.minStack)-1])
    }
}

func (this *MinStack) Pop() {
    this.stack = this.stack[:len(this.stack)-1]
    this.minStack = this.minStack[:len(this.minStack)-1]
}

func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

func (this *MinStack) GetMin() int {
    return this.minStack[len(this.minStack)-1]
}
```

### 24. 算法题：最大子序列和

#### **题目描述：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少包含一个数）。返回最大子序列和。

#### **示例：**
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

#### **示例：**
```
输入：nums = [1]
输出：1
```

#### **示例：**
```
输入：nums = [5,4,-1,7,8]
输出：23
```

#### **答案解析：**

我们可以使用动态规划来解决这个问题。以下是实现的代码：

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }

    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

#### **解析：**

1. **初始化：** 使用两个变量 `maxSum` 和 `currSum`，分别表示当前最大子序列和和当前子序列和。初始时，`maxSum` 和 `currSum` 均为 `nums[0]`。
2. **遍历数组：** 从第二个元素开始遍历数组 `nums`，每次更新 `currSum` 为当前元素与 `currSum+当前元素` 中的最大值。
3. **更新最大子序列和：** 如果 `currSum` 大于 `maxSum`，则更新 `maxSum`。
4. **返回结果：** 最终返回 `maxSum`。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。

#### **完整代码：**

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        maxSum = max(maxSum, currSum)
    }

    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 25. 面试题：有效的括号字符串

#### **题目描述：** 给定一个只包含 '('、')' 和 '-' 的字符串 `s` ，其中 '(' 和 ')' 表示匹配的左右括号，'-' 只会出现在括号字符串的开头或者结尾之间。两个括号字符串 `x` 和 `y` 合并的结果，只有当 `x` 和 `y` 为有效括号字符串时才是有效的。

例如，考虑以下字符串：
- `"(()"` 是有效括号字符串。
- `"())"` 是无效括号字符串。
- `"(("-"` 是有效括号字符串。
- `")("-"` 是无效括号字符串。

有效括号字符串可以被合并为一个新的有效括号字符串，当且仅当合并后字符串中的所有括号都是有效的。

#### **示例：**
```
输入：s = "(()())"
输出："(()())"
```

#### **示例：**
```
输入：s = "()(})"
输出："()"
```

#### **答案解析：**

我们可以使用贪心算法来解决这个问题。以下是实现的代码：

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

#### **解析：**

1. **初始化：** 初始化一个变量 `count` 用于存储括号的数量。
2. **遍历字符串：** 对于字符串 `s` 的每个字符：
   - 如果字符是 `'('`，将 `count` 加一。
   - 如果字符是 `')'`，将 `count` 减一。
   - 如果字符是 `'-'`，且 `count` 大于零，将 `count` 减一。
3. **检查括号数量：** 如果 `count` 小于零，说明字符串不是有效括号字符串，返回空字符串。
4. **返回结果：** 如果字符串是有效括号字符串，返回一个空括号字符串。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是字符串 `s` 的长度。

#### **完整代码：**

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

### 26. 算法题：合并两个有序链表

#### **题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### **示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### **示例：**
```
输入：l1 = [], l2 = []
输出：[]
```

#### **答案解析：**

以下是实现的代码：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### **解析：**

1. **比较头节点：** 如果第一个链表的头节点的值小于第二个链表的头节点的值，那么将第一个链表的下一个节点与第二个链表进行递归合并，并返回第一个链表作为新的头节点。
2. **否则：** 将第二个链表的下一个节点与第一个链表进行递归合并，并返回第二个链表作为新的头节点。

这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 `m` 和 `n` 分别为两个链表的长度。

#### **完整代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

### 27. 算法题：合并两个有序数组

#### **题目描述：** 给你两个整数数组 `nums1` 和 `nums2` ，按升序整理数组 `nums1` 和 `nums2` ，并将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

#### **示例：**
```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
```

#### **示例：**
```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
```

#### **答案解析：**

我们可以使用双指针方法来合并两个数组。以下是实现的代码：

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    idx := m+n-1

    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[idx] = nums1[p1]
            p1--
        } else {
            nums1[idx] = nums2[p2]
            p2--
        }
        idx--
    }

    for p2 >= 0 {
        nums1[idx] = nums2[p2]
        p2--
        idx--
    }
}
```

#### **解析：**

1. **初始化：** 定义两个指针 `p1` 和 `p2`，分别指向两个数组的最后一个元素。定义一个指针 `idx`，指向合并后数组的最后一个位置。
2. **比较并合并：** 当 `p1` 和 `p2` 都大于等于 0 时，比较 `nums1[p1]` 和 `nums2[p2]`，将较大的元素放到 `nums1[idx]`，并相应地移动指针 `p1`、`p2` 和 `idx`。
3. **处理剩余元素：** 如果 `p2` 大于等于 0，说明 `nums2` 中还有未合并的元素，将这些元素放到 `nums1` 中，并相应地移动指针 `p2` 和 `idx`。

这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 `m` 和 `n` 分别为数组 `nums1` 和 `nums2` 的长度。

#### **完整代码：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    idx := m+n-1

    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[idx] = nums1[p1]
            p1--
        } else {
            nums1[idx] = nums2[p2]
            p2--
        }
        idx--
    }

    for p2 >= 0 {
        nums1[idx] = nums2[p2]
        p2--
        idx--
    }
}
```

### 28. 算法题：有效的括号字符串

#### **题目描述：** 给定一个只包含 '('、')' 和 '-' 的字符串 `s` ，其中 '(' 和 ')' 表示匹配的左右括号，'-' 只会出现在括号字符串的开头或者结尾之间。两个括号字符串 `x` 和 `y` 合并的结果，只有当 `x` 和 `y` 为有效括号字符串时才是有效的。

例如，考虑以下字符串：
- `"(()"` 是有效括号字符串。
- `"())"` 是无效括号字符串。
- `"(("-"` 是有效括号字符串。
- `")("-"` 是无效括号字符串。

有效括号字符串可以被合并为一个新的有效括号字符串，当且仅当合并后字符串中的所有括号都是有效的。

#### **示例：**
```
输入：s = "(()())"
输出："(()())"
```

#### **示例：**
```
输入：s = "()(})"
输出："()"
```

#### **答案解析：**

我们可以使用贪心算法来解决这个问题。以下是实现的代码：

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

#### **解析：**

1. **初始化：** 初始化一个变量 `count` 用于存储括号的数量。
2. **遍历字符串：** 对于字符串 `s` 的每个字符：
   - 如果字符是 `'('`，将 `count` 加一。
   - 如果字符是 `')'`，将 `count` 减一。
   - 如果字符是 `'-'`，且 `count` 大于零，将 `count` 减一。
3. **检查括号数量：** 如果 `count` 小于零，说明字符串不是有效括号字符串，返回空字符串。
4. **返回结果：** 如果字符串是有效括号字符串，返回一个空括号字符串。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是字符串 `s` 的长度。

#### **完整代码：**

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

### 29. 算法题：有效的括号字符串

#### **题目描述：** 给定一个只包含 '('、')' 和 '-' 的字符串 `s` ，其中 '(' 和 ')' 表示匹配的左右括号，'-' 只会出现在括号字符串的开头或者结尾之间。两个括号字符串 `x` 和 `y` 合并的结果，只有当 `x` 和 `y` 为有效括号字符串时才是有效的。

例如，考虑以下字符串：
- `"(()"` 是有效括号字符串。
- `"())"` 是无效括号字符串。
- `"(("-"` 是有效括号字符串。
- `")("-"` 是无效括号字符串。

有效括号字符串可以被合并为一个新的有效括号字符串，当且仅当合并后字符串中的所有括号都是有效的。

#### **示例：**
```
输入：s = "(()())"
输出："(()())"
```

#### **示例：**
```
输入：s = "()(})"
输出："()"
```

#### **答案解析：**

我们可以使用贪心算法来解决这个问题。以下是实现的代码：

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

#### **解析：**

1. **初始化：** 初始化一个变量 `count` 用于存储括号的数量。
2. **遍历字符串：** 对于字符串 `s` 的每个字符：
   - 如果字符是 `'('`，将 `count` 加一。
   - 如果字符是 `')'`，将 `count` 减一。
   - 如果字符是 `'-'`，且 `count` 大于零，将 `count` 减一。
3. **检查括号数量：** 如果 `count` 小于零，说明字符串不是有效括号字符串，返回空字符串。
4. **返回结果：** 如果字符串是有效括号字符串，返回一个空括号字符串。

这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是字符串 `s` 的长度。

#### **完整代码：**

```go
func checkValidString(s string) string {
    count := 0
    for _, c := range s {
        switch c {
        case '(':
            count++
        case ')':
            count--
        case '-':
            if count > 0 {
                count--
            }
        }
        if count < 0 {
            return ""
        }
    }
    return "()"
}
```

### 30. 算法题：合并两个有序链表

#### **题目描述：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### **示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### **示例：**
```
输入：l1 = [], l2 = []
输出：[]
```

#### **答案解析：**

以下是实现的代码：

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

#### **解析：**

1. **比较头节点：** 如果第一个链表的头节点的值小于第二个链表的头节点的值，那么将第一个链表的下一个节点与第二个链表进行递归合并，并返回第一个链表作为新的头节点。
2. **否则：** 将第二个链表的下一个节点与第一个链表进行递归合并，并返回第二个链表作为新的头节点。

这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(1)，其中 `m` 和 `n` 分别为两个链表的长度。

#### **完整代码：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

