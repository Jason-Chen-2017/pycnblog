                 

### 1. 字符串匹配算法

**题目：** 实现一个字符串匹配算法，找出给定字符串 `s` 中是否包含子字符串 `pattern`，并返回第一个匹配的子字符串的起始索引。如果不存在匹配项，返回 `-1`。

**答案：** 使用KMP（Knuth-Morris-Pratt）算法进行字符串匹配。

**示例代码：**

```python
def kmp(s: str, pattern: str) -> int:
    def build_lps(pattern: str) -> List[int]:
        lps = [0] * len(pattern)
        length = 0
        i = 1
        while i < len(pattern):
            if pattern[i] == pattern[length]:
                length += 1
                lps[i] = length
                i += 1
            else:
                if length != 0:
                    length = lps[length - 1]
                else:
                    lps[i] = 0
                    i += 1
        return lps

    s = ' ' + s
    pattern = ' ' + pattern
    lps = build_lps(pattern)
    i = j = 1
    while i < len(s):
        if pattern[j - 1] == s[i - 1]:
            i += 1
            j += 1
        if j == len(pattern):
            return i - j
        elif i < len(s) and pattern[j - 1] != s[i - 1]:
            if j != 1:
                j = lps[j - 1]
            else:
                i += 1
    return -1

# 示例
s = "ABCDABD"
pattern = "BDAB"
print(kmp(s, pattern))  # 输出 4
```

**解析：** KMP算法的关键在于构建一个最长公共前后缀数组（LPS），然后通过该数组来避免字符串中的重复比较。在匹配过程中，如果当前字符不匹配，则通过LPS数组来确定下一次匹配的起始位置，从而提高算法效率。

### 2. 二分查找

**题目：** 实现一个二分查找算法，在已排序的整数数组 `nums` 中查找目标值 `target`，并返回它的索引。如果目标值不存在，返回 `-1`。

**答案：** 直接使用二分查找算法。

**示例代码：**

```python
def binary_search(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# 示例
nums = [1, 3, 5, 6]
target = 5
print(binary_search(nums, target))  # 输出 2
```

**解析：** 二分查找算法通过不断地将搜索区间折半，直到找到目标值或确定目标值不存在。这个过程时间复杂度为O(log n)，非常适合在已排序的数组中进行查找。

### 3. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 使用横向扫描法。

**示例代码：**

```python
def longest_common_prefix(strs: List[str]) -> str:
    if not strs:
        return ""
    prefix = ""
    for c in strs[0]:
        for s in strs[1:]:
            if s[:len(prefix)+1].startswith(prefix):
                prefix += c
            else:
                break
    return prefix

# 示例
strs = ["flower","flow","flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

**解析：** 通过逐个字符比较字符串数组中的每个字符串，找到所有字符串的最长公共前缀。这种方法简单易懂，但是当字符串数组长度较大时，效率可能较低。

### 4. 最长回文子串

**题目：** 给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**答案：** 使用动态规划。

**示例代码：**

```python
def longest_palindromic_substring(s: str) -> str:
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    start, max_len = 0, 1
    for i in range(n):
        dp[i][i] = True
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if s[i] == s[j]:
                if j - i == 1 or dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if max_len < j - i + 1:
                        start = i
                        max_len = j - i + 1
            else:
                dp[i][j] = False
    return s[start:start + max_len]

# 示例
s = "babad"
print(longest_palindromic_substring(s))  # 输出 "bab" 或 "aba"
```

**解析：** 动态规划算法通过判断子字符串是否为回文来确定最长回文子串。这种方法的时间复杂度为O(n^2)，空间复杂度也为O(n^2)。

### 5. 盒子翻转

**题目：** 给定一个由若干个盒子组成的列表，每个盒子都可以装一定数量的水。请你设计一个算法来计算最少需要多少次翻转操作，才能将所有盒子的水都倒掉。

**答案：** 使用贪心算法。

**示例代码：**

```python
from heapq import heappush, heappop

def min_flips(blocks: List[int]) -> int:
    max_heap = []
    min_heap = []
    for block in blocks:
        heappush(max_heap, -block)
    res = 0
    while max_heap:
        while max_heap and max_heap[0] < 0:
            heappop(max_heap)
        if not max_heap:
            break
        heappush(min_heap, heappop(max_heap))
        heappush(min_heap, -heappop(max_heap))
        res += 1
    return res

# 示例
blocks = [1, 2, 1, 3]
print(min_flips(blocks))  # 输出 3
```

**解析：** 通过维护两个堆（一个最大堆和一个最小堆），我们每次选择最大堆和最小堆的堆顶元素进行翻转操作，直到最大堆为空。这种方法可以确保每次翻转操作都使得水量减少最多，从而达到最小化翻转次数的目的。

### 6. 最长有效括号

**题目：** 给你一个只包含 '(' 和 ')' 的字符串，找出最长的有效括号子串。

**答案：** 使用栈。

**示例代码：**

```python
def longest_valid_parentheses(s: str) -> int:
    stack = [-1]
    max_len = 0
    for i, c in enumerate(s):
        if c == '(':
            stack.append(i)
        else:
            stack.pop()
            if stack:
                max_len = max(max_len, i - stack[-1])
            else:
                stack.append(i)
    return max_len

# 示例
s = "()(())"
print(longest_valid_parentheses(s))  # 输出 2
```

**解析：** 通过维护一个栈，我们记录每个右括号对应的左括号的索引。每当栈为空时，说明当前右括号没有与之匹配的左括号，此时更新最长有效括号长度。这种方法的时间复杂度为O(n)。

### 7. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：** 使用递归。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

# 示例
# 输入：list1 = [1,2,4], list2 = [1,3,4]
# 输出：[1,1,2,3,4,4]
```

**解析：** 递归地将两个链表的头部节点进行比较，将较小的节点连接到新的链表中，并递归地处理剩余的链表。这种方法的时间复杂度为O(n + m)，其中n和m分别是两个链表的长度。

### 8. 排序链表

**题目：** 给你一个链表，请你采用任何算法对其进行排序。不能使用 comparative 操纵符（如 `<`，`>`）。

**答案：** 使用归并排序。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next
        slow.next = None
        left = self.sortList(head)
        right = self.sortList(mid)
        return self.merge(left, right)

    def merge(self, left: Optional[ListNode], right: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        while left and right:
            if left.val < right.val:
                curr.next = left
                left = left.next
            else:
                curr.next = right
                right = right.next
            curr = curr.next
        curr.next = left if left else right
        return dummy.next

# 示例
# 输入：[4,2,1,3]
# 输出：[1,2,3,4]
```

**解析：** 归并排序是一种经典的排序算法，特别适合于链表。首先找到链表的中点，将链表分为两个部分，然后递归地对两部分进行排序，最后将排好序的链表合并。这种方法的时间复杂度为O(n log n)。

### 9. 螺旋矩阵

**题目：** 给定一个 `m x n` 的矩阵，按照螺旋顺序返回矩阵中的所有元素。

**答案：** 使用模拟。

**示例代码：**

```python
def spiralOrder(matrix: List[List[int]]) -> List[int]:
    if not matrix:
        return []
    rows, cols = len(matrix), len(matrix[0])
    top, bottom, left, right = 0, rows - 1, 0, cols - 1
    ans = []
    while top <= bottom and left <= right:
        for c in range(left, right + 1):
            ans.append(matrix[top][c])
        top += 1
        for r in range(top, bottom + 1):
            ans.append(matrix[r][right])
        right -= 1
        if top <= bottom:
            for c in range(right, left - 1, -1):
                ans.append(matrix[bottom][c])
            bottom -= 1
        if left <= right:
            for r in range(bottom, top - 1, -1):
                ans.append(matrix[r][left])
            left += 1
    return ans

# 示例
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(spiralOrder(matrix))  # 输出 [1,2,3,6,9,8,7,4,5]
```

**解析：** 通过模拟螺旋矩阵的移动过程，依次访问矩阵的四个边界，然后逐步缩小边界范围。这种方法的时间复杂度为O(m * n)。

### 10. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，请实现一个算法，找出两个字符串的最长公共子序列。

**答案：** 使用动态规划。

**示例代码：**

```python
def longest_common_subsequence(text1: str, text2: str) -> str:
    m, n = len(text1), len(text2)
    dp = [["" for _ in range(n+1)] for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + text1[i-1]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)
    return dp[-1][-1]

# 示例
text1 = "abcde"
text2 = "ace"
print(longest_common_subsequence(text1, text2))  # 输出 "ace"
```

**解析：** 动态规划通过构造一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列。在填充 `dp` 数组的过程中，根据字符是否匹配来更新子序列。这种方法的时间复杂度为O(m * n)。

### 11. 删除链表的倒数第 N 个结点

**题目：** 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

**答案：** 使用快慢指针。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        slow = fast = head
        for _ in range(n):
            fast = fast.next
        if fast is None:
            return head.next
        while fast.next:
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return head

# 示例
# 输入：head = [1,2,3,4,5], n = 2
# 输出：[1,2,3,5]
```

**解析：** 通过使用快慢指针，快指针先走 `n` 步，然后慢指针和快指针同时移动。当快指针到达链表末尾时，慢指针正好位于倒数第 `n` 个节点之前。这种方法的时间复杂度为O(n)。

### 12. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**答案：** 使用动态规划。

**示例代码：**

```python
def max_subarray(nums: List[int]) -> int:
    if not nums:
        return 0
    max_so_far = nums[0]
    curr_max = nums[0]
    for i in range(1, len(nums)):
        curr_max = max(nums[i], curr_max + nums[i])
        max_so_far = max(max_so_far, curr_max)
    return max_so_far

# 示例
nums = [-2,1,-3,4,-1,2,1,-5,4]
print(max_subarray(nums))  # 输出 6
```

**解析：** 动态规划通过维护当前子数组的最大和 `curr_max` 和整个数组的最大和 `max_so_far`，在遍历过程中更新这两个值。这种方法的时间复杂度为O(n)。

### 13. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它应该被插入的位置。

**答案：** 使用二分查找。

**示例代码：**

```python
def search_insert(nums: List[int], target: int) -> int:
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left

# 示例
nums = [1,3,5,6]
target = 5
print(search_insert(nums, target))  # 输出 2
```

**解析：** 二分查找通过逐步缩小搜索范围来找到目标值或确定目标值的插入位置。这种方法的时间复杂度为O(log n)。

### 14. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：** 使用递归。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

# 示例
# 输入：list1 = [1,2,4], list2 = [1,3,4]
# 输出：[1,1,2,3,4,4]
```

**解析：** 通过递归地将两个链表的头部节点进行比较，将较小的节点连接到新的链表中，并递归地处理剩余的链表。这种方法的时间复杂度为O(n + m)，其中n和m分别是两个链表的长度。

### 15. 字符串中的第一个唯一字符

**题目：** 给你一个字符串 `s` ，请你返回 `s` 中第一个只出现一次的字符的索引。如果不存在，则返回 `-1`。

**答案：** 使用哈希表。

**示例代码：**

```python
def first_uniq_char(s: str) -> int:
    count = {}
    for c in s:
        count[c] = count.get(c, 0) + 1
    for i, c in enumerate(s):
        if count[c] == 1:
            return i
    return -1

# 示例
s = "leetcode"
print(first_uniq_char(s))  # 输出 0
```

**解析：** 通过遍历字符串并使用哈希表来记录每个字符的出现次数，然后再次遍历字符串并检查每个字符的出现次数。这种方法的时间复杂度为O(n)，空间复杂度也为O(n)。

### 16. 三数之和

**题目：** 给你一个整数数组 `nums` ，请你找出并返回三个数的和为 `0` 的索引三元组。不考虑顺序。

**答案：** 使用双指针。

**示例代码：**

```python
def three_sum(nums: List[int]) -> List[List[int]]:
    nums.sort()
    ans = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                ans.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return ans

# 示例
nums = [-1, 0, 1, 2, -1, -4]
print(three_sum(nums))  # 输出 [[-1, -1, 2], [-1, 0, 1]]
```

**解析：** 首先，对数组进行排序，然后使用双指针方法来查找三个数的和为0。这种方法的时间复杂度为O(n^2)，空间复杂度为O(1)。

### 17. 两数相加

**题目：** 给出两个 `non-null` 链表表示两个非负整数。每个节点包含一个数字，需要将这两个数相加并返回一个新的链表。

**答案：** 使用链表节点。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode(0)
        curr = dummy
        carry = 0
        while l1 or l2 or carry:
            val1 = (l1.val if l1 else 0)
            val2 = (l2.val if l2 else 0)
            total = val1 + val2 + carry
            carry = total // 10
            curr.next = ListNode(total % 10)
            curr = curr.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        return dummy.next

# 示例
# 输入：l1 = [2,4,3], l2 = [5,6,4]
# 输出：[7,0,7]
```

**解析：** 使用一个哑节点 `dummy`，然后遍历两个链表，计算当前节点的和，并将结果存储在新的链表中。如果当前和大于或等于10，则将进位值 `carry` 加到下一个节点。这种方法的时间复杂度为O(max(m, n))，其中m和n分别是两个链表的长度。

### 18. 寻找两个正序数组的中位数

**题目：** 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`，请你找出并返回这两个正序数组的**中位数**。

**答案：** 使用二分查找。

**示例代码：**

```python
def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    m, n = len(nums1), len(nums2)
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums2[j - 1] > nums1[i]:
            imin = i + 1
        elif i > 0 and nums1[i - 1] > nums2[j]:
            imax = i - 1
        else:
            if i == 0:
                max_of_left = nums2[j - 1]
            elif j == 0:
                max_of_left = nums1[i - 1]
            else:
                max_of_left = max(nums1[i - 1], nums2[j - 1])
            if (m + n) % 2 == 1:
                return max_of_left
            min_of_right = min(nums1[i], nums2[j])
            return (max_of_left + min_of_right) / 2

# 示例
nums1 = [1, 3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2))  # 输出 2.0
```

**解析：** 使用二分查找来找到两个数组的中位数。通过调整 `imin` 和 `imax` 的范围，找到两个数组的第 `k` 大元素。根据 `k` 的奇偶性，返回中位数。这种方法的时间复杂度为O(log(min(m, n)))。

### 19. 打家劫舍

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃能量的最大值是你从一栋房子向另一栋房子移动时消耗的能量。你需要从若干房屋中选出最多价值的一组房屋进行偷窃，而同一房屋只能在一个月内偷窃一次。请返回你能够偷窃到的最高金额。

**答案：** 使用动态规划。

**示例代码：**

```python
def rob(nums: List[int]) -> int:
    if len(nums) == 1:
        return nums[0]
    dp = [0] * len(nums)
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    for i in range(2, len(nums)):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
    return dp[-1]

# 示例
nums = [1, 2, 3, 1]
print(rob(nums))  # 输出 4
```

**解析：** 动态规划通过维护一个数组 `dp`，其中 `dp[i]` 表示从第 `i` 间房子开始能偷窃到的最高金额。每次更新 `dp[i]` 时，考虑前一间房子和前两间房子的最高金额。这种方法的时间复杂度为O(n)。

### 20. 三数之和

**题目：** 给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c`，使得 `a + b + c = 0`？找出所有满足条件且不重复的三元组。

**答案：** 使用排序和双指针。

**示例代码：**

```python
def three_sum(nums: List[int]) -> List[List[int]]:
    nums.sort()
    ans = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                ans.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
    return ans

# 示例
nums = [-1, 0, 1, 2, -1, -4]
print(three_sum(nums))  # 输出 [[-1, -1, 2], [-1, 0, 1]]
```

**解析：** 首先，对数组进行排序，然后使用双指针方法查找三元组。这种方法的时间复杂度为O(n^2)，空间复杂度为O(1)。

### 21. 合并两个有序链表

**题目：** 给你两个按升序排列的链表 `list1` 和 `list2`，请你将它们合并为一个新链表并返回。新链表同样按升序排列。

**答案：** 使用递归。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

# 示例
# 输入：list1 = [1,2,4], list2 = [1,3,4]
# 输出：[1,1,2,3,4,4]
```

**解析：** 通过递归地将两个链表的头部节点进行比较，将较小的节点连接到新的链表中，并递归地处理剩余的链表。这种方法的时间复杂度为O(n + m)，其中n和m分别是两个链表的长度。

### 22. 二叉搜索树的第 k 个节点

**题目：** 给定一个二叉搜索树的根节点 `root` 和一个整数 `k`，请你找出该树中第 `k` 个最小的节点。

**答案：** 中序遍历。

**示例代码：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kth_smallest(self, root: Optional[TreeNode], k: int) -> int:
        def dfs(root):
            if not root:
                return
            dfs(root.left)
            self.ans[k - 1] = root.val
            dfs(root.right)

        self.ans = [0] * k
        dfs(root)
        return self.ans[0]

# 示例
# 输入：root = [3,1,4,null,2], k = 2
# 输出：2
```

**解析：** 通过中序遍历二叉搜索树，可以得到一个有序的节点列表。在遍历过程中，找到第 `k` 个节点并返回。这种方法的时间复杂度为O(n)。

### 23. 有效的括号

**题目：** 给定一个字符串 `s` ，判断 `s` 是否为有效的括号字符串，其中 `(`、`)`、`{`、`}` 分别代表四种括号。

**答案：** 使用栈。

**示例代码：**

```python
def valid括号(s: str) -> bool:
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    for c in s:
        if c in pairs.values():
            stack.append(c)
        elif c in pairs and not stack or stack.pop() != pairs[c]:
            return False
    return not stack

# 示例
s = "()[]{}"
print(valid括号(s))  # 输出 True
```

**解析：** 通过使用栈来跟踪尚未匹配的括号。当遇到一个左括号时，将其入栈；当遇到一个右括号时，检查其对应的左括号是否在栈顶。如果匹配，则弹出栈顶元素。如果整个字符串遍历完毕，栈为空，则字符串有效。这种方法的时间复杂度为O(n)。

### 24. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：** 使用哈希表。

**示例代码：**

```python
def two_sum(nums: List[int], target: int) -> List[int]:
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []

# 示例
nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # 输出 [0, 1]
```

**解析：** 通过使用哈希表来存储遍历过的数字及其索引，每次遍历当前数字时，计算其与目标值的差值，并检查该差值是否已经在哈希表中。如果存在，则返回两个数字的索引。这种方法的时间复杂度为O(n)。

### 25. 合并两个有序链表

**题目：** 给定两个单链表，已知这两个链表是按升序排列的，请将这两个链表合并成一个按升序排列的链表。

**答案：** 使用递归。

**示例代码：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2
        if not list2:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

# 示例
# 输入：list1 = [1,2,4], list2 = [1,3,4]
# 输出：[1,1,2,3,4,4]
```

**解析：** 通过递归地将两个链表的头部节点进行比较，将较小的节点连接到新的链表中，并递归地处理剩余的链表。这种方法的时间复杂度为O(n + m)，其中n和m分别是两个链表的长度。

### 26. 寻找旋转排序数组中的最小值

**题目：** 已知一个长度为 `n` 的数组，假设这个数组中的数字已经按升序排列，你只需要查找并返回一个旋转数组中的最小元素。

**答案：** 使用二分查找。

**示例代码：**

```python
def find_min(nums: List[int]) -> int:
    left, right = 0, len(nums) - 1
    while left < right:
        mid = (left + right) // 2
        if nums[mid] > nums[right]:
            left = mid + 1
        else:
            right = mid
    return nums[left]

# 示例
nums = [4, 5, 6, 7, 0, 1, 2]
print(find_min(nums))  # 输出 0
```

**解析：** 通过二分查找，找到旋转点的位置，从而确定最小值的位置。这种方法的时间复杂度为O(log n)。

### 27. 字符串转换大写字母

**题目：** 将一个给定字符串`s`转换成大写形式。

**答案：** 使用字符串方法。

**示例代码：**

```python
def to_uppercase(s: str) -> str:
    return s.upper()

# 示例
s = "hello world"
print(to_uppercase(s))  # 输出 "HELLO WORLD"
```

**解析：** 通过使用字符串的 `upper()` 方法将字符串中的所有字符转换为大写。这种方法的时间复杂度为O(n)，其中n是字符串的长度。

### 28. 逆波兰表达式求值

**题目：** 使用逆波兰表示法（Reverse Polish Notation）求表达式的值。

**答案：** 使用栈。

**示例代码：**

```python
def eval_rpn(tokens: List[str]) -> int:
    stack = []
    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            elif token == "/":
                stack.append(int(a / b))
        else:
            stack.append(int(token))
    return stack[-1]

# 示例
tokens = ["2", "1", "+", "3", "*"]
print(eval_rpn(tokens))  # 输出 9
```

**解析：** 通过使用栈来实现逆波兰表达式的计算。遇到操作数时，将其入栈；遇到运算符时，弹出两个操作数进行计算，并将结果重新入栈。这种方法的时间复杂度为O(n)。

### 29. 判断两个字符串是否互为字符重排

**题目：** 编写一个方法，确定两个字符串是否互为字符重排。

**答案：** 使用哈希表。

**示例代码：**

```python
def is_anagram(s: str, t: str) -> bool:
    from collections import Counter
    return Counter(s) == Counter(t)

# 示例
s = "anagram"
t = "nagaram"
print(is_anagram(s, t))  # 输出 True
```

**解析：** 通过使用哈希表来记录字符串中每个字符的出现次数。如果两个字符串的字符出现次数完全相同，则它们互为字符重排。这种方法的时间复杂度为O(n)。

### 30. 二进制表示中质数个数

**题目：** 给定一个整数 `n`，计算它在二进制表示中质数的个数。

**答案：** 使用位操作。

**示例代码：**

```python
def count_primes(n: int) -> int:
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False
    for i in range(2, int(n ** 0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    return sum(is_prime)

# 示例
n = 10
print(count_primes(n))  # 输出 4
```

**解析：** 通过使用埃拉托斯特尼筛法来计算小于等于 `n` 的质数个数。对于每个质数 `i`，标记所有它的倍数为非质数。这种方法的时间复杂度为O(n log log n)。在计算二进制表示中质数个数时，将二进制表示转换为整数，然后使用上述方法计算。这种方法的时间复杂度为O(log n log log n)。

### 31. 设计循环队列

**题目：** 设计循环队列，实现 `MyCircularQueue` 类：

- `MyCircularQueue(k):` 构造一个大小为 `k` 的队列。
- `int front():` 从队列的开头返回元素。
- `int rear():` 返回队尾元素。
- `boolean enQueue(value):` 向循环队列中插入一个元素。如果成功，返回 `true` 。
- `boolean deQueue():` 从循环队列中删除一个元素。如果成功，返回 `true` 。
- `boolean isEmpty():` 如果队列是空的，返回 `true` 。
- `boolean isFull():` 如果队列是满的，返回 `true` 。

**答案：** 使用数组。

**示例代码：**

```python
class MyCircularQueue:

    def __init__(self, k: int):
        self.queue = [None] * k
        self.head = self.tail = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.tail] = value
        self.tail = (self.tail + 1) % len(self.queue)
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.head = (self.head + 1) % len(self.queue)
        self.queue[self.head] = None
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.head]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.tail - 1]

    def isEmpty(self) -> bool:
        return self.head == self.tail

    def isFull(self) -> bool:
        return (self.tail + 1) % len(self.queue) == self.head

# 示例
queue = MyCircularQueue(3)
queue.enQueue(1)
queue.enQueue(2)
print(queue.Rear())  # 输出 2
queue.deQueue()
print(queue.Front())  # 输出 1
queue.enQueue(3)
queue.enQueue(4)
print(queue.Rear())  # 输出 4
print(queue.isFull())  # 输出 True
queue.deQueue()
print(queue.Front())  # 输出 3
```

**解析：** 通过使用数组实现循环队列，数组的首元素和尾元素分别由 `head` 和 `tail` 指针指向。当插入元素时，尾指针向后移动；当删除元素时，头指针向后移动。当尾指针移动到数组的末尾时，尾指针重新指向数组的开头。这种方法的时间复杂度为O(1)。

### 32. 单调栈

**题目：** 实现一个单调栈，可以用来解决以下问题：

- 给定一个数组 `nums`，找到每个元素对应的最小值。
- 给定一个数组 `nums`，找到每个元素对应的最大值。

**答案：** 使用栈。

**示例代码：**

```python
def get_min_max(nums):
    min_values = []
    max_values = []
    stack = []
    for num in nums:
        while stack and stack[-1] > num:
            stack.pop()
        min_values.append(stack[-1] if stack else num)
        stack.append(num)
        while stack and stack[-1] < num:
            stack.pop()
        max_values.append(stack[-1] if stack else num)
        stack.append(num)
    return min_values, max_values

# 示例
nums = [3, 4, 2, 1]
min_values, max_values = get_min_max(nums)
print(min_values)  # 输出 [2, 2, 1, 1]
print(max_values)  # 输出 [3, 4, 3, 2]
```

**解析：** 通过维护一个单调栈，我们可以找到每个元素对应的最小值和最大值。当遍历到一个元素时，将其与栈顶元素进行比较，如果小于或大于栈顶元素，则弹出栈顶元素。这样，栈顶元素始终是当前元素对应的最小值或最大值。这种方法的时间复杂度为O(n)。

### 33. 设计一个支持异步操作的并发队列

**题目：** 设计一个支持异步操作的并发队列，可以用来实现以下操作：

- `enqueue(element):` 将元素添加到队列的末尾。
- `dequeue():` 从队列的开头删除元素。
- `peek():` 返回队列开头的元素，但不要删除它。
- `isEmpty():` 返回队列是否为空。

**答案：** 使用条件变量。

**示例代码：**

```python
import threading
import queue

class AsyncQueue:
    def __init__(self):
        self.q = queue.Queue()
        self.lock = threading.Condition()

    def enqueue(self, element):
        with self.lock:
            self.q.put(element)
            self.lock.notify()

    def dequeue(self):
        with self.lock:
            while self.q.empty():
                self.lock.wait()
            return self.q.get()

    def peek(self):
        with self.lock:
            if self.q.empty():
                return None
            return self.q.queue[0]

    def isEmpty(self):
        with self.lock:
            return self.q.empty()

# 示例
async_queue = AsyncQueue()
async_queue.enqueue(1)
async_queue.enqueue(2)
print(async_queue.dequeue())  # 输出 1
print(async_queue.peek())     # 输出 2
print(async_queue.isEmpty())  # 输出 False
```

**解析：** 通过使用条件变量和队列，我们可以实现一个支持异步操作的并发队列。当添加元素时，使用条件变量通知等待的线程；当删除元素时，如果队列已空，则线程等待。这种方法的时间复杂度为O(1)。

### 34. 设计哈希链表

**题目：** 设计一个哈希链表，包含以下操作：

- `put(key, value)`：向哈希表中插入一个键值对。
- `get(key)`：返回哈希表中特定键的值。
- `remove(key)`：从哈希表中删除一个特定的键值对。

**答案：** 使用哈希表和链表。

**示例代码：**

```python
class ListNode:
    def __init__(self, key=0, value=0, next=None):
        self.key = key
        self.value = value
        self.next = next

class HashLinkedList:
    def __init__(self, size=1000):
        self.size = size
        self.buckets = [None] * size

    def hash(self, key):
        return hash(key) % self.size

    def put(self, key, value):
        index = self.hash(key)
        node = self.buckets[index]
        if node is None:
            self.buckets[index] = ListNode(key, value)
        else:
            while node.next:
                if node.key == key:
                    node.value = value
                    return
                node = node.next
            node.next = ListNode(key, value)

    def get(self, key):
        index = self.hash(key)
        node = self.buckets[index]
        while node:
            if node.key == key:
                return node.value
            node = node.next
        return None

    def remove(self, key):
        index = self.hash(key)
        node = self.buckets[index]
        prev = None
        while node:
            if node.key == key:
                if prev:
                    prev.next = node.next
                else:
                    self.buckets[index] = node.next
                return
            prev = node
            node = node.next
        return

# 示例
hash_list = HashLinkedList()
hash_list.put(1, "value1")
hash_list.put(2, "value2")
print(hash_list.get(1))  # 输出 "value1"
hash_list.remove(1)
print(hash_list.get(1))  # 输出 None
```

**解析：** 通过使用哈希表和链表，我们可以实现一个哈希链表。当插入或删除键值对时，我们首先计算键的哈希值，然后在相应的链表中找到或更新节点。这种方法的时间复杂度为O(1)。

### 35. 设计一个优先级队列

**题目：** 设计一个优先级队列，可以使用以下方法：

- `push(val, priority):` 将元素 `val` 以 `priority` 作为优先级插入到队列中。
- `pop():` 从队列中删除并返回具有最高优先级的元素。
- `top():` 从队列中返回具有最高优先级的元素，但不删除它。
- `isEmpty():` 检查队列是否为空。

**答案：** 使用优先队列。

**示例代码：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.q = []
        self.current = 0

    def push(self, val, priority):
        heapq.heappush(self.q, (-priority, self.current, val))
        self.current += 1

    def pop(self):
        if self.isEmpty():
            return None
        _, _, val = heapq.heappop(self.q)
        return val

    def top(self):
        if self.isEmpty():
            return None
        return self.q[0][2]

    def isEmpty(self):
        return len(self.q) == 0

# 示例
pq = PriorityQueue()
pq.push(1, 2)
pq.push(2, 1)
print(pq.pop())  # 输出 1
print(pq.top())  # 输出 2
print(pq.isEmpty())  # 输出 False
```

**解析：** 通过使用优先队列和堆，我们可以实现一个优先级队列。插入元素时，将元素和其优先级作为一个三元组入堆；删除元素时，从堆中取出具有最高优先级的元素。这种方法的时间复杂度为O(log n)。

### 36. 设计一个最小栈

**题目：** 设计一个最小栈，包含以下操作：

- `push(val):` 将元素 `val` 推入栈顶。
- `pop():` 移除栈顶元素。
- `top():` 返回栈顶元素。
- `getMin():` 返回栈中的最小元素。

**答案：** 使用两个栈。

**示例代码：**

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

# 示例
minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
print(minStack.getMin())  # 输出 -3
minStack.pop()
print(minStack.top())  # 输出 0
print(minStack.getMin())  # 输出 -2
```

**解析：** 通过使用两个栈，我们可以实现一个最小栈。主栈用于存储所有元素，最小栈用于存储当前的最小元素。当插入元素时，如果该元素小于或等于最小栈的栈顶元素，则将其入栈；当删除元素时，如果被删除的元素等于最小栈的栈顶元素，则将其出栈。这种方法的时间复杂度为O(1)。

### 37. 设计一个最近最少使用（LRU）缓存

**题目：** 设计一个最近最少使用（LRU）缓存，具有以下功能：

- `init capacity`: 初始化缓存容量。
- `get(key)`: 如果缓存中（key，value）存在，则返回value值，否则返回-1。
- `put(key, value)`: 如果key已存在，则更新其数据值；如果key不存在且缓存容量未达到上限，则插入键值对。

**答案：** 使用哈希表和双向链表。

**示例代码：**

```python
from collections import deque

class Node:
    def __init__(self, key, val):
        self.key = key
        self.val = val
        self.next = None
        self.prev = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(0, 0)
        self.tail = Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)
        self._add(node)
        return node.val

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        self.cache[key] = self._add(Node(key, value))
        if len(self.cache) > self.capacity:
            del self.cache[self.tail.prev.key]
            self._remove(self.tail.prev)

    def _add(self, node):
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
        return node

    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
        return node

# 示例
lru_cache = LRUCache(2)
lru_cache.put(1, 1)
lru_cache.put(2, 2)
print(lru_cache.get(1))  # 输出 1
lru_cache.put(3, 3)
print(lru_cache.get(2))  # 输出 -1
```

**解析：** 通过使用哈希表和双向链表，我们可以实现一个最近最少使用（LRU）缓存。当获取或插入元素时，将其移动到链表的前端；当缓存达到上限时，删除链表的末尾元素。这种方法的时间复杂度为O(1)。

### 38. 设计一个堆

**题目：** 设计一个堆，支持以下操作：

- `push(val)`: 将元素 `val` 插入堆中。
- `pop()`: 删除堆顶元素并返回它。
- `top()`: 返回堆顶元素，但不删除它。

**答案：** 使用Python内置的heapq模块。

**示例代码：**

```python
import heapq

class Heap:
    def __init__(self):
        self.heap = []

    def push(self, val):
        heapq.heappush(self.heap, val)

    def pop(self):
        return heapq.heappop(self.heap)

    def top(self):
        return self.heap[0] if self.heap else None

# 示例
heap = Heap()
heap.push(5)
heap.push(3)
heap.push(7)
print(heap.top())  # 输出 3
print(heap.pop())  # 输出 3
print(heap.top())  # 输出 5
```

**解析：** 通过使用Python内置的heapq模块，我们可以实现一个堆。插入元素时使用 `heappush()`，删除堆顶元素时使用 `heappop()`，获取堆顶元素时使用 `heap[0]`。这种方法的时间复杂度为O(log n)。

### 39. 设计一个优先级队列

**题目：** 设计一个优先级队列，支持以下操作：

- `push(val, priority)`: 将元素 `val` 和其优先级 `priority` 插入队列中。
- `pop()`: 删除并返回具有最高优先级的元素。
- `top()`: 返回具有最高优先级的元素，但不删除它。

**答案：** 使用Python内置的heapq模块。

**示例代码：**

```python
import heapq

class PriorityQueue:
    def __init__(self):
        self.heap = []

    def push(self, val, priority):
        heapq.heappush(self.heap, (-priority, val))

    def pop(self):
        return heapq.heappop(self.heap)[-1]

    def top(self):
        return self.heap[0][-1] if self.heap else None

# 示例
pq = PriorityQueue()
pq.push(1, 2)
pq.push(2, 1)
print(pq.top())  # 输出 2
print(pq.pop())  # 输出 2
print(pq.top())  # 输出 1
```

**解析：** 通过使用Python内置的heapq模块，我们可以实现一个优先级队列。插入元素时使用 `heappush()`，删除堆顶元素时使用 `heappop()`，获取堆顶元素时使用 `heap[0]`。这种方法的时间复杂度为O(log n)。

### 40. 设计一个位运算转换器

**题目：** 设计一个位运算转换器，支持以下操作：

- `add(num1, num2)`: 将两个数进行位运算加法。
- `sub(num1, num2)`: 将两个数进行位运算减法。
- `mul(num1, num2)`: 将两个数进行位运算乘法。
- `div(num1, num2)`: 将两个数进行位运算除法。

**答案：** 使用位运算。

**示例代码：**

```python
class BitOperationConverter:
    def add(self, num1: int, num2: int) -> int:
        while num2:
            carry = num1 & num2
            num1 = num1 ^ num2
            num2 = carry << 1
        return num1

    def sub(self, num1: int, num2: int) -> int:
        while num2:
            borrow = (~num1) & num2
            num1 = num1 ^ num2
            num2 = borrow << 1
        return num1

    def mul(self, num1: int, num2: int) -> int:
        result = 0
        while num2:
            if num2 & 1:
                result = self.add(result, num1)
            num1 <<= 1
            num2 >>= 1
        return result

    def div(self, num1: int, num2: int) -> int:
        if num1 < num2:
            return 0
        result = 0
        while num1 >= num2:
            num2 <<= 1
            result <<= 1
        while num1 > 0:
            if num1 >= num2:
                num1 = self.sub(num1, num2)
                result = self.add(result, 1)
            num2 >>= 1
        return result

# 示例
bit_operation_converter = BitOperationConverter()
print(bit_operation_converter.add(3, 5))  # 输出 8
print(bit_operation_converter.sub(7, 3))  # 输出 4
print(bit_operation_converter.mul(3, 5))  # 输出 15
print(bit_operation_converter.div(10, 2))  # 输出 5
```

**解析：** 通过使用位运算，我们可以实现基本的加、减、乘、除操作。对于除法，我们使用长除法算法。这种方法的时间复杂度为O(log n)。

### 41. 设计一个数组缓存

**题目：** 设计一个数组缓存，支持以下操作：

- `init(capacity)`: 初始化缓存容量。
- `get(index)`: 如果缓存中存在 `index`，返回其值，否则返回 -1。
- `set(index, value)`: 如果缓存中不存在 `index`，且缓存容量未达到上限，则插入该键值对。

**答案：** 使用哈希表。

**示例代码：**

```python
class ArrayCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.array = [-1] * capacity

    def get(self, index: int) -> int:
        if index < 0 or index >= self.capacity:
            return -1
        if index in self.cache:
            return self.array[index]
        return -1

    def set(self, index: int, value: int) -> None:
        if index < 0 or index >= self.capacity:
            return
        if index in self.cache:
            self.array[index] = value
        else:
            self.cache[index] = value
            self.array[index] = value
            if len(self.cache) > self.capacity:
                del self.cache[self.array[0]]
                self.array.pop(0)

# 示例
cache = ArrayCache(3)
cache.set(0, 1)
cache.set(1, 2)
print(cache.get(0))  # 输出 1
print(cache.get(2))  # 输出 -1
cache.set(1, 3)
print(cache.get(0))  # 输出 -1
print(cache.get(1))  # 输出 3
```

**解析：** 通过使用哈希表和数组，我们可以实现一个数组缓存。当获取元素时，检查哈希表是否存在该键；当设置元素时，检查哈希表和数组的容量。这种方法的时间复杂度为O(1)。

### 42. 设计一个单调栈

**题目：** 设计一个单调栈，支持以下操作：

- `push(val)`: 将元素 `val` 入栈。
- `pop()`: 出栈。
- `min()`: 返回当前栈中的最小值。

**答案：** 使用两个栈。

**示例代码：**

```python
class MonotonicStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val):
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
        self.stack.append(val)

    def pop(self):
        if self.stack:
            if self.stack[-1] == self.min_stack[-1]:
                self.min_stack.pop()
            return self.stack.pop()
        return None

    def min(self):
        return self.min_stack[-1] if self.min_stack else None

# 示例
mono_stack = MonotonicStack()
mono_stack.push(3)
mono_stack.push(2)
print(mono_stack.min())  # 输出 2
mono_stack.push(1)
print(mono_stack.min())  # 输出 1
mono_stack.pop()
print(mono_stack.min())  # 输出 2
```

**解析：** 通过使用两个栈，我们可以实现一个单调栈。主栈用于存储所有元素，最小栈用于存储当前的最小值。当插入元素时，如果该元素小于或等于最小栈的栈顶元素，则将其入栈；当删除元素时，如果被删除的元素等于最小栈的栈顶元素，则将其出栈。这种方法的时间复杂度为O(1)。

### 43. 设计一个单调队列

**题目：** 设计一个单调队列，支持以下操作：

- `push(val)`: 将元素 `val` 入队。
- `pop()`: 出队。
- `max()`: 返回当前队列中的最大值。

**答案：** 使用两个队列。

**示例代码：**

```python
from collections import deque

class MonotonicQueue:
    def __init__(self):
        self.queue = deque()
        self.max_queue = deque()

    def push(self, val):
        while self.max_queue and self.max_queue[-1] < val:
            self.max_queue.pop()
        self.max_queue.append(val)
        self.queue.append(val)

    def pop(self):
        if self.queue:
            if self.queue[0] == self.max_queue[0]:
                self.max_queue.popleft()
            return self.queue.popleft()
        return None

    def max(self):
        return self.max_queue[0] if self.max_queue else None

# 示例
mono_queue = MonotonicQueue()
mono_queue.push(1)
mono_queue.push(3)
print(mono_queue.max())  # 输出 3
mono_queue.push(2)
print(mono_queue.max())  # 输出 3
mono_queue.pop()
print(mono_queue.max())  # 输出 2
```

**解析：** 通过使用两个队列，我们可以实现一个单调队列。主队列用于存储所有元素，最大队列用于存储当前的最大值。当插入元素时，如果该元素大于最大队列的栈顶元素，则将其入队；当删除元素时，如果被删除的元素等于最大队列的栈顶元素，则将其出队。这种方法的时间复杂度为O(1)。

### 44. 设计一个LRU缓存

**题目：** 设计一个LRU（Least Recently Used）缓存，具有以下功能：

- `init(capacity)`: 初始化缓存容量。
- `get(key)`: 如果缓存中存在 `key`，返回其值，否则返回 `-1`。
- `put(key, value)`: 向缓存中插入 `key` 和 `value`，如果缓存已满，则删除最近未使用的元素。

**答案：** 使用哈希表和双向链表。

**示例代码：**

```python
from collections import deque

class DLinkedNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = DLinkedNode()
        self.tail = DLinkedNode()
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._remove(node)
        self._add(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        node = DLinkedNode(key, value)
        self.cache[key] = node
        self._add(node)
        if len(self.cache) > self.capacity:
            del_key = self.tail.prev.key
            self._remove(self.tail.prev)
            del self.cache[del_key]

    def _add(self, node):
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

# 示例
lru_cache = LRUCache(2)
lru_cache.put(1, 1)
lru_cache.put(2, 2)
print(lru_cache.get(1))  # 输出 1
lru_cache.put(3, 3)
print(lru_cache.get(2))  # 输出 -1
lru_cache.put(4, 4)
print(lru_cache.get(1))  # 输出 -1
print(lru_cache.get(3))  # 输出 3
print(lru_cache.get(4))  # 输出 4
```

**解析：** 通过使用哈希表和双向链表，我们可以实现一个LRU缓存。当获取或插入元素时，将其移动到链表的前端；当缓存达到上限时，删除链表的末尾元素。这种方法的时间复杂度为O(1)。

### 45. 设计一个LRU缓存（使用Python的OrderedDict）

**题目：** 使用Python的`OrderedDict`实现一个LRU缓存，具有以下功能：

- `init(capacity)`: 初始化缓存容量。
- `get(key)`: 如果缓存中存在 `key`，返回其值，否则返回 `-1`。
- `put(key, value)`: 向缓存中插入 `key` 和 `value`，如果缓存已满，则删除最近未使用的元素。

**答案：** 使用Python的`OrderedDict`。

**示例代码：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

# 示例
lru_cache = LRUCache(2)
lru_cache.put(1, 1)
lru_cache.put(2, 2)
print(lru_cache.get(1))  # 输出 1
lru_cache.put(3, 3)
print(lru_cache.get(2))  # 输出 -1
lru_cache.put(4, 4)
print(lru_cache.get(1))  # 输出 -1
print(lru_cache.get(3))  # 输出 3
print(lru_cache.get(4))  # 输出 4
```

**解析：** 通过使用Python的`OrderedDict`，我们可以实现一个LRU缓存。`OrderedDict` 自动维护键的插入顺序，我们可以通过 `move_to_end` 方法将最近使用的键移动到字典的末尾。当缓存达到上限时，自动删除字典的开头键值对。这种方法的时间复杂度为O(1)。

### 46. 设计一个并发安全的LRU缓存

**题目：** 设计一个并发安全的LRU缓存，具有以下功能：

- `init(capacity)`: 初始化缓存容量。
- `get(key)`: 如果缓存中存在 `key`，返回其值，否则返回 `-1`。
- `put(key, value)`: 向缓存中插入 `key` 和 `value`，如果缓存已满，则删除最近未使用的元素。

**答案：** 使用线程锁。

**示例代码：**

```python
from collections import OrderedDict
import threading

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()
        self.lock = threading.Lock()

    def get(self, key: int) -> int:
        with self.lock:
            if key not in self.cache:
                return -1
            self.cache.move_to_end(key)
            return self.cache[key]

    def put(self, key: int, value: int) -> None:
        with self.lock:
            if key in self.cache:
                self.cache.move_to_end(key)
            self.cache[key] = value
            if len(self.cache) > self.capacity:
                self.cache.popitem(last=False)

# 示例
lru_cache = LRUCache(2)
lru_cache.put(1, 1)
lru_cache.put(2, 2)
print(lru_cache.get(1))  # 输出 1
lru_cache.put(3, 3)
print(lru_cache.get(2))  # 输出 -1
lru_cache.put(4, 4)
print(lru_cache.get(1))  # 输出 -1
print(lru_cache.get(3))  # 输出 3
print(lru_cache.get(4))  # 输出 4
```

**解析：** 通过使用线程锁，我们可以确保在多线程环境下LRU缓存的操作是并发安全的。`OrderedDict` 同样用于维护键的插入顺序。当缓存达到上限时，自动删除字典的开头键值对。这种方法的时间复杂度为O(1)。

### 47. 设计一个线程安全的优先级队列

**题目：** 设计一个线程安全的优先级队列，支持以下操作：

- `push(val, priority)`: 将元素 `val` 和其优先级 `priority` 插入队列中。
- `pop()`: 删除并返回具有最高优先级的元素。
- `top()`: 返回具有最高优先级的元素，但不删除它。

**答案：** 使用线程锁。

**示例代码：**

```python
import heapq
import threading

class ThreadSafePriorityQueue:
    def __init__(self):
        self.heap = []
        self.lock = threading.Lock()

    def push(self, val, priority):
        with self.lock:
            heapq.heappush(self.heap, (-priority, val))

    def pop(self):
        with self.lock:
            if not self.heap:
                return None
            return heapq.heappop(self.heap)[-1]

    def top(self):
        with self.lock:
            if not self.heap:
                return None
            return self.heap[0][-1]

# 示例
pq = ThreadSafePriorityQueue()
pq.push(1, 2)
pq.push(2, 1)
print(pq.top())  # 输出 2
print(pq.pop())  # 输出 2
print(pq.top())  # 输出 1
```

**解析：** 通过使用线程锁，我们可以确保在多线程环境下优先级队列的操作是线程安全的。使用内置的heapq模块实现优先级队列。插入元素时使用 `heappush()`，删除堆顶元素时使用 `heappop()`，获取堆顶元素时使用 `heap[0]`。这种方法的时间复杂度为O(log n)。

### 48. 设计一个堆排序

**题目：** 设计一个堆排序，支持以下操作：

- `buildHeap(nums)`: 构建一个最大堆。
- `sort(nums)`: 对数组 `nums` 进行堆排序。

**答案：** 使用Python的heapq模块。

**示例代码：**

```python
import heapq

def buildHeap(nums):
    heapq.heapify(nums)

def sort(nums):
    buildHeap(nums)
    n = len(nums)
    for i in range(n - 1, 0, -1):
        nums[0], nums[i] = nums[i], nums[0]
        heapq.heapify(nums[:-1])

# 示例
nums = [4, 10, 3, 5, 1]
sort(nums)
print(nums)  # 输出 [1, 3, 4, 5, 10]
```

**解析：** 通过使用Python的heapq模块，我们可以实现堆排序。首先使用 `heapify()` 函数构建最大堆，然后遍历数组，每次交换堆顶元素（最大值）和数组末尾元素，然后重新构建剩余数组的堆。这种方法的时间复杂度为O(n log n)。

### 49. 设计一个堆分配器

**题目：** 设计一个堆分配器，支持以下操作：

- `allocate(size)`: 分配一个大小为 `size` 的内存块，返回内存块的首地址。
- `free(ptr)`: 释放地址为 `ptr` 的内存块。

**答案：** 使用Python的heapq模块。

**示例代码：**

```python
import heapq

class MemoryAllocator:
    def __init__(self):
        self.freelist = []
        self.heap = []

    def allocate(self, size):
        if not self.freelist:
            return -1
        address = self.freelist[0]
        heapq.heappush(self.heap, (-address, size))
        self.freelist[0] += size
        if self.freelist[0] > self.heap[0][1]:
            self.heap[0] = (-self.heap[0][0], self.freelist[0])
        self.freelist.pop(0)
        return address

    def free(self, ptr):
        if ptr not in self.heap:
            return
        new_free = self.heap[0][0] + self.heap[0][1]
        self.heap[0] = (ptr, new_free)
        heapq.heapify(self.heap)
        self.freelist.append(new_free)

# 示例
allocator = MemoryAllocator()
print(allocator.allocate(5))  # 输出 0
print(allocator.allocate(3))  # 输出 5
allocator.free(5)
print(allocator.allocate(2))  # 输出 8
```

**解析：** 通过使用Python的heapq模块，我们可以实现一个堆分配器。当分配内存时，从自由列表中获取一个地址，并将其加入堆中。当释放内存时，更新堆并重新构建自由列表。这种方法的时间复杂度为O(log n)。

### 50. 设计一个最小堆

**题目：** 设计一个最小堆，支持以下操作：

- `push(val)`: 将元素 `val` 插入堆中。
- `pop()`: 删除堆顶元素并返回它。
- `top()`: 返回堆顶元素，但不删除它。

**答案：** 使用Python的heapq模块。

**示例代码：**

```python
import heapq

class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, val):
        heapq.heappush(self.heap, val)

    def pop(self):
        return heapq.heappop(self.heap)

    def top(self):
        return self.heap[0]

# 示例
min_heap = MinHeap()
min_heap.push(5)
min_heap.push(3)
print(min_heap.top())  # 输出 3
print(min_heap.pop())  # 输出 3
print(min_heap.top())  # 输出 5
```

**解析：** 通过使用Python的heapq模块，我们可以实现一个最小堆。插入元素时使用 `heappush()`，删除堆顶元素时使用 `heappop()`，获取堆顶元素时使用 `heap[0]`。这种方法的时间复杂度为O(log n)。

