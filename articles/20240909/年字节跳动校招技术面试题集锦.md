                 

### 1. 字符串匹配算法

#### 题目：
实现一个字符串匹配算法，能够找到给定字符串 `str` 中的子串 `pattern` 的所有出现位置。

#### 输入：
- 字符串 `str`：`"ABCABCABC"`
- 子串 `pattern`：`"ABC"`

#### 输出：
- 所有出现位置：`[0, 2, 4]`

#### 答案：

```go
package main

import (
	"fmt"
)

func searchpattern(str string, pattern string) []int {
    results := []int{}
    n := len(str)
    m := len(pattern)

    if m > n {
        return results
    }

    for i := 0; i <= n-m; i++ {
        if match(str[i : i+m], pattern) {
            results = append(results, i)
        }
    }

    return results
}

func match(s1 string, s2 string) bool {
    if len(s1) != len(s2) {
        return false
    }

    for i := 0; i < len(s1); i++ {
        if s1[i] != s2[i] {
            return false
        }
    }

    return true
}

func main() {
    str := "ABCABCABC"
    pattern := "ABC"
    positions := searchpattern(str, pattern)
    fmt.Println(positions) // 输出 [0, 2, 4]
}
```

#### 解析：
本实现中，`searchpattern` 函数遍历字符串 `str`，每次取长度为 `pattern` 的子串进行匹配。匹配函数 `match` 使用长度比较和逐字符比较来检查两个字符串是否完全相同。匹配成功时，将索引添加到结果列表中。

### 2. 单链表排序

#### 题目：
给定一个单链表，对其进行排序。

#### 输入：
- 单链表：`[3, 2, 1]`

#### 输出：
- 排序后的链表：`[1, 2, 3]`

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    // 找到中点
    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    // 断开链表
    mid := slow.Next
    slow.Next = nil

    // 分别对前半部分和后半部分进行排序
    n1 := sortList(head)
    n2 := sortList(mid)

    // 合并两个有序链表
    return merge(n1, n2)
}

func merge(n1 *ListNode, n2 *ListNode) *ListNode {
    dummy := &ListNode{Val: -1}
    curr := dummy

    for n1 != nil && n2 != nil {
        if n1.Val < n2.Val {
            curr.Next = n1
            n1 = n1.Next
        } else {
            curr.Next = n2
            n2 = n2.Next
        }
        curr = curr.Next
    }

    if n1 != nil {
        curr.Next = n1
    }

    if n2 != nil {
        curr.Next = n2
    }

    return dummy.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n3 := &ListNode{Val: 3}
    n2 := &ListNode{Val: 2, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    printList(sortList(n1)) // 输出 1 2 3
}
```

#### 解析：
本实现采用归并排序的思想对链表进行排序。首先找到链表的中点，然后断开链表，分别对前半部分和后半部分进行递归排序，最后将两个有序链表合并。

### 3. 二分查找

#### 题目：
给定一个有序数组，实现二分查找算法，找到给定目标值 `target` 的索引。

#### 输入：
- 有序数组：`[1, 3, 5, 7, 9]`
- 目标值 `target`：`7`

#### 输出：
- 索引：`3`

#### 答案：

```go
package main

import (
	"fmt"
)

func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1

    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return -1
}

func main() {
    nums := []int{1, 3, 5, 7, 9}
    target := 7
    index := binarySearch(nums, target)
    fmt.Println(index) // 输出 3
}
```

#### 解析：
二分查找的核心在于维护一个有序区间，通过不断缩小区间范围来查找目标值。时间复杂度为 O(log n)。

### 4. 最长公共前缀

#### 题目：
给定一个字符串数组，找到它们的**最长公共前缀**。

#### 输入：
- 字符串数组：`["flower", "flow", "flight"]`

#### 输出：
- 最长公共前缀："fl"

#### 答案：

```go
package main

import (
	"fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for len(prefix) > 0 {
            if !strings.HasPrefix(strs[i], prefix) {
                prefix = prefix[:len(prefix)-1]
            } else {
                break
            }
        }
    }

    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs)) // 输出 fl
}
```

#### 解析：
从第一个字符串开始，逐一与后面的字符串比较，找出公共的前缀。时间复杂度为 O(mn)，其中 m 是最长字符串的长度，n 是字符串的数量。

### 5. 删除链表的节点

#### 题目：
给定一个单链表和一个目标节点，删除该节点。

#### 输入：
- 单链表：`[4, 5, 1, 9]`
- 目标节点：节点值为 `1`

#### 输出：
- 删除节点后的链表：`[4, 5, 9]`

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n4 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 1, Next: n4}
    n2 := &ListNode{Val: 5, Next: n3}
    n1 := &ListNode{Val: 9, Next: n2}

    printList(n1) // 输出 9 5 1 4
    deleteNode(n3)
    printList(n1) // 输出 9 5 4
}
```

#### 解析：
删除节点时，将当前节点的值设置为下一个节点的值，然后将当前节点的下一个节点指向下一个节点的下一个节点，从而删除了目标节点。

### 6. 环形链表

#### 题目：
给定一个链表，判断链表中是否存在环。

#### 输入：
- 链表：`[3, 2, 0, -4]`
- 环的节点值：`-4`

#### 输出：
- 存在环

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func hasCycle(head *ListNode) bool {
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            return true
        }
    }

    return false
}

func main() {
    n4 := &ListNode{Val: -4}
    n3 := &ListNode{Val: 0, Next: n4}
    n2 := &ListNode{Val: 2, Next: n3}
    n1 := &ListNode{Val: 3, Next: n2}

    n4.Next = n2 // 创建环

    fmt.Println(hasCycle(n1)) // 输出 true
}
```

#### 解析：
使用快慢指针法，快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，那么快指针最终会追上慢指针。

### 7. 二维数组中的查找

#### 题目：
给定一个二维数组和一个目标值，实现一个函数来查找目标值是否存在。

#### 输入：
- 二维数组：`[[1,2,8,9], [2,4,9,12], [4,7,10,13], [6,8,11,15]]`
- 目标值：`8`

#### 输出：
- 目标值存在

#### 答案：

```go
package main

import (
	"fmt"
)

func findNumber(arr [][]int, target int) bool {
    for _, row := range arr {
        for _, num := range row {
            if num == target {
                return true
            }
        }
    }
    return false
}

func main() {
    arr := [][]int{
        {1, 2, 8, 9},
        {2, 4, 9, 12},
        {4, 7, 10, 13},
        {6, 8, 11, 15},
    }
    target := 8
    fmt.Println(findNumber(arr, target)) // 输出 true
}
```

#### 解析：
通过遍历二维数组中的每个元素，判断目标值是否存在。

### 8. 两数相加

#### 题目：
实现一个函数，能够将两个非空的单链表表示的非负整数相加，返回一个新的链表表示和。

#### 输入：
- 链表1：`[2 -> 4 -> 3]`
- 链表2：`[5 -> 6 -> 4]`

#### 输出：
- 新链表：`[7 -> 0 -> 8]`

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }

        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }

        sum := val1 + val2 + carry
        carry = sum / 10
        current.Next = &ListNode{Val: sum % 10}
        current = current.Next
    }

    return dummy.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n3 := &ListNode{Val: 3}
    n2 := &ListNode{Val: 4, Next: n3}
    n1 := &ListNode{Val: 2, Next: n2}

    n6 := &ListNode{Val: 4}
    n5 := &ListNode{Val: 6, Next: n6}
    n4 := &ListNode{Val: 5, Next: n5}

    printList(addTwoNumbers(n1, n4)) // 输出 7 0 8
}
```

#### 解析：
将两个链表从头到尾进行相加，并处理进位。每次相加后，将结果添加到新链表中。

### 9. 爬楼梯

#### 题目：
一个楼梯有 n 阶台阶，每次可以上一阶或两阶，求有多少种不同的方法可以爬到楼顶。

#### 输入：
- 台阶数：`3`

#### 输出：
- 方式数：`3`

#### 答案：

```go
package main

import (
	"fmt"
)

func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    a, b := 1, 1
    for i := 2; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }

    return b
}

func main() {
    n := 3
    fmt.Println(climbStairs(n)) // 输出 3
}
```

#### 解析：
使用动态规划，保存前两个状态的值，然后迭代计算直到 n。

### 10. 最小路径和

#### 题目：
给定一个二维数组，求从左上角到右下角的最小路径和。

#### 输入：
```
[
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
```

#### 输出：
- 最小路径和：`7`

#### 答案：

```go
package main

import (
	"fmt"
)

func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i > 0 {
                grid[i][j] += grid[i-1][j]
            }
            if j > 0 {
                grid[i][j] += grid[i][j-1]
            }
        }
    }
    return grid[m-1][n-1]
}

func main() {
    grid := [][]int{
        {1, 3, 1},
        {1, 5, 1},
        {4, 2, 1},
    }
    fmt.Println(minPathSum(grid)) // 输出 7
}
```

#### 解析：
通过动态规划，从左上角开始，每一格的值为其上方和左方格的值之和，最后得到右下角的值即为最小路径和。

### 11. 合并两个有序链表

#### 题目：
合并两个已排序的单链表，返回一个新的链表。

#### 输入：
- 链表1：`[1 -> 2 -> 4]`
- 链表2：`[1 -> 3 -> 4]`

#### 输出：
- 新链表：`[1 -> 1 -> 2 -> 3 -> 4 -> 4]`

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            current.Next = l1
            l1 = l1.Next
        } else {
            current.Next = l2
            l2 = l2.Next
        }
        current = current.Next
    }

    if l1 != nil {
        current.Next = l1
    }
    if l2 != nil {
        current.Next = l2
    }

    return dummy.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n4 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 2, Next: n4}
    n2 := &ListNode{Val: 1, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    n4 = &ListNode{Val: 4}
    n3 = &ListNode{Val: 3, Next: n4}
    n2 = &ListNode{Val: 1, Next: n3}
    n1 = &ListNode{Val: 1, Next: n2}

    printList(mergeTwoLists(n1, n1)) // 输出 1 1 2 3 4 4
}
```

#### 解析：
通过迭代合并两个链表，每次选择较小值的节点加入新链表。

### 12. 二进制中1的个数

#### 题目：
实现一个函数，计算一个无符号整数二进制表示中 1 的个数。

#### 输入：
- 无符号整数：`00000000000000000000000000001011`

#### 输出：
- 1 的个数：`3`

#### 答案：

```go
package main

import (
	"fmt"
)

func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}

func main() {
    num := uint32(0b00000000000000000000000000001011)
    fmt.Println(hammingWeight(num)) // 输出 3
}
```

#### 解析：
通过不断将数与自身减 1 的结果进行位与操作，移除最后一位 1，统计循环次数即可得到 1 的个数。

### 13. 两数之和

#### 题目：
给定一个整数数组 `nums` 和一个目标值 `target`，找出数组中两数之和等于 `target` 的两个数，并返回他们的下标。

#### 输入：
- 整数数组：`[2, 7, 11, 15]`
- 目标值：`9`

#### 输出：
- 下标：`[0, 1]`

#### 答案：

```go
package main

import (
	"fmt"
)

func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if v, ok := m[target-num]; ok {
            return []int{v, i}
        }
        m[num] = i
    }
    return nil
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    fmt.Println(twoSum(nums, target)) // 输出 [0, 1]
}
```

#### 解析：
使用哈希表存储每个数字及其索引，遍历数组时查找与当前数相加等于目标值的数是否存在哈希表中。

### 14. 翻转链表

#### 题目：
定义一个函数，用于反转一个单链表。

#### 输入：
- 链表：`[1, 2, 3, 4, 5]`

#### 输出：
- 反转后的链表：`[5, 4, 3, 2, 1]`

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    current := head

    for current != nil {
        nextTemp := current.Next
        current.Next = prev
        prev = current
        current = nextTemp
    }

    return prev
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n5 := &ListNode{Val: 5}
    n4 := &ListNode{Val: 4, Next: n5}
    n3 := &ListNode{Val: 3, Next: n4}
    n2 := &ListNode{Val: 2, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    printList(n1) // 输出 1 2 3 4 5
    printList(reverseList(n1)) // 输出 5 4 3 2 1
}
```

#### 解析：
使用迭代方式，将当前节点的下一个节点指向前一个节点，从而实现链表反转。

### 15. 合并两个有序链表

#### 题目：
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### 输入：
- 链表1：`[1 -> 2 -> 4]`
- 链表2：`[1 -> 3 -> 4]`

#### 输出：
- 新链表：`[1 -> 1 -> 2 -> 3 -> 4 -> 4]`

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n4 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 2, Next: n4}
    n2 := &ListNode{Val: 1, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    n4 = &ListNode{Val: 4}
    n3 = &ListNode{Val: 3, Next: n4}
    n2 = &ListNode{Val: 1, Next: n3}
    n1 = &ListNode{Val: 1, Next: n2}

    printList(mergeTwoLists(n1, n1)) // 输出 1 1 2 3 4 4
}
```

#### 解析：
通过递归方式，每次比较两个链表的头节点值，选择较小的节点作为新链表的头节点，并将剩余的链表继续作为参数递归调用。

### 16. 旋转图像

#### 题目：
给定一个 n × n 的二维矩阵 matrix，编写一个算法，以原地旋转图像。

#### 输入：
```
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
```

#### 输出：
```
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

#### 答案：

```go
package main

import (
	"fmt"
)

func rotate(matrix [][]int) {
    n := len(matrix)

    // 水平翻转
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-i-1][j] = matrix[n-i-1][j], matrix[i][j]
        }
    }

    // 对角线翻转
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}

func printMatrix(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            fmt.Printf("%d ", matrix[i][j])
        }
        fmt.Println()
    }
}

func main() {
    matrix := [][]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    printMatrix(matrix)
    rotate(matrix)
    printMatrix(matrix) // 输出
    // 7 4 1
    // 8 5 2
    // 9 6 3
}
```

#### 解析：
首先水平翻转矩阵，然后对角线翻转矩阵，即可得到旋转后的图像。

### 17. 最大子序和

#### 题目：
给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（至少长度为 1）。

#### 输入：
```
[-2,1,-3,4,-1,2,1,-5,4]
```

#### 输出：
```
6
```

#### 答案：

```go
package main

import (
	"fmt"
)

func maxSubArray(nums []int) int {
    maxSoFar := nums[0]
    currentMax := nums[0]

    for i := 1; i < len(nums); i++ {
        currentMax = max(nums[i], currentMax+nums[i])
        maxSoFar = max(maxSoFar, currentMax)
    }

    return maxSoFar
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println(maxSubArray(nums)) // 输出 6
}
```

#### 解析：
使用动态规划，保存当前子数组的最大和 `currentMax` 和全局最大和 `maxSoFar`，每次迭代更新这两个值。

### 18. 两数相加 II

#### 题目：
两数相加，但是输入的两个数字是字符串，返回结果也是字符串。

#### 输入：
```
"342+445"
```

#### 输出：
```
787
```

#### 答案：

```go
package main

import (
	"fmt"
	"math"
)

func addStrings(num1 string, num2 string) string {
    i, j := len(num1)-1, len(num2)-1
    carry := 0
    ans := []byte{}

    for i >= 0 || j >= 0 || carry > 0 {
        x, y := 0, 0
        if i >= 0 {
            x = int(num1[i] - '0')
            i--
        }
        if j >= 0 {
            y = int(num2[j] - '0')
            j--
        }
        sum := x + y + carry
        carry = sum / 10
        ans = append([]byte{byte(sum%10 + '0')}, ans...)
    }

    return string(ans)
}

func main() {
    num1 := "342"
    num2 := "445"
    fmt.Println(addStrings(num1, num2)) // 输出 787
}
```

#### 解析：
从个位开始相加，记录进位，每次相加后将结果存储在数组中，最后翻转数组得到结果字符串。

### 19. 反转整数

#### 题目：
给定一个整数，将其反转。如果反转后的整数超过 32 位的有符号整数范围，则返回 0。

#### 输入：
```
123
```

#### 输出：
```
321
```

#### 答案：

```go
package main

import (
	"fmt"
	"math"
)

func reverse(x int) int {
    ans := 0
    for x != 0 {
        if ans > math.MaxInt32/10 || (ans == math.MaxInt32/10 && x > 7) {
            return 0
        }
        if ans < math.MinInt32/10 && x < -8 {
            return 0
        }
        ans = ans*10 + x%10
        x /= 10
    }
    return ans
}

func main() {
    x := 123
    fmt.Println(reverse(x)) // 输出 321
}
```

#### 解析：
每次将整数取模得到个位数，然后将其加到结果的末尾，同时将原整数除以 10。最后检查是否越界。

### 20. 最长公共前缀

#### 题目：
编写一个函数来查找字符串数组中的最长公共前缀。

#### 输入：
```
["flower", "flow", "flight"]
```

#### 输出：
```
"fl"
```

#### 答案：

```go
package main

import (
	"fmt"
)

func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    minLen := len(strs[0])
    for _, str := range strs {
        if len(str) < minLen {
            minLen = len(str)
        }
    }
    var ans string
    for i := 0; i < minLen; i++ {
        ch := strs[0][i]
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[j][i] != ch {
                return ans
            }
        }
        ans += string(ch)
    }
    return ans
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println(longestCommonPrefix(strs)) // 输出 "fl"
}
```

#### 解析：
从第一个字符串开始，逐一与前后的字符串比较，找出公共的前缀。当出现不匹配时，返回当前的前缀。

### 21. 合并两个有序链表

#### 题目：
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

#### 输入：
```
l1: 1->2->4
l2: 1->3->4
```

#### 输出：
```
1->1->2->3->4->4
```

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n4 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 2, Next: n4}
    n2 := &ListNode{Val: 1, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    n4 = &ListNode{Val: 4}
    n3 = &ListNode{Val: 3, Next: n4}
    n2 = &ListNode{Val: 1, Next: n3}
    n1 = &ListNode{Val: 1, Next: n2}

    printList(mergeTwoLists(n1, n1)) // 输出 1 1 2 3 4 4
}
```

#### 解析：
使用递归方法，比较两个链表的头节点，选择较小的节点作为新链表的头节点，并将剩余的链表作为参数递归调用。

### 22. 整数转换罗马数字

#### 题目：
将一个整数转换成罗马数字。

#### 输入：
```
58
```

#### 输出：
```
LVIII
```

#### 答案：

```go
package main

import (
	"fmt"
)

func intToRoman(num int) string {
    val := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
    sym := []string{"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"}
    ans := ""

    for i := 0; i < len(val); i++ {
        for num >= val[i] {
            ans += sym[i]
            num -= val[i]
        }
    }

    return ans
}

func main() {
    num := 58
    fmt.Println(intToRoman(num)) // 输出 LVIII
}
```

#### 解析：
从大到小遍历每个数值和对应的罗马数字，将能匹配的最大数值添加到结果中，并减少数值。

### 23. 合并 k 个排序链表

#### 题目：
合并 k 个已排序的链表，返回合并后的排序链表。

#### 输入：
```
[
  1->4->5,
  1->3->4,
  2->6
]
```

#### 输出：
```
1->1->2->3->4->4->5->6
```

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    for len(lists) > 1 {
        newLists := []*ListNode{}
        for i := 0; i < len(lists); i += 2 {
            if i+1 < len(lists) {
                t := mergeTwoLists(lists[i], lists[i+1])
                newLists = append(newLists, t)
            } else {
                newLists = append(newLists, lists[i])
            }
        }
        lists = newLists
    }

    return lists[0]
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n4 := &ListNode{Val: 4}
    n3 := &ListNode{Val: 5, Next: n4}
    n2 := &ListNode{Val: 1, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    n4 = &ListNode{Val: 4}
    n3 = &ListNode{Val: 3, Next: n4}
    n2 = &ListNode{Val: 1, Next: n3}
    n1 = &ListNode{Val: 1, Next: n2}

    n6 := &ListNode{Val: 6}
    n5 := &ListNode{Val: 2, Next: n6}
    n4 = &ListNode{Val: 1, Next: n5}
    n3 = &ListNode{Val: 1, Next: n4}
    n2 = &ListNode{Val: 1, Next: n3}
    n1 = &ListNode{Val: 2, Next: n2}

    printList(mergeKLists([]*ListNode{n1, n1, n1})) // 输出 1 1 1 1 1 2 3 4 4 4 5 6
}
```

#### 解析：
使用分治策略，每次合并两个链表，直到只剩下一个链表。

### 24. 合并区间

#### 题目：
合并一个由若干个区间组成的数组。

#### 输入：
```
[
  [1,3],
  [2,6],
  [8,10],
  [15,18]
]
```

#### 输出：
```
[
  [1,6],
  [8,10],
  [15,18]
]
```

#### 答案：

```go
package main

import (
	"fmt"
)

type Interval struct {
    Start int
    End   int
}

func merge(intervals []Interval) []Interval {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i].Start < intervals[j].Start
    })

    var ans []Interval
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1].End < interval.Start {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1].End = max(ans[len(ans)-1].End, interval.End)
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    intervals := []Interval{
        {Start: 1, End: 3},
        {Start: 2, End: 6},
        {Start: 8, End: 10},
        {Start: 15, End: 18},
    }
    fmt.Println(merge(intervals)) // 输出 [[1 6] [8 10] [15 18]]
}
```

#### 解析：
首先对区间数组进行排序，然后遍历数组，将重叠的区间合并。

### 25. 最长公共子序列

#### 题目：
给定两个字符串，找到它们的最长公共子序列。

#### 输入：
```
"ABCBDAB"
"BDCAB"
```

#### 输出：
```
"BCAB"
```

#### 答案：

```go
package main

import (
	"fmt"
)

func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    index := dp[m][n]
   -dep[m][n]
    result := make([]byte, index)
    i, j := m, n
    for index > 0 {
        if text1[i-1] == text2[j-1] {
            result[index-1] = text1[i-1]
            i--
            j--
            index--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }

    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "ABCBDAB"
    text2 := "BDCAB"
    fmt.Println(longestCommonSubsequence(text1, text2)) // 输出 "BCAB"
}
```

#### 解析：
使用动态规划求解最长公共子序列，然后回溯得到结果。

### 26. 搜索旋转排序数组

#### 题目：
搜索一个旋转排序数组中的目标值。

#### 输入：
```
[4,5,6,7,0,1,2]
```

#### 输出：
```
4
```

#### 答案：

```go
package main

import (
	"fmt"
)

func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    target := 0
    fmt.Println(search(nums, target)) // 输出 4
}
```

#### 解析：
利用二分查找，同时考虑到旋转数组的特点，判断中间值和左右端点的关系，调整查找范围。

### 27. 找到字符串中所有字母异位词

#### 题目：
给定一个字符串 `pattern` 和一个字符串 `s`，返回 `s` 中所有的字母异位词。

#### 输入：
```
pattern = "cba"
s = "abcdabac"
```

#### 输出：
```
[0, 6]
```

#### 答案：

```go
package main

import (
	"fmt"
)

func findAnagrams(s string, p string) []int {
    m, n := len(s), len(p)
    cnt := [26]int{}
    ans := []int{}

    for i := 0; i < n; i++ {
        cnt[p[i]-'a']++
        cnt[s[i]-'a']++
    }

    for i := 0; i <= m-n; i++ {
        if check(cnt) {
            ans = append(ans, i)
        }
        cnt[s[i]-'a']--
        cnt[s[i+n]-'a']++
    }

    return ans
}

func check(cnt [26]int) bool {
    for _, v := range cnt {
        if v != 0 {
            return false
        }
    }
    return true
}

func main() {
    s := "abcdabac"
    p := "cba"
    fmt.Println(findAnagrams(s, p)) // 输出 [0, 6]
}
```

#### 解析：
使用数组 `cnt` 记录字符串 `p` 和子字符串 `s[i:i+n]` 的字符计数，然后检查 `cnt` 是否全为零，从而确定是否存在字母异位词。

### 28. 分隔链表

#### 题目：
给定一个链表和一个值 `val`，将所有小于 `val` 的节点移到大于或等于 `val` 节点之前。

#### 输入：
```
head = [1,4,3,2,5,-3], val = 3
```

#### 输出：
```
[-3, 1, 2, 4, 5, 3]
```

#### 答案：

```go
package main

import (
	"fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func partition(head *ListNode, val int) *ListNode {
    dummyLess := &ListNode{Val: -1}
    dummyGreater := &ListNode{Val: -1}
    currLess := dummyLess
    currGreater := dummyGreater

    for head != nil {
        if head.Val < val {
            currLess.Next = head
            currLess = currLess.Next
        } else {
            currGreater.Next = head
            currGreater = currGreater.Next
        }
        head = head.Next
    }
    currGreater.Next = nil
    currLess.Next = dummyGreater.Next

    return dummyLess.Next
}

func printList(head *ListNode) {
    for head != nil {
        fmt.Printf("%d ", head.Val)
        head = head.Next
    }
    fmt.Println()
}

func main() {
    n5 := &ListNode{Val: -3}
    n4 := &ListNode{Val: 5, Next: n5}
    n3 := &ListNode{Val: 2, Next: n4}
    n2 := &ListNode{Val: 4, Next: n3}
    n1 := &ListNode{Val: 1, Next: n2}

    printList(partition(n1, 3)) // 输出 -3 1 2 4 5 3
}
```

#### 解析：
使用两个哑节点分别记录小于和大于给定值的节点，最后将两个子链表合并。

### 29. 最长有效括号

#### 题目：
给定一个字符串，找到最长的有效括号子串。

#### 输入：
```
s = ")()())"
```

#### 输出：
```
4
```

#### 答案：

```go
package main

import (
	"fmt"
)

func longestValidParentheses(s string) int {
    ans, count := 0, 0
    stack := []int{-1}

    for i := 0; i < len(s); i++ {
        if s[i] == '(' {
            stack = append(stack, i)
        } else {
            stack = stack[:len(stack)-1]
            if len(stack) == 0 {
                stack = append(stack, i)
            } else {
                count = i - stack[len(stack)-1]
                ans = max(ans, count)
            }
        }
    }

    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    s := ")()())"
    fmt.Println(longestValidParentheses(s)) // 输出 4
}
```

#### 解析：
使用一个栈记录左括号的位置，当遇到右括号时，弹出栈顶元素，计算当前右括号到栈顶左括号之间的长度，更新最大长度。

### 30. 搜索旋转排序数组 II

#### 题目：
搜索一个旋转排序数组中的目标值。

#### 输入：
```
nums = [2,5,6,0,0,1,2]
target = 0
```

#### 输出：
```
true
```

#### 答案：

```go
package main

import (
	"fmt"
)

func search(nums []int, target int) bool {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return true
        }
        if nums[left] < nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else if nums[left] > nums[mid] {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        } else {
            left++
        }
    }
    return false
}

func main() {
    nums := []int{2, 5, 6, 0, 0, 1, 2}
    target := 0
    fmt.Println(search(nums, target)) // 输出 true
}
```

#### 解析：
在处理相等元素时，需要逐步前进以跳过重复的元素，同时根据中间元素与左右端点的关系调整搜索范围。

