                 

### 美团2025届社招面试高频算法题解析：动态规划经典题目

动态规划是解决最优化问题的一种重要方法，它通常涉及将问题分解为子问题，并存储子问题的解以避免重复计算。在美团的2025届社招面试中，动态规划题目是一道常见的面试题。以下是几道具有代表性的动态规划题目及详细解析。

### 1. 最长公共子序列（LCS）

**题目描述：**
给定两个字符串 `str1` 和 `str2`，找到它们的最长公共子序列。

**示例：**
```
str1 = "AGGTAB"
str2 = "GXTXAYB"
```
**最长公共子序列为：**
```
"GTAB"
```

**解题思路：**
使用动态规划求解最长公共子序列，可以通过构建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `str1` 的前 `i` 个字符和 `str2` 的前 `j` 个字符的最长公共子序列的长度。

**代码实现：**
```go
func longestCommonSubsequence(str1 string, str2 string) int {
    m, n := len(str1), len(str2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if str1[i-1] == str2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 2. 背包问题（0-1 Knapsack）

**题目描述：**
给定一组物品，每个物品有一个重量和一个价值，求解在不超过给定承重 `W` 的情况下，如何选择这些物品以最大化总价值。

**示例：**
```
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]
W = 8
```
**最大总价值为：**
```
9
```

**解题思路：**
使用动态规划求解 0-1 背包问题，可以通过构建一个二维数组 `dp`，其中 `dp[i][j]` 表示前 `i` 个物品放入容量为 `j` 的背包中的最大价值。

**代码实现：**
```go
func knapSack(W int, wt []int, val []int) int {
    n := len(val)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, W+1)
    }
    for i := 1; i <= n; i++ {
        for w := 1; w <= W; w++ {
            if wt[i-1] <= w {
                dp[i][w] = max(dp[i-1][w-wt[i-1]]+val[i-1], dp[i-1][w])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][W]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 3. 最长上升子序列（LIS）

**题目描述：**
给定一个无序整数数组，找出该数组的最长上升子序列的长度。

**示例：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```
**最长上升子序列长度为：**
```
4
```

**解题思路：**
使用动态规划求解最长上升子序列，可以通过构建一个一维数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 为结尾的最长上升子序列的长度。

**代码实现：**
```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(nums ...int) int {
    res := nums[0]
    for _, v := range nums {
        if v > res {
            res = v
        }
    }
    return res
}
```

### 4. 矩阵中的最长递增路径

**题目描述：**
给定一个整数矩阵，找出从矩阵中的任意一个元素开始，经过一系列的移动到达另一个元素的的最长递增路径的长度。每次移动只能在相邻的元素之间进行。

**示例：**
```
matrix = [
  [9, 9, 4],
  [6, 6, 8],
  [2, 1, 1]
]
```
**最长递增路径为：**
```
[9, 6, 2, 1]
```

**解题思路：**
使用动态规划求解矩阵中的最长递增路径，可以通过构建一个二维数组 `dp`，其中 `dp[i][j]` 表示以 `matrix[i][j]` 为结尾的最长递增路径的长度。

**代码实现：**
```go
var dirs = []int{-1, 0, 1, 0, -1}

func longestIncreasingPath(matrix [][]int) int {
    if len(matrix) == 0 {
        return 0
    }
    m, n := len(matrix), len(matrix[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    var dfs func(x, y int) int
    dfs = func(x, y int) int {
        if dp[x][y] != 0 {
            return dp[x][y]
        }
        mx := 0
        for i := 0; i < 4; i++ {
            nx, ny := x+dirs[i], y+dirs[i+1]
            if nx >= 0 && nx < m && ny >= 0 && ny < n && matrix[nx][ny] > matrix[x][y] {
                mx = max(mx, dfs(nx, ny))
            }
        }
        dp[x][y] = mx + 1
        return dp[x][y]
    }
    ans := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            ans = max(ans, dfs(i, j))
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 5. 最长连续序列

**题目描述：**
给定一个未排序的整数数组，找出最长连续序列的长度（不要求序列元素在原数组中连续）。

**示例：**
```
nums = [100, 4, 200, 1, 3, 2]
```
**最长连续序列为：**
```
[1, 2, 3, 4]
```

**解题思路：**
使用哈希表记录每个数字出现的次数，遍历数组，对于每个数字，如果它的左边和右边都没有出现过的数字，那么它可以作为一个新的序列的起点。更新最长连续序列的长度。

**代码实现：**
```go
func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    cnt := make(map[int]int)
    for _, v := range nums {
        cnt[v] = 1
    }
    ans := 1
    for _, v := range nums {
        if cnt[v] == 0 {
            continue
        }
        cnt[v] = 0
        left, right := v-1, v+1
        l, r := 0, 0
        for left >= 0 && cnt[left] == 0 {
            l++
            left--
        }
        for right < len(nums) && cnt[right] == 0 {
            r++
            right++
        }
        ans = max(ans, l+r+1)
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 6. 最小路径和

**题目描述：**
给定一个包含非负整数的二维网格，找出从左上角到右下角的最小路径和。

**示例：**
```
grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
```
**最小路径和为：**
```
7
```

**解题思路：**
使用动态规划求解最小路径和，可以通过构建一个二维数组 `dp`，其中 `dp[i][j]` 表示从 `(0, 0)` 到 `(i, j)` 的最小路径和。

**代码实现：**
```go
func minPathSum(grid [][]int) int {
    if len(grid) == 0 {
        return 0
    }
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 7. 子集和

**题目描述：**
给定一个整数数组 `nums` 和一个整数 `target`，找出数组中所有满足条件的子集，使其和等于 `target`。

**示例：**
```
nums = [10, 1, 2, 7, 6, 1, 5]
target = 8
```
**满足条件的子集有：**
```
[1, 7], [1, 2, 5], [2, 6], [1, 1, 6]
```

**解题思路：**
使用回溯算法求解子集和，通过递归遍历所有可能的子集，并使用剪枝策略减少不必要的搜索。

**代码实现：**
```go
func subsetSum(nums []int, target int) [][]int {
    var ans [][]int
    var backtrack func(start int, target int, path []int)
    backtrack = func(start, target int, path []int) {
        if target == 0 {
            ans = append(ans, append([]int{}, path...))
            return
        }
        if target < 0 {
            return
        }
        for i := start; i < len(nums); i++ {
            path = append(path, nums[i])
            backtrack(i+1, target-nums[i], path)
            path = path[:len(path)-1]
        }
    }
    backtrack(0, target, []int{})
    return ans
}
```

### 8. 股票买卖的最佳时机 IV

**题目描述：**
给定一个数组 `prices` 表示股票价格，每次交易可以持有最多两股股票，找出能获得的最大利润。

**示例：**
```
prices = [3, 3, 5, 0, 0, 3, 1, 4]
```
**最大利润为：**
```
6
```

**解题思路：**
可以使用动态规划求解，定义 `dp[i][j]` 表示第 `i` 天结束时，恰好进行了 `j` 次交易所能获得的最多利润。状态转移方程为：
```
dp[i][0] = max(dp[i-1][0], dp[i-1][j])
dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])
```

**代码实现：**
```go
func maxProfit(prices []int) int {
    n := len(prices)
    if n == 0 {
        return 0
    }
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, 2)
    }
    dp[0][0], dp[0][1] = 0, -prices[0]
    for i := 1; i < n; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    }
    return dp[n-1][0]
}
```

### 9. 最小栈

**题目描述：**
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

**示例：**
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**解题思路：**
可以使用两个栈，一个栈用于存储元素的值，另一个栈用于存储当前栈中的最小值。

**代码实现：**
```go
type MinStack struct {
    stk  []int
    minstk []int
}

func Constructor() MinStack {
    return MinStack{[]int{}, []int{}}
}

func (this *MinStack) Push(val int) {
    this.stk = append(this.stk, val)
    if len(this.minstk) == 0 || val <= this.minstk[len(this.minstk)-1] {
        this.minstk = append(this.minstk, val)
    }
}

func (this *MinStack) Pop() {
    if this.stk[len(this.stk)-1] == this.minstk[len(this.minstk)-1] {
        this.minstk = this.minstk[:len(this.minstk)-1]
    }
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) GetMin() int {
    return this.minstk[len(this.minstk)-1]
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
```

### 10. 翻转栈

**题目描述：**
使用递归或栈反转一个整数栈。

**示例：**
```
stack = [1, 2, 3, 4]
反转后：
stack = [4, 3, 2, 1]
```

**解题思路：**
使用递归方法，递归地将栈中的元素弹出并压入新栈。

**代码实现：**
```go
type Stack struct {
    Items []int
}

func (s *Stack) Push(item int) {
    s.Items = append(s.Items, item)
}

func (s *Stack) Pop() int {
    lastIndex := len(s.Items) - 1
    item := s.Items[lastIndex]
    s.Items = s.Items[:lastIndex]
    return item
}

func (s *Stack) Peek() int {
    return s.Items[len(s.Items)-1]
}

func (s *Stack) IsEmpty() bool {
    return len(s.Items) == 0
}

func reverseStack(s *Stack) {
    if !s.IsEmpty() {
        top := s.Pop()
        reverseStack(s)
        s.Push(top)
    }
}

// 示例使用
stack := &Stack{}
stack.Push(1)
stack.Push(2)
stack.Push(3)
stack.Push(4)
fmt.Println("Original stack:", stack.Items)

reverseStack(stack)
fmt.Println("Reversed stack:", stack.Items)
```

### 11. 合并区间

**题目描述：**
给定一组区间，将它们合并为一个大区间。

**示例：**
```
intervals = [
  [1, 3],
  [2, 6],
  [8, 10],
  [15, 18]
]
合并后：
[
  [1, 6],
  [8, 10],
  [15, 18]
]
```

**解题思路：**
先将区间按照起始点排序，然后遍历区间，根据区间是否重叠来合并。

**代码实现：**
```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    ans := intervals
    for i := 1; i < len(ans); i++ {
        if ans[i-1][1] >= ans[i][0] {
            ans[i-1][1] = max(ans[i-1][1], ans[i][1])
            ans = append(ans[:i-1], ans[i+1:]...)
            i--
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 12. 环形链表

**题目描述：**
给定一个链表，检查链表中是否存在环。

**示例：**
```
链表:
head = [3, 2, 0, -4]
设定循环位置 index = 2 ，
对应的节点为 node = [0, -4]
```

**解题思路：**
使用快慢指针法，快指针每次移动两个节点，慢指针每次移动一个节点。如果快慢指针相遇，则存在环。

**代码实现：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func hasCycle(head *ListNode) bool {
    if head == nil {
        return false
    }
    slow := head
    fast := head.Next
    for slow != fast {
        if fast == nil || fast.Next == nil {
            return false
        }
        slow = slow.Next
        fast = fast.Next.Next
    }
    return true
}
```

### 13. 搜索二维矩阵

**题目描述：**
给定一个二维矩阵，每个元素都是排序的，且每一行的元素按照从左到右递增排列，每一列的元素都按照从上到下递增排列。编写一个函数，查询某个元素是否存在于矩阵中。

**示例：**
```
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
```

**解题思路：**
从矩阵的右上角开始，如果当前元素小于目标值，则向下移动；如果当前元素大于目标值，则向左移动；如果当前元素等于目标值，则返回 true。

**代码实现：**
```go
func searchMatrix(matrix [][]int, target int) bool {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }
    row, col := 0, len(matrix[0])-1
    for row < len(matrix) && col >= 0 {
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] < target {
            row++
        } else {
            col--
        }
    }
    return false
}
```

### 14. 逆波兰表达式求值

**题目描述：**
根据逆波兰表示法，求表达式的值。

**示例：**
```
expression = ["2", "1", "+", "3", "*"]
```

**解题思路：**
使用栈，遍历表达式，遇到数字则入栈，遇到运算符则弹出栈顶两个元素进行计算，并将结果入栈。

**代码实现：**
```go
func evalRPN(tokens []string) int {
    stk := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a+b)
        case "-":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a-b)
        case "*":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, a*b)
        case "/":
            b := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            a := stk[len(stk)-1]
            stk = stk[:len(stk)-1]
            stk = append(stk, int(float64(a)/float64(b)))
        default:
            stk = append(stk, atoi(token))
        }
    }
    return stk[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    ans := 0
    for i := 0; i < len(token); i++ {
        ans = ans*10 + int(token[i]-'0')
    }
    return ans * sign
}
```

### 15. 二叉搜索树中的搜索

**题目描述：**
给定一个二叉搜索树和一个目标值，搜索树中的节点值各不相同，并按升序排列。写一个函数查找树中节点值等于目标值的节点。

**示例：**
```
[4,2,6,1,3,5,7]
```

**解题思路：**
从根节点开始递归搜索，如果当前节点的值小于目标值，则递归搜索右子树；如果当前节点的值大于目标值，则递归搜索左子树；如果当前节点的值等于目标值，则返回当前节点。

**代码实现：**
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func searchBST(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }
    if root.Val < val {
        return searchBST(root.Right, val)
    }
    return searchBST(root.Left, val)
}
```

### 16. 合并两个有序链表

**题目描述：**
将两个升序链表合并为一个升序链表并返回结果链表。

**示例：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**解题思路：**
使用两个指针分别指向两个链表的头部，每次比较两个指针指向的节点值，选择较小的节点值作为新的链表节点，并将指针向后移动。

**代码实现：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

### 17. 排序链表

**题目描述：**
对链表进行排序。

**示例：**
```
链表：
[4,2,1,3]
```

**解题思路：**
使用归并排序，将链表分成两半，递归排序，最后合并。

**代码实现：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    mid := slow.Next
    slow.Next = nil
    left := sortList(head)
    right := sortList(mid)
    return mergeTwoLists(left, right)
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

### 18. 删除链表的节点

**题目描述：**
删除链表中某个节点，您只能访问该节点。

**示例：**
```
head = [4,5,1,9]
n = 5
```

**解题思路：**
将当前节点的值设置为前一个节点的值，然后将当前节点指向前一个节点指向的下一个节点，相当于删除了当前节点。

**代码实现：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

### 19. 合并两个有序数组

**题目描述：**
将两个已排序的数组合并为一个更大的有序数组。

**示例：**
```
nums1 = [1,2,3,0,0,0]
nums2 = [2,5,6]
```

**解题思路：**
从两个数组的尾部开始比较，将较大的元素放入结果数组的尾部，移动相应的数组指针。

**代码实现：**
```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

### 20. 搜索插入位置

**题目描述：**
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将在数组中插入的位置。

**示例：**
```
nums = [1,3,5,6]
target = 5
```

**解题思路：**
使用二分查找，找到目标值的位置或者其应该插入的位置。

**代码实现：**
```go
func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return left
}
```

### 21. 盛水的容器

**题目描述：**
给定一个整数数组 `height` ，表示一个容器的高度，返回容器能装的最大水量。

**示例：**
```
height = [1,8,6,2,5,4,8,3,7]
```

**解题思路：**
使用双指针法，左右指针分别指向数组的两端，逐步向中间移动，每次移动时，取左右两边的最小值作为容器的高度，并计算容器的宽度，更新最大水量。

**代码实现：**
```go
func maxArea(height []int) int {
    left, right := 0, len(height)-1
    maxArea := 0
    for left < right {
        leftHeight, rightHeight := height[left], height[right]
        width := right - left
        area := width * min(leftHeight, rightHeight)
        if area > maxArea {
            maxArea = area
        }
        if leftHeight < rightHeight {
            left++
        } else {
            right--
        }
    }
    return maxArea
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 22. 最小栈

**题目描述：**
设计一个支持 push、pop、top 操作，并能在常数时间内检索到最小元素的栈。

**示例：**
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**解题思路：**
使用两个栈，一个栈用于存储元素，另一个栈用于存储当前栈中的最小值。

**代码实现：**
```go
type MinStack struct {
    stk  []int
    minstk []int
}

func Constructor() MinStack {
    return MinStack{[]int{}, []int{}}
}

func (this *MinStack) Push(val int) {
    this.stk = append(this.stk, val)
    if len(this.minstk) == 0 || val <= this.minstk[len(this.minstk)-1] {
        this.minstk = append(this.minstk, val)
    }
}

func (this *MinStack) Pop() {
    if this.stk[len(this.stk)-1] == this.minstk[len(this.minstk)-1] {
        this.minstk = this.minstk[:len(this.minstk)-1]
    }
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MinStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MinStack) GetMin() int {
    return this.minstk[len(this.minstk)-1]
}

/**
 * Your MinStack object will be instantiated and called as such:
 * obj := Constructor();
 * obj.Push(val);
 * obj.Pop();
 * param_3 := obj.Top();
 * param_4 := obj.GetMin();
 */
```

### 23. 三数之和

**题目描述：**
给定一个整数数组 `nums` ，返回所有不包含重复三数之和的列表。

**示例：**
```
nums = [-1, 0, 1, 2, -1, -4]
```

**解题思路：**
首先对数组进行排序，然后使用双指针法，固定一个数，另外两个数从当前数的两侧开始查找。

**代码实现：**
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    ans := [][]int{}
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        l, r := i+1, len(nums)-1
        for l < r {
            sum := nums[i] + nums[l] + nums[r]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[l], nums[r]})
                for l < r && nums[l] == nums[l+1] {
                    l++
                }
                for l < r && nums[r] == nums[r-1] {
                    r--
                }
                l++
                r--
            } else if sum < 0 {
                l++
            } else {
                r--
            }
        }
    }
    return ans
}
```

### 24. 最小差值 II

**题目描述：**
给定一个整数数组 `nums` ，找到数组中最小差值，最小差值定义如下：`min(nums[i] - nums[j])` 对于所有 `0 <= i < j < nums.length` 。

**示例：**
```
nums = [1,3,6,10,15]
```

**解题思路：**
排序数组，然后遍历数组，每次移动一个较小的数到较大的数的前面，更新最小差值。

**代码实现：**
```go
func minimumDifference(nums []int) int {
    sort.Ints(nums)
    minDiff := math.MaxInt32
    n := len(nums)
    for i := 0; i < n-1; i++ {
        diff := nums[i+1] - nums[i]
        if diff < minDiff {
            minDiff = diff
        }
        if nums[i] >= nums[i+1] {
            nums[i], nums[i+1] = nums[i+1], nums[i]
        }
    }
    return minDiff
}
```

### 25. 买卖股票的最佳时机 II

**题目描述：**
给定一个整数数组 `prices` ，其中每个元素代表了某一天的股票价格。计算你所能获取的最大利润。

**示例：**
```
prices = [7,1,5,3,6,4]
```

**解题思路：**
遍历数组，每次找到相邻元素中的较小值，并计算它们之间的差值，将这些差值相加。

**代码实现：**
```go
func maxProfit(prices []int) int {
    ans := 0
    for i := 1; i < len(prices); i++ {
        if prices[i-1] < prices[i] {
            ans += prices[i] - prices[i-1]
        }
    }
    return ans
}
```

### 26. 螺旋矩阵

**题目描述：**
给定一个包含 `m` x `n` 个元素的矩阵 `matrix` （`m` 行 `n` 列），编写一个函数，以螺旋顺序返回矩阵中的所有元素。

**示例：**
```
matrix = [
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
]
```

**解题思路：**
模拟螺旋矩阵的遍历过程，分别从左到右、从上到下、从右到左、从下到上四个方向遍历。

**代码实现：**
```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }
    m, n := len(matrix), len(matrix[0])
    ans := make([]int, 0, m*n)
    t, b, l, r := 0, m-1, 0, n-1
    for len(ans) < m*n {
        for i := l; i <= r && len(ans) < m*n; i++ {
            ans = append(ans, matrix[t][i])
        }
        t++
        for i := t; i <= b && len(ans) < m*n; i++ {
            ans = append(ans, matrix[i][r])
        }
        r--
        for i := r; i >= l && len(ans) < m*n; i-- {
            ans = append(ans, matrix[b][i])
        }
        b--
        for i := b; i >= t && len(ans) < m*n; i-- {
            ans = append(ans, matrix[i][l])
        }
        l++
    }
    return ans
}
```

### 27. 合并两个有序链表

**题目描述：**
将两个升序链表合并为一个更大的有序链表并返回结果链表。

**示例：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**解题思路：**
使用两个指针分别指向两个链表的头部，每次比较两个指针指向的节点值，选择较小的节点值作为新的链表节点，并将指针向后移动。

**代码实现：**
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

### 28. 存在重复元素 II

**题目描述：**
给定一个整数数组 `nums` 和一个整数 `k` ，判断数组中是否存在两个不同的索引 `i` 和 `j` ，使得 `nums[i] == nums[j]` 且 `abs(i - j) <= k` 。

**示例：**
```
nums = [1,2,3,1], k = 3
```

**解题思路：**
使用哈希表存储每个数字的最近索引位置，遍历数组，对于每个数字，检查哈希表中是否存在与当前数字相同的值，并且两个索引之间的差值不超过 `k` 。

**代码实现：**
```go
func containsNearbyDuplicate(nums []int, k int) bool {
    mp := map[int]int{}
    for i, v := range nums {
        if j, ok := mp[v]; ok && i-j <= k {
            return true
        }
        mp[v] = i
    }
    return false
}
```

### 29. 存在重复元素 III

**题目描述：**
给定一个整数数组 `nums` 和两个整数 `indexK` 和 `indexLimit` ，计算并返回一个布尔值，表示是否存在两个不同的索引 `i` 和 `j` ，使得 `nums[i] == nums[j]` 且 `abs(i - j) <= indexK` 且 `abs(i - indexK) <= indexLimit` 且 `abs(j - indexK) <= indexLimit` 。

**示例：**
```
nums = [1,2,3,1,2,3], indexK = 2, indexLimit = 2
```

**解题思路：**
使用哈希表存储每个数字的最近索引位置，遍历数组，对于每个数字，检查哈希表中是否存在与当前数字相同的值，并且满足两个索引之间的差值不超过 `indexK` ，且两个索引与 `indexK` 的差值都不超过 `indexLimit` 。

**代码实现：**
```go
func containsNearbyAlmostDuplicate(nums []int, indexK int, indexLimit int) bool {
    mp := map[int]int{}
    for i, v := range nums {
        nearVal := v - indexK
        if j, ok := mp[nearVal]; ok && i-j <= indexK {
            return true
        }
        nearVal = v + indexK
        if j, ok := mp[nearVal]; ok && i-j <= indexK {
            return true
        }
        if i-indexLimit >= 0 {
            delete(mp, nums[i-indexLimit])
        }
        mp[v] = i
    }
    return false
}
```

### 30. 寻找两个正序数组的中位数

**题目描述：**
给定两个升序排列的整数数组 `nums1` 和 `nums2` ，请编写一个函数，找出这两个数组的 中位数 。

**示例：**
```
nums1 = [1,3]
nums2 = [2]
```

**解题思路：**
使用二分查找法，分别对两个数组进行二分，找到中位数的位置，然后取中间值或平均值。

**代码实现：**
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        return findMedianSortedArrays(nums2, nums1)
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            break
        }
    }
    i := imin
    if i == 0 {
        maxLeft := nums2[j-1]
    } else if j == 0 {
        maxLeft := nums1[i-1]
    } else {
        maxLeft := max(nums1[i-1], nums2[j-1])
    }
    if (m+n)%2 == 1 {
        return float64(maxLeft)
    }
    if i == m {
        minRight := nums2[j]
    } else if j == n {
        minRight := nums1[i]
    } else {
        minRight := min(nums1[i], nums2[j])
    }
    return float64(maxLeft+minRight) / 2
}
```

