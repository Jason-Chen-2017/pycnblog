                 

### 1. 顺序处理多个并发任务

**题目：** 如何在 Golang 中顺序处理多个并发任务？

**答案：** 使用 `sync.WaitGroup` 和 `defer` 关键字。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
)

func processTask(taskID int) {
    // 处理任务
    fmt.Printf("Processing task %d\n", taskID)
    // 模拟处理时间
    time.Sleep(time.Millisecond * 500)
}

func main() {
    var wg sync.WaitGroup
    numTasks := 5

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            processTask(id)
        }(i)
    }

    wg.Wait()
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，我们使用 `sync.WaitGroup` 来等待所有并发任务完成。`wg.Add(1)` 将计数器增加 1，表示有一个新的任务被添加。`defer wg.Done()` 在处理任务完成后，将计数器减 1，表示任务已完成。`wg.Wait()` 阻塞主 goroutine，直到所有任务完成。

### 2. 使用通道同步并发任务

**题目：** 在 Golang 中，如何使用通道（channel）来同步多个并发任务？

**答案：** 使用通道（channel）进行通信，通过通道发送和接收信号来同步任务。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func taskProcessor(id int, done chan<- bool) {
    // 处理任务
    fmt.Printf("Processing task %d\n", id)
    time.Sleep(time.Millisecond * 500)

    // 通知任务已完成
    done <- true
}

func main() {
    var wg sync.WaitGroup
    numTasks := 5
    done := make(chan bool, numTasks)

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            taskProcessor(id, done)
        }(i)
    }

    // 等待所有任务完成
    for i := 0; i < numTasks; i++ {
        <-done
    }

    wg.Wait()
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，我们为每个任务创建了一个 `done` 通道，用于通知任务完成。每个任务在完成处理后，将 `true` 发送到 `done` 通道。主 goroutine 从 `done` 通道接收信号，直到接收完所有信号，表示所有任务已完成。`done` 通道使用缓冲通道，可以避免发送和接收操作之间的阻塞。

### 3. 使用 select 语句处理多通道通信

**题目：** 在 Golang 中，如何使用 `select` 语句来处理多个通道的并发通信？

**答案：** 使用 `select` 语句来监听多个通道的发送和接收操作，并在其中一个通道就绪时执行相应的代码块。

**举例：**

```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch)
}

func consumer(ch <-chan int) {
    for i := range ch {
        fmt.Printf("Received: %d\n", i)
    }
}

func main() {
    ch := make(chan int)

    go producer(ch)
    consumer(ch)
}
```

**解析：** 在这个例子中，我们使用 `select` 语句来处理生产者（producer）和消费者（consumer）之间的通信。生产者向通道发送数据，消费者从通道接收数据。当通道关闭时，`range` 循环会自动退出，消费者继续处理剩余的数据。

### 4. 理解 Goroutine 和线程的区别

**题目：** 请解释 Golang 中 Goroutine 和操作系统中线程的主要区别。

**答案：**

* **线程（Thread）：** 线程是操作系统层面的最小执行单位，具有独立的栈、程序计数器和状态等信息。操作系统可以通过线程调度器来调度线程的执行。
* **Goroutine（协程）：** Goroutine 是 Golang 的并行计算单元，由 Go 运行时系统管理。每个 Goroutine 都拥有自己的栈，但共享相同的内存空间和其他资源。

主要区别包括：

1. **调度器：** 线程由操作系统调度，而 Goroutine 由 Go 运行时系统调度。
2. **栈：** 每个线程都有自己的独立栈，而每个 Goroutine 只有自己的栈。
3. **上下文切换：** 线程上下文切换涉及操作系统调度开销，而 Goroutine 上下文切换由 Go 运行时系统管理，开销较小。

### 5. 理解并发数据竞争

**题目：** 在 Golang 中，什么是并发数据竞争？如何避免？

**答案：**

* **并发数据竞争：** 当两个或多个 Goroutine 同时访问同一个变量，并且至少有一个是写入操作时，就可能发生并发数据竞争。如果未正确处理，可能会导致程序不稳定或产生不可预测的结果。

**避免方法：**

1. **使用互斥锁（Mutex）：** 通过互斥锁来保护共享变量，确保同一时间只有一个 Goroutine 可以访问。
2. **使用原子操作：** 使用 `sync/atomic` 包提供的原子操作来确保操作的原子性，避免数据竞争。
3. **减少共享变量：** 通过设计减少需要共享的变量，以降低并发数据竞争的风险。
4. **使用通道（Channel）：** 通过通道进行数据通信，避免直接访问共享变量。

### 6. 使用 WaitGroup 等待多个 Goroutine 完成

**题目：** 如何在 Golang 中使用 `WaitGroup` 等待多个 Goroutine 完成？

**答案：** 使用 `WaitGroup` 可以在主 Goroutine 中等待一组 Goroutine 完成。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func task(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Task %d started\n", id)
    time.Sleep(time.Millisecond * 500)
    fmt.Printf("Task %d completed\n", id)
}

func main() {
    var wg sync.WaitGroup
    numTasks := 5

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go task(i, &wg)
    }

    wg.Wait()
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，`WaitGroup` 用于等待所有 Goroutine 完成。`wg.Add(1)` 将计数器增加 1，表示有一个新的任务被添加。`defer wg.Done()` 在处理任务完成后，将计数器减 1，表示任务已完成。`wg.Wait()` 阻塞主 Goroutine，直到所有任务完成。

### 7. 理解 Goroutine 泄露

**题目：** 什么是 Goroutine 泄露？如何避免 Goroutine 泄露？

**答案：**

* **Goroutine 泄露：** Goroutine 泄露指的是当 Goroutine 的生命周期超出预期，未被正确终止，导致内存泄漏和资源浪费。
* **避免方法：**

1. **明确 Goroutine 生命周期：** 确保每个 Goroutine 在完成任务后能够正确终止。
2. **使用 defer 关键字：** 在 Goroutine 入口函数中使用 `defer` 关键字，确保在 Goroutine 退出时执行清理操作。
3. **使用 Context 控制 Goroutine：** 使用 `context` 包提供的 `Context` 对象来控制 Goroutine 的生命周期，例如使用 `ctx.Done()` 来终止 Goroutine。

### 8. 理解 Context 包

**题目：** 请解释 Golang 中的 Context 包的作用和常见用法。

**答案：**

* **Context 包的作用：** `Context` 是一个用于传递请求信息和取消信号的数据结构，可以用于控制 Goroutine 的生命周期，例如终止 Goroutine 的执行。
* **常见用法：**

1. **创建 Context：** 使用 `context.Background()` 或 `contextTODO` 创建一个无值的 Context，用于普通场景。
2. **传递信息：** 使用 `ctx.Value` 来传递请求信息，如请求头、请求参数等。
3. **取消信号：** 使用 `ctx.Done()` 获取取消信号，当 Context 被取消时，返回 `context.Done`。
4. **WithCancel：** 创建一个可取消的 Context，可以通过 `cancel` 函数取消 Context。

**举例：**

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func process(ctx context.Context, id int) {
    select {
    case <-ctx.Done():
        fmt.Printf("Task %d canceled\n", id)
    default:
        fmt.Printf("Processing task %d\n", id)
        time.Sleep(time.Millisecond * 500)
        fmt.Printf("Completed task %d\n", id)
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    numTasks := 5

    for i := 0; i < numTasks; i++ {
        go process(ctx, i)
    }

    time.Sleep(time.Millisecond * 1000)
    cancel()
}
```

**解析：** 在这个例子中，我们创建了一个可取消的 Context。每个 Goroutine 在处理任务时，会监听 Context 的取消信号。当主 Goroutine 调用 `cancel()` 时，所有 Goroutine 将收到取消信号，并终止执行。

### 9. 使用 Select 语句处理多个通道

**题目：** 在 Golang 中，如何使用 `Select` 语句来处理多个通道的并发通信？

**答案：** `Select` 语句允许 Goroutine 同时监听多个通道，并在其中一个通道就绪时执行相应的代码块。

**举例：**

```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch)
}

func consumer(ch <-chan int) {
    for v := range ch {
        fmt.Printf("Received: %d\n", v)
    }
}

func main() {
    ch := make(chan int)

    go producer(ch)
    consumer(ch)
}
```

**解析：** 在这个例子中，我们使用 `Select` 语句来处理生产者和消费者之间的通信。生产者向通道发送数据，消费者从通道接收数据。当通道关闭时，`Range` 循环会自动退出，消费者继续处理剩余的数据。

### 10. 使用并发模式处理大数据

**题目：** 请解释 Golang 中的并发模式，并举例说明如何使用并发模式处理大数据。

**答案：**

* **并发模式：** 并发模式是一种设计模式，通过将任务分解成多个子任务，并使用多个 Goroutine 同时执行，以实现高性能和可扩展性。
* **示例：**

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

func processTask(taskID int, wg *sync.WaitGroup, result *[]int) {
    defer wg.Done()
    // 处理任务，如计算等
    *result = append(*result, taskID*2)
    time.Sleep(time.Millisecond * 100)
}

func main() {
    var wg sync.WaitGroup
    numTasks := 10
    result := make([]int, 0, numTasks)

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go processTask(i, &wg, &result)
    }

    wg.Wait()
    fmt.Println("Processed results:", result)
}
```

**解析：** 在这个例子中，我们使用并发模式来处理 10 个任务。每个任务都是计算任务，将任务 ID 乘以 2。使用 `WaitGroup` 等待所有任务完成，并将结果存储在一个切片中。

### 11. 理解并发数据同步

**题目：** 在 Golang 中，如何实现并发数据同步？

**答案：**

* **互斥锁（Mutex）：** 使用互斥锁来保护共享资源，确保同一时间只有一个 Goroutine 可以访问。
* **读写锁（RWMutex）：** 当读操作远多于写操作时，使用读写锁可以提高性能。
* **通道（Channel）：** 使用通道进行数据通信，避免直接访问共享资源。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
)

var mu sync.Mutex
var counter int

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}

func main() {
    for i := 0; i < 1000; i++ {
        go increment()
    }

    time.Sleep(time.Millisecond * 1000)
    fmt.Println("Counter:", counter)
}
```

**解析：** 在这个例子中，我们使用互斥锁来保护共享变量 `counter`，确保多个 Goroutine 同时访问时不会导致数据竞争。

### 12. 理解并发中的死锁

**题目：** 什么是并发中的死锁？如何避免死锁？

**答案：**

* **死锁：** 当两个或多个 Goroutine 在同一时间需要访问对方持有的资源，并且都无法继续执行时，可能导致死锁。
* **避免死锁的方法：**

1. **避免资源循环依赖：** 设计资源分配策略，避免循环依赖。
2. **资源有序访问：** 确保 Goroutine 按照固定的顺序访问资源，避免死锁。
3. **使用锁的合理使用：** 避免长时间占用锁，减少死锁的可能性。

### 13. 理解 Goroutine 的并发调度

**题目：** 请解释 Golang 中 Goroutine 的并发调度机制。

**答案：**

* **并发调度机制：** Go 运行时系统通过调度器管理 Goroutine 的执行。调度器将可运行的 Goroutine 分配给可用的 CPU 核心进行执行，同时负责 Goroutine 的创建、销毁和上下文切换。
* **调度策略：**

1. **工作窃取（Work Stealing）：** 当一个 CPU 核心上的 Goroutine 队列空时，可以从其他 CPU 核心的队列中窃取 Goroutine 进行执行。
2. **时间片：** 每个 Goroutine 被分配一定的时间片，执行超过时间片后，会被调度器抢占，分配给其他 Goroutine。

### 14. 使用 Goroutine 和 WaitGroup 同时执行多个任务

**题目：** 在 Golang 中，如何使用 `Goroutine` 和 `WaitGroup` 同时执行多个任务？

**答案：** 使用 Goroutine 和 `WaitGroup` 可以并发执行多个任务，并等待所有任务完成。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
)

func task(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Task %d started\n", id)
    time.Sleep(time.Millisecond * 500)
    fmt.Printf("Task %d completed\n", id)
}

func main() {
    var wg sync.WaitGroup
    numTasks := 5

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go task(i, &wg)
    }

    wg.Wait()
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，我们创建了一个 `WaitGroup`，用于等待所有任务完成。每个任务都是通过 Goroutine 执行的，`defer wg.Done()` 确保在任务完成后将 `WaitGroup` 的计数器减 1。`wg.Wait()` 阻塞主 Goroutine，直到所有任务完成。

### 15. 理解 Goroutine 泄露的原因和解决方案

**题目：** 什么是 Goroutine 泄露？请解释 Goroutine 泄露的原因和解决方案。

**答案：**

* **Goroutine 泄露：** Goroutine 泄露指的是当 Goroutine 的生命周期超出预期，未被正确终止，导致内存泄漏和资源浪费。
* **原因：**

1. **忘记终止 Goroutine：** 创建了 Goroutine，但忘记在适当的时候终止它。
2. **未正确处理 Context：** 当使用 Context 来控制 Goroutine 的生命周期时，未正确处理 Context 的取消信号。
3. **长时间运行的 Goroutine：** 创建了长时间运行的 Goroutine，未及时回收。

**解决方案：**

1. **明确 Goroutine 生命周期：** 在 Goroutine 中明确指定完成条件，并在适当的时候终止。
2. **使用 Context 控制生命周期：** 使用 `context` 包提供的 Context 对象来控制 Goroutine 的生命周期。
3. **使用 defer 关键字：** 在 Goroutine 中使用 `defer` 关键字，确保在 Goroutine 退出时执行清理操作。

### 16. 使用 sync.Pool 缓存对象

**题目：** 请解释 Golang 中的 `sync.Pool` 的作用和用法。

**答案：**

* **`sync.Pool` 的作用：** `sync.Pool` 是一个全局缓存池，用于存储和重用临时对象，减少内存分配和回收的开销。
* **用法：**

1. **创建 Pool：** 使用 `new` 函数创建一个 Pool，指定类型和容量。
2. **获取对象：** 使用 `Get` 方法从 Pool 中获取对象。
3. **归还对象：** 使用 `Put` 方法将对象归还到 Pool 中。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
)

type MyObject struct {
    // 成员变量
}

var objPool = &sync.Pool{
    New: func() interface{} {
        return &MyObject{} // 创建新对象
    },
}

func main() {
    obj := objPool.Get().(*MyObject) // 获取对象
    // 使用对象
    objPool.Put(obj) // 归还对象
}
```

**解析：** 在这个例子中，我们创建了一个 `sync.Pool`，用于缓存 `MyObject` 类型对象。当需要对象时，使用 `Get` 方法从 Pool 中获取；使用完毕后，使用 `Put` 方法将对象归还到 Pool 中，以便其他 Goroutine 重用。

### 17. 使用 defer 语句延迟执行

**题目：** 请解释 Golang 中的 `defer` 语句的作用和用法。

**答案：**

* **`defer` 语句的作用：** `defer` 语句用于在函数返回前延迟执行指定的代码块，确保在函数结束时执行。
* **用法：**

1. **延迟执行函数：** 在函数中添加 `defer` 语句，将指定的函数推迟到函数返回前执行。
2. **资源管理：** 在函数中释放资源时，使用 `defer` 语句确保资源在函数结束时被正确释放。

**举例：**

```go
package main

import "fmt"

func main() {
    fmt.Println("Start")
    defer fmt.Println("Deferred")
    fmt.Println("End")
}
```

**解析：** 在这个例子中，`defer` 语句将 `fmt.Println("Deferred")` 推迟到函数返回前执行。因此，输出结果为：

```
Start
End
Deferred
```

### 18. 使用 defer 实现资源管理

**题目：** 请解释如何在 Golang 中使用 `defer` 语句来实现资源管理。

**答案：**

* **资源管理：** 在 Golang 中，使用 `defer` 语句可以在函数结束时自动释放资源，确保资源的正确释放，避免资源泄露。
* **实现方法：**

1. **打开资源：** 在函数开始时打开需要管理的资源，如文件、网络连接等。
2. **使用 defer：** 在打开资源的代码行后面添加 `defer` 语句，指定关闭资源的函数。

**举例：**

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close() // 延迟关闭文件

    // 使用文件
    fmt.Println("File opened successfully.")
}
```

**解析：** 在这个例子中，我们使用 `defer` 语句将 `file.Close()` 推迟到函数返回前执行，确保在函数结束时自动关闭文件。

### 19. 理解 Goroutine 的生命周期

**题目：** 请解释 Golang 中 Goroutine 的生命周期。

**答案：**

* **Goroutine 的生命周期：** Goroutine 是 Golang 的并发计算单元，其生命周期包括创建、运行、等待和终止等阶段。
* **生命周期阶段：**

1. **创建：** 通过 `go` 语句创建 Goroutine，并将其添加到调度器的运行队列中。
2. **运行：** 调度器将可运行的 Goroutine 分配给 CPU 核心进行执行。
3. **等待：** 当 Goroutine 需要等待其他操作（如 I/O、通道通信等）时，会进入等待状态。
4. **终止：** 当 Goroutine 的任务完成后，会自动终止并从调度器中移除。

### 20. 使用 Panic 和 Recover 处理错误

**题目：** 请解释 Golang 中的 `panic` 和 `recover` 的作用和用法。

**答案：**

* **`panic` 的作用：** `panic` 是一种用于处理程序运行时错误的机制，当程序遇到无法恢复的错误时，可以使用 `panic` 终止程序的执行。
* **`recover` 的作用：** `recover` 是一种用于捕获 `panic` 的机制，可以在 `defer` 语句中捕获并处理 `panic`。
* **用法：**

1. **触发 panic：** 在程序中遇到无法恢复的错误时，使用 `panic` 终止程序执行。
2. **捕获 panic：** 在 `defer` 语句中使用 `recover` 捕获并处理 `panic`。

**举例：**

```go
package main

import (
    "fmt"
)

func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()

    // 触发 panic
    panic("Something went wrong!")
}
```

**解析：** 在这个例子中，我们使用 `defer` 语句在函数返回前捕获并处理 `panic`。当程序遇到无法恢复的错误时，触发 `panic`，`recover` 函数将捕获并输出错误信息。

### 21. 使用 channel 进行数据通信

**题目：** 请解释 Golang 中 channel 的作用和用法。

**答案：**

* **channel 的作用：** channel 是 Golang 中的通信机制，用于在不同的 Goroutine 之间传递数据。
* **用法：**

1. **创建 channel：** 使用 `make` 函数创建一个通道。
2. **发送数据：** 使用 `<-` 运算符向通道发送数据。
3. **接收数据：** 使用 `<-` 运算符从通道接收数据。

**举例：**

```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch)
}

func consumer(ch <-chan int) {
    for v := range ch {
        fmt.Printf("Received: %d\n", v)
    }
}

func main() {
    ch := make(chan int)

    go producer(ch)
    consumer(ch)
}
```

**解析：** 在这个例子中，我们创建了一个无缓冲通道 `ch`，并使用两个 Goroutine 分别作为生产者和消费者。生产者向通道发送数据，消费者从通道接收数据。

### 22. 理解 channel 的缓冲区

**题目：** 请解释 Golang 中 channel 的缓冲区及其作用。

**答案：**

* **channel 的缓冲区：** channel 的缓冲区是一个用于存储发送数据和接收数据的缓冲区。
* **作用：**

1. **缓冲发送数据：** 当通道的缓冲区未满时，发送操作不会阻塞，可以将数据存储在缓冲区中。
2. **缓冲接收数据：** 当通道的缓冲区为空时，接收操作不会阻塞，可以继续执行。

### 23. 使用 select 语句处理多通道

**题目：** 请解释 Golang 中 `select` 语句的作用和用法。

**答案：**

* **`select` 语句的作用：** `select` 语句用于处理多个通道的并发通信，允许 Goroutine 在多个通道就绪时选择一个通道进行操作。
* **用法：**

1. **等待通道就绪：** 使用 `case` 语句监听多个通道，当其中一个通道就绪时，执行相应的代码块。
2. **默认操作：** 使用 `default` 语句指定在所有通道都未就绪时的操作。

**举例：**

```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan<- int) {
    for i := 0; i < 10; i++ {
        ch <- i
        time.Sleep(time.Millisecond * 500)
    }
    close(ch)
}

func consumer(ch <-chan int) {
    for {
        select {
        case v := <-ch:
            fmt.Printf("Received: %d\n", v)
        default:
            time.Sleep(time.Millisecond * 100)
        }
    }
}

func main() {
    ch := make(chan int)

    go producer(ch)
    consumer(ch)
}
```

**解析：** 在这个例子中，我们使用 `select` 语句处理生产者和消费者之间的通信。生产者向通道发送数据，消费者从通道接收数据。如果通道为空，`select` 语句将执行 `default` 代码块，模拟繁忙状态。

### 24. 使用 channel 的非阻塞操作

**题目：** 请解释 Golang 中 channel 的非阻塞操作及其应用场景。

**答案：**

* **channel 的非阻塞操作：** channel 的非阻塞操作是指发送和接收数据时不等待通道就绪，直接执行操作。
* **应用场景：**

1. **生产者与消费者：** 当生产者或消费者不需要等待对方就绪时，可以使用非阻塞操作。
2. **异步通信：** 在异步通信场景中，发送方不需要等待接收方的就绪状态，可以提高性能。

### 25. 使用 goroutine 以并发方式执行任务

**题目：** 请解释 Golang 中如何使用 goroutine 以并发方式执行任务。

**答案：**

* **goroutine 的作用：** goroutine 是 Golang 的并发计算单元，用于在同一个程序中并发执行多个任务。
* **使用方法：**

1. **创建 goroutine：** 使用 `go` 语句创建一个新的 goroutine，并在函数入口处执行。
2. **并发执行：** 在主 Goroutine 中创建多个 goroutine，它们将在不同的 CPU 核心上并发执行。

**举例：**

```go
package main

import (
    "fmt"
    "time"
)

func task(id int) {
    fmt.Printf("Task %d started\n", id)
    time.Sleep(time.Millisecond * 500)
    fmt.Printf("Task %d completed\n", id)
}

func main() {
    numTasks := 5

    for i := 0; i < numTasks; i++ {
        go task(i)
    }

    time.Sleep(time.Millisecond * 1000)
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，我们使用 `go` 语句创建多个 goroutine，它们将在不同的 CPU 核心上并发执行。主 Goroutine 等待所有任务完成，输出结果。

### 26. 使用 WaitGroup 等待多个 goroutine 完成

**题目：** 请解释 Golang 中如何使用 `WaitGroup` 来等待多个 goroutine 完成。

**答案：**

* **WaitGroup 的作用：** `WaitGroup` 是 Golang 中的一个同步工具，用于在主 Goroutine 中等待一组 goroutine 完成执行。
* **使用方法：**

1. **添加任务：** 使用 `Add` 方法将等待的 Goroutine 数量增加。
2. **等待完成：** 使用 `Wait` 方法阻塞主 Goroutine，直到所有添加的任务完成。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
)

func task(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Task %d started\n", id)
    time.Sleep(time.Millisecond * 500)
    fmt.Printf("Task %d completed\n", id)
}

func main() {
    var wg sync.WaitGroup
    numTasks := 5

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go task(i, &wg)
    }

    wg.Wait()
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，我们使用 `WaitGroup` 来等待 5 个 Goroutine 完成。`Add` 方法将等待的 Goroutine 数量增加，`defer wg.Done()` 确保在任务完成后将计数器减 1。`wg.Wait()` 阻塞主 Goroutine，直到所有任务完成。

### 27. 使用 channel 和 waitgroup 结合处理并发任务

**题目：** 请解释如何在 Golang 中使用 `channel` 和 `waitgroup` 结合来处理并发任务。

**答案：**

* **channel 的作用：** channel 用于在不同 Goroutine 之间传递数据。
* **waitgroup 的作用：** waitgroup 用于在主 Goroutine 中等待一组 Goroutine 完成。
* **使用方法：**

1. **创建 channel：** 在主 Goroutine 中创建一个通道，用于接收子 Goroutine 的完成信号。
2. **创建 waitgroup：** 创建一个 waitgroup，用于等待子 Goroutine 完成。
3. **启动子 Goroutine：** 在每个子 Goroutine 中，添加任务到 waitgroup，并向通道发送完成信号。
4. **等待子 Goroutine 完成：** 在主 Goroutine 中从通道接收完成信号，并等待 waitgroup 完成所有任务。

**举例：**

```go
package main

import (
    "fmt"
    "sync"
)

func task(id int, done chan<- bool, wg *sync.WaitGroup) {
    defer wg.Done()
    fmt.Printf("Task %d started\n", id)
    time.Sleep(time.Millisecond * 500)
    fmt.Printf("Task %d completed\n", id)
    done <- true
}

func main() {
    var wg sync.WaitGroup
    numTasks := 5
    done := make(chan bool, numTasks)

    for i := 0; i < numTasks; i++ {
        wg.Add(1)
        go task(i, done, &wg)
    }

    for i := 0; i < numTasks; i++ {
        <-done
    }

    wg.Wait()
    fmt.Println("All tasks completed.")
}
```

**解析：** 在这个例子中，我们使用 channel 和 waitgroup 结合来处理并发任务。每个子 Goroutine 在完成任务后，向 channel 发送完成信号。主 Goroutine 从 channel 接收信号，并等待 waitgroup 完成所有任务。

### 28. 使用 context 实现超时控制

**题目：** 请解释 Golang 中的 context包如何实现超时控制。

**答案：**

* **context包的作用：** context包提供了一种在程序中传递请求范围的数据和取消信号的方式，有助于处理异步操作。
* **超时控制：** 使用 context包提供的 `WithTimeout` 函数可以创建一个带有超时设置的上下文。

**使用方法：**

1. **创建上下文：** 使用 `context.Background()` 创建一个基础上下文，然后使用 `WithTimeout` 函数添加超时设置。
2. **传递上下文：** 将创建的上下文传递给需要执行超时控制的 Goroutine。
3. **检查超时：** 在 Goroutine 中检查上下文的 `Deadline` 或 `Timeout` 方法，以确定是否超时。

**举例：**

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func task(ctx context.Context, id int) {
    select {
    case <-ctx.Done():
        fmt.Printf("Task %d canceled due to timeout\n", id)
    default:
        fmt.Printf("Task %d started\n", id)
        time.Sleep(time.Millisecond * 1000)
        fmt.Printf("Task %d completed\n", id)
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
    defer cancel()

    numTasks := 5

    for i := 0; i < numTasks; i++ {
        go task(ctx, i)
    }

    // 等待任务完成，或者超时
    time.Sleep(time.Millisecond * 1500)
    fmt.Println("Main function completed.")
}
```

**解析：** 在这个例子中，我们创建了一个带有 500 毫秒超时的上下文。每个任务 Goroutine 使用 `select` 语句检查上下文的取消信号。如果超时，上下文的 `Done` 通道会关闭，`task` Goroutine 将打印取消信息并退出。如果任务在超时之前完成，将正常打印完成信息。

### 29. 使用 context 控制并发任务取消

**题目：** 请解释如何使用 Golang 的 context包来控制并发任务的取消。

**答案：**

* **取消并发任务：** 使用 context包可以方便地取消并发任务，通过传递取消信号给运行中的 Goroutine。
* **使用方法：**

1. **创建取消信号：** 使用 `context.WithCancel` 函数创建一个可以取消的上下文。
2. **传递取消信号：** 将创建的上下文传递给需要取消的任务 Goroutine。
3. **监听取消信号：** 在任务 Goroutine 中监听上下文的取消信号，并在接收到取消信号后停止执行。

**举例：**

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func task(ctx context.Context, id int) {
    select {
    case <-ctx.Done():
        fmt.Printf("Task %d canceled\n", id)
        return
    default:
        fmt.Printf("Task %d started\n", id)
        time.Sleep(time.Millisecond * 1000)
        fmt.Printf("Task %d completed\n", id)
    }
}

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    numTasks := 5

    for i := 0; i < numTasks; i++ {
        go task(ctx, i)
    }

    // 模拟用户取消任务
    time.Sleep(time.Millisecond * 500)
    cancel()
    fmt.Println("Cancelled all tasks.")
}
```

**解析：** 在这个例子中，我们创建了一个可取消的上下文。每个任务 Goroutine 在执行过程中会监听取消信号。当主 Goroutine 调用 `cancel()` 时，所有任务 Goroutine 将接收到取消信号并打印取消信息，然后退出执行。

### 30. 使用 context.WithTimeout 和 context.WithDeadline 实现超时和截止时间控制

**题目：** 请解释 Golang 中的 `context.WithTimeout` 和 `context.WithDeadline` 如何实现超时和截止时间控制。

**答案：**

* **`context.WithTimeout`：** 用于创建一个具有指定超时时间的上下文。一旦达到超时时间，上下文的 `Deadline` 会被触发，并返回超时错误。
* **`context.WithDeadline`：** 用于创建一个具有指定截止时间的上下文。一旦达到截止时间，上下文的 `Deadline` 会被触发，并返回超时错误。

**使用方法：**

1. **创建上下文：** 使用 `context.Background()` 创建一个基础上下文，然后使用 `WithTimeout` 或 `WithDeadline` 函数添加超时或截止时间。
2. **传递上下文：** 将创建的上下文传递给需要执行超时或截止时间控制的 Goroutine。
3. **检查超时或截止时间：** 在 Goroutine 中检查上下文的 `Deadline` 方法，以确定是否超时或达到截止时间。

**举例：**

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func task(ctx context.Context, id int) {
    select {
    case <-ctx.Done():
        fmt.Printf("Task %d canceled due to timeout/deadline\n", id)
    default:
        fmt.Printf("Task %d started\n", id)
        time.Sleep(time.Millisecond * 1000)
        fmt.Printf("Task %d completed\n", id)
    }
}

func main() {
    // 使用 WithTimeout 创建超时上下文
    ctxWithTimeout, cancelWithTimeout := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancelWithTimeout()

    // 使用 WithDeadline 创建截止时间上下文
    ctxWithDeadline, cancelWithDeadline := context.WithDeadline(context.Background(), time.Now().Add(3*time.Second))
    defer cancelWithDeadline()

    numTasks := 5

    for i := 0; i < numTasks; i++ {
        go task(ctxWithTimeout, i)
        go task(ctxWithDeadline, i)
    }

    time.Sleep(time.Millisecond * 1500)
    fmt.Println("Main function completed.")
}
```

**解析：** 在这个例子中，我们创建了一个具有 2 秒超时时间和 3 秒截止时间的上下文。每个任务 Goroutine 都会检查上下文的取消信号。如果 Goroutine 在 2 秒内完成，它们将不会取消。如果 Goroutine 在 3 秒内未完成，它们将因为达到截止时间而取消。主 Goroutine 在 1.5 秒后继续执行，因此所有任务 Goroutine 将因为截止时间而取消。输出将显示所有任务的取消信息。

