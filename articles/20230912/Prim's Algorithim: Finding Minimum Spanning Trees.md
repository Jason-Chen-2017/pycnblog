
作者：禅与计算机程序设计艺术                    

# 1.简介
  

在图论中,Prim算法用来在一个连通无向图G=(V,E)里找到一个最小生成树(Minimum Spanning Tree)。该算法具有两个阶段：
- 首先将任意一个顶点v加入到生成树T，并以v作为根节点。
- 在剩余的顶点集合V-{u}中选取权值最小的边{u,v}，其中u已经属于生成树T，则加入T中，并同时删除u-v这个边及其邻接点中的任何其他边。
- 重复第二步直至生成树T包含所有顶点。
该算法时间复杂度为O(n^2),其中n是顶点个数。
# 2. 相关概念
## 2.1 定义
对于一个给定的连通无向图G=(V,E)，一个顶点的度(degree)是指与该顶点相连接的边数，记做d(u)。如果G中所有顶点的度都不超过k，称G为k连通的(k-connected)。当G有k个连通分量时，称G为k连通图。
## 2.2 生成树
生成树是一个子图，它连接了所有的顶点，并且没有环。树中的每条边对应于图中的一条连接，且其权值是最小的。
## 2.3 MST
设G为一个带权连通无向图。一个生成树就是一个连接所有顶点的最小生成树(MST)，它只含有边，而且这些边的权值总和是最小的。

MST的另一种定义方法是：在一个连通无向图G中，若存在一个由n-1条边组成的子集E,使得从任意顶点u到任意顶点v都经过E中某条边(u,v)。则E必定为G的一棵生成树。换言之，MST是唯一的。

# 3. 算法原理
## 3.1 简单介绍
Prim算法以一个不在已构造的生成树中的顶点作为起始点，通过将连接初始点与其他顶点的权值最小边加入生成树，直至所有顶点都被包含进去为止。这种方式构成的生成树称为Prim算法的输出。
## 3.2 求解过程
1. 从图中任意选取一个顶点作为第一个顶点，并标记它为已选择。
2. 依次遍历除已选择外的所有顶点，选择其中连接已选择顶点的最小权值的边，加入到已选择边集合。
3. 对新添加的边进行标记，并重复第二步，直至所有顶点均已选择或生成树已满。
4. 将生成树输出，即所选边的集合。
## 3.3 证明
该算法是一个贪心算法，它每次只考虑增加最小权值的边而不考虑减少权值的影响。
### 证明1
由输入条件可知，G是一个连通无向图。由无向图的性质可知，对于任意的两个顶点u、v，都存在一条连接它们的路径。

又因为G是连通的，所以它存在一条路径P=uv，且对于任意的i∈[0,|P|-1],路径Pi都是u到Vi之间的边，所以路径Pu一定是由选择出的最小权值的边。
### 证明2
假设某个边{u,v}已经被选入生成树，假定他不是生成树中的最小权值的边，即有w(u,v)<min_{all edges}(w(u',v')<w(u,v)),但是u'与v'之间也可能有更小的边。

但由上面的证明1可知，路径Pu=u-v包含了最短路径，因此路径Pu包含了{u,v}这一边，说明它不是最小权值的边，不能加入到生成树中。所以该结论是错误的。
### 证明3
该算法运行结束后，生成树中的每条边的权值之和等于最小生成树的权值之和。因为每条边均是通过选择出的最小权值的边，而且新添加的边都是最小权值的，且都对生成树的权值有正作用。所以该结论正确。
# 4. 操作步骤
1. 初始化一个空的边集T和一个空的顶点集合S；
2. 任取出图G中任意一个顶点v；
3. 把v放入集合S；
4. 若集合S包含了图G的所有顶点，停止，否则执行下一步；
5. 找出集合S中的任意一顶点u，选择所有以u为终点的边中权值为最小的边，把这条边放入集合T中，并把它所在的顶点删掉；
6. 删除那些属于T的顶点；
7. 返回第3步继续执行。
# 5. 实例分析
## 5.1 Kruskal算法实现
### 描述
Kruskal算法基于贪心策略，每次从权值最小的边中选择加入生成树。

Kruskal算法的关键步骤是按照权重从小到大的顺序合并边，然后判断是否形成了回路（出现了环），若有回路则舍弃，反之则将该边放入生成树。

### 操作步骤
1. 构建一个最小堆H，每个节点保存一个边(u,v)及它的权重w(u,v)，初始时堆为空；
2. 建立一个表示并查集的数组F，初始时所有元素均为独立集，元素表示的是各个独立集的大小；
3. 执行如下循环直至堆H为空：
   - 从堆H中弹出权重最小的边e = (u, v, w);
   - 如果F[find(u)]!= F[find(v)], 表示u、v不属于同一独立集，把他们合并为一个独立集，则更新F[find(u)]的值；
   - 否则，跳过该边，因为这条边将产生回路，此时忽略掉它；
   - 最后把e加到生成树中，这样可以保证图中不存在回路。
4. 当循环结束后，得到的生成树即为Kruskal算法的结果。
## 5.2 Prim算法实现
### 描述
Prim算法是在图中选择一条连接顶点集中当前点与其他所有点的边，使得生成树的权值之和达到最小。

### 操作步骤
1. 初始化一个集合S用于存放已选择的顶点及相应的顶点到源点的距离dis[];
2. 以某一随机的顶点u为源点，并令dis[u]=0;
3. 执行如下循环：
   - 从集合V-S中选取最小的顶点v，其中v是与u直接相连的顶点，且v在集合V-S中；
   - 把边(u,v)加入到集合T中；
   - 更新集合S中的u、v以及dis[]值；
4. 当集合T中包含所有顶点，生成树T即完成。
# 6. 未来发展趋势与挑战
1. 多线程优化：适用于具有较大规模的图的问题；
2. 寻找与欧拉标准形的近似算法：适用于具有平坦结构的图；
3. 使用二进制编码压缩边集：降低内存占用及提高运行速度；