
作者：禅与计算机程序设计艺术                    

# 1.简介
  

树是一种数据结构，它具有多个分支，每个分支有多个子节点，用线连接起来。其特点是在同一个层次中，父节点下面的所有子节点都在同一侧，而不同层次之间子节点之间的位置关系不固定。
一般来说，树有四种主要的遍历方式：前序、中序、后序、层序。下面就详细介绍一下这几种遍历方式。
## 前序遍历（Preorder Traversal）
先根遍历又叫做先序遍历或递归遍历。它是树的一种遍历方法。这种遍历法先访问根结点，然后依次先序遍历左子树，再先序遍历右子树。这样就先访问根结点的左子树，从左子树的最底端节点开始。再回到根结点，依次遍历右子树，再次回到根结点，继续向上递归遍历左子树。
- 时间复杂度：$O(n)$，其中 n 为树中的结点个数。
- 空间复杂度：$O(h)$，其中 h 为树的高度。
- 应用场景：按照指定顺序打印树的所有结点的值。

### 代码实现
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def preorderTraversal(root):
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack.pop()
        
        # do something with the current node here
        result.append(node.val)

        # push its children onto the stack in reverse order (so they are popped in forward order later)
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result
```

### 示例


```
         1
      /   \
     2     3
   /    \     \
  4      5     6
           \
            7
``` 

前序遍历结果为`[1, 2, 4, 3, 5, 7, 6]`。

## 中序遍历（Inorder Traversal）
中序遍历也叫做中间序遍历或者后续遍历。它也是树的一种遍历方法。这种遍历法先依次中序遍历左子树，再访问根结点，最后中序遍历右子树。这样就可以先从最左边的节点开始，访问左子树，再访问根结点，再访问右子树。
- 时间复杂度：$O(n)$，其中 n 为树中的结点个数。
- 空间复杂度：$O(h)$，其中 h 为树的高度。
- 应用场景：建立索引表，排序链表等。

### 代码实现
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
    
def inorderTraversal(root):
    if not root:
        return []
    
    stack = []
    result = []
    
    curr = root
    
    while True:
        # move down as far as possible along the left side of the tree
        while curr:
            stack.append(curr)
            curr = curr.left
            
        if len(stack) == 0:
            break
        
        curr = stack.pop()
        
        # do something with the current node here
        result.append(curr.val)
    
        # move to the right child (if it exists) and continue going down the tree
        curr = curr.right
        
    return result
```

### 示例


```
         1
      /   \
     2     3
   /    \     \
  4      5     6
           \
            7
``` 

中序遍历结果为`[4, 2, 1, 5, 3, 7, 6]`。

## 后序遍历（Postorder Traversal）
后序遍历也叫做逆后序遍历，也是树的一种遍历方法。这种遍历法先中序遍历左子树，再中序遍历右子树，最后访问根结点。它的作用主要是释放栈所占用的存储空间。因此，如果应用要求树尽快被释放，则应该选择后序遍历。
- 时间复杂度：$O(n)$，其中 n 为树中的结点个数。
- 空间复杂度：$O(h)$，其中 h 为树的高度。
- 应用场景：释放堆栈所占用的存储空间。

### 代码实现
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def postorderTraversal(root):
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack[-1]
        
        # when we find a leaf or an unprocessed subtree on the left, traverse that subtree instead
        if not node.left or (node.left and node.left.visited):
            stack.pop()
            
            # do something with the current node here
            result.append(node.val)
            
            # mark this node as processed so we don't visit it again below
            node.visited = True
        else:
            # otherwise, go down the left subtree
            stack.append(node.left)
            node.left.visited = False
            
    return result
```

### 示例


```
         1
      /   \
     2     3
   /    \     \
  4      5     6
           \
            7
``` 

后序遍历结果为`[4, 2, 7, 5, 6, 3, 1]`。

## 层序遍历（Level Order Traversal）
层序遍历也称广度优先搜索，它是树的一种遍历方法。这种遍历法先按层次进行遍历，在每一层，从左至右访问所有节点。
- 时间复杂度：$O(n)$，其中 n 为树中的结点个数。
- 空间复杂度：$O(w)$，其中 w 是宽度。
- 应用场景：打印二叉树或输出图像等。

### 代码实现
```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        
def levelOrder(root):
    if not root:
        return []
    
    queue = deque([root])
    result = []
    
    while queue:
        levelSize = len(queue)
        
        for i in range(levelSize):
            currNode = queue.popleft()
            
            # add the current node's value to the list for this level
            result.append(currNode.val)
            
            # enqueue its children (if any) for the next level
            if currNode.left:
                queue.append(currNode.left)
            if currNode.right:
                queue.append(currNode.right)
                
    return result
```

### 示例


```
         1
      /   \
     2     3
   /    \     \
  4      5     6
           \
            7
``` 

层序遍历结果为`[[1], [2, 3], [4, 5, 6, 7]]`。