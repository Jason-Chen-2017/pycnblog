                 

### 百度2025届社招面试高频算法题解析

#### 目录

1. [字符串处理](#字符串处理)
2. [数组与矩阵](#数组与矩阵)
3. [链表](#链表)
4. [树与图](#树与图)
5. [排序与搜索](#排序与搜索)
6. [动态规划](#动态规划)
7. [数学与逻辑](#数学与逻辑)
8. [数据结构](#数据结构)

---

#### 1. 字符串处理

##### 1.1. 最长公共前缀

**题目：** 实现一个函数，求两个字符串的最长公共前缀。

```python
def longestCommonPrefix(strs):
    # 在这里实现逻辑
```

**答案：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        while s[:len(prefix)] != prefix:
            prefix = prefix[:-1]
            if not prefix:
                return ""
    return prefix
```

**解析：** 我们首先将第一个字符串作为初始的前缀。然后，我们逐个遍历剩余的字符串，每次都将当前前缀与字符串的前缀进行比较。如果当前字符串的前缀与当前前缀不匹配，我们就减少当前前缀的长度，直到找到一个匹配的最长公共前缀。

---

#### 2. 数组与矩阵

##### 2.1. 两个数组的交集 II

**题目：** 给定两个整数数组，输出两个数组中的交集。

```python
def intersect(nums1, nums2):
    # 在这里实现逻辑
```

**答案：**

```python
def intersect(nums1, nums2):
    from collections import Counter
    count1, count2 = Counter(nums1), Counter(nums2)
    ans = []
    for k, v in count1.items():
        if k in count2:
            ans.extend([k] * min(v, count2[k]))
    return ans
```

**解析：** 我们使用 Counter 来计算每个元素出现的次数。然后，我们遍历 Counter1 中的每个元素，如果该元素在 Counter2 中也存在，则将其添加到结果数组中，重复次数取两者中较小的值。

---

#### 3. 链表

##### 3.1. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
```

**答案：**

```python
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        prev = dummy
        p, q = list1, list2
        while p and q:
            if p.val < q.val:
                prev.next = p
                p = p.next
            else:
                prev.next = q
                q = q.next
            prev = prev.next
        prev.next = p if p else q
        return dummy.next
```

**解析：** 我们创建一个虚拟头节点 `dummy`，并使用 `prev` 指针来跟踪前一个节点。我们逐个比较两个链表的当前节点，将较小的值连接到 `prev` 的下一个节点。然后，我们将当前节点移动到下一个节点。最后，我们将剩余的未遍历链表连接到结果链表的末尾。

---

#### 4. 树与图

##### 4.1. 二叉树的层序遍历

**题目：** 实现二叉树的层序遍历。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
```

**答案：**

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        q = deque([root])
        ans = []
        while q:
            t = []
            for _ in range(len(q)):
                node = q.popleft()
                t.append(node.val)
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            ans.append(t)
        return ans
```

**解析：** 我们使用广度优先搜索（BFS）来实现层序遍历。首先，我们将根节点放入队列中。然后，我们逐层遍历节点，将每个节点的值添加到当前层的结果列表中，并将左右子节点添加到队列中。遍历完所有层后，我们得到层序遍历的结果。

---

#### 5. 排序与搜索

##### 5.1. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将被按顺序插入的位置。

```python
def searchInsert(nums, target):
    # 在这里实现逻辑
```

**答案：**

```python
def searchInsert(nums, target):
    left, right = 0, len(nums)
    while left < right:
        mid = (left + right) >> 1
        if nums[mid] >= target:
            right = mid
        else:
            left = mid + 1
    return left
```

**解析：** 这是一个二分查找的问题。我们使用二分查找找到目标值或者将其插入的位置。如果中间元素大于或等于目标值，我们将右边界更新为 `mid`。否则，我们将左边界更新为 `mid + 1`。当 `left` 等于 `right` 时，我们返回 `left`，即目标值的位置。

---

#### 6. 动态规划

##### 6.1. 最长递增子序列

**题目：** 给定一个无序数组，返回其最长递增子序列的长度。

```python
def lengthOfLIS(nums):
    # 在这里实现逻辑
```

**答案：**

```python
def lengthOfLIS(nums):
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**解析：** 我们使用动态规划来解决最长递增子序列问题。对于每个元素 `nums[i]`，我们检查它前面的所有元素 `nums[j]`（`j < i`）。如果 `nums[i] > nums[j]`，则我们可以将 `dp[i]` 更新为 `dp[j] + 1`。最终，我们返回所有 `dp[i]` 中的最大值。

---

#### 7. 数学与逻辑

##### 7.1. 汉诺塔问题

**题目：** 使用递归方法解决汉诺塔问题。

```python
def hanota(stick, from_peg, to_peg, aux_peg):
    # 在这里实现逻辑
```

**答案：**

```python
def hanota(stick, from_peg, to_peg, aux_peg):
    if len(stick) == 1:
        print(f"Move disk from {from_peg} to {to_peg}")
        return
    hanota(stick[1:], from_peg, aux_peg, to_peg)
    print(f"Move disk from {from_peg} to {to_peg}")
    hanota(stick[:-1], aux_peg, to_peg, from_peg)
```

**解析：** 汉诺塔问题是一个经典的递归问题。我们将问题分为三个步骤：首先，将 `from_peg` 上除了最下面的磁盘之外的所有磁盘移动到 `aux_peg`；然后，将最下面的磁盘移动到 `to_peg`；最后，将 `aux_peg` 上的所有磁盘移动到 `to_peg`。

---

#### 8. 数据结构

##### 8.1. 设计哈希链表

**题目：** 设计哈希链表。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class MyLinkedList:
    def __init__(self):
        # 在这里实现逻辑

    def get(self, index: int) -> int:
        # 在这里实现逻辑

    def addAtHead(self, val: int) -> None:
        # 在这里实现逻辑

    def addAtTail(self, val: int) -> None:
        # 在这里实现逻辑

    def addAtIndex(self, index: int, val: int) -> None:
        # 在这里实现逻辑

    def deleteAtIndex(self, index: int) -> None:
        # 在这里实现逻辑
```

**答案：**

```python
class MyLinkedList:

    def __init__(self):
        self.head = ListNode(0)
        self.size = 0

    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1
        cur = self.head
        for _ in range(index + 1):
            cur = cur.next
        return cur.val

    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)

    def addAtIndex(self, index: int, val: int) -> None:
        if index < 0 or index > self.size:
            return
        prev = self.head
        for _ in range(index):
            prev = prev.next
        new_node = ListNode(val, prev.next)
        prev.next = new_node
        self.size += 1

    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return
        prev = self.head
        for _ in range(index):
            prev = prev.next
        prev.next = prev.next.next
        self.size -= 1
```

**解析：** 我们使用一个虚拟头节点来简化边界条件的处理。`get` 方法通过遍历查找索引为 `index` 的节点。`addAtHead` 和 `addAtTail` 方法分别添加到头尾节点。`addAtIndex` 方法添加到指定的索引。`deleteAtIndex` 方法删除指定索引的节点。这些操作的时间复杂度都是 O(N)，其中 N 是链表的长度。

---

以上是百度2025届社招面试高频算法题的解析和代码示例。希望这些题目和解析能够帮助你更好地准备面试。如果有任何问题，欢迎在评论区提问。祝你好运！

