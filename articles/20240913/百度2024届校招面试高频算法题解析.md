                 

## 百度2024届校招面试高频算法题解析

### 题目1：最长公共子序列（LCS）

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找出它们的最长公共子序列。最长公共子序列（Longest Common Subsequence，LCS）是在两个序列中同时出现的最长子序列。

**输入：**
```
s1 = "ABCD"
s2 = "ACDF"
```

**输出：**
```
"ACD"
```

**解题思路：** 使用动态规划求解。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列的长度。

**解题步骤：**

1. 初始化 `dp` 数组，所有元素初始化为0。
2. 遍历 `s1` 和 `s2` 的所有字符。
3. 当 `s1[i-1] == s2[j-1]` 时，`dp[i][j] = dp[i-1][j-1] + 1`。
4. 当 `s1[i-1] != s2[j-1]` 时，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
5. 最后 `dp[m][n]` 就是 `s1` 和 `s2` 的最长公共子序列的长度。

**代码实现：**

```go
func longestCommonSubsequence(s1 string, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目2：合并区间（.Interval）

**题目描述：** 给定一个区间的集合，找到需要合并的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
[[1,6],[8,10],[15,18]]
```

**解题思路：** 首先将区间按照起点排序，然后遍历排序后的区间，判断当前区间是否与前一个区间有交集，如果有交集则合并区间。

**解题步骤：**

1. 将区间按照起点排序。
2. 初始化结果数组。
3. 遍历排序后的区间。
4. 如果当前区间的起点大于结果数组最后一个区间的终点，直接将当前区间添加到结果数组。
5. 如果当前区间与结果数组最后一个区间有交集，则更新结果数组最后一个区间的终点为当前区间的终点。

**代码实现：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    ans = append(ans, intervals[0])
    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] <= ans[len(ans)-1][1] {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目3：最长递增子序列（LIS）

**题目描述：** 给定一个无序数组，找出其中的最长递增子序列。

**输入：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

**输出：**
```
[2, 3, 7, 18]
```

**解题思路：** 使用动态规划求解。创建一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

**解题步骤：**

1. 初始化 `dp` 数组，所有元素初始化为1。
2. 遍历数组 `nums`。
3. 对于每个元素 `nums[i]`，遍历前面的所有元素 `nums[j]`。
4. 如果 `nums[i] > nums[j]` 且 `dp[i] < dp[j] + 1`，则更新 `dp[i]`。
5. 最后找到 `dp` 数组中的最大值，即为最长递增子序列的长度。

**代码实现：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] && dp[i] < dp[j]+1 {
                dp[i] = dp[j] + 1
            }
        }
    }
    return max(dp...)
}

func max(values ...int) int {
    m := values[0]
    for _, v := range values {
        if v > m {
            m = v
        }
    }
    return m
}
```

### 题目4：最大子序和（Kadane算法）

**题目描述：** 给定一个整数数组 `nums` ，找出数组中的连续子数组最大和。

**输入：**
```
nums = [-2,1,-3,4,-1,2,1,-5,4]
```

**输出：**
```
6
```

**解题思路：** 使用Kadane算法，维护一个当前最大子序列和 `curSum`，和一个全局最大子序列和 `maxSum`。

**解题步骤：**

1. 初始化 `curSum` 和 `maxSum` 为数组的第一个元素。
2. 遍历数组，对于每个元素：
   - 将当前元素加到 `curSum`。
   - 如果 `curSum` 小于0，将 `curSum` 重置为0。
   - 更新 `maxSum` 为 `max(maxSum, curSum)`。
3. 最后 `maxSum` 即为最大子序列和。

**代码实现：**

```go
func maxSubArray(nums []int) int {
    curSum, maxSum := nums[0], nums[0]
    for i := 1; i < len(nums); i++ {
        curSum = max(nums[i], curSum+nums[i])
        maxSum = max(maxSum, curSum)
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目5：反转链表

**题目描述：** 反转一个单链表。

**输入：**
```
head = [1,2,3,4,5]
```

**输出：**
```
[5,4,3,2,1]
```

**解题思路：** 使用递归或迭代方法反转链表。以下是迭代方法：

**解题步骤：**

1. 初始化三个指针：`prev`、`cur` 和 `next`。
2. `prev` 初始为 `nil`，`cur` 初始为头节点。
3. 遍历链表，每次循环执行以下操作：
   - 将 `next` 指向当前节点的下一个节点。
   - 将当前节点的下一个节点指向 `prev`。
   - 将 `prev` 移动到当前节点。
   - 将 `cur` 移动到 `next`。
4. 当 `cur` 为 `nil` 时，`prev` 就是新的头节点。

**代码实现：**

```go
func reverseList(head *ListNode) *ListNode {
    prev, cur := nil, head
    for cur != nil {
        next := cur.Next
        cur.Next = prev
        prev = cur
        cur = next
    }
    return prev
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

### 题目6：两数相加

**题目描述：** 不使用运算符，实现两个整数相加。

**输入：**
```
l1 = [2,4,3]
l2 = [5,6,4]
```

**输出：**
```
[7,0,7]
```

**解题思路：** 使用模拟加法的方法，从低位到高位逐位相加，并处理进位。

**解题步骤：**

1. 创建一个新的链表来存储结果。
2. 初始化两个指针，分别指向两个链表的头部。
3. 当两个指针都指向非空节点时，执行以下操作：
   - 将两个节点的值相加，得到和。
   - 如果和大于9，则进位，和减去10。
   - 将和的个位数添加到结果链表中。
   - 将两个指针同时向后移动。
4. 如果其中一个链表已经遍历完，将另一个链表的剩余部分添加到结果链表中。
5. 如果相加过程中产生了进位，将进位添加到结果链表中。

**代码实现：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        val2 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := carry + val1 + val2
        carry = sum / 10
        cur.Next = &ListNode{Val: sum % 10}
        cur = cur.Next
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

### 题目7：零钱兑换

**题目描述：** 给定不同面额的硬币和一个总金额，计算有多少种凑足总金额的方法。

**输入：**
```
coins = [1, 2, 5]
amount = 11
```

**输出：**
```
3
```

**解题思路：** 使用动态规划求解。定义一个数组 `dp`，其中 `dp[i]` 表示凑出金额 `i` 的方法数。

**解题步骤：**

1. 初始化 `dp` 数组，`dp[0]` 为1，其他元素为0。
2. 遍历每个硬币的面额。
3. 对于每个硬币，遍历金额 `i` 从 `coin` 到 `amount`。
4. 对于每个金额 `i`，更新 `dp[i]` 为 `dp[i] + dp[i - coin]`。

**代码实现：**

```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    dp[0] = 1
    for _, coin := range coins {
        for i := coin; i <= amount; i++ {
            dp[i] += dp[i-coin]
        }
    }
    if dp[amount] == 0 {
        return -1
    }
    return dp[amount]
}
```

### 题目8：单词搜索

**题目描述：** 给定一个二维字符网格和一个单词，判断该单词是否存在于网格中。

**输入：**
```
board = [
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
word = "ABCCED"
```

**输出：**
```
true
```

**解题思路：** 使用回溯算法搜索网格。对于每个起始位置，如果当前字符与单词的第一个字符匹配，则递归搜索下一个字符。

**解题步骤：**

1. 遍历网格的每个位置作为起始位置。
2. 对于每个起始位置，如果当前字符与单词的第一个字符匹配，则开始回溯搜索。
3. 在回溯过程中，标记当前字符为已访问，然后继续搜索下一个字符。
4. 如果找到单词的最后一个字符，返回 `true`。
5. 如果搜索过程中出现不匹配的情况，回溯到上一个字符并继续搜索。

**代码实现：**

```go
func exist(board [][]byte, word string) bool {
    rows, cols := len(board), len(board[0])
    visit := make([][]bool, rows)
    for i := range visit {
        visit[i] = make([]bool, cols)
    }
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if board[i][j] == word[0] && search(board, visit, word, 0, i, j) {
                return true
            }
        }
    }
    return false
}

func search(board [][]byte, visit [][]bool, word string, idx int, i, j int) bool {
    rows, cols := len(board), len(board[0])
    if i < 0 || i >= rows || j < 0 || j >= cols || visit[i][j] || board[i][j] != word[idx] {
        return false
    }
    visit[i][j] = true
    idx++
    if idx == len(word) {
        return true
    }
    if search(board, visit, word, idx, i+1, j) {
        return true
    }
    if search(board, visit, word, idx, i-1, j) {
        return true
    }
    if search(board, visit, word, idx, i, j+1) {
        return true
    }
    if search(board, visit, word, idx, i, j-1) {
        return true
    }
    visit[i][j] = false
    return false
}
```

### 题目9：股票交易的最佳时机

**题目描述：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。如果在一个周期内只允许你完成一笔交易，设计一个算法来找出最大的利润。

**输入：**
```
prices = [7,1,5,3,6,4]
```

**输出：**
```
5
```

**解题思路：** 维护两个变量 `minPrice` 和 `maxProfit`，分别记录到当前为止遇到的最小价格和最大利润。

**解题步骤：**

1. 初始化 `minPrice` 为第一个价格，`maxProfit` 为0。
2. 遍历数组，对于每个元素：
   - 更新 `minPrice` 为当前元素和之前的 `minPrice` 中的较小值。
   - 计算 `maxProfit` 为当前价格减去 `minPrice`，并与之前的 `maxProfit` 比较，取较大值。
3. 最后 `maxProfit` 就是最大利润。

**代码实现：**

```go
func maxProfit(prices []int) int {
    minPrice, maxProfit := prices[0], 0
    for _, price := range prices {
        minPrice = min(minPrice, price)
        maxProfit = max(maxProfit, price-minPrice)
    }
    return maxProfit
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

### 题目10：移动零

**题目描述：** 给定一个整数数组 `nums`，编写一个函数来移动它所有的 `0` 到数字的末尾，同时保持非零元素的相对顺序。

**输入：**
```
nums = [0,1,0,3,12]
```

**输出：**
```
[1,3,12,0,0]
```

**解题思路：** 使用双指针方法，一个指针 `i` 指向当前非零元素的索引，另一个指针 `j` 遍历数组。

**解题步骤：**

1. 初始化 `i` 为0，`j` 为0。
2. 遍历数组，每次移动 `j` 指针直到遇到一个非零元素。
3. 如果 `j` 指向的元素是非零的，将 `nums[i]` 和 `nums[j]` 交换，同时将 `i` 加1。
4. 当 `j` 遍历完整个数组后，从 `i` 到数组末尾的所有元素都应该是0。

**代码实现：**

```go
func moveZeroes(nums []int) {
    i, j := 0, 0
    for j < len(nums) {
        if nums[j] != 0 {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
        j++
    }
}
```

### 题目11：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**解题思路：** 创建一个新的链表，比较两个链表的头节点，将较小的节点添加到新链表中，并将该链表指向下一个节点。

**解题步骤：**

1. 创建一个哑节点 `dummy`，用于方便返回新链表。
2. 初始化两个指针 `p` 和 `q`，分别指向 `l1` 和 `l2` 的头节点。
3. 比较两个指针所指向的节点，将较小的节点添加到新链表中，并将该指针向后移动。
4. 如果其中一个链表到达末尾，将另一个链表的剩余部分直接添加到新链表的末尾。

**代码实现：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    p, q := l1, l2
    for p != nil && q != nil {
        if p.Val < q.Val {
            cur.Next = p
            p = p.Next
        } else {
            cur.Next = q
            q = q.Next
        }
        cur = cur.Next
    }
    if p != nil {
        cur.Next = p
    }
    if q != nil {
        cur.Next = q
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

### 题目12：有效的括号

**题目描述：** 给定一个包含大括号的字符串，验证它是否为有效的括号字符串，括号必须正确闭合。

**输入：**
```
s = "()"
```

**输出：**
```
true
```

**解题思路：** 使用栈来模拟括号匹配。遇到左括号时入栈，遇到右括号时检查栈顶元素是否匹配，匹配则出栈。

**解题步骤：**

1. 初始化一个空栈。
2. 遍历字符串，对于每个字符：
   - 如果是左括号，将字符入栈。
   - 如果是右括号，检查栈顶元素是否匹配，不匹配则返回 `false`，匹配则出栈。
3. 最后检查栈是否为空，为空则返回 `true`。

**代码实现：**

```go
func isValid(s string) bool {
    stack := []rune{}
    for _, c := range s {
        if c == '(' || c == '{' || c == '[' {
            stack = append(stack, c)
        } else {
            if len(stack) == 0 {
                return false
            }
            top := stack[len(stack)-1]
            if (c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[') {
                return false
            }
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

### 题目13：旋转图像

**题目描述：** 给定一个 `n x n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 `90 度`。

**输入：**
```
matrix = [
  [1,2,3],
  [4,5,6],
  [7,8,9]
]
```

**输出：**
```
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**解题思路：** 可以先水平翻转矩阵，然后沿着对角线进行旋转。

**解题步骤：**

1. 水平翻转矩阵，即交换矩阵中每一行的元素。
2. 沿着对角线进行旋转，即交换矩阵中 `(i, j)` 和 `(j, i)` 的元素。

**代码实现：**

```go
func rotate(matrix [][]int) {
    n := len(matrix)
    for i := 0; i < n/2; i++ {
        for j := 0; j < n; j++ {
            matrix[i][j], matrix[n-1-i][n-1-j] = matrix[n-1-i][n-1-j], matrix[i][j]
        }
    }
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
}
```

### 题目14：最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**输入：**
```
strs = ["flower","flow","flight"]
```

**输出：**
```
"fl"
```

**解题思路：** 从第一个字符串开始，依次与后面的字符串比较，找出公共前缀。

**解题步骤：**

1. 如果字符串数组为空，返回空字符串。
2. 如果数组中只有一个字符串，返回该字符串。
3. 将第一个字符串与后面的每个字符串进行比较，找出公共前缀。

**代码实现：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    if len(strs) == 1 {
        return strs[0]
    }
    prefix := strs[0]
    for _, str := range strs[1:] {
        for prefix != "" && !strings.HasPrefix(str, prefix) {
            prefix = prefix[:len(prefix)-1]
        }
    }
    return prefix
}
```

### 题目15：爬楼梯

**题目描述：** 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**输入：**
```
n = 3
```

**输出：**
```
3
```

**解题思路：** 使用动态规划，定义 `dp[i]` 为到达第 `i` 阶的方法数。

**解题步骤：**

1. 初始化 `dp[0]` 和 `dp[1]`，因为到达第0阶和第1阶的方法只有1种。
2. 从第2阶开始，计算每个台阶的方法数，`dp[i] = dp[i-1] + dp[i-2]`。

**代码实现：**

```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }
    dp := make([]int, n)
    dp[0], dp[1] = 1, 2
    for i := 2; i < n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n-1]
}
```

### 题目16：三数之和

**题目描述：** 给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 `a`，`b`，`c`，使得 `a + b + c = 0`？找出所有满足条件且不重复的三元组。

**输入：**
```
nums = [-1,0,1,2,-1,-4]
```

**输出：**
```
[[-1,-1,2],[-1,0,1]]
```

**解题思路：** 先对数组进行排序，然后使用双指针法找到满足条件的三元组。

**解题步骤：**

1. 对数组进行排序。
2. 遍历数组，对于每个元素 `nums[i]`：
   - 如果 `i > 0` 且 `nums[i] == nums[i-1]`，跳过当前元素，避免重复。
   - 初始化两个指针 `left` 和 `right`，分别指向 `i+1` 和 `len(nums)-1`。
   - 循环执行以下步骤：
     - 如果 `left + right == nums[i]`，找到一个三元组，将 `left` 和 `right` 分别向后移动，并跳过重复元素。
     - 如果 `left + right < nums[i]`，将 `left` 向后移动。
     - 如果 `left + right > nums[i]`，将 `right` 向后移动。

**代码实现：**

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    var triples [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}
```

### 题目17：最长连续序列

**题目描述：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**输入：**
```
nums = [100, 4, 200, 1, 3, 2]
```

**输出：**
```
4
```

**解题思路：** 使用哈希表记录每个数字出现的次数，然后遍历数组，对于每个数字，检查该数字的前一个和后一个数字是否出现，以此来构建连续序列。

**解题步骤：**

1. 初始化一个哈希表 `cnt` 记录每个数字出现的次数。
2. 遍历数组，更新哈希表。
3. 初始化 `maxLen` 为0，遍历数组，对于每个数字：
   - 如果 `cnt[num-1] > 0`，则递增序列长度，`cnt[num-1]--`。
   - 如果 `cnt[num+1] > 0`，则递增序列长度，`cnt[num+1]--`。
   - 更新 `maxLen` 为当前连续序列的长度。

**代码实现：**

```go
func longestConsecutive(nums []int) int {
    cnt := make(map[int]int)
    for _, num := range nums {
        cnt[num]++
    }
    maxLen := 0
    for _, num := range nums {
        if cnt[num] == 0 {
            continue
        }
        cnt[num]--
        left, right := num-1, num+1
        for cnt[left] > 0 {
            cnt[left]--
            left--
        }
        for cnt[right] > 0 {
            cnt[right]--
            right++
        }
        maxLen = max(maxLen, right-left+1)
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目18：合并二叉树

**题目描述：** 给定两个二叉树，合并它们的节点值。

**输入：**
```
root1 = [1,3,2,5]
root2 = [2,1,3,null,4,null,7]
```

**输出：**
```
[3,4,5,5,4,null,7]
```

**解题思路：** 递归遍历两个二叉树，对于每个节点，将两个节点的值相加，并将结果作为新树的当前节点。

**解题步骤：**

1. 如果两个节点都为空，返回 `nil`。
2. 如果其中一个节点为空，返回另一个节点的复制。
3. 否则，创建一个新的节点，其值为两个节点的值相加，然后递归合并左右子树。

**代码实现：**

```go
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

### 题目19：合并多个表

**题目描述：** 给定多个有序表，合并它们并返回结果。

**输入：**
```
lists = [
  [1,4,5],
  [1,3,4],
  [2,6]
]
```

**输出：**
```
[1,1,2,3,4,4,5,6]
```

**解题思路：** 使用优先队列（小根堆）来维护当前最小的元素。

**解题步骤：**

1. 将每个有序表的第一个元素放入优先队列中。
2. 从优先队列中取出最小的元素，将其添加到结果中，并取出该元素的下一个元素放入优先队列中。
3. 重复步骤2，直到优先队列为空。

**代码实现：**

```go
func mergeKLists(lists []*ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    q := &优先队列{}
    for _, list := range lists {
        if list != nil {
            q.push(list)
        }
    }
    for !q.isEmpty() {
        node := q.pop()
        cur.Next = &ListNode{Val: node.Val}
        cur = cur.Next
        if node.Next != nil {
            q.push(node.Next)
        }
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}

type PriorityQueue struct {
    heap []interface{}
}

func (q *PriorityQueue) push(val interface{}) {
    q.heap = append(q.heap, val)
    q.heapSort()
}

func (q *PriorityQueue) pop() interface{} {
    val := q.heap[0]
    q.heap[0] = q.heap[len(q.heap)-1]
    q.heap = q.heap[:len(q.heap)-1]
    q.heapSort()
    return val
}

func (q *PriorityQueue) isEmpty() bool {
    return len(q.heap) == 0
}

func (q *PriorityQueue) heapSort() {
    n := len(q.heap)
    for i := n/2 - 1; i >= 0; i-- {
        q.heapify(i, n)
    }
    for i := n - 1; i > 0; i-- {
        q.heap[i], q.heap[0] = q.heap[0], q.heap[i]
        q.heapify(0, i)
    }
}

func (q *PriorityQueue) heapify(i, n int) {
    l := 2*i + 1
    r := 2*i + 2
    smallest := i
    if l < n && q.heap[l].(int) < q.heap[smallest].(int) {
        smallest = l
    }
    if r < n && q.heap[r].(int) < q.heap[smallest].(int) {
        smallest = r
    }
    if smallest != i {
        q.heap[i], q.heap[smallest] = q.heap[smallest], q.heap[i]
        q.heapify(smallest, n)
    }
}
```

### 题目20：最长公共子串

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找到它们的最长公共子串。

**输入：**
```
s1 = "abcde"
s2 = "acede"
```

**输出：**
```
"ace"
```

**解题思路：** 使用动态规划求解。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子串的长度。

**解题步骤：**

1. 初始化 `dp` 数组，所有元素初始化为0。
2. 遍历 `s1` 和 `s2` 的所有字符。
3. 当 `s1[i-1] == s2[j-1]` 时，`dp[i][j] = dp[i-1][j-1] + 1`。
4. 当 `s1[i-1] != s2[j-1]` 时，`dp[i][j] = 0`。
5. 找到 `dp` 数组中的最大值，即为最长公共子串的长度。

**代码实现：**

```go
func longestCommonSubstring(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    var maxLen, endIndex int
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > maxLen {
                    maxLen = dp[i][j]
                    endIndex = i - 1
                }
            } else {
                dp[i][j] = 0
            }
        }
    }
    return s1[endIndex-maxLen+1 : endIndex+1]
}
```

### 题目21：寻找两个正序数组的中位数

**题目描述：** 给定两个已排序的整数数组 `nums1` 和 `nums2`，找到它们的中位数。

**输入：**
```
nums1 = [1, 3]
nums2 = [2]
```

**输出：**
```
2
```

**解题思路：** 使用二分查找法。找到一个分割点，使得两个数组中的元素数量相等或者相差1，然后比较分割点两侧的元素。

**解题步骤：**

1. 定义两个指针 `i` 和 `j`，分别指向 `nums1` 和 `nums2` 的起始位置。
2. 定义两个变量 `mid1` 和 `mid2`，分别用于存储中位数。
3. 使用二分查找法找到分割点：
   - 如果 `i + j` 是奇数，则 `mid1 = nums1[mid]`，`mid2 = nums2[mid]`。
   - 如果 `i + j` 是偶数，则 `mid1 = (nums1[mid-1] + nums1[mid]) / 2`，`mid2 = (nums2[mid-1] + nums2[mid]) / 2`。
4. 根据中位数的定义，计算中位数。

**代码实现：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            break
        }
    }
    i, j := imin, halfLen-imin
    if i == 0 {
        maxLeft = nums2[j-1]
    } else if j == 0 {
        maxLeft = nums1[i-1]
    } else {
        maxLeft = max(nums1[i-1], nums2[j-1])
    }
    if (m+n) % 2 == 1 {
        return float64(maxLeft)
    }
    if i == m {
        minRight = nums2[j]
    } else if j == n {
        minRight = nums1[i]
    } else {
        minRight = min(nums1[i], nums2[j])
    }
    return (maxLeft + minRight) / 2.0
}
```

### 题目22：最长重复子串

**题目描述：** 给定一个字符串 `s` ，找出其最长的重复子串，输出其长度。

**输入：**
```
s = "abcdabcabcde"
```

**输出：**
```
4
```

**解题思路：** 使用后缀数组或后缀树。通过比较后缀，找出最长的重复子串。

**解题步骤：**

1. 构建后缀数组或后缀树。
2. 遍历后缀数组或后缀树，对于每个后缀，比较与前一个后缀的相同部分。
3. 找出最长的相同部分，即为最长重复子串。

**代码实现：**

```go
// 后缀树实现
func longestRepeatingSubstring(s string) int {
    n := len(s)
    trie := NewTrie()
    for i := 0; i < n; i++ {
        insertSuffixToTrie(trie, s[i:], i)
    }
    longestLen, _ := searchLongestRepeatingSubstring(trie, s[0:], 0)
    return longestLen
}

func insertSuffixToTrie(trie *Trie, suffix string, index int) {
    node := trie
    for _, char := range suffix {
        if _, ok := node.Children[char]; !ok {
            node.Children[char] = &Trie{}
        }
        node = node.Children[char]
        node.Index = index
    }
}

func searchLongestRepeatingSubstring(trie *Trie, prefix string, index int) (int, int) {
    if trie == nil {
        return 0, 0
    }
    maxLen, maxIndex := 0, -1
    for char, node := range trie.Children {
        nextIndex := node.Index
        if nextIndex != index {
            subStr := prefix + string(char)
            len := len(subStr)
            if len > maxLen {
                maxLen = len
                maxIndex = nextIndex
            }
        }
    }
    if maxIndex == -1 {
        return maxLen, node.Index
    } else {
        subStr := prefix + string(char)
        return searchLongestRepeatingSubstring(node, subStr, maxIndex) + 1
    }
}

// 后缀数组实现
func longestRepeatingSubstring(s string) int {
    n := len(s)
    p := make([]int, n+1)
    p[0] = 0
    for i := 1; i <= n; i++ {
        k := p[i-1]
        for k > 0 && s[i-1] != s[k-1] {
            k = p[k-1]
        }
        if s[i-1] == s[k-1] {
            p[i] = k + 1
        } else {
            p[i] = 1
        }
    }
    longestLen := 0
    for i := 1; i <= n; i++ {
        if p[i] > longestLen {
            longestLen = p[i]
        }
    }
    return longestLen
}
```

### 题目23：最长公共子序列

**题目描述：** 给定两个字符串 `s1` 和 `s2`，找出它们的最长公共子序列。

**输入：**
```
s1 = "ABCD"
s2 = "ACDF"
```

**输出：**
```
"ACD"
```

**解题思路：** 使用动态规划求解。创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列的长度。

**解题步骤：**

1. 初始化 `dp` 数组，所有元素初始化为0。
2. 遍历 `s1` 和 `s2` 的所有字符。
3. 当 `s1[i-1] == s2[j-1]` 时，`dp[i][j] = dp[i-1][j-1] + 1`。
4. 当 `s1[i-1] != s2[j-1]` 时，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
5. 最后 `dp[m][n]` 就是 `s1` 和 `s2` 的最长公共子序列的长度。

**代码实现：**

```go
func longestCommonSubsequence(s1 string, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    var result []rune
    i, j := m, n
    for i > 0 && j > 0 {
        if s1[i-1] == s2[j-1] {
            result = append(result, s1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    for i > 0 {
        result = append(result, s1[i-1])
        i--
    }
    for j > 0 {
        result = append(result, s2[j-1])
        j--
    }
    reverse(result)
    return string(result)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func reverse(s []rune) {
    n := len(s)
    for i := 0; i < n/2; i++ {
        s[i], s[n-1-i] = s[n-1-i], s[i]
    }
}
```

### 题目24：单词拆分

**题目描述：** 给定一个字符串 `s` 和一个字符串数组 `wordDict`，返回 `s` 可以被 `wordDict` 中的单词拆分成的最大数量。

**输入：**
```
s = "applepenapple"
wordDict = ["apple", "pen"]
```

**输出：**
```
3
```

**解题思路：** 使用动态规划求解。定义一个数组 `dp`，其中 `dp[i]` 表示 `s` 的前 `i` 个字符可以拆分成 `wordDict` 中的单词的最大数量。

**解题步骤：**

1. 初始化 `dp` 数组，所有元素初始化为0。
2. 对于每个位置 `i`，遍历所有可能的 `j`（`j < i`），如果 `s[j:i]` 在 `wordDict` 中，则 `dp[i] = max(dp[i], dp[j] + 1)`。
3. 最后 `dp[n]` 就是 `s` 可以被 `wordDict` 中的单词拆分成的最大数量。

**代码实现：**

```go
func wordBreak(s string, wordDict []string) int {
    n := len(s)
    dp := make([]int, n+1)
    dp[0] = 1
    for i := 1; i <= n; i++ {
        for j := 0; j < i; j++ {
            if contains(wordDict, s[j:i]) {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return dp[n]
}

func contains(words []string, sub string) bool {
    for _, word := range words {
        if word == sub {
            return true
        }
    }
    return false
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目25：删除排序数组中的重复项

**题目描述：** 给定一个排序数组 `nums`，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

**输入：**
```
nums = [0,0,1,1,1,2,2,3,3,4]
```

**输出：**
```
5, nums = [0,1,2,3,4]
```

**解题思路：** 使用快慢指针。定义两个指针 `fast` 和 `slow`，`fast` 指针用于遍历数组，`slow` 指针用于记录不重复元素的位置。

**解题步骤：**

1. 初始化 `fast` 和 `slow` 都为0。
2. 遍历数组，每次 `fast` 指针向前移动。
3. 如果 `nums[fast] != nums[slow]`，将 `nums[slow]` 更新为 `nums[fast]`，并使 `slow` 指针向前移动。
4. 最后 `slow + 1` 就是新的数组长度。

**代码实现：**

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    slow, fast := 0, 0
    for fast < len(nums) {
        if nums[fast] != nums[slow] {
            slow++
            nums[slow] = nums[fast]
        }
        fast++
    }
    return slow + 1
}
```

### 题目26：合并两个有序链表

**题目描述：** 将两个有序链表合并为一个新的、有序的链表并返回。

**输入：**
```
l1 = [1,2,4]
l2 = [1,3,4]
```

**输出：**
```
[1,1,2,3,4,4]
```

**解题思路：** 创建一个哑节点，使用双指针法逐个比较两个链表中的节点，选择较小的节点添加到新链表中。

**解题步骤：**

1. 创建一个哑节点 `dummy`，用于返回新的链表。
2. 初始化两个指针 `p` 和 `q`，分别指向 `l1` 和 `l2` 的头节点。
3. 比较 `p` 和 `q` 的值，较小的节点添加到新链表中，并将该指针向后移动。
4. 如果其中一个链表到达末尾，将另一个链表的剩余部分直接添加到新链表的末尾。

**代码实现：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    p, q := l1, l2
    for p != nil && q != nil {
        if p.Val < q.Val {
            cur.Next = p
            p = p.Next
        } else {
            cur.Next = q
            q = q.Next
        }
        cur = cur.Next
    }
    if p != nil {
        cur.Next = p
    }
    if q != nil {
        cur.Next = q
    }
    return dummy.Next
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

### 题目27：矩阵中的最大矩形

**题目描述：** 给定一个由 `0` 和 `1` 组成的二维矩阵，找出其中元素全为 `1` 的最大的矩形，并返回其面积。

**输入：**
```
matrix = [
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```

**输出：**
```
6
```

**解题思路：** 首先将矩阵转换为每行的高度数组，然后对每行使用单调栈的方法求出每个元素的最大矩形面积，最后找出最大的矩形面积。

**解题步骤：**

1. 将矩阵转换为每行的高度数组。
2. 对每行使用单调栈的方法求出每个元素的最大矩形面积。
3. 找出最大的矩形面积。

**代码实现：**

```go
func maximalRectangle(matrix [][]byte) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }
    m, n := len(matrix), len(matrix[0])
    heights := make([]int, n)
    maxArea := 0
    for i := 0; i < m; i++ {
        stack := []int{}
        for j := 0; j < n; j++ {
            for len(stack) > 0 && matrix[i][stack[len(stack)-1]] == '0' {
                stack = stack[:len(stack)-1]
            }
            if len(stack) == 0 {
                heights[j] = 0
            } else {
                heights[j] = i - stack[len(stack)-1]
            }
            for len(stack) > 0 && (heights[j] < heights[stack[len(stack)-1]]) {
                h := heights[stack[len(stack)-1]]
                stack = stack[:len(stack)-1]
                width := j - stack[len(stack)-1] - 1
                maxArea = max(maxArea, h*width)
            }
            stack = append(stack, j)
        }
        for len(stack) > 0 {
            h := heights[stack[len(stack)-1]]
            stack = stack[:len(stack)-1]
            width := n - stack[len(stack)-1] - 1
            maxArea = max(maxArea, h*width)
        }
    }
    return maxArea
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目28：合并区间

**题目描述：** 给定一组区间，合并所有重叠的区间。

**输入：**
```
intervals = [[1,3],[2,6],[8,10],[15,18]]
```

**输出：**
```
[[1,6],[8,10],[15,18]]
```

**解题思路：** 首先将区间按照起点排序，然后遍历排序后的区间，判断当前区间是否与前一个区间有交集，如果有交集则合并区间。

**解题步骤：**

1. 将区间按照起点排序。
2. 初始化结果数组。
3. 遍历排序后的区间。
4. 如果当前区间的起点大于结果数组最后一个区间的终点，直接将当前区间添加到结果数组。
5. 如果当前区间与结果数组最后一个区间有交集，则更新结果数组最后一个区间的终点为当前区间的终点。

**代码实现：**

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    ans = append(ans, intervals[0])
    for i := 1; i < len(intervals); i++ {
        if intervals[i][0] <= ans[len(ans)-1][1] {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], intervals[i][1])
        } else {
            ans = append(ans, intervals[i])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 题目29：最长递增子序列

**题目描述：** 给定一个无序数组，找出其中的最长递增子序列。

**输入：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
```

**输出：**
```
[2, 3, 7, 18]
```

**解题思路：** 使用动态规划求解。定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

**解题步骤：**

1. 初始化 `dp` 数组，所有元素初始化为1。
2. 遍历数组，对于每个元素 `nums[i]`：
   - 遍历前面的所有元素 `nums[j]`。
   - 如果 `nums[i] > nums[j]` 且 `dp[i] < dp[j] + 1`，则更新 `dp[i]`。
3. 找到 `dp` 数组中的最大值，即为最长递增子序列的长度。

**代码实现：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] && dp[i] < dp[j]+1 {
                dp[i] = dp[j] + 1
            }
        }
    }
    return max(dp...)
}

func max(values ...int) int {
    m := values[0]
    for _, v := range values {
        if v > m {
            m = v
        }
    }
    return m
}
```

### 题目30：排序链表

**题目描述：** 对链表进行就地排序。

**输入：**
```
head = [4,2,1,3]
```

**输出：**
```
[1,2,3,4]
```

**解题思路：** 使用归并排序对链表进行排序。首先将链表分解成多个子链表，然后对这些子链表进行合并。

**解题步骤：**

1. 使用快慢指针找到链表的中点。
2. 将链表拆分成两个子链表。
3. 递归地对两个子链表进行排序。
4. 合并两个已排序的链表。

**代码实现：**

```go
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    middle := slow.Next
    slow.Next = nil
    left := sortList(head)
    right := sortList(middle)
    return merge(left, right)
}

func merge(left, right *ListNode) *ListNode {
    if left == nil {
        return right
    }
    if right == nil {
        return left
    }
    if left.Val < right.Val {
        left.Next = merge(left.Next, right)
        return left
    } else {
        right.Next = merge(left, right.Next)
        return right
    }
}

type ListNode struct {
    Val int
    Next *ListNode
}
```

### 总结

通过以上解析，我们可以看到，百度2024届校招面试高频算法题覆盖了各种类型的算法问题，包括字符串处理、数组操作、链表操作、动态规划、回溯算法等。这些问题不仅考察了应聘者的算法基础，还考察了编程能力和问题解决能力。在解题过程中，我们需要理解题目要求，选择合适的算法，并进行代码实现。同时，我们也需要注意代码的优化和效率问题。

希望这些解析能够帮助你更好地理解和解决面试中的算法问题，提高你的面试准备。祝你在面试中取得好成绩！

