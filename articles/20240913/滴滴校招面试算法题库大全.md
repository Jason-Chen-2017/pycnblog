                 

### 1. 无重复字符的最长子串

**题目：** 给定一个字符串 `s` ，找出其中不含重复字符的最长子串的长度。

**示例：**
```
输入: s = "abcabcbb"
输出: 3 
解释：因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**答案：** 使用滑动窗口 + 哈希表的方法。

```go
func lengthOfLongestSubstring(s string) int {
    if len(s) == 0 {
        return 0
    }
    left, right := 0, 0
    maxLen, charMap := 0, make(map[rune]int)
    for right < len(s) {
        if _, ok := charMap[s[right]]; ok {
            left = max(left, charMap[s[right]] + 1)
        }
        charMap[s[right]] = right
        maxLen = max(maxLen, right - left + 1)
        right++
    }
    return maxLen
}
```

**解析：**
- 使用双指针技术，`left` 和 `right` 分别代表滑动窗口的左右边界。
- `charMap` 是一个哈希表，用于存储当前窗口内字符的最后出现位置。
- 当遇到重复字符时，将 `left` 移动到重复字符的下一位，这样可以保证窗口内的字符都不重复。
- 在每次移动 `right` 时，更新 `maxLen`，保证记录下当前无重复字符的最长子串长度。

### 2. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**示例：**
```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**答案：** 使用垂直扫描的方法。

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, ch := range strs[0] {
        for j, s := range strs[1:] {
            if i > j || i >= len(s) || ch != s[j] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

**解析：**
- 首先检查数组是否为空，如果为空直接返回空字符串。
- 从第一个字符串开始，逐个字符与后续的字符串比较。
- 一旦找到不匹配的字符或到达字符串末尾，返回当前公共前缀。

### 3. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**示例：**
```
输入：nums = [1,3,5,6], target = 5
输出：2
```

**答案：** 使用二分查找。

```go
func searchInsert(nums []int, target int) int {
    low, high := 0, len(nums)
    for low < high {
        mid := low + (high-low)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return low
}
```

**解析：**
- 使用二分查找算法在排序数组中找到目标值。
- 如果找到目标值，直接返回索引。
- 如果目标值不存在，返回它应该被插入的位置。

### 4. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：** 使用递归。

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：**
- 递归地比较两个链表的头节点，将较小的节点连接到前一个节点。
- 递归调用，直到所有节点被合并。

### 5. 最长回文子串

**题目：** 给你一个字符串 `s`，返回 `s` 的最长回文子串。

**示例：**
```
输入：s = "babad"
输出："bab" 或 "aba"
```

**答案：** 动态规划。

```go
func longestPalindrome(s string) string {
    n := len(s)
    dp := make([][]bool, n)
    for i := range dp {
        dp[i] = make([]bool, n)
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        dp[i][i] = true
    }
    for j := 2; j <= n; j++ {
        for i := 0; i < n-j+1; i++ {
            end := i + j - 1
            if s[i] == s[end] && (j == 2 || dp[i+1][end-1]) {
                dp[i][end] = true
                if j > maxLen {
                    start = i
                    maxLen = j
                }
            }
        }
    }
    return s[start : start+maxLen]
}
```

**解析：**
- 使用动态规划数组 `dp`，其中 `dp[i][j]` 表示字符串 `s[i...j]` 是否为回文。
- 初始化单个字符为真。
- 通过遍历字符串，更新动态规划数组，找出最长回文子串。

### 6. 三数之和

**题目：** 给你一个整数数组 `nums` ，判断是否存在三个数 `nums[i]`、`nums[j]` 和 `nums[k]` 使得它们两两之和等于 `0` 。请

返回所有满足条件且不重复的三元组。

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**答案：** 使用双指针。

```go
func threeSum(nums []int) [][]int {
    nums = sort.Ints(nums)
    var triples [][]int
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                triples = append(triples, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return triples
}
```

**解析：**
- 首先将数组排序。
- 使用双重循环和双指针方法找到三数之和为0的元素。
- 避免重复的元素。

### 7. 两数相加

**题目：** 给出两个 非空 的链表表示两个非负的整数。其中，它们各自的位数是相同的，也都位于 1000 之内。将这两个数相加，并以相同形式返回一个表示和的链表。

**示例：**
```
输入：l1 = [2,4,3], l1 = [5,6,4]
输出：[7,0,7]
```

**答案：** 使用链表。

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{Val: 0}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        v1 := 0
        if l1 != nil {
            v1 = l1.Val
            l1 = l1.Next
        }
        v2 := 0
        if l2 != nil {
            v2 = l2.Val
            l2 = l2.Next
        }
        sum := v1 + v2 + carry
        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }
    return dummy.Next
}
```

**解析：**
- 创建一个哑节点作为结果链表的头。
- 遍历两个链表和进位，计算当前位和进位，将和的个位数作为新节点添加到结果链表中。

### 8. 两数相除

**题目：** 给定两个整数 `a` 和 `b`，返回它们的一般除法操作的商。

**示例：**
```
输入：a = 15, b = 2
输出：7.5
```

**答案：** 使用长除法。

```go
func myDivide(a int, b int) float64 {
    if b == 0 {
        return 0
    }
    sign := 1
    if (a < 0) != (b < 0) {
        sign = -1
    }
    a, b = abs(a), abs(b)
    result := 0
    for a >= b {
        a -= b
        result++
    }
    return float64(sign) * float64(result)
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

**解析：**
- 计算两个整数的符号，如果符号不同，结果为负。
- 使用长除法不断减去 `b`，直到 `a` 小于 `b`。
- 统计循环次数，即为商。

### 9. 合并区间

**题目：** 给一个区间列表，请你合并所有重叠的区间。

**示例：**
```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
```

**答案：** 使用排序。

```go
type Interval struct {
    Start int
    End   int
}

func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    var ans [][]int
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }
    return ans
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 首先对区间列表按起始时间排序。
- 遍历区间列表，合并重叠的区间。
- 如果当前区间的起始时间大于前一个区间的结束时间，说明不重叠，直接添加到结果列表中。

### 10. 三角形的最大周长

**题目：** 给定一个无序的整数数组 `nums` ，返回其中三元组 `nums[i]`、`nums[j]` 和 `nums[k]` 的最大周长。

**示例：**
```
输入：nums = [2,3,6,10]
输出：8
```

**答案：** 

```go
func maximumPolygonArea(nums []int) float64 {
    sort.Ints(nums)
    n := len(nums)
    if n < 4 {
        return 0
    }
    // 三角形1: 使用前两个数
    area1 := float64(nums[0]) * float64(nums[1]) * math.Sqrt(1 - 0.25) / 4
    // 三角形2: 使用后两个数
    area2 := float64(nums[n-2]) * float64(nums[n-1]) * math.Sqrt(1 - 0.25) / 4
    // 三角形3: 使用中间两个数
    area3 := float64(nums[n-2]-nums[0]) * float64(nums[n-1]-nums[1]) * math.Sqrt(1 - 0.25) / 4
    return max(area1, max(area2, area3))
}

func max(a, b float64) float64 {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 对数组进行排序。
- 计算三个不同三角形可能的面积。
- 返回这三个面积中的最大值。

### 11. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长公共子序列的长度。

**示例：**
```
输入：text1 = "abcde", text2 = "ace"
输出：3
```

**答案：** 使用动态规划。

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 和 `text2` 的前 `i` 个字符和前 `j` 个字符的最长公共子序列长度。
- 通过填充数组，使用动态规划找到最长公共子序列长度。

### 12. 有效的括号

**题目：** 给定一个只包含 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

**示例：**
```
输入：s = "()"
输出：true
```

**答案：** 使用栈。

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{'(': ')', '[': ']', '{': '}'}
    for _, char := range s {
        if _, ok := pairs[char]; ok {
            stack = append(stack, char)
        } else if len(stack) == 0 || pairs[stack[len(stack)-1]] != char {
            return false
        } else {
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

**解析：**
- 使用栈存储左括号。
- 遍历时，如果遇到右括号，检查是否与栈顶元素匹配，如果不匹配或栈为空，返回 `false`。
- 最后检查栈是否为空，如果为空，则字符串有效。

### 13. 最小路径和

**题目：** 给定一个包含非负整数的 `mx` 行 `nx` 列的网格 `grid` ，找出一条从左上角到右下角的最短路径和。

**示例：**
```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
```

**答案：** 使用动态规划。

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：**
- 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示从左上角到 `(i, j)` 的最小路径和。
- 通过填充数组，计算最小路径和。

### 14. 盲数搜索中的单词

**题目：** 给定一个二叉搜索树和一个目标值，在树中找到并返回最低公共祖先节点。

**示例：**
```
输入：root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出：6
```

**答案：** 使用递归。

```go
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func lowestCommonAncestor(root *TreeNode, p *TreeNode, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left == nil {
        return right
    }
    if right == nil {
        return left
    }
    return root
}
```

**解析：**
- 递归地搜索左子树和右子树。
- 如果左右子树都返回 `nil`，则当前节点是公共祖先。
- 如果只有一个子树返回 `nil`，则返回另一个子树的公共祖先。

### 15. 搜索旋转排序数组

**题目：** 给你一个旋转排序的数组 `nums` ，请你判断给定的目标值 `target` 是否存在在数组中。如果存在返回 true，否则返回 false。

**示例：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：true
```

**答案：** 使用二分查找。

```go
func search(nums []int, target int) bool {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := l + (r-l)/2
        if nums[mid] == target {
            return true
        }
        if nums[l] < nums[mid] {
            if target >= nums[l] && target < nums[mid] {
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else {
            if target > nums[r] && target <= nums[l] {
                l = mid + 1
            } else {
                r = mid - 1
            }
        }
    }
    return false
}
```

**解析：**
- 对旋转排序的数组使用二分查找。
- 根据中间元素与边界元素的大小关系，决定搜索的左半部分还是右半部分。

### 16. 两个数组的交集

**题目：** 给定两个数组 `nums1` 和 `nums2` ，返回它们交集的最小长度数组。

**示例：**
```
输入：nums1 = [1,2,3,3], nums2 = [3,2,1]
输出：[3,2,1]
```

**答案：** 使用哈希表。

```go
func intersect(nums1 []int, nums2 []int) []int {
    m, n := len(nums1), len(nums2)
    result := make([]int, 0, min(m, n))
    count1 := make(map[int]int)
    for _, num := range nums1 {
        count1[num]++
    }
    for _, num := range nums2 {
        if count1[num] > 0 {
            result = append(result, num)
            count1[num]--
        }
    }
    return result
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：**
- 创建一个哈希表 `count1` 记录数组 `nums1` 的元素及其出现次数。
- 遍历数组 `nums2`，如果元素在哈希表中存在，则将其添加到结果数组中，并减少哈希表中的计数。

### 17. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**示例：**
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组`[4,-1,2,1]` 的和最大，为`6`。
```

**答案：** 使用动态规划。

```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 初始化 `maxSum` 和 `currentSum` 为数组的第一个元素。
- 遍历数组，每次更新 `currentSum`，如果 `currentSum` 小于 `nums[i]`，则从新开始累加。
- 更新 `maxSum`，记录下最大子序和。

### 18. 二进制求和

**题目：** 给你两个二进制字符串，返回它们的和（用二进制表示）。

**示例：**
```
输入：a = "11", b = "1"
输出："100"
```

**答案：** 使用异或和位运算。

```go
func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    result := []byte{}
    for i >= 0 || j >= 0 || carry > 0 {
        sum := carry
        if i >= 0 {
            sum += int(a[i] - '0')
            i--
        }
        if j >= 0 {
            sum += int(b[j] - '0')
            j--
        }
        result = append(result, byte(sum%2+'0'))
        carry = sum / 2
    }
    if carry > 0 {
        result = append(result, byte(carry+'0'))
    }
    return string(result)
}
```

**解析：**
- 从低位开始，使用异或运算求和，并计算进位。
- 将求和结果添加到结果数组中。
- 如果存在进位，继续计算。

### 19. 最大子矩阵

**题目：** 给定一个二维数组 matrix，找到其最大的子矩阵的面积。

**示例：**
```
输入：
matrix = [
  [1,0,1],
  [0,0,1],
  [1,0,1],
]
输出：4
```

**答案：** 使用前缀和。

```go
func maxMatrix(matrix [][]int) int {
    rows, cols := len(matrix), len(matrix[0])
    maxArea := 0
    for i := 0; i < rows; i++ {
        row := make([]int, cols+1)
        for j := 0; j < cols; j++ {
            row[j+1] = row[j] + matrix[i][j]
        }
        for j := 0; j < cols; j++ {
            left, right := j, j
            for left >= 0 && row[left] == row[j+1] {
                left--
            }
            for right < cols && row[right] == row[j+1] {
                right++
            }
            width := right - left - 1
            height := row[j+1]
            maxArea = max(maxArea, width*height)
        }
    }
    return maxArea
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 使用前缀和计算每一行的高度。
- 遍历每一行，使用双指针找到左右边界，计算最大子矩阵的面积。

### 20. 长单词删除

**题目：** 给你一个字符串 `s` 和一个字符串列表 `words` ，你需要实现一个支持以下函数的数据结构：

```
LongestWordDictionary()：返回 `words` 中最长的字符串。
```

**示例：**
```
输入：
words = ["w", "wo", "wor", "work", "workd"]
调用：
LongestWordDictionary()
```

**答案：** 使用字典树。

```go
type Trie struct {
    children [26]*Trie
    isEnd    bool
    word     string
}

func NewTrie() *Trie {
    return &Trie{}
}

func (t *Trie) Insert(word string) {
    node := t
    for _, char := range word {
        idx := int(char - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &Trie{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
    node.word = word
}

func (t *Trie) SearchLongestWord() string {
    var dfs func(*Trie) string
    dfs = func(node *Trie) string {
        if node.isEnd {
            return node.word
        }
        longest := ""
        for _, child := range node.children {
            if child != nil {
                longest = max(longest, dfs(child))
            }
        }
        return longest
    }
    return dfs(t)
}

func max(a, b string) string {
    if len(a) > len(b) {
        return a
    }
    return b
}
```

**解析：**
- 使用字典树存储单词列表。
- 遍历字典树，查找最长的单词。
- 使用深度优先搜索，记录下每个节点的最长单词。

### 21. 最小覆盖子串

**题目：** 给你一个字符串 `s` 和一个字符列表 `chars` ，请你构造一个覆盖了所有 `chars` 的最小字符串。

**示例：**
```
输入：
s = "abc", chars = ['a', 'b', 'c', 'a', 'b']
输出："aacaa"
```

**答案：** 使用双指针。

```go
func minWindow(s string, chars []byte) string {
    charCount := make(map[byte]int)
    for _, c := range chars {
        charCount[c]++
    }
    missingCount := len(chars)
    left, right := 0, 0
    start, length := -1, -1
    while loop:
        if missingCount == 0 {
            if start == -1 {
                start = left
            }
            length = right - left + 1
            if length > right - left {
                start = left
                length = length
            }
            left++
            missingCount++
        } else {
            right++
            if right >= len(s) {
                break while loop
            }
            char := s[right]
            if charCount[char] > 0 {
                charCount[char]--
                if charCount[char] >= 0 {
                    missingCount--
                }
            }
        }
    }
    return ""
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 使用双指针方法，一个指针指向左边界，一个指针指向右边界。
- 在右边界移动时，检查当前字符是否在字符列表中，如果存在则减少缺失的字符计数。
- 当所有字符都被找到时，移动左边界，直到当前子串不再覆盖所有字符。

### 22. 最长连续序列

**题目：** 给定一个未排序的整数数组，找到最长连续序列的长度。

**示例：**
```
输入：nums = [100, 4, 200, 1, 3, 2]
输出：4
解释：最长连续序列是 [1, 2, 3, 4]，它的长度为 4。
```

**答案：** 使用哈希表。

```go
func longestConsecutive(nums []int) int {
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }
    maxLen := 0
    for num := range numSet {
        if !numSet[num-1] {
            currentNum := num
            currentLen := 1
            for numSet[currentNum+1] {
                currentNum++
                currentLen++
            }
            maxLen = max(maxLen, currentLen)
        }
    }
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 使用哈希表记录所有出现的数字。
- 遍历哈希表，对于每个数字，如果它是连续序列的开始，则计算序列的长度。

### 23. 最小操作次数使数组元素相等

**题目：** 给定一个正整数数组 `nums` ，你需要找出并返回使 `nums` 中所有元素相等的最小操作次数。

**示例：**
```
输入：nums = [1,2,3]
输出：2
解释：仅两次操作可以从 [1,2,3] 得到 [2,2,2]。
第一次操作选择任意两个不同数字 x 和 y，使得 x + y = 3 且 x != y。例如，交换 A[0] 和 A[2]，得到 [2,1,3] 。
第二次操作使得唯一剩下的数字达到目标值 2。
```

**答案：** 使用数学方法。

```go
func minMoves2(nums []int) int {
    sort.Ints(nums)
    target := nums[len(nums)/2]
    count := 0
    for _, num := range nums {
        count += abs(num - target)
    }
    return count
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

**解析：**
- 首先对数组进行排序。
- 选择中间的数字作为目标值。
- 计算数组中每个数字与目标值的差的绝对值之和。

### 24. 合并两个有序链表

**题目：** 给定两个有序链表 `l1` 和 `l2` ，将它们合并为一个新的有序链表并返回。

**示例：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**答案：** 使用递归。

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    }
    l2.Next = mergeTwoLists(l1, l2.Next)
    return l2
}
```

**解析：**
- 递归比较两个链表的头节点，将较小的节点连接到前一个节点。
- 递归调用，直到所有节点被合并。

### 25. 链表中倒数第k个节点

**题目：** 给定一个链表，返回链表中的倒数第 `k` 个节点。

**示例：**
```
输入：head = [1,2,3,4,5], k = 2
输出：2
```

**答案：** 使用快慢指针。

```go
func getKthFromEnd(head *ListNode, k int) *ListNode {
    slow, fast := head, head
    for i := 0; i < k; i++ {
        fast = fast.Next
    }
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}
```

**解析：**
- 快指针先走 `k` 步，然后快慢指针同时前进，当快指针到达链表末尾时，慢指针指向倒数第 `k` 个节点。

### 26. 单调栈

**题目：** 使用单调栈实现一个函数，找到数组中的下一个更大元素。数组中每个元素的下一个更大元素是下一个数组中的第一个比该数大的数。

**示例：**
```
输入：nums = [2,1,5,7,3,0,9]
输出：[7,5,9,7,4,9,-1]
```

**答案：** 使用栈。

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    ans := make([]int, n)
    stack := []int{}
    for i := 2 * n - 1; i >= 0; i-- {
        for len(stack) > 0 && nums[stack[len(stack)-1]] <= nums[i%n] {
            stack = stack[:len(stack)-1]
        }
        ans[i%n] = len(stack)
        stack = append(stack, i%n)
    }
    return ans
}
```

**解析：**
- 将数组扩展一倍，以便处理循环。
- 从后向前遍历数组，使用单调栈找到下一个更大的元素。

### 27. 有效的山脉数组

**题目：** 给定一个整数数组 `arr` ，返回 `arr` 的最大山脉数组。如果不存在山脉数组返回 `0` 。

**示例：**
```
输入：arr = [0,10,5,2,20]
输出：15
解释：最大山脉数组是 [0,10,5,20]，其中 10 是山脉的最高点。
```

**答案：** 使用双指针。

```go
func largestMountain(arr []int) int {
    if len(arr) < 3 {
        return 0
    }
    left, right := 0, len(arr)-1
    for left+1 < len(arr) && arr[left] <= arr[left+1] {
        left++
    }
    for right-1 >= 0 && arr[right] <= arr[right-1] {
        right--
    }
    if left >= right {
        return 0
    }
    maxInLeft, maxInRight := 0, 0
    for i := left + 1; i <= right - 1; i++ {
        maxInLeft = max(maxInLeft, arr[i-1])
        maxInRight = max(maxInRight, arr[i+1])
        if maxInLeft > 0 && maxInRight > 0 {
            return max(maxInLeft, maxInRight) - arr[i] + arr[left]
        }
    }
    return 0
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

**解析：**
- 找到山脉的左右边界。
- 计算山脉的最大高度。

### 28. 有效的括号

**题目：** 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

**示例：**
```
输入：s = "()"
输出：true
```

**答案：** 使用栈。

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{'(': ')', '{': '}', '[': ']'}
    for _, char := range s {
        if _, ok := pairs[char]; ok {
            stack = append(stack, char)
        } else if len(stack) == 0 || pairs[stack[len(stack)-1]] != char {
            return false
        } else {
            stack = stack[:len(stack)-1]
        }
    }
    return len(stack) == 0
}
```

**解析：**
- 遍历字符串，遇到左括号入栈，遇到右括号时，检查是否与栈顶元素匹配。

### 29. 加密和解密字符串

**题目：** 请实现一个加密解密字符串的函数对字符串进行加密解密。

**加密方法：** 
- 采用凯撒密码，将字符串中的每个字母按照 `n` 个位置向前移动。

**解密方法：**
- 同样采用凯撒密码，将字符串中的每个字母按照 `n` 个位置向后移动。

**示例：**
```
输入：加密字符串 "hello" ，移位量 2
输出：加密字符串 "jgnnq"
```

**答案：** 使用循环。

```go
func encrypt_decrypt(s string, n int) string {
    res := ""
    for _, c := range s {
        if c >= 'a' && c <= 'z' {
            res += string((c-'a'+n)%26 + 'a')
        } else if c >= 'A' && c <= 'Z' {
            res += string((c-'A'+n)%26 + 'A')
        } else {
            res += string(c)
        }
    }
    return res
}
```

**解析：**
- 遍历字符串，对每个字符进行凯撒密码加密或解密。
- 如果字符是大写字母，将字母重新映射到小写字母。

### 30. 逆波兰表达式求值

**题目：** 实现一个逆波兰表达式求值器。根据逆波兰表示法，求表达式的值。

**示例：**
```
输入：["2", "1", "+", "3", "*"]
输出：9
解释：((2 + 1) * 3) = 9
```

**答案：** 使用栈。

```go
func evalRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a/b)
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(token string) int {
    sign := 1
    if token[0] == '-' {
        sign = -1
        token = token[1:]
    }
    ans := 0
    for _, v := range token {
        ans = ans*10 + int(v-'0')
    }
    return ans * sign
}
```

**解析：**
- 使用栈实现逆波兰表达式的求值。
- 遍历字符串，根据操作符进行相应的计算。

### 总结

本篇博客整理了滴滴校招面试中的高频算法编程题，涵盖了字符串处理、链表、数组、栈、队列、哈希表、递归等多种算法和数据结构。通过这些题目，可以帮助准备滴滴面试的同学熟悉常见面试题的解题思路和实现方法。在面试中，理解算法的原理和实现细节至关重要，同时也要注意代码的可读性和性能优化。希望这篇博客能够对大家的面试准备有所帮助！

