                 

### 网易2025社招编程面试题精华总结

#### 一、常见基础问题

**1. 什么是尾递归？它有什么优势？**

**答案：** 尾递归是一种递归形式，其中递归调用是函数体中的最后一行操作。它避免了栈空间的无限膨胀，因为每次递归调用时，只需要更新当前调用栈的局部变量，而无需创建新的栈帧。

**解析：** 尾递归的优势在于它可以将递归转换为迭代，从而避免栈溢出，提高程序性能。

**2. 什么是哈希表？如何实现？**

**答案：** 哈希表是一种数据结构，通过计算关键字（key）的哈希值来快速访问表中的数据。实现哈希表通常需要三个步骤：创建哈希表、计算哈希值、处理冲突。

**解析：** 创建哈希表通常使用一个数组作为基础结构。计算哈希值可以使用哈希函数，处理冲突可以使用链地址法、开放地址法等。

#### 二、算法编程题库

**1. 寻找两个正序数组的中位数**

**题目：** 给定两个大小分别为 m 和 n 的正序数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

**答案：** 采用归并排序的思想，将两个数组归并成一个新的有序数组，然后取中位数。

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def merge(nums1, nums2):
            i, j = 0, 0
            merged = []
            while i < len(nums1) and j < len(nums2):
                if nums1[i] <= nums2[j]:
                    merged.append(nums1[i])
                    i += 1
                else:
                    merged.append(nums2[j])
                    j += 1
            merged.extend(nums1[i:])
            merged.extend(nums2[j:])
            return merged

        total = len(nums1) + len(nums2)
        if total % 2 == 1:
            return merge(nums1, nums2)[total // 2]
        else:
            return (merge(nums1, nums2)[total // 2 - 1] + merge(nums1, nums2)[total // 2]) / 2

        ```  
解析：**这种方法的时间复杂度为 O(m+n)，空间复杂度为 O(m+n)。在面试中，如果面试官要求优化空间复杂度，可以考虑使用归并排序的思想，只合并一个中间数组，从而降低空间复杂度。

**2. 最长公共子序列**

**题目：** 给定两个字符串 text1 和 text2，找出两者的最长公共子序列。

**答案：** 使用动态规划求解。

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> str:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

        i, j = m, n
        res = []
        while i > 0 and j > 0:
            if text1[i - 1] == text2[j - 1]:
                res.append(text1[i - 1])
                i -= 1
                j -= 1
            elif dp[i - 1][j] > dp[i][j - 1]:
                i -= 1
            else:
                j -= 1

        return ''.join(res[::-1])

        ```  
**解析：** 这种方法的时间复杂度为 O(m*n)，空间复杂度为 O(m*n)。在面试中，如果面试官要求优化空间复杂度，可以考虑使用滚动数组优化空间复杂度。

#### 三、数据结构与算法应用

**1. 单调栈**

**题目：** 求一个数组中的下一个更大元素。

**答案：** 使用单调栈求解。

```python
class Solution:
    def nextGreaterElement(self, nums: List[int]) -> List[int]:
        stack = []
        res = [-1] * len(nums)

        for i in range(len(nums) - 1, -1, -1):
            while stack and nums[i] >= stack[-1]:
                stack.pop()
            if stack:
                res[i] = stack[-1]
            stack.append(nums[i])

        return res

        ```  
**解析：** 这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)。在面试中，如果面试官要求优化空间复杂度，可以考虑使用原地修改数组的方法。

**2. 单调队列**

**题目：** 求一个数组中的下一个最小元素。

**答案：** 使用单调队列求解。

```python
from collections import deque

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        def reverse(i, j):
            while i < j:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
                j -= 1

        def find(i):
            for j in range(len(nums) - 1, i - 1, -1):
                if nums[j] > nums[i]:
                    reverse(i, len(nums) - 1)
                    reverse(i + 1, j)
                    return
            reverse(0, len(nums) - 1)

        find(len(nums) - 1)
        return nums

        ```  
**解析：** 这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。在面试中，如果面试官要求优化空间复杂度，可以考虑使用原地修改数组的方法。

#### 四、图算法

**1. 拓扑排序**

**题目：** 求一个有向无环图的拓扑排序。

**答案：** 使用 Kahn 算法求解。

```python
from collections import deque

class Solution:
    def拓扑排序(self，edges: List[List[int]], n: int) -> List[int]:
        indeg = [0] * n
        graph = [[] for _ in range(n)]

        for u, v in edges:
            graph[u].append(v)
            indeg[v] += 1

        q = deque()
        for i in range(n):
            if indeg[i] == 0:
                q.append(i)

        res = []
        while q:
            u = q.popleft()
            res.append(u)
            for v in graph[u]:
                indeg[v] -= 1
                if indeg[v] == 0:
                    q.append(v)

        return res

        ```  
**解析：** 这种方法的时间复杂度为 O(n)，空间复杂度为 O(n)。在面试中，如果面试官要求优化空间复杂度，可以考虑使用邻接矩阵表示图。

**2. 最短路径**

**题目：** 求一个加权无环图的最短路径。

**答案：** 使用 Dijkstra 算法求解。

```python
import heapq

class Solution:
    def 短路径(self，edges: List[List[int]], n: int, start: int) -> List[int]:
        def dijkstra(edges, n, start):
            INF = float('inf')
            dist = [INF] * n
            dist[start] = 0
            q = [(0, start)]
            while q:
                cur_dist, u = heapq.heappop(q)
                if cur_dist > dist[u]:
                    continue
                for v, w in edges[u]:
                    if dist[v] > cur_dist + w:
                        dist[v] = cur_dist + w
                        heapq.heappush(q, (dist[v], v))
            return dist

        graph = [[] for _ in range(n)]
        for u, v, w in edges:
            graph[u].append((v, w))

        return dijkstra(graph, n, start)

        ```  
**解析：** 这种方法的时间复杂度为 O(n^2)，空间复杂度为 O(n)。在面试中，如果面试官要求优化时间复杂度，可以考虑使用斐波那契堆优化。

#### 五、动态规划

**1. 最长递增子序列**

**题目：** 求一个数组的最长递增子序列。

**答案：** 使用动态规划求解。

```python
class Solution:
    def lengthOfLIS(self，nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)

        ```  
**解析：** 这种方法的时间复杂度为 O(n^2)，空间复杂度为 O(n)。在面试中，如果面试官要求优化时间复杂度，可以考虑使用二分搜索优化。

**2. 最小路径和**

**题目：** 求一个数组的最小路径和。

**答案：** 使用动态规划求解。

```python
class Solution:
    def minimumTotal(self，triangle: List[List[int]]) -> int:
        dp = triangle[-1]
        for i in range(len(triangle) - 2, -1, -1):
            for j in range(len(triangle[i])):
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
        return dp[0]

        ```  
**解析：** 这种方法的时间复杂度为 O(n^2)，空间复杂度为 O(n)。在面试中，如果面试官要求优化空间复杂度，可以考虑使用滚动数组优化。

#### 六、位运算

**1. 只出现一次的数字**

**题目：** 给定一个非空整数数组，除了某个元素只出现一次以外，其余元素均出现两次。请找出那个只出现一次的元素。

**答案：** 使用异或运算求解。

```python
class Solution:
    def singleNumber(self，nums: List[int]) -> int:
        res = 0
        for num in nums:
            res ^= num
        return res

        ```  
**解析：** 这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。在面试中，如果面试官要求优化时间复杂度，可以考虑使用位运算。

**2. 两个数的和**

**题目：** 给定一个整数数组，找到两个数使得它们的和最接近一个给定数 target 。

**答案：** 使用双指针求解。

```python
class Solution:
    def twoSumClosest(self，nums: List[int], target: int) -> int:
        nums.sort()
        i, j = 0, len(nums) - 1
        res = float('inf')

        while i < j:
            s = nums[i] + nums[j]
            if abs(s - target) < abs(res - target):
                res = s
            if s < target:
                i += 1
            elif s > target:
                j -= 1
            else:
                break

        return res

        ```  
**解析：** 这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。在面试中，如果面试官要求优化时间复杂度，可以考虑使用二分搜索优化。

#### 七、数学与逻辑

**1. 判断质数**

**题目：** 给定一个整数 n ，返回 n 的质因数分解。

**答案：** 使用试除法求解。

```python
class Solution:
    def 约瑟夫环(self，n: int, m: int) -> int:
        def dfs(i, n, m):
            if n == 1:
                return i
            i = (i + m - 1) % n
            n -= 1
            return dfs(i, n, m)

        return dfs(0, n, m)

        ```  
**解析：** 这种方法的时间复杂度为 O(n)，空间复杂度为 O(1)。在面试中，如果面试官要求优化时间复杂度，可以考虑使用位运算。

**2. 求最大公约数**

**题目：** 给定两个整数 a 和 b ，求它们的最大公约数。

**答案：** 使用辗转相除法求解。

```python
class Solution:
    def 最大公约数(self，a: int，b: int) -> int:
        while b:
            a, b = b, a % b
        return a

        ```  
**解析：** 这种方法的时间复杂度为 O(log(min(a, b)))，空间复杂度为 O(1)。在面试中，如果面试官要求优化时间复杂度，可以考虑使用更高效的算法，如欧几里得算法。

#### 八、面试技巧

**1. 如何进行面试准备？**

**答案：**  
1. 熟悉常见的数据结构和算法。  
2. 练习编程题，尤其是动态规划和图算法。  
3. 了解面试官所在公司的业务和技术栈。  
4. 准备一些技术面试题的答案。  
5. 提高英语口语和沟通能力。

**2. 如何在面试中展示自己的优势？**

**答案：**  
1. 展示自己的技术水平，通过代码示例和算法分析来说明问题。  
2. 强调自己在项目中的贡献和成果。  
3. 展示自己的学习能力和团队合作能力。  
4. 提出有深度的问题，展现自己的思考能力。

#### 九、总结

面试中，数据结构和算法是核心。熟悉常见的算法和数据结构，能够帮助你快速解决编程问题。同时，面试技巧和沟通能力也是非常重要的，它们将决定你是否能够得到面试官的认可。

在面试前，做好充分的准备，多练习，多总结，相信你一定能够取得好的成绩。祝你好运！

