                 

### 国内头部一线大厂面试题及算法编程题

#### 1. 阿里巴巴：平衡二叉树的高度

**题目：** 请编写一个函数，计算给定二叉树的高度。

**答案：** 使用递归方法计算树的高度。

```java
public int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = getHeight(root.left);
    int rightHeight = getHeight(root.right);
    return Math.max(leftHeight, rightHeight) + 1;
}
```

**解析：** 该算法遍历树的每个节点，计算左右子树的高度，并取最大值加 1 作为当前节点的高度。

#### 2. 腾讯：二分查找

**题目：** 在一个有序数组中查找一个目标值，并返回其索引。如果没有找到，返回 -1。

**答案：** 使用二分查找算法。

```java
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

**解析：** 二分查找通过不断缩小搜索范围，以对数时间复杂度找到目标值。

#### 3. 百度：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：** 使用动态规划算法。

```java
public String longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return getStringFromDpTable(dp, m, n);
}

private String getStringFromDpTable(int[][] dp, int m, int n) {
    StringBuilder sb = new StringBuilder();
    int i = m;
    int j = n;
    while (i > 0 && j > 0) {
        if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else if (dp[i][j - 1] > dp[i - 1][j]) {
            j--;
        } else {
            sb.append(text1.charAt(i - 1));
            i--;
            j--;
        }
    }
    return sb.reverse().toString();
}
```

**解析：** 动态规划算法通过填表来找出最长公共子序列，最终通过回溯得到结果。

#### 4. 字节跳动：两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：** 使用哈希表。

```python
def twoSum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

**解析：** 该算法通过遍历数组，使用哈希表记录每个数字的索引，以实现对数时间复杂度的查找。

#### 5. 京东：最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 使用字符串比较。

```java
public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) {
        return "";
    }
    String prefix = strs[0];
    for (int i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix) != 0) {
            prefix = prefix.substring(0, prefix.length() - 1);
            if (prefix.isEmpty()) {
                return "";
            }
        }
    }
    return prefix;
}
```

**解析：** 该算法从第一个字符串开始，逐个比较后续字符串，不断缩减公共前缀。

#### 6. 美团：合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：** 使用排序和合并区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for i in range(1, len(intervals)):
        if merged[-1][1] >= intervals[i][0]:
            merged[-1][1] = max(merged[-1][1], intervals[i][1])
        else:
            merged.append(intervals[i])
    return merged
```

**解析：** 该算法首先对区间进行排序，然后遍历合并重叠区间。

#### 7. 拼多多：两数相加

**题目：** 给出两个 非空 的链表分别表示两个非负的整数。对这两个整数求和，并以链表形式返回结果。

**答案：** 使用链表。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummy;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummy.next;
}
```

**解析：** 该算法通过模拟加法运算，逐位相加并进位，构建出结果链表。

#### 8. 快手：最长上升子序列

**题目：** 给定一个无序的整数数组，找到其中最长上升子序列的长度。

**答案：** 使用动态规划。

```python
def lengthOfLIS(nums):
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

**解析：** 该算法通过维护一个动态数组，记录以每个元素为结尾的最长上升子序列长度，最终得到最长上升子序列的长度。

#### 9. 滴滴：二进制转换

**题目：** 将一个十进制数转换为二进制数。

**答案：** 使用递归。

```java
public String toBinary(int num) {
    if (num == 0) {
        return "0";
    }
    return Integer.toBinaryString(num);
}
```

**解析：** 该算法通过递归调用 `Integer.toBinaryString()` 方法，将十进制数转换为二进制字符串。

#### 10. 小红书：最大子序和

**题目：** 给定一个整数数组，找到其中最大子序列和。

**答案：** 使用动态规划。

```python
def maxSubArray(nums):
    if not nums:
        return 0
    max_sum = nums[0]
    curr_sum = nums[0]
    for i in range(1, len(nums)):
        curr_sum = max(nums[i], curr_sum + nums[i])
        max_sum = max(max_sum, curr_sum)
    return max_sum
```

**解析：** 该算法通过维护一个当前最大子序列和 `curr_sum`，并在遍历过程中更新最大子序列和 `max_sum`。

#### 11. 蚂蚁金服：字符串匹配

**题目：** 给定一个字符串 `text` 和一个模式 `pattern`，请实现一个支持通配符 `.` 和 `*` 的通配符匹配。

**答案：** 使用动态规划。

```python
def isMatch(text, pattern):
    dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)]
    dp[0][0] = True
    for j in range(1, len(pattern) + 1):
        if pattern[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    for i in range(1, len(text) + 1):
        for j in range(1, len(pattern) + 1):
            if pattern[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif pattern[j - 1] == '.' or text[i - 1] == pattern[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
    return dp[-1][-1]
```

**解析：** 该算法通过构建一个动态规划表，计算文本与模式之间的匹配情况。

#### 12. 阿里云：排序算法

**题目：** 实现快速排序算法。

**答案：** 使用递归。

```java
public void quickSort(int[] nums, int left, int right) {
    if (left >= right) {
        return;
    }
    int pivot = partition(nums, left, right);
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}

public int partition(int[] nums, int left, int right) {
    int pivot = nums[right];
    int i = left;
    for (int j = left; j < right; j++) {
        if (nums[j] < pivot) {
            swap(nums, i, j);
            i++;
        }
    }
    swap(nums, i, right);
    return i;
}

public void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```

**解析：** 该算法通过递归实现快速排序，每次选择一个基准元素，将小于基准的元素移到基准左边，大于基准的元素移到基准右边。

#### 13. 网易：二叉树遍历

**题目：** 实现二叉树的遍历（前序、中序、后序）。

**答案：** 使用递归。

```java
// 前序遍历
void preorderTraversal(TreeNode root) {
    if (root != null) {
        visit(root);
        preorderTraversal(root.left);
        preorderTraversal(root.right);
    }
}

// 中序遍历
void inorderTraversal(TreeNode root) {
    if (root != null) {
        inorderTraversal(root.left);
        visit(root);
        inorderTraversal(root.right);
    }
}

// 后序遍历
void postorderTraversal(TreeNode root) {
    if (root != null) {
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        visit(root);
    }
}

void visit(TreeNode node) {
    System.out.print(node.val + " ");
}
```

**解析：** 该算法通过递归实现二叉树的前序、中序、后序遍历。

#### 14. 腾讯音乐：LRU 缓存

**题目：** 实现一个 LRU 缓存。

**答案：** 使用哈希表和双向链表。

```java
class LRUCache {
    private int capacity;
    private Map<Integer, Node> cache;
    private Node head;
    private Node tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        Node node = cache.get(key);
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            moveToHead(node);
        } else {
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            if (cache.size() > capacity) {
                Node lastNode = tail.prev;
                removeNode(lastNode);
                cache.remove(lastNode.key);
            }
        }
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addNode(node);
    }

    private void addNode(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}

class Node {
    int key;
    int value;
    Node prev;
    Node next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```

**解析：** 该算法使用哈希表实现快速查找，使用双向链表实现最近最少使用（LRU）策略。

#### 15. 美团外卖：最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**答案：** 使用动态规划。

```python
def longestCommonSubstr(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    max_end = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    max_end = i
            else:
                dp[i][j] = 0
    return s1[max_end - max_len: max_end]
```

**解析：** 该算法通过构建一个动态规划表，计算两个字符串的公共子串长度，最终得到最长公共子串。

#### 16. 字节跳动：链表翻转

**题目：** 实现一个链表翻转函数。

**答案：** 使用递归。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    if not head or not head.next:
        return head
    p = reverseList(head.next)
    head.next.next = head
    head.next = None
    return p
```

**解析：** 该算法通过递归翻转链表，每次翻转当前节点和下一个节点的指针。

#### 17. 京东：计算器

**题目：** 实现一个计算器，支持加、减、乘、除四种运算。

**答案：** 使用栈。

```java
import java.util.Stack;

public class Calculator {
    public int calculate(String s) {
        Stack<Integer> numbers = new Stack<>();
        Stack<Character> operators = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                int num = c - '0';
                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {
                    num = num * 10 + (s.charAt(i + 1) - '0');
                    i++;
                }
                numbers.push(num);
            } else if (c == '(') {
                operators.push(c);
            } else if (c == ')') {
                while (operators.peek() != '(') {
                    numbers.push(applyOperator(operators.pop(), numbers.pop(), numbers.pop()));
                }
                operators.pop();
            } else {
                while (!operators.isEmpty() && hasPrecedence(c, operators.peek())) {
                    numbers.push(applyOperator(operators.pop(), numbers.pop(), numbers.pop()));
                }
                operators.push(c);
            }
        }
        while (!operators.isEmpty()) {
            numbers.push(applyOperator(operators.pop(), numbers.pop(), numbers.pop()));
        }
        return numbers.pop();
    }

    private boolean hasPrecedence(char op1, char op2) {
        if (op2 == '(' || op2 == ')') {
            return false;
        }
        if ((op1 == '*' || op1 == '/') && (op2 == '+' || op2 == '-')) {
            return false;
        }
        return true;
    }

    private int applyOperator(char operator, int b, int a) {
        switch (operator) {
            case '+':
                return a + b;
            case '-':
                return a - b;
            case '*':
                return a * b;
            case '/':
                if (b == 0) {
                    throw new IllegalArgumentException("Division by zero");
                }
                return a / b;
        }
        return 0;
    }
}
```

**解析：** 该算法使用两个栈，一个用于存储数字，一个用于存储运算符，按照运算优先级进行计算。

#### 18. 美团：排序算法

**题目：** 实现快速排序算法。

**答案：** 使用递归。

```java
public void quickSort(int[] arr, int left, int right) {
    if (left >= right) {
        return;
    }
    int pivot = partition(arr, left, right);
    quickSort(arr, left, pivot - 1);
    quickSort(arr, pivot + 1, right);
}

public int partition(int[] arr, int left, int right) {
    int pivot = arr[right];
    int i = left;
    for (int j = left; j < right; j++) {
        if (arr[j] < pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, right);
    return i;
}

public void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

**解析：** 该算法通过递归实现快速排序，每次选择一个基准元素，将小于基准的元素移到基准左边，大于基准的元素移到基准右边。

#### 19. 小红书：两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

**答案：** 使用哈希表。

```python
def twoSum(nums, target):
    hash_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[num] = i
    return []
```

**解析：** 该算法通过遍历数组，使用哈希表记录每个数字的索引，以实现对数时间复杂度的查找。

#### 20. 拼多多：两数相加

**题目：** 给出两个 非空 的链表分别表示两个非负的整数。对这两个整数求和，并以链表形式返回结果。

**答案：** 使用链表。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode p = l1, q = l2, curr = dummy;
    int carry = 0;
    while (p != null || q != null) {
        int x = (p != null) ? p.val : 0;
        int y = (q != null) ? q.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if (p != null) p = p.next;
        if (q != null) q = q.next;
    }
    if (carry > 0) {
        curr.next = new ListNode(carry);
    }
    return dummy.next;
}
```

**解析：** 该算法通过模拟加法运算，逐位相加并进位，构建出结果链表。

#### 21. 快手：最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 使用字符串比较。

```java
public String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) {
        return "";
    }
    String prefix = strs[0];
    for (int i = 1; i < strs.length; i++) {
        while (strs[i].indexOf(prefix) != 0) {
            prefix = prefix.substring(0, prefix.length() - 1);
            if (prefix.isEmpty()) {
                return "";
            }
        }
    }
    return prefix;
}
```

**解析：** 该算法从第一个字符串开始，逐个比较后续字符串，不断缩减公共前缀。

#### 22. 滴滴：合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：** 使用排序和合并区间。

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for i in range(1, len(intervals)):
        if merged[-1][1] >= intervals[i][0]:
            merged[-1][1] = max(merged[-1][1], intervals[i][1])
        else:
            merged.append(intervals[i])
    return merged
```

**解析：** 该算法首先对区间进行排序，然后遍历合并重叠区间。

#### 23. 网易云音乐：最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：** 使用哈希表。

```python
def longestConsecutive(nums):
    if not nums:
        return 0
    nums_set = set(nums)
    max_length = 0
    for num in nums_set:
        if num - 1 not in nums_set:
            current_num = num
            current_length = 1
            while current_num + 1 in nums_set:
                current_num += 1
                current_length += 1
            max_length = max(max_length, current_length)
    return max_length
```

**解析：** 该算法通过哈希表记录数组中的数字，然后遍历每个数字，计算以该数字为起点的最长连续序列长度。

#### 24. 蚂蚁金服：字符串匹配

**题目：** 实现字符串匹配算法，支持通配符 `.` 和 `*`。

**答案：** 使用动态规划。

```python
def isMatch(s, p):
    dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]
    dp[0][0] = True
    for j in range(1, len(p) + 1):
        if p[j - 1] == '*':
            dp[0][j] = dp[0][j - 1]
    for i in range(1, len(s) + 1):
        for j in range(1, len(p) + 1):
            if p[j - 1] == '*':
                dp[i][j] = dp[i][j - 1] or dp[i - 1][j]
            elif p[j - 1] == '.' or s[i - 1] == p[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = False
    return dp[-1][-1]
```

**解析：** 该算法通过构建一个动态规划表，计算两个字符串之间的匹配情况。

#### 25. 字节跳动：LRU 缓存

**题目：** 实现一个 LRU 缓存。

**答案：** 使用哈希表和双向链表。

```java
import java.util.HashMap;
import java.util.Map;

public class LRUCache {
    private int capacity;
    private Map<Integer, Node> cache;
    private Node head;
    private Node tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        Node node = cache.get(key);
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            moveToHead(node);
        } else {
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addNode(newNode);
            if (cache.size() > capacity) {
                Node lastNode = tail.prev;
                removeNode(lastNode);
                cache.remove(lastNode.key);
            }
        }
    }

    private void moveToHead(Node node) {
        removeNode(node);
        addNode(node);
    }

    private void addNode(Node node) {
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
        node.prev = head;
    }

    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}

class Node {
    int key;
    int value;
    Node prev;
    Node next;

    public Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}
```

**解析：** 该算法使用哈希表实现快速查找，使用双向链表实现最近最少使用（LRU）策略。

#### 26. 美团外卖：合并两个有序链表

**题目：** 合并两个有序链表。

**答案：** 使用递归。

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val <= l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

**解析：** 该算法通过递归合并两个有序链表。

#### 27. 网易云音乐：环形链表

**题目：** 给定一个链表，判断是否存在环。

**答案：** 使用快慢指针。

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

**解析：** 该算法使用快慢指针，快指针每次移动两个节点，慢指针每次移动一个节点。如果快指针追上慢指针，则说明链表中存在环。

#### 28. 字节跳动：最大子数组

**题目：** 给定一个整数数组 `nums`，找到一个具有最大和的连续子数组。

**答案：** 使用动态规划。

```python
def maxSubArray(nums):
    if not nums:
        return 0
    max_sum = curr_sum = nums[0]
    for i in range(1, len(nums)):
        curr_sum = max(nums[i], curr_sum + nums[i])
        max_sum = max(max_sum, curr_sum)
    return max_sum
```

**解析：** 该算法使用动态规划维护当前子数组和最大子数组和。

#### 29. 拼多多：合并有序数组

**题目：** 将两个有序数组合并为一个有序数组。

**答案：** 使用双指针。

```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = m - 1;
    int p2 = n - 1;
    int tail = m + n - 1;
    while (p1 >= 0 && p2 >= 0) {
        if (nums1[p1] > nums2[p2]) {
            nums1[tail--] = nums1[p1--];
        } else {
            nums1[tail--] = nums2[p2--];
        }
    }
    while (p2 >= 0) {
        nums1[tail--] = nums2[p2--];
    }
}
```

**解析：** 该算法使用两个指针分别指向两个数组的尾部，比较两个元素的大小，将较大的元素放入合并后的数组尾部。

#### 30. 美团：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：** 使用动态规划。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：** 该算法使用动态规划构建一个二维表，记录两个字符串的公共子序列长度。最后返回表中的最大值。

