                 

### å¥½å¥‡å¿ƒï¼šæ¢ç´¢ä¸–ç•Œçš„é’¥åŒ™

åœ¨æ¢ç´¢æœªçŸ¥ä¸–ç•Œçš„æ—…ç¨‹ä¸­ï¼Œå¥½å¥‡å¿ƒæ˜¯æˆ‘ä»¬å‰è¿›çš„é©±åŠ¨åŠ›ã€‚å®ƒå¦‚åŒé’¥åŒ™ï¼Œæ‰“å¼€äº†é€šå¾€çŸ¥è¯†å’Œæ™ºæ…§çš„å¤§é—¨ã€‚æœ¬æ–‡å°†å›´ç»•è¿™ä¸€ä¸»é¢˜ï¼Œæ¢è®¨åœ¨è®¡ç®—æœºç§‘å­¦å’Œç¼–ç¨‹é¢†åŸŸä¸­ï¼Œå¥½å¥‡å¿ƒå¦‚ä½•å¼•å¯¼æˆ‘ä»¬è§£å†³å¤æ‚é—®é¢˜ï¼Œå‘ç°æ–°çŸ¥è¯†ã€‚æˆ‘ä»¬å°†é€šè¿‡åˆ†æä¸€ç³»åˆ—å…¸å‹é¢è¯•é¢˜å’Œç®—æ³•ç¼–ç¨‹é¢˜ï¼Œå±•ç¤ºå¦‚ä½•åˆ©ç”¨å¥½å¥‡å¿ƒè§£å†³å®é™…é—®é¢˜ï¼Œå¹¶ç»™å‡ºè¯¦å°½çš„ç­”æ¡ˆè§£æå’Œæºä»£ç å®ä¾‹ã€‚

### é¢è¯•é¢˜ä¸ç®—æ³•ç¼–ç¨‹é¢˜åº“

#### 1. å¿«æ’ç®—æ³•ï¼ˆæ’åºé—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** å®ç°å¿«é€Ÿæ’åºç®—æ³•ï¼Œå¹¶åˆ†æå…¶æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ã€‚

**ç­”æ¡ˆï¼š** å¿«é€Ÿæ’åºæ˜¯ä¸€ç§é«˜æ•ˆçš„æ’åºç®—æ³•ï¼Œå…¶åŸºæœ¬æ€æƒ³æ˜¯é€šè¿‡ä¸€è¶Ÿæ’åºå°†å¾…æ’è®°å½•åˆ†éš”æˆç‹¬ç«‹çš„ä¸¤éƒ¨åˆ†ï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†è®°å½•çš„å…³é”®å­—å‡æ¯”å¦ä¸€éƒ¨åˆ†çš„å…³é”®å­—å°ï¼Œç„¶åå†æŒ‰æ­¤æ–¹æ³•å¯¹è¿™ä¸¤éƒ¨åˆ†è®°å½•ç»§ç»­è¿›è¡Œæ’åºï¼Œä»¥è¾¾åˆ°æ•´ä¸ªåºåˆ—æœ‰åºã€‚

**è§£æï¼š** å¿«æ’çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º \(O(n\log n)\)ï¼Œæœ€åæƒ…å†µä¸º \(O(n^2)\)ã€‚ç©ºé—´å¤æ‚åº¦ä¸º \(O(\log n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

func quicksort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quicksort(arr, low, pi-1)
        quicksort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[high] = arr[high], arr[i]
    return i
}

func main() {
    arr := []int{10, 7, 8, 9, 1, 5}
    quicksort(arr, 0, len(arr)-1)
    fmt.Println(arr)
}
```

#### 2. äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼ˆæŸ¥æ‰¾é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** å®ç°äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ï¼Œå¹¶åˆ†æå…¶æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ã€‚

**ç­”æ¡ˆï¼š** äºŒåˆ†æŸ¥æ‰¾ç®—æ³•é€šè¿‡ä¸æ–­å°†æŸ¥æ‰¾åŒºé—´ç¼©å°ä¸€åŠï¼Œä»è€Œå®ç°é«˜æ•ˆæŸ¥æ‰¾ã€‚

**è§£æï¼š** äºŒåˆ†æŸ¥æ‰¾çš„å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º \(O(\log n)\)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º \(O(1)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    target := 6
    result := binarySearch(arr, target)
    if result != -1 {
        fmt.Println("Element found at index:", result)
    } else {
        fmt.Println("Element not found.")
    }
}
```

#### 3. å¸¸è§æ’åºç®—æ³•æ¯”è¾ƒï¼ˆæ’åºé—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** åˆ†æå†’æ³¡æ’åºã€æ’å…¥æ’åºã€é€‰æ‹©æ’åºã€å¿«é€Ÿæ’åºç­‰å¸¸è§æ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦ã€‚

**ç­”æ¡ˆï¼š** ä¸åŒæ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦å¦‚ä¸‹ï¼š

* **å†’æ³¡æ’åºï¼š** å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º \(O(1)\)ã€‚
* **æ’å…¥æ’åºï¼š** å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º \(O(1)\)ã€‚
* **é€‰æ‹©æ’åºï¼š** å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º \(O(1)\)ã€‚
* **å¿«é€Ÿæ’åºï¼š** å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º \(O(n\log n)\)ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œç©ºé—´å¤æ‚åº¦ä¸º \(O(\log n)\)ã€‚

**è§£æï¼š** å¿«é€Ÿæ’åºåœ¨å¹³å‡æƒ…å†µä¸‹è¡¨ç°ä¼˜å¼‚ï¼Œä½†æœ€åæƒ…å†µä¸‹æ€§èƒ½ä¸‹é™ï¼›å†’æ³¡æ’åºã€æ’å…¥æ’åºå’Œé€‰æ‹©æ’åºåœ¨æ‰€æœ‰æƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ç›¸åŒï¼Œä½†åœ¨æ•°æ®å‡ ä¹æœ‰åºæ—¶æ€§èƒ½æ›´å¥½ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// å†’æ³¡æ’åº
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

// æ’å…¥æ’åº
func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j+1] = arr[j]
            j--
        }
        arr[j+1] = key
    }
}

// é€‰æ‹©æ’åº
func selectionSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        minIndex := i
        for j := i + 1; j < n; j++ {
            if arr[j] < arr[minIndex] {
                minIndex = j
            }
        }
        arr[i], arr[minIndex] = arr[minIndex], arr[i]
    }
}

func main() {
    arr := []int{64, 25, 12, 22, 11}
    fmt.Println("Original array:", arr)

    // å†’æ³¡æ’åº
    bubbleSort(arr)
    fmt.Println("Sorted array (Bubble Sort):", arr)

    // æ’å…¥æ’åº
    insertionSort(arr)
    fmt.Println("Sorted array (Insertion Sort):", arr)

    // é€‰æ‹©æ’åº
    selectionSort(arr)
    fmt.Println("Sorted array (Selection Sort):", arr)
}
```

#### 4. é“¾è¡¨é—®é¢˜ï¼ˆæ•°æ®ç»“æ„é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** å®ç°ä¸€ä¸ªå•é“¾è¡¨ï¼Œå¹¶å®Œæˆä»¥ä¸‹åŠŸèƒ½ï¼šæ’å…¥èŠ‚ç‚¹ã€åˆ é™¤èŠ‚ç‚¹ã€æŸ¥æ‰¾èŠ‚ç‚¹ã€‚

**ç­”æ¡ˆï¼š** é“¾è¡¨æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œç”±ä¸€ç³»åˆ—èŠ‚ç‚¹ç»„æˆï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«æ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸã€‚

**è§£æï¼š** å®ç°å•é“¾è¡¨éœ€è¦å®šä¹‰èŠ‚ç‚¹ç»“æ„ä½“å’Œé“¾è¡¨æ“ä½œå‡½æ•°ï¼ŒåŒ…æ‹¬æ’å…¥èŠ‚ç‚¹ã€åˆ é™¤èŠ‚ç‚¹å’ŒæŸ¥æ‰¾èŠ‚ç‚¹ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// å•é“¾è¡¨èŠ‚ç‚¹
type ListNode struct {
    Val  int
    Next *ListNode
}

// åˆ›å»ºå•é“¾è¡¨
func createList(arr []int) *ListNode {
    head := &ListNode{Val: arr[0]}
    curr := head
    for i := 1; i < len(arr); i++ {
        curr.Next = &ListNode{Val: arr[i]}
        curr = curr.Next
    }
    return head
}

// æ’å…¥èŠ‚ç‚¹
func insertNode(head *ListNode, val int) *ListNode {
    newNode := &ListNode{Val: val}
    if head == nil {
        return newNode
    }
    curr := head
    for curr.Next != nil {
        curr = curr.Next
    }
    curr.Next = newNode
    return head
}

// åˆ é™¤èŠ‚ç‚¹
func deleteNode(head *ListNode, val int) *ListNode {
    if head == nil {
        return nil
    }
    if head.Val == val {
        return head.Next
    }
    curr := head
    for curr.Next != nil && curr.Next.Val != val {
        curr = curr.Next
    }
    if curr.Next != nil {
        curr.Next = curr.Next.Next
    }
    return head
}

// æŸ¥æ‰¾èŠ‚ç‚¹
func searchNode(head *ListNode, val int) bool {
    curr := head
    for curr != nil && curr.Val != val {
        curr = curr.Next
    }
    return curr != nil
}

func main() {
    arr := []int{1, 2, 3, 4, 5}
    head := createList(arr)
    fmt.Println("Original list:", listToString(head))

    // æ’å…¥èŠ‚ç‚¹
    head = insertNode(head, 6)
    fmt.Println("After insertion:", listToString(head))

    // åˆ é™¤èŠ‚ç‚¹
    head = deleteNode(head, 3)
    fmt.Println("After deletion:", listToString(head))

    // æŸ¥æ‰¾èŠ‚ç‚¹
    found := searchNode(head, 4)
    if found {
        fmt.Println("Node found.")
    } else {
        fmt.Println("Node not found.")
    }
}

// è¾…åŠ©å‡½æ•°ï¼šå°†é“¾è¡¨è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¡¨ç¤º
func listToString(head *ListNode) string {
    result := ""
    for head != nil {
        result += fmt.Sprint(head.Val) + " -> "
        head = head.Next
    }
    return result + "nil"
}
```

#### 5. å›¾ç®—æ³•é—®é¢˜ï¼ˆæ•°æ®ç»“æ„é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** å®ç°å›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰å’Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ç®—æ³•ã€‚

**ç­”æ¡ˆï¼š** å›¾æ˜¯ä¸€ç§ç”±èŠ‚ç‚¹å’Œè¾¹ç»„æˆçš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥è¡¨ç¤ºå¤æ‚çš„ç½‘ç»œå…³ç³»ã€‚

**è§£æï¼š** å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼Œé€å±‚éå†å›¾ä¸­çš„èŠ‚ç‚¹ï¼›æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹ï¼Œå°½å¯èƒ½æ·±åœ°æœç´¢å›¾çš„åˆ†æ”¯ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// å›¾çš„é‚»æ¥è¡¨è¡¨ç¤º
type Graph struct {
    Vertices map[int][]int
    Edges    map[int][]int
}

// åˆ›å»ºå›¾
func createGraph(vertices []int, edges [][]int) *Graph {
    g := &Graph{
        Vertices: make(map[int][]int),
        Edges:    make(map[int][]int),
    }
    for _, v := range vertices {
        g.Vertices[v] = []int{}
        g.Edges[v] = []int{}
    }
    for _, edge := range edges {
        g.Vertices[edge[0]] = append(g.Vertices[edge[0]], edge[1])
        g.Edges[edge[0]] = append(g.Edges[edge[0]], edge[1])
        g.Vertices[edge[1]] = append(g.Vertices[edge[1]], edge[0])
        g.Edges[edge[1]] = append(g.Edges[edge[1]], edge[0])
    }
    return g
}

// å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰
func bfs(g *Graph, start int) []int {
    visited := make(map[int]bool)
    queue := []int{start}
    result := []int{}
    for len(queue) > 0 {
        v := queue[0]
        queue = queue[1:]
        if !visited[v] {
            visited[v] = true
            result = append(result, v)
            for _, w := range g.Vertices[v] {
                if !visited[w] {
                    queue = append(queue, w)
                }
            }
        }
    }
    return result
}

// æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰
func dfs(g *Graph, start int, visited *map[int]bool) []int {
    result := []int{}
    (*visited)[start] = true
    result = append(result, start)
    for _, v := range g.Vertices[start] {
        if !(*visited)[v] {
            result = append(result, dfs(g, v, visited)...)
        }
    }
    return result
}

func main() {
    vertices := []int{1, 2, 3, 4, 5}
    edges := [][]int{{1, 2}, {1, 3}, {2, 4}, {3, 4}, {4, 5}}
    g := createGraph(vertices, edges)

    // å¹¿åº¦ä¼˜å…ˆæœç´¢
    result := bfs(g, 1)
    fmt.Println("BFS:", result)

    // æ·±åº¦ä¼˜å…ˆæœç´¢
    visited := make(map[int]bool)
    result = dfs(g, 1, &visited)
    fmt.Println("DFS:", result)
}
```

#### 6. åŠ¨æ€è§„åˆ’é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** ä½¿ç”¨åŠ¨æ€è§„åˆ’ç®—æ³•æ±‚è§£æ–æ³¢é‚£å¥‘æ•°åˆ—é—®é¢˜ã€‚

**ç­”æ¡ˆï¼š** åŠ¨æ€è§„åˆ’æ˜¯ä¸€ç§é«˜æ•ˆè§£å†³åºåˆ—é—®é¢˜çš„ç®—æ³•ï¼Œé€šè¿‡å°†å­é—®é¢˜åˆ†è§£ä¸ºæ›´å°çš„å­é—®é¢˜ï¼Œå¹¶å­˜å‚¨å­é—®é¢˜çš„è§£ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚

**è§£æï¼š** æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬ n é¡¹å¯ä»¥é€šè¿‡é€’å½’æˆ–åŠ¨æ€è§„åˆ’æ±‚è§£ã€‚åŠ¨æ€è§„åˆ’æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// é€’å½’æ±‚è§£æ–æ³¢é‚£å¥‘æ•°åˆ—
func fibonacciRecursive(n int) int {
    if n <= 1 {
        return n
    }
    return fibonacciRecursive(n-1) + fibonacciRecursive(n-2)
}

// åŠ¨æ€è§„åˆ’æ±‚è§£æ–æ³¢é‚£å¥‘æ•°åˆ—
func fibonacciDynamic(n int) int {
    if n <= 1 {
        return n
    }
    fib := make([]int, n+1)
    fib[0] = 0
    fib[1] = 1
    for i := 2; i <= n; i++ {
        fib[i] = fib[i-1] + fib[i-2]
    }
    return fib[n]
}

func main() {
    n := 10
    fmt.Println("Fibonacci Recursive:", fibonacciRecursive(n))
    fmt.Println("Fibonacci Dynamic:", fibonacciDynamic(n))
}
```

#### 7. æ ‘çŠ¶æ•°ç»„é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** ä½¿ç”¨æ ‘çŠ¶æ•°ç»„æ±‚è§£åŒºé—´å’Œé—®é¢˜ã€‚

**ç­”æ¡ˆï¼š** æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§é«˜æ•ˆè§£å†³åŒºé—´å’Œé—®é¢˜çš„æ•°æ®ç»“æ„ï¼Œé€šè¿‡å°†åŸå§‹æ•°ç»„è½¬åŒ–ä¸ºæ ‘çŠ¶æ•°ç»„ï¼Œå¯ä»¥å¿«é€Ÿè®¡ç®—ä»»æ„åŒºé—´çš„å’Œã€‚

**è§£æï¼š** æ ‘çŠ¶æ•°ç»„çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(\log n)\)ï¼Œé€‚åˆè§£å†³åŒºé—´å’Œé—®é¢˜ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// æ„å»ºæ ‘çŠ¶æ•°ç»„
func buildTree(arr []int) []int {
    n := len(arr)
    tree := make([]int, n*2)
    for i := 0; i < n; i++ {
        tree[n+i] = arr[i]
    }
    for i := n - 1; i > 0; i-- {
        tree[i] = tree[i<<1] + tree[i<<1+1]
    }
    return tree
}

// æ›´æ–°æ ‘çŠ¶æ•°ç»„
func updateTree(tree []int, i, val int) {
    tree[i] += val
    for i >>= 1 {
        tree[i] = tree[i<<1] + tree[i<<1+1]
    }
}

// æŸ¥è¯¢åŒºé—´å’Œ
func queryTree(tree []int, l, r int) int {
    result := 0
    for l <= r {
        if l&1 == 1 {
            result += tree[l]
            l++
        }
        if r&1 == 0 {
            result += tree[r]
            r--
        }
        l >>= 1
        r >>= 1
    }
    return result
}

func main() {
    arr := []int{1, 2, 3, 4, 5}
    tree := buildTree(arr)
    fmt.Println("Tree:", tree)

    // æ›´æ–°åŒºé—´å’Œ
    updateTree(tree, 2, 3)
    fmt.Println("Updated Tree:", tree)

    // æŸ¥è¯¢åŒºé—´å’Œ
    result := queryTree(tree, 1, 3)
    fmt.Println("Query Result:", result)
}
```

#### 8. å‰ç¼€æ ‘é—®é¢˜ï¼ˆæ•°æ®ç»“æ„é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** å®ç°å‰ç¼€æ ‘ï¼ˆTrieï¼‰å¹¶å®Œæˆä»¥ä¸‹åŠŸèƒ½ï¼šæ’å…¥å•è¯ã€æŸ¥è¯¢å•è¯ã€ç»Ÿè®¡å•è¯æ•°é‡ã€‚

**ç­”æ¡ˆï¼š** å‰ç¼€æ ‘æ˜¯ä¸€ç§é«˜æ•ˆè§£å†³å­—ç¬¦ä¸²åŒ¹é…é—®é¢˜çš„é«˜æ•ˆæ•°æ®ç»“æ„ã€‚

**è§£æï¼š** å‰ç¼€æ ‘çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(\text{å•è¯é•¿åº¦})\)ï¼Œé€‚åˆè§£å†³å•è¯æŸ¥è¯¢å’Œç»Ÿè®¡é—®é¢˜ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// Trieæ ‘èŠ‚ç‚¹
type TrieNode struct {
    Children map[rune]*TrieNode
    IsEnd    bool
    Count    int
}

// åˆ›å»ºå‰ç¼€æ ‘
func NewTrieNode() *TrieNode {
    return &TrieNode{
        Children: make(map[rune]*TrieNode),
        IsEnd:    false,
        Count:    0,
    }
}

// æ’å…¥å•è¯
func (t *TrieNode) Insert(word string, count int) {
    node := t
    for _, char := range word {
        if _, ok := node.Children[char]; !ok {
            node.Children[char] = NewTrieNode()
        }
        node = node.Children[char]
    }
    node.IsEnd = true
    node.Count += count
}

// æŸ¥è¯¢å•è¯
func (t *TrieNode) Search(word string) bool {
    node := t
    for _, char := range word {
        if _, ok := node.Children[char]; !ok {
            return false
        }
        node = node.Children[char]
    }
    return node.IsEnd
}

// ç»Ÿè®¡å•è¯æ•°é‡
func (t *TrieNode) CountWord(word string) int {
    node := t
    for _, char := range word {
        if _, ok := node.Children[char]; !ok {
            return 0
        }
        node = node.Children[char]
    }
    return node.Count
}

func main() {
    trie := NewTrieNode()
    words := []string{"apple", "app", "banana", "bat", "batman"}
    counts := []int{5, 2, 3, 1, 4}

    // æ’å…¥å•è¯
    for i, word := range words {
        trie.Insert(word, counts[i])
    }

    // æŸ¥è¯¢å•è¯
    fmt.Println("Search 'apple':", trie.Search("apple"))
    fmt.Println("Search 'app':", trie.Search("app"))

    // ç»Ÿè®¡å•è¯æ•°é‡
    fmt.Println("Count 'apple':", trie.CountWord("apple"))
    fmt.Println("Count 'banana':", trie.CountWord("banana"))
}
```

#### 9. å¹¶å‘ç¼–ç¨‹é—®é¢˜ï¼ˆå¹¶å‘é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** ä½¿ç”¨ Go è¯­è¨€å®ç°ä¸€ä¸ªå¹¶å‘ä¸‹è½½å™¨ï¼Œä¸‹è½½å¤šä¸ªæ–‡ä»¶å¹¶ä¿å­˜åˆ°æœ¬åœ°ã€‚

**ç­”æ¡ˆï¼š** Go è¯­è¨€æä¾›å¼ºå¤§çš„å¹¶å‘æ”¯æŒï¼Œä½¿ç”¨åç¨‹ï¼ˆgoroutineï¼‰å’Œé€šé“ï¼ˆchannelï¼‰å¯ä»¥è½»æ¾å®ç°å¹¶å‘ä¸‹è½½ã€‚

**è§£æï¼š** å¹¶å‘ä¸‹è½½å™¨é€šè¿‡å¯åŠ¨å¤šä¸ªåç¨‹åŒæ—¶ä¸‹è½½æ–‡ä»¶ï¼Œä½¿ç”¨é€šé“æ”¶é›†ä¸‹è½½ç»“æœã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "path/filepath"
    "time"
)

// ä¸‹è½½æ–‡ä»¶
func download(url, savePath string) {
    resp, err := http.Get(url)
    if err != nil {
        fmt.Println("Error downloading file:", err)
        return
    }
    defer resp.Body.Close()

    out, err := os.Create(savePath)
    if err != nil {
        fmt.Println("Error creating file:", err)
        return
    }
    defer out.Close()

    n, err := io.Copy(out, resp.Body)
    if err != nil {
        fmt.Println("Error copying file:", err)
        return
    }

    fmt.Printf("Downloaded %d bytes to %s\n", n, savePath)
}

// å¹¶å‘ä¸‹è½½å¤šä¸ªæ–‡ä»¶
func downloadConcurrently(urls []string, outputDir string) {
    var wg sync.WaitGroup
    downloadCh := make(chan string, len(urls))

    // å¯åŠ¨ä¸‹è½½åç¨‹
    for _, url := range urls {
        wg.Add(1)
        go func(url string) {
            defer wg.Done()
            savePath := filepath.Join(outputDir, filepath.Base(url))
            download(url, savePath)
            downloadCh <- savePath
        }(url)
    }

    // æ”¶é›†ä¸‹è½½ç»“æœ
    go func() {
        wg.Wait()
        close(downloadCh)
    }()

    // æ‰“å°ä¸‹è½½ç»“æœ
    for path := range downloadCh {
        fmt.Println("Downloaded:", path)
    }
}

func main() {
    urls := []string{
        "https://example.com/file1.txt",
        "https://example.com/file2.txt",
        "https://example.com/file3.txt",
    }
    outputDir := "./downloads"

    // åˆ›å»ºè¾“å‡ºç›®å½•
    if err := os.MkdirAll(outputDir, 0755); err != nil {
        fmt.Println("Error creating output directory:", err)
        return
    }

    // å¯åŠ¨ä¸‹è½½å™¨
    downloadConcurrently(urls, outputDir)
}
```

#### 10. ç½‘ç»œç¼–ç¨‹é—®é¢˜ï¼ˆç½‘ç»œé—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** ä½¿ç”¨ Go è¯­è¨€å®ç°ä¸€ä¸ªç®€å•çš„ HTTP æœåŠ¡å™¨ï¼Œæ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚å¹¶è¿”å› HTTP å“åº”ã€‚

**ç­”æ¡ˆï¼š** Go è¯­è¨€å†…ç½®äº†å¼ºå¤§çš„ç½‘ç»œç¼–ç¨‹åº“ï¼Œé€šè¿‡ `net/http` åŒ…å¯ä»¥è½»æ¾å®ç° HTTP æœåŠ¡å™¨çš„åŠŸèƒ½ã€‚

**è§£æï¼š** HTTP æœåŠ¡å™¨é€šè¿‡ç›‘å¬ç‰¹å®šç«¯å£æ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚ï¼Œå¹¶è¿”å› HTTP å“åº”ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
    "net/http"
)

// å¤„ç† HTTP è¯·æ±‚
func handleRequest(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path)
}

func main() {
    http.HandleFunc("/", handleRequest)

    // ç›‘å¬ç«¯å£
    port := ":8080"
    fmt.Println("Starting server on", port)
    if err := http.ListenAndServe(port, nil); err != nil {
        fmt.Println("Error starting server:", err)
    }
}
```

#### 11. è®¾è®¡æ¨¡å¼é—®é¢˜ï¼ˆè®¾è®¡æ¨¡å¼é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** ä½¿ç”¨è®¾è®¡æ¨¡å¼å®ç°ä¸€ä¸ªç®€å•å·¥å‚æ¨¡å¼ï¼Œåˆ›å»ºä¸åŒç±»å‹çš„å¯¹è±¡ã€‚

**ç­”æ¡ˆï¼š** è®¾è®¡æ¨¡å¼æ˜¯ä¸€ç³»åˆ—è§£å†³å¸¸è§é—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼Œç®€å•å·¥å‚æ¨¡å¼æ˜¯ä¸€ç§åˆ›å»ºå‹æ¨¡å¼ï¼Œç”¨äºåœ¨ä¸ç›´æ¥åˆ›å»ºå¯¹è±¡çš„æƒ…å†µä¸‹åˆ›å»ºå¯¹è±¡ã€‚

**è§£æï¼š** ç®€å•å·¥å‚æ¨¡å¼é€šè¿‡ä¸€ä¸ªå·¥å‚ç±»æ¥åˆ›å»ºå¯¹è±¡ï¼Œå·¥å‚ç±»æ ¹æ®ä¼ å…¥çš„å‚æ•°è¿”å›å…·ä½“çš„å¯¹è±¡å®ä¾‹ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import "fmt"

// äº§å“æ¥å£
type Product interface {
    Use()
}

// å…·ä½“äº§å“A
type ProductA struct {
}

func (p *ProductA) Use() {
    fmt.Println("ä½¿ç”¨äº§å“A")
}

// å…·ä½“äº§å“B
type ProductB struct {
}

func (p *ProductB) Use() {
    fmt.Println("ä½¿ç”¨äº§å“B")
}

// ç®€å•å·¥å‚
type SimpleFactory struct {
}

// åˆ›å»ºäº§å“
func (f *SimpleFactory) CreateProduct(productType string) Product {
    switch productType {
    case "A":
        return &ProductA{}
    case "B":
        return &ProductB{}
    default:
        return nil
    }
}

func main() {
    factory := &SimpleFactory{}

    // åˆ›å»ºäº§å“A
    productA := factory.CreateProduct("A")
    if productA != nil {
        productA.Use()
    }

    // åˆ›å»ºäº§å“B
    productB := factory.CreateProduct("B")
    if productB != nil {
        productB.Use()
    }
}
```

#### 12. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡ã€‚

**ç­”æ¡ˆï¼š** å›æ–‡æ˜¯æŒ‡æ­£è¯»å’Œåè¯»éƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚

**è§£æï¼š** åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡å¯ä»¥é€šè¿‡ä»¥ä¸‹æ­¥éª¤ï¼š

1. å°†å­—ç¬¦ä¸²åè½¬ã€‚
2. æ¯”è¾ƒåè½¬åçš„å­—ç¬¦ä¸²ä¸åŸå­—ç¬¦ä¸²æ˜¯å¦ç›¸åŒã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å›æ–‡
func isPalindrome(s string) bool {
    reversed := reverseString(s)
    return s == reversed
}

// åè½¬å­—ç¬¦ä¸²
func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func main() {
    s := "level"
    if isPalindrome(s) {
        fmt.Println(s, "æ˜¯å›æ–‡")
    } else {
        fmt.Println(s, "ä¸æ˜¯å›æ–‡")
    }
}
```

#### 13. æ•°æ®ç»“æ„é¢è¯•é—®é¢˜ï¼ˆæ•°æ®ç»“æ„é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªæ ˆå’Œé˜Ÿåˆ—çš„æ•°æ®ç»“æ„ï¼Œæ”¯æŒåŸºæœ¬çš„ pushã€popã€enqueue å’Œ dequeue æ“ä½œã€‚

**ç­”æ¡ˆï¼š** æ ˆå’Œé˜Ÿåˆ—æ˜¯å¸¸è§çš„åŸºç¡€æ•°æ®ç»“æ„ï¼Œåˆ†åˆ«ç”¨äºå®ç°åè¿›å…ˆå‡ºï¼ˆLIFOï¼‰å’Œå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰æ“ä½œã€‚

**è§£æï¼š** æ ˆå¯ä»¥ä½¿ç”¨æ•°ç»„æˆ–é“¾è¡¨å®ç°ï¼Œé˜Ÿåˆ—å¯ä»¥ä½¿ç”¨å¾ªç¯æ•°ç»„æˆ–é“¾è¡¨å®ç°ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// æ ˆ
type Stack struct {
    items []interface{}
}

func (s *Stack) Push(item interface{}) {
    s.items = append(s.items, item)
}

func (s *Stack) Pop() interface{} {
    if len(s.items) == 0 {
        return nil
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

// é˜Ÿåˆ—
type Queue struct {
    items []interface{}
}

func (q *Queue) Enqueue(item interface{}) {
    q.items = append(q.items, item)
}

func (q *Queue) Dequeue() interface{} {
    if len(q.items) == 0 {
        return nil
    }
    item := q.items[0]
    q.items = q.items[1:]
    return item
}

func main() {
    stack := &Stack{}
    queue := &Queue{}

    // æ ˆæ“ä½œ
    stack.Push(1)
    stack.Push(2)
    stack.Push(3)
    fmt.Println("æ ˆï¼š", stack.Pop()) // è¾“å‡º 3
    fmt.Println("æ ˆï¼š", stack.Pop()) // è¾“å‡º 2

    // é˜Ÿåˆ—æ“ä½œ
    queue.Enqueue(1)
    queue.Enqueue(2)
    queue.Enqueue(3)
    fmt.Println("é˜Ÿåˆ—ï¼š", queue.Dequeue()) // è¾“å‡º 1
    fmt.Println("é˜Ÿåˆ—ï¼š", queue.Dequeue()) // è¾“å‡º 2
}
```

#### 14. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾åˆ°å­—ç¬¦ä¸²ä¸­çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚

**ç­”æ¡ˆï¼š** æœ€é•¿å…¬å…±å‰ç¼€æ˜¯æŒ‡å¤šä¸ªå­—ç¬¦ä¸²ä¸­æœ€é•¿çš„ç›¸åŒå‰ç¼€ã€‚

**è§£æï¼š** å¯ä»¥ä½¿ç”¨å‚ç›´æ‰«ææ³•æ‰¾åˆ°æœ€é•¿å…¬å…±å‰ç¼€ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// æ‰¾åˆ°æœ€é•¿å…¬å…±å‰ç¼€
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := ""
    for i := 0; i < len(strs[0]); i++ {
        ch := strs[0][i]
        for _, str := range strs {
            if i >= len(str) || str[i] != ch {
                return prefix
            }
        }
        prefix += string(ch)
    }
    return prefix
}

func main() {
    strs := []string{"flower", "flow", "flight"}
    fmt.Println("æœ€é•¿å…¬å…±å‰ç¼€ï¼š", longestCommonPrefix(strs))
}
```

#### 15. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—ä¸¤ä¸ªæ•´æ•°çš„å’Œï¼Œè€Œä¸å¾—ä½¿ç”¨ `+`ã€`-`ã€`*` æˆ– `/` è¿ç®—ç¬¦ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨ä½è¿ç®—å®ç°æ•´æ•°çš„åŠ æ³•ã€‚

**è§£æï¼š** ä½è¿ç®—ä¸­çš„å¼‚æˆ–ï¼ˆ^ï¼‰è¿ç®—å¯ä»¥ç”¨æ¥è®¡ç®—ä¸¤ä¸ªæ•´æ•°çš„å’Œï¼Œè€Œä¸ï¼ˆ&ï¼‰è¿ç®—å’Œå·¦ç§»ï¼ˆ<<ï¼‰è¿ç®—å¯ä»¥ç”¨æ¥è®¡ç®—è¿›ä½ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// è®¡ç®—ä¸¤ä¸ªæ•´æ•°çš„å’Œ
func add(a, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}

func main() {
    fmt.Println("å’Œï¼š", add(3, 5)) // è¾“å‡º 8
}
```

#### 16. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºæ•°ç»„ä¸­é‡å¤å‡ºç°çš„å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨æˆ–æ’åºæ–¹æ³•æ‰¾åˆ°é‡å¤å…ƒç´ ã€‚

**è§£æï¼š** å“ˆå¸Œè¡¨æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ï¼Œæ’åºæ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n\log n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// æ‰¾å‡ºé‡å¤å…ƒç´ 
func findDuplicates(nums []int) []int {
    duplicates := []int{}
    m := make(map[int]int)

    for _, num := range nums {
        if _, ok := m[num]; ok {
            duplicates = append(duplicates, num)
        } else {
            m[num] = 1
        }
    }

    return duplicates
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 5, 6, 7}
    fmt.Println("é‡å¤å…ƒç´ ï¼š", findDuplicates(nums))
}
```

#### 17. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€é•¿é€’å¢å­åºåˆ—ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ–¹æ³•æ‰¾åˆ°æœ€é•¿é€’å¢å­åºåˆ—ã€‚

**è§£æï¼š** åŠ¨æ€è§„åˆ’æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n^2)\)ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// æ‰¾å‡ºæœ€é•¿é€’å¢å­åºåˆ—
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    fmt.Println("æœ€é•¿é€’å¢å­åºåˆ—é•¿åº¦ï¼š", lengthOfLIS(nums))
}
```

#### 18. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å°å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨çº¿æ€§æœç´¢æˆ–äºŒåˆ†æœç´¢æ‰¾åˆ°æœ€å°å…ƒç´ ã€‚

**è§£æï¼š** çº¿æ€§æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ï¼ŒäºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(\log n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// çº¿æ€§æœç´¢
func findMinLinear(nums []int) int {
    min := nums[0]
    for _, num := range nums {
        if num < min {
            min = num
        }
    }
    return min
}

// äºŒåˆ†æœç´¢
func findMinBinary(nums []int) int {
    low, high := 0, len(nums)-1
    for low < high {
        mid := (low + high) / 2
        if nums[mid] > nums[high] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}

func main() {
    nums := []int{3, 1, 2, 4, 5}
    fmt.Println("æœ€å°å…ƒç´ ï¼ˆçº¿æ€§æœç´¢ï¼‰:", findMinLinear(nums))
    fmt.Println("æœ€å°å…ƒç´ ï¼ˆäºŒåˆ†æœç´¢ï¼‰:", findMinBinary(nums))
}
```

#### 19. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­é—´å€¼ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨äºŒåˆ†æœç´¢æ‰¾åˆ°ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­é—´å€¼ã€‚

**è§£æï¼š** äºŒåˆ†æœç´¢çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(\log n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// æ‰¾å‡ºä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ä¸­é—´å€¼
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imin = i + 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imax = i - 1
        } else {
            maxLeft := 0.0
            if i == 0 {
                maxLeft = float64(nums2[j-1])
            } else if j == 0 {
                maxLeft = float64(nums1[i-1])
            } else {
                maxLeft = float
```go
                maxLeft = float64(max(nums1[i-1], nums2[j-1]))
            }
            if (m+n)%2 == 1 {
                return maxLeft
            }
            minRight := 0.0
            if i == m {
                minRight = float64(nums2[j])
            } else if j == n {
                minRight = float64(nums1[i])
            } else {
                minRight = float64(min(nums1[i], nums2[j]))
            }
            return (maxLeft + minRight) / 2.0
        }
    }
    return 0.0
}

func main() {
    nums1 := []int{1, 3}
    nums2 := []int{2}
    fmt.Println("ä¸­é—´å€¼:", findMedianSortedArrays(nums1, nums2))
}
```

#### 20. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºé“¾è¡¨ä¸­çš„ç¯ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆæ³•æ‰¾åˆ°é“¾è¡¨ä¸­çš„ç¯ã€‚

**è§£æï¼š** å¿«æ…¢æŒ‡é’ˆæ³•é€šè¿‡ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæ¯æ¬¡ç§»åŠ¨ä¸€æ­¥ï¼ˆæ…¢æŒ‡é’ˆï¼‰ï¼Œä¸€ä¸ªæ¯æ¬¡ç§»åŠ¨ä¸¤æ­¥ï¼ˆå¿«æŒ‡é’ˆï¼‰ï¼Œå¦‚æœé“¾è¡¨ä¸­å­˜åœ¨ç¯ï¼Œé‚£ä¹ˆå¿«æŒ‡é’ˆæœ€ç»ˆä¼šè¿½ä¸Šæ…¢æŒ‡é’ˆã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// é“¾è¡¨èŠ‚ç‚¹
type ListNode struct {
    Val  int
    Next *ListNode
}

// åˆ›å»ºé“¾è¡¨
func createList(arr []int) *ListNode {
    head := &ListNode{Val: arr[0]}
    curr := head
    for i := 1; i < len(arr); i++ {
        curr.Next = &ListNode{Val: arr[i]}
        curr = curr.Next
    }
    return head
}

// å¿«æ…¢æŒ‡é’ˆæ³•æ‰¾åˆ°é“¾è¡¨ä¸­çš„ç¯
func detectCycle(head *ListNode) *ListNode {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            break
        }
    }
    if fast == nil || fast.Next == nil {
        return nil
    }
    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
    return slow
}

func main() {
    arr := []int{1, 2, 3, 4, 5}
    head := createList(arr)
    // åˆ›å»ºç¯
    head.Next.Next.Next.Next.Next = head.Next
    node := detectCycle(head)
    if node != nil {
        fmt.Println("é“¾è¡¨ä¸­å­˜åœ¨ç¯ï¼Œç¯çš„èµ·ç‚¹ä¸º:", node.Val)
    } else {
        fmt.Println("é“¾è¡¨ä¸­ä¸å­˜åœ¨ç¯")
    }
}
```

#### 21. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—å­—ç¬¦ä¸²çš„æ•°å­—ä¹‹å’Œã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥éå†å­—ç¬¦ä¸²ï¼Œå°†å­—ç¬¦è½¬æ¢ä¸ºæ•°å­—å¹¶ç´¯åŠ ã€‚

**è§£æï¼š** éå†å­—ç¬¦ä¸²æ—¶ï¼Œéœ€è¦åˆ¤æ–­æ¯ä¸ªå­—ç¬¦æ˜¯å¦ä¸ºæ•°å­—å­—ç¬¦ï¼Œå¦‚æœæ˜¯ï¼Œå°†å…¶è½¬æ¢ä¸ºæ•°å­—å¹¶ç´¯åŠ ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// è®¡ç®—å­—ç¬¦ä¸²çš„æ•°å­—ä¹‹å’Œ
func stringToNumber(s string) int {
    sum := 0
    for _, ch := range s {
        if ch >= '0' && ch <= '9' {
            sum = sum*10 + int(ch-'0')
        }
    }
    return sum
}

func main() {
    s := "123"
    fmt.Println("å­—ç¬¦ä¸²çš„æ•°å­—ä¹‹å’Œ:", stringToNumber(s))
}
```

#### 22. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—ä¸€ä¸ªæ•´æ•°æ•°ç»„ä¸­çš„æœ€å¤§å­åºå’Œã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æˆ–å‰ç¼€å’Œæ³•è®¡ç®—æœ€å¤§å­åºå’Œã€‚

**è§£æï¼š** åŠ¨æ€è§„åˆ’æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ï¼Œå‰ç¼€å’Œæ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// è®¡ç®—æœ€å¤§å­åºå’Œï¼ˆåŠ¨æ€è§„åˆ’æ³•ï¼‰
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := maxSum
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}

// è®¡ç®—æœ€å¤§å­åºå’Œï¼ˆå‰ç¼€å’Œæ³•ï¼‰
func maxSubArrayPrefixSum(nums []int) int {
    prefixSum := make([]int, len(nums)+1)
    for i := 1; i <= len(nums); i++ {
        prefixSum[i] = prefixSum[i-1] + nums[i-1]
    }
    maxSum := math.MinInt32
    for i := 1; i <= len(nums); i++ {
        maxSum = max(maxSum, prefixSum[i]-prefixSum[i-1])
    }
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println("æœ€å¤§å­åºå’Œï¼ˆåŠ¨æ€è§„åˆ’æ³•ï¼‰:", maxSubArray(nums))
    fmt.Println("æœ€å¤§å­åºå’Œï¼ˆå‰ç¼€å’Œæ³•ï¼‰:", maxSubArrayPrefixSum(nums))
}
```

#### 23. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—å­—ç¬¦ä¸²çš„å¹‚ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨é€’å½’æˆ–å¾ªç¯å®ç°å­—ç¬¦ä¸²çš„å¹‚è¿ç®—ã€‚

**è§£æï¼š** å­—ç¬¦ä¸²çš„å¹‚è¿ç®—å¯ä»¥é€šè¿‡å°†å­—ç¬¦ä¸²é‡å¤æŒ‡å®šçš„æ¬¡æ•°æ¥å®ç°ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// å­—ç¬¦ä¸²å¹‚è¿ç®—ï¼ˆé€’å½’æ³•ï¼‰
func pow(s string, n int) string {
    if n == 0 {
        return ""
    }
    return s + pow(s, n-1)
}

// å­—ç¬¦ä¸²å¹‚è¿ç®—ï¼ˆå¾ªç¯æ³•ï¼‰
func powLoop(s string, n int) string {
    result := ""
    for i := 0; i < n; i++ {
        result += s
    }
    return result
}

func main() {
    s := "hello"
    n := 3
    fmt.Println("å­—ç¬¦ä¸²çš„å¹‚ï¼ˆé€’å½’æ³•ï¼‰:", pow(s, n))
    fmt.Println("å­—ç¬¦ä¸²çš„å¹‚ï¼ˆå¾ªç¯æ³•ï¼‰:", powLoop(s, n))
}
```

#### 24. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²çš„å…¬å…±å­åºåˆ—ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ³•æ‰¾å‡ºä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±å­åºåˆ—ã€‚

**è§£æï¼š** åŠ¨æ€è§„åˆ’æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(mn)\)ï¼Œå…¶ä¸­ m å’Œ n åˆ†åˆ«æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// åŠ¨æ€è§„åˆ’æ³•æ‰¾å‡ºæœ€é•¿å…¬å…±å­åºåˆ—
func longestCommonSubsequence(s1, s2 string) string {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    index := dp[m][n]
    result := make([]byte, index)
    i, j := m, n
    for index > 0 {
        if s1[i-1] == s2[j-1] {
            result[index-1] = s1[i-1]
            i--
            j--
            index--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return string(result)
}

func main() {
    s1 := "abcde"
    s2 := "ace"
    fmt.Println("æœ€é•¿å…¬å…±å­åºåˆ—:", longestCommonSubsequence(s1, s2))
}
```

#### 25. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºå­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å­ä¸²åŠå…¶å‡ºç°æ¬¡æ•°ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•æ¯ä¸ªå­ä¸²åŠå…¶å‡ºç°æ¬¡æ•°ã€‚

**è§£æï¼š** éå†å­—ç¬¦ä¸²ï¼Œæ¯æ¬¡å–ä¸€ä¸ªé•¿åº¦ä¸º k çš„å­ä¸²ï¼Œå°†å…¶ä½œä¸ºé”®æ’å…¥å“ˆå¸Œè¡¨ï¼Œå¹¶æ›´æ–°å¯¹åº”çš„å‡ºç°æ¬¡æ•°ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å­ä¸²åŠå…¶å‡ºç°æ¬¡æ•°
func findSubstrings(s string, k int) map[string]int {
    result := make(map[string]int)
    n := len(s)
    for i := 0; i <= n-k; i++ {
        sub := s[i:i+k]
        result[sub]++
    }
    return result
}

func main() {
    s := "ababc"
    k := 2
    result := findSubstrings(s, k)
    for sub, count := range result {
        fmt.Printf("å­ä¸² %s å‡ºç°æ¬¡æ•° %d\n", sub, count)
    }
}
```

#### 26. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å¤©æ•°å·®ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨æ—¥æœŸåº“è®¡ç®—ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å¤©æ•°å·®ã€‚

**è§£æï¼š** ä½¿ç”¨æ—¥æœŸåº“ä¸­çš„ `Time` ç±»å‹ï¼Œå¯ä»¥é€šè¿‡ `Sub` æ–¹æ³•è®¡ç®—ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å·®å€¼ï¼Œå¹¶å°†å·®å€¼è½¬æ¢ä¸ºå¤©æ•°ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
    "time"
)

// è®¡ç®—ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å¤©æ•°å·®
func daysBetweenDates(date1, date2 string) int {
    layout := "2006-01-02"
    t1, _ := time.Parse(layout, date1)
    t2, _ := time.Parse(layout, date2)
    diff := t2.Sub(t1)
    return int(diff.Hours() / 24)
}

func main() {
    date1 := "2021-01-01"
    date2 := "2021-12-31"
    fmt.Println("ä¸¤ä¸ªæ—¥æœŸä¹‹é—´çš„å¤©æ•°å·®:", daysBetweenDates(date1, date2))
}
```

#### 27. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å¤§è¿ç»­å­åºåˆ—å’Œã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ³•æˆ–å‰ç¼€å’Œæ³•æ‰¾å‡ºæœ€å¤§è¿ç»­å­åºåˆ—å’Œã€‚

**è§£æï¼š** åŠ¨æ€è§„åˆ’æ³•å’Œå‰ç¼€å’Œæ³•çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º \(O(n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// è®¡ç®—æœ€å¤§è¿ç»­å­åºåˆ—å’Œï¼ˆåŠ¨æ€è§„åˆ’æ³•ï¼‰
func maxSubarraySumDynamic(nums []int) int {
    maxSum := nums[0]
    currentSum := maxSum
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}

// è®¡ç®—æœ€å¤§è¿ç»­å­åºåˆ—å’Œï¼ˆå‰ç¼€å’Œæ³•ï¼‰
func maxSubarraySumPrefixSum(nums []int) int {
    prefixSum := make([]int, len(nums)+1)
    for i := 1; i <= len(nums); i++ {
        prefixSum[i] = prefixSum[i-1] + nums[i-1]
    }
    maxSum := math.MinInt32
    for i := 1; i <= len(nums); i++ {
        maxSum = max(maxSum, prefixSum[i]-prefixSum[i-1])
    }
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    fmt.Println("æœ€å¤§è¿ç»­å­åºåˆ—å’Œï¼ˆåŠ¨æ€è§„åˆ’æ³•ï¼‰:", maxSubarraySumDynamic(nums))
    fmt.Println("æœ€å¤§è¿ç»­å­åºåˆ—å’Œï¼ˆå‰ç¼€å’Œæ³•ï¼‰:", maxSubarraySumPrefixSum(nums))
}
```

#### 28. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—å­—ç¬¦ä¸²çš„ç¼–è¾‘è·ç¦»ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨åŠ¨æ€è§„åˆ’æ³•è®¡ç®—å­—ç¬¦ä¸²çš„ç¼–è¾‘è·ç¦»ã€‚

**è§£æï¼š** åŠ¨æ€è§„åˆ’æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(mn)\)ï¼Œå…¶ä¸­ m å’Œ n åˆ†åˆ«æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// è®¡ç®—å­—ç¬¦ä¸²çš„ç¼–è¾‘è·ç¦»
func editDistance(s1, s2 string) int {
    m, n := len(s1), len(s2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 0; i <= m; i++ {
        for j := 0; j <= n; j++ {
            if i == 0 {
                dp[i][j] = j
            } else if j == 0 {
                dp[i][j] = i
            } else if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
            }
        }
    }
    return dp[m][n]
}

func min(a, b, c int) int {
    return min(a, min(b, c))
}

func main() {
    s1 := "kitten"
    s2 := "sitting"
    fmt.Println("ç¼–è¾‘è·ç¦»:", editDistance(s1, s2))
}
```

#### 29. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè®¡ç®—ä¸€ä¸ªæ•´æ•°çš„é˜¶ä¹˜ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨é€’å½’æˆ–å¾ªç¯è®¡ç®—æ•´æ•°çš„é˜¶ä¹˜ã€‚

**è§£æï¼š** é˜¶ä¹˜çš„è®¡ç®—å¯ä»¥é€šè¿‡é€’å½’æˆ–å¾ªç¯å®ç°ï¼Œé€’å½’çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ï¼Œå¾ªç¯çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸º \(O(n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
)

// è®¡ç®—æ•´æ•°çš„é˜¶ä¹˜ï¼ˆé€’å½’æ³•ï¼‰
func factorialRecursive(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorialRecursive(n-1)
}

// è®¡ç®—æ•´æ•°çš„é˜¶ä¹˜ï¼ˆå¾ªç¯æ³•ï¼‰
func factorialIterative(n int) int {
    result := 1
    for i := 2; i <= n; i++ {
        result *= i
    }
    return result
}

func main() {
    n := 5
    fmt.Println("é€’å½’æ³•é˜¶ä¹˜:", factorialRecursive(n))
    fmt.Println("å¾ªç¯æ³•é˜¶ä¹˜:", factorialIterative(n))
}
```

#### 30. ç®—æ³•é¢è¯•é—®é¢˜ï¼ˆç®—æ³•é—®é¢˜ï¼‰

**é¢˜ç›®ï¼š** è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºæ‰¾å‡ºæ•°ç»„ä¸­çš„ç¬¬ä¸‰å¤§å…ƒç´ ã€‚

**ç­”æ¡ˆï¼š** å¯ä»¥ä½¿ç”¨æ’åºæˆ–é€‰æ‹©æ’åºæ³•æ‰¾å‡ºæ•°ç»„ä¸­çš„ç¬¬ä¸‰å¤§å…ƒç´ ã€‚

**è§£æï¼š** æ’åºæ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n\log n)\)ï¼Œé€‰æ‹©æ’åºæ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º \(O(n)\)ã€‚

**æºä»£ç å®ä¾‹ï¼š**

```go
package main

import (
    "fmt"
    "sort"
)

// æ‰¾å‡ºç¬¬ä¸‰å¤§å…ƒç´ ï¼ˆæ’åºæ³•ï¼‰
func thirdLargestSort(nums []int) int {
    sort.Ints(nums)
    return nums[len(nums)-3]
}

// æ‰¾å‡ºç¬¬ä¸‰å¤§å…ƒç´ ï¼ˆé€‰æ‹©æ’åºæ³•ï¼‰
func thirdLargestSelection(nums []int) int {
    for i := 0; i < len(nums)-2; i++ {
        maxIndex := i
        for j := i + 1; j < len(nums); j++ {
            if nums[j] > nums[maxIndex] {
                maxIndex = j
            }
        }
        nums[i], nums[maxIndex] = nums[maxIndex], nums[i]
    }
    return nums[len(nums)-3]
}

func main() {
    nums := []int{3, 2, 1, 5, 6, 4}
    fmt.Println("ç¬¬ä¸‰å¤§å…ƒç´ ï¼ˆæ’åºæ³•ï¼‰:", thirdLargestSort(nums))
    fmt.Println("ç¬¬ä¸‰å¤§å…ƒç´ ï¼ˆé€‰æ‹©æ’åºæ³•ï¼‰:", thirdLargestSelection(nums))
}
```

### ç»“è¯­

é€šè¿‡ä»¥ä¸Š30é“é¢è¯•é¢˜å’Œç®—æ³•ç¼–ç¨‹é¢˜çš„è§£æï¼Œæˆ‘ä»¬ä¸ä»…äº†è§£äº†å„ç§é—®é¢˜çš„è§£æ³•ï¼Œè¿˜å­¦ä¼šäº†å¦‚ä½•åˆ©ç”¨å¥½å¥‡å¿ƒå»æ¢ç´¢æœªçŸ¥ï¼Œå‘ç°æ–°çŸ¥è¯†ã€‚å¥½å¥‡å¿ƒæ˜¯æ¨åŠ¨æˆ‘ä»¬ä¸æ–­è¿›æ­¥çš„åŠ¨åŠ›ï¼Œè®©æˆ‘ä»¬ä¿æŒå¯¹ä¸–ç•Œçš„æ¢ç´¢ç²¾ç¥ï¼Œä¸æ–­æŒ‘æˆ˜è‡ªå·±ï¼Œè§£å†³å¤æ‚é—®é¢˜ã€‚å¸Œæœ›æœ¬æ–‡å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼Œè®©ä½ åœ¨é¢è¯•ä¸­æ›´åŠ è‡ªä¿¡å’Œä»å®¹ã€‚ç¥ä½ é¢è¯•æˆåŠŸï¼ğŸ’ªğŸ’°ğŸ’¯

