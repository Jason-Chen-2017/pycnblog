
作者：禅与计算机程序设计艺术                    

# 1.简介
         
　　左值（lvalue）与右值（rvalue）是编程语言中的两个重要概念，它们是对表达式的求值的概念上的分界线。左值是指一个对象可以出现在某些情况下被赋值或作为函数实参的位置；而右值则是在其他情况下才能被使用的表达式的值。简单来说，左值就是可以给变量、数据成员、数组元素、临时对象的等进行赋值操作的表达式，右值就是不能赋给变量的表达式。例如，对于下面的语句`int x = 5;`来说，"5"是一个右值，因为它不是可以赋值的表达式，"x"也是一个左值，因为它可以被赋值。
         　　
         　　
         　　
         ```cpp
         int main() {
            int a = b + c; // expression statement
            return 0;
         }
         ```
         　　
         　　
         　　
         `b+c`是一个右值，因为它不能被赋值给任何东西，所以它只能出现在赋值语句的右边。而`a=5`，由于"5"是一个右值，所以它不能直接赋值给变量"a",而需要先将其存储到某个地方（比如内存或者寄存器中），然后再将存储地址赋值给变量"a"。
         
         # 2.基本概念术语说明
         ## 左值（lvalue）
         在C++中，左值表示可以被赋值的表达式。左值包括变量、数据成员、数组元素、函数参数、函数返回值及运算符左侧的运算对象。左值可以用于各种赋值或作为函数实参的位置。语法规则如下:
        
         - 可以作为赋值对象的变量名
         - 可以作为赋值对象的成员访问表达式
         - 可以作为赋值对象的数组下标表达式
         - 函数的形式参数
         - 函数的返回值
         
         例如:
         ```cpp
         int a = 10;          // 变量a是左值
         double d(b);         // 函数调用表达式d是左值
         c[i] = d * e;       // 下标表达式c[i]是左值
         f(g) = h / i;        // 函数参数f(g)是左值
         bool operator<(const MyClass& rhs) const   // 函数的返回值operator<是左值
         {}
         ```
         
         
        ## 右值（rvalue）
        在C++中，右值表示不可以被赋值的表达式，它的主要用途是在运算符表达式的右边，以及在类成员函数体内声明但不初始化的对象的引用或指针。
        
        语法规则如下:
        
        - 函数调用表达式或成员函数的名称
        - 没有括号的标记性表达式
        - 一元运算符后面的表达式
        - sizeof 运算符后的表达式
        - new/delete 运算符后的表达式
        - 括号内的表达式
        - throw 表达式
        - 不带括号的类型转换
        
        例如:
        ```cpp
        ++a;                 // 前缀自增，a是右值
        int y = ++x;         // 后缀自增，y是左值
        void* p = &a;        // 取地址运算符&，p是左值
        if (true)            // 真值常量，true是右值
            cout << "hello";// if语句条件，true是右值
        static_cast<int>(x); // 静态类型转换表达式，x是右值
        MyClass obj;         // 默认构造表达式，obj是左值
        std::move(obj);      // C++11的移动构造表达式，obj是右值
        throw X();           // 抛出异常表达式，X()是右值
        ```
        
        ### “左值引用” 和 “右值引用”
        从上面的定义可以看出，左值和右值都是表达式的求值结果，但是为了能够区分左值和右值，C++引入了一种新的引用类型——左值引用和右值引用。左值引用就是对左值进行引用，右值引用就是对右值进行引用。左值引用是对左值的别名，左值引用本身不占据空间，它仅仅是个标签，用来代表左值。同样，右值引用也是如此。因此，左值引用实际上是对左值进行的绑定，而右值引用则是对右值进行的绑定。

        通过右值引用可以间接地获取函数的参数值，从而实现转移语义。例如，`std::move()`函数接受右值引用参数，通过该参数可以传递右值，进而实现资源转移，避免造成资源浪费。

        ```cpp
        template <typename T>
        void swap(T& lhs, T& rhs) {
            T temp{std::move(lhs)};    // 将左值转移到临时变量
            lhs = std::forward<T>(rhs);// 更新左值为右值
            rhs = std::move(temp);     // 更新右值为左值临时变量
        }

        int main() {
            int a = 10, b = 20;
            swap(a, b);             // 交换a和b的值
            return 0;
        }
        ```
        
        上述代码首先定义了一个通用的交换函数`swap()`,它接受两个模板参数`T`,并要求其中之一为左值引用。函数的实现通过右值引用`rhs`接收第二个参数，并通过`std::move()`将第一个参数转移到临时变量中。然后通过`std::forward()`更新第一个参数为右值。最后通过`std::move()`更新第二个参数为临时变量，实现值交换。
        
        当然，对于一般的情况，一般不会使用右值引用。但是在一些特定的场景下，例如移动语义或完美转发（perfect forwarding）时，才会用到右值引用。
        
        ### “纯右值” 和 “非纯右值”
        根据定义，右值可以被看作是不可被修改的表达式的值。那么，什么时候表达式是纯右值呢？只有当以下三个条件同时满足时，才称表达式是纯右值：
        
        - 它是独立于程序执行环境的constexpr或者static局部变量的初始化表达式。
        - 它是一个数组或者一个类的默认构造函数的结果，即使这个类有虚基类也不例外。
        - 它由右值引用捕获，也就是说，它是一个捕获的右值。
        
        如果一个表达式是纯右值，则它的结果一定是一个临时的纯右值，并且这个临时对象只能被移动到其他变量而不是复制，以保持RAII（Resource Acquisition Is Initialization，资源获得就是初始化）原则。而且，除了数组和类的默认构造函数的结果，还有一些其它构造函数的结果也可以看作是纯右值，例如函数的返回值和单目运算符的操作数等。

        另一方面，如果一个表达式不是纯右值，则它的结果可能是非常量的，也就是说，它可以被赋值或销毁，并且可能会导致运行期错误。例如，下面的表达式就是非纯右值，原因是它不是用括号包围：
        
        ```cpp
        int x = func(y + z);  // y+z是一个右值表达式，func是右值引用
        ```
        
        通常来说，用右值可以简化程序逻辑，而用左值则更加灵活。但是有时也存在着一些需要注意的细节。例如，临时对象的生命周期受限于控制流结构的生命周期，而对于栈上的对象来说，其生命周期也依赖于作用域。因此，最好在必要的时候使用`std::move()`或按值传递右值，以避免引起误解。