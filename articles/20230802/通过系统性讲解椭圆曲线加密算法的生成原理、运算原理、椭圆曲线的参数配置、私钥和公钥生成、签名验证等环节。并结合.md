
作者：禅与计算机程序设计艺术                    

# 1.简介
         
20世纪90年代末，美国贝尔实验室的一名研究人员设计出了一种新的公钥加密算法——椭圆曲线密码体制（Elliptic Curve Cryptography，ECC），该算法能够提供高效安全的公钥加密方案。随后，许多其他科研机构陆续基于此工作进行了扩展和完善，目前国际上共有以下几种椭圆曲线加密算法：
            1. ECDH (Elliptic Curve Diffie-Hellman)：借助椭圆曲线交换算法实现密钥协商的公钥加密算法；
            2. ECDSA (Elliptic Curve Digital Signature Algorithm)：借助椭圆曲线签名算法实现数字签名的公钥加密算法；
            3. ECIES (Elliptic Curve Integrated Encryption Scheme)：借助椭圆曲线加密算法实现信息加密的公钥加密算法；
            4. Schnorr签名算法：借助椭圆曲线签名算法实现签名验证和签名生成的公钥加密算法。
         
         在本篇博文中，我将从椭圆曲线密码体制的基本概念出发，详细阐述其加密原理、运算方法、参数配置、私钥和公钥生成、签名验证等环节。并结合比特币的ECDSA、Schnorr签名算法、EOS的EDDSA签名算法等实际应用场景，更好地阐释这些算法的特性及差异。希望能够帮助读者更加清晰地理解这些算法。
         
         # 2.基本概念
          ## 椭圆曲线密码体制
          椭圆曲线密码体制是一种基于密码学的公钥加密算法，它利用椭圆曲线（Elliptic Curves）来实现加密运算。椭圆曲线是一个重要且经典的数论知识。椭圆曲线由一个中心曲线和两个点组成，它们构成了一个平面，称之为EC。根据定义，椭圆曲线上的每条直线都可以通过切割两条曲线上不同点得到。而在 EC 上任意一点 P 的坐标都可以唯一确定。当选择了一对不同的椭圆曲线时，如果已知其中一方的曲线参数，就可以计算另一方的曲线参数，即可以推导出公钥。因此，在进行加密运算时，只需要公开自己的公钥即可，绝不会泄露私钥。如下图所示，椭圆曲线密码体制由椭圆曲线 E 和一个基于 E 的加密算法组成，如ECC。ECC 是一种公钥加密算法，它的安全性建立在椭圆曲线上。公钥是一对整数（X 和 Y），私钥只有一个整数（d）。消息 M 通过随机选择的某个椭圆曲线上的一点 P 发送给接收者 R ，R 可以通过计算 X^dP 或 Y^dP 来计算出共享密钥 K 。K 可用于加密或解密消息。
         
        <div align=center>
        </div>
        
        ### 椭圆曲线相关术语
        1. 椭圆曲线：在二维平面上，椭圆曲线一般是三次曲线，它的方程有两个变量，都是实数域中的变量。椭圆曲线与我们生活中的物体形状一样，具有自相似的性质。
        2. 椭圆：椭圆曲线一般可以近似地表示为这样一个椭圆，圆周率为π。关于椭圆曲线的一些基本属性，比如：在给定角度θ时，椭圆上的任一点E(x,y)，都可以通过两点P(xp,yp)和Q(xq,yq)来唯一确定，同时还要满足勾股定理。
        3. 加法群、乘法群：椭圆曲线上的元素的加法和乘法仍然遵循一定的规则，这就使得椭圆曲LINESEGMENT曲线上元素的集合又有了自己的加法和乘法结构。将所有可能的椭圆曲线上元素排列组合，得到的集合叫做加法群，记作：$E(\mathbb{F}_p)$；将所有可能的椭圆曲线上元素的两倍排列组合，得到的集合叫做乘法群，记作：$E'(\mathbb{F}_p)$。
        4. 生成元：生成元，也被称为基点或者原点，是在某些椭圆曲线上选择的一个点。生成元至少存在于一条椭圆曲线上，并且可以在多个椭圆曲线之间通用。
        5. 有限域：在计算上，为了确保数值计算的准确性，通常将有限范围内的所有数字取出来，这些数字称为有限域。这里的“数值计算”主要指椭圆曲线运算。有限域的大小一般采用素数，比如：$\mathbb{F}_{2}$、$\mathbb{F}_{7}$、$\mathbb{F}_{11}$ 等。
        6. 子群：对于任何一个椭圆曲线 $E(\mathbb{F}_p)$，都有一个生成子群 $G\subseteq E(\mathbb{F}_p)$。子群 $G$ 是由满足公约数为 1 的椭圆曲线上的元素所组成的集合。$|G|$ 表示子群 $G$ 中元素的个数。子群是 ECC 中非常重要的概念，它决定了 ECC 中的加密和签名过程，使得攻击者难以逆向推导出私钥。
        7. 阶：椭圆曲线上元素个数的度量，记作：$n=\frac{\#E}{\#E'}$。
        
        ### 椭圆曲线参数配置
        1. 配置参数时，首先需要选取符合椭圆曲线定义的参数，包括 a, b, p，其中 p 为奇素数，b≠0。其中，a、b 分别表示椭圆曲线在 x 轴、 y 轴的两个参数，可以由公式：
            
            $$a=y^2\mod p$$ 
            $$b=xy\mod p$$ 
        
        2. 将参数按以下方式输入到椭圆曲线加密库：
            - p、a、b 作为设置曲线的参数；
            - n=p+1，作为群的阶，n 也称椭圆曲线的阶。
            - gx、gy 作为基点的坐标，gx、gy 为椭圆曲线上某个点的 x、y 坐标，如 $gx^2+gy^2=1$ 。
            - 随机选取生成元 g 作为椭圆曲线的生成元。
            
            ```python
            from ecpy import EllipticCurve
            
            curve = EllipticCurve(a, b, modulus)
            G = Point(gx, gy, curve)
            ```
        
        3. 生成子群 $G$ 的过程较复杂，需要采用一些算法才能找出有效的子群。最简单的算法就是枚举法，枚举出所有的元素并测试是否属于 G，但这种方法的时间复杂度太高。因此，现有的椭圆曲线密码体制都是基于离散对数算法求解群元的，这个算法的效率比较高。下面是一个基于离散对数算法的例子：
        
            ```python
            def find_subgroup():
                order = curve.order()
                for i in range(2, order):
                    if pow(i, order // 2, order) == 1:
                        return [Point(x, y, curve) for x, y in zip(*[[pow(_, i, order) % order for _ in (gx, gy)] for j in range(2)])]
            ```
            
            该函数采用递归的方式，先计算 $j$ 个 $[x^i,y^i]$ 对的阶，然后判断 $j$ 是否为奇数，若为奇数则返回；否则继续递归。该算法时间复杂度为 $\mathcal{O}(n^\log_2(n))$。
        
        ### 私钥和公钥生成
        根据私钥 d 和生成元 g 计算出公钥 Q=(Qx,Qy)。
        
             ```python
            secretkey = random.randint(1, order - 1)   # 选择一个随机数作为私钥
            publickey = G * secretkey     # 公钥公式
            print("secret key:", hex(secretkey)[2:])
            print("public key:", ("%s,%s")%(hex(publickey.x)[2:],hex(publickey.y)[2:]))
            ```
            
             此外，根据私钥和群 $E'(\mathbb{F}_p)$ 的阶 n，还可以计算出 $k=    ext{lcm}\left(|E(\mathbb{F}_p)|,\ |E'(\mathbb{F}_p)|\right)$，称为同态常数。同态常数 k 可用于 ECDHE 密钥协商算法。
             
        ### 签名验证
        1. 使用私钥对消息 m 进行签名：
            
           ```python
            r = randrange(1, order - 1)    # 选择一个随机数作为 r
            s = ((message + secretkey*r)*inverse(k, order))[0]    # 签名公式
            signature = ("%s,%s") %(hex(r)[2:], hex(s)[2:])     # 签名输出
            ```

        2. 收到消息 m 时，使用公钥 Q 对签名进行验证：

           ```python
            u1 = inverse((s*k), order)       # u1 计算公式
            u2 = inverse((-message*k), order)    # u2 计算公式
            point = (u1*Gx, u2*Gy)            # 验证点
            if point == (-qx, -qy):           # 判断是否正确
               result = True
            else:
               result = False
            ```

        3. 如果验证成功，说明签名正确。
        ## 比特币使用的椭圆曲线加密算法
        ### ECDSA 
        前文介绍过，ECDSA 是椭圆曲线数字签名算法的一种，它可以用来产生和验证签名。比特币使用的椭圆曲线加密算法是 ECDSA ，它依赖椭圆曲线参数 p、a、b、Gx、Gy、n 和私钥 d 生成签名。
        
        ### ECDSA 参数配置
        1. 从 NIST 国际标准出版局获得 elliptic curves over Fp 曲线参数，例如 secp256k1 曲线参数。secp256k1 曲线参数为：

            ```json
            {
                "name": "secp256k1",
                "type": "shortw",
                "p": "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141",
                "a": "00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000",
                "b": "00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007",
                "gx": "79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798",
                "gy": "483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8",
                "bits": "256",
                "n": "FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141",
                "h": "1"
            }
            ```

            2. 设置曲线参数：
                
              ```python
              prime = int(''.join([line.strip() for line in open('prime.txt')]), 16)    # 读取 prime 文件获取素数
              
              # set curve parameters and generator
              curve = CurveFp(prime, 0, 1, 1)      # 设置曲线
              gen = curve.generator()             # 获取生成元
              baselen = len(str(gen.x()))          # 坐标长度
              bytesize = (baselen + 7) >> 3        # 字节长度
              
              print("curve name:", params['name'])
              print("base length:", baselen)
              print("byte size:", bytesize)
              ```
            
             3. 设置私钥 d：
                
              ```python
              private_key = int('<KEY>', 16)    # 私钥 d
              assert isinstance(private_key, int) and 0 < private_key < params['n']
              ```
            
             4. 设置公钥 Q：
                
              ```python
              public_key = gen * private_key    # 公钥公式
              x, y = map(int, str(public_key).split(','))
              print("public key:")
              print("x:", hex(x)[2:].zfill(bytesize))
              print("y:", hex(y)[2:].zfill(bytesize))
              ```
            
        ### 签名生成
        使用私钥对消息 m 进行签名：
        
             ```python
            message = b'message to sign'   # 消息
            hash_msg = sha256(message)     # 消息哈希化
            z = int.from_bytes(hash_msg, byteorder='big')  # 哈希值转换为整数
            r, s = ecdsa_sign(message, z, private_key, curve)    # 签名生成
            sig = encode_sig(r, s)    # 编码签名
            print("signature:")
            print("r:", hex(r)[2:].zfill(bytesize))
            print("s:", hex(s)[2:].zfill(bytesize))
            ```

        ### 签名验证
        1. 从公钥 Q 中解析出坐标 x 和 y。
            
          ```python
          pub_key = PublicKey(params["p"], (x, y))   # 公钥解析
          ```

        2. 检查签名：

          ```python
          msghash = hashlib.sha256(msg.encode()).digest()
          pkcs1v15_verify(pub_key, sig, msghash)   # 签名验证
          ```

        ### 缺陷分析
        ECDSA 虽然容易理解、实现，但是也存在很多缺陷，尤其是在量子计算机的突破口。以下是几个主要的缺陷：
        
        1. 选取随机数作为 k。一般情况下，不应该选取完全随机的 k，因为会导致私钥泄露。
        2. 勾股定理。在大型公钥加密系统中，勾股定理是一个重要的假设。勾股定理认为，如果椭圆曲线上有两个点 P 和 Q，他们之间一定存在第三个点 R ，而且 R 所在直线的斜率为 $\sqrt{(x_P-x_Q)^2+(y_P-y_Q)^2}$ 。而 ECC 不满足这个假设。
        3. 模仿攻击。椭圆曲线密码体制依赖于椭圆曲线参数的随机选择。也就是说，攻击者知道曲线参数后，可以计算出私钥。这会导致系统的隐私泄露。
        
        ## Schnorr 签名算法
        这是一种基于椭圆曲线的公钥签名算法，比起 ECDSA 更简单、更安全。它可以验证签名的正确性，但无法伪造签名。Schnorr 签名算法利用椭圆曲线上的一次函数来计算签名。Schnorr 签名可以防止重放攻击和部分中间人攻击。
        
        ### 签名生成
        首先，用户选择一个随机数 k，并根据 k 和消息 m 生成一次函数 f(m, k)。然后，用户利用私钥对 f(m, k) 进行椭圆曲线运算，得到点 R=(Rx,Ry)。接着，用户利用点 R 再次对消息 m 进行哈希运算，得到哈希摘要 h。最后，用户对点 R 和 h 进行签名：
        
             ```python
            # 用户选择一个随机数 k
            k = secrets.randbits(curve.baselen())   # k 为 256bit 随机数
            
            # 根据 k 和消息 m 生成一次函数 f(m, k)
            f = lambda _: multiply(_[1], _[0]) - _.count(INF) * INF * _[-1]
            fp = lambda _: add(*_) / scalar_mult(_)
            infty = lambda _: None
            FpInf = lambda _: tuple([infty(_) for __ in range(_.curve().degree()+1)])
            fx, fy = curve.lift_x(k)
            gm = (fx**3 + 3*fp(fy)**2 + fp(fx)**3 - fp(-fy)**2 - 3*fp(-fx)**2 - fp(-fx)**3,
                  3*fp(fx)*fp(fy) - fp(fx)**2 - fp(fy)**3 - 3*fp(-fx)*fp(-fy) - fp(-fx)**2 - fp(-fy)**3,
                  fp(fx)**2 + fp(fy)**2 - fp(-fx)**2 - fp(-fy)**2,
                  pyecc_curve._PointAffine__zero)
            rhs = FpInf(curve)
            for pt, coef in zip([gm]*2, [1,-1]):
                rhs = add(*(scalar_mult_(coef, pt_, _) for _, pt_ in enumerate(rhs)))
            fkx = rhs[0][0] % curve.field().p()
            
            # 利用私钥对一次函数 f(m, k) 进行椭圆曲线运算
            Rx = add(f(m, k), multiply(gk, r))
            
            # 用点 R 再次对消息 m 进行哈希运算
            h = sha256(str(m).encode()).digest()
            
            # 用户对点 R 和 h 进行签名
            S = -(rx/fy)%curve.field().p()*inverse(ky, curve.field().p())
            ```
            
         ### 签名验证
        1. 用户检查签名参数 r，s 是否有效：
            
          ```python
          try:
              w = inverse(s, curve.field().p())
              u1 = rx*w % curve.field().p()
              u2 = ry*(pk/(rx**2+ry**2)) % curve.field().p()
              xy = ecadd(ecmul(gen, u1, curve), ecmul(Point(rx, ry, curve), u2, curve), curve)
          except ZeroDivisionError:
              raise InvalidSignatureError('Invalid recovery id.')
          
          if not all((abs(coord) <= curve.p()//2 or coord == -coord)
                      for coord in (xy.x(), xy.y())):
              raise InvalidSignatureError('Signature is not on the curve.')
          ```

        2. 用户检查哈希摘要 h 是否与消息 m 匹配：
            
          ```python
          h1 = SHA256.new(message)
          if h!= h1.digest():
              raise InvalidSignatureError('Hash of message does not match signature.')
          ```