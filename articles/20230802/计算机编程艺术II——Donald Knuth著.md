
作者：禅与计算机程序设计艺术                    

# 1.简介
         
Knuth是一个美国计算机科学家、数学家、逻辑学家和哲学家。他创造了一种重要的算法，即著名的“递归函数”“分治法”。

在许多高校计算机系中，“Knuth算法”是学生必修课。这本书在国际知名大学出版，并被用作公开教材。Knuth最主要的贡献之一就是将分治算法和递归方法应用于求解复杂的组合优化问题。

# 2.基础知识
## 分治法(Divide-and-Conquer)
分治法，也称为“二分法”，指的是把一个大问题分成两个或更多子问题，再把子问题分成更小的子问题，直到最后子问题足够简单，可以直接求解，得到原问题的解。其基本思路是通过递归地解下去，将复杂的问题变得简单化，最终得到问题的解。分治法就是这样运用的，它通常可以划分成多个规模较小的子问题，然后通过递归的方法求解每个子问题，最后再合并得到原问题的解。

例如求数组的最大值，可以通过分治法如下图所示的方法：

1. 把待排序的数组分成两个子数组；
2. 对两个子数组分别采用相同的方式进行递归调用，求解两个子数组的最大值；
3. 比较两个子数组的最大值，选取较大的作为当前数组的最大值；
4. 不断重复这个过程，直到整个数组都得到最大值。


上述算法是分治法的典型例子，其中主问题就是要对一个大的数组求最大值，而两个子问题则是要对两半的数组求最大值，最终合并得到整个数组的最大值。从这个角度看，递归和分治的思想很容易理解。

## 递归函数
递归函数，又称为“自顶向下的递归”，是一种基于栈的数据结构，其特点是在计算某个函数的过程中，会创建新的栈帧，用于存储该函数执行时各个局部变量的值。当递归调用发生时，当前函数的栈帧将会压入堆栈，而新函数的栈帧将被压入堆栈，当函数返回时，相应的栈帧将被弹出，并由调用者继续执行。一般来说，递归函数的计算时间随着问题规模的增长呈指数级增长。

为了保证程序的运行效率，需要注意以下几点：

1. 使用尾递归优化。尾递归是指尾调用（tail call）方式的递归函数。这种形式的递归不会导致栈空间的开销，因此编译器可以优化为循环，提升运行速度。Python中的函数默认就是尾递归优化形式的。
2. 函数的参数数量及类型，参数数量越少，函数的调用开销就越低，内存占用就越少。
3. 用循环替换递归，循环版本的效率要高于递归版本。

# 3.基本概念术语说明
## 求数组的最大值
对于数组A[n]，假设已知A[i]<A[j] (1<=i<j<=n)，若存在一个k使得A[i]<A[k], A[k]>A[j],则A[i]肯定不是最大值，否则A[j]就是最大值。即A[k]可认为是A[j]左边分割线，中间的A[k]区域可认为是中间区域，右边分割线就是A[j+1]处。

利用分治法求数组A[n]的最大值，首先可以分割出A[j]左边的分割线L,A[j]右边的分割线R。设L[m]表示前m个数的最大值，则有如下递推式：

```
if m=0 then L[0]=A[0]; else L[m]=max{A[i]} where i<=m and A[i-1]<A[m]
```

同样，R[m]表示后m-1个数的最大值，也有如下递推式：

```
if m=n then R[m]=A[m]; else R[m]=max{A[i]} where j>=m and A[j+1]>A[m]
```

于是可以建立递归树：

```
       j                        n
    /      \                
   L     [x|y]               
      /   |    \           
     /    |     z            
        x  y       
             |      
            R    
          /  
         /  
        m        
```

其中左子树的根节点是L，右子树的根节点是R，中间有一个值为y或者z的虚节点。至此，可以写出分治算法：

```
maxArrayValue(A,left,right):
    if left==right: return A[left]
    mid=(left+right)/2;
    L[mid]=maxArrayValue(A,left,mid);
    R[mid]=maxArrayValue(A,mid+1,right);
    result=max(L[mid],R[mid])
    for k from left to right do:
        if A[k]>result: result=A[k]
    return result
```

算法根据数组大小确定递归树的高度，即log(n),由于递归调用次数不超过log(n)，所以时间复杂度为O(n*log(n))，也称为线性对数时间复杂度。