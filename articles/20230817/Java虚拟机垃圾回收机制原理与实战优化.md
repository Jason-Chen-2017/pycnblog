
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 1.1 Java虚拟机(JVM)
Java Virtual Machine（JVM）是Java平台最核心的组成部分之一。它负责字节码到底层系统指令集(CPU)的转换工作，并提供一个运行环境给上层的Java应用程序调用。JVM屏蔽了底层硬件系统的差异性，使得Java语言编写的代码可以直接在各种操作系统、体系结构的机器上执行而无需重新编译。
## 1.2 JVM的作用
JVM运行在操作系统之上，它利用自动内存管理和即时编译器对字节码进行优化，将字节码转变为系统级可执行代码。JVM通过垃圾回收(GC)来回收堆中不再被使用的对象，从而释放空间，解决内存碎片的问题。JVM还具有其他重要功能，例如反射(Reflection)，类加载器(ClassLoader)，监控(Monitor)，线程通信(Thread Communication)等。这些功能都依赖于JVM提供的接口与方法。
## 1.3 JVM内存区域
JVM把内存分为五个区域，分别是方法区，堆区，栈区，程序计数器，和元数据区。其中方法区用来存放类信息、常量、静态变量、即时编译器编译后的代码等数据；堆区用于存放对象的实例及其相关数据，大小可动态调整，一般比方法区稍大；栈区用于存储局部变量表、操作数栈、动态链接、返回地址等信息；程序计数器主要用于记录正在执行的字节码指令地址；元数据区用于存放类的描述符、字段、方法等数据。
# 2.概念术语说明
## 2.1 对象引用
当创建一个对象时，JVM会在堆区创建一个新的对象实例，并把这个对象的引用保存到栈区的一个变量里。引用指向的是对象在堆区中的起始位置，也就是说如果堆中有多个同样的对象，他们对应的引用是一样的。换句话说，对象在JVM中的生命周期由它的引用决定。
## 2.2 GC(Garbage Collection)
JVM中提供的垃圾收集器用于释放那些不再需要使用的堆区内存，实现自动内存管理。JVM提供了两种垃圾回收方式：一种是手动回收，也就是应用开发人员手动触发GC操作，另一种是自动回收，系统根据某些条件自动触发GC操作，比如堆内存分配过多或没有释放等。
## 2.3 串行收集器(Serial Collector)
串行收集器是一个单线程收集器，采用标记-复制算法进行垃圾回收。它只使用一条线性扫描过程来完成垃圾回收，并且只有当用户线程都是暂停状态的时候才能使用，因此很适合较小规模的虚拟机进程。
## 2.4 并行收集器(Parallel Collector)
并行收集器是以倍增收集方式实现的收集器，它类似于串行收集器，但是开启多个GC线程并行工作。为了缩短STW(stop-the-world)的时间，它采用多任务处理方式，把垃圾回收的工作分割到不同的线程上，这样可以增加并行度，提高效率。并行收集器也适合于单核CPU的计算机上，因为它减少了线程切换的开销，因此适合服务器端环境。
## 2.5 并发标记清除算法(Concurrent Mark Sweep Algorithm)
并发标记清除算法是CMS的基础算法。CMS是一个并发垃圾回收器，主要关注点是减少Full GC的发生。它采用标记-清除算法，同时在用户线程和GC线程之间进行切换。初始标记阶段仅仅只是标记一下gc roots能直接关联到的对象。此后，并发标记阶段就是遍历所有的对象图中与gc roots直接关联的对象，速度快，但是仍然需要暂停用户线程。再然后，重置所有未标记的对象，最后，并发清除阶段则是清除已经不需要的对象，同时做好最后的资源回收工作，这里不会暂停用户线程。CMS由于可以与用户线程并发执行，因此适合应用服务器或者基于浏览器的客户端场景下。
## 2.6 CMS收集器(Concurrent Mark Sweep Collector)
CMS是一个面向服务端应用的垃圾回收器。它是在JDK 1.5时期发明的，是一种基于标记-清除算法的垃圾回收器。相对于Serial收集器，CMS收集器可以获得更好的性能，原因如下：首先，CMS收集器采用的是并发的标记-清除算法，不会造成用户线程的停顿，因此总体上来说比Serial收集器的吞吐量更高；其次，由于并发收集，CMS收集器可以在不牺牲吞吐量的前提下获得更好的用户响应时间，用户可以交互的同时也不会感觉到明显的延迟。由于其低延迟的特性，因此CMS收集器正在逐渐成为Java SE 8中推荐的默认垃圾回收器。