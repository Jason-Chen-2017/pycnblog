
作者：禅与计算机程序设计艺术                    

# 1.简介
  

排序算法(Sort algorithm)是对一组数据进行排列的方法。不同的数据结构、不同的问题都可以应用到不同的排序算法中。本文主要讨论一些常见的排序算法，并且介绍它们的时间复杂度。排序算法在很多领域有着广泛的应用，如数据库索引的构建、文件管理系统的文件排序等，但也有许多其他的应用场景，比如：图像处理中的基于像素点的颜色排序、视频游戏中的角色顺序排布等。

# 2.排序算法概述
## 2.1 分类
一般分为以下几类:

1. 比较排序算法（Comparison Sorting Algorithms）- 对待排序的序列元素比较后，依照大小关系重新排列。例如：插入排序、选择排序、冒泡排序、归并排序、快速排序。

2. 非比较排序算法（Non-comparison Sorting Algorithms）- 不依赖于元素之间的比较，仅根据元素的值确定其最终位置。例如：计数排序、基数排序、桶排序、堆排序。

3. 外部排序（External Sorting）- 通过外存辅助完成排序。由于需要把大量数据读入内存进行排序，因此速度慢于内置排序算法。例如：外部合并排序（Disk Merge sort）。

比较排序算法的优点是最直观易懂，实现简单，易于理解；缺点是占用内存资源过多，而且时间复杂度高。所以，如果数据的规模不能轻易放入内存时，比较排序算法则往往效率更高。而非比较排序算法则可以降低内存占用量，但实现起来更加困难。

而桶排序、计数排序、基数排序就是属于非比较排序算法的典型代表。桶排序是将要排序的数据划分成不同的区间，然后对每个区间分别进行排序，最后合并这些区间。计数排序是一种线性时间复杂度的排序算法，它根据输入的数据值，将数据映射到输出的整形数组中。基数排序是按照低位到高位的方式进行排序。

## 2.2 时间复杂度
排序算法的时间复杂度是指对给定输入数据长度n所需时间的度量。通常情况下，排序算法的时间复杂度都比较低，达到O(nlogn)级别。但是，还是存在一些比较特殊的情况，比如，如果排序算法每一步都能消除n/k的数据（其中k是一个常数），那么这个算法的时间复杂度就会变成O(kn)。

### 最坏情况时间复杂度
对于任意一个排序算法来说，它的最坏情况时间复杂度都比平均情况复杂度小。因为当输入数据本身已经有序的时候，最坏情况下需要经过n-1次比较操作才能完成排序。举个例子，假设输入数组[7, 6, 5,..., 1]，算法的运行时间取决于输入数组中最大的那个数，也就是7。当数组是降序排列时，此时数组被遍历一次，最坏情况下每次比较操作只需执行n-1次，所以算法的最坏时间复杂度为Ω(n)，等价于O(nlogn)。

为了防止这种最坏情况发生，有些排序算法采用了随机化技术，通过引入随机化因子，使得算法的期望运行时间与输入无关。这样，即便出现最坏情况，期望的运行时间仍然非常接近实际的时间复杂度。

### 稳定性
排序算法的稳定性表明相同的值是否保持其原有的相对顺序。关于排序算法的稳定性，这里有一个重要的概念——反向有序。假设有两个相等的值a和b，在原序列中a出现在b之前，排序之后，a可能仍然在b之前，这就叫做排序算法的不稳定性。有些排序算法如插入排序、选择排序、冒泡排序，虽然看上去好像是稳定的，但是在对重复元素的排序中，可能会造成问题。所以，排序算法的设计者会给出一个准则，来判断某个排序算法是否是稳定的。

### 空间复杂度
排序算法的空间复杂度往往与排序过程中的暂存数据量有关。稳定排序算法只需要额外的常数空间，而不稳定排序算法则还需要记录元素值的交换次数。