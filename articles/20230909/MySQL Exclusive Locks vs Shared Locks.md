
作者：禅与计算机程序设计艺术                    

# 1.简介
  

高并发场景下，多用户对同一个资源同时访问可能导致数据不一致的问题。为了解决这个问题，数据库通常采用两种锁机制：共享锁（shared lock）和排它锁（exclusive lock）。当多个用户或进程需要对同一资源进行读、写操作时，数据库会给予其一种锁类型。共享锁允许多个事务同时读取相同的数据，但不允许写入；而排它锁则相反，一次只能有一个事务获得排他锁，并且在释放之前，其他所有事务都不能访问资源。两种锁类型在不同的应用场景中具有不同的作用，在本文中，我们将讨论这两种锁类型的作用以及它们之间的区别。

# 2.背景介绍
## 数据不一致问题
在高并发场景下，如互联网、电商等场景，有些数据被频繁地修改，如果没有正确处理这种“写-读”冲突，就可能会造成数据不一致的问题。例如，两个用户同时对同一商品添加购物车、提交订单等操作，那么就会导致订单中的商品数量、库存数量、销售量等信息出现不一致的情况。

## 共享锁vs排它锁
为了解决数据不一致问题，数据库通常采用两种锁机制：共享锁（shared lock）和排它锁（exclusive lock）。共享锁和排它锁的区别和作用如下图所示：
### 共享锁（Shared Lock）
共享锁又称为读锁或共享锁，允许多个事务同时读取相同的数据，但不允许写入。若事务T对数据对象A加上了共享锁，则其他事务只能再对该对象加共享锁，不能加排它锁。只有当所有的共享锁释放后，事务T才可以释放对数据对象的占用，使之得以被其他事务继续加锁。

示例1：假设有两个事务（T1和T2）分别读取表A中的数据行，此时如果某个数据行被加上了共享锁，那么其他事务只能再对该数据行加共享锁，不能加排它锁。也就是说，如果某一行已经加锁，其他事务只能等待该事务释放共享锁之后才能获取该行的共享锁。

示例2：事务T1读取数据表A中的数据行，并在读完数据后，事务T1又将数据行B的共享锁释放，然后事务T2开始对数据表A中的某数据行加共享锁。由于事务T2已持有数据行B的共享锁，因此事务T2必须等待事务T1释放该共享锁后才能成功加共享锁。即使发生了死锁，也可以通过超时的方式来避免。

### 排它锁（Exclusive Lock）
排它锁又称为写锁或独占锁，一次只能有一个事务获得排他锁，并且在释放之前，其他所有事务都不能访问资源。若事务T对数据对象A加上了排它锁，则其他事务不能再对该对象加任何锁，直到T释放了锁。排它锁用于数据的独占性保护，保证数据完整性。

示例3：事务T1读取数据表A中的数据行，事务T2要对数据表A中的某数据行进行更新操作，由于事务T1已经对数据表A中的某数据行加了共享锁，因此事务T2不能对该数据行加任何锁，直到事务T1释放该共享锁后，事务T2才可对该数据行加排它锁。即使发生了死锁，也可以通过超时的方式来避免。

## 锁粒度
在MySQL中，InnoDB支持三种锁模式：共享锁（S锁），排它锁（X锁）和意向锁（IS锁）。

* 意向锁（Intention Locks）：InnoDB存储引擎引入意向锁的目的是为了支持多粒度锁定，它是表级锁，用于判断是否存在快速路径，如果不存在则使用元组级别的锁定。意向锁的引入能够降低锁的争用，提升系统并发性能。

* 共享锁（S锁）：S锁可以同时由多个事务获得，但是只能读取数据，不能修改数据，其它事务不能对其进行加任何锁。

* 排它锁（X锁）：X锁也叫排他锁，只能由一个事务获得，同时也阻止其它事务对数据对象进行读、写操作。其他事务如果需要对其数据进行读取或修改，只能等待该事务释放锁。