
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 1.1.什么是垃圾回收机制？
在计算机编程中，垃圾回收（英语：Garbage Collection）是指自动释放内存以供后续程序使用或者归还系统资源的方法。它主要用来解决堆栈上分配的内存空间不断增长的问题，并在适当的时候将其释放给操作系统。目前，许多主流编程语言都提供垃圾回收机制。例如：C/C++、Java、.Net、JavaScript等。当一个对象的引用计数变为0时，便会被判定为垃圾对象，可以进行垃圾回收处理。

## 1.2.为什么要用垃圾回收机制？
由于开发人员编写的代码存在着大量不必要的内存泄漏、内存溢出等问题，因此需要一种机制能够及时清除这些无用的对象，以避免造成系统运行效率下降或崩溃等问题。垃圾回收机制就是为了解决这一类问题而产生的。

## 1.3.什么样的场景下才会使用垃圾回收机制？
一般情况下，使用垃圾回收机制的场景如下：
- 当程序申请到内存空间时，程序员需要手动释放该空间；
- 在函数调用过程中，如果在堆上创建了临时的对象，当返回函数调用时，就需要对该临时对象进行垃圾回收；
- 当变量值发生变化时，系统也需要释放相应的旧数据空间才能分配新数据空间；
- 某个对象的数据结构发生改变时，系统也需要释放旧的数据结构空间才能分配新的数据结构空间。

# 2.基本概念
## 2.1.引用计数法
引用计数法是一种简单有效的垃圾回收算法，在某些编程语言中被称作“标记-清除”或“标记-整理”。该算法的主要思路是维护一个记录所有分配对象的引用数量的列表，当引用数量变为零时，说明这个对象已经没有地方再被使用，就可以被视为垃圾。

当创建一个新的对象时，系统首先会分配一块内存，然后初始化一些成员变量的值，最后把该对象的地址放入引用计数表中。每当有一个程序块引用某个对象时，就将该对象在引用计数表中的引用计数加1；每当程序块结束对某个对象的引用时，就将该对象的引用计数减1。当某个对象的引用计数变为零时，就认为此对象可回收。

虽然引用计数法很简单但也存在着一些缺陷，比如循环引用的问题。对于循环引用的对象来说，其引用计数永远不会为零，使得垃圾回收器难以正确释放该对象。另外，由于对象引用的存在，内存管理变得十分复杂。

## 2.2.标记-清除法
标记-清除法的基本思想是从根集合开始，根据引用关系向外搜索，标记出所有可以释放的对象，然后将他们从内存中删除，剩余的所有对象都是活动对象。这一过程叫做清扫（Sweep）。

这种方法最大的优点就是简单，易于实现。缺点是容易产生内存碎片，导致程序运行效率降低。另外，由于根集合可能不完整，无法保证每次清扫都成功地回收掉所有的垃圾对象。

## 2.3.标记-整理法
标记-整理法的基本思想是将所有的活跃对象移动到内存的一端，然后回收死亡对象占据的内存，并更新引用指针。因此，它不直接对内存进行回收，而是将要回收的对象搬移到内存一端。

由于标记-整理法比标记-清除法快很多，而且不会产生内存碎片，所以它的效率比前者更高。但是，它同样存在着内存碎片的问题，即内存中残留的不可用内存不能满足需求。

# 3.核心算法
## 3.1.GC Roots
在进行垃圾回收之前，需要先确定垃圾回收的范围，也就是找到所有的GC Roots。以下三个选项是作为GC Roots的常见选项：
- 当前正在执行的函数；
- 那些栈帧中的局部变量；
- 全局变量和静态变量；

## 3.2.引用计数法
引用计数法的垃圾回收步骤如下：
- 初始化引用计数为0，同时创建一个空的引用计数表；
- 每次创建一个新对象时，更新引用计数表；
- 当程序块结束对某个对象的引用时，将该对象的引用计数减1；
- 当某个对象的引用计数变为零时，说明此对象可回收；
- 对所有可回收的对象，释放它们占用的内存。


## 3.3.标记-清除法
标记-清除法的垃圾回收步骤如下：
- 扫描所有的GC Roots；
- 把所有引用到的对象的标记为存活对象；
- 将所有非存活对象回收，释放它们占用的内存；


## 3.4.标记-整理法
标记-整理法的垃圾回收步骤如下：
- 扫描所有的GC Roots；
- 从堆顶开始标记活动对象；
- 回收非活动对象占用的内存，并更新引用指针；
