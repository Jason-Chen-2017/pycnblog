
作者：禅与计算机程序设计艺术                    

# 1.简介
  

散列表（Hash table）是一种最常用的查找结构，通过关键字映射到特定的值。在计算机科学中，通过有效地利用键值对存储空间及时间，可以提高检索、插入和删除元素等操作的效率。散列函数将任意长度的数据转换为较短的固定长度的特征码，该特征码通常用整数表示。采用散列函数之后，根据计算得到的特征码，将数据存放在数组或表中相应位置上。通过此种方式，不仅能够快速访问元素，还可以节省内存空间。
传统的散列函数都采用了除留余数法或者乘法 Hash 函数的方式。比如，求取一个数的余数作为 Hash 函数，其优点是简单，易于实现；缺点是容易产生冲突。另外，乘法 Hash 函数虽然能较好地避免冲突，但是需要考虑溢出问题。因此，现代散列函数一般采用摘要函数、随机数生成器等方式。
散列表的主要作用是在线性平均时间复杂度内完成数据的插入、删除、查找等操作。所以，在一些特定的情况下，例如快速排序等场景下，也会采用散列表进行优化。

今天，笔者将为大家介绍两种常用的散列表的实现方法，并结合具体的代码，讲述它们的内部原理和应用。

# 2.基本概念及术语
## 2.1.哈希表
在计算机科学中，**哈希表（hash table）**是一种用于存储键/值对的数据结构。它的工作原理很类似于字典，即给定一个键（key），它可以快速地返回对应的值（value）。哈希表中存储的内容都是由键值对组成的，其中每个键都是唯一的，而值则可以被多个键共享。当需要存储、查询或修改某个键时，只需从哈希表中获取或更新对应的项即可，无须遍历整个集合。

哈希表的关键就是选择好的哈希函数，该函数将键转换为索引位置。最简单的哈希函数是一个单纯的求模运算，即 `index = key % size`，这里 `size` 是哈希表的大小。这种哈希函数的缺点是如果存在两个不同的键，它们的哈希值可能相同，导致冲突。解决的方法是引入另一个哈希函数来处理冲突，再次哈希直至找到可用的空槽，放入新的键值对。

为了减少冲突，哈希表支持两种策略，一种是开放寻址（open addressing），另一种是链接法（chaining）。在开放寻址中，当遇到冲突时，直接向后或向前找一个空槽来放置新元素。链接法通过建立链表来处理冲突，每个键值对节点可以包含多个键值对，方便实现插入和删除操作。

在实际应用中，哈希表又分为静态表和动态表。静态表的大小是固定的，不会随着元素增加而自动扩充。动态表的大小会随着元素增加自动增长，而且扩展过程可以分批进行。

## 2.2.哈希函数
**哈希函数（hash function）**是一个从输入空间到输出空间的一个非线性映射，用于将数据映射到有限的、散布均匀的空间。在散列表中，哈希函数的作用就是将键转化为索引位置。

哈希函数应具有良好的抗碰撞能力，即使发生了冲突也应该保证尽可能均匀分布。常用的哈希函数包括：

1. 求模运算：假设哈希表大小为 $m$ ，则 `h(k) = k mod m`。这种简单且常用的哈希函数基本能满足要求，但速度慢，并且冲突概率高。
2. 加权求模：假设哈希表大小为 $m$ ，且 $a$ 和 $b$ 为两个质数，则 `h(k) = (ak + b) mod m`。这种哈希函数消除了冲突的几率，并且更快、占用更少的空间。
3. 折叠法：将较长的输入序列分割成小块，然后按位异或来获得索引。这种方法速度很快，空间效率很低，适用于较短的输入序列。
4. 分组选择法：先将输入划分成大小相等的几个子串，然后按位异或，最后选择某些位作为索引。这是折叠法的变种，速度更快，适用于较长的输入序列。
5. SHA-256 或 MD5 哈希函数：计算输入的消息摘要，然后截取前 n 位作为索引。这种哈希函数的优点是生成索引效率比较高，同时防止了碰撞。

## 2.3.拉链法
**拉链法（collision resolution technique）**指的是当多个键值对映射到同一个索引位置时，如何解决冲突。拉链法可以采用开放寻址方式，也可以采用链接法。

### 2.3.1.开放寻址法
在开放寻址法中，当遇到冲突时，哈希表会寻找一个空闲的位置来存储新元素。最简单的寻址方式是顺序查找法，即从第一个位置开始依次查找，直到找到一个空槽。这种寻址方式的平均情况性能很差，往往需要扫描整个表才能找到空槽。

为了改善这个问题，一些哈希表采用了二次探测、线性探测、二叉探测等探查技术。这些探查技术在找到第一个空槽之前，会探查一定距离的位置，试图找到一个空槽。探查的步长可以设置为 $1,\ldots,m-1$ ，也可以设置为其他值。

### 2.3.2.链接法
在链接法中，每一个索引位置可以是一个指针，指向一个链表。链表中的每个节点都是一个键值对，用来存储哈希表中所有映射到的元素。当发生冲突时，便将新的键值对插入到链表的尾部，而不是简单地覆盖掉旧的值。链接法的优点是简单易于实现，而且对于搜索操作来说，平均情况的时间复杂度很高。

## 2.4.哈希冲突
当多个元素映射到同一个索引位置时，称为**哈希冲突（hash collision）**。解决哈希冲突的方法有很多，常用的有以下几种：

1. 拉链法：将所有的冲突元素都存放在同一个链表中。
2. 开放寻址法：采用二次探查、线性探查或二叉探查的方式，探查冲突位置直至找到一个空槽。
3. 建立一个公共溢出区：当冲突发生时，将元素存放到溢出区，供后续的元素使用。
4. rehashing：当哈希表填满时，重新构造一个更大的哈希表，将冲突元素重新分布到新表。

# 3.散列表的实现方法
## 3.1.数组实现法
数组实现法是最简单的散列表实现方法。其基本思路是创建一个大小固定的数组，并按照哈希函数将键值对映射到数组的位置。当遇到哈希冲突时，采用开放寻址技术，将新元素插入数组的下一个空位置。

数组实现的散列表的优点是简单、易于理解，但是缺点也是显而易见的。首先，数组的大小是一个固定值，无法根据元素数量自行调整。其次，即使元素分布均匀，也不能完全避免冲突。如果出现严重的负载因子过大，或者是较少的元素，那么哈希表的性能就会下降。

## 3.2.链接法实现法
链接法实现法是把数组中的元素看作链表的首节点，将冲突的元素都放在同一个链表中，这样就可以降低冲突的概率。

在链接法实现中，需要定义一个 `Node` 类来表示一个节点，其中包含了一个键值对，以及指向下一个节点的指针。然后创建一个空的头节点来初始化整个链表，并设置链表的长度。当发生冲突时，只需在链表中添加新节点即可。

链接法实现的散列表的优点是避免了数组大小固定带来的不足，并且降低了冲突的概率。但是，由于每个节点都需要额外的指针域，因此链表本身也占用了一定的空间。另外，删除操作也比较困难。当删除一个节点时，只能从链表头开始遍历，直到找到该节点的前驱节点，然后把该节点从链表中删除。

## 3.3.拉链法实现法
在链接法的基础上，可以让每个节点既保存键值对，又包含一个链表指针。这样，对于每个键值对，就形成了一条独立的链表，称为拉链。每个节点都会记录自己对应的链表的头部，同时还维护着指向下一个节点的指针。

拉链法实现的散列表的优点是利用了链表的局部性，可以在 O(1) 的时间复杂度内定位、删除或插入一个元素。缺点是拉链法的效率比链接法要低，尤其是在删除操作上。当删除一个节点时，只需要更新指向该节点的前驱节点的指针，即可完成删除。但是，链接法中的指针是按序排列的，因此可以快速定位到要删除的节点，而在拉链法中，需要遍历链表才能定位到该节点。另外，在链表之间移动元素的时候，需要维护指针的正确性，否则会破坏链表的结构。

综上所述，目前主流的散列表实现方法有两种，数组实现法和链接法实现法。在实践中，不同的选择可能会影响到哈希表的性能。一般情况下，如果预计存储的数据量比较多，则推荐采用链接法实现；反之，则推荐采用数组实现。