
作者：禅与计算机程序设计艺术                    

# 1.简介
  

JVM（Java Virtual Machine）是运行在诸如桌面、移动设备或服务器上的Java虚拟机。为了实现在不同的平台上可以运行同样的代码，JVM会把源代码编译成符合平台CPU指令集的机器码并执行，但这需要不同平台都支持相同的JVM。JVM拥有自己的内存管理系统，包括堆内存、方法区、虚拟机栈等内存空间。JVM根据内存分配策略将新创建的对象或类的实例保存在内存中指定的内存区域。本文试图通过详细地剖析JVM堆内存区域划分及其分配策略，阐述JVM在内存管理方面的优点和局限性。
# 2.基本概念
首先，介绍一些编程语言相关的基本概念。
- **编译器**：负责把源代码编译成为可被运行的目标代码。包括语法检查、类型检查、语义分析、代码生成、优化、链接等步骤。
- **字节码**：编译后的代码经过 JVM 的编译器编译之后得到字节码。字节码是一种中间表示形式，它并不直接对应于计算机的二进制机器码，而是在虚拟机上运行的 Java 源代码的低级语言。
- **类加载器**：负责从本地文件系统或者网络中加载class文件，class文件包含了编译后生成的字节码。类加载器通过装载某个class文件来初始化这个类。
- **虚拟机栈**：每个线程运行的时候都会创建一个单独的栈，用于存储它的运行状态信息，包括局部变量表、操作数栈、动态链接、方法出口等。
- **堆内存**：JVM管理的内存中最大的一块，用来存放所有类实例和数组。
- **方法区**：方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- **元数据区**：包含类、方法、接口等描述符，这些数据在类加载过程中的解析阶段由 JVM 生成。
- **直接内存**：不是JVM运行时数据结构的一部分，而是通过unsafe包进行操作，直接向系统内存申请和释放。
另外，还有几个JVM实现中的概念，比如“压缩指针”、“偏向锁”等，这里暂且不提。
# 3.内存模型
JVM堆内存主要分为三个区域：Eden区、Survivor区以及老年代。
其中，Eden区和Survivor区都是线程私有的；老年代是整个JVM进程的共享资源，大小和数量由GC算法决定。在JVM堆内存模型中，堆是连续的，而JVM中通常不会对堆的物理内存进行直接操作。相反，内存管理都是借助于垃圾收集器完成的。因此，每当发生GC事件时，JVM便会将堆内存清理干净，然后重新分配空间。


## 3.1 Eden区
JVM堆内存中较小的空间，称为Eden区，它是垃圾收集器从堆里提升过来的内存，一般占用堆空间的5%到10%左右。当新创建的对象大小超过一定阈值，则直接进入Survivor区，否则进入Eden区。因为这个过程非常简单，所以Eden区不需要设置回收阈值，如果出现了很多小对象，那么也会直接进入Survivor区。但是，由于Eden区比较小，所以频繁的GC操作可能会造成性能问题。因此，JVM对Eden区采用了分代收集算法，对象首先在Eden区生成，经历一个GC周期后若仍然存活，则依旧留在Eden区；若要被回收，则会被移至Survivor区，随后还会进一步处理。


## 3.2 Survivor区
Survivor区又叫from/to区，是一个中间区域，两边各有一个。一开始新建的对象先进入Eden区，Eden区满时触发一次GC，Survivor区满时，其中的存活对象才会被复制到另一个Survivor区。经历两个GC周期后，Eden区和两个Survivor区里的存活对象，才会被复制到老年代中，之前占用的内存空间会被释放掉。这样就保证了新生代GC和老年代GC的时间间隔可以缩短，降低应用暂停时间。不过，也正因为此，如果Survivor区中的对象经历过多次GC，而始终没有成功移动到老年代，则可能导致老年代满溢出。因此，JVM设置了一个晋升阈值，只有一个Survivor区满时，才会被选定为要晋升到老年代。


## 3.3 老年代
老年代的作用就是保存生命力长的对象。在JVM中，一般把老年代分成三个区域：伊甸园区、幸存者区、元空间。而元空间跟方法区类似，也是保存类、方法、接口等信息。

### 3.3.1 伊甸园区
伊甸园区也就是新生代中的“大腿”，主要存放生长中的对象，如果遇到了GC，这些对象就会被转移到幸存者区。伊甸园区的大小约为整个新生代的1/3，但不得超过10%，如果占用的空间超过了限制，则触发Full GC。

### 3.3.2 幸存者区
幸存者区是新生代中的“瘦腿”，它保留了上一次GC之后存活的对象。在一次GC之后，新的存活对象都被复制到另一个Survivor区。

### 3.3.3 元空间
元空间主要用于存储类的元数据，如类的名称、字段、方法、常量池等。元空间在JVM启动的时候会初始化，并在堆空间不足时自动扩容。元空间的大小由启动参数配置。


## 3.4 分配算法
JVM堆内存的分配算法主要有两种：
- **固定分配策略**（默认）：在堆内存中划分出一定的内存给各个线程，线程只能在自己的内存中进行分配，不能越界。Java在分配线程栈内存时采用的是固定分配策略，所以栈大小一般默认为1MB或2MB。当然也可以指定线程栈的初始大小、最大值、扩展增长量，甚至可以使用线程局部变量的方式在线程内部分配内存。
- **可变分配策略**（使用`-Xmx`选项控制）：堆内存按需分配，每个线程都可以在自己线程的内存中分配内存，可以任意范围分配，不会超出线程的内存限制。这也是目前流行的JVM默认的内存管理方式，也被称为“bump-the-pointer”。这种方法的好处是可以更灵活的分配内存，避免频繁的GC操作。当然，为了防止堆外内存溢出，JVM需要添加相应的内存管理策略。比如可以使用`-XX:+HeapDumpOnOutOfMemoryError`选项，将堆内存转储到磁盘上，便于排查问题。


## 3.5 Full GC
如果由于内存不足，无法再创建新的对象，便会触发Full GC，包括对整个堆内存进行垃圾回收，清除不再使用的对象和回收死亡对象所占据的内存。Full GC的过程如下：

1. Stop the world: 停止应用程序所有的线程，暂停服务，等待GC完成。

2. Mark phase: 对所有GC Roots进行遍历标记，标记哪些对象是垃圾，哪些对象是活跃的。这一步需要扫描GC Roots的所有存活对象的引用链，将不能到达的对象标志为死亡。

3. Sweep phase: 清理已经标记好的死亡对象，释放它们所占用的内存空间。

4. Copy phase: 将活跃对象复制到其他地方，空出空间。

5. Start the world: 重新恢复应用程序，继续执行。

Full GC一般会比Young GC耗费更多的时间，所以应该尽量避免Full GC发生。但是对于内存空间比较大的系统，可以通过减少老年代的大小或增加survivor区的数量来减少Full GC发生的概率。


# 4. JVM栈与局部变量
## 4.1 栈帧
栈帧（Stack Frame）是用来存储方法调用时的临时变量值的内存区域。每当调用一个方法时，Java虚拟机就会在内存中为这个线程的当前方法创建一个新的栈帧，用来存储局部变量、操作数栈、返回地址和一些额外的信息。


栈帧主要包含以下信息：
- **局部变量表**（Local Variable Table）：存放方法的参数、局部变量和临时变量。局部变量表以Slot为基本单位，每个Slot可以存放一个int、float、reference或returnAddress类型的值。注意，一个Slot大小在32位系统上为32位宽，在64位系统上为64位宽。
- **操作数栈**（Operand Stack）：Java虚拟机的运行引擎工作时，它维护一个操作数栈，作为临时存储数据的场所。操作数栈以Slot为基本单位，每个Slot可以存放一个int、long、float、double或reference类型的值。
- **动态链接**（Dynamic Linking）：由于虚拟机支持多态机制，Java允许程序实现接口和多重继承，而运行期绑定实际类型的动作则由运行时动态链接来实现。栈帧中包含一个指向运行时常量池的方法引用，该引用将在运行时确定接收者对象确切类型，并调用方法入口地址。
- **方法返回地址**（Return Address）：用于支持方法调用的返回值传递。在方法正常执行完毕后，要返回调用它的地方，需要一个方法返回地址，以便能够正确返回。每一个栈帧中都包含一个返回地址指示下一步的执行位置。
- **附加信息**（Additional Information）：JVM规范定义了一些附加信息放在栈帧中，例如安全、隐藏类信息、类加载器、 synthetic 字段属性、以及一些异常处理信息等。

## 4.2 方法调用
当执行某个方法时，Java虚拟机会创建一个新的栈帧，并压入栈顶，同时更新PC寄存器（Program Counter Register），使之指向方法代码的第一条指令地址。当方法调用结束时，栈帧出栈，相应的局部变量表和操作数栈也随之消失。方法调用总是通过方法调用指令来实现的，比如invokevirtual、invokespecial、invokeinterface和invokestatic指令。除了上面介绍的栈帧和栈外内存之外，方法调用过程中还有很多细节需要关注。

方法调用有四种情况：
- **静态方法调用**（Static Method Call）：由方法的class文件的修饰符和属性来决定的。静态方法无需创建对象实例即可直接访问方法体中的代码。
- **实例方法调用**（Instance Method Call）：需要先创建对象实例，然后才能调用对象实例的方法。对象实例方法的调用有两个阶段：
  - 在虚拟机栈中创建新的栈帧，压入栈顶，并且更新PC寄存器指向方法代码的第一条指令地址。
  - 把方法参数的值传送到局部变量表中。
- **构造器方法调用**（Constructor Method Call）：每当创建一个类的实例时，JVM都会调用类的构造器方法来初始化类实例。
- **同步方法调用**（Synchronized Method Call）：同步方法在调用前要获得对象监视器的锁，如果获取失败，线程暂停。当该线程退出同步代码块后，释放对象监视器的锁，其它线程就可以获得该锁并继续执行该同步方法。

在JVM实现中，会根据需求创建不同的运行时栈和寄存器，比如用于处理异常的异常栈、用于支持native方法调用的本地方法栈等。

# 5. JVM内存分配
JVM堆内存的分配主要涉及三个方面：
- 对象创建：当程序中创建了一个对象，JVM会给这个对象在堆内存中开辟一段内存空间，并将对象的头部信息写入内存，包括对象的长度、类型指针、哈希码、GC标志等。
- 对象内存分配：JVM提供两种分配方式：
  - 指针碰撞法：假设一个对象需要8个字节的内存空间，那么分配的内存地址是第一个空闲内存地址。当使用完毕后，JVM会回收这块内存，使得后续分配时不会在这块内存中重复使用。
  - 空闲列表法：维护一个空闲内存列表，当分配对象时，查找最适合的空闲内存空间进行分配。
- 对象内存释放：当一个对象不再被任何变量引用时，JVM会将其内存空间释放，以便它可以被其他对象使用。

## 5.1 指针碰撞法
指针碰撞法认为，每个对象占用一整块内存，内存地址由对象头和对象的实例数据共同决定。首次分配内存时，JVM分配一整块内存空间，并将其起始地址赋值给对象的实例变量。然后，JVM用指针定位到下一个空闲内存地址，并将分配出的内存地址赋值给该对象实例的变量。最后，JVM在对象头中记录下该对象占用的内存大小、类型、空闲标志等信息，并将对象加入到GC管理器中进行管理。


## 5.2 空闲列表法
空闲列表法认为，所有对象都分配在一起的空间称为“空闲内存”或“堆”，而且内存块不应该被任何对象连续分配，以便找到足够大小的内存块进行分配。每个堆块都有一个有效内存大小，当请求分配内存时，根据有效内存大小查找适合的内存块。


JVM的分配算法可以总结为：
- 如果请求的内存小于指针大小，直接分配，如果等于指针大小，则向上取整至大于指针大小的最小2的幂。
- 如果请求的内存大于指针大小，则查找空闲内存链表，找到满足要求的内存块。如果找不到，则尝试进行内存抓取，将已经分配的内存空间返回给操作系统。

# 6. GC垃圾回收算法
## 6.1 标记清除算法
标记清除算法的基本思想是先标记出所有需要回收的对象，再统一回收所有被标记的对象所占用的内存空间。它将内存分为三部分：
- 一部分是所有活动对象，属于存活状态；
- 一部分是所有未活动对象，即将死亡的对象，只能通过“标记-清除”回收；
- 一部分是空闲内存，用于未分配的内存。


算法分为四个步骤：
1. 根集合扫描：对所有的GC Roots进行扫描，标记活跃对象。
2. 死亡对象标记：遍历所有标记的活跃对象，标记没有指向它的死亡对象。
3. 回收死亡对象：将死亡对象占用的内存空间释放，使他们能被分配。
4. 更新引用指针：修正那些仍然被活跃对象引用的指针，以让其指向新的地址。

## 6.2 标记复制算法
标记复制算法和标记清除算法很像，但是多了一份额外的存储空间用于存放活动对象。它将内存分为三部分：
- 一部分是所有活动对象，属于存活状态；
- 一部分是所有未活动对象，即将死亡的对象，只能通过“标记-复制”回收；
- 一部分是空闲内存，用于未分配的内存。


算法分为五个步骤：
1. 初始化活动对象空间和空闲对象空间：将所有活动对象拷贝一份到新的内存空间。
2. 根集合扫描：对所有的GC Roots进行扫描，标记活跃对象。
3. 死亡对象标记：遍历所有标记的活跃对象，标记没有指向它的死亡对象。
4. 拷贝存活对象：将活跃对象依次拷贝到空闲内存中，释放原来的内存。
5. 更新引用指针：修正那些仍然被活跃对象引用的指针，以让其指向新的地址。

## 6.3 标记整理算法
标记整理算法和标记复制算法一样，只是在回收死亡对象时多了一道操作。它将内存分为三部分：
- 一部分是所有活动对象，属于存活状态；
- 一部分是所有未活动对象，即将死亡的对象，只能通过“标记-整理”回收；
- 一部分是空闲内存，用于未分配的内存。


算法分为五个步骤：
1. 初始化活动对象空间和空闲对象空间：将所有活动对象拷贝一份到新的内存空间。
2. 根集合扫描：对所有的GC Roots进行扫描，标记活跃对象。
3. 死亡对象标记：遍历所有标记的活跃对象，标记没有指向它的死亡对象。
4. 移动存活对象：将活跃对象整理到堆的起始位置，释放原来位置的内存。
5. 更新引用指针：修正那些仍然被活跃对象引用的指针，以让其指向新的地址。

## 6.4 标记-延迟算法
标记-延迟算法引入了分代回收机制，根据对象的年龄将内存划分为不同的年龄段，不同的年龄段采用不同的回收算法。它将内存分为四部分：
- 年轻代：使用“标记-复制”算法。
- 中年代：使用“标记-清除”算法。
- 大年代：使用“标记-整理”算法。
- 持久代：永久代，用于存放静态变量和类信息。


算法分为六个步骤：
1. 根集合扫描：对所有的GC Roots进行扫描，标记活跃对象。
2. 死亡对象标记：遍历所有标记的活跃对象，标记没有指向它的死亡对象。
3. 整理对象：根据对象年龄将对象归类，并将不同年龄段的对象回收。
4. 拷贝存活对象：将活跃对象依次拷贝到空闲内存中，释放原来的内存。
5. 更新引用指针：修正那些仍然被活跃对象引用的指针，以让其指向新的地址。
6. 执行完整GC：必要时进行整理和拷贝步骤，直到没有内存分配或回收需要进行。