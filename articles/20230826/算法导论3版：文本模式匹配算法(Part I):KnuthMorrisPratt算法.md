
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 什么是模式匹配？
模式匹配（pattern matching）是指在一个字符串或文本中查找另一个字符串或者子串的方法。

## 为什么要学习模式匹配算法？
字符串匹配算法是数据压缩、数据处理以及很多其他领域中的基础技术。掌握字符串匹配算法可以帮助我们解决许多实际问题，例如：在海量文档中搜索关键词、在序列数据库中进行快速定位、字符串比较检索等。因此，掌握合适的字符串匹配算法至关重要。

## 什么是字符串匹配算法？
字符串匹配算法主要有两种类型，即朴素的字符串匹配算法和自回归的字符串匹配算法。

1. 朴素的字符串匹配算法：朴素的字符串匹配算法采用暴力法，即从左到右依次匹配每个字符。这种方法简单、直观，但是效率低下。
2. 自回归的字符串匹配算法：自回归的字符串匹配算法采用动态规划的方法，同时考虑当前位置和之前的匹配信息。通过保存匹配过程中的状态，避免了重新计算匹配。

# 2.背景介绍
Knuth-Morris-Pratt (KMP) 算法是一个非常著名的字符串匹配算法，其最早由 D.E. Knuth、J.H. Morris 和 C.P. Pratt 在1977年联合发表。KMP算法在模式串匹配中起着“领航者”的作用，堪称“乔治华盛顿梦之队”。

## KMP算法的特点
* 有利于边界匹配，对待待查字符串中的每一个字符，都需要做一次预判，才能确定它的匹配是否成功；
* 通过记录失败指针位置，提前跳过不可能出现的字符，加快模式串匹配速度；
* 对某些特定模式，其失配时刻的数量为已匹配的字符个数减一，但一般情况下失配时刻的数量等于0。

# 3.基本概念术语说明
## 模式串与文本串
模式串（pattern string）：代表待匹配的模式字符串，又称为“模式”。

文本串（text string）：代表被搜索的字符串，也称为“主串”。

## 首字符与末字符
首字符（first character of pattern）：模式串的第一个字符，记作$p_1$。

末字符（last character of pattern）：模式串的最后一个字符，记作$p_{m}$。

首末字符共同决定了模式串的类型，如简单模式串、不完全匹配模式串、完全匹配模式串等。如果$p_i=p_j$，则称$i$和$j$是同位字符。

## 字母表$\Sigma$及其反向映射表$f(\sigma)$
字母表$\Sigma=\{a,b,\cdots,z\}$，其中大小写英文字母的集合。

反向映射表$f(\sigma)$：将字母$\sigma$映射成为数字$0$至$n-1$的函数，其中$n$表示字母表$\Sigma$的大小。例如，如果$\Sigma=\{a,b\}$，那么$f(a)=0$,$f(b)=1$。

## 失配函数
对于某个位置$i$，失配函数$\pi_i$表示模式串的前缀与主串的最长相同前后缀的长度，它描述的是主串中第$i+1$个字符与模式串的哪些字符不一致，并且是如何不一致的。当且仅当$\pi_i>0$时，失配发生。

## 前趋数组predecessor array
前趋数组（predecessor array）是对失配函数的一种优化。在最坏情况下，失配函数需要计算每个位置$i$的前缀与最长相同前后缀的长度，时间复杂度为$O(|\Sigma|^2)$。为了提高效率，KMP算法使用了前趋数组来存储失配函数的值，只需要计算每个位置的前缀与最长相同前后缀的长度即可，降低了时间复杂度。

前趋数组$\mu=[-1,\mu_1,\mu_2,\cdots]$，其中$-1$为哨兵值，$\mu_1,\mu_2,\cdots$为各个位置的前趋索引。若$\mu[i]<0$，则不存在与模式串的前缀相等的后缀，否则，$\mu[i]$就是与模式串的前缀相等的后缀的最大长度。

# 4.核心算法原理和具体操作步骤以及数学公式讲解
## 暴力匹配算法
暴力匹配算法通过逐个字符地匹配模式串与文本串，遇到不匹配的地方立即停止匹配并返回匹配失败。

## Knuth-Morris-Pratt算法
Knuth-Morris-Pratt算法可以看成两个阶段的迭代。第一阶段，构建前趋数组$\mu$；第二阶段，根据前趋数组生成失配函数$\pi$。

### 构造前趋数组$\mu$
首先，令$i=0$，并设置$\mu[i]=-1$，表示当前位置没有前趋。然后，设定$j=0$，遍历$p_1\cdots p_m$。

* 如果$p_{j+1}=p_{i+1}$，则$\mu[++i]=++j$，即后移两步，继续匹配。
* 否则，设定$k=0$，遍历$p_\mu$，找到$\mu[k]>=-1$，再使得$\mu[k]\ge j$。如果存在这样的一个位置$l<k$满足条件，则更新$\mu[k+\mu[l]]=k+1-\mu[l]$。如此一来，就能找到一个位置$r$，使得$\mu[r]>=-1$，而$\mu[r]\ge j$，$\mu[k+\mu[l]]=k+1-\mu[l]=(k-l)+1-\mu[\mu[k]+1]$，于是$k=\mu[k]+1$，接着比较$p_{k+1},p_{i+1}$。重复该步骤，直到$\mu[k]=-1$，此时结束循环。
