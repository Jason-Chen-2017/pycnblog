
作者：禅与计算机程序设计艺术                    

# 1.简介
  

随着信息化时代的到来，越来越多的人加入了创新型、高科技的行业，网络平台也逐渐发展起来，成为所有人的共同的交流平台。而人才也是这一切的基础和保障。在当今这个市场竞争激烈、人力资源配置充裕的年代，找工作真的是越来越难。那么，造成找工作困难的原因又是什么呢？
首先，作为个人来说，定位自己的能力还算不错，但如果想要进入一个团队，能不能很好的融入团队的氛围，用自己的长处和专长帮助团队解决问题，这是重中之重。其次，国内外的大环境和政策有很大的影响，例如教育程度要求、职业工种激烈竞争等。再者，刚毕业不久的学生更加不容易找到满意的工作，因为缺乏足够的实习经验以及项目经验。最后，即使已经有了一份心仪的工作，如何有效的融入团队，结合自身的知识和经验，保持学习和进步也是非常重要的。所以，整体来说，找工作不容易，主要原因还是个人素质的问题。
# 2.核心概念
## 2.1 技术类岗位及对应关键词
这里列出一些最常见的技术类岗位及其对应的关键字，供大家参考：

1. web前端工程师：HTML/CSS/JavaScript/TypeScript/React/Angular/Vue；
2. web后端工程师：Python/Java/Golang/Node.js/PHP；
3. 数据分析工程师：SQL/NoSQL/Hadoop/Spark/Flink；
4. 移动开发工程师：Android/iOS/Flutter/RN；
5. 测试工程师：自动化测试（单元测试/功能测试/压力测试）/集成测试/UI自动化测试；
6. DevOps工程师：Docker/K8s/CI/CD；
7. 数据库工程师：MySQL/Redis/MongoDB/TiDB/InfluxDB；
8. 嵌入式开发工程师：ARM/MCU/Linux驱动开发；
9. 区块链工程师：Solidity/Ethereum/Tron/Cosmos;
10. 智能机器人工程师：ROS/Tensorflow/PyTorch/ROS2/Wekinator/OpenCV/Nvidia JetsonNano

## 2.2 计算机行业分类及岗位信息
计算机行业目前分为以下几个领域：

1. 系统软件
2. 应用软件
3. 网络应用
4. 图形用户界面（GUI）设计与制作
5. 操作系统
6. 数据库系统管理员
7. 系统维护工程师
8. 硬件工程师
9. 游戏开发人员

计算机相关职位的招聘网站包括：

计算机类招聘网站还有很多，大家可以根据自己的喜好进行选择。

# 3.算法原理及具体操作步骤
目前，大数据技术正在逐渐火爆，由于海量数据处理速度的提升，算法相关领域也在蓬勃发展。算法作为核心技术，被广泛运用于各个领域，如图像处理、文本处理、人工智能、推荐系统、搜索引擎等。相信掌握算法相关技术，对找工作会有一定的帮助。下面给出数学原理和具体操作步骤，希望能够帮助大家解决实际问题。
## 3.1 聚类算法
聚类算法是一种无监督学习方法，它通过对给定的数据集进行划分，将具有相似特征的样本归为一类，最终得到多个子集。常见的聚类算法有K-Means、层次聚类和谱聚类等。下面演示K-Means算法的具体操作步骤。
### 3.1.1 K-Means算法步骤
K-Means算法是一个迭代算法，主要用于无监督聚类问题。下面是K-Means算法的步骤：

1. 初始化K个中心点，随机生成即可；
2. 遍历整个数据集，计算每个样本距离K个中心点的距离，确定该样本所属的中心点；
3. 更新中心点位置，使得各个中心点均衡分布；
4. 判断是否收敛，若没有收敛则重复第2~3步，直至收敛。

K-Means算法适用的条件：

1. 数据服从正态分布
2. 有明显的聚类结构
3. 每个样本都有一个标签值或属性值

下面给出一个例子，基于Iris数据集，用K-Means算法进行鸢尾花的分类。

```python
from sklearn import datasets
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
iris = datasets.load_iris()
X = iris.data[:, :2] # 取前两个特征
y = iris.target
plt.scatter(X[y==0, 0], X[y==0, 1]) # 第1类
plt.scatter(X[y==1, 0], X[y==1, 1]) # 第2类
plt.scatter(X[y==2, 0], X[y==2, 1]) # 第3类
kmeans = KMeans(n_clusters=3)
pred_y = kmeans.fit_predict(X)
plt.scatter(X[pred_y==0, 0], X[pred_y==0, 1])
plt.scatter(X[pred_y==1, 0], X[pred_y==1, 1])
plt.scatter(X[pred_y==2, 0], X[pred_y==2, 1])
plt.show()
df = pd.DataFrame(np.hstack((X, pred_y.reshape(-1,1))), columns=['Sepal Length', 'Sepal Width', 'Pred Label'])
print(df)
```

运行结果如下图所示，第一列是 Sepal Length，第二列是 Sepal Width，第三列是预测的标签。


可以看到，K-Means算法成功地将三个不同的鸢尾花类型划分开来。当然，由于随机初始化的原因，每次结果可能略有不同。另外，K-Means算法需要指定初始的K个中心点，因此需要人为设置一个合理的值，同时，中心点的初始值往往会影响最终结果。
## 3.2 PageRank算法
PageRank算法是Google公司用来排名网站的一种算法。它的基本思想是认为，跟一个页面相关的其他页面也应当被重视，并以此衍生出一种权威性评价标准。下面演示PageRank算法的具体操作步骤。
### 3.2.1 PageRank算法步骤
PageRank算法的步骤如下：

1. 将每一个页面抽象成一个节点，并赋予一个随机的权重（假设为1/n），其中n是网页总数；
2. 从给定的起始节点开始，随机游走，选择从当前节点跳出的概率与从起始节点跳出的概率之比相同；
3. 以此类推，直到达到结束节点；
4. 对各个节点的权重进行更新，权重等于相邻节点的权重之和除以节点总数。

PageRank算法适用的条件：

1. 网页的链接结构是随机的，且没有环路现象。
2. 网页的内容具有代表性，比如新闻等。

下面给出一个例子，基于Wiki百科，用PageRank算法对网页进行排名。

```python
import networkx as nx
G = nx.random_internet_as_graph(200)
pr = nx.pagerank(G)
for i in sorted(pr.items(), key=lambda x: -x[1]):
    print('{:>2} {}'.format(*i))
```

运行结果如下所示，前10名的页面和对应的权重。

```
      1 https://en.wikipedia.org/?curid=1
  0.0001 https://en.wikipedia.org/wiki/Main_Page
     ... 
     .
     .
     .
0.0000001 https://en.wikipedia.org/wiki/Special:Random
``` 

可以看到，页面按照PageRank算法的指标进行排名，权重越高，排名越靠前。当然，PageRank算法存在局限性，对于一些权威性低的页面，其权重可能会下降。