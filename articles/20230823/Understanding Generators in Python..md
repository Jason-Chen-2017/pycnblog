
作者：禅与计算机程序设计艺术                    

# 1.简介
  

Python内置了Generator这个非常强大的功能,它可以帮助我们在迭代过程中节省内存空间，同时也避免了程序的内存溢出的问题。本文主要对Python中的Generators进行介绍，并通过一些实例代码介绍其基本用法及其背后的原理。
## 为什么需要Generators？
一般来说，生成器用来创建一个迭代器（Iterator），迭代器是一个可以记住遍历的位置的对象。在Python中，可以使用`yield`关键字创建生成器函数，这个函数不但可以产生值，还可以暂停执行并保存当前状态，返回到下一次的调用。这样就可以边计算边生成数据，适用于处理流式或超大的数据集合。

举个例子，比如要遍历一个列表的所有元素，如果直接在内存中把所有元素都存放起来，可能会占用过多的内存资源导致程序崩溃。此时，可以先把第一个元素生成出来，然后返回到函数里，继续从上次停止的地方继续计算下一个元素，直到最后一个元素被生成。这样就不会把所有元素都存放在内存中，只需要临时存储当前状态即可。

更重要的是，使用生成器后，可以用for循环、list comprehension等高阶的编程技巧来处理数据集合，使得我们的代码编写更加简洁、优雅。
## 生成器的基本概念
### 协程
在计算机科学中，协程（Coroutine）是一种比线程更小的运行单位，又称微线程，属于用户态线程，协程具有以下特点：

1. 一个线程就是一个执行流程，里面通常会包含很多任务切换过程。
2. 而协程则是单任务操作系统内核调度的基本单元，具有自己的寄存器上下文和栈。

协程的特点决定了它能比线程更好地应付处理I/O密集型任务，因为它可以在不占用系统资源的情况下实现“中断”来响应事件。

基于这些特点，Python作者在设计Python语言的时候，引入了第三方模块`greenlet`，通过嵌套上下文实现协程切换。

### 生成器的概念
生成器（Generator）就是一个特殊类型的迭代器，它的定义方式比较特别，生成器函数用`yield`关键字而不是`return`关键字返回结果。当函数遇到`yield`关键字，函数的状态就会被保存，并且处于等待状态，它不会产出值，而是保存当前函数状态，下一次调用恢复该函数，接着从离开的地方继续往下执行。

当生成器第一次启动时，或者外部调用next()方法时，生成器函数的代码会从头到第一个`yield`语句执行，然后返回yield表达式的值，就像普通函数一样；
当再次调用next()方法时，生成器函数会从上次停止的地方继续执行，直到下一个`yield`语句为止，并返回yield表达式的值，直到函数结束，迭代器终止。

这么做的原因是生成器函数保留了上次状态的能力，它可以使用内部状态来保存处理进度，因此可以将无限的序列计算转换成有限的迭代器序列，节省内存。

## 使用生成器的例子
```python
def fibonacci(n):
    a = 0
    b = 1
    for i in range(n):
        yield a
        temp = b
        b += a
        a = temp

f = fibonacci(10)
print([x for x in f]) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

这段代码生成一个斐波那契数列的生成器，初始值为a=0，b=1，函数会生成前n个斐波那契数列的值。用for循环打印生成器的值得到[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]。

```python
def find_primes():
    primes = []
    num = 2
    while True:
        is_prime = True
        for prime in primes:
            if num % prime == 0:
                is_prime = False
                break

        if is_prime:
            primes.append(num)
            yield num

        num += 1

p = find_primes()
print([next(p) for _ in range(10)]) #[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
```

这段代码生成了一个素数的生成器，每次调用`next()`方法都会返回下一个素数，为了限制程序运行时间，这里只打印了前10个数，实际运行次数会受限于计算能力。