
作者：禅与计算机程序设计艺术                    
                
                
图是一种连接节点（node）的有限集合，图中的每条边（edge）都连接两个不同的节点。在图数据结构中，通常采用邻接矩阵或者邻接表的方式表示图，通过图中的各个节点之间的关系及其权重来描述图形结构。图是复杂网络、电路设计、计算机网络等领域的基础工具。图数据结构在计算机科学中也扮演着重要角色，如图的搜索、最短路径、最大流量、图论与网络流分析等方面。

本文首先介绍了图的数据结构以及相关概念，并阐述了如何存储图以及图的基本操作。然后，介绍了几种经典的图遍历算法——广度优先搜索、深度优先搜索、分层遍历和宽度优先搜索。最后，讨论了一些常见的问题和应用。

# 2.基本概念术语说明
## （1）图的定义
图是由顶点（vertex）和边（edge）组成的结构。其中顶点表示图中一个节点或实体，一条边表示从一个顶点到另一个顶点的一条连接线，权重则代表两点间连接的实际长度。图的性质一般包括：

①无向图：图中任意两条边具有方向性，即一条边的起始点和终止点可以不同；
②带权图：图中的每个边上都有一个权重值，代表该条边的实际长度；
③强连通图：图中存在至少一条路径可以从任意一个顶点到达任意其他顶点；
④完全图：图中任意两点之间都存在边相连。

## （2）图的表示方法
图的数据结构中主要有两种方式来表示图：

①邻接矩阵法：采用二维数组来表示图的顶点，对角线上的元素表示节点i和节点j是否相邻，如果相邻则置1，否则置0。这种方法简单直观，但对稀疏图不友好。

②邻接表法：采用链表数组来表示图的顶点。对于节点i来说，建立一个链表，里面存储所有指向它的边。对于节点j来说，它也创建一个链表，里面存储所有指向它的边。这种方法比邻接矩阵法节省空间，同时对于稀疏图也更适用。

## （3）图的基本操作
图的数据结构提供了四种基本操作，包括创建图、访问图、添加/删除图元素以及求解图问题。

①创建图：新建一个空白的图，然后根据需要可以一步步添加顶点和边。

②访问图：可以查看图的某些属性，如图中所有的顶点、边、节点数目，某个顶点的出度、入度，某个顶点的所有邻居等。

③添加/删除图元素：可以动态地添加新顶点和边，或者删除已有的顶点和边。

④求解图问题：图的研究对象多种多样，如路径规划、最小生成树、最大流问题、通信网络设计、机器学习等。图算法也因应用场景的不同而变得更加丰富。

# 3.核心算法原理和具体操作步骤以及数学公式讲解
## （1）图的存储方式
图的存储方式有两种：邻接矩阵和邻接表。本文采用邻接矩阵的方式进行举例。

对于邻接矩阵法，图中的每条边对应于一个二元数组元素，元素的值为1或者0。数组的第一行和列分别表示图中的顶点。对于顶点i和顶点j之间是否存在边，如果存在边则该位置元素值为1，否则为0。如下图所示：

![image-20210701231553579](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210701231553579.png)

对于邻接表法，图中的每条边对应于图的一个链表，链表中包含了指向该边目标顶点的所有节点。数组的第一行和列分别表示图中的顶点。对于顶点i和顶点j之间是否存在边，将在i对应的链表中查找是否存在指向j的节点。如下图所示：

![image-20210701232020234](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210701232020234.png)

## （2）图的遍历
图的遍历，又称图搜索。图的遍历是指从图中某一节点出发，依次访问图中所有的节点，直到所有节点都被访问过为止。

### 广度优先搜索(BFS)
广度优先搜索算法也称按层搜索，即先访问离源节点最近的节点，再依次往外访问。算法中维护了一个队列，每次取队首节点并将其加入到队列尾部，一直到队列为空时停止。

算法描述：

1. 将源节点s放入队列q中；
2. 从队列中弹出一个节点u，标记u为已访问；
3. 查找u的所有未访问的邻居，将这些邻居放入队列q中；
4. 如果队列q为空，则算法结束，否则转回第三步；

算法时间复杂度：$O(|V|+|E|)$，其中|V|表示图中顶点数量，|E|表示图中边数量。

算法例子：

广度优先搜索用于寻找单源最短路径。假设图G=(V, E)，其中V={1, 2, 3, 4, 5}，E={(1, 2), (1, 4), (2, 3), (2, 4), (3, 2), (3, 5), (4, 1), (4, 3), (4, 5)}。则图的结构如下图所示：

![image-20210701232513336](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210701232513336.png)

要计算节点4到各个节点的最短路径，可以按照以下方式执行广度优先搜索：

```python
def bfs():
    # 初始化
    dist = {v: inf for v in G.vertices()}   # 每个节点距离源点的距离
    prev = {}                                # 源点前驱结点

    q = [s]                                  # 队列初始化，只有源点

    while len(q) > 0:
        u = q.pop()                          # 弹出队首元素
        if u == t:                           # 如果到达终点，跳出循环
            break

        for v in G.adj[u]:                   # 对该元素的邻接顶点做松弛操作
            if not visited[v]:
                dist[v] = min(dist[v], dist[u]+1)    # 更新距离值
                prev[v] = u                       # 更新前驱结点
                q.append(v)                      # 添加进队列
        visited[u] = True                     # 将u标记为已访问

    return dist[t]                           # 返回终点到源点的距离
```

### 深度优先搜索(DFS)
深度优先搜索算法也称递归搜索，即沿着树的深度搜索下去，尽可能深的搜索树的分支。算法中实现了一个递归函数，每次都沿着当前子树的深度探索完后回退，重新选择另一个子树继续探索。

算法描述：

1. 将源节点s放入栈S中；
2. 从栈S中弹出一个节点u，标记u为已访问；
3. 以u为根的子树的左子树和右子树均需访问，因此先访问左子树，然后访问右子树；
4. 如果栈S为空，则算法结束，否则转回第三步；

算法时间复杂度：$O(|V|+|E|)$，其中|V|表示图中顶点数量，|E|表示图中边数量。

算法例子：

深度优先搜索用于判断图中是否有环。假设图G=(V, E)。则图的结构如下图所示：

![image-20210701233527974](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210701233527974.png)

要判断图中是否有环，可以按照以下方式执行深度优先搜索：

```python
def dfs(G):
    def visit(u, parent):
        for v in G.adj[u]:
            if v!= parent and color[v] == white:      # v不是parent的孩子且v还没有访问过
                color[v] = gray                        # 标记v为“灰色”
                stack.push((v, u))                      # 将v压入栈中
                if cycle(v, u):                         # 如果v染色成功，说明有环
                    return true
                else:                                   # 如果v染色失败，回溯
                    stack.pop()
                           ...
    def cycle(u, parent):                            # 判断是否有环
        for v in G.adj[u]:
            if v!= parent and color[v] == gray:       # v不是parent的孩子且v已经访问过
                return false
            elif v!= parent and color[v] == white:     # v不是parent的孩子且v还没有访问过
                color[v] = gray                        # 标记v为“灰色”
                stack.push((v, u))                      # 将v压入栈中
                if cycle(v, u):                         # 如果v染色成功，说明有环
                    return true
                else:                                   # 如果v染色失败，回溯
                    stack.pop()
                   ...

   ...                                                         # 初始化颜色、栈等数据结构

    for i in range(len(color)):                          # 遍历所有节点
        if color[i] == white and not cycle(i, -1):        # 如果节点还没访问过且没有环，返回true
            return true                                      # 有环则返回true
    return false                                               # 没有环则返回false
```

### 分层遍历
分层遍历算法也称按组搜索，即先将图中的节点划分成若干层，然后依次访问每层的节点。算法先对图进行预处理，确定每个节点属于哪一层。之后按照层序遍历的过程进行。

算法描述：

1. 为每个节点赋予一个层号，层号为0表示源点，层号随着树的深度增加而增加；
2. 将源点s的层号设置为0，将其所有的邻居放入队列Q中；
3. 从队列Q中弹出一个节点u，标记u为已访问，并更新其邻居的层号为自身层号+1；
4. 将u的所有邻居放入队列Q中，然后取Q中所有层号最小的节点重复步骤3；
5. 当队列Q为空，则算法结束，否则转回第三步；

算法时间复杂度：$O(|V|+|E|)$，其中|V|表示图中顶点数量，|E|表示图中边数量。

算法例子：

分层遍历算法用于寻找图中最长简单路径。假设图G=(V, E)。则图的结构如下图所示：

![image-20210701234520225](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210701234520225.png)

要计算图G的最长简单路径，可以按照以下方式执行分层遍历：

```python
from queue import PriorityQueue          # 使用优先级队列


def find_longest_path(G):
    n = len(G)                             # 节点个数
    level = [-1]*n                         # 记录每个节点所在的层
    dlevel = []                            # 按层序遍历的结果
    adj = [[] for _ in range(n)]            # 邻接表表示

    # 初始化邻接表
    for i in range(n):
        for j in G[i]:
            adj[i].append(j)

    def layer_bfs(start):                  # 层序遍历
        q = [(0, start)]                    # 队列初始化，插入(0, start)
        while q:
            dis, node = heapq.heappop(q)     # 弹出距离最小的节点
            if dis > maxd:                   # 更新最长距离
                maxd = dis

            if level[node] >= 0 or node in visits:  # 已访问或入队过
                continue

            visits.add(node)                 # 标记为已访问
            for neigh in adj[node]:           # 获取相邻节点
                heapq.heappush(q, (dis+1, neigh))      # 插入队列

                if level[neigh] < 0:             # 没有访问过
                    level[neigh] = level[node]+1   # 设置层号

                    # 如果相邻节点没有访问过，入队
                    if neigh not in visits:
                        heapq.heappush(q, (-1e10, neigh))


    maxd = 0                               # 初始最长距离为0
    visits = set([None])                   # 已访问节点集合初始化为空
    for i in range(n):
        level[i] = -1                      # 初始层号为-1
        visits.discard(i)                   # 标记为未访问

    for i in range(n):
        if level[i] < 0 and i not in visits:
            layer_bfs(i)                    # 执行层序遍历
            dlevel.append(-maxd)            # 把此层最长路径加入结果列表
            maxd = 0                        # 清零最长距离

            # 下一层的节点进入队列
            for j in range(n):
                if level[j] == level[i]-1 and j not in visits:
                    heapq.heappush(q, (-1e10, j))

    del visits                             # 删除已访问集合
    return dlevel[-1]                      # 返回图的最长路径
```

### 宽度优先搜索(WFS)
宽度优先搜索算法也称按宽度搜索，即从源点开始，首先扩展到离源点最近的节点，然后再依次扩展到离其最近的节点。算法和广度优先搜索类似，但是宽度优先搜索是逐列进行的。

算法描述：

1. 将源点s放入队列q0中；
2. 从队列q0中弹出一个节点u，标记u为已访问；
3. 生成新的队列q1，将u的所有未访问的邻居放入q1中，使得q1中节点处于同一列；
4. 如果队列q1为空，则算法结束，否则转回第三步；
5. 重复第2至第4步，直到队列q0为空，结束算法。

算法时间复杂度：$O(|V|+|E|)$，其中|V|表示图中顶点数量，|E|表示图中边数量。

算法例子：

宽度优先搜索算法用于计算最大独立集。假设图G=(V, E)。则图的结构如下图所示：

![image-20210701235440376](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210701235440376.png)

要计算图G的最大独立集，可以按照以下方式执行宽度优先搜索：

```python
import sys

def wfs(G):
    s = next(iter(G))                      # 选取任意一个节点作为源点
    V = list(G)                            # 图中所有节点构成的集合
    adj = [[] for _ in range(len(G))]      # 邻接表表示

    # 初始化邻接表
    for u in G:
        for v in G[u]:
            adj[u].append(v)

    seen = set()                           # 已访问节点集合

    while len(seen) < len(G):               # 只要还没有访问完所有节点，就进行搜索
        Q = [set([s])]                     # 初始化队列，把源点放进去
        visits = set([s])                  # 用set表示已访问节点

        while Q:
            S = Q.pop(0)                   # 弹出队列头部元素
            unvisited = False              # 是否还有未访问的邻居

            for u in S:
                if all(w not in seen for w in adj[u]):
                    unvisited = True         # 有未访问的邻居，继续扩张

            if unvisited:                  # 有未访问的邻居，把它们放进队列
                add = False                # 是否需要添加新元素

                for u in S:
                    for v in adj[u]:
                        if v not in S and v not in visits:
                            add = True

                        if v not in visits:
                            visits.add(v)     # 标记v为已访问

                if add:
                    Q.append(S|{v})           # 添加新元素到队列中

    return sorted(list(G-{s}))              # 输出最大独立集
```

## （3）最小生成树
最小生成树（MST）是指一棵生成树，其中包含图中的所有顶点，且权重之和最小。

### Kruskal算法
Kruskal算法是对最短路径进行改进得到的算法。其过程如下：

1. 将所有边按权重从小到大排序；
2. 建立一个最小生成树，其中包含第一个边；
3. 检查剩余边中，权重最小的那一条是否能够在当前最小生成树上形成环；
4. 如果不能，则把该条边加入最小生成树中；
5. 如果可以，则跳过该条边，检查下一条；
6. 一直检查剩余边，直到所有边都被检查完成，或者找到了一棵生成树；
7. 返回最小生成树。

Kruskal算法的时间复杂度为$O(|E|\log |E|)$。

Kruskal算法例子：

Kruskal算法用于求解最小生成树。假设图G=(V, E)，则图的结构如下图所示：

![image-20210702100151879](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210702100151879.png)

要计算图G的最小生成树，可以按照以下方式执行Kruskal算法：

```python
def kruskal(G):
    edges = sorted([(u, v, weight(u, v)) for u in G for v in G[u]], key=lambda e: e[2])  # 按权重排序的边

    mst = Set()                                                                   # MST的集合
    dsu = DSU(len(G))                                                             # 用于判断是否形成环
    res = 0                                                                       # MST的权重

    for edge in edges:                                                            # 遍历所有边
        if not dsu.find(edge[0], edge[1]):                                       # 不形成环，把边加进MST
            mst |= {(edge[0], edge[1])}
            dsu.union(edge[0], edge[1])
            res += edge[2]                                                        # 加权重

    return mst, res                                                               # 返回MST和权重
```

### Prim算法
Prim算法也是一种寻找最小生成树的方法。其过程如下：

1. 任选一个节点作为起始点，在邻接表中建立一个优先级队列，将起始点及其邻居的边放入队列；
2. 从队列中提取权重最小的边，如果该边所结的边的另一端节点未被发现，则将该节点放入已发现集合，并将该边所结的边的另一端节点放入最小生成树中，同时将该节点的邻居的边放入优先级队列；
3. 一直重复第二步，直到找到所有节点，或者优先级队列为空；
4. 返回最小生成树。

Prim算法的时间复杂度为$O(|V|\log |V|)$。

Prim算法例子：

Prim算法用于求解最小生成树。假设图G=(V, E)，则图的结构如下图所示：

![image-20210702100651670](https://gitee.com/yunyangzhang/picture_bed/raw/master/img/image-20210702100651670.png)

要计算图G的最小生成树，可以按照以下方式执行Prim算法：

```python
from collections import defaultdict
import heapq

def prim(G):
    def heuristic(u, v):                                                           # 启发函数，即代价估计
        dx = abs(pos[u][0] - pos[v][0])
        dy = abs(pos[u][1] - pos[v][1])
        return math.sqrt(dx**2 + dy**2)                                            # 曼哈顿距离

    def relax(u, v):                                                              # 松弛操作
        if dist[v] > dist[u] + weight(u, v):
            dist[v] = dist[u] + weight(u, v)
            heapq.heappush(heap, (dist[v] + heuristic(v, sink), v))              # 更新sink到v的距离

    # 初始化
    source = random.choice(list(G))                                              # 随机选择起始点
    dist = defaultdict(lambda: float('inf'))                                       # 节点到源点的最短距离
    dist[source] = 0                                                              # 源点到自身的距离为0
    heap = [(weight(source, v) + heuristic(source, v), v) for v in G[source]]      # 初始化优先队列

    # Dijkstra算法
    while heap:                                                                   # 优先队列非空
        cost, u = heapq.heappop(heap)                                             # 弹出最小cost和对应的u
        if u in seen:                                                             # 当前节点已访问过
            continue

        seen.add(u)                                                                # 标记为已访问
        relax(source, u)                                                          # 更新距离信息

        for v in G[u]:                                                            # 对u的邻居进行松弛操作
            if v not in seen:                                                      # v未访问过
                relax(u, v)

    return dist                                                                   # 返回各节点到源点的距离

def find_mst(G):
    """
    :param G: a graph represented as an adjacency dictionary
    :return: a minimum spanning tree of the given graph using Prim algorithm
    """
    pos = nx.get_node_attributes(nx.Graph(G), 'pos')                              # 节点坐标
    weight = lambda u, v: 1                                                       # 边的权重

    subtrees = []                                                                 # 产生的子树集合
    for component in nx.connected_components(nx.Graph(G)):                         # 枚举连通块
        subtree = prim({k: dict(filter(lambda x: x[0] in component, G[k])) for k in component})
        subtrees.append(subtree)                                                  # 子树加入集合

    mst = []                                                                      # MST集合
    for subtree in subtrees:                                                      # 对所有子树进行合并
        for u, distance in subtree.items():
            for v, alt in subtree.items():
                if distance + alt < subtree[v]:                                    # 松弛操作
                    subtree[v] = distance + alt                                    # 更新距离信息

        for u in subtree:
            if u in mst:
                continue
            for v in subtree:
                if u!= v and subtree[u] + subtree[v] <= sum(subtree.values()) / 2:
                    mst.append((u, v))

    return mst                                                                    # 返回MST集合
```

