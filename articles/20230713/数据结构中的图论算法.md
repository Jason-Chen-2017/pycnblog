
作者：禅与计算机程序设计艺术                    
                
                
## 数据结构介绍
“图”是一种数据结构，它由结点（node）和边（edge）组成。图在计算机科学领域占有重要地位，用于表示复杂网络结构、物流网络等复杂的数据对象。图中各个结点间通过边相互连接，具有无向性和多重性。如，电路图、计算机网络图、人际关系图等。由于图的灵活性和广泛应用，使得图成为许多领域研究的基础。在某些问题中，图也是一种有效的数据结构。例如，在图算法中，邻接矩阵和邻接表是两种最基础的存储方法；搜索与图论方面，Dijkstra算法就是依赖于图这种数据结构的。本文将介绍几个基本的图算法。
## 为什么需要图？
现实世界存在着很多的图，比如城市交通网络、产销平衡网络、社交网络、金融网络等。这些图形结构之间存在着各种联系和相互作用，并且动态变化不断发生。如何快速高效地处理这些图形数据，成为当前算法工程师和软件工程师非常需要的技能之一。今天，介绍几种常用的图算法，希望能够帮助大家更好地理解和运用图论。
# 2.基本概念术语说明
## 图的定义
一个图G=(V,E)是一个带权或不带权的无向或有向图，其中：
- V(G)为G的顶点集合，顶点可以看做图的节点或者点。
- E(G)为G的边集，一条边(u,v)∈E(G)，表示顶点u和顶点v之间的连线，连接顶点u到顶点v。
- w:E(G)->R, (u,v)∈E(G),w(u,v)=w为有向图的权值，反映了从顶点u到顶点v的一条边所承载的信息。如果图是无向的，则把w(u,v)=w(v,u)。

## 图的相关术语
### 有向图/无向图
在有向图中，任意两个顶点之间都存在一条路径，同时还确定了方向。而无向图中的任意两个顶点之间仅存在一条路径。

### 简单图/多重图
简单图中不存在自循环、平行边及平行的回路。反之，多重图允许多个边（或弧）连接同一对顶点，或同一条边连接不同顶点。

### 加权图/非加权图
加权图即每条边有一个权值。对于有向图来说，权值的大小可以用来描述边的趋势、方向，也可以用来描述边的紧迫程度。而非加权图即没有边的权值。

### 完全图
完全图是指所有顶点都与其他所有顶点都连通。

### 子图
子图是指一个图的非空真子集。

## 图的存储结构
图的存储结构是指如何用计算机中的数据结构来表示图。常用的图的存储结构有三种：
- 邻接矩阵：邻接矩阵用一个二维数组表示图。元素a[i][j]表示顶点Vi和顶点Vj之间是否存在边，当且仅当边(Vi,Vj)∈E(G)时，a[i][j]=1。
- 邻接表：邻接表用一个数组存储每个顶点的所有出边。数组下标表示顶点编号，每个元素是一个链表，存放该顶点的出边。
- 十字链表：十字链表是邻接表的一个变体。它把边按照两端点的顺序分成四类：第一类是起始顶点的出边，第二类是终止顶点的入边，第三类是介于两者之间的边（异向边），第四类是介于起始顶点和终止顶点之间的边（回路）。因此，在十字链表结构中，我们不需要分别存储第一类和第二类的边，只需一次遍历就能找到所有边。

以上介绍的都是图的存储结构。下面我们介绍几种常用的图算法。
# 3.核心算法原理和具体操作步骤以及数学公式讲解
## 稠密图
### Breadth First Search（BFS）算法
BFS是一种图搜索算法，它首先访问根节点，然后依次扩展出来的节点，继续进行扩展，直到访问完所有的节点。它的主要操作包括：
- 用队列queue来实现节点的扩展过程。
- 每访问一个新节点的时候，我们都记录一下这个节点的距离dist(s)=0，因为我们已经到达了源节点s。
- 当某个节点被访问完之后，其邻居节点便进入队列。
- 在访问到某节点之后，我们判断是否已经到达目标节点t。若到达则停止。否则继续扩展，重复上述步骤。
- 通过记录节点的距离来判别有向图的最短路径。
BFS算法的时间复杂度是O(|V|+|E|)。


### Depth First Search（DFS）算法
DFS算法与BFS类似，只是它优先选取深度优先遍历。DFS算法通过递归的方式访问所有节点，并沿着邻接边继续往前走，直到不能继续往前走为止。它的主要操作如下：
- 对每个顶点调用函数visit()，函数的参数为当前顶点。
- 如果某个顶点v没有发现（visited）过，那么调用函数visit(v)，并标记v已被发现。
- 对v的每个邻接顶点w，递归调用函数visit(w)。
- 返回到达源点之前，每个顶点都要经过一次DFS。DFS算法的时间复杂度是O(|V|+|E|)。


## 稀疏图
### Kruskal（克鲁斯卡尔）算法
Kruskal算法是一种最小生成树算法。给定一个带权无向图G，它选择权值最小的边加入生成树T，直到生成树T的边数等于图G的总边数-1。也就是说，最终得到的生成树T中没有回路，而且它所含有的边也不违反图G的限制。
Kruskal算法的步骤如下：
- 创建一个堆，用边的权值作为key排序，保证权值小的边先被弹出。
- 从堆中弹出权值最小的边e=(u,v)，并检查这条边是否导致生成树T出现了回路。如果没有回路，则把边e加入生成树T。否则忽略这条边。
- 重复步骤2，直至生成树T的边数等于图G的总边数-1。
Kruskal算法的时间复杂度是O(|E|+|E log |E|)，是prim算法的改进版本。

### Prim（普里姆）算法
Prim算法也是一种最小生成树算法。它以某个节点s为起始点，构造一个包含s的最小生成树T，每一步都在T上选取权值最小的边并加入。直到T中含有n-1条边，即生成树中的边数等于图的总边数减一。
Prim算法的步骤如下：
- 初始化，用集合S={s}和堆H={(s,w(s,u))},其中w(s,u)为边(s,u)的权值。
- 把所有从s可达的节点u添加到集合S中，并更新它们的权值{h'|(s',u')∈H,s'∈S}=min({h'|(s',u')∈H,s'∈S})+w(s,u)。
- 把u从集合S中移除，并把它的所有邻接节点v加入集合S，并更新它们的权值{h'|(s',v')∈H,s'∈S}=min({h'|(s',v')∈H,s'∈S})+w(u,v)。
- 重复步骤2，直至S包含n个节点。
- 将S中的每个顶点对应的边加入生成树T。
Prim算法的时间复杂度是O(|E|+|V|log|V|)。

