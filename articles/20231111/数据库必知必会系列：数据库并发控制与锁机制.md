                 

# 1.背景介绍


## 一、数据库并发控制概述
在现代商业应用系统中，绝大多数系统都需要频繁地读取或修改数据。而对于一个数据的读写操作，数据库系统必须保证完整性和一致性。为了实现数据一致性，数据库系统通常采用了串行化调度（串行化）或可串行化调度（可串行化）的方法对事务进行序列化。具体来说，就是将多个用户事务按照固定顺序排队执行。通过这种方式，可以确保数据库系统从整体上保持数据的正确性和完整性。当同时有多个事务并发访问同一资源时，就可能出现以下几种情况：

 - Dirty Read(脏读)：事务A读取了已被其他事务B更新的数据，而此前B事务没有提交，导致A读到的是一个脏数据；
 - Non-Repeatable Read(不可重复读)：事务A在读取某条记录后，另外一个事务B也更新或删除了该记录，但是A无法确定B是否修改了这个记录，导致A读到的结果不一致；
 - Phantom Read(幻影读)：事务A由于前一次查询条件不准确，得到了幻觉结果，比如之前没有这个人，但是之后插入了一个人，所以A读取到了多余的结果；

这三类问题分别对应于三个不同的问题：
 - 脏读问题是指一个事务读取了另一个事务还未提交的数据；
 - 不可重复读问题是指一个事务在两次读取某个范围内的数据期间，后续的一个事务又对该范围内的数据进行了修改；
 - 幻影读问题是指一个事务在第一次查询时，总是能看到由另外一个事务按时间先后顺序插入的数据。

为了解决这些并发控制问题，数据库系统通常采用下列策略之一：

 - 排他锁（Exclusive Locks）：在对某个数据项加锁的时候，只允许对这个数据项进行独占访问，其他事务必须等待当前事务完成后才能访问该数据项；
 - 悲观锁（Pessimistic Locking）：即假设事务会发生冲突，因此每次访问数据时都会加上共享锁或排它锁；
 - 乐观锁（Optimistic Locking）：假定一个事务不会发生冲突，在提交事务时检测是否有其他事务修改了相同的数据，如果有则回滚该事务。

由于各个厂商的数据库产品实现方式和特点不同，数据库并发控制的方法也千差万别。本文将介绍当前主流数据库产品中的一种并发控制方法，即基于索引的并发控制方法。
## 二、基于索引的并发控制方法
### （一）概念
基于索引的并发控制方法基本上是利用索引来管理事务之间的相互作用，使得不同的事务在访问某个表中的相同数据时，只能看到该表中满足其索引条件的数据。这样就可以防止脏读、不可重复读和幻影读等并发控制问题。 

为了实现基于索引的并发控制，数据库系统会把数据库表按照主键索引建立索引树。在某个事务开始之前，会向系统申请一个排它锁（X Lock）或共享锁（S Lock）。如果一个事务申请了排它锁（X Lock），那么其它任何事务都不能获得此锁直至该事务释放锁。而如果一个事务申请了共享锁（S Lock），则其他事务只能获得该锁，但不能独占该锁，只能对当前读（快照读）数据。

### （二）两种类型的锁
在索引并发控制方法中，存在两种类型的锁：排它锁（X Lock）和共享锁（S Lock）。

1. 排它锁（Exclusive Locks）
   - 当事务取得排它锁时，它将阻止其它事务取得相同索引上的共享或排他锁，但不阻止其它事务取得不同的索引上的共享或排他锁；
   - 当事务释放排它锁时，它能够释放任何与该索引相关的排他锁，包括本身所拥有的排它锁；
   - 如果事务T1已经锁住了索引i上的某条记录r，而T2要申请锁定该记录，则只有T1释放了该索引上的排他锁后，T2才能成功申请锁定；
   - 有时我们也称排它锁为写锁（Write Lock）。

2. 共享锁（Shared Locks）
   - 在事务取得共享锁时，它只阻止其它事务取得相同索引上的排他锁，但不阻止其它事务取得不同的索引上的排他锁；
   - 当事务释放共享锁时，它不释放任何与该索引相关的排他锁，仅仅是将共享锁转换成排它锁；
   - 如果事务T1已经锁住了索引i上的某条记录r，而T2要申请锁定该记录，则T2无需等待T1释放索引i上的任何锁，即可立即申请锁定；
   - 有时我们也称共享锁为读锁（Read Lock）。

例如，对于一个商品库存表，我们可以使用主键（ID）列作为索引。假设商品ID为1001的商品当前库存量为9，如果有两个事务同时购买商品ID为1001的商品，那么在第一阶段，第一个事务开始时会申请X Lock，并将该商品数量减少为8，第二个事务开始时会申请X Lock失败，因为第一个事务仍然持有X Lock；在第二阶段，第一个事务提交，第二个事务才开始并申请X Lock，并将该商品数量减少为7。

### （三）Lock List维护
数据库系统为每个事务分配了一张Lock List，用于存储本事务对每张表中涉及的索引的锁信息。其中每一条记录包含一张表名、一个索引名和一个锁类型（排它锁或共享锁），表示该事务在这张表上对该索引上所持有的锁。

### （四）锁冲突
在数据库系统中，不同的锁之间可能产生冲突。根据锁的兼容关系和模式，可能会导致死锁、饥饿、不可预测性等问题。

1. 死锁（Deadlock）：两个或者更多事务在同一资源竞争时，形成死锁，一直相互等待对方的锁释放，导致系统长时间阻塞；

2. 饥饿（Starvation）：当线程或进程因持有锁长时间得不到资源而进入“饱和”状态，从而导致系统资源耗尽；

3. 可抢占（Preemptive）：当一个事务持有锁时，如果另一个事务试图同时申请该锁，而该事务正在运行，则新申请的事务会被抢占，从而导致死锁；

4. 不可抢占（Non-preemptive）：当一个事务持有锁时，另一个事务只能等候，不能强制性地抢占；

5. 长事务（Long Transaction）：为了避免锁超时，一些数据库系统设置了较短的时间限制（例如30秒），超过这个时间限制的事务就会被标记为长事务，然后系统自动释放长事务持有的锁；

基于索引的并发控制方法主要是为了防止以上各种并发控制问题。