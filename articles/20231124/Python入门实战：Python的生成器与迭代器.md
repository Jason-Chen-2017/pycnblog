                 

# 1.背景介绍


## 生成器（Generator）
生成器函数与普通函数最大的不同之处在于，生成器函数不会把整个结果都创建到内存中，而是在每次需要的时候才生成数据，节省了空间，而且只能用于迭代访问一次。  

```python
def my_range(n):
    for i in range(n):
        yield i*i

my_gen = my_range(5)
print(next(my_gen)) # 0
print(next(my_gen)) # 1
print(list(my_gen)) #[0, 1]
```

上述例子中的`my_range()`函数是一个生成器函数，通过`yield`关键字将每个数字的平方生成出来。调用该函数并赋值给变量`my_gen`，然后使用`next()`方法获取第一个生成的值，接着使用`next()`方法获取第二个生成的值，最后使用`list()`方法将生成器转换成列表。  

另一种使用生成器的方式是使用列表推导式，创建一个新的列表，其中包含所有生成器的元素。例如：  

```python
lst = [x*x for x in my_range(5)]
print(lst) #[0, 1, 4, 9, 16]
```

这里，首先调用`my_range()`函数，得到一个生成器对象。然后使用列表推导式，根据生成器对象中每一个值的平方，创建一个包含这些值的新列表。由于列表的大小受限于生成器对象，因此不必担心内存超出限制的问题。

## 迭代器（Iterator）
迭代器是一个带有`__iter__()`和`__next__()`方法的对象，该对象能够遍历容器（如列表、字典等）或其他可迭代对象的元素，依次访问其中的元素。如果容器中没有元素可以访问时，则会引发一个`StopIteration`异常，通知迭代器停止遍历。

```python
for item in lst:
    print(item)
```

上面的代码展示了一个如何遍历列表的例子。我们不需要自己实现`__iter__()`和`__next__()`, 只要能够获得一个迭代器即可。通常情况下，可以通过使用内置的`iter()`函数将一个可迭代对象转换为迭代器。

```python
my_iterator = iter(lst)
while True:
    try:
        item = next(my_iterator)
        print(item)
    except StopIteration:
        break
```

上述代码展示了一个更加复杂的情况。我们首先通过`iter()`函数将列表转换为迭代器。然后通过`next()`函数获取该迭代器中的第一个元素，并打印它。当再次调用`next()`函数时，如果遇到`StopIteration`异常，就会结束循环。

# 2.核心概念与联系
## 生成器与迭代器
生成器和迭代器是Python中两种不同但相互关联的概念。生成器是Python提供的另一种迭代器类型，但是比一般的迭代器更为特殊。它不保存状态，只存储状态机相关的信息。也就是说，在每一次迭代中，它都会从头重新计算结果，而不是从上次离开的地方继续。这使得它比一般的迭代器更易于控制，更适合处理那些大数据集或者需要长时间运行的任务。

迭代器协议是指通过定义两个方法来创建的可迭代对象。这两个方法分别是`__iter__()`和`__next__()`。它们的作用如下：

1. `__iter__(self)` 方法应该返回一个迭代器对象，这是该对象的构造函数。
2. `__next__(self)` 方法应当返回迭代器的下一个元素，或引发`StopIteration`异常，表示迭代已完成。

迭代器还可以用来延迟执行，这意味着只有在真正需要时才计算值。在某些场景下，我们可能仅仅需要某个值的第一次计算结果，之后我们就不需要它了。因此，我们可以使用迭代器模式来提升程序的性能。

## 创建自己的迭代器
要创建自己的迭代器，只需定义两个方法：`__iter__()` 和 ` __next__()`。`__iter__()` 方法返回迭代器本身；`__next__()` 方法负责返回序列的下一个元素，并在序列耗尽后引发 `StopIteration` 异常。以下是一个简单的迭代器的示例：

```python
class Countdown:
    def __init__(self, n):
        self.n = n
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.n < 1:
            raise StopIteration
        
        r = self.n
        self.n -= 1
        
        return r
        
c = Countdown(5)
for num in c:
    print(num)
```

输出：  
```
5
4
3
2
1
```