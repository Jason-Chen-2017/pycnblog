                 

### 前端基础知识点

#### 1. 什么是事件循环？请简要介绍事件循环的工作原理。

**答案：** 事件循环是JavaScript中的一个核心概念，它是负责处理事件和执行代码的机制。事件循环的工作原理如下：

1. 执行栈：事件循环首先检查执行栈，如果栈中有可以执行的代码，就执行这些代码。
2. 就绪队列：如果执行栈为空，事件循环会检查就绪队列，这个队列包含了所有待执行的异步任务。
3. 任务分配：事件循环从就绪队列中取出一个任务，并将其放入执行栈中执行。
4. 回收：当任务完成执行后，它会被移出执行栈，并且如果有必要，事件循环会将其放入微任务队列（microtask queue）。
5. 渲染：当事件循环执行完毕，如果没有需要执行的宏任务（macrotasks），浏览器将进行渲染。

#### 2. 介绍前端中的盒模型。

**答案：** 前端中的盒模型是指HTML元素在网页中所占据的空间，由以下几个部分组成：

1. 内容宽度（Content Width）：元素内部实际内容的宽度。
2. 内容高度（Content Height）：元素内部实际内容的高度。
3. 填充宽度（Padding Width）：元素内容周围的内边距。
4. 填充高度（Padding Height）：元素内容周围的上下内边距。
5. 边框宽度（Border Width）：元素边框的宽度。
6. 边框高度（Border Height）：元素边框的高度。

盒模型的计算方式分为两种：

1. 标准盒模型：宽度 = 内容宽度 + 左填充 + 右填充，高度 = 内容高度 + 顶部填充 + 底部填充。
2. IE 盒模型：宽度 = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框，高度 = 内容高度 + 顶部填充 + 底部填充 + 顶部边框 + 底部边框。

#### 3. 请解释一下BFC（块级格式化上下文）的概念。

**答案：** BFC（Block Formatting Context）是指块级格式化上下文，它是CSS布局中的一个概念。当满足以下条件时，元素会创建一个BFC：

1. 根元素；
2. 浮动元素（float不是none）；
3. 绝对定位元素（position为absolute或fixed）；
4. overflow值为auto或hidden的元素；
5. display值为flow-root的元素；
6. display值为inline-block、table-cell、table-caption或flex容器的元素。

BFC有以下特性：

1. 内部的盒模型会在垂直方向一个接一个地放置；
2. BFC区域的内部元素不会影响外部元素的布局；
3. BFC可以阻止浮动元素造成父元素的高度塌陷。

#### 4. 解释一下什么是跨域资源共享（CORS）。

**答案：** 跨域资源共享（CORS）是一种安全策略，它允许限制资源（如网页）从不同源进行访问。CORS通过HTTP头部中的访问控制策略来控制跨源请求。

CORS的主要组成部分如下：

1. **简单请求：** 请求方法为GET、POST或HEAD，且只使用以下HTTP头部字段：Accept、Accept-Language、Content-Language、Content-Type。
2. **预检请求：** 对于不符合简单请求条件的请求，浏览器会先发送一个预检请求（OPTIONS），询问服务器是否允许实际的请求。
3. **响应头部：** 服务器需要在响应中包含特定的头部字段，如`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`和`Access-Control-Allow-Headers`等。

#### 5. 什么是响应式网页设计（Responsive Web Design）？请简要介绍其原理。

**答案：** 响应式网页设计（Responsive Web Design，简称RWD）是一种设计网页的方法，使得网页在不同设备和屏幕尺寸上都能够良好地展示。其原理主要包括以下几个方面：

1. 媒体查询（Media Queries）：通过CSS媒体查询，根据设备的宽度和高度等属性来应用不同的样式规则。
2. 流体布局（Fluid Layout）：使用百分比而不是固定像素值来定义元素的宽度和高度，以适应不同的屏幕尺寸。
3. 弹性图片（Responsive Images）：使用CSS或JavaScript来调整图片的大小，使其在不同设备上都有最佳展示效果。
4. 可伸缩矢量图形（SVG）：使用SVG代替像素密集的图片，以便在不同的设备上保持清晰度。

通过这些方法，响应式网页设计可以确保网页在不同设备上提供一致的用户体验。

### 常见前端面试题

#### 6. 描述事件冒泡和事件捕获的流程。

**答案：** 事件冒泡（Bubble Phase）和事件捕获（Capture Phase）是事件传播的两种阶段。它们的流程如下：

1. 事件捕获：从DOM树的根节点开始，向下传递到目标元素。
2. 事件目标：目标元素接收到事件，并执行相应的事件处理函数。
3. 事件冒泡：从目标元素开始，向上传递到DOM树的根节点。

在事件冒泡阶段，事件处理器的执行顺序是：捕获阶段 > 目标元素 > 冒泡阶段。这意味着事件会在捕获阶段触发，然后在目标元素上触发，最后在冒泡阶段再次触发。

#### 7. 如何处理跨域请求？

**答案：** 处理跨域请求通常有以下几种方法：

1. **CORS（跨域资源共享）：** 通过在服务器端设置特定的HTTP头部，允许或拒绝跨源请求。这通常涉及到`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`和`Access-Control-Allow-Headers`等头部字段。
2. **代理服务器：** 使用代理服务器转发跨域请求，从而绕过浏览器的同源策略。
3. **JSONP：** 利用`<script>`标签的跨域特性，通过动态添加`<script>`标签来发送跨域请求。这种方法只能用于GET请求。

#### 8. 解释一下JavaScript中的闭包。

**答案：** 闭包（Closure）是JavaScript中的一个重要概念，它是指一个函数及其访问的外部作用域的集合。闭包的形成通常有以下两种情况：

1. 函数内部引用了外部作用域的变量。
2. 函数被作为返回值返回。

闭包的特点如下：

1. 可以访问并操作其定义时的作用域链中的变量。
2. 即使外部函数已经执行完毕，闭包仍然可以保持其访问的作用域链。

闭包的应用场景包括：

1. 高阶函数：返回一个函数的函数，闭包可以用来保留函数的上下文状态。
2. 隐藏实现细节：通过闭包，可以隐藏函数的实现细节，仅暴露必要的接口。

#### 9. 什么是Promise？请简述其作用。

**答案：** Promise是JavaScript中的一个用于处理异步操作的标准化抽象对象。它表示一个可能还没有完成，但是将来会完成的操作。Promise的作用如下：

1. **处理异步操作：** Promise可以用于处理异步操作，如网络请求、定时器等，使得代码更加简洁和易于管理。
2. **链式调用：** Promise提供了`.then()`和`.catch()`方法，可以方便地链式调用多个异步操作，从而实现异步流程的控制。
3. **错误处理：** Promise的`.catch()`方法可以用于捕获和处理异步操作中的错误，避免了传统的错误处理方式的“回调地狱”。

#### 10. 解释一下React组件的生命周期。

**答案：** React组件的生命周期是指组件从创建到销毁的整个过程。React组件的生命周期主要包括以下几个阶段：

1. **挂载（Mounting）：** 组件创建的过程，包括初始化状态、挂载DOM元素等。
   - `componentWillMount`：组件即将挂载，但在服务器端渲染时不会被调用。
   - `componentDidMount`：组件已经挂载到DOM树上，可以在此阶段获取外部数据并执行副作用操作。

2. **更新（Updating）：** 当组件的属性或状态发生变化时，组件会重新渲染。
   - `componentWillReceiveProps`：组件接收到新的属性时，但在更新之前。
   - `shouldComponentUpdate`：组件在接收到新的属性或状态时，决定是否进行渲染。
   - `componentWillUpdate`：组件在更新之前，但DOM元素还未更新。
   - `componentDidUpdate`：组件已经更新并完成渲染。

3. **卸载（Unmounting）：** 当组件从DOM树上移除时，会触发卸载过程。
   - `componentWillUnmount`：组件即将从DOM树上卸载。

通过掌握组件的生命周期，可以更好地控制组件的行为，优化性能并管理外部资源。

#### 11. 请解释React中的虚拟DOM和其作用。

**答案：** 虚拟DOM（Virtual DOM）是React中用于优化性能的一个重要概念。它是一个轻量级的对象表示DOM结构，通过对比虚拟DOM和实际DOM的差异，React可以高效地更新DOM。

虚拟DOM的作用如下：

1. **减少DOM操作：** 通过使用虚拟DOM，React可以在不直接操作实际DOM的情况下更新UI，从而减少DOM操作的次数，提高性能。
2. **批量更新：** React将所有状态更新合并成一次渲染操作，避免了不必要的DOM操作。
3. **组件复用：** 通过虚拟DOM，React可以更容易地实现组件的复用和重渲染。

#### 12. 如何优化React应用程序的性能？

**答案：** 优化React应用程序的性能可以从以下几个方面进行：

1. **使用PureComponent：** 使用`PureComponent`代替`Component`，通过浅比较属性和状态来减少不必要的渲染。
2. **shouldComponentUpdate：** 在组件中重写`shouldComponentUpdate`方法，根据具体需求决定是否进行渲染。
3. **React.memo：** 使用`React.memo`包装组件，通过比较属性来减少不必要的渲染。
4. **使用React.lazy和Suspense：** 对于大型组件或路由，使用`React.lazy`和`Suspense`可以实现懒加载，减少初始加载时间。
5. **使用async/await和setTimeout：** 使用async/await和setTimeout可以避免回调地狱，提高代码的可读性和可维护性。
6. **减少组件嵌套：** 减少组件的嵌套层次，提高组件的复用性和可维护性。
7. **避免使用inline styles：** 避免使用inline styles，而是使用CSS-in-JS库或CSS Modules，以提高性能和可维护性。

通过这些方法，可以有效地优化React应用程序的性能，提供更好的用户体验。

### 常见前端算法编程题

#### 13. 如何实现一个简单的排序算法？

**答案：** 下面是实现一个简单的冒泡排序算法的示例：

```javascript
function bubbleSort(arr) {
    const n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}
```

**解析：** 冒泡排序算法通过多次遍历数组，比较相邻元素并交换它们，使得较大的元素逐渐“冒泡”到数组的末尾，最终实现数组的排序。

#### 14. 如何实现一个二分查找算法？

**答案：** 下面是实现一个简单的二分查找算法的示例：

```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}
```

**解析：** 二分查找算法通过将数组划分为两部分，根据目标值与中间元素的比较，逐步缩小查找范围，直到找到目标值或确定目标值不存在。

#### 15. 实现一个函数，判断一个字符串是否是回文。

**答案：** 下面是实现一个简单判断字符串是否为回文的函数：

```javascript
function isPalindrome(str) {
    const reversedStr = str.split('').reverse().join('');
    return str === reversedStr;
}
```

**解析：** 该函数通过将字符串反转并比较原字符串与反转后的字符串是否相等，来判断字符串是否为回文。

### 前端工程化

#### 16. 什么是Webpack？请简要介绍Webpack的工作流程。

**答案：** Webpack是一个现代JavaScript应用程序的静态模块打包器，它将多个模块打包成一个或多个bundle。Webpack的工作流程如下：

1. **入口（Entry）：** 指定Webpack需要解析和打包的文件入口。
2. **加载器（Loaders）：** 用于处理各种类型的文件，如CSS、图片、HTML等。Webpack本身只理解JavaScript。
3. **插件（Plugins）：** 扩展Webpack功能，例如压缩代码、生成文件等。
4. **输出（Output）：** 指定打包后文件的输出目录和文件名。
5. **模式（Mode）：** 指定Webpack构建模式，如开发模式、生产模式等。

#### 17. 如何优化Webpack打包速度？

**答案：** 优化Webpack打包速度可以从以下几个方面进行：

1. **减少文件数量：** 优化入口文件，删除不需要的模块和文件。
2. **使用缓存：** 启用Webpack的缓存功能，如Babel和TypeScript的缓存。
3. **并行处理：** 使用`thread-loader`等插件并行处理模块。
4. **分割代码：** 使用`SplitChunksPlugin`将公共代码拆分为单独的bundle。
5. **延迟加载：** 使用`React.lazy`和`Suspense`实现动态导入，减少初始加载时间。
6. **使用外部扩展：** 引入外部库（如lodash、moment等）时使用`externals`插件，避免打包这些大文件。

#### 18. 请解释一下Babel的作用和原理。

**答案：** Babel是一个用于转换JavaScript代码的工具，它可以将ES6及更高版本的代码转换为兼容现代浏览器的代码。Babel的作用和原理如下：

1. **作用：** Babel负责将最新的JavaScript代码转换为向后兼容的版本，以便在当前的浏览器环境中运行。
2. **原理：** Babel的工作流程主要包括以下几个步骤：
   - **解析（Parsing）：** 将源代码解析为抽象语法树（AST）。
   - **转换（Transforming）：** 对AST进行一系列的转换操作，如语法糖转换、类型转换等。
   - **生成（Code Generation）：** 将转换后的AST生成新的JavaScript代码。

通过这些步骤，Babel可以实现对最新JavaScript特性的兼容性处理。

### 前端安全

#### 19. 什么是跨站脚本攻击（XSS）？请简述其原理和防范方法。

**答案：** 跨站脚本攻击（Cross-Site Scripting，简称XSS）是一种常见的Web安全漏洞，攻击者通过在目标网站上注入恶意脚本，欺骗用户的浏览器执行这些脚本。XSS的原理和防范方法如下：

1. **原理：** 攻击者通过在目标网站上注入恶意脚本，使得这些脚本在用户的浏览器中执行。恶意脚本通常用于盗取用户信息、篡改页面内容等。
2. **防范方法：**
   - **输入验证：** 在服务器端对用户输入进行严格验证，确保输入符合预期格式，避免注入恶意脚本。
   - **输出编码：** 对用户输出的数据进行编码，防止恶意脚本在浏览器中被执行。
   - **内容安全策略（CSP）：** 使用CSP（Content Security Policy）限制资源的加载来源，减少XSS攻击的风险。

#### 20. 什么是跨站请求伪造（CSRF）？请简述其原理和防范方法。

**答案：** 跨站请求伪造（Cross-Site Request Forgery，简称CSRF）是一种攻击手段，攻击者通过伪造用户的请求，使得用户在不知情的情况下执行恶意操作。CSRF的原理和防范方法如下：

1. **原理：** 攻击者通过在恶意网站上放置一个恶意链接或图片，诱导用户点击，从而在用户的浏览器中执行恶意请求。
2. **防范方法：**
   - **验证码：** 在敏感操作前，要求用户输入验证码，确保用户是主动执行操作。
   - **Token验证：** 在每次请求中包含一个Token，服务器端验证Token的合法性，确保请求是用户主动发起的。
   - **Referer验证：** 检查请求的Referer头部信息，确保请求来自合法的网站。

通过这些方法，可以有效地防范CSRF攻击。### 前端性能优化

#### 21. 什么是首屏加载时间？请简述影响首屏加载时间的因素和优化方法。

**答案：** 首屏加载时间（First Contentful Paint，FCP）是指从用户打开页面到页面内容开始显示的时间。影响首屏加载时间的因素主要包括：

1. **资源大小：** 页面中包含的CSS、JavaScript、图片等资源大小会影响加载时间。
2. **网络延迟：** 用户与服务器之间的网络连接速度会影响加载时间。
3. **资源加载顺序：** 资源加载的顺序会影响首屏加载时间。

优化首屏加载时间的方法如下：

1. **代码分割（Code Splitting）：** 将代码分割成多个chunks，按需加载，减少初始加载时间。
2. **懒加载（Lazy Loading）：** 对于非首屏的内容，采用懒加载技术，延迟加载，减少页面初始加载时间。
3. **静态资源压缩：** 使用Gzip压缩CSS和JavaScript文件，减少文件大小。
4. **预渲染（Pre-rendering）：** 对于静态页面，可以使用预渲染技术，提前生成HTML，提高首屏加载速度。
5. **HTTP/2：** 使用HTTP/2协议，提高资源加载速度。

#### 22. 什么是性能预算（Performance Budget）？请简述其制定方法和应用场景。

**答案：** 性能预算（Performance Budget）是指为网站或应用设定一组性能指标，以确保用户体验的一致性和质量。制定性能预算的方法如下：

1. **确定关键性能指标（Key Performance Indicators，KPI）：** 例如首屏加载时间、页面响应时间等。
2. **设置目标值：** 根据用户体验和业务需求，设定每个KPI的目标值。
3. **分析当前性能：** 使用性能分析工具（如Lighthouse）分析当前性能指标，了解优化的方向。
4. **制定优化策略：** 根据分析结果，制定优化策略，如代码分割、静态资源压缩等。

应用场景包括：

1. **新功能发布：** 在发布新功能前，确保性能指标符合预算要求。
2. **性能监控：** 定期监控性能指标，确保网站或应用始终在预算范围内。

通过制定和遵循性能预算，可以确保网站或应用提供良好的用户体验。

#### 23. 什么是渲染阻塞资源？请简述其影响和优化方法。

**答案：** 渲染阻塞资源是指在加载和渲染页面时，会阻止浏览器渲染页面的资源。常见的渲染阻塞资源包括：

1. **JavaScript文件：** JavaScript文件阻塞DOM解析和渲染，直到JavaScript文件加载并执行完毕。
2. **CSS文件：** CSS文件阻塞DOM渲染，直到CSS文件加载并应用。

渲染阻塞资源的影响包括：

1. **延迟页面内容显示：** 浏览器无法渲染页面内容，直到所有渲染阻塞资源加载完毕。
2. **影响页面加载速度：** 阻塞资源延迟页面内容的渲染，影响页面加载速度。

优化方法如下：

1. **异步加载JavaScript：** 使用异步（async）或延迟（defer）属性，将JavaScript文件异步加载，减少阻塞时间。
2. **外部CSS文件：** 使用外部CSS文件，将CSS文件放在HTML文档的底部，减少阻塞时间。
3. **CSS精灵（CSS Sprites）：** 将多个图片合并成一个图片，通过背景位置实现图片切换，减少HTTP请求。
4. **内联CSS：** 对于小型的、关键的CSS样式，可以使用内联CSS，避免外部CSS文件的加载。

通过优化渲染阻塞资源，可以提高页面加载速度和用户体验。

### 前端框架

#### 24. 什么是React？请简述React的核心概念和优点。

**答案：** React是一个用于构建用户界面的JavaScript库，由Facebook开发。React的核心概念和优点如下：

1. **核心概念：**
   - **组件化：** React将UI划分为可复用的组件，使得代码更易于管理和维护。
   - **虚拟DOM：** React使用虚拟DOM来提高性能，通过对比虚拟DOM和实际DOM的差异，高效地更新UI。
   - **单向数据流：** React通过单向数据流管理状态，使得数据流更加清晰和可预测。

2. **优点：**
   - **组件化：** 提高代码复用性和可维护性。
   - **虚拟DOM：** 提高性能，减少DOM操作。
   - **单向数据流：** 降低状态管理的复杂性。
   - **丰富的生态系统：** 支持React Native、React VR等跨平台开发。

#### 25. 什么是Vue？请简述Vue的核心概念和优点。

**答案：** Vue是一个用于构建用户界面的JavaScript框架，由尤雨溪开发。Vue的核心概念和优点如下：

1. **核心概念：**
   - **声明式渲染：** Vue使用声明式渲染，通过模板语法将数据渲染到视图。
   - **响应式系统：** Vue使用响应式系统来监听数据变化，并自动更新视图。
   - **组件系统：** Vue支持组件化开发，提高代码复用性和可维护性。

2. **优点：**
   - **简单易学：** Vue的语法简洁明了，易于上手。
   - **响应式系统：** 提高性能和开发体验。
   - **双向绑定：** 支持数据双向绑定，减少手动操作DOM。
   - **灵活性：** 支持组合使用其他库，如Vuex和Vue Router。

#### 26. 什么是Angular？请简述Angular的核心概念和优点。

**答案：** Angular是一个用于构建大型单页应用的前端框架，由Google开发。Angular的核心概念和优点如下：

1. **核心概念：**
   - **组件驱动：** Angular使用组件作为构建应用的基本单元，提高代码的可维护性和复用性。
   - **依赖注入：** Angular通过依赖注入（DI）机制，管理组件之间的依赖关系。
   - **声明式UI：** Angular使用声明式UI，通过模板语法描述UI和行为。

2. **优点：**
   - **强类型检查：** TypeScript支持强类型检查，提高代码质量和可维护性。
   - **依赖注入：** 简化组件之间的依赖管理。
   - **丰富的生态系统：** 支持大量第三方库和工具，如ng-cli、ngRx等。
   - **大型应用支持：** 适用于构建大型和复杂的应用。

通过上述核心概念和优点，可以看出React、Vue和Angular各自在构建用户界面方面有着独特的优势，适用于不同的开发场景和需求。### 2024 字节跳动前端面试常见问题与答案

#### 27. 什么是React Hooks？请简要介绍React Hooks的作用和用法。

**答案：** React Hooks 是 React 16.8 版本引入的新特性，允许在函数组件中“钩取”状态和生命周期。React Hooks 的主要作用和用法如下：

1. **作用：** 
   - **状态管理：** Hooks 可以在函数组件中管理组件的状态，无需使用类组件。
   - **生命周期：** Hooks 可以模拟类组件的生命周期方法，如 `useEffect`、`useLayoutEffect` 等。
   - **逻辑复用：** Hooks 可以用于封装通用的逻辑，提高代码复用性。

2. **用法：**
   - **`useState`：** 用于在函数组件中添加状态。
   ```javascript
   function Counter() {
     const [count, setCount] = useState(0);
   }
   ```
   - **`useEffect`：** 用于在组件中进行副作用操作，类似于类组件的生命周期方法。
   ```javascript
   function Example() {
     useEffect(() => {
       // 进行副作用操作
       return () => {
         // 清理副作用
       };
     }, [/* 依赖项 */]);
   }
   ```
   - **`useContext`：** 用于在组件中访问和使用上下文（Context）。
   ```javascript
   function ComponentWithTheme() {
     const theme = useContext(ThemeContext);
   }
   ```
   - **其他Hooks：** 如 `useReducer`、`useCallback`、`useMemo` 等，用于处理更复杂的逻辑和性能优化。

#### 28. 什么是JavaScript中的作用域和闭包？请简要介绍其概念和工作原理。

**答案：** JavaScript中的作用域和闭包是核心概念，它们影响着变量的访问和作用范围。

1. **作用域：**
   - **概念：** 作用域是指变量（包括函数和变量）的可见和可访问范围。
   - **工作原理：** JavaScript中的作用域分为全局作用域和函数作用域。全局作用域中的变量可以在任何地方访问，而函数作用域中的变量只能在函数内部访问。

2. **闭包：**
   - **概念：** 闭包是指函数及其定义时的作用域链，即使外部函数已经执行完毕，闭包仍然可以访问其定义时的作用域链中的变量。
   - **工作原理：** 当一个函数被定义时，它不仅包含了函数体，还包括了一个内部作用域链。当外部函数执行完毕后，内部函数仍然可以访问外部函数的作用域链，形成了闭包。

#### 29. 如何实现一个防抖（Debounce）函数？请简要介绍其原理和实现方法。

**答案：** 防抖函数用于限制函数在一定时间内被调用的次数，常用于输入框输入、窗口大小调整等场景。

1. **原理：** 防抖函数通过在一段时间内记录函数调用次数，当这段时间内没有再次调用函数时，触发函数执行。

2. **实现方法：**
   ```javascript
   function debounce(func, wait) {
     let timeout;
     return function(...args) {
       const later = () => {
         clearTimeout(timeout);
         func.apply(this, args);
       };
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
     };
   }
   ```

   在这个实现中，每次触发函数时，都会清除之前的定时器，并设置一个新的定时器。如果在设定的时间（`wait` 参数）内没有再次触发函数，则执行实际的函数。

#### 30. 如何实现一个节流（Throttle）函数？请简要介绍其原理和实现方法。

**答案：** 节流函数用于限制函数在一定时间间隔内被调用的次数，常用于窗口大小调整、滚动事件等场景。

1. **原理：** 节流函数通过在一段时间内记录函数调用次数，当这段时间内函数被调用时，只执行一次。

2. **实现方法：**
   ```javascript
   function throttle(func, wait) {
     let last = 0;
     return function(...args) {
       const now = Date.now();
       if (now - last >= wait) {
         func.apply(this, args);
         last = now;
       }
     };
   }
   ```

   在这个实现中，每次触发函数时，都会计算当前时间与上一次触发时间的时间差。如果时间差大于设定的时间间隔（`wait` 参数），则执行实际的函数，并将上一次触发时间更新为当前时间。

通过掌握这些常见的前端知识点和面试题，可以更好地准备字节跳动的前端面试。在面试中，不仅要熟悉知识点，还要能够灵活运用，结合实际项目经验进行解答。

