                 

### 网易2025届校招面试高频算法题解析

#### 目录

1. [最长公共子序列](#最长公共子序列)
2. [二分查找](#二分查找)
3. [排序算法](#排序算法)
4. [图算法](#图算法)
5. [树算法](#树算法)
6. [动态规划](#动态规划)
7. [贪心算法](#贪心算法)
8. [组合数和排列数](#组合数和排列数)
9. [数论](#数论)
10. [字符串匹配算法](#字符串匹配算法)

---

#### 1. 最长公共子序列

##### 题目

给定两个字符串 `s1` 和 `s2`，找出两个字符串的最长公共子序列。

##### 示例

```
s1 = "ABCD"
s2 = "ACDF"
最长公共子序列为 "ACD"
```

##### 解题思路

使用动态规划求解。定义一个二维数组 `dp[i][j]`，表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符的最长公共子序列的长度。状态转移方程如下：

```
if s1[i - 1] == s2[j - 1]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
```

##### 代码实现

```go
func longestCommonSubsequence(s1 string, s2 string) int {
    n, m := len(s1), len(s2)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, m+1)
    }
    for i := 1; i <= n; i++ {
        for j := 1; j <= m; j++ {
            if s1[i-1] == s2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[n][m]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

##### 题目

给定一个数组 `nums`，找出最长连续递增子序列的长度。

##### 示例

```
nums = [1,2,2,3,4]
最长连续递增子序列为 [1,2,3,4]，长度为 4
```

##### 解题思路

使用贪心算法。初始化 `length` 为 1，遍历数组 `nums`，对于每个元素 `nums[i]`，如果 `nums[i] > nums[i - 1]`，则将 `length` 更新为 `length + 1`。否则，将 `length` 重置为 1。

##### 代码实现

```go
func lengthOfLIS(nums []int) int {
    length := 1
    for i := 1; i < len(nums); i++ {
        if nums[i] > nums[i-1] {
            length++
        } else {
            length = 1
        }
    }
    return length
}
```

---

#### 2. 二分查找

##### 题目

给定一个有序数组 `nums` 和一个目标值 `target`，找出 `target` 在数组中的索引。

##### 示例

```
nums = [1,3,5,6]
target = 5
索引为 2
```

##### 解题思路

使用二分查找算法。初始化 `left` 和 `right` 分别为数组的起始和终止索引。当 `left < right` 时，计算 `mid` 的值，如果 `nums[mid]` 等于 `target`，则返回 `mid`。如果 `nums[mid]` 小于 `target`，则将 `left` 更新为 `mid + 1`。否则，将 `right` 更新为 `mid - 1`。

##### 代码实现

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left < right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

---

#### 3. 排序算法

##### 题目

给定一个数组 `nums`，对其进行排序。

##### 示例

```
nums = [5,2,4,6,1,3]
排序后为 [1,2,3,4,5,6]
```

##### 解题思路

选择一个排序算法，如快速排序、归并排序或冒泡排序，对数组进行排序。

##### 快速排序代码实现

```go
func quickSort(nums []int) {
    if len(nums) <= 1 {
        return
    }
    pivot := nums[len(nums)/2]
    left, right := 0, len(nums)-1
    for {
        for nums[left] < pivot {
            left++
        }
        for nums[right] > pivot {
            right--
        }
        if left >= right {
            break
        }
        nums[left], nums[right] = nums[right], nums[left]
        left++
        right--
    }
    quickSort(nums[:left])
    quickSort(nums[left:])
}
```

##### 冒泡排序代码实现

```go
func bubbleSort(nums []int) {
    n := len(nums)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if nums[j] > nums[j+1] {
                nums[j], nums[j+1] = nums[j+1], nums[j]
            }
        }
    }
}
```

---

#### 4. 图算法

##### 题目

给定一个无向图，判断图中是否存在一条路径，其权重之和等于给定值 `target`。

##### 示例

```
graph = [[1,2], [2,3], [1,3], [4,3]]
target = 6
存在路径 [1,2,3,4]
```

##### 解题思路

使用深度优先搜索（DFS）遍历图，记录遍历过的节点和路径权重。当遍历到目标节点时，检查路径权重之和是否等于给定值 `target`。

##### 代码实现

```go
func canFindPath(graph [][]int, target int) bool {
    visited := make(map[int]bool)
    return dfs(graph, 0, target, visited)
}

func dfs(graph [][]int, node, target int, visited map[int]bool) bool {
    if visited[node] {
        return false
    }
    visited[node] = true
    if len(graph[node]) == 0 {
        return target == 0
    }
    for _, neighbor := range graph[node] {
        if dfs(graph, neighbor, target-node, visited) {
            return true
        }
    }
    return false
}
```

---

#### 5. 树算法

##### 题目

给定一棵二叉树，判断其是否为平衡二叉树。

##### 示例

```
root = [3,9,20,null,null,15,7]
不是平衡二叉树
```

##### 解题思路

使用后序遍历，计算每个节点的左子树和右子树的高度，并判断是否满足平衡二叉树的性质。

##### 代码实现

```go
func isBalanced(root *TreeNode) bool {
    if root == nil {
        return true
    }
    leftHeight := getHeight(root.Left)
    rightHeight := getHeight(root.Right)
    if abs(leftHeight-rightHeight) > 1 {
        return false
    }
    return isBalanced(root.Left) && isBalanced(root.Right)
}

func getHeight(node *TreeNode) int {
    if node == nil {
        return 0
    }
    leftHeight := getHeight(node.Left)
    rightHeight := getHeight(node.Right)
    return max(leftHeight, rightHeight) + 1
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

---

#### 6. 动态规划

##### 题目

给定一个整数数组 `nums`，找出所有连续子数组的和为 `target` 的子数组个数。

##### 示例

```
nums = [1,1,1]
target = 3
连续子数组和为 3 的子数组有 [1,1,1]，共有 1 个
```

##### 解题思路

使用哈希表记录前缀和，遍历数组 `nums`，计算每个位置的前缀和。如果前缀和等于 `target`，则说明存在一个连续子数组的和为 `target`，计数器加一。否则，计算 `target - nums[i]` 的前缀和，如果前缀和存在，则说明存在一个连续子数组的和为 `target`，计数器加一。

##### 代码实现

```go
func subarraySum(nums []int, target int) int {
    prefixSum := make(map[int]int)
    prefixSum[0] = 1
    count := 0
    for i, num := range nums {
        sum := 0
        if i > 0 {
            sum = prefixSum[nums[i-1]] + num
        } else {
            sum = num
        }
        if sum == target {
            count++
        }
        if v, ok := prefixSum[sum-target]; ok {
            count += v
        }
        prefixSum[sum]++
    }
    return count
}
```

---

#### 7. 贪心算法

##### 题目

给定一个整数数组 `nums`，找出所有连续子数组的和大于等于 `target` 的子数组个数。

##### 示例

```
nums = [1,1,1]
target = 3
连续子数组和大于等于 3 的子数组有 [1,1,1]，共有 1 个
```

##### 解题思路

使用双指针算法。初始化两个指针 `left` 和 `right` 分别为数组的起始位置，`sum` 记录当前子数组的和。当 `sum` 小于 `target` 时，将 `right` 指针向右移动，更新 `sum`。当 `sum` 大于等于 `target` 时，记录当前子数组的长度，并将 `left` 指针向右移动，更新 `sum`。

##### 代码实现

```go
func subarraySumGreaterEqualTarget(nums []int, target int) int {
    left, right := 0, 0
    count := 0
    sum := 0
    for right < len(nums) {
        sum += nums[right]
        for sum < target {
            right++
            sum += nums[right]
        }
        count += right - left
        sum -= nums[left]
        left++
    }
    return count
}
```

---

#### 8. 组合数和排列数

##### 题目

给定一个整数 `n`，求出 `C(n, k)` 的值。

##### 示例

```
n = 5, k = 3
C(5, 3) = 10
```

##### 解题思路

使用递归或循环计算组合数。递归实现如下：

```go
func C(n, k int) int {
    if k == 0 || n == k {
        return 1
    }
    return C(n-1, k-1) + C(n-1, k)
}
```

循环实现如下：

```go
func C(n, k int) int {
    result := 1
    for i := 1; i <= k; i++ {
        result *= (n - i + 1)
        result /= i
    }
    return result
}
```

---

#### 9. 数论

##### 题目

给定一个整数 `n`，求出 `n` 的所有因数。

##### 示例

```
n = 12
因数为 1, 2, 3, 4, 6, 12
```

##### 解题思路

使用两层循环，外层循环从 1 到 `n`，内层循环从外层循环变量到 `n`。如果 `i` 是 `n` 的因数，则将 `i` 加入结果数组。

##### 代码实现

```go
func getFactors(n int) []int {
    factors := make([]int, 0)
    for i := 1; i <= n; i++ {
        for j := i; j <= n/i; j++ {
            if n%j == 0 {
                factors = append(factors, j)
            }
        }
    }
    return factors
}
```

---

#### 10. 字符串匹配算法

##### 题目

给定一个字符串 `s` 和一个模式 `p`，找出 `s` 中所有与 `p` 匹配的子字符串。

##### 示例

```
s = "abracadabra"
p = "abr"
与 "abr" 匹配的子字符串有 "abr", "abracadabra"
```

##### 解题思路

使用 KMP 算法。首先计算 `p` 的最长公共前后缀数组 `next`，然后使用 `next` 数组和双指针算法实现字符串匹配。

##### 代码实现

```go
func KMP(s, p string) []int {
    next := make([]int, len(p))
    j := 0
    for i := 1; i < len(p); i++ {
        while j > 0 && p[i] != p[j] {
            j = next[j - 1]
        }
        if p[i] == p[j] {
            j++
        }
        next[i] = j
    }
    i, j = 0, 0
    result := make([]int, 0)
    for i < len(s) {
        while j > 0 && s[i] != p[j] {
            j = next[j - 1]
        }
        if s[i] == p[j] {
            j++
            if j == len(p) {
                result = append(result, i-j+1)
                j = next[j-1]
            }
        }
        i++
    }
    return result
}
```

