                 

### 京东2025届校招面试高频算法题解析

#### 一、排序相关

##### 1. 快速排序算法

**题目：** 实现快速排序算法，并解释其原理和复杂度。

**答案：** 快速排序是一种分治算法，基本思想是通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，然后分别对这两部分记录再次进行快速排序。

**原理：**
- 选择一个“基准”元素。
- 将比基准元素小的元素放到其左侧，比其大的元素放到其右侧。
- 对左右两部分递归地使用快速排序。

**复杂度：**
- 最坏情况下：O(n^2)
- 平均情况下：O(n log n)

**代码示例：**

```go
func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }

    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    right := make([]int, 0)

    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else {
            right = append(right, v)
        }
    }

    quickSort(left)
    quickSort(right)

    arr = append(append(arr[:0], left...), right...)
}

// 示例
arr := []int{9, 3, 5, 2, 4, 8, 1, 7, 6}
quickSort(arr)
fmt.Println(arr)
```

##### 2. 堆排序算法

**题目：** 实现堆排序算法，并解释其原理和复杂度。

**答案：** 堆排序是基于堆这种数据结构的排序算法。堆是一种特殊的树状数据结构，具有以下性质：

- 完全二叉树：每个节点的子节点都存在。
- 大顶堆：每个父节点的值都大于或等于其子节点的值。
- 小顶堆：每个父节点的值都小于或等于其子节点的值。

**原理：**
- 将输入的序列构造成一个大顶堆。
- 将堆顶元素（最大值）与最后一个元素交换，然后删除最后一个元素。
- 将剩余的元素重新调整成大顶堆。
- 重复上述步骤，直到堆中只剩下一个元素。

**复杂度：**
- 最坏情况下：O(n log n)
- 平均情况下：O(n log n)

**代码示例：**

```go
// 构建大顶堆
func buildMaxHeap(arr []int) {
    n := len(arr)
    for i := n/2 - 1; i >= 0; i-- {
        maxHeapify(arr, i, n)
    }
}

// 调整大顶堆
func maxHeapify(arr []int, i, n int) {
    largest := i
    l := 2*i + 1
    r := 2*i + 2

    if l < n && arr[l] > arr[largest] {
        largest = l
    }

    if r < n && arr[r] > arr[largest] {
        largest = r
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        maxHeapify(arr, largest, n)
    }
}

// 堆排序
func heapSort(arr []int) {
    buildMaxHeap(arr)
    n := len(arr)

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        maxHeapify(arr, 0, i)
    }
}

// 示例
arr := []int{9, 3, 5, 2, 4, 8, 1, 7, 6}
heapSort(arr)
fmt.Println(arr)
```

##### 3. 归并排序算法

**题目：** 实现归并排序算法，并解释其原理和复杂度。

**答案：** 归并排序是一种分治算法，将待排序的序列不断分割成两个子序列，分别对两个子序列进行排序，然后将排序好的子序列合并成一个有序序列。

**原理：**
- 将待排序序列分为若干个子序列，每个子序列都是有序的。
- 两两合并这些子序列，生成新的序列，新的序列是有序的。
- 重复上述步骤，直到所有子序列合并成一个有序序列。

**复杂度：**
- 最坏情况下：O(n log n)
- 平均情况下：O(n log n)

**代码示例：**

```go
// 归并排序
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }

    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])

    return merge(left, right)
}

// 合并两个有序序列
func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0

    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }

    result = append(result, left[i:]...)
    result = append(result, right[j:]...)

    return result
}

// 示例
arr := []int{9, 3, 5, 2, 4, 8, 1, 7, 6}
sortedArr := mergeSort(arr)
fmt.Println(sortedArr)
```

#### 二、二叉树相关

##### 1. 二叉树的遍历

**题目：** 实现二叉树的先序遍历、中序遍历和后序遍历。

**答案：** 二叉树的遍历包括三种方式：先序遍历、中序遍历和后序遍历。

- **先序遍历：** 先访问根节点，然后递归遍历左子树，最后递归遍历右子树。
- **中序遍历：** 递归遍历左子树，访问根节点，然后递归遍历右子树。
- **后序遍历：** 递归遍历左子树，递归遍历右子树，最后访问根节点。

**代码示例：**

```go
// 二叉树的节点定义
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// 先序遍历
func preorderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    if root != nil {
        result = append(result, root.Val)
        result = append(result, preorderTraversal(root.Left)...)
        result = append(result, preorderTraversal(root.Right)...)
    }
    return result
}

// 中序遍历
func inorderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    if root != nil {
        result = append(result, inorderTraversal(root.Left)...)
        result = append(result, root.Val)
        result = append(result, inorderTraversal(root.Right)...)
    }
    return result
}

// 后序遍历
func postorderTraversal(root *TreeNode) []int {
    result := make([]int, 0)
    if root != nil {
        result = append(result, postorderTraversal(root.Left)...)
        result = append(result, postorderTraversal(root.Right)...)
        result = append(result, root.Val)
    }
    return result
}

// 示例
root := &TreeNode{Val: 1}
root.Left = &TreeNode{Val: 2}
root.Right = &TreeNode{Val: 3}
root.Left.Left = &TreeNode{Val: 4}
root.Left.Right = &TreeNode{Val: 5}

fmt.Println(preorderTraversal(root))
fmt.Println(inorderTraversal(root))
fmt.Println(postorderTraversal(root))
```

##### 2. 二叉搜索树

**题目：** 实现二叉搜索树（BST），包括插入、删除和查找操作。

**答案：** 二叉搜索树是一种特殊的二叉树，具有以下性质：

- 每个节点的左子树只包含小于当前节点的值。
- 每个节点的右子树只包含大于当前节点的值。
- 左右子树都是二叉搜索树。

**插入操作：** 在二叉搜索树中找到一个空位置插入新节点。

**删除操作：** 根据节点的值找到待删除节点，然后根据待删除节点的情况进行调整。

**查找操作：** 在二叉搜索树中查找具有特定值的节点。

**代码示例：**

```go
// 二叉搜索树的节点定义
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// 插入操作
func insert(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return &TreeNode{Val: val}
    }

    if val < root.Val {
        root.Left = insert(root.Left, val)
    } else if val > root.Val {
        root.Right = insert(root.Right, val)
    }

    return root
}

// 删除操作
func delete(root *TreeNode, val int) *TreeNode {
    if root == nil {
        return root
    }

    if val < root.Val {
        root.Left = delete(root.Left, val)
    } else if val > root.Val {
        root.Right = delete(root.Right, val)
    } else {
        if root.Left == nil && root.Right == nil {
            return nil
        } else if root.Left == nil {
            return root.Right
        } else if root.Right == nil {
            return root.Left
        }

        minVal := findMin(root.Right).Val
        root.Val = minVal
        root.Right = delete(root.Right, minVal)
    }

    return root
}

// 查找操作
func find(root *TreeNode, val int) *TreeNode {
    if root == nil || root.Val == val {
        return root
    }

    if val < root.Val {
        return find(root.Left, val)
    }

    return find(root.Right, val)
}

// 找到最小值的节点
func findMin(node *TreeNode) *TreeNode {
    if node == nil || node.Left == nil {
        return node
    }
    return findMin(node.Left)
}

// 示例
root := &TreeNode{Val: 5}
root = insert(root, 3)
root = insert(root, 7)
root = insert(root, 2)
root = insert(root, 4)
root = insert(root, 6)
root = insert(root, 8)

fmt.Println(find(root, 4)) // 输出：{4 <nil> <nil>}
root = delete(root, 4)
fmt.Println(find(root, 4)) // 输出：<nil>
```

#### 三、动态规划

##### 1. 最长递增子序列

**题目：** 给定一个无序数组，找出最长递增子序列的长度。

**答案：** 动态规划是一种常用的算法设计技巧，可以有效地解决许多优化问题。对于最长递增子序列问题，可以使用动态规划来求解。

**思路：**
- 定义一个数组 `dp`，其中 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
- 遍历数组，对于每个元素 `nums[i]`，遍历其左侧的所有元素 `nums[j]`（`j < i`），如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
- 最终结果为所有 `dp[i]` 中的最大值。

**代码示例：**

```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    dp := make([]int, len(nums))
    dp[0] = 1

    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[j] < nums[i] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }

    return max(dp...)
}

// 示例
nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
fmt.Println(lengthOfLIS(nums)) // 输出：4
```

##### 2. 最小路径和

**题目：** 给定一个整数矩阵，找出从左上角到右下角的最小路径和。

**答案：** 使用动态规划，从右下角开始向前遍历矩阵，更新每个元素的最小路径和。

**思路：**
- 定义一个二维数组 `dp`，其中 `dp[i][j]` 表示从左上角到点 `(i, j)` 的最小路径和。
- 遍历矩阵，对于每个元素 `dp[i][j]`，它的值可以通过以下公式计算：
  - `dp[i][j] = nums[i][j] + min(dp[i-1][j], dp[i][j-1])`
- 最终结果为 `dp[m-1][n-1]`。

**代码示例：**

```go
func minPathSum(nums [][]int) int {
    if len(nums) == 0 || len(nums[0]) == 0 {
        return 0
    }

    m, n := len(nums), len(nums[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    dp[m-1][n-1] = nums[m-1][n-1]

    for i := m - 2; i >= 0; i-- {
        dp[i][n-1] = nums[i][n-1] + dp[i+1][n-1]
    }

    for j := n - 2; j >= 0; j-- {
        dp[m-1][j] = nums[m-1][j] + dp[m-1][j+1]
    }

    for i := m - 2; i >= 0; i-- {
        for j := n - 2; j >= 0; j-- {
            dp[i][j] = nums[i][j] + min(dp[i+1][j], dp[i][j+1])
        }
    }

    return dp[0][0]
}

// 示例
nums := [][]int{
    {1, 3, 1},
    {1, 5, 1},
    {4, 2, 1},
}
fmt.Println(minPathSum(nums)) // 输出：7
```

#### 四、贪心算法

##### 1. 贪心算法介绍

**题目：** 请简述贪心算法的基本概念和特点。

**答案：** 贪心算法是一种在每一步选择中都采取当前最好或最优的选择，从而希望导致结果是全局最好或最优的算法策略。

**特点：**
- **每一步选择都是局部最优的：** 在每一步选择中，算法都会选择当前看起来最好的选择。
- **不一定能得到全局最优解：** 贪心算法并不保证每次选择都是全局最优的，但它通常能够找到一种近似最优解。

##### 2. 背包问题

**题目：** 请实现一个贪心算法解决背包问题。

**答案：** 背包问题是一种常见的优化问题，其目标是选择一些物品放入背包中，使得背包中的物品总价值最大化，同时不超过背包的容量限制。

**贪心策略：**
- 根据物品的价值与重量比例（价值/重量）进行排序。
- 从高价值/重量比例的物品开始选择，直到背包填满或不能再放入物品为止。

**代码示例：**

```go
// 背包问题
func knapsack(weights []int, values []int, capacity int) int {
    n := len(weights)
    items := make([]Item, n)
    for i := 0; i < n; i++ {
        items[i] = Item{Weight: weights[i], Value: values[i]}
    }

    // 根据价值/重量比例排序
    sort.Slice(items, func(i, j int) bool {
        return float64(items[i].Value) / items[i].Weight > float64(items[j].Value) / items[j].Weight
    })

    totalValue := 0
    for _, item := range items {
        if capacity >= item.Weight {
            capacity -= item.Weight
            totalValue += item.Value
        } else {
            totalValue += (float64(capacity) / float64(item.Weight)) * float64(item.Value)
            break
        }
    }

    return totalValue
}

type Item struct {
    Weight  int
    Value   int
}

// 示例
weights := []int{2, 3, 4, 5}
values := []int{3, 4, 5, 6}
capacity := 8
fmt.Println(knapsack(weights, values, capacity)) // 输出：9
```

#### 五、图论算法

##### 1. 深度优先搜索（DFS）

**题目：** 请实现一个深度优先搜索（DFS）算法，用于寻找图中两点间的路径。

**答案：** 深度优先搜索（DFS）是一种用于遍历或搜索树或图的算法。在DFS中，我们沿着一个路径一直走到底，然后再回溯。

**思路：**
- 从起始点开始，将其标记为已访问。
- 访问其邻接点，如果邻接点未访问过，则递归地对邻接点进行DFS。
- 如果找到了目标节点，则返回路径。

**代码示例：**

```go
// 图的节点定义
type Graph struct {
    Vertices map[int][]int
}

func NewGraph() *Graph {
    return &Graph{
        Vertices: make(map[int][]int),
    }
}

func (g *Graph) AddEdge(v1, v2 int) {
    g.Vertices[v1] = append(g.Vertices[v1], v2)
    g.Vertices[v2] = append(g.Vertices[v2], v1)
}

// 深度优先搜索
func (g *Graph) DFS(start, target int) []int {
    visited := make(map[int]bool)
    path := make([]int, 0)

    func dfs(v int) {
        if visited[v] {
            return
        }
        visited[v] = true
        path = append(path, v)

        if v == target {
            return
        }

        for _, neighbor := range g.Vertices[v] {
            dfs(neighbor)
        }

        if len(path) > 0 {
            path = path[:len(path)-1]
        }
    }

    dfs(start)
    return path
}

// 示例
g := NewGraph()
g.AddEdge(0, 1)
g.AddEdge(0, 2)
g.AddEdge(1, 2)
g.AddEdge(1, 3)
g.AddEdge(2, 3)

path := g.DFS(0, 3)
fmt.Println(path) // 输出：[0 1 3]
```

##### 2. 广度优先搜索（BFS）

**题目：** 请实现一个广度优先搜索（BFS）算法，用于寻找图中两点间的最短路径。

**答案：** 广度优先搜索（BFS）是一种用于遍历或搜索树或图的算法。在BFS中，我们首先访问起始点，然后依次访问其邻接点，再依次访问邻接点的邻接点，以此类推。

**思路：**
- 使用一个队列来存储待访问的节点。
- 从起始点开始，将其标记为已访问，并将其加入队列。
- 循环从队列中取出一个节点，访问其邻接点，如果邻接点未访问过，则将其标记为已访问，并加入队列。
- 当队列空时，算法结束。

**代码示例：**

```go
// 广度优先搜索
func (g *Graph) BFS(start, target int) []int {
    queue := make([]int, 0)
    queue = append(queue, start)
    visited := make(map[int]bool)
    visited[start] = true

    path := make([]int, 0)

    for len(queue) > 0 {
        v := queue[0]
        queue = queue[1:]

        if v == target {
            break
        }

        for _, neighbor := range g.Vertices[v] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
                path = append(path, neighbor)
            }
        }
    }

    return path
}

// 示例
path := g.BFS(0, 3)
fmt.Println(path) // 输出：[0 1 3]
```

##### 3. Dijkstra 算法

**题目：** 请实现Dijkstra算法，用于计算图中两点间的最短路径。

**答案：** Dijkstra算法是一种用于计算单源最短路径的算法，它基于贪心策略，逐步扩大已知的“最短路径”集合。

**思路：**
- 初始化一个距离数组 `dist`，其中 `dist[v]` 表示从源点 `s` 到点 `v` 的距离，初始时 `dist[s] = 0`，其他点的距离为无穷大。
- 创建一个优先队列，用来选择下一个距离最小的点。
- 循环选择距离最小的点，将其加入“最短路径”集合，并更新其他点到该点的距离。

**代码示例：**

```go
// Dijkstra算法
func (g *Graph) Dijkstra(start int) []int {
    n := len(g.Vertices)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0

    visited := make(map[int]bool)
    pq := make(PriorityQueue, 0)
    pq = append(pq, &Item{Value: start, Cost: 0})
    heap.Init(&pq)

    for len(pq) > 0 {
        item := heap.Pop(&pq).(*Item)
        if visited[item.Value] {
            continue
        }
        visited[item.Value] = true

        for _, neighbor := range g.Vertices[item.Value] {
            if !visited[neighbor] {
                alt := item.Cost + g.Vertices[item.Value][neighbor]
                if alt < dist[neighbor] {
                    dist[neighbor] = alt
                    heap.Push(&pq, &Item{Value: neighbor, Cost: alt})
                }
            }
        }
    }

    return dist
}

// 示例
dist := g.Dijkstra(0)
fmt.Println(dist) // 输出：[0 1 2 3 4 5]
```

##### 4. 红黑树

**题目：** 请简述红黑树的基本概念和性质。

**答案：** 红黑树是一种自平衡二叉查找树，它通过特定的规则来确保树的平衡，从而保证查找、插入和删除操作的平均时间复杂度为O(log n)。

**基本概念：**
- 每个节点都是红色或黑色。
- 根节点是黑色的。
- 每个叶节点（NIL节点，通常是叶子节点的子节点）都是黑色的。
- 如果一个节点是红色的，则它的两个子节点都是黑色的（红黑树的任何简单路径上不会有两个连续的红色节点）。

**性质：**
- 每条路径上黑色节点的数量相同。
- 红黑树是一种平衡树，确保了树的深度不超过2倍的对数。

#### 六、字符串处理

##### 1. KMP 算法

**题目：** 请简述KMP算法的基本原理和步骤。

**答案：** KMP（Knuth-Morris-Pratt）算法是一种用于字符串匹配的高效算法。它的核心思想是避免字符串的重复比较，通过构建部分匹配表（Next数组）来实现。

**基本原理：**
- 当出现不匹配时，算法能够利用已匹配的信息，避免回溯到字符串的开始位置重新比较。

**步骤：**
1. 构建部分匹配表（Next数组）：遍历模式串，根据已匹配的信息更新Next数组。
2. 模式串和文本串对齐，从左到右逐个字符比较。
3. 如果出现不匹配，根据Next数组的值决定下一个比较位置，避免回溯。

**代码示例：**

```go
// 构建部分匹配表
func buildNext(s string) []int {
    next := make([]int, len(s))
    j := 0
    for i := 1; i < len(s); i++ {
        for j > 0 && s[i] != s[j] {
            j = next[j-1]
        }
        if s[i] == s[j] {
            j++
        }
        next[i] = j
    }
    return next
}

// KMP算法
func kmp(s, t string) int {
    next := buildNext(t)
    i, j := 0, 0
    for i < len(s) && j < len(t) {
        if j == -1 || s[i] == t[j] {
            i++
            j++
        } else {
            j = next[j]
        }
    }
    if j == len(t) {
        return i - j
    }
    return -1
}

// 示例
s := "ABABDABACD"
t := "ABACD"
index := kmp(s, t)
fmt.Println(index) // 输出：4
```

##### 2. 字符串匹配

**题目：** 请实现一个字符串匹配算法，用于寻找一个字符串在另一个字符串中的所有出现位置。

**答案：** 使用KMP算法可以高效地实现字符串匹配。

**代码示例：**

```go
func findAll(s, t string) []int {
    next := buildNext(t)
    i, j := 0, 0
    indices := make([]int, 0)
    for i < len(s) && j < len(t) {
        if j == -1 || s[i] == t[j] {
            i++
            j++
        } else {
            j = next[j]
        }
        if j == len(t) {
            indices = append(indices, i-j)
            j = next[j-1]
        }
    }
    return indices
}

// 示例
s := "ABABDABACD"
t := "ABACD"
indices := findAll(s, t)
fmt.Println(indices) // 输出：[4 5]
```

#### 七、其他算法

##### 1. 二进制枚举

**题目：** 请实现一个二进制枚举算法，用于找出满足特定条件的二进制数。

**答案：** 二进制枚举是一种通过遍历二进制数的所有可能组合来解决问题的方法。

**思路：**
- 从0开始，不断将二进制数左移，并在最低位添加0或1，遍历所有可能的二进制数。
- 对于每个二进制数，判断其是否满足特定条件。

**代码示例：**

```go
func binarySearch(nums []int, target int) bool {
    for i := 0; i < 1<<len(nums); i++ {
        num := 0
        for j := 0; j < len(nums); j++ {
            if (i >> j) & 1 == 1 {
                num += nums[j]
            }
        }
        if num == target {
            return true
        }
    }
    return false
}

// 示例
nums := []int{1, 2, 3}
target := 6
fmt.Println(binarySearch(nums, target)) // 输出：true
```

##### 2. 斐波那契数列

**题目：** 请实现一个斐波那契数列的计算方法。

**答案：** 斐波那契数列是这样一个序列：0, 1, 1, 2, 3, 5, 8, 13, 21, ...

**思路：**
- 使用递归实现：`fib(n) = fib(n-1) + fib(n-2)`。
- 使用动态规划实现：`fib(n) = fib(n-1) + fib(n-2)`，使用数组存储已计算的结果，避免重复计算。

**代码示例：**

```go
// 递归实现
func fib(n int) int {
    if n <= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}

// 动态规划实现
func fibDP(n int) int {
    if n <= 1 {
        return n
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}

// 示例
n := 10
fmt.Println(fib(n)) // 输出：55
fmt.Println(fibDP(n)) // 输出：55
```

##### 3. 背包问题

**题目：** 请实现一个贪心算法解决背包问题。

**答案：** 背包问题是一种常见的优化问题，其目标是选择一些物品放入背包中，使得背包中的物品总价值最大化，同时不超过背包的容量限制。

**贪心策略：**
- 根据物品的价值与重量比例（价值/重量）进行排序。
- 从高价值/重量比例的物品开始选择，直到背包填满或不能再放入物品为止。

**代码示例：**

```go
// 背包问题
func knapsack(weights []int, values []int, capacity int) int {
    n := len(weights)
    items := make([]Item, n)
    for i := 0; i < n; i++ {
        items[i] = Item{Weight: weights[i], Value: values[i]}
    }

    // 根据价值/重量比例排序
    sort.Slice(items, func(i, j int) bool {
        return float64(items[i].Value) / items[i].Weight > float64(items[j].Value) / items[j].Weight
    })

    totalValue := 0
    for _, item := range items {
        if capacity >= item.Weight {
            capacity -= item.Weight
            totalValue += item.Value
        } else {
            totalValue += (float64(capacity) / float64(item.Weight)) * float64(item.Value)
            break
        }
    }

    return totalValue
}

type Item struct {
    Weight  int
    Value   int
}

// 示例
weights := []int{2, 3, 4, 5}
values := []int{3, 4, 5, 6}
capacity := 8
fmt.Println(knapsack(weights, values, capacity)) // 输出：9
```

##### 4. 股票买卖

**题目：** 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格。设计一个算法能够找到最大的利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在当天再次购买股票（即冷冻期为 1 天）。

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

**提示：**

- 1 <= prices.length <= 5000
- 0 <= prices[i] <= 1000

**答案：**

可以使用动态规划的方法来解决这个问题。定义四个状态：

- `dp[i][0]`：第 i 天结束时，持有股票的最大利润。
- `dp[i][1]`：第 i 天结束时，不持有股票且处于冷冻期的最大利润。
- `dp[i][2]`：第 i 天结束时，不持有股票且不在冷冻期的最大利润。
- `dp[i][3]`：第 i 天结束时，持有股票的最大利润，但处于冷冻期。

状态转移方程：

- `dp[i][0] = dp[i-1][2] - prices[i]`：今天买入股票，那么今天不持有股票的最大利润是昨天不持有股票且不在冷冻期的最大利润减去今天的价格。
- `dp[i][1] = dp[i-1][0]`：今天不持有股票且处于冷冻期，那么今天不持有股票且处于冷冻期的最大利润是昨天持有股票的最大利润。
- `dp[i][2] = max(dp[i-1][1], dp[i-1][3])`：今天不持有股票且不在冷冻期，那么今天不持有股票且不在冷冻期的最大利润是昨天处于冷冻期或昨天处于冷冻期的最大利润。
- `dp[i][3] = dp[i-1][1] - prices[i]`：今天持有股票且处于冷冻期，那么今天持有股票且处于冷冻期的最大利润是昨天处于冷冻期的最大利润减去今天的价格。

初始状态：

- `dp[0][0] = -prices[0]`：第 0 天结束时，持有股票的最大利润是初始时买入的股票价格。
- `dp[0][1] = 0`：第 0 天结束时，不持有股票且处于冷冻期的最大利润是 0。
- `dp[0][2] = 0`：第 0 天结束时，不持有股票且不在冷冻期的最大利润是 0。
- `dp[0][3] = 0`：第 0 天结束时，持有股票的最大利润，但处于冷冻期是 0。

代码实现：

```go
func maxProfit(prices []int) int {
    n := len(prices)
    if n < 2 {
        return 0
    }
    dp := make([][4]int, n)
    dp[0][0] = -prices[0]
    dp[0][1] = 0
    dp[0][2] = 0
    dp[0][3] = 0
    for i := 1; i < n; i++ {
        dp[i][0] = dp[i-1][2] - prices[i]
        dp[i][1] = dp[i-1][0]
        dp[i][2] = max(dp[i-1][1], dp[i-1][3])
        dp[i][3] = dp[i-1][1] - prices[i]
    }
    return max(dp[n-1][0], dp[n-1][2])
}

// 示例
prices := []int{1, 2, 3, 0, 2}
fmt.Println(maxProfit(prices)) // 输出：3
```

##### 5. 合并两个有序数组

**题目：** 给定两个已排序的整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个排序数组。

**说明：**
- 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
- 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

**示例：**
```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

**答案：** 可以使用双指针的方法来解决这个问题。假设两个数组分别从后开始遍历，将较大的元素依次放入 nums1 的末尾。

具体步骤如下：

1. 初始化两个指针 i 和 j，分别指向 nums1 和 nums2 的最后一个元素。
2. 初始化一个指针 k，指向 nums1 的最后一个元素。
3. 从后向前遍历两个数组，比较 i 和 j 指向的元素，将较大的元素放入 k 指向的位置，并将 k 指向的位置向后移动。
4. 当其中一个数组遍历完毕后，将另一个数组的剩余元素依次放入 nums1 的末尾。

代码实现：

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}

// 示例
nums1 := []int{1, 2, 3, 0, 0, 0}
m := 3
nums2 := []int{2, 5, 6}
n := 3
merge(nums1, m, nums2, n)
fmt.Println(nums1) // 输出：[1 2 2 3 5 6]
```

##### 6. 最长公共子序列

**题目：** 给定两个字符串 text1 和 text2，返回他们的最长公共子序列的长度。

**示例 1:**

```
输入: text1 = "abcde", text2 = "ace"
输出: 3
解释: 最长公共子序列是 "ace"，它的长度为 3。
```

**示例 2:**

```
输入: text1 = "abc", text2 = "abc"
输出: 3
解释: 最长公共子序列是 "abc"，它的长度为 3。
```

**示例 3:**

```
输入: text1 = "abc", text2 = "def"
输出: 0
解释: 最长公共子序列是空，它的长度为 0。
```

**提示：**

- 1 <= text1.length, text2.length <= 1000
- "abcde" 或者 "ace" 长度最大为1000，有多种最长公共子序列的答案，其中最短的答案是 "ace"； "abc" 长度最大为1000，有多种最长公共子序列的答案，最短的答案是 "abc"； "abc" 和 "def" 长度最大为1000，有多种最长公共子序列的答案，最短的答案是 ""。

**答案：** 使用动态规划的方法来解决这个问题。定义一个二维数组 dp，其中 dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度。

状态转移方程：

- 如果 text1[i-1] 等于 text2[j-1]，那么 dp[i][j] = dp[i-1][j-1] + 1。
- 如果 text1[i-1] 不等于 text2[j-1]，那么 dp[i][j] = max(dp[i-1][j], dp[i][j-1])。

初始状态：

- dp[0][j] = 0，因为 text1 的前 0 个字符和 text2 的前 j 个字符没有公共子序列。
- dp[i][0] = 0，因为 text1 的前 i 个字符和 text2 的前 0 个字符没有公共子序列。

代码实现：

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

// 示例
text1 := "abcde"
text2 := "ace"
fmt.Println(longestCommonSubsequence(text1, text2)) // 输出：3
text1 = "abc"
text2 = "abc"
fmt.Println(longestCommonSubsequence(text1, text2)) // 输出：3
text1 = "abc"
text2 = "def"
fmt.Println(longestCommonSubsequence(text1, text2)) // 输出：0
```

##### 7. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**示例：**

```
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**答案：** 使用排序和双指针的方法。首先将区间按照左端点排序，然后遍历排序后的区间，使用双指针技巧合并重叠的区间。

具体步骤如下：

1. 将区间按照左端点排序。
2. 初始化一个空数组 res，用于存储合并后的区间。
3. 遍历排序后的区间，使用两个指针 l 和 r，分别指向当前区间的左端点和右端点。
4. 如果 res 为空，或者当前区间的左端点大于 res 中最后一个区间的右端点，将当前区间添加到 res 中。
5. 如果当前区间的左端点小于等于 res 中最后一个区间的右端点，将当前区间的右端点更新为 max(当前区间的右端点，res 中最后一个区间的右端点)，然后继续遍历下一个区间。

代码实现：

```go
func merge(intervals [][]int) [][]int {
    if len(intervals) == 0 {
        return nil
    }
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })
    res := make([][]int, 0, len(intervals))
    l, r := intervals[0][0], intervals[0][1]
    for _, interval := range intervals {
        if interval[0] > r {
            res = append(res, []int{l, r})
            l, r = interval[0], interval[1]
        } else {
            r = max(r, interval[1])
        }
    }
    res = append(res, []int{l, r})
    return res
}

// 示例
intervals := [][]int{{1, 3}, {2, 6}, {8, 10}, {15, 18}}
fmt.Println(merge(intervals)) // 输出：[[1 6] [8 10] [15 18]]
```

##### 8. 简化路径

**题目：** 给你一个字符串 path ，其中 path[i] 的值可以是 '$'、'N'、'S'、'E' 或 'W'，其中：

- '$'：起始位置（路径上的第一个字符）。
- 'N'：向北移动一步。
- 'S'：向南移动一步。
- 'E'：向东移动一步。
- 'W'：向西移动一步。

最终你需要返回一个表示最终位置的字符串，其中路径上的第一步是字符串的字面第一个字符。如果无法从字符串的字面第一个字符返回字符串的字面最后一个字符，则返回空字符串。

**示例 1：**

```
输入：path = "NES"
输出："N"
解释：从起始点向北移动一步，然后向东移动一步，最后向南移动一步到字面最后一个字符。
```

**示例 2：**

```
输入：path = "NESW"
输出：""
解释：从起始点向北、东、南和西各自移动一步，无法返回字面最后一个字符。
```

**答案：** 使用变量 x 和 y 分别表示横坐标和纵坐标。初始化 x 和 y 为 0，然后遍历字符串 path，根据字符更新 x 和 y 的值。如果字符串的长度大于 1，且 x 和 y 的值不为 0，说明无法从字符串的字面第一个字符返回字面最后一个字符，返回空字符串。否则，返回表示最终位置的字符串。

代码实现：

```go
func simplifyPath(path string) string {
    x, y := 0, 0
    for _, c := range path {
        switch c {
        case 'N':
            y++
        case 'S':
            y--
        case 'E':
            x++
        case 'W':
            x--
        case '.':
            continue
        case '/':
            if x != 0 || y != 0 {
                x, y = 0, 0
            }
        default:
            return ""
        }
    }
    if x != 0 || y != 0 {
        return ""
    }
    return "/" + string(path[0])
}

// 示例
path := "NES"
fmt.Println(simplifyPath(path)) // 输出："N"
path = "NESW"
fmt.Println(simplifyPath(path)) // 输出：""
```

##### 9. 股票买卖

**题目：** 给你一个整数数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

你只能选中一只股票进行一次买卖。

请你设计一个算法能够最大限度地从中获取利润。你可以无限次地买卖该股票，但是你每次买卖股票的时候需付交易费用 transactionFee 。

**注意：** 你不能同时参与多次交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], transactionFee = 2
输出：8
解释：能够完成的最大利润: 8 = (8 - 2) + (9 - 2) = 8.
或者，8 = (8 - 2) + (9 - 4) = 8.
```

**示例 2：**

```
输入：prices = [1, 3, 7, 5, 10, 3], transactionFee = 3
输出：6
解释：能够完成的最大利润: 6 = (7 - 3) + (10 - 3) = 6.
```

**提示：**

- 1 <= prices.length <= 105
- 0 <= prices[i] <= 104
- 0 <= transactionFee <= 104

**答案：** 使用动态规划的方法。定义四个状态：

- `dp[i][0]`：第 i 天结束时，持有股票的最大利润。
- `dp[i][1]`：第 i 天结束时，不持有股票且处于冷冻期的最大利润。
- `dp[i][2]`：第 i 天结束时，不持有股票且不在冷冻期的最大利润。
- `dp[i][3]`：第 i 天结束时，持有股票的最大利润，但处于冷冻期。

状态转移方程：

- `dp[i][0] = dp[i-1][2] - prices[i]`：今天买入股票，那么今天不持有股票的最大利润是昨天不持有股票且不在冷冻期的最大利润减去今天的价格。
- `dp[i][1] = dp[i-1][0]`：今天不持有股票且处于冷冻期，那么今天不持有股票且处于冷冻期的最大利润是昨天持有股票的最大利润。
- `dp[i][2] = max(dp[i-1][1], dp[i-1][3])`：今天不持有股票且不在冷冻期，那么今天不持有股票且不在冷冻期的最大利润是昨天处于冷冻期或昨天处于冷冻期的最大利润。
- `dp[i][3] = dp[i-1][1] - prices[i]`：今天持有股票且处于冷冻期，那么今天持有股票且处于冷冻期的最大利润是昨天处于冷冻期的最大利润减去今天的价格。

初始状态：

- `dp[0][0] = -prices[0]`：第 0 天结束时，持有股票的最大利润是初始时买入的股票价格。
- `dp[0][1] = 0`：第 0 天结束时，不持有股票且处于冷冻期的最大利润是 0。
- `dp[0][2] = 0`：第 0 天结束时，不持有股票且不在冷冻期的最大利润是 0。
- `dp[0][3] = 0`：第 0 天结束时，持有股票的最大利润，但处于冷冻期是 0。

代码实现：

```go
func maxProfit(prices []int, transactionFee int) int {
    m := len(prices)
    if m < 2 {
        return 0
    }
    dp := make([][4]int, m)
    dp[0][0] = -prices[0]
    dp[0][1] = 0
    dp[0][2] = 0
    dp[0][3] = 0
    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][2] - prices[i]
        dp[i][1] = dp[i-1][0]
        dp[i][2] = max(dp[i-1][1], dp[i-1][3])
        dp[i][3] = dp[i-1][1] - prices[i]
    }
    return max(dp[m-1][0], dp[m-1][2])
}

// 示例
prices := []int{1, 3, 7, 5, 10, 3}
transactionFee := 3
fmt.Println(maxProfit(prices, transactionFee)) // 输出：6
```

##### 10. 翻转字母

**题目：** 给你一个字符串 s ，请你反转字符串中单词的顺序。

**注意：** 单词是以空格分隔开的。

**说明：**

- 翻转后的字符串应按字典序排列。

**示例 1：**

```
输入：s = "Let's take LeetCode contest"
输出："contest LeetCode take's Let"
```

**示例 2：**

```
输入：s = "God Ding"
输出："ding God"
```

**提示：**

- 1 <= s.length <= 10^4
- s 包含可打印的 ASCII 字符。

**答案：** 使用双指针的方法。首先将字符串反转，然后将反转后的字符串中的单词分隔开。具体步骤如下：

1. 初始化两个指针 i 和 j，分别指向字符串的起始位置和结束位置。
2. 反转字符串：将 i 和 j 指向的字符交换，然后同时向后移动 i 和 j，直到 i 大于 j。
3. 初始化一个空字符串 res，用于存储结果。
4. 从反转后的字符串中分隔单词：遍历反转后的字符串，当遇到空格时，将当前单词添加到 res 后面，并跳过空格。
5. 如果遍历结束后，字符串末尾还有单词，将其添加到 res 后面。
6. 返回 res。

代码实现：

```go
func reverseWords(s string) string {
    s = "\n" + s + "\n" // 添加字符串的开始和结束标志
    n := len(s)
    i, j := 0, 0
    for i < n {
        if s[i] == '\n' {
            i++ // 跳过字符串的开始标志
            break
        }
        j = i
        for j < n && s[j] != '\n' {
            j++
        }
        // 将 i 和 j 指向的子字符串添加到 res 后面
        res := append(res, s[i:j]...)
        res = append(res, ' ')
        i = j
    }
    if len(res) > 0 {
        res = res[:len(res)-1] // 删除字符串的最后一个空格
    }
    return res
}

// 示例
s := "Let's take LeetCode contest"
fmt.Println(reverseWords(s)) // 输出："contest LeetCode take's Let"
s = "God Ding"
fmt.Println(reverseWords(s)) // 输出："ding God"
```

##### 11. 搜索旋转排序数组

**题目：** 整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，

比如，原数组可能为 [0,1,2,4,5,6,7] ，
如下所

