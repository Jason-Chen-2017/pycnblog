                 

## 阿里巴巴2025校招面试真题与算法题解

### 面试题库

#### 1. 剑指 Offer 中的经典问题：重建二叉树

**题目描述：** 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。如果不存在这样的二叉树，则返回 NULL。

**解答：**

```go
func buildTree(pre, in []int) *TreeNode {
    if len(pre) == 0 || len(in) == 0 {
        return nil
    }
    rootVal := pre[0]
    root := &TreeNode{Val: rootVal}
    var buildTree func(preIndex, inIndex, inLength int) *TreeNode
    buildTree = func(preIndex, inIndex, inLength int) *TreeNode {
        if preIndex >= len(pre) || inIndex >= inIndex+inLength || pre[preIndex] != in[inIndex] {
            return nil
        }
        leftLength := 0
        for ; inIndex+leftLength < inIndex+inLength; leftLength++ {
            if in[inIndex+leftLength] == pre[preIndex+1] {
                break
            }
        }
        root.Left = buildTree(preIndex+1, inIndex, leftLength)
        root.Right = buildTree(preIndex+1+leftLength, inIndex+leftLength+1, inLength-leftLength-1)
        return root
    }
    _ = buildTree(0, 0, len(in))
    return root
}
```

**解析：** 该题主要考察的是对二叉树的遍历和递归的理解。通过前序遍历和中序遍历的结果，我们可以找到根节点，然后根据中序遍历的结果将树分为左右子树，递归地构建二叉树。

#### 2. 剑指 Offer 中的问题：旋转数组的最小数字

**题目描述：** 把一个数组最外层的数字依次向内移动，例如数组 `[1,2,3,4,5]` 移动后变为 `[5,4,3,2,1]`。

**解答：**

```go
func minArray(nums []int) int {
    n := len(nums)
    if n < 2 {
        return nums[0]
    }
    low, high := 0, n-1
    for low < high {
        mid := (low + high) >> 1
        if nums[mid] > nums[high] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}
```

**解析：** 该题采用二分查找的方法，寻找数组中第一个比右边元素小的数，即旋转后的最小元素。

#### 3. 剑指 Offer 中的问题：斐波那契数列

**题目描述：** 写一个函数，输入一个非负整数 n，返回该数对应的斐波那契数列的第 n 项。

**解答：**

```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for ; n > 1; n-- {
        a, b = b, a+b
    }
    return b
}
```

**解析：** 该题利用迭代的方式，避免递归带来的大量重复计算，实现斐波那契数列的求解。

### 算法编程题库

#### 1. LeetCode 上的问题：合并两个有序链表

**题目描述：** 将两个升序排列的链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**解答：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    var dummy *ListNode
    pre := &ListNode{}
    dummy = pre
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            pre.Next = l1
            l1 = l1.Next
        } else {
            pre.Next = l2
            l2 = l2.Next
        }
        pre = pre.Next
    }
    if l1 != nil {
        pre.Next = l1
    } else if l2 != nil {
        pre.Next = l2
    }
    return dummy.Next
}
```

**解析：** 该题使用虚拟头节点的方式，将两个链表依次合并，最后返回虚拟头节点的下一个节点。

#### 2. LeetCode 上的问题：两数相加

**题目描述：** 给你两个非空链表表示两个非负整数，它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。请将这两个数相加，并以相同形式返回一个表示和的链表。

**解答：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    pre := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry != 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        sum := val1 + val2 + carry
        carry = sum / 10
        pre.Next = &ListNode{Val: sum % 10}
        pre = pre.Next
    }
    return dummy.Next
}
```

**解析：** 该题利用一个额外的变量 `carry` 来存储每次相加后可能产生的进位，确保每一位的运算都正确。

#### 3. LeetCode 上的问题：三数和

**题目描述：** 给定一个包含 n 个整数的数组 nums，判断是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

**解答：**

```go
func threeSum(nums []int) [][]int {
    res := [][]int{}
    sort.Ints(nums)
    n := len(nums)
    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

**解析：** 该题使用排序加双指针的方法，先对数组进行排序，然后固定一个数，使用双指针在剩余的数组中寻找另外两个数的组合，避免重复解。

