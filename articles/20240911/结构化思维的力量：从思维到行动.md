                 

### 主题：结构化思维的力量：从思维到行动

#### 面试题和算法编程题库

##### 1. 阿里巴巴 - 链表环检测问题

**题目描述：** 给定一个链表，判断链表中是否存在环。

**示例：**
```
输入: 3 -> 2 -> 0 -> -4
输出: 环
```

**答案：**

```go
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```

**解析：** 使用快慢指针法，快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，快指针最终会追上慢指针。

##### 2. 腾讯 - 二分查找问题

**题目描述：** 在排序数组中查找一个特定的元素。

**示例：**
```
输入: [1, 3, 5, 6], target = 5
输出: true
```

**答案：**

```go
func binarySearch(nums []int, target int) bool {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return true
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return false
}
```

**解析：** 使用二分查找算法，逐步缩小查找范围，直到找到目标元素或确定其不存在。

##### 3. 字节跳动 - 字符串匹配问题

**题目描述：** 给定两个字符串，判断其中一个字符串是否是另一个字符串的子串。

**示例：**
```
输入: "hello", "helloworld"
输出: true
```

**答案：**

```go
func isSubstring(s1, s2 string) bool {
    n1, n2 := len(s1), len(s2)
    if n1 > n2 {
        return false
    }
    for i := 0; i <= n2-n1; i++ {
        if s2[i:i+n1] == s1 {
            return true
        }
    }
    return false
}
```

**解析：** 通过遍历 s2，每次取长度为 n1 的子串与 s1 进行比较，判断是否相等。

##### 4. 京东 - 动态规划问题

**题目描述：** 给定一个数组和两个目标值，找到数组中两个数的组合，使得它们的和等于目标值。

**示例：**
```
输入: [2, 7, 11, 15], target = 9
输出: [[2, 7] 或 [11, -2]]
```

**答案：**

```go
func twoSum(nums []int, target int) [][]int {
    var res [][]int
    for i := 0; i < len(nums); i++ {
        for j := i + 1; j < len(nums); j++ {
            if nums[i]+nums[j] == target {
                res = append(res, []int{i, j})
            }
        }
    }
    return res
}
```

**解析：** 使用双重循环遍历数组，检查每一对数字的和是否等于目标值，如果相等则添加到结果数组中。

##### 5. 美团 - 并发编程问题

**题目描述：** 请实现一个线程安全的缓存，支持 GET 和 PUT 操作。

**示例：**
```
输入: ["LRUCache", "get", "put", "get", "put", "get"]
[[2], [1], [2], [3], [4], [4]]
输出: [null, -1, null, -1, null, 4]
```

**答案：**

```go
type LRUCache struct {
    m     map[int]int
    keys  []int
    size  int
    lock  sync.RWMutex
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        m:   make(map[int]int),
        keys: make([]int, 0, capacity),
        size: capacity,
    }
}

func (this *LRUCache) Get(key int) int {
    this.lock.RLock()
    defer this.lock.RUnlock()
    if v, ok := this.m[key]; ok {
        idx := this.indexOfKey(key)
        this.keys = append(this.keys[:idx], this.keys[idx+1:]...)
        this.keys = append([]int{key}, this.keys...)
        return v
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    this.lock.Lock()
    defer this.lock.Unlock()
    if v, ok := this.m[key]; ok {
        this.m[key] = value
        idx := this.indexOfKey(key)
        this.keys = append(this.keys[:idx], this.keys[idx+1:]...)
        this.keys = append([]int{key}, this.keys...)
    } else {
        this.m[key] = value
        this.keys = append(this.keys, key)
        if len(this.keys) > this.size {
            delete(this.m, this.keys[0])
            this.keys = this.keys[1:]
        }
    }
}

func (this *LRUCache) indexOfKey(key int) int {
    for i, k := range this.keys {
        if k == key {
            return i
        }
    }
    return -1
}
```

**解析：** 使用读写锁实现一个线程安全的 LRU 缓存，其中 m 存储键值对，keys 存储所有键的有序列表。

##### 6. 小红书 - 递归问题

**题目描述：** 实现一个递归函数，计算斐波那契数列的第 n 项。

**示例：**
```
输入: n = 5
输出: 5
```

**答案：**

```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    return fib(n-1) + fib(n-2)
}
```

**解析：** 使用递归实现斐波那契数列的计算，递归终止条件为 n <= 1。

##### 7. 拼多多 - 数组问题

**题目描述：** 给定一个整数数组，找到所有三个数的组合，使其和等于一个特定的目标值。

**示例：**
```
输入: nums = [1, 4, 5, 3, 2], target = 6
输出: [[1, 3, 2], [1, 4, 1], [2, 3, 1]]
```

**答案：**

```go
func threeSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

**解析：** 对数组进行排序，然后使用双重指针遍历数组，找到所有三个数的组合使其和等于目标值。

##### 8. 百度 - 图问题

**题目描述：** 给定一个无向图，找到图中所有的最长路径。

**示例：**
```
输入:
0 ----> 1
|   |
2 ----> 3

输出: [0, 1, 2, 3]
```

**答案：**

```go
func longestPath(graph [][]int) []int {
    n := len(graph)
    dist := make([]int, n)
    indeg := make([]int, n)
    for i := range graph {
        for _, j := range graph[i] {
            indeg[j]++
        }
    }
    var q []int
    for i, d := range indeg {
        if d == 0 {
            q = append(q, i)
            dist[i] = -1
        }
    }
    for len(q) > 0 {
        v := q[0]
        q = q[1:]
        for _, w := range graph[v] {
            indeg[w]--
            if indeg[w] == 0 {
                q = append(q, w)
                dist[w] = dist[v] - 1
            }
        }
    }
    var ans []int
    for i, d := range dist {
        if d >= 0 {
            if len(ans) == 0 || d > ans[0] {
                ans = []int{i}
            } else if d == ans[0] {
                ans = append(ans, i)
            }
        }
    }
    return ans
}
```

**解析：** 使用拓扑排序找到所有节点的最长路径，并返回结果。

##### 9. 蚂蚁支付宝 - 数据结构问题

**题目描述：** 给定一个整数数组，找出所有出现次数超过数组长度一半的元素。

**示例：**
```
输入: [1, 2, 2, 2, 3]
输出: 2
```

**答案：**

```go
func majorityElement(nums []int) int {
    count := 0
    candidate := 0
    for _, num := range nums {
        if count == 0 {
            candidate = num
            count = 1
        } else if candidate == num {
            count++
        } else {
            count--
        }
    }
    count = 0
    for _, num := range nums {
        if candidate == num {
            count++
        }
    }
    if count > len(nums)/2 {
        return candidate
    }
    return -1
}
```

**解析：** 使用摩尔投票算法，找到出现次数超过数组长度一半的元素。

##### 10. 快手 - 算法优化问题

**题目描述：** 给定一个字符串，找出最长的回文子串。

**示例：**
```
输入: "babad"
输出: "bab" 或 "aba"
```

**答案：**

```go
func longestPalindrome(s string) string {
    n := len(s)
    if n < 2 {
        return s
    }
    start, maxLen := 0, 1
    for i := 0; i < n; i++ {
        len1, len2 := expandAroundCenter(s, i, i), expandAroundCenter(s, i, i+1)
        len := max(len1, len2)
        if len > maxLen {
            maxLen = len
            start = i - (len - 1) / 2
        }
    }
    return s[start : start+maxLen]
}

func expandAroundCenter(s string, left, right int) int {
    for left >= 0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return right - left - 1
}
```

**解析：** 使用中心扩散法找到最长回文子串，将字符串分为奇数和偶数长度的回文子串，分别扩展左右边界。

##### 11. 字节跳动 - 网络问题

**题目描述：** 设计一个缓存系统，支持 GET 和 PUT 操作。

**示例：**
```
输入: ["LRUCache", "get", "put", "get", "put"]
[[2], [1], [2], [3], [4]]
输出: [null, -1, null, -1, null]
```

**答案：**

```go
type LRUCache struct {
    m     map[int]int
    keys  []int
    size  int
    lock  sync.RWMutex
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        m:   make(map[int]int),
        keys: make([]int, 0, capacity),
        size: capacity,
    }
}

func (this *LRUCache) Get(key int) int {
    this.lock.RLock()
    defer this.lock.RUnlock()
    if v, ok := this.m[key]; ok {
        idx := this.indexOfKey(key)
        this.keys = append(this.keys[:idx], this.keys[idx+1:]...)
        this.keys = append([]int{key}, this.keys...)
        return v
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    this.lock.Lock()
    defer this.lock.Unlock()
    if v, ok := this.m[key]; ok {
        this.m[key] = value
        idx := this.indexOfKey(key)
        this.keys = append(this.keys[:idx], this.keys[idx+1:]...)
        this.keys = append([]int{key}, this.keys...)
    } else {
        this.m[key] = value
        this.keys = append(this.keys, key)
        if len(this.keys) > this.size {
            delete(this.m, this.keys[0])
            this.keys = this.keys[1:]
        }
    }
}

func (this *LRUCache) indexOfKey(key int) int {
    for i, k := range this.keys {
        if k == key {
            return i
        }
    }
    return -1
}
```

**解析：** 使用读写锁实现一个线程安全的 LRU 缓存，其中 m 存储键值对，keys 存储所有键的有序列表。

##### 12. 小红书 - 数学问题

**题目描述：** 计算斐波那契数列的第 n 项。

**示例：**
```
输入: n = 5
输出: 5
```

**答案：**

```go
func fib(n int) int {
    if n <= 1 {
        return n
    }
    a, b := 0, 1
    for i := 2; i <= n; i++ {
        c := a + b
        a = b
        b = c
    }
    return b
}
```

**解析：** 使用动态规划计算斐波那契数列的第 n 项。

##### 13. 京东 - 字符串问题

**题目描述：** 给定一个字符串，找到其中第一个重复的子串。

**示例：**
```
输入: "abcabcabcabc"
输出: "abc"
```

**答案：**

```go
func firstRepeatedSubstring(s string) string {
    n := len(s)
    for i := 1; i <= n/2; i++ {
        if n%i == 0 {
            sub := s[:i]
            for j := i; j < n-i+1; j += i {
                if s[j:j+i] == sub {
                    return sub
                }
            }
        }
    }
    return ""
}
```

**解析：** 遍历字符串长度的一半，判断是否存在重复的子串。

##### 14. 拼多多 - 回溯问题

**题目描述：** 给定一个无重复数字的数组，返回所有可能的全排列。

**示例：**
```
输入: [1, 2, 3]
输出: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
```

**答案：**

```go
func permute(nums []int) [][]int {
    var res [][]int
    var backtrack func([]int)
    visited := make([]bool, len(nums))
    backtrack = func(arr []int) {
        if len(arr) == len(nums) {
            res = append(res, append([]int{}, arr...))
            return
        }
        for i, v := range nums {
            if visited[i] {
                continue
            }
            visited[i] = true
            arr = append(arr, v)
            backtrack(arr)
            arr = arr[:len(arr)-1]
            visited[i] = false
        }
    }
    backtrack([]int{})
    return res
}
```

**解析：** 使用回溯算法生成所有可能的排列。

##### 15. 字节跳动 - 算法问题

**题目描述：** 给定一个字符串，判断它是否是回文串。

**示例：**
```
输入: "racecar"
输出: true
```

**答案：**

```go
func isPalindrome(s string) bool {
    n := len(s)
    i, j := 0, n-1
    for i < j {
        if s[i] != s[j] {
            return false
        }
        i++
        j--
    }
    return true
}
```

**解析：** 遍历字符串，比较两端字符是否相等，直到中间位置。

##### 16. 蚂蚁支付宝 - 栈和队列问题

**题目描述：** 设计一个支持基本操作和查询最大元素的栈。

**示例：**
```
输入: ["MaxStack", "push", "push", "max", "pop", "top"]
[[], [5], [7], [], [], []]
输出: [null, null, null, 7, 5, 7]
```

**答案：**

```go
type MaxStack struct {
    stk     []int
    maxStk  []int
}

func Constructor() MaxStack {
    return MaxStack{
        stk:    make([]int, 0),
        maxStk: make([]int, 0),
    }
}

func (this *MaxStack) Push(x int) {
    this.stk = append(this.stk, x)
    if len(this.maxStk) == 0 || x >= this.maxStk[len(this.maxStk)-1] {
        this.maxStk = append(this.maxStk, x)
    }
}

func (this *MaxStack) Pop() {
    if this.stk[len(this.stk)-1] == this.maxStk[len(this.maxStk)-1] {
        this.maxStk = this.maxStk[:len(this.maxStk)-1]
    }
    this.stk = this.stk[:len(this.stk)-1]
}

func (this *MaxStack) Top() int {
    return this.stk[len(this.stk)-1]
}

func (this *MaxStack) Max() int {
    return this.maxStk[len(this.maxStk)-1]
}
```

**解析：** 使用两个栈，一个存储元素，一个存储最大元素，保证每次插入和删除操作的时间复杂度为 O(1)。

##### 17. 美团 - 树问题

**题目描述：** 给定一个二叉树，返回其节点值的锯齿形层次遍历结果。

**示例：**
```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

**答案：**

```go
func zigzagLevelOrder(root *TreeNode) [][]int {
    var res [][]int
    if root == nil {
        return res
    }
    var q []*TreeNode
    q = append(q, root)
    leftToRight := true
    for len(q) > 0 {
        level := []int{}
        nextQ := []*TreeNode{}
        for _, node := range q {
            level = append(level, node.Val)
            if node.Left != nil {
                nextQ = append(nextQ, node.Left)
            }
            if node.Right != nil {
                nextQ = append(nextQ, node.Right)
            }
        }
        if !leftToRight {
            reverse(level)
        }
        res = append(res, level)
        leftToRight = !leftToRight
        q = nextQ
    }
    return res
}

func reverse(arr []int) {
    n := len(arr)
    for i := 0; i < n/2; i++ {
        arr[i], arr[n-i-1] = arr[n-i-1], arr[i]
    }
}
```

**解析：** 使用广度优先搜索遍历二叉树，交替排列每一层的节点值。

##### 18. 百度 - 算法优化问题

**题目描述：** 给定一个字符串，找到它的最长公共前缀。

**示例：**
```
输入: ["flower","flow","flight"]
输出: "fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i, v := range strs[0] {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || v != strs[j][i] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

**解析：** 逐个比较字符串的前缀，直到找到不同的字符。

##### 19. 拼多多 - 算法问题

**题目描述：** 给定一个整数数组，找到和为特定值的三个数。

**示例：**
```
输入: [-1, 0, 1, 2, -1, -4], target = 0
输出: [[-1, 0, 1]]
```

**答案：**

```go
func threeSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

**解析：** 使用排序和双指针方法，找到和为特定值的三个数。

##### 20. 字节跳动 - 字符串匹配问题

**题目描述：** 设计一个支持基本操作的字符串匹配算法。

**示例：**
```
输入: ["WordDictionary", "addWord", "addWord", "search", "search"]
[[], ["bad"], ["dad"], ["bad", "dad", "mad"], ["pad"], ["bad"]]
输出: [null, null, null, true, false]
```

**答案：**

```go
type WordDictionary struct {
    nodes map[rune]*WordDictionary
}

func Constructor() WordDictionary {
    return WordDictionary{
        nodes: make(map[rune]*WordDictionary),
    }
}

func (w *WordDictionary) AddWord(word string) {
    node := w
    for _, r := range word {
        if node.nodes[r] == nil {
            node.nodes[r] = &WordDictionary{
                nodes: make(map[rune]*WordDictionary),
            }
        }
        node = node.nodes[r]
    }
    node.isEnd = true
}

func (w *WordDictionary) Search(word string) bool {
    return w.search(word, 0)
}

func (w *WordDictionary) search(word string, i int) bool {
    if i == len(word) {
        return w.isEnd
    }
    r := rune(word[i])
    if w.nodes[r] == nil {
        return false
    }
    return w.nodes[r].search(word, i+1)
}
```

**解析：** 使用前缀树实现字符串匹配，支持添加单词和搜索功能。

##### 21. 滴滴 - 数据结构问题

**题目描述：** 设计一个支持基本操作的堆数据结构。

**示例：**
```
输入: ["Heap", "push", "push", "pop", "top"]
[[], [3], [2], [], []]
输出: [null, null, null, 2, 3]
```

**答案：**

```go
type Heap struct {
    data []int
}

func Constructor() Heap {
    return Heap{
        data: []int{0},
    }
}

func (h *Heap) Push(val int) {
    h.data = append(h.data, val)
    h.heapifyUp(len(h.data)-1)
}

func (h *Heap) Pop() {
    if len(h.data) == 1 {
        h.data = h.data[:0]
        return
    }
    h.data[1], h.data[len(h.data)-1] = h.data[len(h.data)-1], h.data[1]
    h.data = h.data[:len(h.data)-1]
    h.heapifyDown(1)
}

func (h *Heap) Top() int {
    return h.data[1]
}

func (h *Heap) heapifyUp(index int) {
    parent := (index - 1) / 2
    if index > 1 && h.data[parent] < h.data[index] {
        h.data[parent], h.data[index] = h.data[index], h.data[parent]
        h.heapifyUp(parent)
    }
}

func (h *Heap) heapifyDown(index int) {
    left := 2 * index + 1
    right := 2 * index + 2
    largest := index
    if left < len(h.data) && h.data[left] > h.data[largest] {
        largest = left
    }
    if right < len(h.data) && h.data[right] > h.data[largest] {
        largest = right
    }
    if largest != index {
        h.data[index], h.data[largest] = h.data[largest], h.data[index]
        h.heapifyDown(largest)
    }
}
```

**解析：** 使用数组实现堆数据结构，支持插入、删除和获取堆顶元素操作。

##### 22. 小红书 - 算法优化问题

**题目描述：** 给定一个整数数组，找到所有三个数的组合，使其和等于特定值。

**示例：**
```
输入: nums = [1, 4, 5, 3, 2], target = 6
输出: [[1, 3, 2], [1, 4, 1], [2, 3, 1]]
```

**答案：**

```go
func threeSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

**解析：** 对数组进行排序，使用双指针方法找到所有三个数的组合使其和等于目标值。

##### 23. 美团 - 图问题

**题目描述：** 给定一个有向图，判断是否存在一条路径，使其经过所有节点。

**示例：**
```
输入:
0 ----> 1
|   |
2 ----> 3

输出: true
```

**答案：**

```go
func canVisitAllRooms(rooms [][]int) bool {
    visited := make([]bool, len(rooms))
    var dfs func(int)
    dfs = func房间 int {
        visited[房间] = true
        for _, next := range rooms[房间] {
            if !visited[next] {
                dfs(next)
            }
        }
    }
    dfs(0)
    for _, v := range visited {
        if !v {
            return false
        }
    }
    return true
}
```

**解析：** 使用深度优先搜索遍历图，判断是否所有房间都被访问过。

##### 24. 字节跳动 - 算法问题

**题目描述：** 给定一个字符串，判断它是否是整数。

**示例：**
```
输入: "42"
输出: true
```

**答案：**

```go
func isInteger(s string) bool {
    n := len(s)
    if n == 0 {
        return false
    }
    if s[0] == '-' || s[0] == '+' {
        n--
    }
    for i := 0; i < n; i++ {
        if s[i] < '0' || s[i] > '9' {
            return false
        }
    }
    return true
}
```

**解析：** 遍历字符串，判断是否只包含数字字符。

##### 25. 京东 - 并发编程问题

**题目描述：** 请实现一个生产者 - 消费者模型，支持高并发操作。

**示例：**
```
输入: ["BoundedBuffer", "produce", "produce", "consume", "consume"]
[[2], [1], [2], [], []]
输出: [null, true, true, 1, 2]
```

**答案：**

```go
type BoundedBuffer struct {
    ch    chan int
    limit int
}

func Constructor(capacity int) BoundedBuffer {
    return BoundedBuffer{
        ch:    make(chan int, capacity),
        limit: capacity,
    }
}

func (b *BoundedBuffer) Produce(item int) bool {
    if len(b.ch) >= b.limit {
        return false
    }
    b.ch <- item
    return true
}

func (b *BoundedBuffer) Consume() int {
    if len(b.ch) == 0 {
        return -1
    }
    return <-b.ch
}
```

**解析：** 使用带缓冲的通道实现生产者 - 消费者模型，保证高并发操作。

##### 26. 腾讯 - 算法问题

**题目描述：** 给定一个无重复数字的数组，返回所有可能的子集。

**示例：**
```
输入: nums = [1, 2, 3]
输出: [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
```

**答案：**

```go
func subsets(nums []int) [][]int {
    var res [][]int
    var backtrack func([]int)
    backtrack = func(arr []int) {
        res = append(res, append([]int{}, arr...))
        for i := range nums {
            if i > 0 && nums[i] == nums[i-1] {
                continue
            }
            arr = append(arr, nums[i])
            backtrack(arr)
            arr = arr[:len(arr)-1]
        }
    }
    backtrack([]int{})
    return res
}
```

**解析：** 使用回溯算法生成所有可能的子集。

##### 27. 阿里巴巴 - 数据结构问题

**题目描述：** 请实现一个栈，支持栈顶元素、入栈和出栈操作。

**示例：**
```
输入: ["Stack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出: [null, true, true, 2, true, false]
```

**答案：**

```go
type Stack struct {
    data []int
}

func Constructor() Stack {
    return Stack{
        data: []int{},
    }
}

func (s *Stack) Push(x int) {
    s.data = append(s.data, x)
}

func (s *Stack) Pop() bool {
    if len(s.data) == 0 {
        return false
    }
    s.data = s.data[:len(s.data)-1]
    return true
}

func (s *Stack) Top() int {
    return s.data[len(s.data)-1]
}

func (s *Stack) Empty() bool {
    return len(s.data) == 0
}
```

**解析：** 使用数组实现栈，支持栈顶元素、入栈和出栈操作。

##### 28. 拼多多 - 数学问题

**题目描述：** 计算两个整数的最大公约数。

**示例：**
```
输入: a = 15, b = 5
输出: 5
```

**答案：**

```go
func gcd(a int, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

**解析：** 使用辗转相除法计算最大公约数。

##### 29. 小红书 - 字符串问题

**题目描述：** 给定一个字符串，返回其最长公共前缀。

**示例：**
```
输入: ["flower","flow","flight"]
输出: "fl"
```

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    prefix := ""
    for i, v := range strs[0] {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || v != strs[j][i] {
                return prefix
            }
        }
        prefix += string(v)
    }
    return prefix
}
```

**解析：** 遍历字符串，比较前缀，直到找到不同的字符。

##### 30. 字节跳动 - 算法问题

**题目描述：** 给定一个整数数组，返回其中两个数的组合，使其和等于特定值。

**示例：**
```
输入: nums = [2, 7, 11, 15], target = 9
输出: [[2, 7]]
```

**答案：**

```go
func twoSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    for i := 0; i < len(nums)-1; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == target {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < target {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

**解析：** 对数组进行排序，使用双指针方法找到两个数的组合使其和等于目标值。

