                 

### 2025年华为校招技术面试题集锦：算法与编程挑战

#### 1. 股票买卖交易策略

**题目：** 给定一个整数数组 `prices`，其中 `prices[i]` 是第 `i` 天股票的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖 一只股票）。

**答案：**

要获取最大利润，我们可以采用贪心算法。每次交易，我们都会选择在价格较低的时候买入，在价格较高的时候卖出。

**示例代码：**

```go
func maxProfit(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}
```

**解析：** 我们遍历数组 `prices`，只要发现后一天的价格比前一天高，就进行一次交易，利润累加。这种方法称为“贪心算法”，因为它总是选择当前最优的局部操作。

#### 2. 字符串匹配（KMP 算法）

**题目：** 给定两个字符串 `s` 和 `p`，实现一个支持 KMP（Knuth-Morris-Pratt）字符串匹配算法的函数，实现 `strStr` 功能：在字符串 `s` 中寻找字符串 `p` 的第一个出现位置。

**答案：**

KMP 算法的核心在于预处理字符串 `p`，计算出它的最长前后缀数组（lps）。在搜索过程中，利用 lps 数组，我们可以避免不必要的字符比较。

**示例代码：**

```go
func computeLPSArray(pattern string) []int {
    lps := make([]int, len(pattern))
    length := 0
    lps[0] = 0
    i := 1
    
    while (i < len(pattern)):
        if (pattern[i] == pattern[length]):
            length += 1
            lps[i] = length
            i += 1
        else:
            if (length != 0):
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1

    return lps
}

func strStr(haystack string, needle string) int {
    if needle == "":
        return 0

    lps := computeLPSArray(needle)
    i := 0
    j := 0

    while i < len(haystack):
        if needle[j] == haystack[i]:
            i += 1
            j += 1
        if j == len(needle):
            return i - j
        elif i < len(haystack) and needle[j] != haystack[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return -1
}
```

**解析：** 我们先计算 `p` 的 lps 数组，然后使用两个指针 `i` 和 `j` 分别遍历 `s` 和 `p`。如果 `s[i]` 不等于 `p[j]`，我们根据 lps 数组更新 `j` 的值。

#### 3. 快排优化

**题目：** 实现快速排序算法，并优化其性能。

**答案：**

快速排序的优化方法主要包括：

* 避免选择最左或最右的元素作为枢轴，以减少数据已排序的情况。
* 小于等于枢轴的元素放在一个列表中，大于枢轴的元素放在另一个列表中。
* 对于小数据集，使用插入排序代替快速排序。

**示例代码：**

```go
func quickSort(arr []int) {
    if len(arr) <= 1 {
        return
    }
    pivot := arr[len(arr)/2]
    left := make([]int, 0)
    middle := make([]int, 0)
    right := make([]int, 0)

    for _, v := range arr {
        if v < pivot {
            left = append(left, v)
        } else if v == pivot {
            middle = append(middle, v)
        } else {
            right = append(right, v)
        }
    }

    quickSort(left)
    quickSort(right)

    arr = append(append(left, middle...), right...)
}
```

**解析：** 我们选择中间的元素作为枢轴，然后将数组分为小于等于和大于枢轴的两个列表，递归排序。

#### 4. 连接两个链表

**题目：** 给定两个已经排序的单链表，将它们合并为一个链表，并保持排序顺序。

**答案：**

我们可以采用归并排序的思想，创建一个新的链表，然后比较两个链表的头节点，将较小的节点添加到新链表中，然后移动相应链表的指针。

**示例代码：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}
```

**解析：** 我们创建一个虚拟头节点 `dummy`，然后逐个比较两个链表的头节点，将较小的节点添加到新链表中。

#### 5. 反转链表

**题目：** 实现一个函数，反转一个单链表。

**答案：**

我们可以使用迭代或递归的方法来实现链表反转。

**迭代示例代码：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head

    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }

    return prev
}
```

**递归示例代码：**

```go
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    newHead := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

**解析：** 我们使用迭代或递归的方法，逐个将链表的节点反转，最终返回新的头节点。

#### 6. 字符串匹配（暴力法）

**题目：** 给定两个字符串 `s` 和 `p`，实现一个函数 `strStr`，找出 `p` 在 `s` 中的第一个出现位置。

**答案：**

我们可以使用双重循环，遍历字符串 `s` 和 `p`，检查 `p` 是否在 `s` 中。

**示例代码：**

```go
func strStr(s string, p string) int {
    n, m := len(s), len(p)
    for i := 0; i <= n-m; i++ {
        if s[i:i+m] == p {
            return i
        }
    }
    return -1
}
```

**解析：** 我们逐个检查字符串 `s` 的每个子串，与 `p` 进行比较，找到第一个匹配的位置。

#### 7. 单调栈

**题目：** 给定一个数组 `prices`，找出每个元素在数组中的下一个更大元素。

**答案：**

我们可以使用单调栈来解决这个问题。栈中保存的是元素的索引，栈顶元素总是当前已遍历元素中最大的。

**示例代码：**

```go
func nextGreaterElements(nums []int) []int {
    n := len(nums)
    result := make([]int, n)
    stack := []int{}

    for i := 0; i < 2*n; i++ {
        while (stack and nums[stack[len(stack)-1]] <= nums[i]):
            stack = stack[:len(stack)-1]
        if stack:
            result[i%n] = nums[stack[len(stack)-1]]
        stack = append(stack, i)
    }

    return result
}
```

**解析：** 我们遍历数组 `nums` 的两个副本，利用单调栈找到每个元素的下一个更大元素。当栈不为空且栈顶元素小于当前元素时，我们弹出栈顶元素，更新结果。

#### 8. 两个有序数组的合并

**题目：** 给定两个有序整数数组 `nums1` 和 `nums2`，将它们合并为一个有序数组 `nums1`。

**答案：**

我们可以使用归并排序的思想，两个指针分别指向两个数组的尾部，比较两个指针指向的元素，将较大的元素放入 `nums1` 中。

**示例代码：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2 := m-1, n-1
    t := m + n - 1
    for p1 >= 0 and p2 >= 0:
        if nums1[p1] > nums2[p2]:
            nums1[t] = nums1[p1]
            p1 -= 1
        else:
            nums1[t] = nums2[p2]
            p2 -= 1
        t -= 1
    for p2 >= 0:
        nums1[t] = nums2[p2]
        p2 -= 1
        t -= 1
}
```

**解析：** 我们从两个数组的尾部开始比较，将较大的元素放到 `nums1` 的尾部。如果 `nums2` 还有剩余元素，我们将其直接复制到 `nums1` 中。

#### 9. 链表中的环

**题目：** 给定一个链表，检查链表中是否存在环。

**答案：**

我们可以使用快慢指针法。快指针每次移动两个节点，慢指针每次移动一个节点。如果链表中存在环，快指针最终会追上慢指针。

**示例代码：**

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head

    for fast != nil and fast.Next != nil:
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast:
            return true

    return false
}
```

**解析：** 我们使用快慢指针法，遍历链表。如果快指针和慢指针相遇，说明链表中存在环。

#### 10. 翻转字符串中的单词

**题目：** 给定一个字符串，编写一个函数，将字符串中的单词进行反转。

**答案：**

我们可以先将字符串分割成单词，然后使用双指针法将每个单词反转，最后将反转后的单词拼接成一个字符串。

**示例代码：**

```go
func reverseWords(s string) string {
    words := strings.Fields(s)
    n := len(words)

    for i := 0; i < n; i++ {
        start, end := 0, len(words[i])-1
        for start < end {
            words[i][start], words[i][end] = words[i][end], words[i][start]
            start++
            end--
        }
    }

    return strings.Join(words, " ")
}
```

**解析：** 我们先将字符串分割成单词，然后使用双指针法将每个单词反转，最后将反转后的单词拼接成一个字符串。

#### 11. 合并区间

**题目：** 给定一个区间列表，找到需要合并的区间。

**答案：**

我们可以先将区间按照起始点排序，然后遍历区间列表，检查当前区间是否与前一个区间重叠。如果重叠，我们合并两个区间。

**示例代码：**

```go
type Interval struct {
    Start int
    End   int
}

func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    var result [][]int
    for _, interval := range intervals {
        if len(result) == 0 or result[len(result)-1][1] < interval[0] {
            result = append(result, interval)
        } else {
            result[len(result)-1][1] = max(result[len(result)-1][1], interval[1])
        }
    }

    return result
}
```

**解析：** 我们先将区间列表按照起始点排序，然后遍历区间列表，检查当前区间是否与前一个区间重叠。如果重叠，我们合并两个区间。

#### 12. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个搜索函数来找出给定目标值的位置。

**答案：**

我们可以使用二分查找法，但需要特殊处理旋转的情况。我们在每次迭代时检查中间元素是否等于目标值。如果不等，我们检查中间元素是否小于区间的左端点，以确定新的搜索区间。

**示例代码：**

```go
func search(nums []int, target int) int {
    n := len(nums)
    left, right := 0, n-1

    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        }
        if nums[mid] >= nums[left] {
            if target >= nums[left] and target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] and target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }

    return -1
}
```

**解析：** 我们使用二分查找法，每次迭代时，根据中间元素是否等于目标值以及中间元素与区间的左右端点的关系，确定新的搜索区间。

#### 13. 合并二叉树

**题目：** 给定两个二叉树，实现一个函数来合并它们为一个新的二叉树。合并的规则是：如果两个节点重叠，那么将他们的值相加作为新节点的值，否则，不为空的两个节点中，保留不为空的节点并将其作为新节点的左右子节点。

**答案：**

我们可以使用递归方法，遍历两个二叉树的节点，按照合并规则进行操作。

**示例代码：**

```go
func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode {
    if t1 == nil {
        return t2
    }
    if t2 == nil {
        return t1
    }
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left, t2.Left)
    t1.Right = mergeTrees(t1.Right, t2.Right)
    return t1
}
```

**解析：** 我们递归遍历两个二叉树的节点，将它们的值相加作为新节点的值，然后递归合并左右子树。

#### 14. 最小栈

**题目：** 设计一个支持 push、pop、top 操作，并能在常数时间内检索到最小元素的栈。

**答案：**

我们可以使用两个栈，一个用于存储元素，另一个用于存储当前的最小元素。

**示例代码：**

```go
type MinStack struct {
    s1 []int
    s2 []int
}

func Constructor() MinStack {
    return MinStack{s1: []int{}, s2: []int{}}
}

func (this *MinStack) Push(x int) {
    this.s1 = append(this.s1, x)
    if len(this.s2) == 0 or x < this.s2[len(this.s2)-1] {
        this.s2 = append(this.s2, x)
    } else {
        this.s2 = append(this.s2, this.s2[len(this.s2)-1])
    }
}

func (this *MinStack) Pop() {
    if this.s1[len(this.s1)-1] == this.s2[len(this.s2)-1] {
        this.s2 = this.s2[:len(this.s2)-1]
    }
    this.s1 = this.s1[:len(this.s1)-1]
}

func (this *MinStack) Top() int {
    return this.s1[len(this.s1)-1]
}

func (this *MinStack) GetMin() int {
    return this.s2[len(this.s2)-1]
}
```

**解析：** 我们使用两个栈，一个用于存储元素，另一个用于存储当前的最小元素。在 push 操作时，我们比较新元素和当前最小元素，更新最小元素栈。

#### 15. 设计哈希表

**题目：** 设计一个哈希表，实现 put、get 和 delete 操作。

**答案：**

我们可以使用拉链法解决哈希冲突，每个链表的长度不超过负载因子（例如 0.75）。在哈希表中，键值对作为链表的一个节点存储。

**示例代码：**

```go
type HashTable struct {
    buckets []*Node
    size    int
    capacity int
    loadFactor float64
}

type Node struct {
    key   int
    value int
    next  *Node
}

func (ht *HashTable) Put(key int, value int) {
    index := hash(key, ht.capacity)
    node := &Node{key: key, value: value}

    if ht.buckets[index] == nil {
        ht.buckets[index] = node
        ht.size++
    } else {
        curr := ht.buckets[index]
        for curr.next != nil {
            if curr.key == key {
                curr.value = value
                return
            }
            curr = curr.next
        }
        curr.next = node
        ht.size++
    }

    if float64(ht.size) > ht.loadFactor * float64(ht.capacity) {
        ht.resize()
    }
}

func (ht *HashTable) Get(key int) int {
    index := hash(key, ht.capacity)
    curr := ht.buckets[index]
    for curr != nil {
        if curr.key == key {
            return curr.value
        }
        curr = curr.next
    }
    return -1
}

func (ht *HashTable) Delete(key int) {
    index := hash(key, ht.capacity)
    curr := ht.buckets[index]
    prev := nil

    for curr != nil {
        if curr.key == key {
            if prev == nil {
                ht.buckets[index] = curr.next
            } else {
                prev.next = curr.next
            }
            ht.size--
            return
        }
        prev = curr
        curr = curr.next
    }
}

func (ht *HashTable) resize() {
    ht.capacity *= 2
    newBuckets := make([]*Node, ht.capacity)

    for _, bucket := range ht.buckets {
        curr := bucket
        for curr != nil {
            index := hash(curr.key, ht.capacity)
            node := &Node{key: curr.key, value: curr.value}

            if newBuckets[index] == nil {
                newBuckets[index] = node
            } else {
                prev := newBuckets[index]
                for prev.next != nil {
                    prev = prev.next
                }
                prev.next = node
            }
            curr = curr.next
        }
    }

    ht.buckets = newBuckets
    ht.loadFactor = 0.75
}
```

**解析：** 我们使用拉链法解决哈希冲突，每个链表的长度不超过负载因子。当负载因子超过阈值时，我们重新调整哈希表的大小。

#### 16. 设计 Twitter

**题目：** 设计一个简化版的 Twitter。实现推文功能、获取关注者最近的推文以及获取关注者列表。

**答案：**

我们可以使用一个哈希表存储用户的推文和关注者列表。每个用户有一个唯一的标识符，用于唯一标识。

**示例代码：**

```go
type User struct {
    ID       int
    Tweets   []*Tweet
    Followers map[int]bool
}

type Tweet struct {
    ID        int
    UserID    int
    Content   string
    CreatedAt time.Time
}

type Twitter struct {
    users     map[int]*User
    nextID    int
}

func Constructor() Twitter {
    return Twitter{users: map[int]*User{}, nextID: 1}
}

func (t *Twitter) postTweet(userId int, tweetId int, content string) {
    t.users[userId] = &User{ID: userId, Followers: map[int]bool{}}
    t.users[userId].Tweets = append(t.users[userId].Tweets, &Tweet{ID: tweetId, UserID: userId, Content: content, CreatedAt: time.Now()})
}

func (t *Twitter) getNewsFeed(userId int) []*Tweet {
    if len(t.users[userId].Tweets) == 0 {
        return nil
    }

    sortedTweets := sortTweetsByTime(t.users[userId].Tweets)
    return sortedTweets[:10]
}

func (t *Twitter) follow(followerId int, followeeId int) {
    t.users[followerId] = &User{ID: followerId, Followers: map[int]bool{}}
    t.users[followeeId] = &User{ID: followeeId, Followers: map[int]bool{}}
    t.users[followerId].Followers[followeeId] = true
}

func (t *Twitter) unfollow(followerId int, followeeId int) {
    if followerId == followeeId {
        return
    }
    t.users[followerId] = &User{ID: followerId, Followers: map[int]bool{}}
    delete(t.users[followerId].Followers, followeeId)
}
```

**解析：** 我们使用哈希表存储用户的推文和关注者列表。当用户发布推文时，我们将推文添加到用户的推文列表中。获取关注者最近的推文时，我们根据推文的时间顺序排序，并返回前 10 个推文。

#### 17. 设计一个有大小限制的栈

**题目：** 设计一个具有固定大小 k 的栈，并且可以获取栈顶元素。

**答案：**

我们可以使用一个循环队列来实现栈，并且使用一个额外的数组来存储栈顶元素。

**示例代码：**

```go
type CustomStack struct {
    capacity int
    size int
    data []int
    top []int
}

func Constructor(k int) CustomStack {
    return CustomStack{capacity: k, size: 0, data: make([]int, k), top: make([]int, k)}
}

func (this *CustomStack) push(x int)  {
    if this.size < this.capacity {
        this.data[this.size] = x
        this.top[this.size] = x
        this.size++
    }
}

func (this *CustomStack) pop() int {
    if this.size == 0 {
        return -1
    }
    val := this.data[this.size-1]
    this.size--
    return val
}

func (this *CustomStack) top() int {
    if this.size == 0 {
        return -1
    }
    return this.top[this.size-1]
}
```

**解析：** 我们使用一个循环队列来实现栈，当栈满时，我们不再添加元素。当弹出元素时，我们从队列的尾部弹出，并将栈顶元素更新。

#### 18. 设计一个后缀树

**题目：** 设计一个后缀树，并实现以下功能：添加字符串、搜索字符串、搜索前缀。

**答案：**

我们可以使用 Trie 数据结构来实现后缀树。每个节点表示一个字符，并包含子节点、结束标志和计数器。

**示例代码：**

```go
type Trie struct {
    children [26]*Trie
    isEnd    bool
    count    int
}

func Constructor() Trie {
    return Trie{}
}

func (t *Trie) insert(word string) {
    node := t
    for _, c := range word {
        idx := int(c - 'a')
        if node.children[idx] == nil {
            node.children[idx] = &Trie{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
    node.count++
}

func (t *Trie) search(word string) bool {
    node := t
    for _, c := range word {
        idx := int(c - 'a')
        if node.children[idx] == nil {
            return false
        }
        node = node.children[idx]
    }
    return node.isEnd
}

func (t *Trie) searchPrefix(prefix string) int {
    node := t
    for _, c := range prefix {
        idx := int(c - 'a')
        if node.children[idx] == nil {
            return 0
        }
        node = node.children[idx]
    }
    return node.count
}
```

**解析：** 我们在每个节点中存储子节点、结束标志和计数器。在插入字符串时，我们遍历字符，并创建新的节点。在搜索字符串时，我们检查每个节点是否为结束标志。

#### 19. 设计一个最小栈

**题目：** 设计一个最小栈，支持 push、pop、getMin 操作。

**答案：**

我们可以使用两个栈来实现最小栈，一个栈用于存储元素，另一个栈用于存储当前的最小值。

**示例代码：**

```go
type MinStack struct {
    s1 []int
    s2 []int
}

func Constructor() MinStack {
    return MinStack{s1: []int{}, s2: []int{}}
}

func (this *MinStack) push(x int) {
    this.s1 = append(this.s1, x)
    if len(this.s2) == 0 or x < this.s2[len(this.s2)-1] {
        this.s2 = append(this.s2, x)
    } else {
        this.s2 = append(this.s2, this.s2[len(this.s2)-1])
    }
}

func (this *MinStack) pop() {
    if this.s1[len(this.s1)-1] == this.s2[len(this.s2)-1] {
        this.s2 = this.s2[:len(this.s2)-1]
    }
    this.s1 = this.s1[:len(this.s1)-1]
}

func (this *MinStack) top() int {
    return this.s1[len(this.s1)-1]
}

func (this *MinStack) getMin() int {
    return this.s2[len(this.s2)-1]
}
```

**解析：** 我们使用两个栈，一个用于存储元素，另一个用于存储当前的最小值。在 push 操作时，我们比较新元素和当前最小值，更新最小值栈。

#### 20. 设计一个最小矩形框

**题目：** 设计一个最小矩形框，支持以下操作：添加、获取最小矩形框。

**答案：**

我们可以使用一个优先队列（最小堆）来存储矩形框，并使用一个哈希表来快速查找。

**示例代码：**

```go
type MinRectangle struct {
    area int
    i int
}

type MinHeap []MinRectangle

func (h MinHeap) Len() int {
    return len(h)
}

func (h MinHeap) Less(i, j int) bool {
    return h[i].area < h[j].area
}

func (h MinHeap) Swap(i, j int) {
    h[i], h[j] = h[j], h[i]
}

func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(MinRectangle))
}

func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func Constructor() MinRectangle {
    return MinRectangle{}
}

func (this *MinRectangle) add(w, h, i int) {
    this.area = w * h
    this.i = i
    minHeap.Push(&this)
}

func (this *MinRectangle) getMin() MinRectangle {
    return minHeap.Pop().(MinRectangle)
}
```

**解析：** 我们使用一个优先队列（最小堆）来存储矩形框，并使用一个哈希表来快速查找。在 add 操作时，我们计算矩形框的面积，并将其添加到堆中。在 getMin 操作时，我们返回堆顶元素。

### 总结

在这篇博客中，我们介绍了华为校招技术面试题集锦中的 20 个经典面试题和算法编程题。通过这些题目，我们可以看到华为对候选人算法和数据结构能力的重视。在解答这些题目时，我们提供了详细的解析和示例代码，帮助读者理解解题思路和实现方法。希望这篇博客能够对准备华为校招面试的同学们有所帮助。祝大家面试顺利！

