                 

### 自拟标题：洞见形成之路——探索观察与反思的重要性

## 一、观察与反思的重要性

在《洞见的形成：从观察到反思》这篇文章中，我们探讨了观察和反思在知识获取和思维发展中的关键作用。观察是我们获取外部信息的基础，而反思则是我们对这些信息进行加工和理解的过程。通过结合观察与反思，我们能够形成更加深刻的洞见，从而更好地应对复杂的问题和挑战。

## 二、典型问题/面试题库与解析

### 1. 如何提升观察力？

**题目：** 如何在日常生活中提升自己的观察力？

**答案：**
提升观察力需要通过有意识地进行练习和培养。以下是一些方法：

1. **培养好奇心：** 对周围的事物保持好奇，尝试理解它们的工作原理和背后的逻辑。
2. **养成记录习惯：** 每天记录下你所观察到的有趣事物，这有助于加深记忆和思考。
3. **多角度观察：** 尝试从不同角度和不同维度去观察同一个事物，这有助于更全面地理解问题。
4. **实践练习：** 通过绘画、摄影等艺术形式来训练观察力和表达能力。

**解析：** 提高观察力不仅有助于我们更好地理解世界，还能在面试和工作中展示我们的综合素质和思考能力。

### 2. 反思与自我提升

**题目：** 如何通过反思来提升自己的能力？

**答案：**
反思是一种重要的自我提升方式，以下是一些方法：

1. **定期自我评估：** 定期回顾自己的工作表现，识别优点和不足。
2. **接受反馈：** 从他人的反馈中获取改进的方向，并对自己的行为进行反思。
3. **记录思考过程：** 将自己的思考和决策过程记录下来，以便日后进行分析和改进。
4. **设定目标：** 根据反思结果设定具体可行的目标，并持续跟踪自己的进步。

**解析：** 通过反思，我们能够更加明确自己的优势和劣势，从而有针对性地进行自我提升。

### 3. 算法编程题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**
使用动态规划算法，我们可以解决这个问题。以下是 Python 代码示例：

```python
def longest_common_subsequence(str1, str2):
    m, n = len(str1), len(str2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if str1[i-1] == str2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

str1 = "ABCD"
str2 = "ACDF"
print(longest_common_subsequence(str1, str2))  # 输出 2
```

**解析：** 最长公共子序列问题是一个经典的动态规划问题，通过构建一个二维数组来记录状态转移，从而得到最终的结果。

### 4. 面试题：K 个最接近的元素

**题目：** 给定一个排序数组和一个整数 k，找出数组中与给定整数最接近的 k 个数。

**答案：**
我们可以使用二分查找来解决这个问题。以下是 Python 代码示例：

```python
def find_closest_elements(arr, target, k):
    left, right = 0, len(arr) - k
    result = []

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    result.extend(arr[left:right+1])
    return result

arr = [1, 2, 3, 4, 5]
target = 3
k = 2
print(find_closest_elements(arr, target, k))  # 输出 [2, 3]
```

**解析：** 通过二分查找，我们能够快速找到与给定整数最接近的 k 个数，这有助于提高面试中的算法设计能力。

### 5. 面试题：二分查找

**题目：** 实现一个二分查找函数，用于在排序数组中查找一个特定元素。

**答案：**
以下是 Python 代码示例：

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

arr = [1, 2, 3, 4, 5]
target = 3
print(binary_search(arr, target))  # 输出 2
```

**解析：** 二分查找是一种高效的搜索算法，通过不断缩小区间来找到目标元素。掌握二分查找有助于在面试中展示我们的算法能力。

### 6. 面试题：合并区间

**题目：** 给定一个区间列表，合并所有重叠的区间。

**答案：**
以下是 Python 代码示例：

```python
def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        prev, curr = result[-1], intervals[i]
        if prev[1] >= curr[0]:
            result[-1] = [prev[0], max(prev[1], curr[1])]
        else:
            result.append(curr)

    return result

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge_intervals(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

**解析：** 通过排序和合并区间，我们能够高效地处理重叠的区间。这有助于在面试中展示我们的数据处理能力。

### 7. 面试题：最大子序和

**题目：** 给定一个整数数组，找出最大子序和。

**答案：**
以下是 Python 代码示例：

```python
def max_subarray_sum(nums):
    if not nums:
        return 0

    max_sum, curr_sum = nums[0], 0
    for num in nums[1:]:
        curr_sum = max(num, curr_sum + num)
        max_sum = max(max_sum, curr_sum)

    return max_sum

nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(max_subarray_sum(nums))  # 输出 6
```

**解析：** 使用动态规划，我们能够找到最大子序和。这有助于在面试中展示我们的算法理解能力。

### 8. 面试题：最长公共前缀

**题目：** 给定一个字符串数组，找出其中最长的公共前缀。

**答案：**
以下是 Python 代码示例：

```python
def longest_common_prefix(strs):
    if not strs:
        return ""

    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or prefix[i] != s[i]:
                prefix = prefix[:i]
                break

    return prefix

strs = ["flower", "flow", "flight"]
print(longest_common_prefix(strs))  # 输出 "fl"
```

**解析：** 通过遍历字符串数组，我们能够找到最长的公共前缀。这有助于在面试中展示我们的字符串处理能力。

### 9. 面试题：有效括号

**题目：** 给定一个字符串，判断其是否为有效括号。

**答案：**
以下是 Python 代码示例：

```python
def is_valid(s):
    stack = []
    for c in s:
        if c in "({[}", stack.append(c)
        elif not stack or (c == ")" and stack[-1] != "(" or
                           c == "}" and stack[-1] != "{" or
                           c == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()

    return not stack

s = "()[]{}"
print(is_valid(s))  # 输出 True
```

**解析：** 通过使用栈，我们能够判断字符串是否为有效括号。这有助于在面试中展示我们的数据结构运用能力。

### 10. 面试题：两数相加

**题目：** 给定两个非空链表，表示两个非负整数，每个节点包含一个数字。将这两个数相加并返回一个新的链表。

**答案：**
以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
print([node.val for node in add_two_numbers(l1, l2)])  # 输出 [7, 0, 8]
```

**解析：** 通过构建一个新的链表，我们能够实现两个链表表示的数字的相加。这有助于在面试中展示我们的链表操作能力。

### 11. 面试题：最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：**
以下是 Python 代码示例：

```python
def longest_consecutive(nums):
    if not nums:
        return 0

    nums = list(set(nums))
    nums.sort()
    longest = 1
    current = 1

    for i in range(1, len(nums)):
        if nums[i] == nums[i-1] + 1:
            current += 1
        else:
            longest = max(longest, current)
            current = 1

    return max(longest, current)

nums = [100, 4, 200, 1, 3, 2]
print(longest_consecutive(nums))  # 输出 4
```

**解析：** 通过将数组转换为集合并排序，我们能够找到最长连续序列。这有助于在面试中展示我们的数据结构和排序能力。

### 12. 面试题：打乱数组

**题目：** 给定一个整数数组，打乱它的元素。要求实现一个函数，能完成以下功能：

1. 每次调用时，返回数组的不同随机排列。
2. 每次调用时，返回的数组必须是之前未返回过的随机排列。

**答案：**
以下是 Python 代码示例：

```python
import random

class Solution:
    def __init__(self, nums: List[int]):
        self.nums = nums

    def reset(self) -> List[int]:
        return self.nums

    def shuffle(self) -> List[int]:
        shuffled = self.nums[:]
        n = len(shuffled)
        for i in range(n):
            j = random.randint(i, n - 1)
            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        return shuffled

# Example usage
sol = Solution([1, 2, 3])
print(sol.reset())  # 输出 [1, 2, 3]
print(sol.shuffle())  # 输出 [3, 1, 2]
print(sol.shuffle())  # 输出 [2, 3, 1]
```

**解析：** 通过使用随机数生成器，我们能够实现数组的不同随机排列。这有助于在面试中展示我们的算法和随机化能力。

### 13. 面试题：旋转图像

**题目：** 给定一个 n × n 的二维矩阵，将矩阵按顺时针旋转 90 度。

**答案：**
以下是 Python 代码示例：

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp

    return matrix

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(rotate(matrix))  # 输出 [[3, 6, 9], [2, 5, 8], [1, 4, 7]]
```

**解析：** 通过依次旋转矩阵的四个角，我们能够实现矩阵的顺时针旋转。这有助于在面试中展示我们的矩阵操作能力。

### 14. 面试题：有效的括号

**题目：** 给定一个字符串，判断其是否为有效的括号。

**答案：**
以下是 Python 代码示例：

```python
def isValid(s):
    stack = []
    for c in s:
        if c in "([{", stack.append(c)
        elif not stack or (c == ")" and stack[-1] != "(" or
                           c == "}" and stack[-1] != "{" or
                           c == "]" and stack[-1] != "["):
            return False
        else:
            stack.pop()

    return not stack

s = "()[]{}"
print(isValid(s))  # 输出 True
```

**解析：** 通过使用栈，我们能够判断字符串是否为有效的括号。这有助于在面试中展示我们的数据结构运用能力。

### 15. 面试题：最长公共子串

**题目：** 给定两个字符串，找出它们的最长公共子串。

**答案：**
以下是 Python 代码示例：

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]
    longest, x_longest = 0, 0

    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
                if dp[i][j] > longest:
                    longest = dp[i][j]
                    x_longest = i
            else:
                dp[i][j] = 0

    return s1[x_longest-longest: x_longest]

s1 = "abcdefg"
s2 = "zabcxy"
print(longest_common_substring(s1, s2))  # 输出 "abc"
```

**解析：** 通过构建一个二维数组来记录状态转移，我们能够找到最长公共子串。这有助于在面试中展示我们的动态规划能力。

### 16. 面试题：有效的 ASCII 表示

**题目：** 给定一个字符串，判断其是否可以表示一个有效的 ASCII 编码序列。

**答案：**
以下是 Python 代码示例：

```python
def isValidSequence(s):
    hexes = "0123456789abcdefABCDEF\\-+"
    state = 0

    for c in s:
        if state == 0 and c != "%":
            return False
        elif state == 0 and c == "%":
            state = 1
        elif state == 1 and c not in hexes:
            return False
        elif state == 1 and c in hexes:
            state = 2
        elif state == 2 and c not in hexes:
            return False
        elif state == 2 and c in hexes:
            state = 3
        elif state == 3 and c not in hexes:
            return False
        elif state == 3 and c in hexes:
            state = 0

    return state == 0

s = "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d"
print(isValidSequence(s))  # 输出 True
```

**解析：** 通过维护状态机，我们能够判断字符串是否为有效的 ASCII 编码序列。这有助于在面试中展示我们的状态机运用能力。

### 17. 面试题：判断子序列

**题目：** 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

**答案：**
以下是 Python 代码示例：

```python
def isSubsequence(s, t):
    i, j = 0, 0

    while i < len(s) and j < len(t):
        if s[i] == t[j]:
            i += 1
        j += 1

    return i == len(s)

s = "abc"
t = "ahbgdc"
print(isSubsequence(s, t))  # 输出 True
```

**解析：** 通过遍历字符串，我们能够判断 s 是否为 t 的子序列。这有助于在面试中展示我们的字符串处理能力。

### 18. 面试题：最小栈

**题目：** 设计一个支持 push ，pop ，top 操作的栈，并能在常数时间内检索到栈中的最小元素。

**答案：**
以下是 Python 代码示例：

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

# Example usage
minStack = MinStack()
minStack.push(-2)
minStack.push(0)
minStack.push(-3)
print(minStack.getMin())  # 输出 -3
minStack.pop()
print(minStack.top())  # 输出 0
print(minStack.getMin())  # 输出 -2
```

**解析：** 通过维护一个辅助栈，我们能够在常数时间内检索到栈中的最小元素。这有助于在面试中展示我们的栈数据结构运用能力。

### 19. 面试题：字符串转换整数 (atoi)

**题目：** 实现一个函数，将字符串转换成整数。如果字符串不是以数字开头，则返回 0。

**答案：**
以下是 Python 代码示例：

```python
def myAtoi(s):
    INT_MAX = 2**31 - 1
    INT_MIN = -2**31
    i = 0
    sign = 1
    result = 0

    while i < len(s) and s[i] == " ":
        i += 1

    if i < len(s) and (s[i] == "+" or s[i] == "-"):
        sign = -1 if s[i] == "-" else 1
        i += 1

    while i < len(s) and s[i].isdigit():
        digit = ord(s[i]) - ord("0")
        if result > (INT_MAX - digit) // 10:
            return INT_MAX if sign == 1 else INT_MIN
        result = result * 10 + digit
        i += 1

    return result * sign

s = "42"
print(myAtoi(s))  # 输出 42
s = "-91283472332"
print(myAtoi(s))  # 输出 -2147483648
```

**解析：** 通过处理字符串中的空格、符号和数字，我们能够实现字符串到整数的转换。这有助于在面试中展示我们的字符串处理能力。

### 20. 面试题：验证二分树

**题目：** 给定一棵二叉树，判断其是否为有效的二分树。

**答案：**
以下是 Python 代码示例：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBST(root):
    def check(node, low, high):
        if not node:
            return True
        if node.val <= low or node.val >= high:
            return False
        return check(node.right, node.val, high) and check(node.left, low, node.val)

    return check(root, float("-inf"), float("inf"))

root = TreeNode(2, TreeNode(1), TreeNode(3))
print(isValidBST(root))  # 输出 True
root = TreeNode(5, TreeNode(1, TreeNode(4), TreeNode(7), TreeNode(8)))
print(isValidBST(root))  # 输出 False
```

**解析：** 通过递归检查每个节点的值是否在给定的范围内，我们能够判断一棵二叉树是否为有效的二分树。这有助于在面试中展示我们的树形结构处理能力。

### 21. 面试题：最长公共子序列

**题目：** 给定两个字符串，找出它们的最长公共子序列。

**答案：**
以下是 Python 代码示例：

```python
def longest_common_subsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(1, m+1):
        for j in range(1, n+1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[m][n]

s1 = "ABCD"
s2 = "ACDF"
print(longest_common_subsequence(s1, s2))  # 输出 2
```

**解析：** 通过构建一个二维数组来记录状态转移，我们能够找到最长公共子序列。这有助于在面试中展示我们的动态规划能力。

### 22. 面试题：删除链表的节点

**题目：** 给定一个单链表，删除链表中的节点。

**答案：**
以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next

# Example usage
head = ListNode(4, ListNode(5, ListNode(1, ListNode(9))))
deleteNode(head.next.next)
print([node.val for node in head])  # 输出 [4, 5, 9]
```

**解析：** 通过修改当前节点的值和指针，我们能够删除链表中的节点。这有助于在面试中展示我们的链表操作能力。

### 23. 面试题：快速排序

**题目：** 实现快速排序算法。

**答案：**
以下是 Python 代码示例：

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))  # 输出 [1, 1, 2, 3, 6, 8, 10]
```

**解析：** 通过递归划分和合并数组，我们能够实现快速排序。这有助于在面试中展示我们的排序算法能力。

### 24. 面试题：两数之和

**题目：** 给定一个整数数组，找出两个数，使其和等于特定目标值。

**答案：**
以下是 Python 代码示例：

```python
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i

    return []

nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # 输出 [0, 1]
```

**解析：** 通过使用哈希表，我们能够找到两个数，使其和等于特定目标值。这有助于在面试中展示我们的哈希表运用能力。

### 25. 面试题：合并两个有序链表

**题目：** 给定两个有序链表，合并它们为一个新的有序链表。

**答案：**
以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_sorted_lists(l1, l2):
    dummy = ListNode(0)
    curr = dummy

    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next

    curr.next = l1 or l2
    return dummy.next

l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
print([node.val for node in merge_sorted_lists(l1, l2)])  # 输出 [1, 2, 3, 4, 5, 6]
```

**解析：** 通过比较两个链表中的节点值，我们能够合并两个有序链表。这有助于在面试中展示我们的链表操作能力。

### 26. 面试题：旋转图像

**题目：** 给定一个 n × n 的二维矩阵，将矩阵按顺时针旋转 90 度。

**答案：**
以下是 Python 代码示例：

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp

    return matrix

matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(rotate(matrix))  # 输出 [[3, 6, 9], [2, 5, 8], [1, 4, 7]]
```

**解析：** 通过依次旋转矩阵的四个角，我们能够实现矩阵的顺时针旋转。这有助于在面试中展示我们的矩阵操作能力。

### 27. 面试题：两数相加

**题目：** 给定两个非空链表，表示两个非负整数，每个节点包含一个数字。将这两个数相加并返回一个新的链表。

**答案：**
以下是 Python 代码示例：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def add_two_numbers(l1, l2):
    dummy = ListNode(0)
    curr = dummy
    carry = 0

    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next

        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next

    return dummy.next

l1 = ListNode(2, ListNode(4, ListNode(3)))
l2 = ListNode(5, ListNode(6, ListNode(4)))
print([node.val for node in add_two_numbers(l1, l2)])  # 输出 [7, 0, 8]
```

**解析：** 通过构建一个新的链表，我们能够实现两个链表表示的数字的相加。这有助于在面试中展示我们的链表操作能力。

### 28. 面试题：合并区间

**题目：** 给定一个区间列表，合并所有重叠的区间。

**答案：**
以下是 Python 代码示例：

```python
def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]

    for i in range(1, len(intervals)):
        prev, curr = result[-1], intervals[i]
        if prev[1] >= curr[0]:
            result[-1] = [prev[0], max(prev[1], curr[1])]
        else:
            result.append(curr)

    return result

intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(merge_intervals(intervals))  # 输出 [[1, 6], [8, 10], [15, 18]]
```

**解析：** 通过排序和合并区间，我们能够高效地处理重叠的区间。这有助于在面试中展示我们的数据处理能力。

### 29. 面试题：合并两个有序数组

**题目：** 给定两个有序整数数组，将它们合并为一个有序数组。

**答案：**
以下是 Python 代码示例：

```python
def merge_sorted_arrays(nums1, m, nums2, n):
    i = m - 1
    j = n - 1
    k = m + n - 1

    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1

    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1

    return nums1

nums1 = [1, 2, 3, 0, 0, 0]
m = 3
nums2 = [2, 5, 6]
n = 3
print(merge_sorted_arrays(nums1, m, nums2, n))  # 输出 [1, 2, 2, 3, 5, 6]
```

**解析：** 通过比较两个数组的元素并填充到第一个数组中，我们能够合并两个有序数组。这有助于在面试中展示我们的数组操作能力。

### 30. 面试题：爬楼梯

**题目：** 假设你正在爬楼梯。需要 n 阶台阶才能到达楼顶。每次你可以爬 1 或 2 个台阶。编写一个函数，计算有多少种不同的方法可以爬到楼顶。

**答案：**
以下是 Python 代码示例：

```python
def climb_stairs(n):
    if n <= 2:
        return n

    a, b = 1, 1
    for i in range(2, n):
        c = a + b
        a, b = b, c

    return b

print(climb_stairs(3))  # 输出 3
print(climb_stairs(4))  # 输出 5
```

**解析：** 通过动态规划，我们能够计算有多少种不同的方法可以爬到楼顶。这有助于在面试中展示我们的动态规划能力。

