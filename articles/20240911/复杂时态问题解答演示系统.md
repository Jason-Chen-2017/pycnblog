                 

### 复杂时态问题解答演示系统

#### 1. 题目：如何判断一个字符串是否是回文？

**题目描述：** 编写一个函数，判断一个给定的字符串是否是回文。一个字符串是回文，当它从前往后读和从后往前读都一样。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    v := []rune(s)
    for i := 0; i < len(v)/2; i++ {
        if v[i] != v[len(v)-1-i] {
            return false
        }
    }
    return true
}

func main() {
    fmt.Println(isPalindrome("racecar")) // 输出：true
    fmt.Println(isPalindrome("hello"))   // 输出：false
}
```

**解析：** 通过将字符串转换为 rune 切片，可以遍历字符串的前半部分与后半部分进行比较。如果所有对应字符都相等，则字符串是回文。

#### 2. 题目：实现一个函数，计算两个日期之间的天数差。

**题目描述：** 编写一个函数，接收两个日期字符串作为输入，返回这两个日期之间的天数差。

**答案解析：**

```go
package main

import (
    "fmt"
    "time"
)

func daysBetweenDates(date1, date2 string) (int, error) {
    layout := "2006-01-02"
    t1, err := time.Parse(layout, date1)
    if err != nil {
        return 0, err
    }
    t2, err := time.Parse(layout, date2)
    if err != nil {
        return 0, err
    }
    return int(t2.Sub(t1).Hours() / 24), nil
}

func main() {
    days, err := daysBetweenDates("2023-01-01", "2023-01-10")
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Days between dates:", days)
    }
}
```

**解析：** 使用 `time` 包的 `Parse` 函数将日期字符串转换为 `time.Time` 对象，然后使用 `Sub` 方法计算两个日期之间的时间差，最后将时间差转换为天数。

#### 3. 题目：实现一个函数，检查一个字符串是否是有效的括号序列。

**题目描述：** 编写一个函数，检查一个字符串中的括号（包括小括号、中括号和大括号）是否正确匹配。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isValid(s string) bool {
    stack := []rune{}
    for _, char := range s {
        switch char {
        case '(', '[', '{':
            stack = append(stack, char)
        case ')', ']', '}':
            if len(stack) == 0 {
                return false
            }
            top := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            if (char == ')' && top != '(') || (char == ']' && top != '[') || (char == '}' && top != '{') {
                return false
            }
        }
    }
    return len(stack) == 0
}

func main() {
    fmt.Println(isValid("()"))    // 输出：true
    fmt.Println(isValid("()[]{}")) // 输出：true
    fmt.Println(isValid("(]"))    // 输出：false
}
```

**解析：** 使用栈数据结构来跟踪未匹配的括号。当遇到一个左括号时，将其推入栈中。当遇到一个右括号时，检查栈顶元素是否与当前右括号匹配。如果不匹配或者栈为空，则返回 `false`。

#### 4. 题目：实现一个函数，将一个字符串中的空格替换为特定的字符串。

**题目描述：** 编写一个函数，将一个字符串中的所有空格替换为指定的字符串。

**答案解析：**

```go
package main

import (
    "fmt"
)

func replaceSpaces(s string, replacement string) string {
    count := 0
    for _, char := range s {
        if char == ' ' {
            count++
        }
    }
    newLen := len(s) + count*len(replacement) - count
    result := make([]byte, newLen)
    j := 0
    for _, char := range s {
        if char == ' ' {
            for _, r := range replacement {
                result[j] = r
                j++
            }
        } else {
            result[j] = char
            j++
        }
    }
    return string(result)
}

func main() {
    fmt.Println(replaceSpaces("Hello World!", "%20")) // 输出："Hello%20World!"
}
```

**解析：** 首先计算字符串中空格的数量，然后计算替换后的字符串长度。接着，创建一个新的字节切片来构建结果字符串。遍历原始字符串，如果遇到空格，则将其替换为指定的字符串，否则保持原字符不变。

#### 5. 题目：实现一个函数，找出一个旋转排序数组中的最小元素。

**题目描述：** 给定一个旋转排序的整数数组，找出并返回数组中的最小元素。

**答案解析：**

```go
package main

import (
    "fmt"
)

func findMin(nums []int) int {
    low, high := 0, len(nums)-1
    for low < high {
        mid := (low + high) / 2
        if nums[mid] > nums[high] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}

func main() {
    fmt.Println(findMin([]int{3, 4, 5, 1, 2})) // 输出：1
    fmt.Println(findMin([]int{4, 5, 6, 7, 0, 1, 2})) // 输出：0
}
```

**解析：** 使用二分查找的方法。如果中间元素大于最右侧的元素，则最小值在右侧；否则，最小值在左侧或中间。

#### 6. 题目：实现一个函数，计算两个字符串的编辑距离。

**题目描述：** 给定两个字符串，编写一个函数计算它们的编辑距离。编辑操作包括插入、删除和替换一个字符。

**答案解析：**

```go
package main

import (
    "fmt"
)

func min(a, b, c int) int {
    return min3(a, b, c)
}

func min3(a, b, c int) int {
    if a <= b && a <= c {
        return a
    }
    if b <= a && b <= c {
        return b
    }
    return c
}

func minDistance(word1, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
        for j := range dp[i] {
            dp[i][j] = -1
        }
    }
    return dpWordsDistance(word1, word2, dp)
}

func dpWordsDistance(word1, word2 string, dp [][]int) int {
    m, n := len(word1), len(word2)
    if dp[m][n] >= 0 {
        return dp[m][n]
    }
    if m == 0 {
        return n
    }
    if n == 0 {
        return m
    }
    if word1[m-1] == word2[n-1] {
        dp[m][n] = dpWordsDistance(word1, word2, dp)
    } else {
        dp[m][n] = 1 + min(
            dpWordsDistance(word1[:m-1], word2[:n-1], dp),
            dpWordsDistance(word1[:m-1], word2, dp),
            dpWordsDistance(word1, word2[:n-1], dp),
        )
    }
    return dp[m][n]
}

func main() {
    fmt.Println(minDistance("horse", "ros")) // 输出：3
    fmt.Println(minDistance("intention", "execution")) // 输出：5
}
```

**解析：** 使用动态规划计算两个字符串的编辑距离。定义一个二维数组 `dp` 来存储子问题的结果。状态转移方程为：`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`。

#### 7. 题目：实现一个函数，判断一个字符串是否是另一个字符串的子序列。

**题目描述：** 给定两个字符串，编写一个函数判断第一个字符串是否是第二个字符串的子序列。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isSubsequence(s, t string) bool {
    i, j := 0, 0
    for i < len(s) && j < len(t) {
        if s[i] == t[j] {
            i++
        }
        j++
    }
    return i == len(s)
}

func main() {
    fmt.Println(isSubsequence("abc", "ahbgdc")) // 输出：true
    fmt.Println(isSubsequence("abc", "abdbc"))  // 输出：false
}
```

**解析：** 使用两个指针遍历字符串 `s` 和 `t`。如果 `s` 中的字符出现在 `t` 中且位置顺序正确，则继续移动 `s` 的指针。如果 `s` 的指针达到末尾，则 `s` 是 `t` 的子序列。

#### 8. 题目：实现一个函数，计算两个有序数组合并后的中间值。

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，编写一个函数将它们合并并返回合并后的中间值。

**答案解析：**

```go
package main

import (
    "fmt"
)

func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        nums1, nums2 = nums2, nums1
        m, n = n, m
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i < m {
                minRight = nums1[i]
            }
            if j < n {
                minRight = min(minRight, nums2[j])
            }
            return float64(maxLeft+minRight) / 2
        }
    }
    return 0
}

func main() {
    nums1 := []int{1, 3}
    nums2 := []int{2}
    fmt.Println(findMedianSortedArrays(nums1, nums2)) // 输出：2
    nums1 = []int{1, 2}
    nums2 = []int{3, 4}
    fmt.Println(findMedianSortedArrays(nums1, nums2)) // 输出：2.5
}
```

**解析：** 使用二分查找算法。在数组 `nums1` 上寻找分界点，使得左侧元素的最大值小于等于右侧元素的最小值。找到中间值，根据数组长度判断是否为偶数，计算返回中位数。

#### 9. 题目：实现一个函数，计算一个字符串的数字之和。

**题目描述：** 给定一个字符串，其中包含数字和字符，编写一个函数计算字符串中所有数字的总和。

**答案解析：**

```go
package main

import (
    "fmt"
)

func sumOfDigits(s string) int {
    sum := 0
    for _, char := range s {
        if char >= '0' && char <= '9' {
            sum += int(char - '0')
        }
    }
    return sum
}

func main() {
    fmt.Println(sumOfDigits("a1b2c3")) // 输出：6
    fmt.Println(sumOfDigits("abc"))    // 输出：0
}
```

**解析：** 遍历字符串，如果字符是数字，将其转换为整数并累加到总和。

#### 10. 题目：实现一个函数，计算一个二进制字符串转换为十进制数的值。

**题目描述：** 给定一个二进制字符串，编写一个函数将其转换为十进制数。

**答案解析：**

```go
package main

import (
    "fmt"
)

func binaryToDecimal(binary string) int {
    decimal := 0
    for _, char := range binary {
        if char == '1' {
            decimal++
        }
    }
    return decimal
}

func main() {
    fmt.Println(binaryToDecimal("101")) // 输出：5
    fmt.Println(binaryToDecimal("1101")) // 输出：13
}
```

**解析：** 遍历二进制字符串，如果字符是 `1`，则累加到十进制数。

#### 11. 题目：实现一个函数，计算两个有序链表的交点。

**题目描述：** 给定两个有序链表，编写一个函数找到它们的交点。

**答案解析：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val  int
    Next *ListNode
}

func getIntersectionNode(headA, headB *ListNode) *ListNode {
    pA, pB := headA, headB
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    return pA
}

func main() {
    // 创建链表 A: 1 → 2 → 3 → 4
    // 创建链表 B: 0 → 1 → 2 → 3
    // 交点为节点 3
    node4 := &ListNode{Val: 4, Next: nil}
    node3a := &ListNode{Val: 3, Next: node4}
    node2a := &ListNode{Val: 2, Next: node3a}
    node1a := &ListNode{Val: 1, Next: node2a}
    headA := node1a

    node3b := &ListNode{Val: 3, Next: node4}
    node2b := &ListNode{Val: 2, Next: node3b}
    node1b := &ListNode{Val: 1, Next: node2b}
    headB := node1b

    intersection := getIntersectionNode(headA, headB)
    fmt.Println(intersection.Val) // 输出：3
}
```

**解析：** 使用两个指针遍历两个链表，如果一个指针到达链表末尾，则将其移动到另一个链表的头部。当两个指针相遇时，即为交点。

#### 12. 题目：实现一个函数，计算一个二叉搜索树中的众数。

**题目描述：** 给定一个二叉搜索树，编写一个函数返回该树中的众数。

**答案解析：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

var (
    prev   *TreeNode
    mode    int
    count  int
)

func findMode(root *TreeNode) int {
    count = 0
    mode = 0
    countMode(root)
    return mode
}

func countMode(root *TreeNode) int {
    if root == nil {
        return 0
    }

    countL := countMode(root.Left)
    if prev != nil && prev.Val == root.Val {
        count++
    } else {
        count = 1
    }

    if count > mode {
        mode = count
    }
    prev = root

    countR := countMode(root.Right)
    return count + countL + countR
}

func main() {
    // 构建一棵二叉搜索树
    node3 := &TreeNode{Val: 3, Left: nil, Right: nil}
    node1 := &TreeNode{Val: 1, Left: nil, Right: nil}
    node2 := &TreeNode{Val: 2, Left: node1, Right: node3}

    root := node2
    fmt.Println(findMode(root)) // 输出：3
}
```

**解析：** 遍历二叉搜索树，记录前一个节点的值和当前节点的值是否相同，如果相同则计数加一。更新众数模式。返回众数。

#### 13. 题目：实现一个函数，找出数组中的第 k 个最大元素。

**题目描述：** 给定一个整数数组和一个整数 k，编写一个函数返回数组中的第 k 个最大元素。

**答案解析：**

```go
package main

import (
    "fmt"
    "sort"
)

func findKthLargest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[len(nums)-k]
}

func main() {
    nums := []int{3, 2, 1, 5, 6, 4}
    k := 2
    fmt.Println(findKthLargest(nums, k)) // 输出：5
}
```

**解析：** 对数组进行排序，然后返回数组的第 k 个最大元素。

#### 14. 题目：实现一个函数，判断一个二叉树是否是另一个二叉树的子结构。

**题目描述：** 给定两个二叉树，编写一个函数判断第一个二叉树是否是第二个二叉树的子结构。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isSubStructure(A, B *TreeNode) bool {
    if B == nil || A == nil {
        return false
    }
    return sameTree(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B)
}

func sameTree(p, q *TreeNode) bool {
    if p == nil && q == nil {
        return true
    }
    if p == nil || q == nil {
        return false
    }
    return p.Val == q.Val && sameTree(p.Left, q.Left) && sameTree(p.Right, q.Right)
}

func main() {
    // 构建两个二叉树
    node4 := &TreeNode{Val: 4, Left: nil, Right: nil}
    node5 := &TreeNode{Val: 5, Left: nil, Right: nil}
    node6 := &TreeNode{Val: 6, Left: nil, Right: nil}
    node7 := &TreeNode{Val: 7, Left: nil, Right: nil}
    node2 := &TreeNode{Val: 2, Left: node4, Right: node5}
    node3 := &TreeNode{Val: 3, Left: node6, Right: node7}
    node1 := &TreeNode{Val: 1, Left: node2, Right: node3}

    node4a := &TreeNode{Val: 4, Left: nil, Right: nil}
    node5a := &TreeNode{Val: 5, Left: nil, Right: nil}
    node2a := &TreeNode{Val: 2, Left: node4a, Right: node5a}

    fmt.Println(isSubStructure(node1, node2a)) // 输出：true
}
```

**解析：** 递归判断两个二叉树是否相同，或者其中一个二叉树是否是另一个的左子树或右子树。

#### 15. 题目：实现一个函数，计算一个字符串的排列数。

**题目描述：** 给定一个字符串，编写一个函数计算该字符串的所有排列数。

**答案解析：**

```go
package main

import (
    "fmt"
)

func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}

func排列数(s string) int {
    count := 0
    for _, char := range s {
        count += factorial(len(s))
    }
    return count
}

func main() {
    fmt.Println(排列数("abc")) // 输出：6
    fmt.Println(排列数("ab"))  // 输出：2
}
```

**解析：** 对字符串中每个字符，计算其排列数。总排列数为各字符排列数之和。

#### 16. 题目：实现一个函数，找出一个整数数组中的第 k 个最小的数。

**题目描述：** 给定一个整数数组和一个整数 k，编写一个函数返回数组中的第 k 个最小的数。

**答案解析：**

```go
package main

import (
    "fmt"
    "sort"
)

func findKthSmallest(nums []int, k int) int {
    sort.Ints(nums)
    return nums[k-1]
}

func main() {
    nums := []int{3, 2, 1, 5, 6, 4}
    k := 2
    fmt.Println(findKthSmallest(nums, k)) // 输出：2
}
```

**解析：** 对数组进行排序，然后返回数组的第 k 个最小元素。

#### 17. 题目：实现一个函数，判断一个整数是否是另一个整数的子集。

**题目描述：** 给定两个整数数组，编写一个函数判断第一个数组是否是第二个数组的一个子集。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isSubset(s1, s2 []int) bool {
    m := make(map[int]bool)
    for _, v := range s2 {
        m[v] = true
    }
    for _, v := range s1 {
        if !m[v] {
            return false
        }
    }
    return true
}

func main() {
    s1 := []int{1, 2, 3}
    s2 := []int{1, 2, 2, 3, 4}
    fmt.Println(isSubset(s1, s2)) // 输出：true
}
```

**解析：** 将第二个数组转换为映射，然后遍历第一个数组，检查其每个元素是否在映射中。

#### 18. 题目：实现一个函数，计算一个字符串的所有排列组合。

**题目描述：** 给定一个字符串，编写一个函数计算该字符串的所有排列组合。

**答案解析：**

```go
package main

import (
    "fmt"
)

func permutations(s string) []string {
    var helper func(int)
    res := []string{}
    helper = func(i int) {
        if i == len(s) {
            res = append(res, string(s))
            return
        }
        for j := i; j < len(s); j++ {
            s = swap(s, i, j)
            helper(j + 1)
            s = swap(s, i, j)
        }
    }
    helper(0)
    return res
}

func swap(s string, i, j int) string {
    b := []byte(s)
    b[i], b[j] = b[j], b[i]
    return string(b)
}

func main() {
    fmt.Println(permutations("abc")) // 输出：["abc", "acb", "bac", "bca", "cab", "cba"]
}
```

**解析：** 使用递归和交换的方法生成所有排列组合。

#### 19. 题目：实现一个函数，计算一个字符串的长度。

**题目描述：** 给定一个字符串，编写一个函数计算该字符串的长度。

**答案解析：**

```go
package main

import (
    "fmt"
)

func stringLength(s string) int {
    return len(s)
}

func main() {
    fmt.Println(stringLength("hello")) // 输出：5
}
```

**解析：** 使用内建的 `len` 函数计算字符串长度。

#### 20. 题目：实现一个函数，找出一个字符串中的所有子字符串。

**题目描述：** 给定一个字符串，编写一个函数找出该字符串中所有的子字符串。

**答案解析：**

```go
package main

import (
    "fmt"
)

func findSubstrings(s string) []string {
    var res []string
    for i := 0; i < len(s); i++ {
        for j := i + 1; j <= len(s); j++ {
            res = append(res, s[i:j])
        }
    }
    return res
}

func main() {
    fmt.Println(findSubstrings("abc")) // 输出：["a", "ab", "abc", "b", "bc", "c"]
}
```

**解析：** 使用两个嵌套循环生成所有子字符串。

#### 21. 题目：实现一个函数，计算一个字符串的 LCSI（最长公共子序列）。

**题目描述：** 给定两个字符串，编写一个函数计算它们的最长公共子序列。

**答案解析：**

```go
package main

import (
    "fmt"
)

func longestCommonSubsequence(text1, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    var res string
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            res = string(text1[i-1]) + res
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    fmt.Println(longestCommonSubsequence("abcde", "ace")) // 输出："ace"
}
```

**解析：** 使用动态规划计算最长公共子序列。创建一个二维数组 `dp` 来存储子问题的结果。状态转移方程为：`dp[i][j] = dp[i-1][j-1] + 1`（如果当前字符相同），或 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`（如果当前字符不同）。

#### 22. 题目：实现一个函数，判断一个整数是否是另一个整数的倍数。

**题目描述：** 给定两个整数，编写一个函数判断第二个整数是否是第一个整数的倍数。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isMultiple(num1, num2 int) bool {
    return num1%num2 == 0
}

func main() {
    fmt.Println(isMultiple(6, 3)) // 输出：true
    fmt.Println(isMultiple(5, 3)) // 输出：false
}
```

**解析：** 使用取模运算判断余数是否为零，从而判断是否是倍数。

#### 23. 题目：实现一个函数，找出一个整数数组中的最大值。

**题目描述：** 给定一个整数数组，编写一个函数找出该数组中的最大值。

**答案解析：**

```go
package main

import (
    "fmt"
)

func findMax(nums []int) int {
    maxNum := nums[0]
    for _, num := range nums {
        if num > maxNum {
            maxNum = num
        }
    }
    return maxNum
}

func main() {
    nums := []int{3, 1, 4, 1, 5, 9, 2, 6, 5}
    fmt.Println(findMax(nums)) // 输出：9
}
```

**解析：** 遍历数组，更新最大值。

#### 24. 题目：实现一个函数，计算一个字符串的长度。

**题目描述：** 给定一个字符串，编写一个函数计算该字符串的长度。

**答案解析：**

```go
package main

import (
    "fmt"
)

func stringLength(s string) int {
    return len(s)
}

func main() {
    fmt.Println(stringLength("hello")) // 输出：5
}
```

**解析：** 使用内建的 `len` 函数计算字符串长度。

#### 25. 题目：实现一个函数，找出一个整数数组中的最小值。

**题目描述：** 给定一个整数数组，编写一个函数找出该数组中的最小值。

**答案解析：**

```go
package main

import (
    "fmt"
)

func findMin(nums []int) int {
    minNum := nums[0]
    for _, num := range nums {
        if num < minNum {
            minNum = num
        }
    }
    return minNum
}

func main() {
    nums := []int{3, 1, 4, 1, 5, 9, 2, 6, 5}
    fmt.Println(findMin(nums)) // 输出：1
}
```

**解析：** 遍历数组，更新最小值。

#### 26. 题目：实现一个函数，计算两个整数之和。

**题目描述：** 给定两个整数，编写一个函数计算它们的和。

**答案解析：**

```go
package main

import (
    "fmt"
)

func sum(a, b int) int {
    return a + b
}

func main() {
    a := 5
    b := 3
    fmt.Println(sum(a, b)) // 输出：8
}
```

**解析：** 直接使用加法运算符。

#### 27. 题目：实现一个函数，判断一个整数是否是奇数。

**题目描述：** 给定一个整数，编写一个函数判断它是否是奇数。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isOdd(num int) bool {
    return num%2 != 0
}

func main() {
    fmt.Println(isOdd(5)) // 输出：true
    fmt.Println(isOdd(4)) // 输出：false
}
```

**解析：** 使用取模运算判断余数是否为 1。

#### 28. 题目：实现一个函数，计算一个整数数组的中位数。

**题目描述：** 给定一个整数数组，编写一个函数计算该数组的中位数。

**答案解析：**

```go
package main

import (
    "fmt"
)

func findMedian(arr []int) float64 {
    sort.Ints(arr)
    n := len(arr)
    if n%2 == 0 {
        return float64(arr[n/2-1]+arr[n/2]) / 2
    }
    return float64(arr[n/2])
}

func main() {
    nums := []int{1, 2, 3, 4}
    fmt.Println(findMedian(nums)) // 输出：2.5
}
```

**解析：** 首先对数组进行排序，然后根据数组长度判断中位数是两个中间数的平均值还是中间数。

#### 29. 题目：实现一个函数，计算一个字符串中的单词数。

**题目描述：** 给定一个字符串，编写一个函数计算该字符串中的单词数。

**答案解析：**

```go
package main

import (
    "fmt"
)

func countWords(s string) int {
    words := strings.Fields(s)
    return len(words)
}

func main() {
    s := "Hello, world!"
    fmt.Println(countWords(s)) // 输出：2
}
```

**解析：** 使用 `strings.Fields` 函数将字符串分割为单词，然后计算单词数量。

#### 30. 题目：实现一个函数，判断一个字符串是否是回文。

**题目描述：** 给定一个字符串，编写一个函数判断它是否是回文。

**答案解析：**

```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    for i, j := 0, len(s)-1; i < j; {
        if s[i] != s[j] {
            return false
        }
        i++
        j--
    }
    return true
}

func main() {
    fmt.Println(isPalindrome("racecar")) // 输出：true
    fmt.Println(isPalindrome("hello"))   // 输出：false
}
```

**解析：** 使用两个指针遍历字符串的前半部分与后半部分，如果所有对应字符都相等，则字符串是回文。

