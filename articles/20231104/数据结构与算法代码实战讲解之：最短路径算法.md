
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、最短路径问题简介

在图论中，最短路径问题（Shortest Path Problem）即在一个带权且连接着若干顶点的有向图G=(V,E)上找出一条从某一顶点s到另一顶点t的路径，使得路径上的每条边的权值之和最少。其一般形式如下：设G=(V,E)是一个带权有向图，其中顶点集V={v1,v2,...,vn}，其中vi∈{1,2,...,n}表示图中的顶点，边集E={(u,v):u,v∈V,u≠v}表示图中的边，权函数w: E->R是指从顶点u到顶点v的边的权值，并满足对所有的u,v∈V和任意两个不同的顶点x,y∈V，如果存在一条从x到y的路径，则有w(x,y)=min{w(x,z)+w(z,y)},其中z是经过顶点z的中间顶点。已知源点s和终点t，求从s到t的最短路径及其权值。通常采用广度优先搜索或Dijkstra算法解决此类问题。由于其NP完全性，因此目前还没有一种完美的时间复杂度为O(n^2m)的算法。然而，一些近似算法具有较好的运行时间，如Bellman-Ford算法、Floyd-Warshall算法等。

## 二、算法设计
### 1. Floyd-Warshall算法
Floyd-Warshall算法基于动态规划法，对于任意给定的整数n，其运行时间为Θ(n^3)。它是一个多源最短路径算法，适用于稠密图，并能求出任意两点间的最短距离。其基本思想是在做状态转移时，不仅考虑当前位置到达其他所有顶点的距离，而且也考虑直接从相邻顶点过来的距离。这样一来，就可以将状态空间压缩到一维数组，从而避免了在矩阵乘法运算时的复杂度。该算法可以应用于负权值的情况，但由于其复杂度太高，很难处理实际问题。

### 2. Dijkstra算法
Dijkstra算法与BFS、DFS等搜索算法一样，也是一种贪心算法。它的特点是每次选择距离源点最近的一个顶点，直至所有顶点都已经加入到最终路径中。它适用于无权值的图，也可用作改进的Dijkstra算法。其运行时间为Θ(mnlog n)，m为顶点个数，n为边个数。可以证明其为最短路径算法中最快的一种。

### 3. Bellman-Ford算法
Bellman-Ford算法是一种动态规划算法，它能计算单源最短路径和负权重的单源最短路径。其运行时间为Θ((mn)^2), m为顶点个数，n为边个数。其特点是利用松弛约束求解单源最短路径。但是，当图中存在负权回路时，其无法检测出来，因此不适合于所有权值均为非负的图。其特点是利用松弛约束求解单源最短路径。

## 三、示例分析
### 1. 正权图例：



假设源点s=1，目标点t=4。采用Floyd-Warshall算法求出最短路径：

初始化dist[][][] = {{ {0,INF,INF,INF,INF},
                        {INF,0,INF,INF,INF},
                        {INF,INF,0,INF,INF},
                        {INF,INF,INF,0,INF},
                        {INF,INF,INF,INF,0} }}; 

for k from 1 to n do
    for i from 1 to n do
        for j from 1 to n do
            if (i!= j && dist[i][j] > dist[i][k] + dist[k][j]) then
                dist[i][j] ← dist[i][k] + dist[k][j];
                
最后dist[s][t]=4。因此，最短路径为s->2->3->4。

采用Dijkstra算法求出最短路径：

用dist数组保存每个节点到源点s的最短距离；用pre数组保存前驱节点。初始化dist[s] = 0; others = INF. 将S加入队列Q;
while Q is not empty do
    u = extract min vertex in Q with dist[u]
    foreach v adjacent to u do
        newDist = dist[u] + w(u,v);
        if (newDist < dist[v]) then
            dist[v] = newDist;
            pre[v] = u;

最后dist[t]即为s到t的最短距离。 

采用Bellman-Ford算法求出最短路径：

利用松弛约束求解单源最短路径，其特点是遍历每条边一次，因此，在得到结果前需要进行 |V|-1 次松弛操作。

在第 i 轮迭代中，对每个顶点 v ，遍历所有入射边 (u,v)，松弛操作是 dist[v] = min(dist[v], dist[u]+weight(u,v)) 。由于负权回路的问题，需要检查松弛后的结果是否发生变化，如果变化则说明存在负权回路，此时输出错误信息，停止算法执行。否则，算法继续执行到第 i+1 轮迭代。