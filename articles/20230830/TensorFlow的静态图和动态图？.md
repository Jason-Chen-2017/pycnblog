
作者：禅与计算机程序设计艺术                    

# 1.简介
  

静态图和动态图是tensorflow的两种执行方式。它们的区别主要体现在计算图的构建阶段上。

静态图构建完后，系统会对整个计算图进行一次优化并生成计算指令序列。然后，编译器可以直接将这些指令序列转换成可执行的程序。这种方式下，模型运行时无需反复解析计算图，效率较高。但是，当模型结构变化时，需要重新构建计算图，这样就导致了训练速度慢、耗费资源多等问题。因此，静态图适用于训练模型时只需要改变模型结构不频繁的场景。

而动态图则不同。在这种情况下，系统不会提前生成所有计算指令。相反，它只会根据运行时的输入数据及参数，通过底层的自动微分机制来求取梯度值。根据梯度值，系统会决定如何更新模型参数以达到更好的效果。动态图的优点是易于调试，可以在不停地修改网络结构和训练参数的情况下快速调整结果；缺点也显而易见，它的计算开销比静态图大得多，而且其自动微分机制可能会让初学者感到困惑。除此之外，动态图还存在很多细节上的限制，比如限制了某些操作的实现（如一些控制流操作）、无法并行化运算、需要对内存管理非常谨慎等。

# 2.基本概念术语说明
## 定义与特点
静态图：在tensorflow中，默认采用静态图的方式运行。用户定义好一个计算图之后，系统生成该计算图的指令序列，再通过优化器编译成优化后的二进制文件，然后执行指令序列，完成模型的前向传播和反向传播过程。

动态图：在tensorflow中，若用户需要采用动态图的方式运行，则需要手动切换到dynamic_graph模式，然后建立该计算图。在运行过程中，系统根据输入数据及参数，通过底层的自动微分机制，不断计算梯度，并根据梯度更新模型的参数。

两者的区别在于计算图的构建阶段。静态图由用户定义，系统优化并生成指令序列。动态图根据用户输入数据及参数，系统不断计算梯度，更新参数。动态图的执行流程类似于一个循环，每次迭代都会触发一次前向传播和反向传播。

## TensorFlow对象图与计算图
TensorFlow中的对象图与计算图是密切相关的。对象图表示的是程序运行所需要的所有对象的集合，包括变量、张量、损失函数等。计算图则是在对象图基础上建立的运行图，它记录了如何从输入数据计算出目标输出的过程。

在静态图模式下，系统首先创建对象图，然后分析对象之间的依赖关系，最后生成计算图的指令序列。在这个过程中，如果有节点之间有依赖关系，即有张量之间的数据依赖，系统会对计算图做一些优化，比如合并多个节点，或者对计算图结构进行重排。

而在动态图模式下，系统仅仅是构建计算图，并不进行优化，只有在运行时才会根据输入数据及参数计算梯度，并更新参数。这意味着系统不需要生成完整的计算图，只需要构建子图，然后在合适的时候启动计算即可。动态图也支持在运行过程中将计算图切割成不同的子图，并并行执行，从而加快计算速度。

## 符号求导法则
在tensorflow中，通过tf.GradientTape()上下文管理器来跟踪张量，并利用其方法record()，记录张量在给定函数下的梯度信息。在下游调用过程中，可以使用tape.gradient(target, sources)函数来求取函数target对于源张量sources的导数。

但是，由于自动微分机制的限制，tf.GradientTape()不能处理控制流相关的操作，所以目前用法仍较少。除此之外，在实际使用中，还存在其他一些需要注意的问题。比如，tf.GradientTape()是基于符号式求导法则的，所以对于数值精度要求较高；另外，计算图的大小也可能影响到计算性能。为了解决这些问题，一些开源项目尝试基于ADMM的方法，并针对性设计了新的控制流机制，同时优化了计算图的大小。不过，目前来看，静态图或动态图都具有较好的表现力，各自适用于不同的场景。