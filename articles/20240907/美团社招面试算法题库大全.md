                 

# 2025美团社招面试算法题库大全

## 1. 动态规划问题

### 1.1. 最长递增子序列

**题目：** 给定一个无序数组，找到最长递增子序列的长度。

**答案：**

```go
func lengthOfLIS(nums []int) int {
    n := len(nums)
    dp := make([]int, n)
    for i := 0; i < n; i++ {
        dp[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}
```

**解析：** 使用动态规划求解，dp[i] 表示以 nums[i] 结尾的最长递增子序列的长度。遍历数组，更新 dp[i] 的值。

### 1.2. 最长公共子序列

**题目：** 给定两个字符串，找到它们的最长公共子序列。

**答案：**

```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }
    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

**解析：** 使用动态规划求解，dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度。

## 2. 图算法问题

### 2.1. 单源最短路径

**题目：** 使用 Dijkstra 算法求解单源最短路径。

**答案：**

```go
func dijkstra(graph [][]int, start int) []int {
    n := len(graph)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0
    priorityQueue := PriorityQueue{items: make([]int, 0, n)}
    priorityQueue.items = append(priorityQueue.items, start)
    priorityQueue.sort()
    for priorityQueue.isEmpty() {
        u := priorityQueue.extractMin()
        for v, w := range graph[u] {
            if dist[u]+w < dist[v] {
                dist[v] = dist[u]+w
                priorityQueue.items = append(priorityQueue.items, v)
                priorityQueue.sort()
            }
        }
    }
    return dist
}
```

**解析：** 使用优先队列实现 Dijkstra 算法，优先队列中存储未处理的节点和它们到起点的距离。每次选择距离最小的节点，更新其他节点的距离。

### 2.2. 寻找单源最短路径上的所有路径

**题目：** 给定一个有权重的无向图，找到从源点到目标点的所有最短路径。

**答案：**

```go
func allPathsSourceTarget(graph [][]int) [][]int {
    n := len(graph)
    paths := make([][][]int, n)
    for i := range paths {
        paths[i] = make([][]int, 0)
    }
    dfs(graph, 0, n-1, []int{}, &paths[0])
    return paths[0]
}

func dfs(graph [][]int, u, target int, path []int, paths *[][]int) {
    path = append(path, u)
    if u == target {
        *paths = append(*paths, append([]int{}, path...))
    } else {
        for v := range graph[u] {
            dfs(graph, v, target, path, paths)
        }
    }
}
```

**解析：** 使用深度优先搜索（DFS）遍历所有可能的路径，当到达目标节点时，将当前路径添加到 paths 中。

## 3. 数据结构问题

### 3.1. 设计哈希表

**题目：** 设计一个哈希表，支持添加、删除和查询操作。

**答案：**

```go
type MyHashMap struct {
    buckets []*entry
    size    int
}

func Constructor(k int) MyHashMap {
    return MyHashMap{
        buckets: make([]*entry, k),
        size:    k,
    }
}

func (this *MyHashMap) Put(key int, value int) {
    index := hash(key, this.size)
    if this.buckets[index] == nil {
        this.buckets[index] = &entry{key, value}
    } else {
        this.buckets[index].value = value
    }
}

func (this *MyHashMap) Get(key int) int {
    index := hash(key, this.size)
    if this.buckets[index] == nil {
        return -1
    }
    return this.buckets[index].value
}

func (this *MyHashMap) Delete(key int) {
    index := hash(key, this.size)
    if this.buckets[index] != nil {
        this.buckets[index] = nil
    }
}

type entry struct {
    key  int
    value int
}

func hash(key int, size int) int {
    return key % size
}
```

**解析：** 使用哈希表实现，哈希函数将键映射到哈希表中的索引。添加、删除和查询操作的时间复杂度为 O(1)。

### 3.2. 设计有序哈希表

**题目：** 设计一个有序哈希表，支持添加、删除和查询操作。

**答案：**

```go
type SortedHashMap struct {
    buckets []*entry
    size    int
}

func Constructor(k int) SortedHashMap {
    return SortedHashMap{
        buckets: make([]*entry, k),
        size:    k,
    }
}

func (this *SortedHashMap) Put(key int, value int) {
    index := hash(key, this.size)
    if this.buckets[index] == nil {
        this.buckets[index] = &entry{key, value}
    } else {
        for e := this.buckets[index]; e != nil; e = e.next {
            if e.key == key {
                e.value = value
                return
            }
        }
        e.next = &entry{key, value}
    }
}

func (this *SortedHashMap) Get(key int) int {
    index := hash(key, this.size)
    if this.buckets[index] == nil {
        return -1
    }
    for e := this.buckets[index]; e != nil; e = e.next {
        if e.key == key {
            return e.value
        }
    }
    return -1
}

func (this *SortedHashMap) Delete(key int) {
    index := hash(key, this.size)
    if this.buckets[index] == nil {
        return
    }
    prev := this.buckets[index]
    for e := prev; e != nil; e = e.next {
        if e.key == key {
            if prev == e {
                this.buckets[index] = e.next
            } else {
                prev.next = e.next
            }
            return
        }
        prev = e
    }
}

type entry struct {
    key  int
    value int
    next  *entry
}

func hash(key int, size int) int {
    return key % size
}
```

**解析：** 在哈希表中添加一个 next 指针，用于维护有序链表。添加、删除和查询操作的时间复杂度为 O(1)。

## 4. 算法面试题

### 4.1. 找出数组的重复元素

**题目：** 给定一个数组，找出其中的重复元素。

**答案：**

```go
func findDuplicate(nums []int) int {
    n := len(nums)
    for i := 0; i < n; i++ {
        idx := abs(nums[i]) - 1
        if nums[idx] < 0 {
            return abs(nums[idx])
        }
        nums[idx] = -nums[idx]
    }
    return 0
}
```

**解析：** 使用数组下标作为哈希表的键，将数组中的元素取绝对值后作为下标，并反向标记。找到重复元素后返回。

### 4.2. 找到字符串中的第一个唯一字符

**题目：** 给定一个字符串，找到其中的第一个唯一字符。

**答案：**

```go
func firstUniqChar(s string) int {
    freq := make([]int, 26)
    for _, c := range s {
        freq[int(c-'a')]++
    }
    for i, c := range s {
        if freq[int(c-'a')] == 1 {
            return i
        }
    }
    return -1
}
```

**解析：** 使用数组存储字符串中每个字符的频率，遍历字符串并找到第一个频率为 1 的字符。

## 5. 系统设计题

### 5.1. 设计LRU缓存

**题目：** 设计一个具有固定大小的LRU（最近最少使用）缓存。

**答案：**

```go
type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head, tail *Node
}

func Constructor(capacity int) LRUCache {
    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*Node),
        head: &Node{},
        tail: &Node{},
    }
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToFront(node)
        return node.val
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.val = value
        this.moveToFront(node)
    } else {
        newNode := &Node{key, value}
        this.cache[key] = newNode
        this.addToFront(newNode)
        if len(this.cache) > this.capacity {
            oldest := this.tail.next
            delete(this.cache, oldest.key)
            this.removeFromFront(oldest)
        }
    }
}

func (this *LRUCache) moveToFront(node *Node) {
    this.removeFromFront(node)
    this.addToFront(node)
}

func (this *LRUCache) removeFromFront(node *Node) {
    if node == this.head || node == this.tail {
        return
    }
    prev := node.prev
    next := node.next
    prev.next = next
    next.prev = prev
}

func (this *LRUCache) addToFront(node *Node) {
    node.next = this.head.next
    node.prev = this.head
    this.head.next.prev = node
    this.head.next = node
}

type Node struct {
    key   int
    val   int
    prev  *Node
    next  *Node
}
```

**解析：** 使用双向链表实现，最近访问的节点移到链表头部，超出容量时删除链表尾部的节点。

### 5.2. 设计一个分布式锁

**题目：** 设计一个分布式锁，支持分布式系统中的多节点间互斥访问。

**答案：**

```go
type RedisLock struct {
    key       string
    expiration int64
    client    *redis.Client
}

func NewRedisLock(key string, expiration int64, client *redis.Client) *RedisLock {
    return &RedisLock{
        key:       key,
        expiration: expiration,
        client:    client,
    }
}

func (l *RedisLock) Lock() error {
    return l.client.SetNX(l.key, "locked", l.expiration).Err()
}

func (l *RedisLock) Unlock() error {
    script := "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"
    return l.client.Eval(script, []string{l.key}, 1, "locked").Err()
}
```

**解析：** 使用 Redis 的 SETNX 命令实现分布式锁，锁的过期时间由锁持有时间决定。使用 Lua 脚本实现解锁，保证原子性。

## 6. 算法面试题

### 6.1. 搜索旋转排序数组

**题目：** 搜索一个旋转排序的数组中的一个目标值。

**答案：**

```go
func search(nums []int, target int) int {
    l, r := 0, len(nums)-1
    for l <= r {
        mid := (l + r) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[l] <= nums[mid] {
            if target >= nums[l] && target < nums[mid] {
                r = mid - 1
            } else {
                l = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[r] {
                l = mid + 1
            } else {
                r = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 使用二分查找，判断中点所在的分区，将问题转化为常规二分查找。

### 6.2. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度。

**答案：**

```go
func longestConsecutive(nums []int) int {
    s := make(map[int]bool)
    for _, num := range nums {
        s[num] = true
    }
    ans := 0
    for num := range s {
        if !s[num-1] {
            count := 1
            for num+count <= len(nums) && s[num+count] {
                count++
            }
            ans = max(ans, count)
        }
    }
    return ans
}
```

**解析：** 使用哈希表存储数组中的元素，遍历数组，判断当前元素是否为最长连续序列的起始点，计算连续序列的长度。

