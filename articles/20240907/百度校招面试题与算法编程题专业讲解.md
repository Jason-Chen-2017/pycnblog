                 

### 2024百度校招面试题与算法编程题专业讲解

#### 1. 反转链表

**题目描述：** 实现一个函数，反转单链表。

**代码实现：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head

    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }

    return prev
}
```

**答案解析：** 通过遍历链表，将每个节点的 `Next` 指针指向前一个节点，实现链表反转。时间复杂度 O(n)，空间复杂度 O(1)。

#### 2. 合并两个有序链表

**题目描述：** 实现一个函数，合并两个有序的单链表，返回合并后的链表。

**代码实现：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    } else if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}
```

**答案解析：** 通过遍历两个有序链表，比较当前节点值，将较小值插入新链表中。时间复杂度 O(n+m)，空间复杂度 O(1)。

#### 3. 二进制求和

**题目描述：** 给你两个二进制字符串，返回它们的和（用二进制表示）。

**代码实现：**

```go
func addBinary(a string, b string) string {
    i, j := len(a)-1, len(b)-1
    carry := 0
    res := ""

    for i >= 0 || j >= 0 || carry > 0 {
        if i >= 0 {
            carry += int(a[i] - '0')
            i--
        }
        if j >= 0 {
            carry += int(b[j] - '0')
            j--
        }
        res = strconv.Itoa(carry%2) + res
        carry /= 2
    }

    return res
}
```

**答案解析：** 从低位开始，依次求和，并将进位保留。最后将求和结果转换为二进制字符串。时间复杂度 O(max(len(a), len(b)))，空间复杂度 O(1)。

#### 4. 字符串转换整数 (atoi)

**题目描述：** 实现一个函数，将字符串转换为整数。

**代码实现：**

```go
func myAtoi(s string) int {
    const (
        MaxInt32 = 1 << 31 - 1
        MinInt32 = -1 << 31
    )
    i, sign, ans := 0, 1, 0
    for i < len(s) && (s[i] == ' ' || s[i] == '\t') {
        i++
    }
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        sign = -1
        i++
    }
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        if ans > (MaxInt32 - int(s[i]-'0'))/sign {
            return MaxInt32
        }
        if ans < (MinInt32 + int(s[i]-'0'))/sign {
            return MinInt32
        }
        ans = ans*10 + int(s[i]-'0')
        i++
    }
    return ans * sign
}
```

**答案解析：** 从字符串中依次读取字符，判断是否为空格、正负号或数字。对于数字，将其转换为整数，注意判断整数溢出。时间复杂度 O(n)，空间复杂度 O(1)。

#### 5. 两数相加

**题目描述：** 实现一个函数，计算两个非空链表表示的两个非负整数的和。

**代码实现：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        curr.Next = &ListNode{
            Val: (val1 + val2 + carry) % 10,
            Next: nil,
        }
        carry = (val1 + val2 + carry) / 10
        curr = curr.Next
    }
    return dummy.Next
}
```

**答案解析：** 通过遍历两个链表，依次计算两个节点值的和，并处理进位。最后将结果链表返回。时间复杂度 O(max(n, m))，空间复杂度 O(1)。

#### 6. 字符串转换成整数 (atoi)

**题目描述：** 实现一个函数，将字符串转换为整数。

**代码实现：**

```go
func myAtoi(s string) int {
    const (
        MaxInt32 = 1 << 31 - 1
        MinInt32 = -1 << 31
    )
    i, sign, ans := 0, 1, 0
    for i < len(s) && (s[i] == ' ' || s[i] == '\t') {
        i++
    }
    if i < len(s) && (s[i] == '+' || s[i] == '-') {
        sign = -1
        i++
    }
    for i < len(s) && s[i] >= '0' && s[i] <= '9' {
        if ans > (MaxInt32 - int(s[i]-'0'))/sign {
            return MaxInt32
        }
        if ans < (MinInt32 + int(s[i]-'0'))/sign {
            return MinInt32
        }
        ans = ans*10 + int(s[i]-'0')
        i++
    }
    return ans * sign
}
```

**答案解析：** 从字符串中依次读取字符，判断是否为空格、正负号或数字。对于数字，将其转换为整数，注意判断整数溢出。时间复杂度 O(n)，空间复杂度 O(1)。

#### 7. 两数相加

**题目描述：** 实现一个函数，计算两个非空链表表示的两个非负整数的和。

**代码实现：**

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0
    for l1 != nil || l2 != nil || carry > 0 {
        val1 := 0
        if l1 != nil {
            val1 = l1.Val
            l1 = l1.Next
        }
        val2 := 0
        if l2 != nil {
            val2 = l2.Val
            l2 = l2.Next
        }
        curr.Next = &ListNode{
            Val: (val1 + val2 + carry) % 10,
            Next: nil,
        }
        carry = (val1 + val2 + carry) / 10
        curr = curr.Next
    }
    return dummy.Next
}
```

**答案解析：** 通过遍历两个链表，依次计算两个节点值的和，并处理进位。最后将结果链表返回。时间复杂度 O(max(n, m))，空间复杂度 O(1)。

#### 8. 快乐数

**题目描述：** 编写一个算法来判断一个数是否是“快乐数”。

**代码实现：**

```go
func isHappy(n int) bool {
    defi
``` <|vqi|>n>0
    seen := make(map[int]bool)
    for n != 1 {
        if seen[n] {
            return false
        }
        seen[n] = true
        n = getNext(n)
    }
    return true
}

func getNext(n int) int {
    sum := 0
    for n > 0 {
        digit := n % 10
        sum += digit * digit
        n /= 10
    }
    return sum
}
```

**答案解析：** 通过循环判断当前数是否已出现过，如果出现过则说明进入循环，返回 false。否则，计算下一个数，并判断是否为 1，如果为 1 则说明是快乐数，返回 true。时间复杂度 O(logn)，空间复杂度 O(logn)。

#### 9. 字符串轮换

**题目描述：** 编写一个函数，实现字符串的轮换。

**代码实现：**

```go
func rotateString(s string, k int) string {
    n := len(s)
    k %= n
    if k == 0 {
        return s
    }
    sRunes := []rune(s)
    reverse(sRunes, 0, n-k-1)
    reverse(sRunes, n-k, n-1)
    reverse(sRunes, 0, n-1)
    return string(sRunes)
}

func reverse(s []rune, start, end int) {
    for i, j := start, end; i < j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
```

**答案解析：** 利用反转字符串的算法，首先反转前 k 个字符，然后反转剩余的字符，最后反转整个字符串。时间复杂度 O(n)，空间复杂度 O(1)。

#### 10. 最长公共前缀

**题目描述：** 编写一个函数来查找字符串数组中的最长公共前缀。

**代码实现：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }
    for i := 0; i < len(strs[0]); i++ {
        for j := 1; j < len(strs); j++ {
            if i >= len(strs[j]) || strs[0][i] != strs[j][i] {
                return strs[0][:i]
            }
        }
    }
    return strs[0]
}
```

**答案解析：** 从第一个字符串开始，逐个比较后续字符串的字符，一旦出现不同的字符，则返回当前公共前缀。时间复杂度 O(n*m)，空间复杂度 O(1)。

#### 11. 两数之和

**题目描述：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**代码实现：**

```go
func twoSum(nums []int, target int) []int {
    var idx [2]int = [2]int{-1, -1}
    var h = make(map[int]int)

    for i, num := range nums {
        if pos, ok := h[target-num]; ok {
            idx[0] = pos
            idx[1] = i
            break
        }
        h[num] = i
    }

    return idx[:]
}
```

**答案解析：** 使用哈希表实现，遍历数组，将每个元素作为键存入哈希表中，同时检查哈希表中是否存在 `target - num` 的键。时间复杂度 O(n)，空间复杂度 O(n)。

#### 12. 合并两个有序数组

**题目描述：** 给你两个整数数组 `nums1` 和 `nums2` ，按 `数组中元素的相对顺序` 合并两个数组。

**代码实现：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    i, j, k := m-1, n-1, m+n-1
    for i >= 0 && j >= 0 {
        if nums1[i] > nums2[j] {
            nums1[k] = nums1[i]
            i--
        } else {
            nums1[k] = nums2[j]
            j--
        }
        k--
    }
    for j >= 0 {
        nums1[k] = nums2[j]
        j--
        k--
    }
}
```

**答案解析：** 从后向前比较两个数组中的元素，将较大的元素填充到 `nums1` 的末尾。时间复杂度 O(m+n)，空间复杂度 O(1)。

#### 13. 盛最多水的容器

**题目描述：** 给定一个二叉树，找出其中两条边构成的容器的最大容量。

**代码实现：**

```go
func maxArea(height []int) int {
    i, j := 0, len(height)-1
    res := 0
    for i < j {
        left, right := height[i], height[j]
        res = max(res, (j-i)*min(left, right))
        if left < right {
            i++
        } else {
            j--
        }
    }
    return res
}
```

**答案解析：** 双指针法，分别从数组的两端开始遍历，每次比较两边的高度，取较小值与两边之差作为当前容器的容量，更新最大容量。时间复杂度 O(n)，空间复杂度 O(1)。

#### 14. 二叉树的层次遍历

**题目描述：** 给定一个二叉树，返回其节点值的层次遍历结果。

**代码实现：**

```go
func levelOrder(root *TreeNode) [][]int {
    var ans [][]int
    if root == nil {
        return ans
    }
    var q []*TreeNode = []*TreeNode{root}
    for len(q) > 0 {
        var t []*TreeNode
        var level []int
        for _, v := range q {
            level = append(level, v.Val)
            if v.Left != nil {
                t = append(t, v.Left)
            }
            if v.Right != nil {
                t = append(t, v.Right)
            }
        }
        ans = append(ans, level)
        q = t
    }
    return ans
}
```

**答案解析：** 使用广度优先搜索（BFS）遍历二叉树，每次循环处理一层节点，将当前层节点的值存入列表中，并将下一层节点添加到队列中。时间复杂度 O(n)，空间复杂度 O(n)。

#### 15. 剑指 Offer 52. 两个链表的第一个公共节点

**题目描述：** 输入两个链表，找出它们的第一个公共节点。

**代码实现：**

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    pa, pb := headA, headB
    for pa != pb {
        if pa == nil {
            pa = headB
        } else {
            pa = pa.Next
        }
        if pb == nil {
            pb = headA
        } else {
            pb = pb.Next
        }
    }
    return pa
}
```

**答案解析：** 两个指针分别从两个链表的头节点开始遍历，一个指针到达链表末尾时，重置为另一个链表的头节点。当两个指针相遇时，即为两个链表的第一个公共节点。时间复杂度 O(n+m)，空间复杂度 O(1)。

#### 16. 剑指 Offer 55 - II. 平衡二叉树

**题目描述：** 输入一棵二叉树的根节点，判断该树是否是平衡二叉树。

**代码实现：**

```go
func isBalanced(root *TreeNode) bool {
    defi
``` <|vqi|>0
    return check(root) > 0
}

func check(node *TreeNode) int {
    if node == nil {
        return 0
    }
    left := check(node.Left)
    if left < 0 {
        return -1
    }
    right := check(node.Right)
    if right < 0 {
        return -1
    }
    if abs(left-right) > 1 {
        return -1
    }
    return max(left, right) + 1
}
```

**答案解析：** 递归判断每个节点是否是平衡二叉树，返回当前节点的高度。如果当前节点的高度差大于 1，则返回 -1。否则，返回左右子树的高度加 1。根节点的平衡性取决于子节点的高度差。时间复杂度 O(n)，空间复杂度 O(n)。

#### 17. 寻找两个正序数组的中位数

**题目描述：** 给定两个大小分别为 `m` 和 `n` 的正序数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 `中位数`。

**代码实现：**

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    m, n := len(nums1), len(nums2)
    if m > n {
        return findMedianSortedArrays(nums2, nums1)
    }
    imin, imax, halfLen := 0, m, (m+n+1)/2
    for imin <= imax {
        i := (imin + imax) / 2
        j := halfLen - i
        if i < m && nums2[j-1] > nums1[i] {
            imax = i - 1
        } else if i > 0 && nums1[i-1] > nums2[j] {
            imin = i + 1
        } else {
            if i == 0 {
                maxLeft := nums2[j-1]
            } else if j == 0 {
                maxLeft := nums1[i-1]
            } else {
                maxLeft := max(nums1[i-1], nums2[j-1])
            }
            if (m+n)%2 == 1 {
                return float64(maxLeft)
            }
            minRight := 0
            if i == m {
                minRight = nums2[j]
            } else if j == n {
                minRight = nums1[i]
            } else {
                minRight = min(nums1[i], nums2[j])
            }
            return float64(maxLeft+minRight) / 2
        }
    }
    return 0
}
```

**答案解析：** 使用二分查找法找到两个数组的中间元素。首先确定 `imin` 和 `imax`，然后在 `imin` 和 `imax` 之间遍历，找到合适的位置。最后根据数组长度判断返回中位数。时间复杂度 O(log(min(m, n)))，空间复杂度 O(1)。

#### 18. 剑指 Offer 57 - 和为指定值

**题目描述：** 写一个函数，计算两个整数之和，要求在函数体内不得使用 + 或者 −。

**代码实现：**

```go
func getSum(a int, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}
```

**答案解析：** 使用位运算实现加法。通过不断计算 `a ^ b` 得到无进位和，计算 `a & b` 得到进位，将进位左移一位后再次与无进位和相加。循环直到进位为 0。时间复杂度 O(n)，空间复杂度 O(1)。

#### 19. 剑指 Offer 39. 数组中出现次数超过一半的数字

**题目描述：** 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

**代码实现：**

```go
func majorityElement(nums []int) int {
    count, candidate := 0, 0
    for num := range nums {
        if count == 0 {
            candidate = nums[num]
            count = 1
        } else if nums[num] == candidate {
            count++
        } else {
            count--
        }
    }
    return candidate
}
```

**答案解析：** 使用摩尔投票法。首先选举一个候选数字，然后遍历数组，统计候选数字的出现次数。如果出现次数小于 0，则重新选举候选数字。最后返回候选数字。时间复杂度 O(n)，空间复杂度 O(1)。

#### 20. 剑指 Offer 68 - I. 删除重复节点

**题目描述：** 给出一个单链表，删除其中重复的节点，使每个元素只出现一次。

**代码实现：**

```go
func deleteDuplicateNodes(pHead *ListNode) *ListNode {
    dummy := &ListNode{Next: pHead}
    cur := dummy
    p := pHead
    for p != nil {
        q := p
        for q != nil && q.Next != nil && q.Next.Val != p.Val {
            q = q.Next
        }
        if q == nil || q.Next == nil {
            cur.Next = p.Next
        } else {
            p = p.Next
        }
        cur = cur.Next
    }
    return dummy.Next
}
```

**答案解析：** 使用快慢指针法。慢指针每次移动一步，快指针每次移动两步。如果快指针指向的节点与慢指针指向的节点值相同，则删除慢指针指向的节点。否则，慢指针和快指针同时移动。时间复杂度 O(n)，空间复杂度 O(1)。

#### 21. 剑指 Offer 46. 把数字翻译成字符串

**题目描述：** 给定一个数字，按要求将数字翻译成字符串。

**代码实现：**

```go
func translateNum(num int) int {
    s := strconv.Itoa(num)
    n := len(s)
    dp := make([]int, n+1)
    dp[0] = 1
    dp[1] = 1
    for i := 2; i <= n; i++ {
        if (s[i-2]-'0')*10+(s[i-1]-'0') < 26 {
            dp[i] = dp[i-1] + dp[i-2]
        } else {
            dp[i] = dp[i-1]
        }
    }
    return dp[n]
}
```

**答案解析：** 使用动态规划。定义一个数组 `dp`，其中 `dp[i]` 表示从字符串第 `i` 个位置开始到字符串末尾的翻译方案数。遍历字符串，判断当前位置和前一位是否可以组成一个有效的两位数字，如果可以，则将当前位置的方案数累加到前两位位置的方案数上。否则，直接将当前位置的方案数赋值给前一位位置的方案数。时间复杂度 O(n)，空间复杂度 O(n)。

#### 22. 剑指 Offer 43. 1 的个数

**题目描述：** 计算一个32位无符号整数二进制表示中1的个数。

**代码实现：**

```go
func hammingWeight(num uint32) int {
    count := 0
    for num != 0 {
        count++
        num = num & (num - 1)
    }
    return count
}
```

**答案解析：** 使用位运算。将数字与数字减 1 的结果进行按位与运算，每次操作将最后一位 1 变为 0，并计数。循环直到数字变为 0。时间复杂度 O(logn)，空间复杂度 O(1)。

#### 23. 剑指 Offer 35. 复杂链表的复制

**题目描述：** 复制一个复杂链表。

**代码实现：**

```go
type Node struct {
    Val  int
    Next *Node
    Rand *Node
}

func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }
    dummy := &Node{}
    curr := dummy
    cnt := 0
    pos := map[*Node]int{}
    for head != nil {
        curr.Next = &Node{Val: head.Val}
        pos[head] = cnt
        curr = curr.Next
        cnt++
        head = head.Next
    }
    curr.Next = nil
    head = dummy.Next
    for i := 0; i < cnt; i++ {
        if head.Random != nil {
            curr.Random = pos[head.Random]
        }
        head = head.Next
        curr = curr.Next
    }
    return dummy.Next
}
```

**答案解析：** 使用哈希表。首先创建一个新链表，将原链表中的每个节点复制到一个新节点，并将新节点插入到原链表中。然后，遍历新链表，通过哈希表查找原链表中的节点，设置新节点的 `Random` 指针。最后，将原链表和新链表分离。时间复杂度 O(n)，空间复杂度 O(n)。

#### 24. 剑指 Offer 36. 二叉搜索树与双向链表

**题目描述：** 将一个二叉搜索树转换为双向链表，要求节点顺序保持不变。

**代码实现：**

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 * }
 */

func treeToDoublyList(root *Node) *Node {
    if root == nil {
        return nil
    }
    var prev *Node
    var dummy *Node

    var dfs func(node *Node)
    dfs = func(node *Node) {
        if node == nil {
            return
        }
        dfs(node.Left)
        if prev == nil {
            dummy = node
        } else {
            prev.Right = node
            node.Left = prev
        }
        prev = node
        dfs(node.Right)
    }

    dfs(root)
    dummy.Left = prev
    prev.Right = dummy
    return dummy
}
```

**答案解析：** 使用递归中序遍历。在递归过程中，将前一个节点连接到当前节点，并更新前一个节点为当前节点。遍历完成后，设置头节点的 `Left` 指针指向最后一个节点，最后一个节点的 `Right` 指针指向头节点。时间复杂度 O(n)，空间复杂度 O(n)。

#### 25. 剑指 Offer 40. 最小的k个数

**题目描述：** 在未排序的数组中，找到最小的 `k` 个数。

**代码实现：**

```go
func getLeastNumbers(arr []int, k int) []int {
    if k == 0 {
        return nil
    }
    quickSelect(arr, 0, len(arr)-1, k)
    return arr[:k]
}

func quickSelect(arr []int, l, r, k int) {
    if l == r {
        return
    }
    pivotIndex := partition(arr, l, r)
    if k == pivotIndex {
        return
    } else if k < pivotIndex {
        quickSelect(arr, l, pivotIndex-1, k)
    } else {
        quickSelect(arr, pivotIndex+1, r, k)
    }
}

func partition(arr []int, l, r int) int {
    pivot := arr[r]
    i := l
    for j := l; j < r; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[r] = arr[r], arr[i]
    return i
}
```

**答案解析：** 使用快速选择算法。在数组中选择一个基准元素，将数组分为两部分，小于基准元素的放在基准元素左侧，大于基准元素的放在基准元素右侧。递归选择左侧或右侧的子数组，直到找到第 `k` 个最小的元素。时间复杂度 O(n)，空间复杂度 O(logn)。

#### 26. 剑指 Offer 29. 顺时针打印矩阵

**题目描述：** 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每个数字。

**代码实现：**

```go
func printMatrix(matrix [][]int) []int {
    if len(matrix) == 0 {
        return nil
    }
    ans := make([]int, 0, len(matrix)*len(matrix[0]))
    top, bottom := 0, len(matrix)
    left, right := 0, len(matrix[0])
    for bottom-top > 0 && right-left > 0 {
        for j := left; j < right; j++ {
            ans = append(ans, matrix[top][j])
        }
        for i := top + 1; i < bottom; i++ {
            ans = append(ans, matrix[i][right-1])
        }
        if top != bottom-1 {
            for j := right - 2; j >= left; j-- {
                ans = append(ans, matrix[bottom-1][j])
            }
        }
        if left != right-1 {
            for i := bottom - 2; i > top; i-- {
                ans = append(ans, matrix[i][left])
            }
        }
        top++
        bottom--
        left++
        right--
    }
    return ans
}
```

**答案解析：** 通过四个边界变量 `top`、`bottom`、`left`、`right` 来控制打印的行列范围。每次循环先打印上边界，然后打印右边界，接着打印下边界，最后打印左边界。时间复杂度 O(n^2)，空间复杂度 O(n)。

#### 27. 剑指 Offer 14. 对链表进行插入排序

**题目描述：** 对一个链表进行插入排序。

**代码实现：**

```go
type ListNode struct {
    Val int
    Next *ListNode
}

func insertionSortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    dummy := &ListNode{Next: head}
    curr := head
    for curr != nil && curr.Next != nil {
        if curr.Val <= curr.Next.Val {
            curr = curr.Next
            continue
        }
        prev := dummy
        for prev.Next.Val <= curr.Next.Val {
            prev = prev.Next
        }
        next := curr.Next
        curr.Next = next.Next
        next.Next = prev.Next
        prev.Next = next
    }
    return dummy.Next
}
```

**答案解析：** 使用插入排序。遍历链表，对于每个节点，将其插入到已排序链表中合适的位置。时间复杂度 O(n^2)，空间复杂度 O(1)。

#### 28. 剑指 Offer 23. 二叉树的镜像

**题目描述：** 对二叉树进行镜像遍历。

**代码实现：**

```go
func mirrorTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    left, right := root.Left, root.Right
    root.Left, root.Right = mirrorTree(right), mirrorTree(left)
    return root
}
```

**答案解析：** 使用递归。交换节点的左右子节点，然后递归处理左右子节点。时间复杂度 O(n)，空间复杂度 O(n)。

#### 29. 剑指 Offer 38. 字符串的排列

**题目描述：** 输入一个字符串，打印出字符串中字符的所有排列。

**代码实现：**

```go
func permutation(nums []byte) [][]byte {
    ans := make([][]byte, 0)
    var dfs func([]byte, int)
    dfs = func(path []byte, start int) {
        if start == len(nums) {
            t := make([]byte, len(nums))
            copy(t, path)
            ans = append(ans, t)
            return
        }
        for i := start; i < len(nums); i++ {
            if i != start && nums[i] == nums[start] {
                continue
            }
            nums[start], nums[i] = nums[i], nums[start]
            dfs(path, start+1)
            nums[start], nums[i] = nums[i], nums[start]
        }
    }
    dfs([]byte{}, 0)
    return ans
}
```

**答案解析：** 使用深度优先搜索。遍历字符串，对于每个字符，将其与后续字符交换，然后递归处理剩余的字符。遍历完成后，将字符还原。时间复杂度 O(n*n!)，空间复杂度 O(n)。

#### 30. 剑指 Offer 50. 第一个只出现一次的字符

**题目描述：** 在字符串 s 中找出第一个只出现一次的字符，并返回它的索引。如果不存在，返回 -1。

**代码实现：**

```go
func firstUniqChar(s string) int {
    cnt := [128]int{}
    for i := 0; i < len(s); i++ {
        cnt[s[i]]++
    }
    for i, c := range s {
        if cnt[c] == 1 {
            return i
        }
    }
    return -1
}
```

**答案解析：** 使用数组统计每个字符出现的次数。遍历字符串，找到第一个出现次数为 1 的字符，并返回其索引。时间复杂度 O(n)，空间复杂度 O(1)。

