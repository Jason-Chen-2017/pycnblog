                 

### 华为2025届校招面试高频算法题解析

#### 1. 单调栈问题

**题目：** 给定一个整数数组 `arr`，返回一个数组 `result`，其中 `result[i]` 表示 `arr` 中从 `i` 到数组末尾的最长递增子序列的长度。

**示例：**
```python
arr = [2, 1, 5, 3, 6]
result = [3, 1, 2, 2, 3]
```

**解答：**
这个问题可以使用单调栈来解决。我们用一个栈来维护当前元素之前的所有元素，并记录每个元素对应的最长递增子序列的长度。

**代码实现：**
```python
def lengthOfLIS(nums):
    if not nums:
        return []
    
    n = len(nums)
    stk = [0] * n
    stkLen = 0
    result = [1] * n
    
    for i, num in enumerate(nums):
        while stkLen > 0 and nums[stk[stkLen - 1]] >= num:
            stkLen -= 1
        if stkLen == 0:
            stk.append(i)
            stkLen += 1
        else:
            result[i] = result[stk[stkLen - 1]] + 1
            stk.append(i)
            stkLen += 1
    
    return result
```

#### 2. 链表反转问题

**题目：** 给定一个单链表的头节点 `head`，请反转整个链表并返回新的头节点。

**示例：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# 输入
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
# 输出
head = ListNode(4, ListNode(3, ListNode(2, ListNode(1))))
```

**解答：**
这个问题可以使用递归或迭代的方法来解决。这里我们使用迭代方法。

**代码实现：**
```python
def reverseList(head):
    prev = None
    curr = head
    
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    
    return prev
```

#### 3. 二分查找问题

**题目：** 给定一个有序数组 `nums` 和一个目标值 `target`，找到 `nums` 中的 `target` 并返回其索引。如果不存在，返回 `-1`。

**示例：**
```python
nums = [1, 3, 5, 6]
target = 5
# 输出
# 索引：2
```

**解答：**
二分查找是一种高效搜索算法，可以在有序数组中找到目标值。我们不断缩小区间，直到找到目标值或确定目标值不存在。

**代码实现：**
```python
def searchInsert(nums, target):
    low, high = 0, len(nums) - 1
    
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    
    return low
```

#### 4. 环形链表问题

**题目：** 给定一个链表，判断链表中是否有环。

**示例：**
```python
# 输入
head = ListNode(3, ListNode(2, ListNode(0, ListNode(-4))))
# 输出
# 存在环
```

**解答：**
我们可以使用快慢指针法来判断链表中是否有环。快指针每次移动两个节点，慢指针每次移动一个节点。如果快指针追上慢指针，则链表中存在环。

**代码实现：**
```python
def hasCycle(head):
    fast = head
    slow = head
    
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
        if fast == slow:
            return True
    
    return False
```

#### 5. 最大子序和问题

**题目：** 给定一个整数数组 `nums`，找到数组中最大和连续子序列，返回其和。

**示例：**
```python
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
# 输出
# 最大子序和：6
```

**解答：**
这个问题可以使用动态规划的方法来解决。我们维护一个变量 `max_ending_here` 和 `max_so_far`，分别表示当前子序列的最大和和全局最大和。

**代码实现：**
```python
def maxSubArray(nums):
    max_ending_here = max_so_far = nums[0]
    
    for i in range(1, len(nums)):
        max_ending_here = max(nums[i], max_ending_here + nums[i])
        max_so_far = max(max_so_far, max_ending_here)
    
    return max_so_far
```

#### 6. 最小栈问题

**题目：** 设计一个最小栈，支持 push、pop 和 getMin 操作。

**示例：**
```python
# 输入
stack = MinStack()
stack.push(5)
stack.push(2)
stack.push(4)
stack.getMin()
# 输出
# 2
```

**解答：**
我们可以使用两个栈来实现最小栈。一个栈 `stack` 用于存储元素，另一个栈 `min_stack` 用于存储当前栈中最小元素的下标。

**代码实现：**
```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []

    def push(self, val: int) -> None:
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)

    def pop(self) -> None:
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

#### 7. 搜索旋转排序数组问题

**题目：** 给定一个旋转排序的数组，找出一个给定的目标值。数组中的每个元素都是唯一的。

**示例：**
```python
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
# 输出
# 索引：4
```

**解答：**
我们可以使用二分查找的方法来解决这个问题。由于数组是旋转的，我们需要找到旋转点，然后将数组分成两个有序子数组，再在其中一个子数组中查找目标值。

**代码实现：**
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

#### 8. 合并区间问题

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```python
intervals = [[1,3],[2,6],[8,10],[15,18]]
# 输出
# [[1,6],[8,10],[15,18]]
```

**解答：**
这个问题可以通过排序和合并区间来解决。我们首先对区间按照起点排序，然后依次合并相邻的区间。

**代码实现：**
```python
def merge(intervals):
    if not intervals:
        return []
    
    intervals.sort()
    result = [intervals[0]]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])
    
    return result
```

#### 9. 拓扑排序问题

**题目：** 给定一个无向图，返回其拓扑排序的序列。

**示例：**
```python
nodes = [[5, 2], [5, 0], [4, 0], [4, 1], [3, 4], [6, 4]]
# 输出
# [5, 4, 6, 3, 2, 0, 1]
```

**解答：**
这个问题可以通过深度优先搜索（DFS）和广度优先搜索（BFS）来实现。我们首先使用 DFS 来获取每个节点的入度，然后使用 BFS 来生成拓扑排序序列。

**代码实现：**
```python
from collections import defaultdict, deque

def拓扑排序(nodes):
    graph = defaultdict(list)
    in_degree = defaultdict(int)
    
    for u, v in nodes:
        graph[u].append(v)
        in_degree[v] += 1
    
    queue = deque()
    for node, deg in in_degree.items():
        if deg == 0:
            queue.append(node)
    
    result = []
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return result
```

#### 10. 合并两个有序链表问题

**题目：** 给定两个有序链表 `l1` 和 `l2`，合并它们并返回一个新的排序链表。

**示例：**
```python
# 输入
l1 = ListNode(1, ListNode(3, ListNode(5)))
l2 = ListNode(2, ListNode(4, ListNode(6)))
# 输出
# ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6))))))
```

**解答：**
我们可以使用迭代的方法来合并两个有序链表。我们创建一个新的头节点和当前节点，依次比较两个链表的当前节点值，将较小值添加到新链表中。

**代码实现：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1, l2):
    dummy = ListNode()
    curr = dummy
    
    while l1 and l2:
        if l1.val < l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    
    curr.next = l1 or l2
    return dummy.next
```

#### 11. 单词搜索问题

**题目：** 给定一个二维字符网格 `board` 和一个字符串 `word`，判断 `word` 是否存在于网格中。

**示例：**
```python
board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]]
word = "ABCCED"
# 输出
# True
```

**解答：**
这个问题可以使用深度优先搜索（DFS）来解决。我们从每个字符开始，尝试在网格中找到 `word` 的下一个字符，然后递归地搜索。

**代码实现：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        
        return res
    
    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    
    return False
```

#### 12. 有效的括号问题

**题目：** 给定一个字符串 `s` ，判断 `s` 是否为有效的括号字符串。

**示例：**
```python
s = "()[]{}"
# 输出
# True
```

**解答：**
这个问题可以使用栈来解决。我们遍历字符串，将左括号入栈，右括号与栈顶元素匹配并出栈。如果匹配成功，继续遍历；否则，返回 `False`。

**代码实现：**
```python
def isValid(s):
    stack = []
    mapping = {')': '(', ']': '[', '}': '{'}
    
    for c in s:
        if c in mapping:
            if not stack or stack.pop() != mapping[c]:
                return False
        else:
            stack.append(c)
    
    return not stack
```

#### 13. 二进制求和问题

**题目：** 给定两个二进制字符串，返回它们的和（也以二进制字符串的形式）。

**示例：**
```python
a = "11"
b = "1"
# 输出
# "100"
```

**解答：**
这个问题可以通过字符串反转和逐位相加来解决。我们先将两个字符串反转，然后从最低位开始相加，并在需要时进位。

**代码实现：**
```python
def addBinary(a, b):
    max_len = max(len(a), len(b))
    a = a.zfill(max_len)
    b = b.zfill(max_len)
    
    result = []
    carry = 0
    
    for i in range(max_len - 1, -1, -1):
        sum = carry
        sum += 1 if a[i] == '1' else 0
        sum += 1 if b[i] == '1' else 0
        result.append('1' if sum % 2 == 1 else '0')
        carry = sum // 2
    
    if carry:
        result.append('1')
    
    return ''.join(result[::-1])
```

#### 14. 删除链表的节点问题

**题目：** 给定一个单链表的头节点 `head` 和一个整数 `val`，删除链表中值为 `val` 的节点。

**示例：**
```python
# 输入
head = ListNode(4, ListNode(5, ListNode(1, ListNode(9))))
val = 5
# 输出
# ListNode(4, ListNode(1, ListNode(9)))
```

**解答：**
我们可以使用迭代的方法来解决这个问题。我们遍历链表，找到值为 `val` 的节点，然后将其前一个节点指向下一个节点。

**代码实现：**
```python
def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

#### 15. 合并两个有序数组问题

**题目：** 给定两个有序整数数组 `nums1` 和 `nums2`，将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。

**示例：**
```python
nums1 = [1, 2, 3, 0, 0, 0]
nums2 = [2, 5, 6]
# 输出
# [1, 2, 2, 3, 5, 6]
```

**解答：**
我们可以使用双指针的方法来解决这个问题。我们从两个数组的末尾开始比较，将较大的元素放入 `nums1` 的末尾，然后分别向前移动指针。

**代码实现：**
```python
def merge(nums1, m, nums2, n):
    i, j, k = m - 1, n - 1, m + n - 1
    
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
    
    return nums1
```

#### 16. 合并区间问题

**题目：** 给定一组区间，合并所有重叠的区间。

**示例：**
```python
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
# 输出
# [[1, 6], [8, 10], [15, 18]]
```

**解答：**
这个问题可以通过排序和合并区间来解决。我们首先对区间按照起点排序，然后依次合并相邻的区间。

**代码实现：**
```python
def merge(intervals):
    if not intervals:
        return []
    
    intervals.sort()
    result = [intervals[0]]
    
    for i in range(1, len(intervals)):
        if intervals[i][0] <= result[-1][1]:
            result[-1][1] = max(result[-1][1], intervals[i][1])
        else:
            result.append(intervals[i])
    
    return result
```

#### 17. 三数之和问题

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出三个数，使得它们的和与 `target` 最接近。

**示例：**
```python
nums = [-1, 0, 1, 2, -1, -4]
target = 1
# 输出
# [-1, 2, -1] 或 [-1, -1, 2]
```

**解答：**
这个问题可以通过排序和双指针的方法来解决。我们首先对数组进行排序，然后固定第一个数，使用双指针寻找两个数使得它们的和与 `target` 最接近。

**代码实现：**
```python
def threeSumClosest(nums, target):
    nums.sort()
    diff = float('inf')
    for i in range(len(nums) - 2):
        l, r = i + 1, len(nums) - 1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if abs(target - s) < abs(diff):
                diff = target - s
            if s < target:
                l += 1
            elif s > target:
                r -= 1
            else:
                return target
    return target - diff
```

#### 18. 搜索旋转排序数组问题

**题目：** 给定一个旋转排序的数组，找到目标值，并返回其索引。如果不存在，返回 `-1`。

**示例：**
```python
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
# 输出
# 索引：4
```

**解答：**
这个问题可以通过二分查找的方法来解决。我们需要找到旋转点，然后根据目标值与旋转点的关系，决定在哪个子数组中继续查找。

**代码实现：**
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

#### 19. 最长公共前缀问题

**题目：** 给定一个字符串数组 `strs`，返回 `strs` 的最长公共前缀。

**示例：**
```python
strs = ["flower", "flow", "flight"]
# 输出
# "fl"
```

**解答：**
这个问题可以通过逐个字符比较的方法来解决。我们从第一个字符串开始，逐个比较后续字符串，直到找到不匹配的字符。

**代码实现：**
```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    
    prefix = strs[0]
    for s in strs[1:]:
        i = 0
        while i < len(prefix) and i < len(s):
            if prefix[i] != s[i]:
                break
            i += 1
        prefix = prefix[:i]
    
    return prefix
```

#### 20. 两数相加问题

**题目：** 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只存储单个数字。请将这两个数相加，并以相同形式返回一个表示和的链表。

**示例：**
```python
# 输入：l1 = [2, 4, 3], l2 = [5, 6, 4]
# 输出：[7, 0, 8]
# 解释：342 + 465 = 807.
```

**解答：**
我们可以通过模拟手工加法的过程来解决这个问题。我们使用两个指针分别遍历两个链表，将对应的数字相加，并将结果存储在新的链表中。如果相加的结果大于等于10，我们需要将进位加到下一个节点。

**代码实现：**
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1, l2):
    dummy = ListNode()
    curr = dummy
    carry = 0
    
    while l1 or l2 or carry:
        val1 = (l1.val if l1 else 0)
        val2 = (l2.val if l2 else 0)
        sum = val1 + val2 + carry
        carry = sum // 10
        curr.next = ListNode(sum % 10)
        curr = curr.next
        
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
    
    return dummy.next
```

#### 21. 有效的括号字符串问题

**题目：** 给定一个只包含 `'('` 、')'` 和 `'{'` 、'}'` 的字符串 `s` ，判断字符串是否有效。

**示例：**
```python
s = "{}{()}"
# 输出
# True
```

**解答：**
这个问题可以通过模拟手工处理字符串的过程来解决。我们使用栈来存储尚未匹配的括号，如果当前字符是左括号，我们将其入栈；如果是右括号，我们检查栈顶元素是否与之匹配，如果不匹配或栈为空，则字符串无效。

**代码实现：**
```python
def isValid(s):
    mapping = {')': '(', '}': '{'}
    stack = []
    
    for c in s:
        if c in mapping:
            if not stack or stack.pop() != mapping[c]:
                return False
        else:
            stack.append(c)
    
    return not stack
```

#### 22. 最小路径和问题

**题目：** 给定一个包含非负整数的 `mx` 行 `n` 列的网格 `grid` ，找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**示例：**
```python
grid = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]
# 输出
# 7
```

**解答：**
这个问题可以使用动态规划的方法来解决。我们定义一个二维数组 `dp`，其中 `dp[i][j]` 表示到达坐标 `(i, j)` 的最小路径和。我们从左上角开始，逐步计算到达每个坐标的最小路径和。

**代码实现：**
```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    
    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    
    return dp[-1][-1]
```

#### 23. 有效的山脉数组问题

**题目：** 给定一个整数数组 `arr` ，如果它是有效的山脉数组就返回 `true`，否则返回 `false`。

**示例：**
```python
arr = [2, 1]
# 输出
# False
```

**解答：**
这个问题可以通过遍历数组来判断是否存在上升和下降的子数组，并且下降子数组的起点和上升子数组的终点相同。

**代码实现：**
```python
def validMountainArray(arr):
    n = len(arr)
    if n < 3:
        return False
    
    i = 0
    while i + 1 < n and arr[i] < arr[i + 1]:
        i += 1
    if i == n - 1:
        return False
    
    j = i
    while j + 1 < n and arr[j] > arr[j + 1]:
        j += 1
    
    return i != j and j == n - 1
```

#### 24. 子数组的最小值问题

**题目：** 给定一个整数数组 `nums`，返回数组中所有子数组中的最小值之和。

**示例：**
```python
nums = [3, 7, 1, 2, 6]
# 输出
# 41
```

**解答：**
这个问题可以通过前缀和和单调栈的方法来解决。我们计算每个元素左侧和右侧的最小值，然后计算所有子数组的和。

**代码实现：**
```python
def sumSubarrayMins(nums):
    n = len(nums)
    left_min = [0] * n
    right_min = [0] * n
    stack = []
    
    for i in range(n):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            left_min[i] = nums[stack[-1]]
        else:
            left_min[i] = nums[0]
        stack.append(i)
    
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            right_min[i] = nums[stack[-1]]
        else:
            right_min[i] = nums[-1]
        stack.append(i)
    
    return sum(v * (left_min[i] * right_min[i]) for i, v in enumerate(nums))
```

#### 25. 有效数字问题

**题目：** 给定一个字符串 `s` ，如果它是有效的数字就返回 `true`，否则返回 `false`。

**示例：**
```python
s = "0"
# 输出
# True
```

**解答：**
这个问题可以通过状态机的方法来解决。我们定义多个状态来处理数字的各个部分，例如整数部分、小数部分、指数部分等。

**代码实现：**
```python
def isNumber(s):
    states = [
        ["", "sign", "numeric", "dot", "exp", "signExp"],  # 0
        ["", "sign", "numeric", "dot", "exp", "signExp"],  # 1
        ["", "end", "end", "end", "end", "end"],           # 2
        ["", "end", "end", "end", "end", "end"],           # 3
        ["", "end", "end", "end", "end", "end"],           # 4
        ["", "end", "end", "end", "end", "end"],           # 5
        ["", "end", "end", "end", "end", "end"],           # 6
        ["", "end", "end", "end", "end", "end"],           # 7
        ["", "end", "end", "end", "end", "end"],           # 8
        ["", "end", "end", "end", "end", "end"],           # 9
    ]
    
    def check(state, c):
        if state not in range(10):
            return False
        if c not in "0123456789e.E+-":
            return False
        if state == 0 and c in "-+":
            return True
        if state == 1 and c in "0123456789":
            return True
        if state == 2 and c in "eE":
            return True
        if state == 3 and c in "0123456789+-":
            return True
        if state == 4 and c in "0123456789":
            return True
        if state == 5 and c in "eE":
            return True
        if state == 6 and c in "0123456789+-":
            return True
        if state == 7 and c in "0123456789":
            return True
        if state == 8 and c in "eE":
            return True
        if state == 9 and c in "eE":
            return True
        if state == 10 and c in "eE":
            return True
        return False
    
    state = 0
    for c in s:
        state = states[state][ord(c) - ord('0')]
        if not check(state, c):
            return False
    
    return state != 1 and state != 2
```

#### 26. 搜索旋转排序数组问题

**题目：** 给定一个旋转排序的数组，找到目标值，并返回其索引。如果不存在，返回 `-1`。

**示例：**
```python
nums = [4, 5, 6, 7, 0, 1, 2]
target = 0
# 输出
# 索引：4
```

**解答：**
这个问题可以通过二分查找的方法来解决。我们需要找到旋转点，然后根据目标值与旋转点的关系，决定在哪个子数组中继续查找。

**代码实现：**
```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1
```

#### 27. 单词搜索问题

**题目：** 给定一个二维字符网格 `board` 和一个字符串 `word` ，判断 `word` 是否存在于网格中。

**示例：**
```python
board = [["A", "B", "C", "E"], ["S", "F", "C", "S"], ["A", "D", "E", "E"]]
word = "ABCCED"
# 输出
# True
```

**解答：**
这个问题可以通过深度优先搜索（DFS）来解决。我们从每个字符开始，尝试在网格中找到 `word` 的下一个字符，然后递归地搜索。

**代码实现：**
```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        
        return res
    
    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    
    return False
```

#### 28. 有效的括号字符串问题

**题目：** 给定一个只包含 `'('` 、')'` 和 `'{'` 、'}'` 的字符串 `s` ，判断字符串是否有效。

**示例：**
```python
s = "{}{()"
# 输出
# True
```

**解答：**
这个问题可以通过模拟手工处理字符串的过程来解决。我们使用栈来存储尚未匹配的括号，如果当前字符是左括号，我们将其入栈；如果是右括号，我们检查栈顶元素是否与之匹配，如果不匹配或栈为空，则字符串无效。

**代码实现：**
```python
def isValid(s):
    mapping = {')': '(', '}': '{'}
    stack = []
    
    for c in s:
        if c in mapping:
            if not stack or stack.pop() != mapping[c]:
                return False
        else:
            stack.append(c)
    
    return not stack
```

#### 29. 子数组的最小值问题

**题目：** 给定一个整数数组 `nums` ，返回数组中所有子数组中的最小值之和。

**示例：**
```python
nums = [3, 7, 1, 2, 6]
# 输出
# 41
```

**解答：**
这个问题可以通过前缀和和单调栈的方法来解决。我们计算每个元素左侧和右侧的最小值，然后计算所有子数组的和。

**代码实现：**
```python
def sumSubarrayMins(nums):
    n = len(nums)
    left_min = [0] * n
    right_min = [0] * n
    stack = []
    
    for i in range(n):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            left_min[i] = nums[stack[-1]]
        else:
            left_min[i] = nums[0]
        stack.append(i)
    
    stack = []
    for i in range(n - 1, -1, -1):
        while stack and nums[stack[-1]] >= nums[i]:
            stack.pop()
        if stack:
            right_min[i] = nums[stack[-1]]
        else:
            right_min[i] = nums[-1]
        stack.append(i)
    
    return sum(v * (left_min[i] * right_min[i]) for i, v in enumerate(nums))
```

#### 30. 三数之和问题

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，找出三个数，使得它们的和与 `target` 最接近。

**示例：**
```python
nums = [-1, 0, 1, 2, -1, -4]
target = 1
# 输出
# [-1, 2, -1] 或 [-1, -1, 2]
```

**解答：**
这个问题可以通过排序和双指针的方法来解决。我们首先对数组进行排序，然后固定第一个数，使用双指针寻找两个数使得它们的和与 `target` 最接近。

**代码实现：**
```python
def threeSumClosest(nums, target):
    nums.sort()
    diff = float('inf')
    for i in range(len(nums) - 2):
        l, r = i + 1, len(nums) - 1
        while l < r:
            s = nums[i] + nums[l] + nums[r]
            if abs(target - s) < abs(diff):
                diff = target - s
            if s < target:
                l += 1
            elif s > target:
                r -= 1
            else:
                return target
    return target - diff
```

### 总结

以上就是华为2025届校招面试高频算法题的解析。这些题目涵盖了各种数据结构和算法，包括链表、栈、队列、数组、字符串、二分查找、排序、动态规划、深度优先搜索、广度优先搜索等。这些题目不仅考察了编程能力，还考察了逻辑思维和解决问题的能力。希望这些解析能够帮助你更好地理解和解决面试中的算法问题。如果你有任何疑问或需要进一步的解释，请随时提问。祝你面试成功！

