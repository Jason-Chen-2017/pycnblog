                 

### 京东2025校招编程面试题精华总结

#### 一、典型面试题

##### 1. 如何判断一个链表是否为回文结构？

**题目：** 实现一个函数，判断一个链表是否为回文结构。

**答案：** 可以使用快慢指针法找到链表的中间节点，然后将后半部分链表反转，接着比较前半部分和反转后的后半部分是否相同。

**代码示例：**

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    ListNode fast = head;
    ListNode slow = head;
    // 快慢指针找到中间节点
    while (fast.next != null && fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // 反转后半部分链表
    ListNode secondHalf = reverse(slow.next);
    // 比较前半部分和反转后的后半部分
    while (head != null && secondHalf != null) {
        if (head.val != secondHalf.val) {
            return false;
        }
        head = head.next;
        secondHalf = secondHalf.next;
    }
    return true;
}

private ListNode reverse(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(1)。

##### 2. 如何实现一个排序链表？

**题目：** 实现一个排序链表的函数。

**答案：** 可以使用归并排序来对链表进行排序。

**代码示例：**

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    // 使用快慢指针找到中间节点
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // 将链表分为两半
    ListNode mid = slow.next;
    slow.next = null;
    // 对两半分别排序
    ListNode l1 = sortList(head);
    ListNode l2 = sortList(mid);
    // 合并两个排序后的链表
    return merge(l1, l2);
}

private ListNode merge(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    if (l1 != null) {
        current.next = l1;
    } else if (l2 != null) {
        current.next = l2;
    }
    return dummy.next;
}
```

**解析：** 此方法的时间复杂度为 O(n log n)，空间复杂度为 O(1)。

##### 3. 如何实现一个二叉搜索树的中序遍历？

**题目：** 实现一个二叉搜索树的中序遍历函数。

**答案：** 可以使用递归或迭代的方法进行中序遍历。

**代码示例：**

**递归方法：**

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root != null) {
        result.addAll(inorderTraversal(root.left));
        result.add(root.val);
        result.addAll(inorderTraversal(root.right));
    }
    return result;
}
```

**迭代方法：**

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        result.add(root.val);
        root = root.right;
    }
    return result;
}
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(n)。

#### 二、算法编程题

##### 4. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：** 可以使用分治法，首先找到所有字符串的第一个字符的最长公共前缀，然后递归地对剩下的字符进行同样的操作。

**代码示例：**

```python
def longestCommonPrefix(strs):
    if not strs:
        return ""
    prefix = ""
    for c in zip(*strs):
        if len(set(c)) == 1:
            prefix += c[0]
        else:
            break
    return prefix
```

**解析：** 此方法的时间复杂度为 O(n * m)，其中 n 是字符串数组中的字符串数量，m 是字符串的最大长度。

##### 5. 最长回文子串

**题目：** 给定一个字符串，找到最长的回文子串。

**答案：** 可以使用动态规划的方法。

**代码示例：**

```python
def longestPalindrome(s):
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    start, max_len = 0, 1
    for i in range(n):
        dp[i][i] = True
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if s[i] == s[j]:
                if j - i == 0 or dp[i + 1][j - 1]:
                    dp[i][j] = True
                    if max_len < j - i + 1:
                        start = i
                        max_len = j - i + 1
    return s[start:start + max_len]
```

**解析：** 此方法的时间复杂度为 O(n^2)，空间复杂度为 O(n^2)。

##### 6. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。

**答案：** 可以使用递归或迭代的方法。

**递归方法：**

```python
def mergeTwoLists(l1, l2):
    if l1 is None:
        return l2
    if l2 is None:
        return l1
    if l1.val < l2.val:
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    else:
        l2.next = mergeTwoLists(l1, l2.next)
        return l2
```

**迭代方法：**

```python
def mergeTwoLists(l1, l2):
    dummy = ListNode(0)
    prev = dummy
    while l1 and l2:
        if l1.val < l2.val:
            prev.next = l1
            l1 = l1.next
        else:
            prev.next = l2
            l2 = l2.next
        prev = prev.next
    prev.next = l1 if l1 else l2
    return dummy.next
```

**解析：** 此方法的时间复杂度为 O(n + m)，空间复杂度为 O(1)，其中 n 和 m 分别是两个链表的长度。

##### 7. 盛最多水的容器

**题目：** 给定一个二维矩阵，计算矩阵中最大的矩形面积。

**答案：** 可以使用单调栈的方法。

**代码示例：**

```python
def largestRectangleArea(heights):
    heights = [0] + heights + [0]
    stack = []
    max_area = 0
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            h = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * width)
        stack.append(i)
    return max_area
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(n)。

##### 8. 两数相加

**题目：** 给出两个非空链表，表示两个非负的整数，每个节点包含一个数字，返回这两个数字表示的整数的和。

**答案：** 可以使用链表反转的方法。

**代码示例：**

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    int carry = 0;
    while (l1 != null || l2 != null || carry != 0) {
        int x = (l1 != null) ? l1.val : 0;
        int y = (l2 != null) ? l2.val : 0;
        int sum = x + y + carry;
        carry = sum / 10;
        current.next = new ListNode(sum % 10);
        current = current.next;
        if (l1 != null) l1 = l1.next;
        if (l2 != null) l2 = l2.next;
    }
    return dummy.next;
}
```

**解析：** 此方法的时间复杂度为 O(max(m, n))，空间复杂度为 O(1)，其中 m 和 n 分别是两个链表的长度。

##### 9. 三数之和

**题目：** 给定一个数组 nums 和一个目标值 target，找出数组中三个元素的和为 target 的组合。

**答案：** 可以使用双指针的方法。

**代码示例：**

```python
def threeSum(nums, target):
    nums.sort()
    result = []
    for i in range(len(nums) - 2):
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total == target:
                result.append([nums[i], nums[left], nums[right]])
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1
            elif total < target:
                left += 1
            else:
                right -= 1
    return result
```

**解析：** 此方法的时间复杂度为 O(n^2)，空间复杂度为 O(1)。

##### 10. 盛最多水的容器

**题目：** 给定一个二维矩阵，计算矩阵中最大的矩形面积。

**答案：** 可以使用单调栈的方法。

**代码示例：**

```python
def largestRectangleArea(heights):
    heights = [0] + heights + [0]
    stack = []
    max_area = 0
    for i, h in enumerate(heights):
        while stack and heights[stack[-1]] > h:
            h = heights[stack.pop()]
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, h * width)
        stack.append(i)
    return max_area
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(n)。

##### 11. 删除链表的节点

**题目：** 编写一个函数，用于删除链表中的一个节点（不是尾节点），你只能访问该节点。

**答案：** 将待删除节点的下一个节点的值复制到待删除节点，然后删除下一个节点。

**代码示例：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNode(node):
    node.val = node.next.val
    node.next = node.next.next
```

**解析：** 此方法的时间复杂度为 O(1)，空间复杂度为 O(1)。

##### 12. 设计循环队列

**题目：** 设计一个循环队列，支持插入和删除操作。

**答案：** 使用两个指针，一个用于指向队头，一个用于指向队尾。

**代码示例：**

```python
class MyCircularQueue:
    def __init__(self, k: int):
        self.queue = [0] * k
        self.front = self.rear = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        if self.rear == 0:
            return self.queue[self.capacity - 1]
        return self.queue[self.rear - 1]

    def isEmpty(self) -> bool:
        return self.front == self.rear

    def isFull(self) -> bool:
        return (self.rear + 1) % self.capacity == self.front
```

**解析：** 此方法的时间复杂度为 O(1)，空间复杂度为 O(n)。

##### 13. 最长公共子序列

**题目：** 给定两个字符串，找出它们的公共最长子序列。

**答案：** 使用动态规划。

**代码示例：**

```python
def longestCommonSubsequence(s1, s2):
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[-1][-1]
```

**解析：** 此方法的时间复杂度为 O(m * n)，空间复杂度为 O(m * n)，其中 m 和 n 分别是两个字符串的长度。

##### 14. 翻转整数

**题目：** 编写一个函数，用于将一个整数反转。

**答案：** 将整数转换为字符串，然后反转字符串，再将字符串转换为整数。

**代码示例：**

```python
def reverse(x: int) -> int:
    s = str(x)
    s = s[::-1]
    return int(s)
```

**解析：** 此方法的时间复杂度为 O(log n)，空间复杂度为 O(log n)，其中 n 是整数的位数。

##### 15. 两数相加

**题目：** 给定两个非空链表，表示两个非负的整数，每个节点包含一个数字，返回这两个数字表示的整数的和。

**答案：** 可以使用链表反转的方法。

**代码示例：**

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    int carry = 0;
    while (l1 != null || l2 != null || carry != 0) {
        int x = (l1 != null) ? l1.val : 0;
        int y = (l2 != null) ? l2.val : 0;
        int sum = x + y + carry;
        carry = sum / 10;
        current.next = new ListNode(sum % 10);
        current = current.next;
        if (l1 != null) l1 = l1.next;
        if (l2 != null) l2 = l2.next;
    }
    return dummy.next;
}
```

**解析：** 此方法的时间复杂度为 O(max(m, n))，空间复杂度为 O(1)，其中 m 和 n 分别是两个链表的长度。

##### 16. 旋转图像

**题目：** 给定一个 n × n 的二维矩阵表示一个图像，旋转 90 度。

**答案：** 可以使用原地旋转的方法。

**代码示例：**

```python
def rotate(matrix):
    n = len(matrix)
    for i in range(n // 2):
        for j in range(i, n - i - 1):
            temp = matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][i]
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]
            matrix[j][n - i - 1] = temp
```

**解析：** 此方法的时间复杂度为 O(n^2)，空间复杂度为 O(1)。

##### 17. 合并两个有序链表

**题目：** 将两个升序链表合并为一个新的升序链表并返回。

**答案：** 可以使用递归或迭代的方法。

**递归方法：**

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

**迭代方法：**

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    if (l1 != null) {
        current.next = l1;
    } else if (l2 != null) {
        current.next = l2;
    }
    return dummy.next;
}
```

**解析：** 此方法的时间复杂度为 O(n + m)，空间复杂度为 O(1)，其中 n 和 m 分别是两个链表的长度。

##### 18. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 从起始位置开始与 nums2 合并后的数组为新的有序数组。

**答案：** 从数组的末尾开始合并，将较大的元素填入 nums1 的末尾。

**代码示例：**

```python
def merge(nums1, m, nums2, n):
    i = m - 1
    j = n - 1
    k = m + n - 1
    while i >= 0 and j >= 0:
        if nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
    while j >= 0:
        nums1[k] = nums2[j]
        j -= 1
        k -= 1
```

**解析：** 此方法的时间复杂度为 O(m + n)，空间复杂度为 O(1)。

##### 19. 最长公共子串

**题目：** 给定两个字符串，找出它们的公共最长子串。

**答案：** 使用动态规划。

**代码示例：**

```python
def longestCommonSubstr(s1, s2):
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    max_len = 0
    end_pos = 0
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i
            else:
                dp[i][j] = 0
    return s1[end_pos - max_len: end_pos]
```

**解析：** 此方法的时间复杂度为 O(m * n)，空间复杂度为 O(m * n)，其中 m 和 n 分别是两个字符串的长度。

##### 20. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**答案：** 使用二分查找。

**代码示例：**

```python
def searchInsert(nums, target):
    low, high = 0, len(nums) - 1
    while low <= high:
        mid = (low + high) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return low
```

**解析：** 此方法的时间复杂度为 O(log n)，空间复杂度为 O(1)，其中 n 是数组的长度。

##### 21. 寻找旋转排序数组中的最小值

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转。

**答案：** 使用二分查找。

**代码示例：**

```python
def findMin(nums):
    low, high = 0, len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        else:
            high = mid
    return nums[low]
```

**解析：** 此方法的时间复杂度为 O(log n)，空间复杂度为 O(1)，其中 n 是数组的长度。

##### 22. 最小路径和

**题目：** 给定一个包含非负整数的网格，找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**答案：** 使用动态规划。

**代码示例：**

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    dp = [[0] * n for _ in range(m)]
    dp[0][0] = grid[0][0]
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    return dp[-1][-1]
```

**解析：** 此方法的时间复杂度为 O(m * n)，空间复杂度为 O(m * n)，其中 m 和 n 分别是网格的行数和列数。

##### 23. 翻转整数

**题目：** 编写一个函数，用于将一个整数反转。

**答案：** 将整数转换为字符串，然后反转字符串，再将字符串转换为整数。

**代码示例：**

```python
def reverse(x: int) -> int:
    s = str(x)
    s = s[::-1]
    return int(s)
```

**解析：** 此方法的时间复杂度为 O(log n)，空间复杂度为 O(log n)，其中 n 是整数的位数。

##### 24. 搜索旋转排序数组

**题目：** 假设按照升序排序的数组在预先未知的某个点上进行了旋转，请找出并返回旋转数组中的最小元素。

**答案：** 使用二分查找。

**代码示例：**

```python
def searchMin(nums):
    low, high = 0, len(nums) - 1
    while low < high:
        mid = (low + high) // 2
        if nums[mid] > nums[high]:
            low = mid + 1
        else:
            high = mid
    return nums[low]
```

**解析：** 此方法的时间复杂度为 O(log n)，空间复杂度为 O(1)，其中 n 是数组的长度。

##### 25. 存在重复元素

**题目：** 给定一个整数数组，判断是否存在重复元素。

**答案：** 使用哈希表。

**代码示例：**

```python
def containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(n)，其中 n 是数组的长度。

##### 26. 删除有序数组中的重复元素

**题目：** 给定一个排序数组，你需要在原地删除重复出现的元素，使每个元素只出现一次。

**答案：** 使用双指针。

**代码示例：**

```python
def removeDuplicates(nums):
    if not nums:
        return 0
    slow = fast = 0
    while fast < len(nums):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
        fast += 1
    return slow + 1
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组的长度。

##### 27. 移动零

**题目：** 给定一个数组 nums，编写一个函数来移动所有 0 到数组的末尾，同时保持非零元素的相对顺序。

**答案：** 使用双指针。

**代码示例：**

```python
def moveZeroes(nums):
    slow = fast = 0
    while fast < len(nums):
        if nums[fast] != 0:
            nums[slow] = nums[fast]
            slow += 1
        fast += 1
    while slow < len(nums):
        nums[slow] = 0
        slow += 1
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组的长度。

##### 28. 合并区间

**题目：** 给出一个区间的集合，请合并所有重叠的区间。

**答案：** 使用排序和双指针。

**代码示例：**

```python
def merge(intervals):
    if not intervals:
        return []
    intervals.sort(key=lambda x: x[0])
    result = [intervals[0]]
    for interval in intervals[1:]:
        if result[-1][1] >= interval[0]:
            result[-1][1] = max(result[-1][1], interval[1])
        else:
            result.append(interval)
    return result
```

**解析：** 此方法的时间复杂度为 O(n log n)，空间复杂度为 O(n)，其中 n 是区间的数量。

##### 29. 有效的数独

**题目：** 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

- 数字 1-9 无重复出现在每一行。
- 数字 1-9 无重复出现在每一列。
- 数字 1-9 无重复出现在每一个 3x3 的宫格内。

**答案：** 使用数组记录每一行、每一列和每个 3x3 宫格的状态。

**代码示例：**

```python
def isValidSudoku(board):
    rows = [False] * 10
    cols = [False] * 10
    boxes = [False] * 10
    for i in range(9):
        for j in range(9):
            num = board[i][j]
            if num != 0:
                box_index = (i // 3) * 3 + (j // 3)
                if rows[i][num] or cols[j][num] or boxes[box_index][num]:
                    return False
                rows[i][num] = True
                cols[j][num] = True
                boxes[box_index][num] = True
    return True
```

**解析：** 此方法的时间复杂度为 O(1)，空间复杂度为 O(1)。

##### 30. 买卖股票的最佳时机 III

**题目：** 给定一个数组，它的第 i 个元素代表第 i 天股票的价格。如果最多只允许完成两笔交易，设计一个算法来找出最大利润。

**答案：** 维护两个变量，一个表示第一笔交易后的利润，一个表示第二笔交易后的利润。

**代码示例：**

```python
def maxProfit(prices):
    first_buy, second_buy = -prices[0], 0
    for price in prices:
        first_buy = max(first_buy, -price)
        second_buy = max(second_buy, first_buy + price)
    return second_buy
```

**解析：** 此方法的时间复杂度为 O(n)，空间复杂度为 O(1)，其中 n 是数组的长度。

