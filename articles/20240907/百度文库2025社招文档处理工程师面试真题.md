                 

### 百度文库2025社招文档处理工程师面试真题解析

#### 一、基础算法题目

**1. 请实现一个函数，求出两个有序数组的中位数。**

**题目描述：** 给定两个有序数组 `nums1` 和 `nums2`，请实现一个函数 `findMedian`，求出这两个有序数组的中位数。

**答案：**

```java
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int[] merged = new int[nums1.length + nums2.length];
    int i = 0, j = 0, k = 0;
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] <= nums2[j]) {
            merged[k++] = nums1[i++];
        } else {
            merged[k++] = nums2[j++];
        }
    }
    while (i < nums1.length) {
        merged[k++] = nums1[i++];
    }
    while (j < nums2.length) {
        merged[k++] = nums2[j++];
    }
    int n = merged.length;
    if (n % 2 == 0) {
        return (merged[n / 2 - 1] + merged[n / 2]) / 2.0;
    } else {
        return merged[n / 2];
    }
}
```

**解析：** 我们可以使用归并算法来合并两个有序数组，然后根据合并后的数组长度判断中位数是第几个元素。

**2. 请实现一个函数，计算字符串的长度。**

**题目描述：** 给定一个字符串 `s`，请实现一个函数 `lengthOfLongestSubstring`，计算字符串中的最长子字符串长度。

**答案：**

```python
def lengthOfLongestSubstring(s):
    n = len(s)
    ans = 0
    j = 0
    for i in range(n):
        while j < n and s[i] != s[j]:
            j += 1
        ans = max(ans, i - j + 1)
    return ans
```

**解析：** 我们可以使用双指针的方法，右指针 `i` 遍历字符串，左指针 `j` 寻找与 `i` 相同的字符，每次找到重复字符时，更新答案并移动左指针。

**3. 请实现一个函数，对链表进行排序。**

**题目描述：** 给定一个单链表的头节点 `head`，请实现一个函数 `sortList`，对链表进行排序。

**答案：**

```java
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode slow = head, fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    ListNode mid = slow.next;
    slow.next = null;
    ListNode l1 = sortList(head);
    ListNode l2 = sortList(mid);
    return merge(l1, l2);
}

private ListNode merge(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;
    while (l1 != null && l2 != null) {
        if (l1.val < l2.val) {
            curr.next = l1;
            l1 = l1.next;
        } else {
            curr.next = l2;
            l2 = l2.next;
        }
        curr = curr.next;
    }
    curr.next = l1 == null ? l2 : l1;
    return dummy.next;
}
```

**解析：** 我们可以使用归并排序的方法，将链表分成两半，然后分别对两部分进行排序，最后合并两部分。

#### 二、编程题目

**4. 实现一个数据结构，支持以下操作：添加元素、删除元素、查询是否存在。**

**题目描述：** 设计一个数据结构，支持以下操作：添加元素、删除元素、查询是否存在。要求实现时间复杂度尽可能低。

**答案：**

```python
class MyDataStructure:
    def __init__(self):
        self.data = set()
        self.dict = defaultdict(list)

    def add(self, val: int) -> None:
        self.data.add(val)
        self.dict[val].append(val)

    def remove(self, val: int) -> None:
        if val in self.data:
            self.data.remove(val)
            self.dict[val].pop()

    def exists(self, val: int) -> bool:
        return val in self.data
```

**解析：** 使用集合 `data` 存储元素，使用字典 `dict` 存储每个元素出现的次数。添加和删除操作的时间复杂度为 O(1)，查询是否存在的时间复杂度为 O(1)。

**5. 实现一个函数，计算两个字符串的相似度。**

**题目描述：** 给定两个字符串 `s1` 和 `s2`，请实现一个函数 `similarity`，计算两个字符串的相似度。相似度定义为两个字符串中相同字符的个数。

**答案：**

```python
def similarity(s1, s2):
    count = 0
    for c1, c2 in zip(s1, s2):
        if c1 == c2:
            count += 1
    return count
```

**解析：** 使用两个指针遍历两个字符串，每次比较两个指针指向的字符是否相同，相同则计数器加一。

#### 三、系统设计与算法优化

**6. 设计一个分布式缓存系统。**

**题目描述：** 设计一个分布式缓存系统，要求支持以下功能：添加元素、删除元素、查询元素、缓存淘汰策略。

**答案：**

```python
class DistributedCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = LRUCache(capacity)

    def add(self, key, value):
        self.cache.put(key, value)

    def remove(self, key):
        self.cache.remove(key)

    def get(self, key):
        return self.cache.get(key)

    def set_ttl(self, key, ttl):
        self.cache.set_ttl(key, ttl)

    def evict(self):
        self.cache.evict()
```

**解析：** 使用 LRU 缓存实现缓存系统，添加、删除、查询操作的时间复杂度为 O(1)。缓存淘汰策略使用 LRU 算法，根据访问时间最长的元素进行淘汰。

**7. 优化一个耗时函数，提高运行效率。**

**题目描述：** 给定一个函数 `f(n)`，该函数计算时间复杂度为 O(n^2)。请设计一种方法，降低其时间复杂度。

**答案：**

```python
def f(n):
    # 原始函数，时间复杂度为 O(n^2)
    result = 0
    for i in range(n):
        for j in range(n):
            result += i * j
    return result

# 优化后的函数，时间复杂度为 O(n)
def f_optimized(n):
    result = 0
    for i in range(1, n+1):
        result += i * (n - i + 1) // 2
    return result
```

**解析：** 使用数学方法将双重循环转换为单循环，时间复杂度降低为 O(n)。

