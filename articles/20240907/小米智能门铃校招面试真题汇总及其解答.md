                 

### 小米智能门铃2024校招面试题库与解析

#### 1. 简述你所熟悉的一种排序算法及其原理

**题目：** 简述你所熟悉的一种排序算法，并解释其基本原理。

**答案：** 排序算法中，快速排序（Quick Sort）是比较常用的一种。其基本原理是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

**解析：** 快速排序的基本思想是选择一个“基准”元素，然后将序列分为两部分，一部分都比基准小，另一部分都比基准大。这样，基准元素在排序后的序列中就位于其正确的位置。然后递归地对这两部分进行快速排序。时间复杂度为 O(n log n)。

#### 2. 请实现一个函数，判断一个字符串是否是回文

**题目：** 请实现一个函数，判断一个字符串是否是回文。

**答案：** 

```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        if runes[i] != runes[j] {
            return false
        }
    }
    return true
}

func main() {
    s := "radar"
    fmt.Println(isPalindrome(s)) // 输出：true
}
```

**解析：** 该函数通过将字符串转换成 rune 数组，然后分别比较字符串的首尾字符，直到中间位置。如果中间的字符不匹配，则返回 `false`。如果所有字符匹配，则返回 `true`。

#### 3. 如何实现一个单例模式？

**题目：** 请用 Go 语言实现一个单例模式。

**答案：**

```go
package singleton

import "sync"

type Singleton struct {
    // instance 需要保护
    instance *Singleton
    once      sync.Once
}

func (s *Singleton) Instance() *Singleton {
    s.once.Do(func() {
        s.instance = &Singleton{}
    })
    return s.instance
}
```

**解析：** 该单例模式的实现使用了 Go 语言的 `sync.Once`，确保实例在程序执行过程中只被创建一次。

#### 4. 请实现一个函数，实现整数除法，但不能使用 `/` 操作符。

**题目：** 请实现一个函数，实现整数除法，但不能使用 `/` 操作符。

**答案：**

```go
package main

import (
    "fmt"
)

func divide(dividend, divisor int) int {
    if dividend == 0 {
        return 0
    }
    if divisor == 1 {
        return dividend
    }
    sign := 1
    if (dividend < 0) != (divisor < 0) {
        sign = -1
    }
    dividend, divisor = abs(dividend), abs(divisor)
    result := 0
    for dividend >= divisor {
        temp, multiple := divisor, 1
        for dividend >= (temp << 1) {
            temp <<= 1
            multiple <<= 1
        }
        dividend -= temp
        result += multiple
    }
    return result * sign
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}

func main() {
    fmt.Println(divide(10, 2)) // 输出：5
    fmt.Println(divide(-10, 2)) // 输出：-5
    fmt.Println(divide(10, -2)) // 输出：-5
    fmt.Println(divide(-10, -2)) // 输出：5
}
```

**解析：** 该函数通过减去 `divisor` 的倍数，模拟除法操作。利用位运算（`<<`）来加速计算。

#### 5. 请实现一个函数，计算字符串的长度，但不能使用 `len` 函数。

**题目：** 请实现一个函数，计算字符串的长度，但不能使用 `len` 函数。

**答案：**

```go
package main

import (
    "fmt"
    "unicode"
)

func stringLength(s string) int {
    length := 0
    for _, _ = range s {
        length++
    }
    return length
}

func main() {
    s := "Hello, World!"
    fmt.Println(stringLength(s)) // 输出：13
}
```

**解析：** 该函数通过遍历字符串中的每个字符，计数字符数量。

#### 6. 请实现一个函数，将字符串中的空格替换为指定字符串。

**题目：** 请实现一个函数，将字符串中的空格替换为指定字符串。

**答案：**

```go
package main

import (
    "fmt"
)

func replaceSpaces(s string, spaces string) string {
    var result []byte
    for _, v := range s {
        if v == ' ' {
            result = append(result, []byte(spaces)...)
        } else {
            result = append(result, byte(v))
        }
    }
    return string(result)
}

func main() {
    s := "Hello, World!"
    spaces := "%20"
    fmt.Println(replaceSpaces(s, spaces)) // 输出：Hello%2C%20World!
}
```

**解析：** 该函数通过遍历字符串 `s`，将空格替换为指定的字符串 `spaces`。

#### 7. 请实现一个函数，对字符串进行反转。

**题目：** 请实现一个函数，对字符串进行反转。

**答案：**

```go
package main

import (
    "fmt"
)

func reverseString(s string) string {
    runes := []rune(s)
    for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
        runes[i], runes[j] = runes[j], runes[i]
    }
    return string(runes)
}

func main() {
    s := "Hello, World!"
    fmt.Println(reverseString(s)) // 输出：!dlroW ,olleH
}
```

**解析：** 该函数通过将字符串转换成 rune 数组，然后对数组进行反转。

#### 8. 请实现一个函数，计算字符串中数字的个数。

**题目：** 请实现一个函数，计算字符串中数字的个数。

**答案：**

```go
package main

import (
    "fmt"
    "unicode"
)

func countDigits(s string) int {
    count := 0
    for _, c := range s {
        if unicode.IsDigit(c) {
            count++
        }
    }
    return count
}

func main() {
    s := "123abc456"
    fmt.Println(countDigits(s)) // 输出：6
}
```

**解析：** 该函数通过遍历字符串，利用 `unicode.IsDigit` 函数判断字符是否为数字，计数数字的个数。

#### 9. 请实现一个函数，判断字符串是否为回文。

**题目：** 请实现一个函数，判断字符串是否为回文。

**答案：**

```go
package main

import (
    "fmt"
)

func isPalindrome(s string) bool {
    s = strings.ToLower(s)
    left, right := 0, len(s)-1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}

func main() {
    s := "Madam"
    fmt.Println(isPalindrome(s)) // 输出：true
}
```

**解析：** 该函数通过将字符串转换为小写，然后从字符串的两端开始比较，判断是否为回文。

#### 10. 请实现一个函数，对数组进行冒泡排序。

**题目：** 请实现一个函数，对数组进行冒泡排序。

**答案：**

```go
package main

import (
    "fmt"
)

func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    bubbleSort(arr)
    fmt.Println(arr) // 输出：[11 12 22 25 34 64 90]
}
```

**解析：** 该函数通过两层嵌套循环，对数组进行冒泡排序。

#### 11. 请实现一个函数，查找数组中的最大值。

**题目：** 请实现一个函数，查找数组中的最大值。

**答案：**

```go
package main

import (
    "fmt"
)

func findMax(arr []int) int {
    if len(arr) == 0 {
        return -1
    }
    max := arr[0]
    for _, v := range arr {
        if v > max {
            max = v
        }
    }
    return max
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println(findMax(arr)) // 输出：90
}
```

**解析：** 该函数通过遍历数组，找出最大值。

#### 12. 请实现一个函数，计算两个整数的和，但不使用 `+` 或 `-` 操作符。

**题目：** 请实现一个函数，计算两个整数的和，但不使用 `+` 或 `-` 操作符。

**答案：**

```go
package main

import (
    "fmt"
)

func add(a, b int) int {
    for b != 0 {
        carry := a & b
        a = a ^ b
        b = carry << 1
    }
    return a
}

func main() {
    fmt.Println(add(3, 5)) // 输出：8
}
```

**解析：** 该函数利用位运算，实现两个整数的加法。

#### 13. 请实现一个函数，查找数组中的最小值。

**题目：** 请实现一个函数，查找数组中的最小值。

**答案：**

```go
package main

import (
    "fmt"
)

func findMin(arr []int) int {
    if len(arr) == 0 {
        return -1
    }
    min := arr[0]
    for _, v := range arr {
        if v < min {
            min = v
        }
    }
    return min
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println(findMin(arr)) // 输出：11
}
```

**解析：** 该函数通过遍历数组，找出最小值。

#### 14. 请实现一个函数，实现二分查找。

**题目：** 请实现一个函数，实现二分查找。

**答案：**

```go
package main

import (
    "fmt"
)

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1
    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    return -1
}

func main() {
    arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    fmt.Println(binarySearch(arr, 5)) // 输出：4
}
```

**解析：** 该函数实现的是经典的二分查找算法，通过不断缩小区间来查找目标元素。

#### 15. 请实现一个函数，对数组进行插入排序。

**题目：** 请实现一个函数，对数组进行插入排序。

**答案：**

```go
package main

import (
    "fmt"
)

func insertionSort(arr []int) {
    n := len(arr)
    for i := 1; i < n; i++ {
        key := arr[i]
        j := i - 1
        for j >= 0 && arr[j] > key {
            arr[j + 1] = arr[j]
            j--
        }
        arr[j + 1] = key
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    insertionSort(arr)
    fmt.Println(arr) // 输出：[11 12 22 25 34 64 90]
}
```

**解析：** 该函数通过插入排序，对数组进行排序。

#### 16. 请实现一个函数，实现快速排序。

**题目：** 请实现一个函数，实现快速排序。

**答案：**

```go
package main

import (
    "fmt"
)

func quickSort(arr []int, low, high int) {
    if low < high {
        pi := partition(arr, low, high)
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    quickSort(arr, 0, len(arr)-1)
    fmt.Println(arr) // 输出：[11 12 22 25 34 64 90]
}
```

**解析：** 该函数实现了快速排序，通过一趟排序将数组划分为两个子数组，然后递归地对子数组进行快速排序。

#### 17. 请实现一个函数，计算一个数字的二进制表示中 1 的个数。

**题目：** 请实现一个函数，计算一个数字的二进制表示中 1 的个数。

**答案：**

```go
package main

import (
    "fmt"
)

func countSetBits(n uint64) int {
    count := 0
    for n > 0 {
        count += int(n & 1)
        n >>= 1
    }
    return count
}

func main() {
    n := uint64(15)
    fmt.Println(countSetBits(n)) // 输出：4
}
```

**解析：** 该函数通过位运算，计算一个数字的二进制表示中 1 的个数。

#### 18. 请实现一个函数，实现字符串的加密和解密。

**题目：** 请实现一个函数，实现字符串的加密和解密。

**答案：**

加密：

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/hex"
    "io"
    "os"
)

func encrypt(plaintext string, key string) (string, error) {
    block, err := aes.NewCipher([]byte(key))
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }

    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return hex.EncodeToString(ciphertext), nil
}
```

解密：

```go
package main

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/hex"
    "io"
    "os"
)

func decrypt(ciphertext string, key string) (string, error) {
    block, err := aes.NewCipher([]byte(key))
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    nonceSize := gcm.NonceSize()
    nonce, ciphertext, _ := hex.DecodeString(ciphertext)
    plaintext, err := gcm.Open(nil, nonce[:nonceSize], ciphertext)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}
```

**解析：** 该函数利用 Go 标准库中的加密模块，实现字符串的 AES 加密和解密。

#### 19. 请实现一个函数，计算两个日期之间的天数差。

**题目：** 请实现一个函数，计算两个日期之间的天数差。

**答案：**

```go
package main

import (
    "fmt"
    "time"
)

func daysBetween(d1, d2 time.Time) int {
    return int(d1.Sub(d2).Hours() / 24)
}

func main() {
    d1 := time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC)
    d2 := time.Date(2023, 1, 10, 0, 0, 0, 0, time.UTC)
    fmt.Println(daysBetween(d1, d2)) // 输出：9
}
```

**解析：** 该函数通过 `time.Sub` 方法计算两个日期之间的差值，并将差值转换为天数。

#### 20. 请实现一个函数，实现深度优先搜索（DFS）算法。

**题目：** 请实现一个函数，实现深度优先搜索（DFS）算法。

**答案：**

```go
package main

import (
    "fmt"
)

func dfs(graph map[string][]string, start string) {
    visited := make(map[string]bool)
    visit := func(node string) {
        if visited[node] {
            return
        }
        visited[node] = true
        fmt.Println(node)
        for _, n := range graph[node] {
            visit(n)
        }
    }
    visit(start)
}

func main() {
    graph := map[string][]string{
        "A": []string{"B", "C"},
        "B": []string{"D", "E"},
        "C": []string{"F"},
        "D": []string{"G"},
        "E": []string{"H"},
        "F": []string{"I"},
        "G": []string{"J"},
        "H": []string{"K"},
        "I": []string{"L"},
        "J": []string{"M"},
        "K": []string{"N"},
        "L": []string{"O"},
        "M": []string{"P"},
        "N": []string{"Q"},
        "O": []string{"R"},
        "P": []string{"S"},
        "Q": []string{"T"},
        "R": []string{"U"},
        "S": []string{"V"},
        "T": []string{"W"},
        "U": []string{"X"},
        "V": []string{"Y"},
        "W": []string{"Z"},
    }

    dfs(graph, "A")
}
```

**解析：** 该函数实现的是深度优先搜索算法，通过递归遍历图中的节点。

#### 21. 请实现一个函数，实现广度优先搜索（BFS）算法。

**题目：** 请实现一个函数，实现广度优先搜索（BFS）算法。

**答案：**

```go
package main

import (
    "fmt"
)

func bfs(graph map[string][]string, start string) {
    visited := make(map[string]bool)
    queue := []string{start}

    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        if visited[node] {
            continue
        }
        visited[node] = true
        fmt.Println(node)
        for _, n := range graph[node] {
            if !visited[n] {
                queue = append(queue, n)
            }
        }
    }
}

func main() {
    graph := map[string][]string{
        "A": []string{"B", "C"},
        "B": []string{"D", "E"},
        "C": []string{"F"},
        "D": []string{"G"},
        "E": []string{"H"},
        "F": []string{"I"},
        "G": []string{"J"},
        "H": []string{"K"},
        "I": []string{"L"},
        "J": []string{"M"},
        "K": []string{"N"},
        "L": []string{"O"},
        "M": []string{"P"},
        "N": []string{"Q"},
        "O": []string{"R"},
        "P": []string{"S"},
        "Q": []string{"T"},
        "R": []string{"U"},
        "S": []string{"V"},
        "T": []string{"W"},
        "U": []string{"X"},
        "V": []string{"Y"},
        "W": []string{"Z"},
    }

    bfs(graph, "A")
}
```

**解析：** 该函数实现的是广度优先搜索算法，通过队列来实现节点的逐层遍历。

#### 22. 请实现一个函数，实现快速幂算法。

**题目：** 请实现一个函数，实现快速幂算法。

**答案：**

```go
package main

import (
    "fmt"
)

func fastPower(x int, n int) int {
    if n == 0 {
        return 1
    }
    if n%2 == 0 {
        return fastPower(x*x, n/2)
    }
    return x * fastPower(x*x, (n-1)/2)
}

func main() {
    x := 2
    n := 10
    fmt.Println(fastPower(x, n)) // 输出：1024
}
```

**解析：** 该函数通过递归实现快速幂算法，可以显著减少计算次数。

#### 23. 请实现一个函数，实现二进制搜索树（BST）的插入和查找操作。

**题目：** 请实现一个函数，实现二进制搜索树（BST）的插入和查找操作。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func (t *TreeNode) Insert(val int) {
    if val < t.Val {
        if t.Left == nil {
            t.Left = &TreeNode{Val: val}
        } else {
            t.Left.Insert(val)
        }
    } else {
        if t.Right == nil {
            t.Right = &TreeNode{Val: val}
        } else {
            t.Right.Insert(val)
        }
    }
}

func (t *TreeNode) Find(val int) bool {
    if t == nil {
        return false
    }
    if t.Val == val {
        return true
    } else if val < t.Val {
        return t.Left.Find(val)
    } else {
        return t.Right.Find(val)
    }
}

func main() {
    root := &TreeNode{Val: 5}
    root.Insert(3)
    root.Insert(7)
    root.Insert(2)
    root.Insert(4)
    root.Insert(6)
    root.Insert(8)

    fmt.Println(root.Find(4)) // 输出：true
    fmt.Println(root.Find(9)) // 输出：false
}
```

**解析：** 该函数实现的是二叉搜索树（BST），通过递归实现插入和查找操作。

#### 24. 请实现一个函数，实现二分搜索树（BST）的中序遍历。

**题目：** 请实现一个函数，实现二分搜索树（BST）的中序遍历。

**答案：**

```go
package main

import (
    "fmt"
)

type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func (t *TreeNode) InOrderTraversal() {
    if t == nil {
        return
    }
    t.Left.InOrderTraversal()
    fmt.Println(t.Val)
    t.Right.InOrderTraversal()
}

func main() {
    root := &TreeNode{Val: 5}
    root.Left = &TreeNode{Val: 3}
    root.Right = &TreeNode{Val: 7}
    root.Left.Left = &TreeNode{Val: 2}
    root.Left.Right = &TreeNode{Val: 4}
    root.Right.Left = &TreeNode{Val: 6}
    root.Right.Right = &TreeNode{Val: 8}

    root.InOrderTraversal()
}
```

**解析：** 该函数通过递归实现二叉搜索树的中序遍历。

#### 25. 请实现一个函数，实现堆排序。

**题目：** 请实现一个函数，实现堆排序。

**答案：**

```go
package main

import (
    "fmt"
)

func heapify(arr []int, n int, i int) {
    largest := i
    l := 2*i + 1
    r := 2*i + 2

    if l < n && arr[l] > arr[largest] {
        largest = l
    }

    if r < n && arr[r] > arr[largest] {
        largest = r
    }

    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}

func heapSort(arr []int) {
    n := len(arr)

    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func main() {
    arr := []int{12, 11, 13, 5, 6, 7}
    heapSort(arr)
    fmt.Println(arr) // 输出：[5 6 7 11 12 13]
}
```

**解析：** 该函数通过建立最大堆实现堆排序。

#### 26. 请实现一个函数，计算两个数的最大公约数（GCD）。

**题目：** 请实现一个函数，计算两个数的最大公约数（GCD）。

**答案：**

```go
package main

import (
    "fmt"
)

func gcd(a int, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}

func main() {
    a := 48
    b := 18
    fmt.Println(gcd(a, b)) // 输出：6
}
```

**解析：** 该函数通过递归实现辗转相除法，计算两个数的最大公约数。

#### 27. 请实现一个函数，判断一个数是否为质数。

**题目：** 请实现一个函数，判断一个数是否为质数。

**答案：**

```go
package main

import (
    "fmt"
)

func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    for i := 2; i*i <= n; i++ {
        if n%i == 0 {
            return false
        }
    }
    return true
}

func main() {
    n := 29
    fmt.Println(isPrime(n)) // 输出：true
}
```

**解析：** 该函数通过判断一个数是否能被小于其平方根的数整除，判断其是否为质数。

#### 28. 请实现一个函数，实现链表的数据结构。

**题目：** 请实现一个函数，实现链表的数据结构。

**答案：**

```go
package main

import (
    "fmt"
)

type ListNode struct {
    Val int
    Next *ListNode
}

func (l *ListNode) Append(val int) {
    if l.Next == nil {
        l.Next = &ListNode{Val: val}
    } else {
        l.Next.Append(val)
    }
}

func (l *ListNode) Print() {
    if l == nil {
        return
    }
    fmt.Print(l.Val, " -> ")
    l.Next.Print()
}

func main() {
    head := &ListNode{Val: 1}
    head.Append(2)
    head.Append(3)
    head.Print() // 输出：1 -> 2 -> 3
}
```

**解析：** 该函数实现了一个简单的链表结构，包括插入和打印功能。

#### 29. 请实现一个函数，实现堆数据结构。

**题目：** 请实现一个函数，实现堆数据结构。

**答案：**

```go
package main

import (
    "fmt"
)

type Heap struct {
    arr []int
}

func (h *Heap) Insert(val int) {
    h.arr = append(h.arr, val)
    i := len(h.arr) - 1
    for {
        parent := (i - 1) / 2
        if i == 0 || h.arr[parent] >= h.arr[i] {
            break
        }
        h.arr[parent], h.arr[i] = h.arr[i], h.arr[parent]
        i = parent
    }
}

func (h *Heap) ExtractMax() int {
    if len(h.arr) == 0 {
        panic("heap is empty")
    }
    max := h.arr[0]
    h.arr[0] = h.arr[len(h.arr)-1]
    h.arr = h.arr[:len(h.arr)-1]
    h.heapify(0)
    return max
}

func (h *Heap) heapify(i int) {
    l := 2*i + 1
    r := 2*i + 2
    largest := i
    if l < len(h.arr) && h.arr[l] > h.arr[largest] {
        largest = l
    }
    if r < len(h.arr) && h.arr[r] > h.arr[largest] {
        largest = r
    }
    if largest != i {
        h.arr[largest], h.arr[i] = h.arr[i], h.arr[largest]
        h.heapify(largest)
    }
}

func main() {
    heap := &Heap{}
    heap.Insert(3)
    heap.Insert(2)
    heap.Insert(15)
    heap.Insert(5)
    heap.Print() // 输出：15 -> 5 -> 3 -> 2

    fmt.Println(heap.ExtractMax()) // 输出：15
    heap.Print() // 输出：5 -> 3 -> 2
}
```

**解析：** 该函数实现了一个最小堆，包括插入和提取最大元素的功能。

#### 30. 请实现一个函数，实现快速选择算法。

**题目：** 请实现一个函数，实现快速选择算法。

**答案：**

```go
package main

import (
    "fmt"
)

func quickSelect(arr []int, k int) int {
    if len(arr) == 0 {
        panic("array is empty")
    }
    return quickSelectHelper(arr, 0, len(arr)-1, k)
}

func quickSelectHelper(arr []int, low, high int, k int) int {
    if low == high {
        return arr[low]
    }
    pivotIndex := partition(arr, low, high)
    if k == pivotIndex {
        return arr[k]
    } else if k < pivotIndex {
        return quickSelectHelper(arr, low, pivotIndex-1, k)
    } else {
        return quickSelectHelper(arr, pivotIndex+1, high, k)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low
    for j := low; j < high; j++ {
        if arr[j] < pivot {
            arr[i], arr[j] = arr[j], arr[i]
            i++
        }
    }
    arr[i], arr[high] = arr[high], arr[i]
    return i
}

func main() {
    arr := []int{4, 2, 7, 1, 5}
    k := 2
    fmt.Println(quickSelect(arr, k-1)) // 输出：4
}
```

**解析：** 该函数实现的是快速选择算法，用于找到数组中的第 `k` 个最小元素。

