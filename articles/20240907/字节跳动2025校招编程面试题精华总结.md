                 

### 字节跳动2025校招编程面试题精华总结

#### 目录

1. 基本算法和数据结构
2. 链表和图
3. 动态规划
4. 字符串处理
5. 排序和搜索
6. 数组和矩阵
7. 树和树相关算法
8. 贪心算法
9. 蓝吊算法
10. 并查集
11. 背包问题
12. 数学相关算法
13. 网络流算法
14. 排序算法
15. 算法设计思想
16. 编程实践

#### 1. 基本算法和数据结构

**题目1：实现一个有序链表**

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def insert(head, val):
    if not head:
        return ListNode(val)
    curr = head
    while curr.next and curr.next.val < val:
        curr = curr.next
    new_node = ListNode(val)
    new_node.next = curr.next
    curr.next = new_node
    return head
```

**解析：** 使用循环遍历链表，找到合适的位置插入新节点。

**题目2：判断链表是否回文**

**答案：**

```python
def is_palindrome(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    curr = slow
    prev = None
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    first_half = prev
    second_half = head
    while first_half and second_half:
        if first_half.val != second_half.val:
            return False
        first_half = first_half.next
        second_half = second_half.next
    return True
```

**解析：** 使用快慢指针找到链表的中点，然后将后半部分反转。最后比较前半部分和反转后的后半部分是否相等。

#### 2. 链表和图

**题目3：实现一个单向链表**

**答案：**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse(head):
    prev = None
    curr = head
    while curr:
        next_node = curr.next
        curr.next = prev
        prev = curr
        curr = next_node
    return prev
```

**解析：** 使用循环反转链表。

**题目4：判断图中是否存在路径**

**答案：**

```python
from collections import defaultdict

def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```

**解析：** 使用深度优先搜索（DFS）在图中寻找路径。在搜索过程中，标记已访问的节点，以避免重复搜索。

#### 3. 动态规划

**题目5：最长公共子序列**

**答案：**

```python
def longest_common_subsequence(a, b):
    m, n = len(a), len(b)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if a[i - 1] == b[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```

**解析：** 使用二维数组 `dp` 存储子问题的解，通过填表的方式求解最长公共子序列。

#### 4. 字符串处理

**题目6：最长公共前缀**

**答案：**

```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    prefix = strs[0]
    for s in strs[1:]:
        for i in range(len(prefix)):
            if i >= len(s) or prefix[i] != s[i]:
                prefix = prefix[:i]
                break
    return prefix
```

**解析：** 使用两个字符串的公共前缀逐步缩小范围，直至找到最长公共前缀。

#### 5. 排序和搜索

**题目7：搜索旋转排序数组**

**答案：**

```python
def search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
```

**解析：** 使用二分查找法，处理旋转数组。

#### 6. 数组和矩阵

**题目8：矩阵中的路径**

**答案：**

```python
def exist(board, word):
    def dfs(i, j, k):
        if k == len(word):
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:
            return False
        temp = board[i][j]
        board[i][j] = '#'
        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)
        board[i][j] = temp
        return res

    m, n = len(board), len(board[0])
    for i in range(m):
        for j in range(n):
            if dfs(i, j, 0):
                return True
    return False
```

**解析：** 使用深度优先搜索（DFS）在矩阵中寻找路径。

#### 7. 树和树相关算法

**题目9：二叉树的遍历**

**答案：**

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorderTraversal(root):
    if not root:
        return []
    return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)
```

**解析：** 使用递归实现中序遍历二叉树。

#### 8. 贪心算法

**题目10：贪心算法求解硬币找零问题**

**答案：**

```python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[-1] if dp[-1] != float('inf') else -1
```

**解析：** 使用动态规划实现贪心算法，计算找零的最少硬币数量。

#### 9. 蓝吊算法

**题目11：蓝吊算法求最长公共子串**

**答案：**

```python
def longest_common_substring(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                max_len = max(max_len, dp[i][j])
            else:
                dp[i][j] = 0
    return max_len
```

**解析：** 使用二维数组 `dp` 存储子问题的解，通过填表的方式求解最长公共子串。

#### 10. 并查集

**题目12：并查集求解连通性**

**答案：**

```python
class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            self.p[root_x] = root_y
```

**解析：** 使用并查集实现连通性判断。

#### 11. 背包问题

**题目13：01背包问题**

**答案：**

```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            if j >= weights[i - 1]:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1])
            else:
                dp[i][j] = dp[i - 1][j]
    return dp[n][capacity]
```

**解析：** 使用动态规划实现01背包问题。

#### 12. 数学相关算法

**题目14：最大公约数和最小公倍数**

**答案：**

```python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)
```

**解析：** 使用辗转相除法求最大公约数，使用最大公约数求最小公倍数。

#### 13. 网络流算法

**题目15：最大流问题**

**答案：**

```python
from collections import defaultdict

def max_flow(graph, source, sink):
    flow = 0
    while True:
        parent = [None] * len(graph)
        res = bfs(graph, source, sink, parent)
        if parent[sink] is None:
            break
        flow += 1
        v = sink
        while v != source:
            u = parent[v]
            graph[u][v] -= flow
            graph[v][u] += flow
            v = u
    return flow

def bfs(graph, source, sink, parent):
    visited = [False] * len(graph)
    queue = []
    queue.append(source)
    visited[source] = True
    while queue:
        u = queue.pop(0)
        for v, w in enumerate(graph[u]):
            if not visited[v] and w > 0:
                queue.append(v)
                visited[v] = True
                parent[v] = u
    return visited[sink]
```

**解析：** 使用Edmonds-Karp算法求解最大流问题。

#### 14. 排序算法

**题目16：快速排序**

**答案：**

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

**解析：** 使用递归实现快速排序。

#### 15. 算法设计思想

**题目17：分治算法求最大子序列和**

**答案：**

```python
def max_subarray_sum(arr):
    def divide_conquer(arr):
        if len(arr) <= 1:
            return arr[0], 0, 0
        mid = len(arr) // 2
        left_sum, left_start, left_end = divide_conquer(arr[:mid])
        right_sum, right_start, right_end = divide_conquer(arr[mid:])
        mid_sum, mid_start, mid_end = max_subarray_cross(arr, mid)
        if left_sum >= right_sum and left_sum >= mid_sum:
            return left_sum, left_start, left_end
        if right_sum >= left_sum and right_sum >= mid_sum:
            return right_sum, right_start, right_end
        return mid_sum, mid_start, mid_end

    def max_subarray_cross(arr, mid):
        left_sum = float('-inf')
        curr_sum = 0
        left_start = left_end = 0
        for i in range(mid, -1, -1):
            curr_sum += arr[i]
            if curr_sum > left_sum:
                left_sum = curr_sum
                left_start = i
                left_end = mid
        right_sum = float('-inf')
        curr_sum = 0
        right_start = right_end = mid + 1
        for i in range(mid + 1, len(arr)):
            curr_sum += arr[i]
            if curr_sum > right_sum:
                right_sum = curr_sum
                right_start = mid + 1
                right_end = i
        return max(left_sum + right_sum, right_sum, left_sum), left_start, right_end

    return divide_conquer(arr)
```

**解析：** 使用分治算法求最大子序列和，同时计算跨越中点的子序列和。

#### 16. 编程实践

**题目18：设计一个简单的HTTP服务器**

**答案：**

```python
from socket import socket, AF_INET, SOCK_STREAM
from http.server import HTTPServer, BaseHTTPRequestHandler

class SimpleHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(b"Hello, world!")

def run_server(host, port):
    httpd = HTTPServer((host, port), SimpleHTTPRequestHandler)
    print(f"Server running at http://{host}:{port}/")
    httpd.serve_forever()

if __name__ == "__main__":
    run_server("localhost", 8080)
```

**解析：** 使用Python的`http.server`模块实现一个简单的HTTP服务器，监听本地8080端口。

#### 17. 常见面试题总结

**题目19：如何判断一个链表是否为循环链表？**

**答案：**

```python
def has_cycle(head):
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

**解析：** 使用快慢指针法判断链表是否为循环链表。

**题目20：如何在一个有序数组中找到两个数，它们的和等于目标值？**

**答案：**

```python
def two_sum(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        curr_sum = nums[left] + nums[right]
        if curr_sum == target:
            return [left, right]
        elif curr_sum < target:
            left += 1
        else:
            right -= 1
    return []
```

**解析：** 使用双指针法在一个有序数组中找到两个数，它们的和等于目标值。

**题目21：如何实现一个LRU缓存？**

**答案：**

```python
from collections import OrderedDict

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        value = self.cache.pop(key)
        self.cache[key] = value
        return value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value
```

**解析：** 使用OrderedDict实现一个LRU缓存。

#### 总结

本篇博客总结了字节跳动2025校招编程面试题精华，涵盖了常见的数据结构与算法、编程实践等知识点。在面试准备过程中，掌握这些知识点是基础，同时需要不断练习和总结，以提高解题能力。希望对您有所帮助！

