                 

### 2024京东校招面试算法题库大全

#### 一、算法和数据结构

##### 1. 链表翻转

**题目：** 实现一个函数，将单链表翻转。

**答案：**

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head

    for curr != nil {
        nextTemp := curr.Next
        curr.Next = prev
        prev = curr
        curr = nextTemp
    }
    return prev
}
```

**解析：** 通过迭代的方式，使用三个指针变量分别指向当前节点、下一个节点和前一个节点，依次将每个节点指向其前一个节点，即可实现链表翻转。

##### 2. 两个有序链表合并

**题目：** 实现一个函数，将两个有序链表合并为一个有序链表。

**答案：**

```go
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

**解析：** 采用递归的方式，每次比较两个链表的头节点，选择较小的节点作为新的头节点，并递归合并剩余部分。

##### 3. 二叉树的最大深度

**题目：** 计算二叉树的最大深度。

**答案：**

```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    left := maxDepth(root.Left)
    right := maxDepth(root.Right)
    return max(left, right) + 1
}
```

**解析：** 采用递归的方式，计算左右子树的最大深度，取两者的最大值，再加上当前节点一层。

##### 4. 合并两个有序数组

**题目：** 给定两个有序数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 nums1 从起始位置开始包含两个数组的所有元素，并依然有序。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p3 := m-1, n-1, m+n-1

    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p3] = nums1[p1]
            p1--
        } else {
            nums1[p3] = nums2[p2]
            p2--
        }
        p3--
    }

    for p2 >= 0 {
        nums1[p3] = nums2[p2]
        p2--
        p3--
    }
}
```

**解析：** 从两个数组的尾部开始比较，将较大的值放入到合并后的数组的尾部，直到一个数组为空，然后将剩余的元素复制到合并后的数组中。

#### 二、高频面试题

##### 5. 螺旋矩阵

**题目：** 给定一个 m x n 的矩阵，按照螺旋顺序返回矩阵中的元素。

**答案：**

```go
func spiralOrder(matrix [][]int) []int {
    if len(matrix) == 0 {
        return []int{}
    }

    ans := make([]int, 0, len(matrix)*len(matrix[0]))
    rows, cols := len(matrix), len(matrix[0])
    rowStart, rowEnd, colStart, colEnd := 0, rows-1, 0, cols-1

    for {
        // print top row
        for col := colStart; col <= colEnd; col++ {
            ans = append(ans, matrix[rowStart][col])
        }
        rowStart++
        if rowStart > rowEnd || colStart > colEnd {
            break
        }

        // print right column
        for row := rowStart; row <= rowEnd; row++ {
            ans = append(ans, matrix[row][colEnd])
        }
        colEnd--

        if rowStart > rowEnd || colStart > colEnd {
            break
        }

        // print bottom row
        for col := colEnd; col >= colStart; col-- {
            ans = append(ans, matrix[rowEnd][col])
        }
        rowEnd--

        if rowStart > rowEnd || colStart > colEnd {
            break
        }

        // print left column
        for row := rowEnd; row >= rowStart; row-- {
            ans = append(ans, matrix[row][colStart])
        }
        colStart++
    }

    return ans
}
```

**解析：** 通过四个边界控制螺旋遍历，每次遍历后将边界向内收缩。

##### 6. 搜索插入位置

**题目：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它应该被按顺序插入的位置。

**答案：**

```go
func searchInsert(nums []int, target int) int {
    low, high := 0, len(nums)-1

    for low <= high {
        mid := (low + high) / 2

        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return low
}
```

**解析：** 采用二分查找算法，找到目标值或者最接近目标值的索引。

##### 7. 两数之和

**题目：** 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```go
func twoSum(nums []int, target int) []int {
    var map = make(map[int]int)

    for i, num := range nums {
        complement := target - num
        if j, ok := map[complement]; ok {
            return []int{j, i}
        }
        map[num] = i
    }

    return nil
}
```

**解析：** 使用哈希表存储数组元素的值和索引，通过计算目标值与当前元素的差值，查找是否存在对应的元素。

##### 8. 盗贼无法偷窃的最大金额

**题目：** 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响因素包括：距离下一间房子的距离、所偷窃的房子的最大金额和被偷窃的房子的邻居房子的最大金额。你需要从这些房子中选出最大的金额，但要注意不能相邻。

**答案：**

```go
func rob(nums []int) int {
    n := len(nums)
    if n == 0 {
        return 0
    }
    if n == 1 {
        return nums[0]
    }

    dp := make([]int, n)
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i := 2; i < n; i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }

    return dp[n-1]
}
```

**解析：** 动态规划，当前最大金额取决于前两个最大金额，状态转移方程为 `dp[i] = max(dp[i-1], dp[i-2]+nums[i])`。

##### 9. 搜索旋转排序数组

**题目：** 给你一个升序排列的整数数组 `nums`，该数组被多次旋转，每次旋转都会将数组中的一个元素移动到数组的开头。请找出并返回数组中的最小元素。

**答案：**

```go
func searchMin(nums []int) int {
    left, right := 0, len(nums)-1

    for left < right {
        mid := (left + right) / 2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }

    return nums[left]
}
```

**解析：** 二分查找，每次比较中点与最右端元素的关系，将数组划分为有序和无序两部分，不断缩小区间。

##### 10. 最长连续序列

**题目：** 给定一个未排序的整数数组，找出最长连续序列的长度（不要求序列元素在原数组中连续）。

**答案：**

```go
func longestConsecutive(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }

    ans := 1

    for num := range numSet {
        if !numSet[num-1] {
            curr := num
            for numSet[curr+1] {
                curr++
            }
            ans = max(ans, curr-num+1)
        }
    }

    return ans
}
```

**解析：** 使用哈希表存储数组元素，遍历数组，判断当前元素是否为最长连续序列的起点，如果是，则计算序列长度。

##### 11. 最大子序和

**题目：** 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数）。

**答案：**

```go
func maxSubArray(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    ans, currSum := nums[0], nums[0]

    for i := 1; i < len(nums); i++ {
        currSum = max(nums[i], currSum+nums[i])
        ans = max(ans, currSum)
    }

    return ans
}
```

**解析：** 动态规划，当前子序列和为前一个子序列和加上当前元素或者当前元素本身，取两者中的最大值，更新最大子序列和。

##### 12. 最长公共前缀

**题目：** 编写一个函数来查找字符串数组中的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix); j++ {
            if j >= len(strs[i]) || strs[i][j] != prefix[j] {
                prefix = prefix[:j]
                break
            }
        }
    }

    return prefix
}
```

**解析：** 遍历字符串数组，逐个比较前缀，直到找到一个不再匹配的部分，返回最长公共前缀。

##### 13. 罗马数字转整数

**题目：** 罗马数字包含以下七种字符：I，V，X，L，C，D和M。

```
字符  计算值
I     1
V     5
X     10
L     50
C     100
D     500
M     1000
```

例如，罗马数字`MMXXIII`表示2023。

给你一个罗马数字字符串`s`，请将其转换成整数。

**答案：**

```go
func romanToInt(s string) int {
    m := map[rune]int{
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000,
    }

    prev, ans := 0, 0
    for i := len(s) - 1; i >= 0; i-- {
        curr := m[rune(s[i])]
        if curr < prev {
            ans -= curr
        } else {
            ans += curr
        }
        prev = curr
    }
    return ans
}
```

**解析：** 从右向左遍历字符串，判断当前字符与下一个字符的大小关系，根据关系进行加减运算。

##### 14. 有效的括号

**题目：** 给定一个只包括 `'('`，`)`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效的字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }

    for _, char := range s {
        if _, ok := pairs[char]; ok {
            top := len(stack) - 1
            if top >= 0 && stack[top] == pairs[char] {
                stack = stack[:top]
            } else {
                return false
            }
        } else {
            stack = append(stack, char)
        }
    }

    return len(stack) == 0
}
```

**解析：** 使用栈进行括号匹配，遇到左括号入栈，遇到右括号则与栈顶元素匹配，不匹配则返回 false。

##### 15. 合并两个有序链表

**题目：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

**解析：** 采用递归的方式，每次比较两个链表的头节点，选择较小的节点作为新的头节点，并递归合并剩余部分。

##### 16. 快慢指针求环的入口

**题目：** 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

**答案：**

```go
func detectCycle(head *ListNode) *ListNode {
    slow := head
    fast := head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            break
        }
    }

    if fast == nil || fast.Next == nil {
        return nil
    }

    slow = head
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }

    return slow
}
```

**解析：** 使用快慢指针，快指针走两步，慢指针走一步，当快慢指针相遇时，再从链表头开始移动慢指针和快指针，直到它们再次相遇，此时相遇点即为环的入口。

##### 17. 三数之和

**题目：** 给定一个包含 `n` 个整数的数组 `nums`，判断 `nums` 中是否含有三个元素 a，b，c，使得 `a + b + c = 0`？找出所有满足条件且不重复的三元组。

**答案：**

```go
func threeSum(nums []int) [][]int {
    ans := [][]int{}
    n := len(nums)
    sort.Ints(nums)

    for i := 0; i < n-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        left, right := i+1, n-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                ans = append(ans, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }

    return ans
}
```

**解析：** 对数组进行排序，然后遍历数组，对于每个元素，使用双指针在剩余的数组中寻找两个数，使得三个数的和为 0。

##### 18. 有效括号字符串

**题目：** 给定一个只包含 '('，')'，'{'，'}'，'['，']' 的字符串 `s`，判断字符串是否有效。

有效的字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

**答案：**

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        '}': '{',
        ']': '[',
    }

    for _, char := range s {
        if _, ok := pairs[char]; ok {
            top := len(stack) - 1
            if top >= 0 && stack[top] == pairs[char] {
                stack = stack[:top]
            } else {
                return false
            }
        } else {
            stack = append(stack, char)
        }
    }

    return len(stack) == 0
}
```

**解析：** 使用栈进行括号匹配，遇到左括号入栈，遇到右括号则与栈顶元素匹配，不匹配则返回 false。

##### 19. 字符串匹配

**题目：** 给定一个字符串 `s` 和一个字符模式 `p`，实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```  
'.' 匹配任意单个字符。  
'*' 匹配零个或多个前面的那一个元素。  
匹配应该覆盖整个输入字符串（不是部分）。

```

**答案：**

```go
func isMatch(s string, p string) bool {
    m, n := len(s), len(p)
    dp := make([][]bool, m+1)
    for i := range dp {
        dp[i] = make([]bool, n+1)
        dp[i][0] = true
    }
    dp[0][0] = true

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if p[j-1] == '*' {
                dp[i][j] = dp[i][j-2] || dp[i-1][j]
            } else if p[j-1] == '?' || s[i-1] == p[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = false
            }
        }
    }

    return dp[m][n]
}
```

**解析：** 使用动态规划，状态转移方程为 `dp[i][j] = dp[i][j-2] || dp[i-1][j]` （`*`匹配）或 `dp[i][j] = dp[i-1][j-1]` （`?`或相同字符匹配）。

##### 20. 零钱兑换

**题目：** 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

**答案：**

```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    dp[0] = 0
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
        for _, coin := range coins {
            if i >= coin && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }
    if dp[amount] == math.MaxInt32 {
        return -1
    }
    return dp[amount]
}
```

**解析：** 使用动态规划，状态转移方程为 `dp[i] = min(dp[i], dp[i-coin]+1)`，其中 `coin` 是硬币的面额。如果不存在解，返回 `-1`。

##### 21. 等概率抽取最大元素

**题目：** 给定一个整数数组 `nums` 和一个整数 `k`，请返回能够通过 1 次抽取出数组中第 `k` 个最大元素的起始索引（从 0 开始计数）。如果不能通过 1 次抽取得到第 `k` 个最大元素，请返回 `-1`。

**答案：**

```go
func findKthLargest(nums []int, k int) int {
    return quickSelect(nums, 0, len(nums)-1, len(nums)-k)
}

func quickSelect(nums []int, left, right, k int) int {
    if left == right {
        return nums[left]
    }

    pivot := partition(nums, left, right)
    if k == pivot {
        return nums[k]
    } else if k < pivot {
        return quickSelect(nums, left, pivot-1, k)
    } else {
        return quickSelect(nums, pivot+1, right, k)
    }
}

func partition(nums []int, left, right int) int {
    pivot := nums[right]
    i := left
    for j := left; j < right; j++ {
        if nums[j] < pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }
    nums[i], nums[right] = nums[right], nums[i]
    return i
}
```

**解析：** 使用快速选择算法，每次选择一个基准值，将小于基准值的元素放在其左侧，大于或等于基准值的元素放在其右侧，递归处理左侧或右侧部分，直到找到第 `k` 个最大元素。

##### 22. 合并区间

**题目：** 给定一组区间，请合并所有重叠的区间。

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }

    return ans
}
```

**解析：** 首先对区间进行排序，然后遍历区间，如果当前区间的左端点大于前一个区间的右端点，则将当前区间添加到结果中；否则，将当前区间的右端点与前一个区间的右端点合并。

##### 23. 最小路径和

**题目：** 给定一个包含非负整数的 `m x n` 网格。请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**答案：**

```go
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }
    dp[0][0] = grid[0][0]

    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }

    return dp[m-1][n-1]
}
```

**解析：** 使用动态规划，状态转移方程为 `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`，计算从左上角到每个点的最小路径和。

##### 24. 搜索旋转排序数组

**题目：** 给定一个旋转排序的数组，实现一个搜索函数，找出目标值，并返回它的索引。如果目标值不存在，返回 `-1`。

**答案：**

```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := (left + right) / 2
        if nums[mid] == target {
            return mid
        }
        if nums[left] <= nums[mid] {
            if target >= nums[left] && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if target > nums[mid] && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

**解析：** 采用二分查找算法，每次判断中点是否是目标值，并根据中点值与左右端点值的关系来确定下一次搜索的区间。

##### 25. 最小覆盖子串

**题目：** 给你一个字符串 `s` 和一个字符集合 `t`。请你判断是否可以通过应用字符集合 `t` 中的字符替换 `s` 中的字符从而得到一个新的字符串，使得其包含且只包含字符集合 `t` 中的每个字符一次。

**答案：**

```go
func minWindow(s string, t string) string {
    if len(t) > len(s) {
        return ""
    }

    need := make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }

    left, right, valid := 0, 0, 0
    ans := ""
    cnt := make(map[byte]int)

    for right < len(s) {
        c := s[right]
        cnt[c]++
        if cnt[c] <= need[c] {
            valid++
        }
        right++

        for valid == len(need) {
            if len(ans) == 0 || right-left < len(ans) {
                ans = s[left:right]
            }

            d := s[left]
            cnt[d]--
            if cnt[d] < need[d] {
                valid--
            }
            left++
        }
    }

    return ans
}
```

**解析：** 使用双指针和哈希表，维护滑动窗口中的字符计数，当窗口中的字符满足条件时，更新结果。

##### 26. 最长公共子序列

**题目：** 给定两个字符串 `text1` 和 `text2`，找出 `text1` 和 `text2` 的最长公共子序列。

**答案：**

```go
func longestCommonSubsequence(text1 string, text2 string) string {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    var ans []byte
    i, j := m, n
    for i > 0 && j > 0 {
        if text1[i-1] == text2[j-1] {
            ans = append(ans, text1[i-1])
            i--
            j--
        } else if dp[i-1][j] > dp[i][j-1] {
            i--
        } else {
            j--
        }
    }

    reverse(ans)
    return string(ans)
}
```

**解析：** 使用动态规划，状态转移方程为 `dp[i][j] = dp[i-1][j-1] + 1` （相同字符）或 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])` （不同字符），然后回溯找出最长公共子序列。

##### 27. 二进制求和

**题目：** 给你两个二进制字符串，返回它们的和（用二进制表示）。

**答案：**

```go
func addBinary(a string, b string) string {
    ans := []byte{}
    i, j := len(a)-1, len(b)-1
    carry := 0

    for i >= 0 || j >= 0 || carry > 0 {
        x, y := 0, 0
        if i >= 0 {
            x = int(a[i] - '0')
            i--
        }
        if j >= 0 {
            y = int(b[j] - '0')
            j--
        }
        sum := x + y + carry
        carry = sum / 2
        ans = append(ans, byte(sum%2 + '0'))
    }

    reverse(ans)
    return string(ans)
}
```

**解析：** 从低位开始，对两个二进制字符串进行逐位相加，并计算进位，最后将结果翻转得到最终的和。

##### 28. 最大子矩阵和

**题目：** 给定一个二维数组 matrix，返回其中任意矩形子矩阵的最大和。

**答案：**

```go
func maxMatrixSum(matrix [][]int) int {
    ans := 0
    rows, cols := len(matrix), len(matrix[0])

    maxSum := func(nums []int) int {
        if len(nums) < 2 {
            return nums[0]
        }
        minIndex := 0
        for i := 1; i < len(nums); i++ {
            if nums[i] < nums[minIndex] {
                minIndex = i
            }
        }
        revNums := make([]int, len(nums))
        for i, num := range nums {
            revNums[len(nums)-i-1] = num
        }
        return max(nums[minIndex], revNums[minIndex])
    }

    for i := 0; i < rows; i++ {
        rowSum := make([]int, cols)
        for j := 0; j < cols; j++ {
            rowSum[j] += matrix[i][j]
        }
        for j := 0; j < cols; j++ {
            colSum := make([]int, rows)
            for i := 0; i < rows; i++ {
                colSum[i] += matrix[i][j]
            }
            for _, r := range colSum {
                for _, c := range rowSum {
                    ans = max(ans, maxSum([]int{r, c, -r, -c}))
                }
            }
        }
    }

    return ans
}
```

**解析：** 遍历数组，计算所有行和列的和，然后遍历行和列的和的交叉点，计算矩形子矩阵的和，并更新最大值。

##### 29. 前K个高频元素

**题目：** 给定一个非空的整数数组 `nums` 和一个整数 `k`，返回其中出现频率前 `k` 高的元素。可以按任意顺序返回答案。

**答案：**

```go
func topKFrequent(nums []int, k int) []int {
    count := make(map[int]int)
    for _, num := range nums {
        count[num]++
    }

    var heap []int
    for num, cnt := range count {
        heap = heapInsert(heap, cnt)
        if len(heap) > k {
            heap = heap[1:]
        }
    }

    ans := make([]int, k)
    for i := len(heap) - 1; i >= 0; i-- {
        for cnt := heap[i]; cnt > 0; cnt-- {
            ans = append(ans, num)
        }
    }
    return ans
}

func heapInsert(heap []int, val int) []int {
    heap = append(heap, val)
    i := len(heap) - 1
    for i > 0 && heap[(i-1)/2] < heap[i] {
        heap[i], heap[(i-1)/2] = heap[(i-1)/2], heap[i]
        i = (i - 1) / 2
    }
    return heap
}
```

**解析：** 使用哈希表统计元素出现频率，然后使用小根堆（大根堆也可）维护频率前 `k` 高的元素。

##### 30. 合并区间

**题目：** 给出一组区间，如何合并所有有重叠的区间？

**答案：**

```go
func merge(intervals [][]int) [][]int {
    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    ans := [][]int{}
    for _, interval := range intervals {
        if len(ans) == 0 || ans[len(ans)-1][1] < interval[0] {
            ans = append(ans, interval)
        } else {
            ans[len(ans)-1][1] = max(ans[len(ans)-1][1], interval[1])
        }
    }

    return ans
}
```

**解析：** 对区间进行排序，然后遍历区间，如果当前区间的左端点大于前一个区间的右端点，则将当前区间添加到结果中；否则，将当前区间的右端点与前一个区间的右端点合并。

### 31. 删除链表的节点

**题目：** 给定一个单链表和一个目标节点，删除该节点。

**答案：**

```go
func deleteNode(node *ListNode) {
    node.Val = node.Next.Val
    node.Next = node.Next.Next
}
```

**解析：** 将下一个节点的值赋给当前节点，然后跳过下一个节点。

### 32. 最长公共前缀

**题目：** 给定多个字符串，找出它们的最长公共前缀。

**答案：**

```go
func longestCommonPrefix(strs []string) string {
    if len(strs) == 0 {
        return ""
    }

    prefix := strs[0]
    for i := 1; i < len(strs); i++ {
        for j := 0; j < len(prefix); j++ {
            if j >= len(strs[i]) || strs[i][j] != prefix[j] {
                prefix = prefix[:j]
                break
            }
        }
    }

    return prefix
}
```

**解析：** 遍历字符串数组，依次比较前缀，直到找到一个不再匹配的部分。

### 33. 合并有序链表

**题目：** 给定两个有序链表，将它们合并为一个新的有序链表。

**答案：**

```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }

    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}
```

**解析：** 采用递归的方式，每次比较两个链表的头节点，选择较小的节点作为新的头节点，并递归合并剩余部分。

### 34. 最长递增子序列

**题目：** 给定一个整数数组，返回最长递增子序列的长度。

**答案：**

```go
func lengthOfLIS(nums []int) int {
    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }

    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }

    return max(dp...)
}
```

**解析：** 动态规划，状态转移方程为 `dp[i] = max(dp[i], dp[j]+1)`，其中 `nums[i] > nums[j]`。

### 35. 单调栈

**题目：** 使用单调栈解决以下问题：

- 给定一个数组 `nums`，返回下一个更大元素。
- 给定一个数组 `nums`，返回下一个更小元素。

**答案：**

```go
// 下一个更大元素
func nextGreaterElement(nums1 []int, nums2 []int) []int {
    stack := []int{}
    ans := make([]int, len(nums1))
    for i := len(nums2) - 1; i >= 0; i-- {
        for len(stack) > 0 && nums2[i] >= stack[len(stack)-1] {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            ans[nums1[i]] = -1
        } else {
            ans[nums1[i]] = stack[len(stack)-1]
        }
        stack = append(stack, nums2[i])
    }

    return ans
}

// 下一个更小元素
func nextSmallerElement(nums []int) []int {
    stack := []int{}
    ans := make([]int, len(nums))
    for i := len(nums) - 1; i >= 0; i-- {
        for len(stack) > 0 && nums[i] >= stack[len(stack)-1] {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            ans[i] = -1
        } else {
            ans[i] = stack[len(stack)-1]
        }
        stack = append(stack, nums[i])
    }

    return ans
}
```

**解析：** 使用单调栈，从右向左遍历数组，维护一个递减的栈。对于下一个更大/小元素，如果当前元素大于栈顶元素，则更新答案，并将栈顶元素弹出；否则，继续遍历下一个元素。

### 36. 柯里化

**题目：** 实现柯里化函数，将函数重构成多个函数，每次调用其中一个函数，可以减少参数数量，直到调用最后一个函数执行。

**答案：**

```go
func curry(fn func(a int, b int) int) (func(int), func(int)) {
    return func(a int) func(int) int {
        return func(b int) int {
            return fn(a, b)
        }
    }, func(b int) int {
        return fn(0, b)
    }
}
```

**解析：** 使用闭包，将函数重构成两个嵌套函数。第一个嵌套函数接收一个参数，返回第二个嵌套函数；第二个嵌套函数接收一个参数，执行原始函数。

### 37. 打家劫舍

**题目：** 给定一个非负整数数组 `nums`，每个元素代表从数组这个位置往后的房屋价值。计算你在不超过偷窃相邻房屋条件限制的情况下，一夜之内能够偷窃的最高价值。

**答案：**

```go
func rob(nums []int) int {
    prev, curr := 0, 0
    for _, num := range nums {
        prev, curr = curr, max(prev+num, curr)
    }
    return curr
}
```

**解析：** 动态规划，状态转移方程为 `dp[i] = max(dp[i-1], dp[i-2]+nums[i])`。

### 38. 二进制表示中的数字范围

**题目：** 给定一个二进制字符串，返回该字符串所表示的数字范围。例如，二进制字符串 `"1101"` 表示数字范围 `[6, 9]`。

**答案：**

```go
func rangeBitwiseAnd(m int, n int) int {
    shift := 0
    for m != n {
        m >>= 1
        n >>= 1
        shift++
    }
    return m << shift
}
```

**解析：** 将两个数同时右移，直到它们相等，记录右移的位数，然后将结果左移回原来的位置。

### 39. 两数之和

**题目：** 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

**答案：**

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        complement := target - num
        if j, ok := m[complement]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

**解析：** 使用哈希表，将每个元素与其索引存储在哈希表中。遍历数组，计算目标值与当前元素的差值，检查差值是否在哈希表中，如果是，则返回差值对应的索引和当前元素的索引。

### 40. 逆波兰表达式求值

**题目：** 给你一个逆波兰表达式（RPN 表达式），请你计算这个表达式的值。

有效的运算符包括 `+`、`-`、`*` 和 `/`。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**答案：**

```go
func evaluateRPN(tokens []string) int {
    stack := []int{}
    for _, token := range tokens {
        switch token {
        case "+":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a+b)
        case "-":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a-b)
        case "*":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            stack = append(stack, a*b)
        case "/":
            b := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            a := stack[len(stack)-1]
            if b == 0 {
                return 0
            }
            stack = stack[:len(stack)-1]
            stack = append(stack, a/b)
        default:
            stack = append(stack, atoi(token))
        }
    }
    return stack[0]
}

func atoi(s string) int {
    sign, num := 1, 0
    if s[0] == '-' {
        sign = -1
        s = s[1:]
    }
    for i := 0; i < len(s); i++ {
        num = num*10 + int(s[i]-'0')
    }
    return sign*num
}
```

**解析：** 使用栈，遍历逆波兰表达式，根据操作符进行相应的计算，并将结果入栈。

### 41. 设计哈希映射

**题目：** 设计哈希映射（HashMap）。实现一个 `MyHashMap` 类：

- `MyHashMap()` 使用一个空数组初始化哈希映射。
- `int put(int key, int value)`：向哈希映射中插入一个键值对（key-value）。如果键已存在，则更新其对应的值。
- `int get(int key)`：返回特定键的值（如果存在）。否则返回 `-1`。
- `void remove(int key)`：如果表中存在该键，则移除它的键值对。

**答案：**

```go
type MyHashMap struct {
    Buckets []int
    Size    int
}

/** Initialize your data structure here. */
func Constructor() MyHashMap {
    return MyHashMap{make([]int, 1000), 0}
}

/** value will always be non-negative. */
func (this *MyHashMap) Put(key int, value int) {
    if this.Buckets[key%1000] == -1 {
        this.Buckets[key%1000] = value
        this.Size++
    } else {
        this.Buckets[key%1000] = value
    }
}

/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
func (this *MyHashMap) Get(key int) int {
    if this.Buckets[key%1000] == -1 {
        return -1
    }
    return this.Buckets[key%1000]
}

/** Removes the mapping of the specified value key if this map contains a mapping for the key */
func (this *MyHashMap) Remove(key int) {
    if this.Buckets[key%1000] != -1 {
        this.Buckets[key%1000] = -1
        this.Size--
    }
}
```

**解析：** 使用数组模拟哈希表，通过取模确定元素在数组中的位置，实现 `put`、`get` 和 `remove` 操作。

### 42. 面试题 10.01. 合并排序的数组

**题目：** 给定两个排序后的数组 `nums1` 和 `nums2`，只有一个数组是满的，设计一个算法，将 `nums2` 合并到 `nums1` 中，使得 `nums1` 成为一个排序好的数组。

**答案：**

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
    p1, p2, p3 := m-1, n-1, m+n-1

    for p1 >= 0 && p2 >= 0 {
        if nums1[p1] > nums2[p2] {
            nums1[p3] = nums1[p1]
            p1--
        } else {
            nums1[p3] = nums2[p2]
            p2--
        }
        p3--
    }

    for p2 >= 0 {
        nums1[p3] = nums2[p2]
        p2--
        p3--
    }
}
```

**解析：** 从两个数组的尾部开始比较，将较大的值放入到合并后的数组的尾部，直到一个数组为空，然后将剩余的元素复制到合并后的数组中。

### 43. 面试题 17.07. 指数级时间复杂度

**题目：** 编写一个程序，找出两个整数 `num1` 和 `num2`，它们的乘积是一个指数级时间复杂度的数。例如 `num1 = 2` 和 `num2 = 3`，则返回 `6`。

**答案：**

```go
func superEggDrop(n int, k int) int {
    memo := make(map[int]int)
    return eggDropHelper(n, k, memo)
}

func eggDropHelper(m int, k int, memo map[int]int) int {
    if m == 0 || k == 1 {
        return m
    }

    if _, ok := memo[k*m]; ok {
        return memo[k*m]
    }

    ans := math.MaxInt32
    for i := 1; i <= m; i++ {
        left := eggDropHelper(i-1, k-1, memo)
        right := eggDropHelper(m-i, k, memo)
        ans = min(ans, 1+max(left, right))
    }

    memo[k*m] = ans
    return ans
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

**解析：** 使用动态规划，状态转移方程为 `dp(m, k) = 1 + max(dp(i-1, k-1), dp(m-i, k))`，其中 `i` 是当前测试的楼层。

### 44. 面试题 16.25. 秒度日历问题

**题目：** 实现一个秒度日历。秒度日历应支持以下两个操作：

1. `book(int start, int end)`：预订时间区间 `[start, end)`。
2. `book(int start, int end)`：取消预订时间区间 `[start, end)`。

请实现 `LeetcodeCalendar` 类：

- `LeetcodeCalendar()` 使用空参数初始化一个秒度日历对象。
- `bool book(int start, int end)`：返回 `true` 如果可以预订时间段 `[start, end)`，否则返回 `false`。如果时间段已经被预订，则不可预订。
- `bool book(int start, int end)`：返回 `true` 如果可以取消预订时间段 `[start, end)`，否则返回 `false`。如果时间段没有被预订，则不可取消。

**答案：**

```go
type LeetcodeCalendar struct {
    free map[int]bool
}

func Constructor() LeetcodeCalendar {
    return LeetcodeCalendar{map[int]bool{}}
}

func (this *LeetcodeCalendar) Book(start int, end int) bool {
    if start >= end {
        return false
    }
    if _, ok := this.free[start]; ok {
        this.free[start] = false
        if end > start {
            this.free[end] = true
        }
        return true
    }
    for k, v := range this.free {
        if k >= start && v {
            this.free[start] = true
            this.free[k] = false
            if end > k {
                this.free[end] = true
            }
            return true
        }
    }
    return false
}

func (this *LeetcodeCalendar) Unbook(start int, end int) bool {
    if start >= end {
        return false
    }
    if _, ok := this.free[start]; ok {
        this.free[start] = true
        if end > start {
            this.free[end] = false
        }
        return true
    }
    for k, v := range this.free {
        if k >= start && v {
            this.free[start] = false
            this.free[k] = true
            if end > k {
                this.free[end] = false
            }
            return true
        }
    }
    return false
}
```

**解析：** 使用哈希表存储每个时间点的状态，`true` 表示空闲，`false` 表示已预订。对于 `book` 操作，如果起始时间已预订，则将起始时间和结束时间设置为空闲；否则，遍历哈希表找到第一个空闲的时间点，将起始时间设置为预订，结束时间设置为空闲。对于 `unbook` 操作，如果起始时间已预订，则将起始时间和结束时间设置为空闲；否则，遍历哈希表找到第一个预订的时间点，将起始时间设置为空闲，结束时间设置为预订。

### 45. 面试题 17.19. 水域面积

**题目：** 给你一个大小为 `m x n` 的二进制矩阵 grid 。一个岛屿是由每行每列只包含 `1` 的最大矩形组成。

- 如果只有岛屿的内部边界被 `0` 包围，那么我们称它为孤独岛屿。

请你返回 grid 中所有岛屿中，孤独岛屿的数量。

**答案：**

```go
func countIslands(grid [][]int) int {
    rows, cols := len(grid), len(grid[0])
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}

    def func(i, j int) {
        grid[i][j] = 0
        for _, dir := range dirs {
            x, y := i+dir[0], j+dir[1]
            if 0 <= x && x < rows && 0 <= y && y < cols && grid[x][y] == 1 {
                def(func(x, y))
            }
    }

    ans := 0
    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if grid[i][j] == 1 {
                def(i, j)
                ans++
            }
        }
    }

    return ans
}
```

**解析：** 使用 DFS 遍历岛屿，并将其标记为已访问。如果岛屿的边界完全由 `0` 组成，则它是孤独的。

### 46. 面试题 17.20. �аков�帽问题

**题目：** 有一个正方形网格，你需要从格子 `(0, 0)` 出发，达到格子 `(m-1, n-1)`，每一步可以在四个方向上移动，但是不能穿过有障碍物（用 `2` 表示）的格子。每次移动都有一定的能量消耗，你的目标是使总能量消耗最小。

- 假设你在格子 `(i, j)`，需要移动到 `(i+1, j)`，则消耗的能量为 `|i+1 - i|`。
- 同理，如果你需要移动到 `(i, j+1)`，则消耗的能量为 `|j+1 - j|`。

请你设计一个算法，找出使总能量消耗最小的路径。

**答案：**

```go
func minimumTotalEnergy(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    energy := make([]int, m)
    energy[0] = 0

    for i := 1; i < m; i++ {
        energy[i] = energy[i-1] + abs(grid[i][0]-grid[i-1][0])
    }

    for j := 1; j < n; j++ {
        prev := energy[0]
        energy[0] = energy[0] + abs(grid[0][j]-grid[0][j-1])

        for i := 1; i < m; i++ {
            curr := energy[i]
            energy[i] = prev + abs(grid[i][j]-grid[i][j-1])
            prev = curr
        }
    }

    return energy[m-1]
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

**解析：** 动态规划，分别计算从左向右和从上向下移动的能量消耗，最后得到到达 `(m-1, n-1)` 的最小能量消耗。

### 47. 面试题 17.21. 矩阵中的路径

**题目：** 给定一个包含字母的矩阵 matrix（含有 `1` 到 `26` 个字母），设计一个算法来搜索矩阵 matrix 中的路径。一条路径是指从左上角 (0, 0) 到右下角 (m-1, n-1) 的路径，路径中的每一项必须是矩阵中的字母。路径中不可能走过 `2` 个连续的相同字母。

例如，如果 `matrix` 如下所示：

```
[
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
```

可以找到以下的路径：

```
[
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E']
]
```

但不合法的路径：

```
[
  ['A', 'B', 'C', 'E'],
  ['S', 'F', 'C', 'S'],
  ['A', 'D', 'E', 'E'],
  ['A', 'E', 'E', 'E']
]
```

**答案：**

```go
func exist(board [][]byte, word string) bool {
    rows, cols := len(board), len(board[0])
    visited := make([][]bool, rows)
    for i := range visited {
        visited[i] = make([]bool, cols)
    }

    for i := 0; i < rows; i++ {
        for j := 0; j < cols; j++ {
            if search(board, i, j, 0, visited, word) {
                return true
            }
        }
    }

    return false
}

func search(board [][]byte, i int, j int, k int, visited [][]bool, word string) bool {
    if k == len(word) {
        return true
    }
    if i < 0 || i >= len(board) || j < 0 || j >= len(board[0]) || visited[i][j] || board[i][j] != byte(word[k]) {
        return false
    }
    visited[i][j] = true
    if search(board, i+1, j, k+1, visited, word) {
        return true
    }
    if search(board, i-1, j, k+1, visited, word) {
        return true
    }
    if search(board, i, j+1, k+1, visited, word) {
        return true
    }
    if search(board, i, j-1, k+1, visited, word) {
        return true
    }
    visited[i][j] = false
    return false
}
```

**解析：** 使用 DFS 遍历矩阵，每次判断当前位置是否满足条件，如果满足，则递归搜索下一个位置。

### 48. 面试题 17.22. 山坡路线

**题目：** 一个直观点是，你可以通过将两个元素沿着下坡方向相加来创建一个新的元素，例如 `[1, 3, 2, 4]` 可以通过 `[2, 3, 5, 7]` 来创建。请你实现一个函数，返回给定的数组和整数 `k` 可以创建的最小的元素。

例如，`[4, 2, 1]` 和 `k = 1` 的最小可能元素是 `[2, 2, 2]`。

**答案：**

```go
func minimumElement(nums []int, k int) int {
    sort.Ints(nums)
    n := len(nums)
    for i := n - 1; i >= 0; i-- {
        if nums[i]+k >= nums[i-1] {
            return nums[i] + k
        }
        k--
    }
    return 0
}
```

**解析：** 将数组排序，从后向前遍历，如果当前元素加上 `k` 大于前一个元素，则返回当前元素加上 `k`，否则将 `k` 减一，继续遍历。

### 49. 面试题 17.23. 每日温度

**题目：** 请编写一个函数，以温度序列 temperatures 作为输入，该函数返回一个整数数组，其中第 i 个元素表示对于 temperatures 中第 i 天的下一日最高温度。如果气温在这之后不会升高，则该值应该是 `0`。

例如，给定一个温度列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的函数应该返回 `[0, 1, 4, 2, 1, 1, 0, 0]`。

**答案：**

```go
func dailyTemperatures(temperatures []int) []int {
    ans := make([]int, len(temperatures))
    stack := []int{}
    for i, v := range temperatures {
        for len(stack) > 0 && temperatures[stack[len(stack)-1]] <= v {
            stack = stack[:len(stack)-1]
        }
        if len(stack) == 0 {
            ans[i] = 0
        } else {
            ans[i] = i - stack[len(stack)-1]
        }
        stack = append(stack, i)
    }
    return ans
}
```

**解析：** 使用单调栈，遍历数组，对于每个元素，如果栈顶元素小于当前元素，则弹出栈顶元素，并将当前元素与栈顶元素的索引差作为答案；否则，将当前元素入栈。

### 50. 面试题 17.24. 交换连续的元素

**题目：** 给定一个数组 `nums`，你可以交换数组内两个元素的顺序。返回需要多少次交换才能使数组成为严格递增的序列。

例如，`[4, 3, 1, 2]` 可以通过仅交换 `[4, 3]` 变为 `[1, 2, 3, 4]`。

**答案：**

```go
func countSwaps(nums []int) int {
    n := len(nums)
    ans := 0
    for i := 0; i < n-1; i++ {
        for j := i + 1; j < n; j++ {
            if nums[i] > nums[j] {
                nums[i], nums[j] = nums[j], nums[i]
                ans++
            }
        }
    }
    return ans
}
```

**解析：** 使用冒泡排序算法，遍历数组，如果当前元素大于下一个元素，则交换它们，并计数交换次数。

