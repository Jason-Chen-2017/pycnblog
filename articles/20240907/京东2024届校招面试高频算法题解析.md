                 




# 京东2024届校招面试高频算法题解析

## 目录

1. [二分查找](#1-二分查找)
2. [最长递增子序列](#2-最长递增子序列)
3. [旋转数组中的最小值](#3-旋转数组中的最小值)
4. [最长公共子序列](#4-最长公共子序列)
5. [最小生成树](#5-最小生成树)
6. [图的最短路径](#6-图的最短路径)
7. [字符串匹配](#7-字符串匹配)
8. [动态规划](#8-动态规划)
9. [排序算法](#9-排序算法)
10. [数据结构](#10-数据结构)
11. [其他面试题](#11-其他面试题)

## 1. 二分查找

### 题目

实现二分查找算法，给定一个有序数组和一个目标值，判断目标值是否存在于数组中。

### 答案

```go
package main

import "fmt"

func binarySearch(arr []int, target int) int {
    low, high := 0, len(arr)-1

    for low <= high {
        mid := (low + high) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }

    return -1
}

func main() {
    arr := []int{1, 3, 5, 7, 9}
    target := 5
    result := binarySearch(arr, target)
    if result != -1 {
        fmt.Printf("目标值 %d 在数组中，索引为 %d\n", target, result)
    } else {
        fmt.Printf("目标值 %d 不在数组中\n", target)
    }
}
```

### 解析

该算法的时间复杂度为 \(O(\log n)\)，在数组中查找目标值非常高效。算法的核心思想是通过不断将搜索范围缩小一半，从而快速找到目标值或确定其不存在。

## 2. 最长递增子序列

### 题目

给定一个无序数组，找出最长递增子序列的长度。

### 答案

```go
package main

import "fmt"

func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = 1
    for i := 1; i < len(nums); i++ {
        dp[i] = 1
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
    }
    return max(dp...)
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{10, 9, 2, 5, 3, 7, 101, 18}
    result := lengthOfLIS(nums)
    fmt.Printf("最长递增子序列的长度为：%d\n", result)
}
```

### 解析

该算法使用动态规划求解最长递增子序列的长度，时间复杂度为 \(O(n^2)\)。算法的核心思想是通过遍历数组，对于每个元素，找出其之前的所有元素中，可以构成递增子序列的最大长度，并更新全局最长递增子序列的长度。

## 3. 旋转数组中的最小值

### 题目

给定一个旋转后的有序数组，找出数组中的最小值。

### 答案

```go
package main

import "fmt"

func findMin(nums []int) int {
    low, high := 0, len(nums)-1
    for low < high {
        mid := (low + high) / 2
        if nums[mid] > nums[high] {
            low = mid + 1
        } else {
            high = mid
        }
    }
    return nums[low]
}

func main() {
    nums := []int{4, 5, 6, 7, 0, 1, 2}
    result := findMin(nums)
    fmt.Printf("旋转数组中的最小值为：%d\n", result)
}
```

### 解析

该算法使用二分查找法在旋转后的数组中找到最小值，时间复杂度为 \(O(\log n)\)。算法的核心思想是通过比较中间元素和最右端元素的大小关系，不断缩小查找范围，直到找到最小值。

## 4. 最长公共子序列

### 题目

给定两个字符串，找出它们的最长公共子序列。

### 答案

```go
package main

import "fmt"

func longestCommonSubsequence(text1, text2 string) string {
    dp := make([][]int, len(text1)+1)
    for i := range dp {
        dp[i] = make([]int, len(text2)+1)
        for j := range dp[i] {
            if i == 0 || j == 0 {
                dp[i][j] = 0
            } else if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[len(text1)][len(text2)]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    text1 := "abcde"
    text2 := "ace"
    result := longestCommonSubsequence(text1, text2)
    fmt.Printf("最长公共子序列为：%s\n", result)
}
```

### 解析

该算法使用动态规划求解最长公共子序列，时间复杂度为 \(O(mn)\)，其中 \(m\) 和 \(n\) 分别为两个字符串的长度。算法的核心思想是构建一个二维数组，记录每个位置的最长公共子序列长度，然后通过回溯找到最长公共子序列。

## 5. 最小生成树

### 题目

给定一个加权无向图，找出最小生成树。

### 答案

```go
package main

import (
    "fmt"
    "sort"
)

type Edge struct {
    start, end, weight int
}

func (e Edge) LessThan(other Edge) bool {
    return e.weight < other.weight
}

func prim_graph(graph [][]int) int {
    n := len(graph)
    mst := make([]bool, n)
    total := 0
    edges := make([]Edge, 0)
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            if graph[i][j] > 0 {
                edges = append(edges, Edge{i, j, graph[i][j]})
            }
        }
    }
    sort.Sort(EdgeSlice(edges))
    for i := 0; i < n-1; i++ {
        _, j := edges[0].LessThan(edges[1])
        total += edges[0].weight
        mst[edges[0].start] = true
        mst[edges[0].end] = true
        graph[edges[0].start][edges[0].end] = 0
        graph[edges[0].end][edges[0].start] = 0
        edges = edges[1:]
    }
    return total
}

func main() {
    graph := [][]int{
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 1, 7},
        {6, 8, 1, 0, 2},
        {0, 5, 7, 2, 0},
    }
    result := prim_graph(graph)
    fmt.Printf("最小生成树的总权值为：%d\n", result)
}
```

### 解析

该算法使用 Prim 算法求解最小生成树，时间复杂度为 \(O(E\log V)\)，其中 \(E\) 为边数，\(V\) 为顶点数。算法的核心思想是从任意一个顶点开始，逐步添加边，直到形成最小生成树。

## 6. 图的最短路径

### 题目

给定一个加权有向图和一个起始顶点，找出从起始顶点到其他所有顶点的最短路径。

### 答案

```go
package main

import (
    "fmt"
    "math"
)

func dijkstra(graph [][]float64, start int) []float64 {
    n := len(graph)
    dist := make([]float64, n)
    for i := 0; i < n; i++ {
        dist[i] = math.MaxFloat64
    }
    dist[start] = 0
    visited := make([]bool, n)
    for i := 0; i < n; i++ {
        u := -1
        for j := 0; j < n; j++ {
            if !visited[j] && (u == -1 || dist[j] < dist[u]) {
                u = j
            }
        }
        visited[u] = true
        for v := 0; v < n; v++ {
            if graph[u][v] > 0 && !visited[v] {
                dist[v] = min(dist[v], dist[u]+graph[u][v])
            }
        }
    }
    return dist
}

func min(a, b float64) float64 {
    if a < b {
        return a
    }
    return b
}

func main() {
    graph := [][]float64{
        {0, 4, 0, 0, 0, 0, 0, 8, 0},
        {4, 0, 8, 0, 0, 0, 0, 11, 0},
        {0, 8, 0, 2, 0, 7, 0, 0, 9},
        {0, 0, 2, 0, 6, 0, 3, 0, 0},
        {0, 0, 0, 6, 0, 2, 0, 0, 7},
        {0, 0, 7, 0, 2, 0, 5, 4, 0},
        {0, 0, 0, 3, 0, 5, 0, 4, 2},
        {8, 11, 0, 0, 0, 4, 4, 0, 0},
        {0, 0, 9, 0, 7, 0, 2, 0, 0},
    }
    start := 0
    result := dijkstra(graph, start)
    fmt.Println(result)
}
```

### 解析

该算法使用 Dijkstra 算法求解最短路径，时间复杂度为 \(O(V^2)\)，其中 \(V\) 为顶点数。算法的核心思想是从起始顶点开始，逐步更新每个顶点的最短路径，直到所有顶点的最短路径都被计算出来。

## 7. 字符串匹配

### 题目

给定一个字符串和一个模式，找出字符串中所有与模式匹配的子字符串。

### 答案

```go
package main

import "fmt"

func search(s string, pattern string) []int {
    n, m := len(s), len(pattern)
    lps := make([]int, m)
    j := 0

    computeLPSArray(pattern, m, lps)

    i := 0
    for i < n {
        if pattern[j] == s[i] {
            i++
            j++
        }

        if j == m {
            fmt.Printf("匹配的子字符串从索引 %d 到 %d\n", i-j, i-1)
            j = lps[j-1]
        }

        if pattern[j] != s[i] {
            if j != 0 {
                j = lps[j-1]
            } else {
                i++
            }
        }
    }
    return nil
}

func computeLPSArray(pattern string, m int, lps []int) {
    length := 0
    lps[0] = 0
    i := 1
    for i < m {
        if pattern[i] == pattern[length] {
            length++
            lps[i] = length
            i++
        } else {
            if length != 0 {
                length = lps[length-1]
            } else {
                lps[i] = 0
                i++
            }
        }
    }
}

func main() {
    s := "ababdaba"
    p := "abad"
    search(s, p)
}
```

### 解析

该算法使用 KMP 算法进行字符串匹配，时间复杂度为 \(O(n+m)\)，其中 \(n\) 为主字符串长度，\(m\) 为模式长度。算法的核心思想是利用最长公共前后缀（LPS）数组，避免在匹配失败时回溯，从而提高匹配效率。

## 8. 动态规划

### 题目

给定一个数组，找出最大子序列和。

### 答案

```go
package main

import "fmt"

func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]
    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}

func main() {
    nums := []int{-2, 1, -3, 4, -1, 2, 1, -5, 4}
    result := maxSubArray(nums)
    fmt.Printf("最大子序列和为：%d\n", result)
}
```

### 解析

该算法使用动态规划求解最大子序列和，时间复杂度为 \(O(n)\)，其中 \(n\) 为数组长度。算法的核心思想是从前一个元素的最大子序列和和当前元素中选出较大的值，作为当前元素的最大子序列和。

## 9. 排序算法

### 题目

给定一个数组，使用快速排序算法进行排序。

### 答案

```go
package main

import "fmt"

func quickSort(nums []int, low, high int) {
    if low < high {
        pi := partition(nums, low, high)
        quickSort(nums, low, pi-1)
        quickSort(nums, pi+1, high)
    }
}

func partition(nums []int, low, high int) int {
    pivot := nums[high]
    i := low - 1
    for j := low; j < high; j++ {
        if nums[j] < pivot {
            i++
            nums[i], nums[j] = nums[j], nums[i]
        }
    }
    nums[i+1], nums[high] = nums[high], nums[i+1]
    return i + 1
}

func main() {
    nums := []int{3, 6, 8, 10, 1, 2, 1}
    quickSort(nums, 0, len(nums)-1)
    fmt.Println(nums)
}
```

### 解析

该算法使用快速排序算法进行排序，时间复杂度为 \(O(n\log n)\) 的平均情况。算法的核心思想是通过一趟排序将数组分成两部分，其中一部分的所有元素都比另一部分的所有元素小，然后递归地对这两部分进行排序。

## 10. 数据结构

### 题目

实现一个链表数据结构，支持插入、删除和遍历操作。

### 答案

```go
package main

import "fmt"

type ListNode struct {
    Val  int
    Next *ListNode
}

func (l *ListNode) Append(val int) {
    new_node := &ListNode{Val: val}
    if l == nil {
        l = new_node
    } else {
        current := l
        for current.Next != nil {
            current = current.Next
        }
        current.Next = new_node
    }
}

func (l *ListNode) Delete(val int) {
    if l == nil {
        return
    }
    if l.Val == val {
        l = l.Next
        return
    }
    current := l
    for current.Next != nil && current.Next.Val != val {
        current = current.Next
    }
    if current.Next != nil {
        current.Next = current.Next.Next
    }
}

func (l *ListNode) Print() {
    if l == nil {
        fmt.Println("链表为空")
        return
    }
    current := l
    for current != nil {
        fmt.Printf("%d ", current.Val)
        current = current.Next
    }
    fmt.Println()
}

func main() {
    l := &ListNode{}
    l.Append(1)
    l.Append(2)
    l.Append(3)
    l.Append(4)
    l.Print()
    l.Delete(3)
    l.Print()
}
```

### 解析

该算法实现了一个链表数据结构，支持插入、删除和遍历操作。链表使用一个 `ListNode` 结构体表示，其中包含值和指向下一个节点的指针。算法的核心思想是通过修改节点的指针来实现插入和删除操作。

## 11. 其他面试题

### 题目

实现一个函数，判断一个整数是否是回文数。

### 答案

```go
package main

import "fmt"

func isPalindrome(x int) bool {
    if x < 0 || (x % 10 == 0 && x != 0) {
        return false
    }
    reversed := 0
    for x > reversed {
        reversed = reversed*10 + x%10
        x /= 10
    }
    return x == reversed || x == reversed/10
}

func main() {
    x := 12321
    if isPalindrome(x) {
        fmt.Println("是回文数")
    } else {
        fmt.Println("不是回文数")
    }
}
```

### 解析

该算法实现了一个函数，判断一个整数是否是回文数。算法的核心思想是将整数反转，然后与原整数进行比较，如果相等，则说明是回文数。注意需要处理特殊情况，如负数和非零的尾数为0的整数。时间复杂度为 \(O(\log n)\)，其中 \(n\) 为整数的位数。

