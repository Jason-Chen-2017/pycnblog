
作者：禅与计算机程序设计艺术                    

# 1.简介
  

动态规划（Dynamic Programming）是一种通过把相似的子问题的解重复计算的方法，从而避免解决每个子问题一次并得到最终结果的方法。它运用了分治策略的思想，将复杂的问题分成多个相同或相似的子问题，递归地求解各个子问题，然后再合并其结果，从而达到总问题的最优解。动态规划通常适用于具有最优子结构的问题，也就是一个问题的最优解由其子问题的最优解所决定。

在实际应用中，动态规划往往面临着很多挑战，例如时间复杂度高、空间复杂度大等，因此，对于一般的动态规划题目，应首先要对动态规划的定义和基本准则有所了解，然后才能进一步分析其特点和适用性，并利用相应的算法设计方法求得正确的答案。另外，还需要注意动态规划算法中的一些陷阱和局限性。

本文将介绍动态规划经典题目的类型和难度，并介绍如何快速掌握这类题目的技巧。

# 2.动态规划概述
## 2.1 动态规划分类及难度
根据动态规划问题的输入规模的大小，可以分为自顶向下法(bottom-up)和自底向上法(top-down)，但通常只提倡使用自顶向下法。

自顶向下法就是逐步推演，先考虑简单的情况，再依次推广到所有的情况。他要求各个状态之间互相独立，同时定义一个数组dp[]，其中dp[i]表示当期末索引为i时的最大收益。

### 一维数组
假设有一段长度为n的序列，每天只能买入或卖出一次，问给定前i天的价格序列，确定第i+1天股票的最佳买卖点。这类问题属于最优化问题。

这道题可以使用一维数组来进行状态转移，我们定义dp[i]代表第i天股票的最佳买卖点，那么就有如下状态转移方程:

1. 如果不持股，那么dp[i]=max{dp[j]+p[i]}，其中j=0..i-1,p[i]>0, p[i]代表第i日的价格。这是因为不持股时，当前的最高利润取决于之前的所有交易日的最低价加上今天的收盘价；

2. 如果持股，那么dp[i]=max{dp[j]-p[i]}，其中j=0..i-1,p[i]<0, -p[i]代表第i日的价格。这是因为持股时，当前的最高利润取决于之前的所有交易日的最高价减去今天的开盘价。

时间复杂度：O(n)。
空间复杂度：O(1)。

### 二维数组
假设有一个矩阵M，它的元素可以取-1、0或者1，代表四种不同的动作。第i行第j列代表在位置(i,j)处的位置，我们希望选择路径上的所有元素，使得最终选取的元素之和最大。这类问题也是最优化问题。

这道题可以使用二维数组来进行状态转移，我们定义dp[i][j]代表在位置(i,j)处的路径上的元素和的最大值，那么就有如下状态转移方程:

1. 如果当前位置为空格，那么dp[i][j]=dp[i-1][j],dp[i][j]=dp[i][j-1];

2. 如果当前位置为+1，那么dp[i][j]=max{dp[k][l]+M[i][j]},其中k<i<=dp[0].size(), l<j<=dp[0][0].size();

3. 如果当前位置为-1，那么dp[i][j]=max{-dp[k][l]+M[i][j]},其中k<i<=dp[0].size(), l<j<=dp[0][0].size();

其中dp[0].size()代表矩阵的行数，dp[0][0].size()代表矩阵的列数。

时间复杂度：O(mn)。
空间复杂度：O(mn)。

### n维数组
这类问题最难，但是也很重要，要求解满足一定条件的多维问题。这种问题可以通过递归的方式进行，其中每一个维度是一个问题，都可以分别采用自顶向下或者自底向上的方式进行求解，最后的答案就是这些子问题的解的组合。

这类问题包括很多，比如背包问题，旅行商问题等。

# 3.怎样快速掌握动态规划题型
除了知识基础，掌握某一种动态规划题型还需要一些技巧。下面介绍一下几种典型的题型及其对应的技巧。

## 3.1 一维数组的DP问题——买卖股票
这一类问题比较简单，即寻找一段连续的时间内股票的最大收益。

#### 解题思路：

第一步，确定状态变量，我们定义dp[i]代表第i天股票的最大收益，那么就有如下状态转移方程:

1. dp[i] = max(dp[i-1], prices[i])，如果第i天不买入股票，则最大收益等于前一天最大收益；

2. dp[i] = max(dp[i-1], prices[i] + dp[i-2]), 如果第i天买入股票，则最大收益等于前一天最大收益加上今天的收益。

第二步，确定边界条件，对于没有操作的初始值，我们可以设置为prices[0]，对于还没交易的天数，我们可以设置为0，这样的话，dp[0]、dp[1]...都是prices[0]。

第三步，实现代码，时间复杂度为O(n)，空间复杂度为O(1)。

#### 提升技巧：

1. 暴力解法。暴力解法需要穷举所有可能的状态和选择，时间复杂度太高，不现实。

2. 分治法。对于这类问题，可以将整个数组分成两个子问题，分别求解，最后合并得到答案。分治法的平均时间复杂度是O(nlgn)，可以在较小数据量下运行得非常好。

3. 动态规划的备忘录。对于同样的问题，我们可以保存已经计算过的值，省去重复计算。

4. 使用滚动数组。对于这类问题，只需要保留两个状态变量即可，不需要存储完整的dp数组。

## 3.2 一维数组的DP问题——最长上升子序列
这一类问题描述的是一个整数数组，找到这个数组中的最长上升子序列的长度。

#### 解题思路：

第一步，确定状态变量，我们定义dp[i]代表以第i个数字结尾的最长上升子序列的长度，那么就有如下状态转移方程:

1. dp[i] = max(dp[j] + 1), where j < i and nums[j] < nums[i] for all j (0 <= j < i). 此时我们可以从左侧找到比nums[i]大的数，则以此数字结尾的子序列长度为dp[i]+1；

2. dp[i] = 1 if there is no such j in the previous step. 此时我们可以从右侧找到比nums[i]大的数，则以此数字结尾的子序列长度为1。

第二步，确定边界条件，对于没有操作的初始值，我们可以设置为1，对于只有一个元素的数组，其最长上升子序列的长度为1，所以dp[0] = 1。

第三步，实现代码，时间复杂度为O(n^2)，空间复杂度为O(n)。

#### 提升技巧：

1. 暴力解法。暴力解法需要穷举所有可能的状态和选择，时间复杂度太高，不现实。

2. 分治法。对于这类问题，可以将整个数组分成两个子问题，分别求解，最后合并得到答案。分治法的平均时间复杂度是O(nlgn)，可以在较小数据量下运行得非常好。

3. 贪心算法。贪心算法会选择一个局部最优解，我们可以每次选择数组中最小的数加入子序列。这种方法不会产生全局最优解，但可以保证最优解是有界的。

4. DP的矩阵压缩。动态规划的状态数过多时，可以使用矩阵压缩的方法来降低内存消耗。

## 3.3 二维数组的DP问题——编辑距离
这一类问题描述的是两个字符串之间的最小编辑距离。

#### 解题思路：

第一步，确定状态变量，我们定义dp[i][j]代表从s1的前i个字符转换到s2的前j个字符的最小编辑距离，那么就有如下状态转移方程:

1. 如果s1[i-1] == s2[j-1], dp[i][j] = dp[i-1][j-1];

2. 如果s1[i-1]!= s2[j-1], dp[i][j] = min{dp[i-1][j], dp[i][j-1], dp[i-1][j-1]} + 1;

第二步，确定边界条件，对于空串，dp[i][0] = i，dp[0][j] = j。

第三步，实现代码，时间复杂度为O(mn)，空间复杂度为O(mn)。

#### 提升技巧：

1. 暴力解法。暴力解法需要穷举所有可能的状态和选择，时间复杂度太高，不现实。

2. 动态规划矩阵优化。矩阵的大小其实并不是平方关系，我们可以仅仅维护两个一维数组，来代替二维数组。

3. 动态规划状态压缩。由于编辑距离有三种情况，如果只用三个状态，就可以减少空间复杂度。

## 3.4 n维数组的DP问题——矩阵链乘法
这一类问题描述的是一个n个矩阵的乘积，找到最有效率的顺序来计算他们。

#### 解题思路：

首先，我们可以将这个问题分解成两个子问题，即计算A[i]与B[i]的乘积，以及计算A[i]与C[i]、B[i]与C[i]的乘积。然后，可以得到子问题的最优解。

然后，我们可以对两者结合起来，来获得最终的最优解。这里的状态变量是f[i][j]，表示计算A[i]到C[j]的乘积的最小代价，那么就有如下状态转移方程:

1. f[i][j] = MIN(f[i][k]+f[k+1][j]+P[i]*P[k]*P[j]), k from i to j-1; 表示按照顺序计算A[i]到C[j]的最小代价，需要用A[i]和A[i+1]……C[j-1]与A[i]与B[i]与C[i]的乘积，但是中间那条路径为i到k和k+1到j的乘积，可以直接得到；

2. f[i][i] = 0, for i from 0 to n-1; 表示计算A[i]到A[i]的乘积为0。

然后，我们可以用动态规划来计算这个最优解，时间复杂度为O(n^3)。

#### 提升技巧：

1. 暴力解法。暴力解法需要穷举所有可能的状态和选择，时间复杂度太高，不现实。

2. 分治法。对于这类问题，可以将整个数组分成两个子问题，分别求解，最后合并得到答案。分治法的平均时间复杂度是O(nlgn)，可以在较小数据量下运行得非常好。

3. DP的矩阵压缩。动态规划的状态数过多时，可以使用矩阵压缩的方法来降低内存消耗。

4. 记忆化搜索。记忆化搜索法可以记录之前计算过的值，省去重复计算。