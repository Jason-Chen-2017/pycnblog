
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、问题定义
在一个连通的无向图中，希望找到一棵权值之和最小的连通子图（又称为生成树），该子图满足以下两个条件：

1.边数等于节点数-1；

2.所有顶点之间都存在路径相连。

此时的图可以用邻接矩阵或邻接表表示，采用Prim算法或Kruskal算法可快速求出一棵权值之和最小的生成树。但是，即使对于一般的图来说，Prim算法或Kruskal算法也需要进行多次运行才能得到一个最优解，因此一般情况下较耗时。而使用贪心算法则可以保证每次迭代得到一个近似最优解，快速收敛到全局最优解。贪心算法有很多种选择，这里以Kruskal算法为例。
## 二、算法介绍
Kruskal算法是一种贪心算法，它每次选取一条边加入到生成树中，直至满足生成树条件。具体地说，Kruskal算法遵循如下步骤：

1.将各个节点看作单独的集合。
2.从图的边集合中选取一条权值最小的边并将其加入到生成树中。
3.检查是否形成了回路，如果形成了，那么将边剔除；否则，合并这条边所在的两端的集合。
4.重复第2步，直至生成树中含有n-1条边，其中n是节点个数。

贪心选择的结果是，由于边按照权值的大小非严格递增顺序选取，因此能保证生成树中权值之和最小。同时，由于每一次选择都会剔除掉某些不可能成为生成树边的边，因此可以快速收敛到局部最优解。

## 三、复杂度分析
Kruskal算法的时间复杂度是$O(E\log E)$，其中E是图的边数目。主要是在找边的时候，要排序所有的边，这个时间复杂度是$O(E\log E)$。而合并集合的操作是常量时间的，因此Kruskal算法的时间复杂度还是很稳定的。空间复杂度是$O(N)$，其中N是节点数目，这是因为算法需要维护一些信息。

# 2.核心概念与联系
## 一、最小生成树
### 1. 概念
最小生成树是指连接所有结点的权最小的树。设G=(V,E)是一个连通无向图，其权函数w:E->R，称为边权。若T∈MST(G)，则称T为G的最小生成树。

最小生成树的生成树具有如下性质：

1. 任意两点间至少有一条路径相连；
2. 最小生成树的代价是树中的所有边的权重的总和，即树上的边的权值之和。

特别地，对于连通图G，不存在具有相同边数的最小生成树。

### 2. 生成树
设G=(V,E)是一个带权连通无向图，T∈MST(G)是一个最小生成树。则称T为G的生成树。

显然，给定一个最小生成树T，如果对T上某个顶点u，增加一条新边(u,v)，使得该边的权值不小于任何从u可达顶点v的权值，并且仍然有路径连接u和v，则称为生成树。

例如，如果在图G=(V,E)上增加一条边(u,v)，使得w(uv)<min\{w(e): e∈E\{uv\}\},则称G的最小生成树仍然是生成树。换句话说，只要一条新边可以比其他所有边更轻松地连接两个结点，就可以把它加进去。