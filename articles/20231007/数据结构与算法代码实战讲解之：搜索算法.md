
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 概述
对于一个经典的数据结构——数组或者链表，进行查找、插入或删除操作通常都需要从头到尾遍历整个结构才能找到对应的数据或元素，而时间复杂度为O(n)的操作就会极大地影响程序的运行效率。因此，如何有效地在这些数据结构中快速定位元素、寻找最小值、最大值等一系列搜索操作，成为计算机科学领域中的一项基本技能。搜索算法就是用来解决这一类问题的算法。

## 分类及应用场景
### 顺序搜索算法
顺序搜索（也称线性搜索、直接搜索）算法是在不允许重复元素的情况下，通过一次比较和顺序移动的方式找到某一特定元素。这种算法最简单，但效率较低。其基本思想是依次访问每个存储单元直到找到目标元素或者发现不存在这样的元素为止。其时间复杂度为O(n)，即需要扫描整个数组一次。如下图所示：

例如：给定一个升序序列{3,5,7,9}，要查找数字5对应的下标，就可以采用顺序搜索算法。

```c++
int binarySearch(vector<int>& nums, int target){
    for(int i = 0; i < nums.size(); ++i){
        if(nums[i] == target)
            return i; //返回索引
    }
    return -1;    //没找到返回-1
}
```

### 有序表查找算法
有序表查找算法即利用已排序好的数组或链表，在logarithmic时间内找到某一特定元素。一般来说，有序表查找算法又分为两种：折半查找和二分查找。
#### 折半查找
折半查找法的基本思想是将待查表划分成两个子表，其中第1个子表包含元素值小于等于查找值的元素，第2个子表包含元素值大于查找值的元素。对比第1个子表和查找值大小，决定是否进入第2个子表继续查找，直到找到或确定该元素不存在。其时间复杂度为O(log n)。

例如：给定一个升序序列{3,5,7,9},要查找数字5对应的下标，可以使用折半查找算法。

```c++
int binarySearch(vector<int>& nums, int target){
    int left = 0, right = nums.size() - 1;
    while(left <= right){
        int mid = (left + right) / 2;   //取中间值
        if(target == nums[mid]){
            return mid;
        }else if(target > nums[mid]){
            left = mid + 1;      //搜索右侧区间
        }else{
            right = mid - 1;     //搜索左侧区间
        }
    }
    return -1;        //没找到返回-1
}
```

#### 二分查找
二分查找是一种折半查找算法的优化版本，它对折半查找的右边界进行了改进。主要原因是因为如果待查表的长度为偶数，则折半查找的右边界必然是列表长度减一；但是如果待查表的长度为奇数，则折半查找的右边界恰好是列表长度除以2，导致无法保证在正常情况下仍能找到目标元素。所以，为了保证在所有情况下都能找到目标元素，改进后的二分查找法设置了更严格的条件，必须使得折半查找的右边界至少比实际存在的最大元素还要大1，此时才有可能命中目标元素。其时间复杂度为O(log n)。

例如：给定一个升序序列{3,5,7,9}，要查找数字7对应的下标，可以使用二分查找算法。

```c++
int binarySearch(vector<int>& nums, int target){
    int left = 0, right = nums.size()-1;
    
    while(left <= right){
        int mid = left + (right - left) / 2;
        if(target == nums[mid])
            return mid;
        else if(target < nums[mid])
            right = mid - 1;
        else
            left = mid + 1;
    }

    return -1;        //没找到返回-1
}
```