
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 概述

在算法领域中，回文字符串（Palindrome string）是指从左往右读和从右往左读都是一样的字符序列。例如："racecar"，"civic", "deified", "noon", "redivider". 在一般意义上来说，回文串是一个很好的工具来对字符串进行分类、检索和排序。

很多编程语言都提供了一些基本的数据结构和算法来帮助处理回文串的问题，如字符串反转、回文检查等，但是这些算法通常并不是很高效或者直接可用。因此本文将主要介绍一种基于回文子串的最长公共子序列(Longest Common Subsequence)的算法，这种算法能够有效地解决回文串的问题，而且它的时间复杂度是线性的。

本文首先会介绍回文子串的定义和特征，然后介绍一下最长公共子序列(LCS)的定义和特征。之后详细阐述了如何用动态规划求解LCS的问题，最后给出了几种优化的方法。最后再总结一下该算法的时间和空间复杂度。

## 回文子串
一个字符串s[0..n-1]如果从左往右读和从右往左读都是一样的字符序列，那么称这个字符串s是一个回文串。例如："racecar", "civic", "deified", "noon", "redivider"都是回文串，但"hello"不是。

对于任意长度为$n$的字符串s，都可以找到最短的回文串t[0..m-1],其中m<=n。只需判断t是否为s的回文串即可。如果存在这样的回文串，则称t为s的一个回文子串。

记回文串t[0..m-1]的首尾指针分别为i,j,其对应于字符串s的起始位置为si+1,sj+1,尾指针即为从j到i的一个回文串。比如："abcdba"的回文子串为"bcdb",首尾指针分别为4,0,尾指针为0到4对应的回文串就是"bcdbc"。

假设字符串s和t的长度分别为$n$, $m$，则根据回文串的定义，其最大回文串的长度至多为$min\{n,m\}$。而通过枚举回文串的起始位置，就可以找出所有可能的回文串。对于长度为$k$的回文串，其对应的回文子串长度为$l=\frac{k}{2}$,其中$l$为奇数或偶数均可。因此，当$k=2n+1$时, 所对应的回文子串就恰好为$t$。在实现的时候，可以将所有可能的回文子串存入一个哈希表中，以便快速查找。

## LCS的定义
两个序列X和Y之间的最长公共子序列(LCS),记作$LCS(X, Y)$, 是指X和Y两条序列的最长的匹配子序列，使得该匹配子序列恰好由相同的元素组成，并且该匹配子序列是所有匹配子序列中最长的。

对于两个字符串s[0..n-1]和t[0..m-1]，它们的LCS可以表示为如下二维数组C:

$$ C = \begin{pmatrix}
   & a_0 \\
   b_0 & c_0 & c_1 \\
   b_1 & c_2 & c_3 & d_0\\
   b_2 & c_4 & c_5 & d_1 & e_0\\
   \vdots && \vdots && \vdots && \ddots\\
   b_{m-1} & c_{2m-2} & c_{2m-1} & d_{m/2} & e_{m/2} & f_0\\
  \end{pmatrix}, $$
  
其中a_0,b_0,c_0,d_0,e_0,f_0代表空字符串，标注每个元素对应的字符。

由于C是个矩阵，每行和每列都是一个子序列，因此C[i][j]的值表示的是$s_i$和$t_j$之间的LCS的长度。例如，C[3][1]的值是b_1和c_2之间的LCS的长度。注意这里使用下标，而不是元素，因此最前面的那些元素对应的字符已经被省略掉了。

为了更清晰地展示LCS的内容，可以将上面的矩阵还原为如下形式：

$$ \left(\begin{matrix}\color{blue}{\text{"ab"}}&\color{red}{\text{"ab"}}&\color{red}{\text{"ac"}}\\\color{red}{\text{"bd"}}&\color{blue}{\text{"cd"}}&\color{green}{\text{"bc"}}\\\color{red}{\text{"be"}}&\color{red}{\text{"cf"}}&\color{purple}{\text{"ce"}}&\color{orange}{\text{"ed"}}\end{matrix}\right) $$

其中，每条竖线上的文字代表一个字符，蓝色代表不属于LCS的一部分，红色代表属于LCS的一部分，绿色代表匹配的一部分。

可以看到，左上角的文字"ab"既不属于LCS的一部分也不属于匹配的一部分，因此这三个元素的LCS的长度为0；右上角的文字"cd"既不属于LCS的一部分也不属于匹配的一部分，因此这三个元素的LCS的长度为0；右下角的文字"ce"属于LCS的一部分且与匹配的一部分"cd"相邻，因此这四个元素的LCS的长度为1。

因此，LCS的定义其实就是一个二维矩阵中的元素，它的值等于s[i]和t[j]是否匹配，同时又等于C[i-1][j-1]+1或max(C[i-1][j],C[i][j-1])。 

## 动态规划求解LCS的问题
### 基本思路
1. 将X和Y看做由0~n-1和0~m-1这两个索引值所标识的元素序列，分别对应于s和t。
2. 根据s[i]和t[j]的匹配关系来填充矩阵C。
    - 如果s[i]=t[j], 则LCS的长度等于前面一行的LCS长度加1,也就是C[i-1][j-1]+1。
    - 如果s[i]!=t[j], 则LCS的长度等于较小的那个前缀的LCS长度,也就是max(C[i-1][j],C[i][j-1]).

3. 从矩阵C中寻找LCS的元素，也就是C[n-1][m-1]中的元素。把这些元素依次连接起来，就得到了s和t的LCS。

### 优化方式
1. 使用滚动数组来优化空间复杂度。

   在计算C[i][j]时，需要用到之前的计算结果，所以可以使用滚动数组的方式来减少内存消耗。即用数组V保存C[i][j]的值，C[i][j]的值等于C[i][j-1]或C[i-1][j]，V[i][j]等于C[i-1][j-1]或V[i-1][j]。当需要用到V[i-1][j-1]时，可以先将它赋值给C[i][j]，从而节约计算资源。

2. 使用记忆化搜索优化递归调用。

   当计算C[i][j]时，如果已经计算过C[i-1][j]或C[i][j-1]的值，可以直接返回，从而避免重复计算。

## 复杂度分析
* 时间复杂度：

  LCS的时间复杂度是O(nm)，因为对于所有的i,j，我们都需要计算一次LCS的长度。

  矩阵的填充过程，时间复杂度也是O(nm)。

  矩阵的填充过程可以分为三步，第一步初始化数组C，第二步填充矩阵C，第三步从矩阵C中找到LCS。对于第一步和第三步，时间复杂度都为O(nm)，因此总的时间复杂度为O(nm)。

  记忆化搜索的优化，可以提升性能。如果缓存中已经存在某个子问题的答案，那么就不需要重新计算它，而是直接返回这个答案。因此，当某个子问题的答案已经计算出来，后续遇到相同的子问题时，可以直接返回答案，从而节约计算资源。

* 空间复杂度：

  LCS的空间复杂度是O(nm)，我们需要创建矩阵C来保存LCS的长度。

  滚动数组的空间复杂度为O(nm)。

  备忘录的空间复杂度为O(mn)。