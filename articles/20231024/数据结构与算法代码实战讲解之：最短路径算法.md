
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 1.1 图论简介
图（Graph）是一种数据结构，它用来描述各种各样复杂系统中物体、活动和关系之间的互相联系。在生活中，比如网络结构、交通网络、地图等都可以用图来表示。图的表示方法有很多种，包括邻接矩阵、邻接表、边集数组等。
## 1.2 最短路径算法
最短路径问题是指一个节点从源点到目的点所经过的最少的路径长度。最短路径问题通常使用贪婪或动态规划的方法求解。贪婪算法通过维护一个单调递增的优先队列进行搜索，而动态规划则要求利用矩阵乘法来解决问题。
### 1.2.1 Dijkstra算法
Dijkstra算法是最著名的最短路径算法之一，也是广泛运用的一个算法。它的主要思想是每次选取一条当前已经到达最小距离的边，将它加入到已知路径中，并更新该节点到其余所有节点的距离。直至所有的顶点都添加到已知路径中，或者没有新的边可以添加。
### 1.2.2 A*算法
A*算法是在Dijkstra算法的基础上引入启发函数，使其更准确地估计了整条路径的长度。启发函数是一个函数h(n)用于评估从起始点到顶点n的实际距离，其中n是当前顶点，h(n)=g(n)+h'(n)。其中g(n)是从起始点到顶点n的实际距离；h'(n)是估计从顶点n到终止点的实际距离，这个值由启发函数计算得出。一般来说，启发函数可以采用曼哈顿距离或欧几里得距离，但也可根据需要自行设计。A*算法具有比较好的时间复杂度，并且可以使用多线程加速运算。
### 1.2.3 Bellman-Ford算法
Bellman-Ford算法是一种比Dijkstra算法更快的最短路径算法。它对负权圈进行优化，可以检测出存在负权回路，但不能处理加权图。其基本思想是每一步迭代时，对每条边进行松弛（relax），直至不再发生变化。如果在某一步某个顶点的最短路径被松弛超过一次，则存在负权回路。
# 2.核心概念与联系
## 2.1 图的定义及性质
图G=(V,E)，其中V表示图中的顶点集合，E表示图中的边集合，两顶点之间如果存在一条边，就称它们相邻。图的一些重要性质包括：
- 有向图：如果存在一条边a->b，则b->a就不存在，即方向不同。有向图可以用来表示带方向的信息流。
- 无向图：如果不存在一条边a->b，则b->a也不存在。无向图可以用来表示同性质的信息流，例如，黑白染色问题，初始时，所有顶点均不染色，那么染成黑色或白色的顺序将不会影响结果。
- 简单图：无向图或无圈图，即不含有重复边。
- 完全图：对于任意两个顶点u,v，图中存在一条边连接u和v。
- 没有自环：图中不存在边连接顶点自身。
- 没有平行边：无向图中不存在两条相同的边。
- 稠密图：图中存在多条边。
- 网：有向图或无向图。
## 2.2 迹和路径
迹（tour）是一种旅行方式，它指的是从一个顶点开始走到另一个顶点，再从另一个顶点返回，最后再次回到第一个顶点的旅行路线。路径（path）是一系列的连续的边，代表着从一个顶点到另一个顶点的途径。
## 2.3 最短路径问题
最短路径问题（Shortest Path Problem）是指一个节点从源点到目的点所经过的最少的路径长度。最短路径问题可以分为两类：
- 单源最短路径问题：在一个图中找到从给定源点到所有其他点的最短路径。
- 全源最短路径问题：在一个图中找到从每个顶点到其他所有顶点的最短路径。
## 2.4 最短路径树
最短路径树（Shortest Path Tree）是指构造出的一个子图，该子图包含所有顶点，边的数目和权重之和最小。它是找出所有最短路径的一个有效的方法。
## 2.5 代价
代价（cost）是指到达某一顶点所需的时间或费用，也可表示为c(u,v)，表示从顶点u到顶点v的权值。
# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 3.1 单源最短路径问题
### 3.1.1 Bellman-Ford算法
Bellman-Ford算法是一个线性运行时间的算法，用来计算单源最短路径的问题。
算法思想：
1. 对每条边(u,v), 假设d[v]=INF (u<v)，对所有的v−>u, d[v] = c[u]+d[u]。
2. 在k=2...|V|-1,对每条边(u,v), 如果d[u]>d[v]+c[u], d[v]=d[u]-d[v]+c[u]。
3. 当k=|V|-1, 检查是否存在u,v使得d[u]>d[v]+c[u]。若存在，则有负权回路。否则，d[u]即为最短距离。

算法实现：
```cpp
void bellman_ford(int s){
    // 初始化最短距离为最大值
    for(int i=0;i<n;i++)
        dis[s][i]=MAX_INT;
    // 第一轮初始化，最大步数为顶点数减一
    for(int k=1;k<=n-1;k++){
        bool updateflag=false;   // 更新标记
        for(int i=0;i<n;i++){
            if(dis[s][i]==MAX_INT ||!flag[i]){continue;}// 不处理非法顶点，或本轮无更新
            int tmp=dis[s][i];    // 保存中间值
            for(Edge e : edges[i]){
                if(!flag[e.to]) continue;    // 不考虑无效顶点
                if(tmp+e.val < dis[s][e.to]){
                    dis[s][e.to]=tmp+e.val;  // 更新
                    parent[e.to].clear();      // 清空父节点
                    parent[e.to].push_back(i); // 设置父节点
                    flag[e.to]=true;           // 置有效
                    updateflag=true;          // 标记更新
                }else if(tmp+e.val==dis[s][e.to]){
                    parent[e.to].push_back(i); // 添加父节点
                }
            }
        }
        if(!updateflag) break;              // 若无更新，则提前结束
    }
    // 检查是否存在负权回路
    for(int i=0;i<n;i++){
        if(dis[s][i]<MAX_INT && check(s,i)) return false;// 查看节点s到i是否有负权回路
    }
    return true;
}

bool check(int u,int v){
    vector<int> path{v};       // 从v开始，记录路径上的点
    while(parent[v][0]!=u){
        v=parent[v][0];        // 从上个父节点转移到v
        path.push_back(v);     // 添加到路径
    }
    reverse(path.begin(),path.end());// 反序输出路径上的点
    cout<<"Negative weight cycle: ";
    printPath(path);             // 输出路径
    return true;                 // 有负权回路
}

void printPath(vector<int>& p){
    for(int x : p){cout<<x<<" ";}
    cout<<endl;
}
```
注：此处check函数调用printPath函数打印路径。

### 3.1.2 Dijkstra算法
Dijkstra算法是基于贪心策略的最短路径算法。算法思路如下：
1. 将源点s的距离设置为0，其他顶点的距离设置为无穷大。
2. 创建一个优先队列，按距离s到其他所有顶点的距离进行排序。
3. 从优先队列中依次取出距离最小的顶点u，然后更新所有以u为中间节点的路径的长度。
4. 如果有新顶点加入到优先队列，那么将其距离设置为之前距离到u的距离加上u到新顶点的距离。
5. 重复步骤3~4，直到优先队列为空。
6. 返回每个顶点的最短距离。

算法实现：
```cpp
void dijkstra(int s){
    priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;  // 优先队列
    fill(dist,dist+n,inf);                    // 初始化距离为正无穷
    dist[s]=0;                                 // 设置源点距离为0
    pq.emplace(0,s);                           // 入队
    while(!pq.empty()){                         // 优先队列非空
        auto [du,u]=pq.top();                  // 取出距离最小的顶点
        pq.pop();                              // 出队
        if(visited[u]) continue;               // 若已访问过，跳过
        visited[u]=true;                       // 标记为已访问
        for(auto [v,w]:adj[u]){                 // 遍历u的所有邻居，更新距离
            if(dist[u]+w<dist[v]){              // 如果更新后更小，则入队
                dist[v]=dist[u]+w;
                pq.emplace(dist[v],v);         // 更新父节点
                parent[v]=u;                   // 更新父节点
            }
        }
    }
}
```
注：此处dist数组初始化为正无穷，而其他算法都是初始化为正无穷大。dist[s]=-1，因为这是对dijkstra的扩展，并非原生的单源最短路径算法。

### 3.1.3 Floyd算法
Floyd算法是一种基于矩阵乘法的最短路径算法。算法思路如下：
1. 建立n^3大小的矩阵D，其中D_{ij}=0，i=j。
2. 对每一对顶点i,j，判断D_{ij}是否等于顶点i到j的最短路径。
3. 根据矩阵的三角性质，可以只用3次循环完成矩阵的填充。
4. 返回矩阵D。

算法实现：
```cpp
void floyd(){
    for(int k=0;k<n;k++){
        for(int i=0;i<n;i++){
            if(edges[i].size()==0||!flag[i]) continue;  // 没有边 或 无效顶点
            for(int j=0;j<n;j++){
                if(edges[j].size()==0||!flag[j]) continue;  // 没有边 或 无效顶点
                int val=min(D[i][j],D[i][k]+D[k][j]);    // 判断三角形的值
                if(D[i][j]>val){                          // 更新
                    D[i][j]=val;
                    parent[i][j]=parent[k][j];            // 父节点也要更新
                }
            }
        }
    }
}
```
注：此处D[i][j]表示从顶点i到顶点j的最短路径，parent[i][j]表示顶点i到顶点j的父节点。

### 3.1.4 A*算法
A*算法是一种启发式算法，基于堆的数据结构。算法思路如下：
1. 创建初始列表L，并把源点s放进去。
2. 对列表L中的每个顶点p：
   a. 如果p是终点，返回经过p的所有顶点组成的路径。
   b. 对p的每个邻居q，计算新路径的长度f=g(p)+w(p,q)。如果f小于q的估计距离，则更新估计距离h(q)=(dst(q)-src(q))+h’(q)，并插入q进列表L。
3. 直到列表L为空。

算法实现：
```cpp
vector<int> astar(int src,int dst){
    vector<int> ret;                     // 存储路径
    unordered_set<int> vis;              // 已访问集合
    vis.insert(src);                      // 标记为已访问
    queue<pair<int,int>> que;            // 优先队列
    pair<int,int> tmp={0,src};            // 起点，估计值
    que.push(tmp);                        // 入队
    while(!que.empty()){                  // 队列非空
        auto [co,cur]=que.front();        // 取出
        que.pop();                         // 删除
        if(cur==dst) {                     // 到达目标
            ret.push_back(dst);           // 添加目标节点
            while(parant[ret.back()]!=-1){// 回溯父节点
                ret.push_back(parent[ret.back()]);
            }
            reverse(ret.begin(),ret.end());// 反序输出
            return ret;                   // 返回路径
        }
        for(auto edge:adj[cur]){           // 当前节点的所有邻居
            if(vis.count(edge.to)==0){      // 未访问过
                int newCo=co+(co>0?1:0)+edge.weight;    // 计算总距离
                if(!vis.count(edge.to)||newCo<dist[edge.to]){   // 更新
                    dist[edge.to]=newCo;                             // 更新距离
                    parnet[edge.to]=cur;                            // 更新父节点
                    hValue[edge.to]=heuristic(edge.to);                // 计算估计值
                    que.push({-(newCo+hValue[edge.to]),edge.to});    // 入队
                    vis.insert(edge.to);                               // 标记已访问
                }
            }
        }
    }
}
```
注：此处co是当前节点到源点的估计距离，dst是终点节点，heuristic函数是启发函数。

## 3.2 全源最短路径问题
### 3.2.1 Johnson算法
Johnson算法是一种基于Bellman-Ford和Dijkstra的全源最短路径算法。算法思路如下：
1. 通过Bellman-Ford算法求出图中所有顶点间的最短距离。如果有负权回路，则返回错误结果。
2. 把源点s加入到原图中，添加一个虚拟源点vs，其到所有其他顶点的距离设置为0，然后开始执行Dijkstra算法，获得源点s到所有其他顶点的距离。
3. 返回源点s到所有顶点的距离。

算法实现：
```cpp
void johnson(){
    int n=graph.size();

    // 建立带虚拟源点的图
    graph.resize(n+1);
    adj.resize(n+1);
    dist.resize(n+1);
    parent.resize(n+1);
    hValue.resize(n+1);
    memset(dist,-1,sizeof(dist));
    
    // 把源点s加入到原图中
    for(int i=0;i<n;i++){
        graph[i].resize(n+1);
        graph[i][n].first=graph[i][n].second=0;
        graph[i][n].third=true;
        dist[n]=0;
        for(auto& it:graph[i]){
            adj[it.from].push_back({{n},it.second,{i}});
        }
    }
    // 添加虚拟源点
    dist[n]=0;
    source.push_back({{n},0,{n}});
    target.push_back({{n},{n},0});

    // 执行Bellman-Ford算法，求出所有顶点间的最短距离
    bool negativeCycle=bellman_ford(n);
    if(negativeCycle) printf("ERROR\n");

    // 恢复原图
    graph.resize(n);
    adj.resize(n);
    dist.resize(n);
    parent.resize(n);
    hValue.resize(n);

    // 执行Dijkstra算法，求出源点s到所有其他顶点的距离
    dijkstra(n);

    // 恢复父节点信息
    for(int i=0;i<n;i++){
        for(auto& it:adj[i]){
            int to=it.to;
            it.to--;
            it.from--;
        }
        swap(source[i].from,target[i].to);
        swap(source[i].to,target[i].from);
    }
    swap(dist[n],dist[n-1]);
    swap(parent[n],parent[n-1]);
}
```
注：此处graph[i]表示原图中的第i个顶点，source[i]表示从虚拟源点到i的路径，target[i]表示从i到虚拟源点的路径。

### 3.2.2 Floyd-Warshall算法
Floyd-Warshall算法是一种基于矩阵乘法的全源最短路径算法。算法思路如下：
1. 建立n^3大小的矩阵D，其中D_{ij}=c_{ij}，即边权重为距离。
2. 对任意两点i,j，判断D_{ij}>D_{ik}+D_{kj}，如果是，则更新D_{ij}。
3. 返回矩阵D。

算法实现：
```cpp
void fw() {
    const int INF = numeric_limits<int>::max() / 2;   // 用二进制反码表示正无穷大
    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            if (!flag[i]) continue;
            for (int j = 0; j < n; ++j) {
                if (!flag[j]) continue;
                int w = min(D[i][j], D[i][k] + D[k][j]);
                if (D[i][j] > w) {
                    D[i][j] = w;
                    parent[i][j] = k;
                }
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        if (!flag[i]) continue;
        for (int j = 0; j < n; ++j) {
            if (!flag[j]) continue;
            if (D[i][j] == INF) {
                cout << "Not connected" << endl;
                return ;
            }
        }
    }
}
```