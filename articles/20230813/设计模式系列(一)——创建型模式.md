
作者：禅与计算机程序设计艺术                    

# 1.简介
  

创建型模式（Creational Patterns）用于在创建对象的同时隐藏对象创建的复杂性，并允许对象按照特定的方式来创建。这种类型的设计模式主要关注如何将对象组织到一起，属于**对象创建型模式**。创建型模式涉及到了以下一些模式：

 - **单例模式**：保证一个类仅有一个实例，并提供一个访问它的全局点。
 - **抽象工厂模式**：提供一个接口，用来创建相关或依赖对象的家族，而无需指定它们具体类的那些类。
 - **工厂方法模式**：定义一个用于创建对象的接口，让子类决定哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。
 - **建造者模式**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的 representations 。
 - **原型模式**：用一个已经创建的实例作为原型，通过复制这个原型对象来创建一个新的对象。
 
本文将对这些模式进行详细阐述，并结合实例代码、实例分析等形式，帮助读者更好地理解并掌握他们的概念。

 

# 2.单例模式
## 2.1 目的
保证一个类仅有一个实例，并提供一个访问它的全局点。即一个类只能生成唯一的一个对象，且该对象必须可以通过类名直接调用。

## 2.2 例子
比如，在整个应用程序中只需要配置一次日志文件路径和用户名密码，那么我们就可以使用单例模式，把用户信息做成一个单例类。

## 2.3 UML类图

## 2.4 代码实现
```java
public class Singleton {
    private static final Singleton instance = new Singleton();
    
    // 构造函数私有化，避免外部创建对象
    private Singleton() {}
    
    public static Singleton getInstance() {
        return instance;
    }
    
    // 方法示例
    public void printMessage() {
        System.out.println("This is a single message.");
    }
}

// 测试用例
public class Client {
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        singleton.printMessage();
        
        // 创建第二个对象时，会抛出异常，因为该对象已被创建过
        try {
            Singleton secondSingleton = new Singleton();
            secondSingleton.printMessage();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 2.5 优缺点
 ### 优点

1. 在系统内存中只有一个对象，减少了内存开销，尤其是在频繁的创建和销毁对象时，可以提高性能；
2. 可以全局访问，共享数据时可以方便；
3. 避免由于资源竞争带来的复杂性，解决了对象多重实例的问题；
4. 有利于设计松耦合的系统结构。

 ### 缺点

1. 单例模式一般没有接口，扩展比较困难；
2. 没有抽象层，如果要改动内部逻辑，则影响范围很大；
3. 单例模式违反了依赖倒置原则，应该为客户提供静态的或动态的实例，而不是创建实例；
4. 当想实例化一个对象的时候，需要先获取锁定，降低效率。