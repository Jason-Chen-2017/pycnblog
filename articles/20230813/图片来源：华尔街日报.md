
作者：禅与计算机程序设计艺术                    

# 1.简介
  

# 华尔街日报是美国的主要财经新闻媒体。其创办者Dorsey曾担任福布斯中国榜上的第7名。从20世纪初到2008年底，华尔街日报共刊登了超过2.4万篇新闻文章、24部电视节目以及150余份有关股票市场的分析文章。截至目前，它是美国第二大的财经媒体。

# 本文从中枢分析、波动率判断、随机漫步、分形计算等几个方面对华尔街日报最新发布的研报进行分析。

# 2.背景介绍
# 中枢分析（Chaikin Oscillator）是一个成熟的技术指标，应用于股票价格的研判、预测市场走势，具有极高的实用价值。但是在过去的几十年里，由于市场的复杂性、情绪因素的影响，中枢分析方法在某些方面的效果不佳。随着机器学习、数据挖掘、统计学和金融学的不断发展，一些新的技术被开发出来。这些技术将新的领域引入到中枢分析的方法中。其中一个最有影响力的是基于支持向量机（Support Vector Machine，SVM）的中枢识别技术。该技术通过训练模型将不同时期的价格序列分开，从而提取出长期中枢的特征。

# 求解SVM中的超平面问题的优化算法称为“支撑向量机分类器”（Support Vector Classifier）。支撑向量机可以用来处理线性不可分的问题，是一种监督学习的模型。它的特点就是能够自动找到合适的超平面，使得样本数据集的最大间隔和最小化误差两个目标同时达到。

# 在实践过程中，许多研究人员发现，中枢分析方法并不能真正准确地捕获整体趋势，因此研究者们又提出了一个更强大的分析工具——波动率判断法（Bollinger Bands）。该方法通过估计价格的均值和标准差，判断股票的波动范围是否有所变化。波动率判断法与中枢分析方法结合起来，可以帮助投资者更加准确地预测股票价格的走势。

# 在过去的十年里，许多成功的公司都采用了“随机漫步”（Random Walk）作为策略的主要方法。“随机漫步”的核心思想就是假定股票的运动是随机的，只要股票当前价格出现小幅的变化，就可以根据一定规则做出交易决策。这种方法已经被证明很有效，它可以帮助企业根据未来股票走势做出反应，从而在短期内制造买卖机会。

# 同样，分形计算（Fractal Geometry）也成为众多投资者追求的技术。分形计算是利用数据模型的自然循环特性，找寻数据的生物特性。根据数据波动的规律，分形计算可以揭示出非线性分布的数据模式，并给出相应的建模和分析方法。

# 通过上述几种分析技术，华尔街日报股票市场的分析工作才能进一步完善、科学化。

# 3.基本概念术语说明
1．中枢分析：
中枢分析（Chaikin Oscillator）是一种股市分析技术，用于识别股价走势中的趋势和持续的区域。它是由华尔街日报创始人Dorsey先生发明的。它通过计算每天股价在短期和长期均值的差距，来判断市场的趋势方向及持续性。

2．波动率判断法：
波动率判断法（Bollinger Bands）是一个技术指标，由华尔街日报创始人Dorsey先生发明。它通过计算股价的移动平均线、标准差以及收盘价上方和下方两条标准差区间的宽度来判断股价的变动状况。当股价处于上方标准差区间时，表示股价在上涨趋势；当股价处于下方标准差区间时，表示股价在下跌趋势。

3．随机漫步：
随机漫步（Random Walk）是一种股市交易策略。它认为，股价的走势可以被看作是一种对冲基金的回报。如果股价的平均收益率呈现出放松趋势，那么即使是在牛市中亏钱的概率也是很低的。因此，采用随机漫步策略往往能赚更多钱。

4．分形计算：
分形计算（Fractal Geometry）是利用数据模型的自然循环特性，找寻数据的生物特性。它的优点是可以帮企业发现数据中的规律，从而给出解决问题、改善业务策略提供依据。分形计算可以用来揭示股价曲线的循环节，并且发现股价的拐点、谷顶、峰值、交叉状态以及其他相关信息。

5．支持向量机（SVM）：
支持向量机（SVM）是一种监督学习的模型。它通过训练模型将不同时期的价格序列分开，从而提取出长期中枢的特征。SVM可以用来训练和分类多个不同的股票数据。

6．支撑向量机分类器：
支撑向量机分类器（Support Vector Classifier）是求解SVM中的超平面问题的优化算法。它通过训练模型将不同时期的价格序列分开，从而提取出长期中枢的特征。支撑向量机分类器可以处理线性不可分的问题，是一种监督学习的模型。

# 4.核心算法原理和具体操作步骤以及数学公式讲解
# （1）SVM模型的构建
SVM模型的构建是一个关键步骤。首先需要构造训练数据集，这个训练数据集应该包含很多不同类型股票的价格序列。然后按照以下公式计算出核函数的值：

K(x, y) = <x, y> + c

这里，<x, y>表示内积；c是一个参数，它是关于超平面的惩罚项。

接着，利用拉格朗日对偶性，求解最优化问题，得到最优超平面。对于任何输入x，通过超平面得到对应的输出y，当且仅当存在一个满足约束条件的样本点对，使得K(x_i, x_j) >= 1或K(x_i, x_j) <= -1，其中i和j分别对应于任意两个不同样本点。因此，SVM算法可以看作是非线性分类器的集合的二阶范式。

# （2）SVM的决策边界
SVM模型能够对给定的输入数据进行预测，但预测结果只能告诉我们输入属于哪个类别，无法给出具体的数值。为了便于理解，我们可以通过决策边界（decision boundary）这一直观的概念来理解SVM算法预测的结果。

决策边界是由最优超平面决定的。一条直线或其他曲线通过所有样本点，并且离开超平面的距离都是固定的。例如，在图2-2中，一条直线作为决策边界，其左侧为类别1（红色圆圈），右侧为类别2（蓝色方块）。


另一种直观的理解方式是把SVM看作一个在空间中的超曲面，超曲面的中心是超平面的交点。换句话说，SVM试图找到一个平面，使得不同类的样本点之间的距离和难度都尽可能小。这样，在一个样本点周围，其他点越靠近则预测结果越准确。

# （3）支撑向量机分类器
支撑向量机分类器（Support Vector Classifier，SVC）是一种优化的SVM分类器。其特点是可以获得最大的间隔，也就是在两类样本点间取得最大的距离。换句话说，支撑向量机分类器寻找的超平面要远离分类边界，因此可以最大程度地提高分类精度。

为了找寻这个超平面，首先需要定义优化目标，目标函数通常是关于违背核函数的两个数据点的距离之和，或者是分类误差的和。

接着，利用拉格朗日对偶性，求解最优化问题，得到最优超平面。最优超平面使得目标函数达到全局最优，它是一个凸函数，因此可以使用梯度下降法进行优化。

最后，就可以用训练好的模型对测试数据进行预测，并评估性能。

# （4）中枢识别
中枢识别是基于SVM的一种技术。它通过训练模型来识别长期股价中枢。中枢识别方法的主要思路是，每隔一段时间收集一段代表性的历史数据，然后对这段数据进行训练，得到一个SVM模型。然后利用这段数据训练出来的模型预测出下一段数据的中枢位置。

在确定中枢之前，需要对股票价格进行归一化处理，否则容易导致预测精度较低。另外，还可以加入其他的技术指标来辅助中枢识别。例如，波动率判断法可以衡量股票价格的变动范围；随机漫步策略可以判断股票趋势的走向；分形计算可以发现股价的循环节等。

# （5）波动率判断法
波动率判断法（Bollinger Bands）是一种用于判断股票价格变动情况的技术。它的基本思路是计算股票价格的移动平均线、标准差以及收盘价上方和下方两条标准差区间的宽度。

在股价的上方标准差区间里，表示股价在上涨趋势；在下方标准差区间里，表示股价在下跌趋势。一般来说，股价的波动范围要比中枢的变动范围大得多。

# （6）随机漫步策略
随机漫步（Random Walk）是一种股市交易策略。它认为，股价的走势可以被看作是一种对冲基金的回报。如果股价的平均收益率呈现出放松趋势，那么即使是在牛市中亏钱的概率也是很低的。因此，采用随机漫步策略往往能赚更多钱。

股价走势可以被抽象为一系列的买卖信号。在随机漫步策略中，我们可以假设股价的每一次变化都伴随着一个均匀概率的涨跌，因此每一个股票价格的变动都有一个固定的买卖信号。

# （7）分形计算
分形计算（Fractal Geometry）是利用数据模型的自然循环特性，找寻数据的生物特性。它的优点是可以帮企业发现数据中的规律，从而给出解决问题、改善业务策略提供依据。分形计算可以用来揭示股价曲线的循环节，并且发现股价的拐点、谷顶、峰值、交叉状态以及其他相关信息。

在计算分形特征之前，需要对原始数据进行归一化处理。然后，可以使用基于傅立叶变换的小波变换，也可以使用基于变换的维纳分析法，提取数据的主要周期性结构。

# 5.具体代码实例和解释说明
# （1）SVM模型的实现
SVM算法是一个线性分类器，其决策边界为一个超平面。因此，在实际项目中，我们通常不会直接套用SVM算法进行股票价格的预测。

在应用SVM算法进行股票价格预测之前，通常需要构造训练数据集。可以选择不同类型的股票，比如股票、债券、现金、外汇等。这些股票的价格序列通常具有不同的波动性和模式。为了避免模型过拟合，通常需要将数据进行划分，建立训练集和测试集。

# SVM模型的实现流程如下：

1. 导入相关库。

2. 对数据进行预处理。包括对数据进行标准化、归一化等操作。

3. 定义核函数。核函数是决定是否采用某个特定的基函数的一个重要因素。通常情况下，径向基函数（Radial basis function，RBF）函数是最常用的核函数。

4. 创建SVM对象。

5. 将训练数据分割为训练集和测试集。

6. 使用训练集训练SVM模型。

7. 使用测试集测试SVM模型的性能。

8. 保存模型。

```python
import pandas as pd
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.svm import SVC

# 数据加载
data = pd.read_csv('stock_price.csv', index_col=0)
X = data['Close'].values.reshape(-1,1)
y = data['Direction'].values

# 数据预处理
min_max_scaler = preprocessing.MinMaxScaler()
X_train = min_max_scaler.fit_transform(X[:int(len(X)*0.8)])
X_test = min_max_scaler.transform(X[int(len(X)*0.8):])

y_train = y[:int(len(y)*0.8)]
y_test = y[int(len(y)*0.8):]

# 建立SVM分类器
svc = SVC(kernel='rbf') # 指定径向基函数作为核函数
svc.fit(X_train, y_train) 

# 模型评估
print("模型准确率:",accuracy_score(svc.predict(X_test), y_test))

# 保存模型
joblib.dump(svc,'svc.pkl') 
```

# （2）支撑向量机分类器
支撑向量机分类器（Support Vector Classifier，SVC）是一种优化的SVM分类器。其特点是可以获得最大的间隔，也就是在两类样本点间取得最大的距离。

利用支撑向量机分类器的训练数据，可以对所有样本点进行分类。通过求解优化问题，找到一个使得目标函数达到全局最优的超平面。

在训练支撑向量机分类器之前，需要定义核函数。核函数可以用来控制数据之间的相似性。我们可以尝试不同的核函数，直到找到最合适的核函数。

```python
import numpy as np
from sklearn.datasets import make_blobs
from sklearn.model_selection import GridSearchCV
from sklearn.svm import SVC
from sklearn.externals import joblib

# 生成数据集
X, y = make_blobs(n_samples=100, centers=2, random_state=0, cluster_std=0.60)

# 定义搜索空间
param_grid = {'C': [0.1, 1, 10],
              'gamma': ['scale', 'auto']}

# 定义SVM分类器
svc = SVC()

# 使用网格搜索法寻找最优超参数
grid_search = GridSearchCV(estimator=svc, param_grid=param_grid, cv=5)
grid_search.fit(X, y)

# 选取最优超参数
best_params = grid_search.best_params_

# 建立SVM分类器
svc = SVC(C=best_params['C'], gamma=best_params['gamma'])
svc.fit(X, y)

# 模型评估
accuracy = svc.score(X, y)
print("模型准确率:", accuracy)

# 保存模型
joblib.dump(svc,'svc.pkl')
```

# （3）中枢识别
中枢识别是基于SVM的一种技术。它通过训练模型来识别长期股价中枢。中枢识别方法的主要思路是，每隔一段时间收集一段代表性的历史数据，然后对这段数据进行训练，得到一个SVM模型。然后利用这段数据训练出来的模型预测出下一段数据的中枢位置。

中枢识别的实现流程如下：

1. 导入相关库。

2. 从股票交易数据库中获取历史股票数据。

3. 对历史数据进行预处理，如标准化、归一化等。

4. 设置参数：设置窗口大小，即每隔多少天收集一段代表性的历史数据。

5. 初始化变量：创建一个空列表，用来存储训练集和测试集。

6. 遍历每一段代表性的历史数据：
    a. 将每一段历史数据划分为训练集和测试集。
    b. 根据训练集训练SVM模型，并将模型保存。
    c. 测试模型，并记录准确率。

7. 选择最好的模型。选择准确率最高的模型。

8. 用最好的模型预测下一段数据的中枢位置。

```python
import numpy as np
import matplotlib.pyplot as plt
from sklearn import svm, datasets
from sklearn.externals import joblib


class SupportVectorMachine:

    def __init__(self, window_size=20):
        self.window_size = window_size
    
    def prepare_dataset(self, dataset):
        X = []
        y = []
        
        for i in range(len(dataset)-self.window_size):
            X.append(dataset[i:i+self.window_size]['Close'].values)
            y.append(dataset[i+self.window_size]['Direction'])
            
        return np.array(X), np.array(y).flatten()
    
    def train_and_save_model(self, X_train, y_train):
        model = svm.SVC(kernel='linear', C=1.0)
        model.fit(X_train, y_train)
        
        joblib.dump(model, f'model_{str(len(models)+1)}.pkl')
        
    def predict_model(self, model, X_test):
        prediction = model.predict([X_test])[0]
        if prediction == "up":
            print("向上")
        elif prediction == "down":
            print("向下")
        else:
            print("震荡")
    
    def evaluate_performance(self, model, X_test, y_test):
        predictions = model.predict(X_test)
        accuracy = sum((predictions==y_test))/len(y_test)
        print("准确率:", accuracy*100,"%")
        
    
if __name__=="__main__":
    models = {}
    
    # 获取数据
    df = get_history_data("AAPL", start="2010-01-01", end="2020-12-31")
    print(df.tail())
    
    # 分割数据集
    splitter = int(len(df)*0.8)
    train_set = df[:splitter]
    test_set = df[splitter:]
    
    # 训练模型并保存
    clf = SupportVectorMachine()
    X_train, y_train = clf.prepare_dataset(train_set)
    clf.train_and_save_model(X_train, y_train)
    
    
    # 测试模型并评估性能
    best_model = max(models.items(), key=lambda item:item[1][1])[0]
    X_test, y_test = clf.prepare_dataset(test_set)
    clf.evaluate_performance(models[best_model]["model"], X_test[:,:-1], y_test[:-1])
    clf.predict_model(models[best_model]["model"], X_test[-1,:])
```

# （4）波动率判断法
波动率判断法（Bollinger Bands）是一种用于判断股票价格变动情况的技术。它的基本思路是计算股票价格的移动平均线、标准差以及收盘价上方和下方两条标准差区间的宽度。

在股价的上方标准差区间里，表示股价在上涨趋势；在下方标准差区间里，表示股价在下跌趋势。一般来说，股价的波动范围要比中枢的变动范围大得多。

```python
def bollinger_bands(prices, n=20, k=2):
    """
    :param prices: 股票收盘价序列
    :param n: 窗口大小
    :param k: 標準差倍數
    :return: 上方標準區間、中央標準區間、下方標準區間
    """
    rolling_mean = prices.rolling(n).mean().dropna()
    rolling_std = prices.rolling(n).std().dropna()
    
    upper_band = rolling_mean + k * rolling_std
    lower_band = rolling_mean - k * rolling_std
    
    return upper_band, rolling_mean, lower_band
```

# （5）随机漫步策略
随机漫步（Random Walk）是一种股市交易策略。它认为，股价的走势可以被看作是一种对冲基金的回报。如果股价的平均收益率呈现出放松趋势，那么即使是在牛市中亏钱的概率也是很低的。因此，采用随机漫步策略往往能赚更多钱。

股价走势可以被抽象为一系列的买卖信号。在随机漫步策略中，我们可以假设股价的每一次变化都伴随着一个均匀概率的涨跌，因此每一个股票价格的变动都有一个固定的买卖信号。

```python
import numpy as np

def simulate_random_walk():
    prices = np.zeros(20)   # 初始化股价序列
    direction = np.random.choice([-1, 1])   # 随机选择初始方向
    
    for t in range(20):
        change = np.random.normal(loc=direction, scale=0.1)    # 以正常分布生成随机漫步
        price = round(prices[t-1]*(1+change),2)     # 更新股价序列
        
        if (price > 100 and direction == -1) or (price < 0 and direction == 1):
            break    # 如果价格突破了上限或下限，停止交易

        prices[t] = price    # 记录最新价格

        if change > 0.01:      # 判断买入
            buy()
        elif change < -0.01:   # 判断卖出
            sell()

        direction *= -1       # 更改方向

simulate_random_walk()
```