
作者：禅与计算机程序设计艺术                    

# 1.简介
  

InnoDB存储引擎是一个高性能、高可用、支持事务的关系型数据库引擎。它的设计目标是处理大容量的读写请求，它最主要的特征就是它实现了四个标准的隔离级别，并通过并发控制和崩溃恢复机制保证数据的一致性。其内部采用的是聚集索引结构，因此数据按主键顺序存放，同时也提供了灵活的插入和压缩功能。

InnoDB存储引擎是MySQL中默认的支持事务的关系型数据库引擎，其数据结构由以下几个主要模块组成：

 - 共享内存结构
 - 缓冲池结构
 - 日志管理模块
 - 页管理模块

本章节将主要对InnoDB存储引擎的数据结构做一些阐述，其中包括如下方面：
 
 1. 数据结构的层级
 2. 数据结构的分类
 3. 文件结构
 4. 数据页结构
 5. 页的分裂与合并
 6. 插入操作
 7. 删除操作
 8. 更新操作
 9. 查询操作
 10. 辅助索引的结构
 
# 2. 数据结构的层级

InnoDB存储引擎的数据结构是按照一个树形结构来组织的，底层是B+树索引（用于快速定位记录），顶层则是系统表空间，用来保存重要信息如数据字典、事务日志等。下图展示了一个InnoDB存储引擎的数据结构的层级：


InnoDB存储引eng的存储结构可以分为4层，从上到下依次是：

 - 硬盘文件系统层，即物理文件系统，此处通常存放的数据是磁盘上的原始数据文件，如表空间文件、日志文件等。
 - Buffer Pool层，包含内存中的缓存，用于存储读取的数据。
 - B+ Tree Index层，B+树的索引结构在这里得到应用。
 - System Tablespace层，主要存放一些系统相关的数据，如数据字典、事务日志等。

我们知道InnoDB存储引擎采用页式存储，每一个表对应一个数据文件，每个数据文件由若干个数据页构成，而每一个数据页又分成多个行组、不同大小的列组，如下图所示：


 - 页面：InnoDB使用页作为基本的存储单位，一个数据页包含512字节或更少的字节数据。
 - 行组：一个数据页可能不能装载完整的行记录，所以InnoDB允许将同属于一个逻辑实体的一组相邻的行记录存储在一个行组里，以便一次性读取。
 - 字段组：一个行记录可以包含多个字段，但为了优化查询速度，InnoDB一般把相同数据类型或访问频率较高的字段放在一起。
 - 堆叠页：堆叠页是一种特殊的存储方式，可以存储小规模的数据。

以上就是InnoDB存储引擎的数据结构层级。

# 3. 数据结构的分类

由于InnoDB存储引擎的实现方案是基于B+树索引的，因此相关的数据结构也都具有B+树的特性，比如节点、键值、指针等。以下将介绍InnoDB存储引擎的数据结构的分类。

## 3.1 普通索引的数据结构

普通索引的数据结构如下图所示：


普通索引的数据结构，也被称为“聚集索引”，因为所有的索引都是聚集在一个索引树上的。这种索引组织形式将数据存储和检索的流程进行了完全的优化，在一个数据页内的记录按主键或其他唯一索引的顺序排列，可以有效地利用随机IO和缓存。

## 3.2 二级索引的数据结构

二级索引的数据结构如下图所示：


二级索引的数据结构，也被称为“非聚集索引”，因为该索引并不是聚集在索引树上的，它只包含数据的引用而不是实际的数据。索引数据只是帮助InnoDB存储引擎找到具体的数据位置。这种索引组织形式比较适合于查找某个范围内的数据，或者查找某种条件的数据。

## 3.3 数据字典的数据结构

数据字典的数据结构如下图所示：


数据字典的数据结构，保存了InnoDB数据库的所有相关信息，例如表名、表结构、数据位置、索引位置、数据分布等。这也是数据字典的作用所在。

## 3.4 事务日志的数据结构

事务日志的数据结构如下图所示：


事务日志的数据结构，保存了对数据库的所有修改动作，包括对表的创建、删除、修改等，每一条日志都被标记上了执行的时间点、用户账号等信息，并通过提交回滚点(redo log point)来保证事务的完整性。

以上就是InnoDB存储引擎的数据结构分类。

# 4. 文件结构

对于InnoDB存储引擎的数据文件，其结构如下图所示：


 - 创建时间：表示该文件的创建时间。
 - 上一次修改时间：表示该文件上一次被修改的时间。
 - 修改次数：表示该文件被修改的次数。
 - 最大页面号：表示数据文件最大的页号。
 - 当前页面号：表示当前页面号。
 - 是否脏页：表示该页面是否脏。如果页面为脏页，则需要同步至磁盘。

除此之外，还有一个系统数据文件SYSTEM，其结构如下图所示：


这个文件主要用来保存表空间的相关信息，比如系统表格的位置、最后提交事务的位置等。

# 5. 数据页结构

数据页是InnoDB存储引擎中最小的存储单位，其结构如下图所示：


数据页共分为三部分：

 - Page Header：固定长度的头部信息，包含页号、页面类型及其它一些属性信息。
 - Infimum & Supremum Records：Infimum Record和Supremum Record是两个占位符记录，作为第一个记录和最后一个记录。
 - User Records：用户记录，即真正的记录数据部分。

User Records部分又细分为：

 - Record Header：记录头部，包含记录的大小、版本号、删除标记、锁定标记、空间标识、空闲链表指针等信息。
 - Fixed Length Fields：固定长度字段，如记录的ID号、前驱记录地址、后继记录地址等。
 - Variable Length Fields：变长字段，即记录中的所有可变长度字段。

除了以上基本的数据结构，InnoDB存储引擎还会用到的一些辅助结构，如下图所示：


其中：

 - Undo Log Buffer：InnoDB存储引擎提供一个Undo Log Buffer，存储待撤销的事务修改记录。当发生事务回滚时，可以通过Undo Log Buffer获得之前的记录并重现出事物的历史数据。
 - Insert Buffer Queue：插入缓冲队列，用于暂存Insert语句产生的新记录，在写入磁盘前先将它们批量写到这个队列里。
 - Adaptive Hash Index：自适应哈希索引，是一个用来减少搜索开销的索引结构。在没有任何聚簇索引情况下，InnoDB存储引擎会自动创建一个基于数据的哈希索引。
 - Change Buffer：变化缓冲，用于跟踪数据页的修改情况，并根据变化情况刷新磁盘上的页面。

# 6. 页的分裂与合并

页的分裂与合并指的是对页进行拆分和合并操作，InnoDB存储引擎根据需求对数据页进行分裂或合并，以达到使整个表的高度平衡，提升查询效率。分裂页和合并页的过程称为合并度，这个值通过参数innodb_page_size=16KB设置。

页分裂的过程主要是为了使得一个页大小不超过innodb_page_size，并且能够适应一个数据页的大小。首先，InnoDB存储引擎会检查当前页面的剩余空间是否符合要求，如果满足则停止分裂；否则就要选择一个合适的拆分点。

具体的拆分点有两种：

1. 平均拆分点：将当前页划分成两半，将其中一个拆分点设置为平均值的位置，使得两半的大小差距最小。
2. 近似拆分点：将当前页划分成三份，分别以当前页第一条记录、中间记录及最后一条记录作为拆分点，这三个拆分点距离当前页的中心记录的距离相等。

然后，InnoDB存储引机就会拆分当前页，并在拆分点处新建一个空白页。拆分后的新页中只包含当前页的用户记录部分，而Infimum和Supremum记录仍然保留在原页中。

页合并的过程主要是为了防止出现过多的碎片页，让数据页尽可能保持整齐、连续。页合并的条件如下：

1. 可以合并的页。即需要满足页的低水印和上限水印，且这两个水印距离总页数小于merge_factor。
2. 不包含更新的页。即这些页里面没有正在进行的事务，也就是说这些页里面没有等待提交的更新。
3. 属于同一个页簇。即这些页应该属于同一个表空间的数据页。

在满足合并条件的情况下，InnoDB存储引擎将选取满足条件的所有页，将其合并为一个单独的页面。合并完成后，将生成一个新的页面，此时的页面中包含着来自各个页面的用户记录。另外，拆分后的两个页面将加入到空闲列表中，供之后再次使用。

# 7. 插入操作

对于InnoDB存储引擎的插入操作，其基本流程如下：

 1. 从用户缓冲区中获取要插入的记录；
 2. 检查是否有当前页已满；
    * 如果已满，则检查当前页是否可以进行页分裂；
      + 如果可以进行页分裂，则进行页分裂，并将记录插入到新生成的空白页；
      + 如果不可进行页分裂，则调用InnoDB的页合并进程进行页合并；
    * 如果当前页未满，则直接将记录插入到当前页；
 3. 将新插入的记录插入到记录的链表中；
 4. 如果插入导致当前页已满，则调用InnoDB的页分裂进程，并将记录插入到新生成的空白页；
 5. 在SYS_INDEX表中插入相应的记录；
 6. 调用UNDO日志写入模块，记录这次插入操作；
 7. 通过修改检测模块检测是否有任何地方发生了变化，如果有，则通知BufferPool的Page Flusher进程刷新磁盘上的相关页；
 8. 返回插入成功的提示给用户。

# 8. 删除操作

对于InnoDB存储引擎的删除操作，其基本流程如下：

 1. 从用户缓冲区中获取要删除的记录对应的页号、记录所在的位置；
 2. 根据记录所在的位置找到对应的User Record；
 3. 使用旧记录的Record ID删除掉对应的记录；
 4. 使用链表的方式将记录连接到相邻的记录上；
 5. 对记录的头部信息进行更新；
 6. 如果当前页已经没有记录，则调用InnoDB的页合并进程进行页合并；
 7. 在SYS_INDEX表中删除相应的记录；
 8. 调用UNDO日志写入模块，记录这次删除操作；
 9. 通过修改检测模块检测是否有任何地方发生了变化，如果有，则通知BufferPool的Page Flusher进程刷新磁盘上的相关页；
 10. 返回删除成功的提示给用户。

# 9. 更新操作

对于InnoDB存储引擎的更新操作，其基本流程如下：

 1. 从用户缓冲区中获取要更新的记录；
 2. 检查是否有当前页已经满；
    * 如果当前页已经满，则调用InnoDB的页分裂进程，将记录插入到新生成的空白页；
 3. 用新记录替换掉旧记录；
 4. 将新记录插入到记录的链表中；
 5. 判断更新后记录的头部是否超出了页边界，如果超出，则调用InnoDB的页分裂进程，将记录插入到新生成的空白页；
 6. 在SYS_INDEX表中更新相应的记录；
 7. 调用UNDO日志写入模块，记录这次更新操作；
 8. 通过修改检测模块检测是否有任何地方发生了变化，如果有，则通知BufferPool的Page Flusher进程刷新磁盘上的相关页；
 9. 返回更新成功的提示给用户。

# 10. 查询操作

对于InnoDB存储引擎的查询操作，其基本流程如下：

 1. 解析查询条件，得到查询的模式（全表扫描或索引扫描）及相关索引；
 2. 如果是全表扫描，则从头遍历记录，直到结束；
    * 如果遇到匹配条件的记录，则返回结果；
 3. 如果是索引扫描，则根据索引树和查询条件，得到需要查询的记录所在的页号；
    * 如果查询条件为空，则从头遍历记录，直到结束；
    * 如果遇到匹配条件的记录，则返回结果；