
作者：禅与计算机程序设计艺术                    

# 1.简介
  

创建型模式（Creational Pattern）是一类用来创建对象的设计模式。它关注于将对象实例化的过程，也就是说，怎样创建一个对象或一组对象的类的实例。在创建型模式中，对象通常会通过某种形式的工厂方法或者其他方式被创建出来，而不是像传统的构造函数那样一步到位地完成创建。在创建型模式中有许多不同的模式，但所有的模式都有着一些共同的特点。

一般来说，创建型模式分为三种类型：

1.单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个全局访问点。
2.原型模式（Prototype Pattern）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
3.工厂模式（Factory Method Pattern）：定义一个用于创建产品的接口，将实际创建工作延迟到子类。

除了以上三个典型的创建型模式外，还有以下几种创建型模式：

1.抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。
2.建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同一个构建过程可以创建不同的表示。
3.原型模式（Prototype Pattern）：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
4.模板方法模式（Template Method Pattern）：定义一个操作中的算法骨架，将一些步骤延迟到子类中，让子类实现个别步骤的方法，这种方法叫做模版方法。
5.适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的两个类可以一起工作。

# 2. 单例模式——保证一个类只有一个实例，并提供一个全局访问点。
## 2.1 概念
单例模式（Singleton Pattern）是一种创建型模式，其特点是某个类只能生成唯一的一个实例，而且该实例可以从一个全局访问点获得。单例模式的目的是为了控制实例数量，因此当第一次请求某个单例时，会生成该单例的实例，并保存起来供后续请求使用；如果已经存在了该单例的实例，再次请求时则直接返回该实例，避免了重复创建实例的开销。

一般情况下，单例模式要求确保一个类仅有一个实例，并提供一个全局访问点，这个全局访问点的类称之为单例类，它负责创建、管理和提供对整个系统只INSTANCE一个实例的访问。例如，对于某个数据库操作类来说，只有一个数据库连接池实例，所有客户端都通过该类获取数据库连接对象，同时也保证了数据的一致性。反过来，单例模式也是如此，只有一个应用配置类，为系统中的各个模块提供共享的配置信息。

## 2.2 原理
1. 首先，我们把构造方法设为私有的，这样其他处的代码就无法通过new关键字来实例化这个类。
```java
    private Singleton(){
        // prevent instance from being created from outside
    }
```
2. 在类的内部创建静态私有变量instance，并初始化为空值。
```java
    private static Singleton instance = null;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class){
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
```
3. 对外提供公有的静态方法getInstance()，返回实例化后的实例。

## 2.3 使用场景
1. 在一个系统中，要求一个类只有一个实例而且自行创建这个实例的能力，例如只能有一个数据库连接池，只能有一个应用配置类等；
2. 当想控制实例个数时，比如有些类只能允许创建固定数量的实例，那么可以使用单例模式来实现；
3. 当一个类可以作为一个全局性的 utility 来调用的时候，应该使用单例模式，例如工具类，网络工具类，日志工具类等；
4. 需要全局锁时，可以使用单例模式。

## 2.4 优缺点
### 2.4.1 优点
1. 提供了对唯一实例的受控访问；
2. 可以方便地替换、扩展或改变与系统的其他部分的交互；
3. 比其他创建模式更加灵活。

### 2.4.2 缺点
1. 因为单例模式限制了getInstance()的调用次数，所以当在较多线程环境下使用时，需要考虑同步策略；
2. 在并发场景下，如果没有正确的同步策略，很容易造成多个实例。