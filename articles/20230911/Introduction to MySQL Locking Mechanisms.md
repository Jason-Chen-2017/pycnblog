
作者：禅与计算机程序设计艺术                    

# 1.简介
  

MySQL是一个非常受欢迎的开源关系型数据库管理系统(RDBMS)，用于存储和检索大量的数据。在实际应用场景中，由于并发访问的需求，使得单个数据库服务器承载的请求数量越来越多。为了保证数据的一致性、完整性和正确性，很多时候都需要对数据库进行加锁处理，以避免多个客户端同时操作相同的数据造成数据冲突或不一致的问题。因此，对MySQL数据库的加锁机制有着至关重要的作用。本文将从整体流程、加锁机制、加锁策略三个方面介绍MySQL锁定机制。
# 2.关键概念和术语
## 2.1. 概念
**Lock**：在计算机科学领域里，lock就是控制资源共享的方法之一。简单地说，当多个进程或线程想共同访问某个资源时，通过锁可以实现互斥访问（多个进程或线程不能同时访问某个资源）。锁提供了一种独占的方式，用来保护共享资源免于竞争。
**Database Lock**：在MySQL中，database lock 是最基础的一种锁，它把整个数据库结构和表结构都锁住了，使得其他进程无法对其进行任何修改。当一个session想要对数据库做任何修改时，必须先获得数据库锁，才能继续对数据库进行读或者写操作。
**Table Lock**：如果一个session只需要对某一张表进行读操作，而不需要对其他表进行任何操作，那么可以只对该表加锁，这样可以提高效率。这种类型的锁称为table lock。
**Row-level Locks**：在MySQL中，除了对整个表加锁外，还可以通过row-level locks对行级别进行加锁。当一个session只需要对特定的一行或几行数据进行读或写操作时，就可以给这个行加上锁。比如，假如有两个session对同一条记录A进行读取和更新操作，但是其中一个session还没提交事务，另一个session又尝试读取和更新记录A，此时就可能会出现并发访问导致数据不一致的问题。这种情况下，可以给记录A加上读锁，表示当前session只能读取该记录，其他session只能等待；也可以给记录A加上写锁，表示当前session只能对该记录进行修改，其他session只能等待。
**Lock Timeout**：当一个session因长时间占用了锁而发生死锁时，MySQL会自动释放所有的锁，防止产生死锁。在这种情况下，新的session就会获得数据库锁，然后继续执行相应操作。但是，如果持续的时间超过了锁超时时间阈值(wait_timeout参数的值)，则MySQL也会自动释放该锁，让其他session能够获取数据库锁，继续执行相应操作。
**Deadlocks**：两个或以上进程因互相等待对方释放资源而陷入僵局状态，称为死锁。如果一个事务T1持有资源X，而事务T2也想要访问资源X，那么T1就会等待T2完成事务才释放资源，但T2却一直等待T1完成事务。最终结果是，两个事务永远都无法完成，系统一直处于死锁状态。

## 2.2. 技术概述
### 2.2.1. 概览
MySQL是一个关系型数据库管理系统(RDBMS)。由于并发访问的需求，使得单个数据库服务器承载的请求数量越来越多。为了保证数据的一致性、完整性和正确性，很多时候都需要对数据库进行加锁处理，以避免多个客户端同时操作相同的数据造成数据冲突或不一致的问题。MySQL数据库中的锁机制分为两种类型：全局锁和表级锁。本文主要介绍全局锁和表级锁。

### 2.2.2. 全局锁
全局锁是MySQL里最简单的一种锁，对整个库的数据加锁，所有进程只能串行运行。它的语法形式如下所示：
```
FLUSH TABLES WITH READ LOCK;
SELECT * FROM table_name WHERE condition; -- 直到当前会话结束才释放锁
UNLOCK TABLES;
```
这段代码的作用是将所有表都锁住，使得其他进程只能排队等候，直到这个会话结束才释放锁。例如，当我们执行`ALTER TABLE table_name ADD COLUMN column_name INT;`这条命令时，就会触发全局锁，阻塞其他进程的写操作。

全局锁的开销很小，加锁期间仅仅把请求变成了串行化的过程，没有阻塞其他进程，故而也称为非阻塞式的锁。InnoDB引擎提供了一个默认的全局锁，也就是第一次启动服务时自动加的表级锁。在SHOW ENGINE INNODB STATUS查看：
```
"RW-shared sp: waiting for table metadata lock"
```
这句话的意思是：有多个session正在申请读锁(sp: shared page)，并且等候表元数据锁(metadata lock)。

### 2.2.3. 表级锁
表级锁是在特定场景下的锁机制。当一个表被多个会话并发读写时，不同的会话可能对同一张表施加不同的锁。不同类型的锁有以下几种：
- **排他锁(Exclusive Lock)**：又名写锁。对于不同的session，即便都是需要修改表内某一行或多行数据，也只能由一个session进行，也就是只能有一个session拥有该表的写锁。当一个session正在给表A加上写锁后，其他session如果要对表A进行任何操作，都会处于等待状态，直到该session提交事务释放了写锁才可以继续进行。
- **共享锁(Shared Lock)**：又名读锁。一个session对表A加上共享锁后，其他session就可以同时对表A进行读取操作，但不能加任何锁。另外，一个session可以再次对同一张表加上读锁，以获取该表的最新数据。当某个session释放了对表A的读锁之后，其他session就可以继续对该表进行读或写操作，但不能再获取该表的写锁。
- **意向锁(Intention Lock)**：InnoDB支持意向锁，用于表之间的互斥锁定。当一个session想要给表A加上写锁时，可以在表B上首先给自己加上意向锁，但只有当B也需要给A加上写锁时，两个session才能真正加锁成功。

图展示了四种类型的锁。

1. InnoDB在给一个表分配了行锁后，不再允许对其进行INSERT和DELETE操作，直到该行锁被释放。

2. 如果多个会话同时对表A进行写操作，则只有一个会话能成功获得锁。如果该会话回滚事务，则其他会话仍然可以获得锁，继续进行写操作。

3. 当session1获取写锁时，session2必须等待锁释放。

4. session3只能获取表B上的读锁，不能获取表C上的任何锁。