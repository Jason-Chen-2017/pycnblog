                 

# 1.背景介绍



在计算机科学中，回文字符串（palindrome string）是指从左往右读和从右往左读都是一样的字符序列，通常可以简称为“回文”。例如，"racecar", "madam"等就是回文字符串。判断一个字符串是否为回文，可以通过比较两个指针指向的字符来进行。

本文通过解答两个重要的问题：

1.如何判定一个字符串是否为回文？
2.如何对一个字符串中的所有回文子串快速检索出所有的回文子串？

首先，我们需要定义什么叫做回文串。从字面上理解，回文串是具有相同字符顺序向内的字串，比如："racecar"、"level"、"deified"、"noon"、"radar"。一般来说，如果一个字符串是回文串，那么它的前半段和后半段都可以拆开来看作两条线，然后把这两条线的方向相反即可获得另一个相同的字符串。这里我想强调一下，不是任意的字符。仅仅只有相同字符顺序的字串才是回文串。

举个例子，"A man a plan a canal Panama"这是一个回文串，因为它的所有字符都出现了相同次数且位置也一致。"abcddcba"也是回文串，因为它可以分成三组：(a, b, c)，(d, e, f)，(g, h, i)。但是"abccba"却不是回文串，它没有重复的元素。

判定一个字符串是否为回文最简单的方法，就是依次比较字符串的第一个字符和最后一个字符，第二个字符和倒数第二个字符，第三个字符和倒数第三个字符……直到第n/2个字符和第n/2-1个字符相同时停止，如果中间某一次比较发现不一致，则不是回文串；否则，就是回文串。这个方法的时间复杂度是O(n)，空间复杂度也只是O(1)而已。

然而，还有更加高效的方法——“Manacher算法”（Miller 1975）。

# 2.核心概念与联系

回文串算法包含三个重要的概念，分别是回文串的“轴对称点”，“回文半径”和“滚动数组”。轴对称点指的是回文串的中心轴线位置。回文半径又称为“逼近半径”，指的是回文串在轴对称点的旁边的区域内，每个位置的最大值。滚动数组又称为“马蹬扫描”或者“回文逐渐扩张”的过程，即先将一个小的范围内的回文串求解出来，再移动这个范围并去除重复部分，进而得到当前的回文串，这样反复迭代多次就可求得整个字符串的全部回文子串。

这些概念有什么联系呢？实际上，轴对称点和回文半径的关系类似于指针指向的字符，即任取一个字符，它能够对准回文串的轴心。当该字符的左侧和右侧之间存在较长的回文串时，它可以从中间开始往两侧扩展寻找轴心。反之，如果只有较短的回文串或者只有单个字符时，它只能尝试从两侧向中间靠拢。对于每一个位置上的字符，它都有一个与其对应的轴对称点的距离和一个回文半径。距离越长，回文半径就越小，反之亦然。因此，回文半径大小决定了一个位置的取舍。同样，回文半径也可以用来构造滚动数组。滚动数组的中心是回文串的轴心，在两端以外，它延伸出一个规模为回文半径的矩形范围，在这个矩形范围内，每一行都是一个回文子串。如果一个位置的回文半径大于等于上一行的回文半径，则在滚动数组上填入“1”；否则，在滚动数组上填入“0”。这样，可以对整个字符串的回文子串进行滚动处理，使得滚动数组的值代表着字符串中各个位置是否为回文子串。最后，根据滚动数组的结果就可以获取所有回文子串。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解

## Manacher算法

Manacher算法的基本思路是利用“回文串的滚动数组”这一思路。通过构建一个滚动数组，可以有效地解决“回文串匹配”这一问题。具体地说，就是用数组来表示一个待匹配串，其中数组元素的值表示该位置是否为回文子串的起始位置。我们将数组中每个元素表示为二维坐标(i,j)，其中i为行号，j为列号，它可以表示一个长度为奇数的回文串，而且下标从0开始，即该元素所在的行列号都应对应着该回文串的奇数下标的字符。

例如，对于待匹配串“ABCDBCDE”的情况，其滚动数组为：

```
    0  1  2  3  4  5
  A [F T F F F] B
  C [T F F F F] D
  D [T F F F F] E
   \   |    /
      V
```

如此，可以看到在第0行，第0列、第2列、第3列、第4列五个位置为“回文子串的起始位置”，因为它们是偶数下标的字符。在第1行，第1列、第3列、第4列为“回文子串的起始位置”，因为它们是奇数下标的字符。同理，在第2行，第2列为“回文子串的起始位置”。

通过滚动数组，我们可以方便地求解待匹配串中的所有回文子串。具体地说，可以从第一行开始，在该行中的“1”对应的位置处，找到一个回文子串，然后向下移动一行，继续查找，直到找到第N行，得到一个完整的回文子串。这里的N为行数，N=len(s)+1。为了避免重复计算，我们可以预先计算好“所有子串”中的一些特定的回文子串，比如长度为奇数的回文子串或长度为偶数的回文子串。

例如，对于待匹配串"ABCDBCDE"，我们预先计算了"BDBC"、"DBC"和"C"的回文子串。其中"BDBC"的回文子串由‘B’和‘D’构成，其轴对称点为3（从1开始计数），回文半径为3。因此，在滚动数组中，可以标记为“回文子串的起始位置”的字母为红色。

```
    red             green
  -1 0  1  2  3  4    5  6
A [- F R F T F F ] B [R F R F R] C
B [T F R F T F F ] D [T F R F R] E
C [T F R F T F F ] E []        G
D [T F R F T F F ]                H
E []                             I
```

如上图所示，我们可以看出满足回文半径大于等于3的点均为“回文子串的起始位置”，所以"BCDBCE"和"BDBC"可以找到对应的回文子串。注意到"C"的回文半径为0，不能用于查找回文子串，所以"ABCD"和"ABC"只能找到长度为3的回文子串。

最后，为了便于输出，还需要保存这些回文子串的“起始下标”、“结束下标”和“长度”。

Manacher算法的时间复杂度为O(nm), m为待匹配串的长度，n为行数，因为遍历每个待匹配字符都要访问滚动数组中的至少一行。空间复杂度为O(m)，因为滚动数组的大小为待匹配串的长度。

## 回文串匹配

回文串匹配即查找给定字符串中的所有回文串。Manacher算法可以帮助我们解决这一问题。假设给定字符串S，我们可以在O(n^2*m)的时间内对每个子串[i, j]（i <= j < n+m）都检查是否为回文串，但这样会导致时间复杂度过高，于是采用分治法进行优化。

分治法的基本思路是：先将给定字符串S分割成两部分，分别记作S1和S2。若S1和S2都是回文串，则S是回文串。否则，若S1是回文串，则S2一定不是回文串；若S2是回文串，则S1一定不是回文串；否则，考虑字符串S3，它可以被分成两部分：S13和S23，其中S13和S23分别属于S1和S2。若S13和S23都是回文串，则S3也是回文串；否则，若S13是回文串，则S23一定不是回文串；若S23是回文串，则S13一定不是回文串；否则，S3也是回文串。类似地，还可以证明这样的过程最终会将原问题划分为无穷多个回文串的组合。

分治法虽然比暴力算法要快，但是它还是有很多缺点。首先，它要求时间和空间上的开销要远远超过原问题的规模，因此运行速度可能受到影响。其次，它可能会产生许多不需要的回文串，增加了计算量。因此，Manacher算法仍然是一种有效的解决方案。