
作者：禅与计算机程序设计艺术                    

# 1.简介
  

堆是一个可以被看成一棵树的特殊结构，本文将对堆进行详细阐述，并分析其在实际应用中的各种应用场景。
## 1.背景介绍
堆数据结构（英语：Heap data structure）是一种类似于二叉树的数据结构，它满足一定的性质，使得数据元素可以动态地增加或者删除。堆分为两种类型：最大堆和最小堆。最大堆中，每个节点的值都大于或等于其子节点的值；最小堆中，每个节点的值都小于或等于其子节点的值。
堆可以用数组来实现，可以用两个堆实现优先队列。数组索引从0开始。堆分为堆顶和堆底。在堆中，根节点永远是堆顶。堆顶所在位置称为堆指针(heap pointer)，堆底位置表示空堆。堆结构具有以下几个特性：

1. 完全二叉树：除了最底层外，每个节点都有左右两个子节点；如果最后一层不满，则多出来的是叶节点。所以堆是一个完全二叉树。

2. 堆序性：对于一个任意节点来说，如果其子节点的值都比它大或都比它小，那么这个节点就是堆序的。最大堆中，堆顶的值一定是所有节点中的最大值；最小堆中，堆顶的值一定是所有节点中的最小值。因此，堆可以用来实现排序和检索等操作。

3. 性质：堆中某个节点的值总是小于等于其父节点的值。根据性质，可以保证最大堆的根节点始终是最大值，最小堆的根节点始终是最小值。

4. 操作：插入、删除操作的时间复杂度都是O(logn)。

## 2.基本概念术语说明
### 1.堆顶指针（heap pointer）
堆顶指针指向堆顶元素，堆底指针指向堆底元素。堆顶元素是堆中最大（最小）元素。堆底元素通常不存储有效信息，仅作为堆栈的底部标记。堆顶指针（堆指针）指向堆顶元素所在的位置。堆底指针指向堆底元素所在的位置。堆指针也可以指示堆中第一个非空元素的位置。

### 2.父节点（parent node）
设H为堆的顺序表，其索引编号从0到n-1。若i>0，则称结点i为H[i]的父亲节点或父节点，父节点对应的索引为（i-1）/2。当i=0时，结点i没有父亲节点，其父节点的索引也是0。

### 3.左孩子节点（left child node）
设H为堆的顺序表，其索引编号从0到n-1。若i>=1且2*i+1<=n-1，则称结点i的左孩子节点或左儿子节点，左孩子节点对应的索引为2*i+1。当i>=(n-1)/2时，结点i没有左孩子节点，其左孩子节点的索引也是-(∞)或∞。

### 4.右孩子节点（right child node）
设H为堆的顺序表，其索引编号从0到n-1。若i>=1且2*i+2<=n-1，则称结点i的右孩子节点或右儿子节点，右孩子节点对应的索引为2*i+2。当i>=(n-1)/2或i=0时，结点i没有右孩子节点，其右孩子节点的索引也是-(∞)或∞。

### 5.子女节点（child node）
设H为堆的顺序表，其索引编号从0到n-1。结点i的子女节点包括其左孩子节点、右孩子节点、父节点和兄弟节点。左孩子节点对应索引为2*i+1；右孩子节点对应索引为2*i+2；父节点对应索引为（i-1）/2；兄弟节点对应索引分别为2*i+3和2*i+4。

### 6.兄弟节点（sibling node）
设H为堆的顺序表，其索引编号从0到n-1。结点i的兄弟节点是它父节点的另一颗子树上的节点。当结点i没有左孩子节点时，结点i的右孩子节点就是它的兄弟节点；当结点i没有右孩子节点时，结点i的左孩子节点就是它的兄弟节点。兄弟节点可以分为两类，即“叔叔”和“堂哥”。

7.最大堆

在最大堆中，每个节点的值都大于或等于其子节点的值。堆序性的定义导致最大值位于堆顶。如下图所示：

如上图所示，最大堆的形式是一个完全二叉树，并且每个节点的值都大于等于其父节点的值。

最小堆相反，每个节点的值都小于或等于其子节点的值。堆序性的定义导致最小值位于堆顶。

### 8.堆的操作
#### 插入操作
将新元素加入到堆末尾，然后逐步上移直至其上升为止。为了保持堆的高度较低，可以使用尾插法，即插入到堆底，然后依次向上调整，使其保持最大堆性质。如下图所示：

#### 删除操作
删除堆顶元素，并把堆末尾元素移至堆顶，然后再次下沉直至其下降为止。为了保持堆的高度较低，可以使用头插法，即先删除堆顶元素，再将元素插入堆顶，然后依次向下调整，使其保持最大堆性质。如下图所示：

#### 求堆顶元素
求堆顶元素的方法也很简单，只需要访问堆顶指针即可。无论是最大堆还是最小堆，堆顶指针都会指向堆顶元素。

#### 修改堆顶元素
修改堆顶元素可以直接通过堆指针修改。无论是最大堆还是最小堆，堆顶指针都会指向堆顶元素。

## 3.堆的算法描述及实现
### （1）堆化操作（buildMaxHeap）

堆化操作会构造一个新的最大堆，给定一个堆的顺序表H[0..n-1]，其中堆底指针last为n-1，首先将first=last//2取整，因为下标从0开始，因此除以2后结果应是整数。令i=first，然后循环执行以下操作：

　　　　a. H[i]和H[2*i+1]进行比较，如果H[2*i+1]>H[i]，则交换H[i]和H[2*i+1]。

　　　　b. H[i]和H[2*i+2]进行比较，如果H[2*i+2]>H[i]，则交换H[i]和H[2*i+2]。

　　　　c. i=i-1，重复步骤a~c，直到i=-1或H[i]<=H[((i-1)//2)]为止。

时间复杂度：O(nlogn)，空间复杂度：O(1)。

### （2）插入操作（insert）

插入操作会把一个新的元素插入到堆中，并且保持最大堆性质，过程如下：

　　　　a. 将newElement追加到堆的底部。

　　　　b. 调用maxHeapify()函数将该元素调整为最大堆。

时间复杂度：O(logn)，空间复杂度：O(1)。

### （3）删除操作（extractMax）

删除操作会从堆中删除堆顶元素并返回它，同时保持最大堆性质，过程如下：

　　　　a. 将堆顶元素（即H[0]）和堆的最后一个元素（即H[last]）进行交换。

　　　　b. 删除堆的最后一个元素。

　　　　c. 调用maxHeapify()函数将堆顶元素调整为最大堆。

时间复杂度：O(logn)，空间复杂度：O(1)。

### （4）修改操作（increaseKey）

修改操作用于更新堆中的某一元素的键值，同时保持最大堆性质，过程如下：

　　　　a. 找到待修改元素在堆中的索引。

　　　　b. 如果待修改元素的键值比其父节点的键值还大，则停止操作，否则继续。

　　　　c. 更新待修改元素的键值。

　　　　d. 使用sinkDown()函数将待修改元素调整为最大堆。

时间复杂度：O(logn)，空间复杂度：O(1)。