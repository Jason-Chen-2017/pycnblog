
作者：禅与计算机程序设计艺术                    

# 1.简介
  

面向对象编程(Object-Oriented Programming， OOP)是一种计算机编程方法，它是一种基于数据抽象的编程模型。其主要特征之一是将对象作为程序的基本单元，通过封装、继承、多态等特性来创建灵活、可扩展、可重用的代码。OOP 的特点就是通过将现实世界中的各种事物建模成对象，用类和实例来表示，并通过它们之间的交互来进行系统的开发。所以，理解 OOP 的关键在于搞清楚三个核心概念：类（Class）、实例（Instance）、消息（Message）。

本文主要内容包括以下六个方面：

1. UML概述
2. 类的创建、继承及组合
3. 抽象类、接口及多态性
4. 对象的构造函数、析构函数及成员函数
5. 异常处理
6. 单元测试

# 2. UML概述
Unified Modeling Language (UML) 是用于系统工程领域的通用图形化建模语言。它提供了一种标准的可视化方式，使得复杂系统可以用图表的方式呈现出来，更容易地理解和沟通。在面向对象分析中，UML 是最重要的工具之一，因为它可以用来描述类、对象、关系、协作、职责等各方面的信息。下面简要介绍一下 UML 中一些基本的元素和符号。

### 2.1 用例图
用例图（Use Case Diagram）是一个简单而直观的图表形式，用来描述系统功能需求。它以用例（Use Case）为基础，描述了系统需要支持哪些用途以及它们如何相互作用。用例图的主要元素有：

- Actor：系统用户或其他参与者，例如客户、管理员等；
- Use case：一个系统功能需求，例如登录、注册等；
- Include：包含某个用例所需的所有子用例；
- Extend：扩充某个用例，增加新的功能要求；
- Association：实体间的关联，表示他们之间存在某种联系；
- Generalization：表示父类和子类之间的关系，也就是说，父类拥有的属性和行为会被它的子类继承；
- Realization：表示实现某个接口的实体的具体实现。

如下图所示：


### 2.2 类图
类图（Class Diagram）是一个用来描述系统中类以及类之间的静态关系的图表。它由以下几个元素组成：

- Class：表示系统中的对象类型，类名即为该类的名称；
- Attribute：表示类的数据成员，每个数据成员都有名称和数据类型；
- Method：表示类的方法，每个方法都有名称、参数列表和返回值；
- Generalization：表示类的继承关系，即派生类（derived class）继承基类（base class）的属性和行为；
- Association：表示两个类之间的关联关系，即一个类可以有多个实例，或者一个实例可以属于不同的类；
- Interface：表示类的接口，即定义了类的所有公共操作，但不提供实现细节；
- Composition：表示类的内部结构，即包含关系，即一个类可以直接包含其他类的实例；
- Dependency：表示两个类之间的控制依赖关系，即当一个类的实例改变时，另一个类也应该相应改变；
- Package：表示一个命名空间（namespace），即包（package）内包含若干相关类及文件。

如下图所示：


### 2.3 活动图
活动图（Activity Diagram）用来描述对象之间的交互过程。活动图的主要元素有：

- Action：表示活动（Action），即对象执行某个操作；
- Control Flow：表示流程控制，即连接活动的线条；
- Object Node：表示系统中的对象，包含对象名和身份；
- Initial Node：表示程序开始运行的节点，即第一个节点；
- Fork Node：表示分叉点，即同时存在两个或多个分支的节点；
- Decision/Merge Node：表示选择和合并节点，即根据条件选择一条路径，或合并两条路径上的流量；
- Final Node：表示程序结束时的节点，即最后一个节点；
- Exception Node：表示出现异常的节点，即程序不能继续执行时；
- Subprocess：表示子流程，即包含其他活动的块状区域。

如下图所示：


### 2.4 状态机图
状态机图（State Machine Diagram）用来描述对象的状态变化逻辑。状态机图的主要元素有：

- State：表示状态，即对象处于某个特定阶段；
- Transition：表示状态转换，即从一个状态到另一个状态；
- Event：表示外部输入，即对象收到的外部信号；
- Entry/Exit Actions：表示进入或退出某个状态时的操作；
- Initial State：表示初始状态，即系统刚启动时的状态；
- Final States：表示系统终止时的状态；
- Intermediate States：表示中间状态，即除初始状态和终止状态外的其他状态。

如下图所示：


# 3. 类的创建、继承及组合
## 3.1 创建类
在面向对象编程中，为了能够管理程序的复杂性，将复杂任务分解成多个小模块，将每一个模块称为“类”，然后按照一定规则组合这些类成为更大的结构，最终得到整个程序。因此，创建一个类就等于定义了一个新的对象类型。

类一般由以下几部分构成：

- 类的名称（Name）：描述类的作用或含义；
- 属性（Attribute）：包含类的一些数据字段；
- 方法（Method）：包含类提供的功能；
- 构造函数（Constructor）：在创建类的实例时调用，用来初始化对象；
- 析构函数（Destructor）：在销毁类的实例时调用，用来释放内存；
- 友元（Friend）：声明类的友元函数或类。

### 3.1.1 定义一个简单的类

```c++
// Point类
class Point {
public:
    // 属性
    double x;
    double y;

    // 构造函数
    Point(double a = 0, double b = 0):x(a),y(b){};

    // 方法
    void print() const{
        std::cout << "Point(" << x << "," << y << ")" << std::endl;
    }

    // 运算符重载
    bool operator==(const Point& p) const{
        return this->x == p.x && this->y == p.y;
    }

    friend std::ostream& operator<<(std::ostream&, const Point&);
};

// 友元函数
std::ostream& operator<<(std::ostream& os, const Point& p){
    os << "(" << p.x << ", " << p.y << ")";
    return os;
}

int main(){
    Point p1(1, 2);
    Point p2(p1);

    if(p1==p2){
        std::cout << "p1 and p2 are equal" << std::endl;
    }else{
        std::cout << "p1 and p2 are not equal" << std::endl;
    }

    p1.print();
    p2.print();

    std::cout << p1 << std::endl;

    system("pause");
    return 0;
}
```

输出结果：

```c++
p1 and p2 are equal
Point(1,2)
Point(1,2)
(1, 2)
```

### 3.1.2 使用友元声明一个类

如前面所示，我们可以为一个类添加一个友元函数。友元函数通常是另一个类或者类模板的非成员函数，但是又想访问该类的私有和保护成员。那么就可以使用友元来访问类的私有成员。如下面的例子：

```c++
class Point {
private:
    int color_;    // 颜色

public:
    //...
};

class ColorPrinter{
private:
    static const char* colors[];   // 颜色数组

public:
    static void PrintColor(const Point& point){
        for(int i=0;i<point.MAX_COLOR;++i){
            if(colors[i]==nullptr){
                continue;
            }

            if(strcmp(colors[i],point.color_)==0){
                cout << "This is a "<<colors[i]<<" point."<<endl;
                break;
            }
        }
    }
};

// 在类外声明colors数组
const char* ColorPrinter::colors[]={"red","blue","green"};
```

注意：友元函数必须是全局函数或者类的全局函数，且必须声明为`extern "C"`，否则编译器可能会产生警告。另外，友元声明不需要`using namespace`语句。