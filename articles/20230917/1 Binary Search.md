
作者：禅与计算机程序设计艺术                    

# 1.简介
  

Binary search (BS) 是一种在有序数组中查找特定元素的搜索算法，它的时间复杂度是 O(log n)，可以应用于很多实际的问题。本文主要讨论二分查找算法，并详细阐述其工作原理及应用场景。
# 2.基本概念术语
## （1）有序数组
在 BS 中，假设有一个长度为n的有序数组A[0...n-1]。其中，索引从0到n-1的每个位置上都对应着一个元素值，而这些值的顺序就是数组的升序排列（或降序排列）。比如，如果A[i]<A[j]，则 i<j。即所有元素的值都是严格单调递增或者单调递减的。
## （2）目标元素x
BS的核心是找出目标元素x在数组中的位置（索引），如果x不存在于数组中，则返回x应该插入的位置。举个例子：
```
{3, 7, 9, 12, 15} 想要查找的目标元素是 9，因此在数组中找到该元素后，返回其索引。
```
## （3）下标low、high 和mid
对于 BS，假设已经知道了数组A的起始下标 low 和终止下标 high ，且当前的搜索范围是一个半闭半开区间 [low, high) 。在每次迭代中，将 mid=(low+high)/2 将数组划分成两个半区间 [low, mid) 和 [mid, high) 。
# 3.2 操作步骤
## （1）初始化
设置变量 low=0, high=n-1, 执行第一次循环。
## （2）循环
### （a）更新mid值
当下标 low>=high 时，表明目标元素 x 不存在于数组中，此时应返回 high 的值（下标值等于数组的插入点）。
### （b）比较mid值与目标元素值
如果 A[mid]==x，则表示目标元素 x 在数组 A 中，此时应返回 mid 值（下标值）。
### （c）调整搜索范围
如果 A[mid]>x，则说明目标元素可能存在左侧子数组 A[low... mid-1] 中，所以更新 high=mid-1；如果 A[mid]<x，则说明目标元素可能存在右侧子数组 A[mid+1... high] 中，所以更新 low=mid+1。
### （d）重复循环直至找到或插入目标元素
重复以上操作，直至 low>=high 或找到目标元素 x 为止。
## （3）代码实现
C++ 语言的代码实现如下：
```
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;

    while (left <= right) {
        // 用右中位数替代mid，防止出现死循环
        int mid = (left + right) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    // 如果循环结束，仍然没有找到目标元素
    return left;
}
```
## （4）时间复杂度分析
BS 算法最坏情况下需要比较 log2(n) 次才能找到目标元素，因此，它的平均时间复杂度是 O(log n)。但是，在极端情况下，比如输入数组是降序排序，那么每一步都需要翻转搜索范围，所以时间复杂度会退化到 O(n)。因此，为了保证效率，一般要求待搜索的数据集具有良好的局部性，并且搜索元素与其他元素分布的相对顺序一致，这样就可以有效地避免陷入最坏情况。