# Graph Shortest Path算法原理与代码实例讲解

## 1. 背景介绍
### 1.1 图论基础
#### 1.1.1 图的定义与表示  
图(Graph)是由顶点(Vertex)和边(Edge)组成的数学结构,用来模拟事物之间的关系网络。顶点表示事物,边表示事物之间的联系。根据边是否有方向,可以把图分为无向图和有向图。在无向图中,边没有方向,顶点之间的联系是双向的;而在有向图中,每条边都有特定的方向,表示顶点之间的单向联系。图可以用邻接矩阵或邻接表来表示。

#### 1.1.2 图的常见术语
- 顶点的度(Degree):一个顶点的度是指与该顶点相连的边的数量。在有向图中,顶点的度还可以分为入度(指向该顶点的边数)和出度(从该顶点出发的边数)。  
- 路径(Path):图中的一个路径是由一系列顶点和边首尾连接形成的序列,起点和终点可以相同(构成回路)也可以不同。
- 连通图:如果图中任意两个顶点之间都存在一条路径,则称该图是连通图。

### 1.2 最短路径问题概述
在图论中,最短路径问题(Shortest Path Problem)是指在带权图中,找到两个指定顶点之间的所有路径中,边权重之和最小的路径。求解最短路径是图算法中的经典问题,在实际应用中有重要意义,如网络路由、地图导航、资源调度优化等。根据问题的不同形式,最短路径可以分为以下几类:  

- 单源最短路径(Single-Source Shortest Path):求一个源点到图中其他所有顶点的最短路径。
- 单对最短路径(Single-Pair Shortest Path):求一对特定顶点之间的最短路径。  
- 全局最短路径(All-Pairs Shortest Path):求图中任意两个顶点之间的最短路径。

## 2. 核心概念与联系
### 2.1 最短路径的数学定义
设 G=(V,E) 是一个带权有向图,其中 V 是顶点集,E 是边集。边 e=(u,v) 的权重为 w(u,v),表示从顶点 u 到顶点 v 的距离。对于图中任意两个顶点 s 和 t,s 到 t 的最短路径定义为:
$$
\delta(s,t) = \min\limits_{\pi \in \Pi(s,t)} \sum_{e \in \pi} w(e)
$$
其中 $\Pi(s,t)$ 表示图中 s 到 t 的所有可能路径的集合。如果 s 和 t 之间不存在路径,则 $\delta(s,t)=\infty$。

### 2.2 最短路径算法分类  
求解最短路径的算法主要可以分为两大类:
1. 基于松弛操作的单源最短路径算法,代表算法有 Dijkstra 和 Bellman-Ford。这类算法通过不断松弛(更新)顶点的最短距离估计值,直到所有顶点的最短距离都得到确定。
2. 基于动态规划的全局最短路径算法,代表算法是 Floyd-Warshall。该算法通过递推计算所有顶点对之间的最短路径,其核心思想是利用中间顶点对最短路径进行松弛。

### 2.3 最短路径算法比较
下表总结了几种经典最短路径算法的特点和复杂度:

| 算法 | 适用问题 | 边权限制 | 时间复杂度 | 空间复杂度 |
|------|--------|---------|-----------|-----------|  
| Dijkstra | 单源最短路径 | 非负权重 | $O((V+E)\log V)$ | $O(V)$ |
| Bellman-Ford | 单源最短路径 | 任意权重 | $O(VE)$ | $O(V)$ |  
| Floyd-Warshall | 全局最短路径 | 任意权重 | $O(V^3)$ | $O(V^2)$ |

其中 V 和 E 分别表示图的顶点数和边数。可以看出,这些算法在时间和空间复杂度上有不同的权衡,需要根据具体问题的特点来选择合适的算法。

## 3. 核心算法原理与操作步骤
本节将重点介绍 Dijkstra 和 Floyd-Warshall 这两个最短路径算法的原理和步骤。

### 3.1 Dijkstra 算法
Dijkstra 算法是一种基于贪心策略的单源最短路径算法,适用于边权重非负的有向图。算法的核心思想是:每次选择未确定最短距离的顶点中距离源点最近的顶点,通过该顶点更新其他顶点的距离,直到所有顶点的最短距离都确定下来。

#### 3.1.1 算法步骤
1. 初始化:设置源点 s 的距离为0,其他所有顶点的距离为无穷大。创建两个集合 S 和 Q,S 存储已确定最短距离的顶点,初始时为空;Q 存储未确定最短距离的顶点,初始时包含所有顶点。 
2. 从 Q 中选择距离最小的顶点 u,将其加入 S,并从 Q 中删除。
3. 对 u 的所有出边 (u,v) 进行松弛操作:如果 `dist[u] + w(u,v) < dist[v]`,则更新 `dist[v] = dist[u] + w(u,v)`。
4. 重复步骤 2 和 3,直到 Q 为空,此时 S 中所有顶点的最短距离都已确定。

#### 3.1.2 算法流程图
```mermaid
graph LR
A[初始化源点距离为0其他顶点距离为无穷大] --> B{Q是否为空}
B -->|是| C[算法结束]
B -->|否| D[从Q中选择距离最小的顶点u加入S] --> E[对u的出边进行松弛操作更新相邻顶点距离] --> B
```

### 3.2 Floyd-Warshall 算法
Floyd-Warshall 算法是一种基于动态规划的全局最短路径算法,可以求出图中任意两个顶点之间的最短路径。算法的核心思想是:如果顶点 i 到顶点 j 的最短路径经过顶点 k,那么该最短路径可以分解为 i 到 k 的最短路径和 k 到 j 的最短路径。

#### 3.2.1 算法步骤
1. 初始化距离矩阵 `dist[i][j]`,如果顶点 i 和 j 之间有边直接相连,则 `dist[i][j]` 等于边的权重,否则 `dist[i][j]` 为无穷大。对角线元素 `dist[i][i]` 初始化为0。
2. 遍历中间顶点 k,更新所有顶点对之间的最短距离:
   ```
   for k: 1 to n
     for i: 1 to n  
       for j: 1 to n
         if dist[i][k] + dist[k][j] < dist[i][j] then
           dist[i][j] = dist[i][k] + dist[k][j]
   ```
3. 最终 `dist[i][j]` 即为顶点 i 到顶点 j 的最短路径长度。如果需要输出最短路径,可以用一个辅助矩阵 `path[i][j]` 记录最短路径上顶点 j 的前驱顶点。

#### 3.2.2 算法流程图
```mermaid
graph TD
A[初始化距离矩阵dist] --> B{遍历中间顶点k}
B -->|k<=n| C{遍历起点i}
C -->|i<=n| D{遍历终点j} 
D -->|j<=n| E{dist[i][k]+dist[k][j]<dist[i][j]}
E -->|是| F[更新dist[i][j]=dist[i][k]+dist[k][j]] --> D
E -->|否| D
D -->|j>n| C
C -->|i>n| B
B -->|k>n| G[算法结束dist[i][j]为i到j的最短距离]
```

## 4. 数学模型与公式详解
### 4.1 Dijkstra 算法的数学模型
设 G=(V,E) 是带权有向图,`w(u,v)` 表示边 `(u,v)` 的权重。定义 `dist[v]` 表示源点 s 到顶点 v 的最短距离,初始时:
$$
dist[v]=
\begin{cases}
0 & v=s \\
\infty & v \neq s
\end{cases}
$$
Dijkstra 算法的松弛操作可以用以下公式表示:
$$
dist[v]=\min\{dist[v], \ dist[u]+w(u,v)\}
$$
其中 `(u,v)` 是图中的一条边,`u` 是已确定最短距离的顶点。通过不断执行松弛操作,直到所有顶点都加入 S,最终 `dist[v]` 就是源点到顶点 `v` 的最短距离。

### 4.2 Floyd-Warshall 算法的数学模型
Floyd-Warshall 算法的核心是状态转移方程:
$$
dist[i][j]=\min\{dist[i][j], \ dist[i][k]+dist[k][j]\}
$$
其中 `dist[i][j]` 表示顶点 `i` 到顶点 `j` 的最短距离,`k` 是中间顶点。这个方程表示,如果顶点 `i` 到 `j` 的最短路径经过顶点 `k`,那么 `i` 到 `j` 的最短距离可以通过 `i` 到 `k` 的最短距离加上 `k` 到 `j` 的最短距离来更新。

Floyd-Warshall 算法的时间复杂度是 $O(V^3)$,其中 `V` 是图的顶点数。尽管该算法的时间复杂度较高,但它可以处理带负权边的图,并且代码实现简洁。

## 5. 项目实践:代码实例与详解
下面给出 Dijkstra 和 Floyd-Warshall 算法的 C++ 代码实现。

### 5.1 Dijkstra 算法代码
```cpp
const int INF = 0x3f3f3f3f; // 无穷大
const int MAXN = 1005; // 图的最大顶点数

int n, m; // n表示顶点数,m表示边数
int dist[MAXN]; // dist[i]表示源点到顶点i的最短距离
bool vis[MAXN]; // vis[i]表示顶点i是否已加入S集合
vector<pair<int,int>> G[MAXN]; // 邻接表存储图

void dijkstra(int s) {
    memset(dist, INF, sizeof(dist)); // 初始化距离为无穷大
    memset(vis, false, sizeof(vis)); // 初始化所有顶点未加入S集合
    dist[s] = 0; // 源点到自身距离为0
    
    for (int i = 1; i <= n; i++) {
        int u = -1, MIN = INF;
        // 找出当前未确定最短距离的顶点中距离最小的顶点u
        for (int j = 1; j <= n; j++) {
            if (!vis[j] && dist[j] < MIN) {
                u = j;
                MIN = dist[j];
            }
        }
        if (u == -1) break; // 如果找不到该顶点说明所有顶点都已加入S集合
        vis[u] = true; // 将顶点u加入S集合
        // 对u的所有出边进行松弛操作
        for (auto e : G[u]) {
            int v = e.first, w = e.second;
            if (!vis[v] && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        G[u].push_back({v, w}); // 建图
    }
    int s; // 源点
    cin >> s;
    dijkstra(s);
    // 输出源点到每个顶点的最短距离
    for (int i = 1; i <= n; i++) {
        cout << dist[i] << " ";
    }
    return 0;
}
```

### 5.2 Floyd-Warshall 算法代码
```cpp
const int INF = 0x3f3f3f3f; // 无穷大
const int MAXN = 105; // 图的最大顶点数

int n, m; // n表示顶点数,m表示边数  
int dist[MAXN][MAXN]; // dist[i][j]表示顶点i到j的最短距离

void floyd() {
    // 初始化距离矩阵,不直接连通的顶点