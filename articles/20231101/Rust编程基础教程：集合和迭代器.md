
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 集合（Collections）

在计算机科学中，集合（collection）是一个抽象的数据类型，它包括元素、顺序关系及元素间的各种关系。集合又分为两类：

1. 有序集合：有序集合中的元素有固定的顺序，比如说数组、链表等；
2. 无序集合：无序集合中的元素没有固定顺序，比如说哈希表、树形结构等。

不同类型的集合都可以用来存储不同的数据类型，如数字、字符串、元组等。不过，集合和其他数据类型一样，也是一种类型系统的一部分，其定义、操作和用法也遵循着一套统一的规则。

## Rust 中的集合

Rust 的标准库提供了丰富的集合类型，包括数组 `Vec<T>`、`VecDeque<T>` 和切片 `&[T]`，以及哈希表 `HashMap<K, V>`、双端队列 `LinkedList<T>` 和 btree 数据库 `BTreeMap<K, V>` 。其中 `Vec`、`VecDeque` 和切片都是有序集合类型，而 `HashMap`，`LinkedList` 和 `BTreeMap` 是无序集合类型。另外，还有一些类型的实现不属于集合类型，如栈 `Vec<T>` 或 `std::process::Output` 。

除了这些基本集合类型之外，Rust 还提供了几个特别有用的集合相关类型。首先，有一个叫做 `HashSet<T>` 的无序集合类型，它是基于哈希表实现的，可以用来存放唯一元素。第二个是 `Option<T>` ，它是一个枚举类型，有两个可能的值 `Some(T)` 和 `None`。第三个是 `Result<T, E>` ，它是一个枚举类型，有两种可能的值 `Ok(T)` 和 `Err(E)`。

这些类型将在后面的章节中逐一介绍。

## 迭代器（Iterator）

迭代器（iterator）是 Rust 中重要的抽象概念。迭代器的作用是访问集合中的元素，并依次访问每个元素。具体来说，它是一个惰性计算的对象，只有在被要求时才会计算下一个元素。迭代器可以通过不同的方法来创建，包括函数 `iter()`、`into_iter()`、`iter_mut()`、`keys()`、`values()`、`enumerate()`、`zip()`、`cycle()`、`repeat()`、`skip()`、`take()`、`filter()`、`flat_map()` 和 `chain()` 。

可以使用 for 循环或其它流程控制语句来对迭代器进行遍历。对于已知长度的集合，例如数组、切片等，for 循环可读性较高；对于未知长度的集合，则需要借助 while 循环或其它流程控制语句，或者调用 `.next()` 方法来获得下一个元素。

对于某些特定的迭代器，还有一些方法可用。例如，`Iterator::sum()` 可用于求和，`Iterator::max()` 可以找到最大值，`Iterator::any()` 可以判断是否存在满足条件的元素，等等。

# 2.核心概念与联系

## 集合与迭代器

集合与迭代器是 Rust 中的两个主要概念。集合表示一系列值，迭代器表示一种计算方式，能够按需生成值序列。集合和迭代器之间最著名的联系莫过于 Rust 语言中的 for 循环，用它来迭代集合中的元素。

由于 Rust 强大的类型系统，任何集合类型都可以隐式转换为相应的迭代器类型。比如，数组 `[1, 2, 3].iter()` 将返回一个迭代器，该迭代器会产生数组 `[1, 2, 3]` 中的每一个元素。当然，也可以显式地调用 `IntoIter` trait 来获取相应的迭代器。

```rust
let v = vec![1, 2, 3];
let it = IntoIter::into_iter(v); // it: std::vec::IntoIter<i32>
```

## 函数式编程与集合

函数式编程（Functional Programming，FP）是一种编程范式，它将计算视为对数据的映射和变换。很多 FP 技术都与集合和迭代器有关。

### 惰性求值与迭代器

惰性求值（Lazy Evaluation）是 FP 中的一个重要概念。顾名思义，就是当表达式被求值的时候才计算其结果，而不是立刻求出所有值。惰性求值的好处在于，只有实际需要的值时才会被计算出来，这样就减少了内存的占用，提升运行效率。

Rust 中的迭代器正是采用惰性求值的手段，只有在被要求时才会计算下一个元素。这样做的好处在于，可以实现惰性求值的递归算法，而不需要显式地编写循环。

例如，斐波那契数列就可以通过迭代器的方式写成如下形式：

```rust
fn fibonacci() -> impl Iterator<Item=u64> {
    let mut prev = 0;
    let mut curr = 1;

    iter::once(prev)
       .chain(
            iter::from_fn(move || {
                std::mem::swap(&mut prev, &mut curr);
                Some((curr))
            })
        )
}
```

上述函数返回一个实现了 `Iterator` trait 的匿名闭包，并在首项前加了一个预先计算的 `Some(prev)` 。这个函数用到了 Rust 提供的 `iter::once()` 函数和 `iter::from_fn()` 函数，它们分别创建一个只含单个元素的迭代器，以及一个由回调函数生成值的迭代器。

这个迭代器是一个惰性求值的算法，它的首项和下一项之间的关系仅在被要求时才会被计算出来。这就是为什么 `fibonacci()` 返回的是一个匿名闭包而不是直接返回斐波那契数列的原因。

### 流水线与迭代器

流水线（Pipeline）是 FP 中另一个重要概念。它把多个函数组合起来，形成一条链式调用的函数序列。流水线的输出是输入到最后一个函数的值。流水线的好处在于，方便地进行数据处理，而且函数之间相互独立，易于维护和测试。

Rust 中的迭代器同样可以作为流水线中的一环。例如，可以通过迭代器流水线对数组进行排序：

```rust
let a = [4, 2, 7, 9, 3];
a.iter().cloned().sorted().collect::<Vec<_>>(); // returns [2, 3, 4, 7, 9]
```

这种用法利用到了 Rust 提供的 `sorted()` 方法，它会产生一个新迭代器，包含输入迭代器中的元素按照升序排列后的结果。为了产生正确的结果，需要指定 `cmp` 参数，否则默认按照 lexicographical order 进行排序。