
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 什么是回文串？
回文串(palindrome)是指正读反读仍然一样的字符串，比如："racecar"、"civic"等。
回文串是一种特殊的字符串，它从前往后阅读和从后往前阅读的内容完全相同，例如："level"就是回文串，"noon"也是回文串。
## 为何要判断回文串？
对于一些应用场景，如信息检索、搜索引擎、网络流量分析等，都需要对文本进行大量的处理，其中就包括字符串匹配。特别是在搜索引擎的垂直搜索中，对用户输入的内容进行匹配是非常重要的，而判断一个字符串是否为回文串则成为关键的一环。
## 如何判断回文串？
判断一个字符串是否为回文串，最简单的方式莫过于逐个字符比较大小。但是这样的时间复杂度为O(n^2)，不仅效率低下而且不可扩展。因此需要利用数学的知识来做到高效的判断。
### 方法一：暴力法（双重循环）
由于时间复杂度太低，因此很少使用此方法。
```python
def is_palindrome(s):
    n = len(s)
    for i in range(n//2):
        if s[i]!= s[n-1-i]:
            return False
    return True
```
### 方法二：中心扩散法
此方法利用两个指针，一个指向头部，一个指向尾部。当两个指针相遇时，说明该字符串是一个回文串；如果在某个位置上，左边的指针向右移动一步，右边的指针向左移动一步，那么这个字符串也是一个回文串。这种算法的时间复杂度为O(n)，即线性扫描整个字符串一次。
```python
def is_palindrome(s):
    left, right = 0, len(s)-1
    while left < right:
        if s[left]!= s[right]:
            return False
        else:
            left += 1
            right -= 1
    return True
```
### 方法三：拓展中心法
此方法与中心扩散法类似，但在中间增加了一个判断条件，如果当前字符与其相邻的字符相同，那么就跳过这一层继续判断，使得算法更加高效。这种算法的时间复杂度还是O(n)。
```python
def is_palindrome(s):
    left, right = 0, len(s)-1
    while left < right:
        # 如果当前字符与其相邻的字符相同，跳过这一层继续判断
        if s[left] == s[right] and (right - left <= 2 or s[left+1] == s[right]):
            left += 1
            right -= 1
        else:
            return False
    return True
```
### 方法四：Manacher算法
此方法是20世纪60年代提出的一种回文串判定算法，它的主要思想是用动态规划的方法求解。算法的时间复杂度为O(n)。Manacher算法比其他算法更快更精确，所以经常被用于实际生产环境。
```python
def manacher(s):
    t = '#' + '#'.join(list(s)) + '#'    # 在每个字符两侧添加分隔符
    p = [0] * len(t)                        # 初始化p数组
    center, right = 0, 0                     # 初始化中心下标center和右端点right
    max_right = 0                           # 最大右端点

    for i in range(len(t)):                 # 从左至右扫描每个字符
        if i < right:                       # 如果当前字符在右端点之内，则令p[i]等于p[2*center-i]
            p[i] = min(right-i, p[2*center-i])

        # 求出以当前字符为中心的回文半径
        while t[i-p[i]-1:i+1] == t[i-p[i]+1:i+p[i]+2][::-1]:
            p[i] += 1                      # 根据公式更新回文半径

        # 更新中心及最大右端点
        if i+p[i] > right:                   # 更新最大右端点
            center, right = i, i+p[i]       # 更新中心下标center和右端点right

        max_right = max(max_right, right)     # 更新最大右端点

    # 把p数组中存储的距离转化成最终结果
    res = []                                # 初始化结果列表
    for i in range(len(s)):                 # 从左至右遍历每个字符
        k = 2*(right-i)+1                    # 以第i个字符为中心时的回文半径
        if k >= len(res)*2:                  # 当距离超过已知的最大距离时，结束
            break                            
        elif k % 2 == 0:                      # 判断是否为奇数
            res.append(k//2)                  
    
    return res                              # 返回结果列表
```