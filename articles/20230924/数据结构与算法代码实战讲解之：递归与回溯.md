
作者：禅与计算机程序设计艺术                    

# 1.简介
  

“数据结构与算法”系列是计算机领域一个热门话题。它是许多领域（例如计算机科学、通信工程等）的基础课程。我作为一名经验丰富的程序员，对于这个话题也有一些自己的理解。

在实际应用中，使用递归函数或回溯法解决问题往往比直接用循环节省很多时间。这次的主题就是通过对递归和回溯两个算法进行介绍，帮助读者实现更多的应用。

## 1.1 为什么要学习递归与回溯？
递归和回溯是两种重要的算法。当我们分析一个问题时，如果发现这个问题具有分治性质，而且在划分子问题的过程中需要保存一些中间状态，那么就考虑使用递归或回溯算法。

下面通过一个经典的例子来说明为什么要学习递归与回溯。

## 1.2 斐波那契数列
前面说过，递归就是指将一个复杂的问题分成多个子问题，再从每个子问题出发，逐层求解，最后综合得到完整的结果。斐波那契数列就是典型的使用了递归的例子。

假设我们想计算第n个斐波那契数，可以把这个问题拆分成两步：
1. 如果n等于1或者2，那么斐波那契数列只有这两个元素；
2. 否则，我们可以认为第n-1个数是由前两个斐波那契数相加得来的。

因此，我们可以通过递归的方式来计算斐波那契数列：

	fib(n) = fib(n-1) + fib(n-2)，n > 2
	
初始条件：fib(1) = 1; fib(2) = 1；

代码实现如下：

	int fib(int n){
	    if (n == 1 || n == 2){
	        return 1;
	    } else {
	        return fib(n - 1) + fib(n - 2);
	    }
	}

这个函数的效率非常高。但是，当n很大的时候，这个函数的时间复杂度就会达到O(2^n)。所以，为了提高效率，一般会采用备忘录的方法来优化这个函数。

## 1.3 使用递归的方式求解组合数C(n,m)
另一个关于递归的经典案例就是求解组合数C(n, m)。

C(n,m)表示从n个物体中取出m个物体的所有可能的组合方式。通常来说，我们会先排好序，然后从左边界向右移动，直到剩下m个物体为止。

求解C(n,m)可以这样做：

	C(n,m) = C(n-1,m) + C(n-1,m-1) 

初始条件：C(i,j) = i*j   for 1 <= i <= j <= n

代码实现如下：

	int C(int n, int m){
	    if (m == 0 || m == n){
	        return 1;
	    } else {
	        return C(n-1,m) + C(n-1,m-1);
	    }
	}

同样地，这个函数的时间复杂度也很高，达到了O(2^n)。所以，为了更快的计算，我们需要进行一些改进。

## 1.4 改进方法：记忆化搜索
为了降低时间复杂度，我们可以使用记忆化搜索的方法。这种方法的基本思路是记录下所有已经计算过的组合方式，避免重复计算。

举个例子，假如我们需要计算C(7,4)。我们首先计算C(6,4),然后计算C(6,3),C(6,2),C(6,1)。再来计算C(5,4)。由于C(6,1)=1，我们只需要计算C(5,2)、C(5,3)。

因此，我们可以定义一个数组mem[]，用来存储已经计算过的组合方式。每当计算新的组合方式时，我们先检查mem[i][j]是否已经计算过。如果是，则直接返回结果；如果没有，则计算并存入数组，然后返回结果。

如下所示的代码实现：

	int mem[MAXN+1][MAXN+1]; // mem[i][j]表示从i个物体中选出j个物体的组合方式。
	
	void init(){
	    memset(mem, -1, sizeof(mem));
	}
	
	int C(int n, int m){
	    if (m < 0 || m > n){
	        return 0;
	    }
	    if (m == 0 || m == n){
	        return 1;
	    } 
	    if (mem[n][m]!= -1){
	        return mem[n][m];
	    }
	    
	    int res = C(n-1,m) + C(n-1,m-1);
	    mem[n][m] = res;
	    return res;
	} 
	
这个函数的时间复杂度降低到了O(nm)。