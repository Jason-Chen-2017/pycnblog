
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


在计算机科学中，拓扑排序(Topological Sorting)是一个经典且重要的问题。在工程应用中，有些问题具有多种解决方案。例如，有序度约束优化、电路布线、任务调度等都可以用拓扑排序来进行求解。

首先，我们应该明白什么是拓扑排序？它是对有向图的顶点的一种排列顺序，使得每条边的两个端点都出现在一个顶点之后。这里的“顶点”可以是一个对象或者事件，比如结点、任务等；“有向图”则指的是节点之间的有向关系，比如任务之间的依赖关系等。

其次，为什么需要拓扑排序？因为很多图结构的数据处理或分析任务要求我们先对图做预处理工作，如排序、删除、合并等，而这些都是基于图论的算法的。对于复杂的网络流量、生产活动、任务依赖图等，要想清楚它们之间的数据依赖关系及相互影响因素，并以此制定优化策略，就需要对图做拓扑排序，从而把它们组织成有序的序列或结构。

最后，本文将以非常生动活泼的方式来带领大家理解拓扑排序算法，并通过代码实例与讲解，将复杂的拓扑排序算法推广到实际应用场景中，帮助读者加强对拓扑排序算法的理解，巩固自己的数据结构与算法基础功底。
# 2.核心概念与联系
## 拓扑排序算法
拓扑排序（英语：Topology sort）是指对一个有向无环图（DAG, Directed Acyclic Graph）中的所有顶点进行排序。它的基本思想是从某个指定的节点出发，按照图中各个顶点间的先后关系，依次访问每个顶点。若不存在回路（即该路径上存在循环），则输出这个节点及其邻接的顶点，然后转入下一个没有被输出的顶点，直至所有顶点均已输出。否则，如果发现回路，则无法进行拓扑排序，因此拓扑排序也称作无回路图的排序。

拓扑排序的基本方法是通过DFS（深度优先搜索）实现的，在遍历时，对图进行排序的方法为从一个顶点出发，只访问一次其邻居，不断地往深层走，直到访问完所有的顶点，然后再返回到前面的节点继续访问。当访问完某一节点的所有邻居时，将其标记为“已访问”，并放入栈中。等到栈为空时，说明已经访问完所有顶点了，此时的排序结果就是拓扑排序。

由于DFS是一种深度优先搜索，所以适用于DAG结构。然而，对于一般的有向图来说，可能存在多个有向回环，这种情况下拓扑排序是无法完成的。为了解决这个问题，可以先对图进行处理，将有向回环的部分删除掉。但如果图中还有其他不确定的点，那么拓扑排序就会失败。

## 有向无环图（DAG, Directed Acyclic Graph）
> 一幅图是由顶点和边所构成的，其中每条边都是有方向的，并且不存在回路（即从任何顶点到达另一个顶点，必经过中间的一个顶点）。即：有向无环图=带权有向图+不含自环

## 关键路径
> 在一个有向无回路图（DAG）中，关键路径是所有顶点中最长的简单路径。它是完成全部工作所需时间的上界。

## DAG-DFS拓扑排序算法
DAG-DFS拓扑排序算法是一种基于DFS的拓扑排序算法，其步骤如下：

1. 从DAG中选取一个没有前驱的顶点并输出
2. 对该顶点的每一个出边，判断它是否指向了DAG中已被访问过的顶点，若是，则说明这个顶点的前驱顶点已经被访问过了，则将当前顶点的入度减一，否则说明这个顶点还没有被访问过，则将其加入栈中
3. 当栈为空时，则说明所有顶点都已经被输出，输出完毕，结束算法。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 3.1 DFS拓扑排序算法
### 3.1.1 概念
DFS（Depth First Search，深度优先搜索），又叫做搜寻算法、树搜索算法、宽搜法。它是一种图形算法，用来找出图或者树中从指定结点可达的所有顶点，同时记录并输出他们的访问顺序。

当DFS遍历树或图时，会先访问其根结点，然后依次访问该结点的各子孙结点，直到访问完整个树或图。DFS算法的时间复杂度是$O(|V|+|E|)$,其中|V|表示顶点个数，|E|表示边的个数。

### 3.1.2 操作步骤
#### 3.1.2.1 初始化操作
从任意一个结点开始DFS，设该结点为第一个访问的结点，将其标记为已访问，初始化空列表stack。

#### 3.1.2.2 DFS操作
从栈stack中弹出一个结点u，并标记为已访问，对u的所有未访问的邻居结点v进行遍历，对于每个邻居结点，判断该结点是否已被访问过，若否，则将其压入栈stack，同时将该邻居结点标记为已访问。

#### 3.1.2.3 返回操作
将当前正在访问的结点p压入栈stack。

### 3.1.3 实现步骤

1. 定义DFS函数，参数为目标顶点start。
2. 将start标记为已访问。
3. 创建空栈stack。
4. 进入while循环，条件是栈stack不为空。
   a. 弹出栈顶元素，记为node。
   b. 如果node没有被访问过，则执行node的入度计数器减一。
   c. 如果node的入度计数器变为零，则将其输出。
   d. 对node的每个邻居结点neigh进行以下操作：
      i. 如果neigh没有被访问过，则将neigh压入栈stack。
      ii. neigh标记为已访问。
5. 函数返回。

#### python示例实现

```python
def dfs(graph, start):
    visited = [False] * len(graph) # 是否被访问过的数组
    stack = []

    def _dfs(node):
        if not visited[node]:
            visited[node] = True

            for neighbour in graph[node]:
                if not visited[neighbour]:
                    _dfs(neighbour)
            
            stack.append(node)
            
    _dfs(start)
    
    return stack
```

#### 测试代码

```python
>>> graph = [[1, 2], [3], [], [2]]
>>> topological_sort = dfs(graph, 0)
>>> print(topological_sort) #[0, 3, 1, 2]
```

### 3.1.4 DAG-DFS拓扑排序算法
DAG-DFS拓顶算法是在DFS拓扑排序算法的基础上扩展得到的，其特点是该算法在构建栈的时候，遇到了环，则停止搜索。若DAG中存在环，则说明存在着拓扑序不唯一的情况。

> 非DAG图一定不是拓扑排序，如果一个DAG图中存在环，则一定不能进行拓扑排序。

## 3.2 拓扑排序过程模型

### 3.2.1 证明过程
假设$T_{xy}$表示顶点$x$在拓扑序中位于顶点$y$之前。根据定义，$T_{xy}=x$或者$y$。如果$T_{xy}=x$，则$x$在$T_{yx}$中，也就是说$x$在$y$之前。同样，如果$T_{yx}=y$，则$y$在$T_{xy}$中，也就是说$y$在$x$之前。

因此，$T$中所有的顶点都满足如下关系：

$$\begin{cases}
T_{xy}=x\\
T_{xy}=y\\
T_{yz}=z\quad \text{(即$y$在$z$之前)}\Leftrightarrow T_{zy}=z\quad \text{(即$z$在$y$之前)}\\
\end{cases}$$

我们知道，若$w$在$x$之前且$w$在$y$之后，则$w$在$T$中必定在$x$之前，这样的$w$最多只有$o(n)$个，因为只有在$T$中的$n$个顶点才能构成$n$条边。因此，$T$的最大长度不会超过$n$。

综上，$T$是一个有序序列，而且序列中的每个元素都是$1,2,...,n$的子集。

### 3.2.2 进一步证明
设$G=(V,E)$为有向无回路图，$u\in V$。则$T$中$u$之后的顶点均只能以$u$的入射点为起点进行排序。也就是说，$u$没有定义好它的排位。

考虑以$u$作为源点的单源最短路径$d^+(u),d^-(u)$，它们分别沿着其入射点和出射点进行排序。然后把$d^+(u)$中除$u$外的所有顶点$v$拿出来，并把第$k$小的顶点作为$u$的排位，使得它在$T$中的位置为$\min\{k+d^+(u)_v,n\}$，$n$为$V$的大小。如果$\max\{d^+(u)_v,d^-(u)_v\}>1$，说明存在一个新的排位点，我们只需在$\min\{k+\sum_{i=1}^k\alpha_id^+(u)_i+d^+(u)_{n-k},n\}$中找到最小值即可，$\alpha_i$表示$(v,v')$的权重，表示从$v$到$v'$的路径的数量。注意，这个定义不能保证最终能够产生正确的排序，但肯定能给出一个有效的初步估计。

# 4.具体代码实例和详细解释说明
## 4.1 Kahn算法求关键路径
Kahn算法是一种解决有向图的关键路径（Critical Path）问题的算法。该算法在每一次迭代中，都会确定某个顶点的出度，并将有向边按权值递增的次序排列起来。若顶点$u$的出度等于$1$，且$u$的前驱顶点$v$存在一条权值为$w$的有向边直接连接到$u$，则将$w$的期望值赋给顶点$u$，并将其压入栈中。

每次从栈中弹出一个顶点$u$，则将其所有后继顶点$v$标记为“已处理”，并对$v$的每一个邻居顶点$w$，若$w$的出度减去$1$等于$0$，则将$w$标记为“已处理”，并计算$w$的期望值，并将其压入栈中。重复以上操作，直到栈为空，此时完成拓扑排序。

### 4.1.1 算法流程

#### 4.1.1.1 初始化
输入：有向无回路图$G=(V,E)$。

创建一个列表，将所有顶点的入度赋值为0。

创建一个字典，key为每个顶点，value为该顶点的所有后继顶点。

#### 4.1.1.2 执行Kahn算法
从队列$Q$中取出一个顶点$u$。

若$u$的出度等于$0$，则将其加入到已处理的顶点集合$S$中。

否则，对于$u$的每一个邻居顶点$v$，且$u$存在一条权值为$w$的有向边连接到$v$，则修改$u$的入度，即令$d_u^{in}-=1$。

并将顶点$v$加入到队列$Q$中。

重复以上操作，直到$Q$为空，且已处理的顶点集合$S$中所有顶点的出度都不等于$0$，此时算法结束。

#### 4.1.1.3 获取关键路径
对于输出结果中的每个顶点$u$，计算其最大入度为$d_u^{in}$的顶点，记为$C_u$，那么有$C_u$的前驱顶点就是$u$的前驱顶点，而$C_u$的后继顶点就是$u$的后继顶点。

遍历所有关键路径上的顶点$v$，记录其出度为$d_v^{out}$，$v$的后继顶点记为$D_v$。

对于$v$，其对应的前驱顶点$u$，计算其权值$t_uv$为$d_v^{in}-d_u^{out}$。

构建所有边$(C_v,v)$的带权值。

求所有边$(u,v)$的权值$c_uv$的最小值，并将其作为$u$的出度，再求该值，以此类推，直到所有边权值都得到确定。

获取完毕。

#### 4.1.1.4 例子


给定课程的集合$C=\{A,B,C,D,E\}$，课程之间的先修关系如下：

$$A:B$$

$$B:\overline{AC},C$$

$$C:BC,D$$

$$D:BE,CD$$

$$E:\overline{DE},ED$$

求$C$的关键路径。

由Kahn算法求出$C$的拓扑排序为$C_v$，所以有：

$$C_A=A,C_B=B,C_C=C,C_D=D,C_E=E$$

由于课程$A$，$B$，$C$，$D$和$E$都是该课程的第一节课，所以它们的关键路径分别为：

$$C_A=C_A+\overline{C_B}$$

$$C_C=\min\{C_C+C_B,C_D+C_B\}$$

$$C_D=C_D+C_B+C_C$$

$$C_E=C_E+\min\{C_E+C_D,C_E+C_D+C_D\}$$

然后计算每个顶点的出度和相关的信息：

$$d_A^{in}=0,d_A^{out}=1,e_A^{AB}=0$$

$$d_B^{in}=1,d_B^{out}=2,e_B^{\overline{AC}}=-2,e_B^{AC}=0$$

$$d_C^{in}=2,d_C^{out}=2,e_C^{BC}=1$$

$$d_D^{in}=2,d_D^{out}=2,e_D^{BE}=0,e_D^{CE}=1$$

$$d_E^{in}=1,d_E^{out}=2,e_E^{\overline{DE}}=-1,e_E^{DE}=1$$

利用图论计算可以得到$C$的关键路径长度为3。