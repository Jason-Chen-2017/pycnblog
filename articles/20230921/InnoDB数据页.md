
作者：禅与计算机程序设计艺术                    

# 1.简介
  

InnoDB存储引擎是MySQL默认的数据库引擎，它的特点是支持ACID事务、行级锁和外键完整性约束、MVCC多版本并发控制、数据字典缓存、查询优化器、自适应哈希索引、插入缓冲区等功能。因此，InnoDB对于高性能、高并发访问的场景十分重要。本文首先简要介绍一下InnoDB的整体架构及其主要模块。然后，将介绍InnoDB存储引擎的页结构，介绍页的两种组织方式，页类型(B+树索引页、分裂页、undo页等)，并详细阐述InnoDB存储引擎的索引管理机制。最后，详细介绍InnoDB存储引擎对事务的支持、锁的实现、空间管理、崩溃恢复等方面。
# 2.基本概念术语
## 2.1.B+树索引
B+树是一种高度平衡的索引数据结构，能够快速地找到一个节点内的数据。InnoDB存储引擎使用的是B+树作为主键索引、辅助索引、聚集索引和非聚集索引的实现之一。
在InnoDB中，所有的数据都存放在表空间文件中，而表空间又由段(segment)、区(extent)和页(page)组成。InnoDB表以页为单位读写磁盘，每个页大小为16KB，页可以视为磁盘块的集合。在InnoDB中，索引页也是一个逻辑上的概念，即索引数据不再保存在单独的文件或表中，而是以页的形式存在于主数据页里。
## 2.2.页结构
InnoDB存储引擎的页结构如下图所示:

如上图所示，InnoDB的页包含了一些固定格式的数据，其中包括头部信息(header)、用户数据、目录项(directory entry)、FIL头信息(file header information)。其中，用户数据部分用于存放真正的用户数据；目录项则用来存放指向相邻数据的指针；FIL头信息记录了当前页面的状态以及一些其他信息。头部信息中包括当前页面是否为空、页面类型、页号、相邻的前驱和后继页面等。在用户数据区域中，InnoDB还用一个隐藏字段隐藏了事务ID，该字段用来帮助进行MVCC读写。
## 2.3.页类型
InnoDB存储引擎把页面分成不同的类型，根据页面的功能不同，它们可以进一步划分为以下几种类型：
1. B+树索引页：用于维护B+树索引结构的页面。
2. 分裂页：当一个数据页（数据量超过一定限值）被修改时，如果需要继续修改的话，就会在当前页创建一个新的分裂页。
3. undo页：用于保存已经提交的 undo log 的页面。
4. 数据字典页：包含了数据字典信息的页面，比如表定义信息、列信息、索引信息等。
5. 插入缓冲区页：由于MySQL的写入速度远低于磁盘的速度，为了提高写入效率，InnoDB存储引擎提供了一种页级的缓存，即插入缓冲区（insert buffer）。

除了以上几类页面之外，还有很多系统表空间中的页面类型，例如：预读页面(read ahead page)、事务执行日志(transaction execute log)等。

## 2.4.页组织
### 2.4.1.聚簇索引
InnoDB存储引擎按照主键顺序物理存放数据，因此每张表只有一个聚集索引（Clustered Index），并且这个索引就是主键索引。InnoDB的聚集索引要求主键的值唯一且不能有空值，如果没有定义主键，InnoDB会自动选择一个唯一且不可为空的唯一键作为主键索引。
聚集索引的优点是查找数据非常快，缺点是插入新数据需要移动数据，需要处理可能出现的页分裂。

### 2.4.2.非聚集索引
InnoDB存储引擎允许给某些列创建索引，但不是所有的列都需要建立索引。这些不需要索引的列称为非聚集索引（Secondary Indexes），它包含普通的索引列和另外的非索引列。非聚集索引中的数据不按照索引列的顺序存放，而是以散列的方式存放。所以查找数据的时候需要从索引列对应的B+树查找页中取出相应的行记录数据。

#### 2.4.2.1.主键索引
在InnoDB存储引擎中，主键索引指的就是聚集索引，而且主键列只能是一列。这种索引的好处是在查找数据时非常迅速，因为它只需要扫描一棵B+树就能找到主键对应的行记录数据，而且主键列是聚集索引的唯一标识符，具有唯一性、不重复性，是一种索引组织形式。

#### 2.4.2.2.辅助索引
除了主键索引，InnoDB存储引擎还允许创建普通的辅助索引。一般情况下，除了主键索引外，其他的辅助索引都会被建在主键列的上面。这种索引的好处在于，通过辅助索引查询数据比直接通过聚集索引查询数据更快。

#### 2.4.2.3.联合索引
联合索引也是通过多个列组合构建的，但是联合索引的目的是为了保证索引的唯一性，并且一次查询可以利用多个索引列来定位数据，而不是仅仅使用其中一列。

### 2.4.3.回滚段
InnoDB存储引擎使用Undo段来实现事务的原子性，也就是说，如果某个事务回滚，那么它所做的所有修改都可以进行回滚。Undo段里面有一个链表，保存着所有已经完成的事务的修改信息，每一条修改信息都可以回滚到原来的状态。每条修改的信息都是一行Undo Record，包含了事务编号、回滚指针、事务修改的各个字段的值、下一条修改的位置等。

### 2.4.4.插入缓冲区
插入缓冲区是一个磁盘上的缓存，它用来临时存储那些满足条件的数据。如果某个事务要向表中插入一行数据，InnoDB存储引擎并不会立即将该数据写到磁盘，而是先暂时存放在插入缓冲区中，待事务提交时才统一写入磁盘。这样可以减少随机写，提升插入的效率。

### 2.4.5.压缩页
InnoDB存储引擎可以对页的数据进行压缩，减少磁盘占用空间。采用压缩功能之后，每张表都有一套独立的压缩算法配置。通常情况下，压缩后的页占用的空间应该小于原始页的空间。

# 3.索引管理机制
## 3.1.索引创建
InnoDB存储引擎支持两种类型的索引，分别是主键索引（Primary Key Index）和辅助索引（Secondary Index）。

### 3.1.1.主键索引
主键索引是在每张表中必须存在的，它必须包含所有的主键列，并且不能有任何重复的值。同时，主键索引的名称一般叫做 PRIMARY KEY。

### 3.1.2.辅助索引
InnoDB存储引擎允许给某些列创建索引，但不是所有的列都需要建立索引。这些不需要索引的列称为非聚集索引（Secondary Indexes），它包含普通的索引列和另外的非索引列。非聚集索引中的数据不按照索引列的顺序存放，而是以散列的方式存放。所以查找数据的时候需要从索引列对应的B+树查找页中取出相应的行记录数据。

一般情况下，除了主键索引外，其他的辅助索引都会被建在主键列的上面。这种索引的好处在于，通过辅助索引查询数据比直接通过聚集索引查询数据更快。

除了手动创建索引之外，InnoDB存储引擎也可以通过分析器自动创建索引。

## 3.2.索引维护
### 3.2.1.插入删除更新
当对数据进行插入、删除或者更新时，InnoDB存储引擎都会自动维护相关的索引数据结构。具体来说，当插入或者更新一行数据时，InnoDB存储引擎会先搜索该行对应的聚集索引树，如果找到了相应的叶子节点，那么就修改该节点中的数据；否则，就需要搜索这个范围内的最左边的叶子节点，并根据叶子节点所在的页面情况，将新的数据插入到这个最左边的叶子节点，并进行分裂操作。

当删除一行数据时，InnoDB存储引擎也会维护相关的索引数据结构。具体来说，当删除的一行数据对应的叶子节点只有一个关键字值时，那么InnoDB存储引擎会直接删除该节点；否则，InnoDB存储引擎会重排索引数据结构，使得关键字值连续的两个节点合并成一个节点。

### 3.2.2.空间管理
为了避免浪费空间，InnoDB存储引擎采用了页的方式对数据进行存储，每张表都对应一个索引页（聚集索引页或非聚集索引页），这些页按照一定的规则放置在磁盘上，并按需分配。当一个索引页满了的时候，会申请一个新的页面，然后把当前页面中的数据复制到新的页面中，并重新插入到B+树中。这样一来，就可以保证一个页内的数据量不会过大，保持数据较为密集。此外，InnoDB存储引擎还提供了压缩功能，来降低数据页的物理空间需求，从而减少磁盘空间的开销。

# 4.事务支持
## 4.1.事务概述
事务是数据库中重要的概念，它确保了一组数据库操作成功地执行或者全部不执行。事务具有4个属性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。这四个属性保证事务的完整性，让数据库操作始终保持一致性。

在关系型数据库中，事务分为显式事务和自动事务。显式事务是应用层通过BEGIN、COMMIT、ROLLBACK等语句显式启动、提交或回滚事务；自动事务是指数据库自己决定什么时候开启事务，什么时候提交事务。

在InnoDB存储引擎中，事务的实现是基于 redo log 和 undo log 的。redo log 是 InnoDB 引擎特有的日志，作用是保证事务的持久性。当事务对数据进行修改时，会先写 redo log ，然后再更新内存。如果系统发生宕机，可以通过 redo log 中的数据恢复丢失的数据。

而 undo log 用于实现事务的回滚操作，当事务的执行结果发现错误时，可以根据 undo log 恢复到事务开始之前的状态。

## 4.2.事务隔离级别
InnoDB存储引擎提供4种事务隔离级别，分别是READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。

### 4.2.1.READ UNCOMMITTED
READ UNCOMMITTED隔离级别最大的问题就是可能读取到脏数据，也就是另一个事务尚未提交的数据。

### 4.2.2.READ COMMITTED
READ COMMITTED隔离级别下，一个事务只能看到自己最近的一个事务提交的数据，其他事务的提交无法影响当前事务的提交，也就是说，一个事务的读取操作只能看到该事务提交后的最新数据，InnoDB存储引擎默认的事务隔离级别就是READ COMMITTED。

### 4.2.3.REPEATABLE READ
REPEATABLE READ隔离级别下，一个事务只能看到自己初始SELECT给出的准确结果，InnoDB存储引擎通过MVCC（多版本并发控制）解决了REPEATABLE READ隔离级别下同一行数据被修改的并发问题。

### 4.2.4.SERIALIZABLE
SERIALIZABLE隔离级别下，所有的事务都完全串行化执行，也就是说，当一个事务执行时，其他事务都无法并发执行。这往往对性能影响比较大，比较耗费资源，一般很少使用。

## 4.3.死锁
InnoDB存储引擎处理死锁的方法是检测超时，如果等待时间超过设置的时间限制，则判定为死锁。检测超时的方法可以是系统定时检测，也可以是每隔一段时间检查一次。

# 5.锁管理
## 5.1.锁粒度
InnoDB存储引擎支持行级锁和表级锁，并且两种锁都可以在不同级别上进行加锁。InnoDB存储引擎的行级锁是通过间隙锁（Gap Locks）和共享锁（Share Locks）来实现的。

### 5.1.1.行级锁
行级锁是InnoDB存储引擎的默认锁机制，表示只针对一个行记录进行加锁。在一次事务中，只能对同一个记录加共享锁或互斥锁，不能同时兼顾两者。行级锁能大大减少锁冲突，提高并发度。

### 5.1.2.表级锁
表级锁是锁住整个表的意思，整个表结构的变动将导致锁的释放和获取。表级锁分为两种类型：全局共享锁（S）和全局排他锁（X）。除此之外，InnoDB存储引擎还支持意向锁（Intention Locks）。意向锁是用来判定在某个事务是否有可能修改某个数据。在InnoDB存储引擎中，INSERT INTO... SELECT...语句的执行过程与DELETE FROM... WHERE...相同，它们都会用到意向锁。

## 5.2.锁算法
InnoDB存储引擎提供了几种锁算法，包括Record Locks、Gap Locks、Next-Key Locks、Insert Intention Locks等。

### 5.2.1.Record Locks
Record Locks是InnoDB存储引擎最基本的锁算法，表示对一条记录加锁。其基本思想是只锁住需要的记录，不锁住不必要的记录。Record Locks的加锁粒度最小，但开销也最小，是性能和并发度之间的一个折中方案。

### 5.2.2.Gap Locks
Gap Locks是InnoDB存储引擎使用的一种算法，表示对范围内的记录加锁，但不锁住记录本身。比如，如果对一个范围[A,B]的记录加锁，会阻塞记录A和B之间所有的记录的插入、更新和删除操作。

### 5.2.3.Next-Key Locks
Next-Key Locks是记录锁和gap锁的结合。其是InnoDB存储引擎使用的算法，表示对某条记录加共享锁和gap锁，防止其他事务插入到该范围内。Next-Key Locks的加锁策略可以阻止其他事务插入到指定范围内的记录，但不阻止插入范围外的记录。

### 5.2.4.Insert Intention Locks
Insert Intention Locks是InnoDB存储引擎用于插入语句的一种锁。在INSERT INTO... SELECT...语句的执行过程中，InnoDB存储引擎会根据SELECT语句生成的查询计划来确定插入操作的目标页，并对该页加Insert Intention Locks。直到语句结束，该页上的Insert Intention Locks才会释放。

## 5.3.死锁检测和处理
InnoDB存储引擎支持死锁检测和死锁处理。当检测到死锁时，InnoDB存储引擎会中断其中一个或几个事务，并返回一个错误，应用程序可以根据错误码识别死锁并采取适当的策略处理死锁。

# 6.空间管理
## 6.1.数据页组织
InnoDB存储引擎把数据按页存储，页大小为16KB，可以看作是磁盘块的集合。对于普通的索引页，其类型为INODE PAGE，对于数据页，其类型为DATA PAGE。InnoDB存储引enger的每个数据页都有自己的头部信息，其中包括页号、页面类型、事务ID等。

数据页的内容有用户数据和数据字典信息，其中数据字典信息用于描述数据页的信息。用户数据部分用来保存真实的数据。

## 6.2.页分裂与填充
### 6.2.1.页分裂
当数据页的剩余空间小于用户数据的大小时，InnoDB存储引擎就会申请新的页，将数据页分裂为两个相邻的新页。分裂页中的数据与原数据页中的数据组成了一个链表，该链表由PAGE HEADER信息中的NEXT PAGE指针连接。

### 6.2.2.页填充
当创建的新数据页中没有可供插入的数据时，InnoDB存储引擎就会向页面添加一些填充字节，以保证新页面中能够容纳更多的用户数据。

## 6.3.压缩页
InnoDB存储引擎支持页压缩功能，通过对页数据进行压缩，可以减少磁盘的空间占用，从而提升性能。

# 7.崩溃恢复
## 7.1.数据恢复模式
InnoDB存储引擎支持三种数据恢复模式：异步、生成快照、归档。

### 7.1.1.异步恢复
InnoDB存储引擎的异步恢复模式下，数据恢复工作是在后台线程完成的。因此，应用客户端发起请求后，服务器立刻返回响应信息，而数据恢复过程会在后台线程完成。

异步恢复模式下的优点是简单，且对数据一致性没有影响。不过，若数据库关闭期间发生了崩溃，可能会造成部分数据丢失。

### 7.1.2.生成快照
InnoDB存储引擎的生成快照模式下，会在事务提交时生成一个热备份。快照可以包含事务开始之前的数据，但不包含其他事务的提交数据。

生成快照模式下，不会影响事务的执行和应用客户端的查询，且对数据一致性也没有影响。不过，它占用了更多的磁盘空间，并且在数据库运行过程中，会产生额外的开销。

### 7.1.3.归档
InnoDB存储引擎的归档模式下，会在事务提交时将数据写入归档文件，而不会更新磁盘上的数据文件。当数据库关闭时，它会使用归档文件恢复数据。

归档模式下，不会影响事务的执行和应用客户端的查询，且对数据一致性也没有影响。但由于数据是以归档的方式存放的，故当数据量过大时，它占用的磁盘空间可能较大。

## 7.2.崩溃恢复过程
当InnoDB存储引擎因系统原因或用户命令导致崩溃时，InnoDB存储引擎会停止服务，并将当前内存中的脏数据刷新到磁盘，生成数据文件的一个临时副本。当系统重新启动时，InnoDB存储引擎会校验文件头信息，确认是否是有效的InnoDB文件。如果是，则加载临时副本到内存，并执行重做日志中的事务。

InnoDB存储引擎启动后，首先运行的是redo log 的回滚操作，用于恢复因系统崩溃而丢失的数据，然后依次运行undo log 的回滚操作，用于撤销在当前事务中已做的修改。

Redo Log 的回滚操作是根据 RedoLog 中的事务信息，将相关的 undolog 操作倒序执行，以回滚数据。Undo Log 的回滚操作，是根据 UndoLog 中的事务信息，将相关的 RedoLog 中未提交的操作取出来，撤销掉即可。

当 InnoDB 存储引擎重新启动之后，将 Redo Log 中所有事务的提交记录同步到磁盘中，即完成数据恢复过程。