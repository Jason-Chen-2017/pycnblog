
作者：禅与计算机程序设计艺术                    

# 1.简介
  

现代计算机系统中，数据的存储、组织形式有很多种方式。队列和栈都是经常使用的两种数据结构，对其进行有效的应用可以使得系统运行效率得到提升。
本文将详细介绍这两个数据结构在实际应用中的基础概念、结构及原理。并用C++语言基于数组的方式实现了队列和栈的算法。通过示例代码演示如何使用这两种数据结构以及各种算法。希望能够帮助读者更好的理解数据结构与算法，增强编程能力，提高工作效率。
# 2.基本概念及术语
## 队列
队列（queue）是一个先进先出的数据结构。在队列里面的元素，只能从队首(rear)端进入，从队尾(front)端退出。它具有以下特点：

1. FIFO (First In First Out):新元素必须排在队列之前。也就是说，当一个新的元素被加入到队列的时候，这一元素必须排在其他的元素之后。
2. 只允许在队尾添加元素(rear)，只允许在队头删除元素(front)。
3. 操作受限。仅允许在队尾添加元素和在队头删除元素。


## 栈
栈（stack）也是一个先进后出的的数据结构。不同于队列，栈只能在栈顶(top)端添加元素，只能在栈底(bottom)端删除元素。它具有以下特点：

1. LIFO (Last In First Out): 最新加入的元素会先被移除。意味着，最后一个加入的元素总是在最前面，而第一个被移除的元素则是最后一个被添加的元素。
2. 操作受限。只能在栈顶添加元素，只能在栈底删除元素。


## 双端队列
双端队列（deque，double-ended queue），又称作“回文队列”，它是一种两端都可以进行插入和删除操作的队列。该队列具有以下特征：

1. 支持双向操作：即可以从队列的左右两端插入或删除元素。
2. 使用方便：不需要像栈和队列一样定义两套函数，只需要一套双端队列相关函数就可以完成所有的操作。
3. 可扩展性好：可以很容易地进行动态扩充或缩小。

## 数组
数组（array）是由相同类型的元素组成的顺序集合，所有元素按照一定顺序排列。数组有以下几个重要属性：

1. 一维数组：即单行的一维数组。
2. 二维数组：即多行且同样数量的元素的二维数组。
3. 多维数组：即多行且每个元素也可以是多维数组的三维数组，以此类推。
4. 有序数组：数组元素可以按照一定的顺序排列。
5. 不变数组：数组大小不能改变。

# 3.队列和栈的结构
## 数组实现
### 队列
#### 入队操作(enqueue operation)
数组实现队列的入队操作，有两种方案：

1. 从队尾位置开始存放元素，新元素放在数组最后一个位置；
2. 如果队列满了，就必须申请一个新的更大的数组，把旧数组中的元素全部复制到新数组中，然后再把新元素放到新数组的末尾。这种方法的开销比较大，而且频繁申请内存还可能导致内存碎片。因此，一般不采用这种方法。

在数组实现的队列中，当空间已满时，就会产生溢出(overflow)异常，告诉调用者队列已满。需要处理这种情况，比如通过抛出异常或者通过提供另外的接口，让调用者自己判断队列是否已经满，然后采取相应的措施。

```c++
class Queue {
    private:
        int front = -1; // 队头指针
        int rear = -1;  // 队尾指针
        const int SIZE = 100; // 最大容量
        int arr[SIZE];      // 队列数组
    
    public:
        void enqueue(int value){
            if(isFull()) throw "Queue overflow!";
            rear = (rear + 1)%SIZE;
            arr[rear] = value;
        }
        
        bool dequeue(){
            if(isEmpty()){
                return false;
            }else{
                front = (front + 1)%SIZE;
                return true;
            }
        }

        bool isEmpty() { 
            return front == rear && front == -1; 
        }

        bool isFull() { 
            return ((rear+1)%SIZE == front); 
        }

        int peek() { 
            if(!isEmpty()) 
                return arr[(front + 1)%SIZE];  
            else   
                return -1; 
        }
};

// Example usage of the above class 
Queue q; 

q.enqueue(10);  
q.enqueue(20);  
q.enqueue(30);  

cout << q.peek();   // Output: 10 

while (!q.isEmpty()) { 
    cout << q.dequeue();  // Output: 10 20 30 
} 

q.enqueue(40);  

if (q.isFull()) { 
   cout << "Queue full"; 
 }
```

#### 出队操作(dequeue operation)
数组实现的队列的出队操作，返回队首元素的值，并修改队头指针指向下一个元素位置。如果队列为空，则返回-1。

```c++
int deque() {
    if(isEmpty()) return -1;
    int temp = arr[front];
    front = (front + 1)%SIZE;
    return temp;
}
```

### 栈
#### 压栈操作(push operation)
数组实现栈的压栈操作，将新元素放置于栈顶元素的下一个位置上。如果栈满了，则产生溢出异常。

```c++
void push(int value){
    if(isFull()) throw "Stack overflow!";
    top++;
    stack[top] = value;
}
```

#### 弹栈操作(pop operation)
数组实现栈的弹栈操作，返回栈顶元素的值，并减少栈顶指针。如果栈空了，则返回-1。

```c++
int pop() {
    if(isEmpty()) return -1;
    int temp = stack[top];
    top--;
    return temp;
}
```

## 链表实现
### 队列
#### 入队操作(enqueue operation)
链表实现队列的入队操作，通过创建一个节点对象，并将其插入到队尾处。

```c++
struct Node {
    int data;
    struct Node* next;
};

void enqueue(int value){
    if(isFull()) throw "Queue overflow!";
    struct Node *temp = new Node;
    temp->data = value;
    temp->next = NULL;

    if(head == NULL) head = tail = temp;
    else{
        tail->next = temp;
        tail = temp;
    }
}
```

#### 出队操作(dequeue operation)
链表实现队列的出队操作，首先将队首节点的值保存起来，然后将队首指针指向下一个节点，释放掉队首节点所占用的内存。

```c++
bool dequeue(){
    if(isEmpty()) return false;
    struct Node* temp = head;
    head = head->next;
    delete temp;
    return true;
}
```

### 栈
#### 压栈操作(push operation)
链表实现栈的压栈操作，也是通过创建一个节点对象，并将其插入到栈顶处。

```c++
void push(int value){
    if(isFull()) throw "Stack overflow!";
    struct Node *temp = new Node;
    temp->data = value;
    temp->next = top;
    top = temp;
}
```

#### 弹栈操作(pop operation)
链表实现栈的弹栈操作，将栈顶节点的值保存起来，然后将栈顶指针指向下一个节点，释放掉栈顶节点所占用的内存。

```c++
int pop() {
    if(isEmpty()) return -1;
    int temp = top->data;
    struct Node* delNode = top;
    top = top->next;
    delete delNode;
    return temp;
}
```