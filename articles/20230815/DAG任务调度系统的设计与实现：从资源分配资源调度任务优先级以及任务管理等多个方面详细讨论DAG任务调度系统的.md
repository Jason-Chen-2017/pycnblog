
作者：禅与计算机程序设计艺术                    

# 1.简介
  

DAG（Directed Acyclic Graph）任务调度系统（英语：Directed Acyclic Graph scheduling），又称有向无环图调度系统，通常指一种依赖关系图形化表示法，描述了一个任务依赖关系的图形结构，其中每一个节点表示某种类型的任务，每个箭头代表一种依赖关系，依赖方向表明了数据流动的方向，而箭头的方向则是相对于任务的执行顺序而言的。

按照维基百科上的定义，DAG任务调度系统是一个用于处理有向无环图（DAG）调度问题的计算机程序或设备。DAG中每个节点表示一个任务，该任务可能是需要计算的，也可能是不需要计算的。如果某条路径上存在回路，那么该路径中的任务将会发生死锁（deadlock）。

DAG任务调度系统可以用来解决各种调度问题，如作业调度、流水线资源管理、高性能计算集群的任务调度、金融交易所的订单处理、图形渲染等。

在当今企业应用中，作为数据中心管理、云计算平台基础设施建设的重要组成部分，DAG任务调度系统也扮演着越来越重要的角色。

# 2.基本概念术语说明
## 2.1 有向无环图（DAG）
DAG 是 Directed Acyclic Graph 的缩写，即有向无环图。它是一种对多重图形进行分类的标准方法。其特点是，由顶点和边组成，其中顶点表示工作的活动（task），边表示活动之间的依赖关系，依赖关系的方向表示了工作的流向。一个无环图就是不存在任何回路的图。如下图所示：


有向无环图（DAG）具有以下特征：

1. 每个顶点都是一个独立的工作单位，并且可以并行执行。
2. 有向性：从顶点 a 到顶点 b 表示工作 a 依赖于工作 b 。因此，该图是一个有向的图。
3. 环：回路是指两个工作之间相互依赖而不能完成的情况。例如，A -> B -> C -> D -> E -> F -> A 就构成了一个回路。
4. 强连通性：即所有顶点都可以直接或者间接地与其他顶点建立连接。

## 2.2 图的度（Degree）
度（degree）是一个图论中的概念。在一个图 G 中，顶点 v 的度表示连接到 v 这个顶点的边的数量。度也可以定义为顶点 v 对其他顶点的度之和，也就是说，v 的度等于该顶点到其他顶点的权值的和。

度的直观解释：对于顶点 v ，度是指与 v 直接相连的顶点个数；若 v 是奇数度的，则称为 odd-degree 顶点；若 v 是偶数度的，则称为 even-degree 顶点。

## 2.3 拓扑排序（Topological Sorting）
拓扑排序（topological sorting）是指对一个有向无环图 (DAG) 的所有顶点进行排序，使得前面的顶点优先于后面的顶点，且整个过程满足序列。

例如，有向无环图 G=(V,E)，顶点 V={A,B,C,D,E}，边集 E={(A,B),(A,C),(B,D),(C,D),(C,E)}。此时拓扑排序的结果为：D->C->E->B->A。

拓扑排序的一个重要用途是给出任意一个有向无环图的线性顺序，因为只有这样才能保证图的所有顶点都能被访问一次。另外，还可以用于判断一个图是否有回路（不满足拓扑序）。

# 3.核心算法原理及操作步骤
DAG任务调度系统一般采用多种算法和模型来模拟、优化和实现任务调度。这里主要讨论两种最常用的算法：Greedy Best First Search 和 Preemptive Greedy Best First Search。

## 3.1 Greedy Best First Search
Greedy Best First Search（GBFS，又称贪婪最优搜索算法）是一种简单但有效的任务调度算法。

GBFS 从某个初始状态出发，在决策树层次上沿着距离当前最优目标的节点选择下一步行动的路径。在每一次迭代过程中，GBFS 都会选择距离目标最近的节点进行扩展，直到所有的可达节点都已经被访问过，或者找到了一个可以满足约束条件的最优解为止。

GBFS 的步骤如下：

1. 将初始节点放入“已发现”集合。
2. 对于“未发现”集合中的每个节点 n，计算它的各项启发值，并根据启发值从小到大的顺序放入“候选”队列。
3. 取出队首元素 n，标记为“已发现”，并将其邻居加入“未发现”集合。
4. 如果所有可达节点都被访问过，则停止；否则转至步骤 2。

GBFS 使用的是启发式策略，仅考虑了节点的紧凑程度，而不是它的整体价值。它主要适用于静态环境、对抗攻击和有限计算资源的场景。

## 3.2 Preemptive Greedy Best First Search
Preemptive Greedy Best First Search（PGBS）是 GBFS 在实践中遇到的限制导致的改进版本。PGBS 可以兼顾效率与准确性。其基本思想是在节点选择时引入抢占机制，防止出现无效任务。

PGBS 首先依照 GBFS 进行普通节点选择，然后进行抢占操作。抢占分两种情况，一种是新到来的任务与现有的任务交替执行，另一种是抢占正在运行的任务。

具体步骤如下：

1. 初始化已发现集合为空集，候选队列为空，任务集合为空，活跃时间和截止时间均为 0，空闲资源量为所有资源容量之和。
2. 将初始任务 t 插入到任务集合 T，设置其截止时间为 $t_{end}$ ，将初始资源设置为 t 需要的资源，设置 t 为当前任务，置 t 在活跃时间为 0 。
3. 循环执行：
    - 根据启发函数 H 选取候选任务 c_best，并将其置入“候选”队列。
    - 检查“未发现”集合，查找能够满足当前任务需求的最佳任务 n_best，计算其抢占时间 p_time。
    - 把 t 置为 n_best ，将其截止时间设置为 $min(n_best_{end},c_best_{start}-p_time)$ 。
    - 更新活跃时间，将 n_best 从“未发现”集合移到“已发现”集合，并将 n_best 放入到任务集合 T ，将 n_best 设置为当前任务，置活跃时间为 0 。
    - 若当前任务 t 可抢占，则进行抢占操作：
        - 计算 t 剩余运行时间 r_time，计算新到来任务 u 的截止时间 c_u 。
        - 如果 c_u >= t_{end} + r_time，则把 c_u 设置为 $t_{end}+r_time$ 。
        - 删除 t 自身，将 u 添加到任务集合 T 中，更新 t_{end} 、截止时间、资源量等属性。
        - 记录抢占日志。
4. 当所有任务结束时结束循环。

# 4.具体代码实例与解释说明
待补充。。。