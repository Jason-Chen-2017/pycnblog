
作者：禅与计算机程序设计艺术                    

# 1.简介
         
1979年，贝尔丝·斯托芬鲁普(<NAME>)发表了著名的“C++和对象技术”论文，对C++语言的基础语法、数据结构、类和对象等进行了全面系统的阐述。近几十年来，随着C++作为高级编程语言在工程应用中的广泛接受，学习C++的读者越来越多，但是对于那些从事C++开发工作的人来说，了解C++的背景知识仍然是一个重要的前提。本书就是为了帮助读者理解并掌握C++的语言特性及其背后的原理，帮助读者快速熟悉C++语法和各种数据结构、算法的用法。作者通过丰富的图示、插图、动画、样例代码、练习题等方式，全面地讲解了C++的基本语法、运行机制、标准库、内存管理、运算符重载、面向对象编程等方面的知识，并且提供了大量的实例来展示这些知识的实际作用。通过阅读本书，读者可以更好的理解和掌握C++语言的各个特性及其实现原理，同时也能够在实际项目中运用所学知识解决问题，提升自己技能水平。
         本书适合具有一定编程经验的读者阅读，包括但不限于C/C++语言的初学者、有一定编程经验的工程师、技术人员。本书将从语言的起源、运行机制、数据类型、语句控制、表达式求值、函数、数组和指针、类和对象、异常处理、文件输入输出、字符串和字符串处理、动态内存分配、模板、联合体、位域、递归、迭代器、模板元编程等各个领域，深入浅出地剖析C++的核心语法及其原理。通过阅读本书，读者可以轻松掌握C++的基本语法、数据结构和算法、面向对象的基本概念、内存管理、运算符重载、文件输入输出、字符串处理等常用功能，同时具备独特的思维能力和学习能力，成为进一步提升自我竞争力、锻炼综合能力的优秀工具。
         2.目录
         # 第一章 语言的起源（Introduction）
         1. 计算机科学的历史回顾
         - 计算机发展的历史与进程
        由于人们对计算机科学的发展过程都很陌生，所以让我们先从计算机科学的历史回顾来看一下。从古到今，信息技术的发展史可以分为三条脉络：冯·诺依曼体系、计算机程序设计的出现、网络通信的发明。这三个方面互相交织，影响着计算机科学的发展历程。
         - 冯·诺依曼体系：从二进制机（即二极管电路）发展而来的“机器语言”，定义了计算机的硬件结构、指令编码方式、数据表示方式、程序执行方式；
         - 计算机程序设计的出现：出现了编译程序的概念，使程序员可以用他们熟悉的高级语言，直接编写机器指令代码，生成可以被计算机识别和执行的文件；
         - 网络通信的发明：用晶体管打造的网络互连设备催生了Internet，它促进了计算机之间的数据传输和计算，也引导了后续的分布式系统的形成。从上述三个方面看，当时的计算机科学分工明确，各司其职，彼此之间没有互相依赖性，是一台巨大的整体。
           1. 开发语言的需求：随着计算机科学技术的进步，计算机程序越来越复杂，越来越难以处理和维护。因此，计算机科学界和其他学科一样，产生了一种新的需求：需要一种新的编程语言来支持快速、有效地解决复杂的问题。
           2. “C语言”的诞生：为了满足这样的需求，1969年1月，约翰·洛克菲勒和丹尼斯·里奇在贝尔实验室共同开发了一个新的编程语言——“C语言”。“C语言”既可以在不同的计算机平台上移植，又可以在系统调用和操作系统接口上访问底层资源。“C语言”提供的“低级”控制机制和“高级”抽象机制，在很大程度上简化了程序员的编程负担，加快了编程速度。1973年，“C语言”被国际标准化组织ISO正式采用。
           - 语言的分类：按照目前流行的命名规则，按照历史发展顺序，“C语言”可以划分为两类：
             - 命令式语言（Imperative programming language）：命令式编程语言，它通过一系列的命令来指示计算机完成某项任务，比如赋值、条件判断和循环控制。每一条命令都要经过解释器的编译和执行才能得到结果。像C、Pascal等命令式编程语言都属于这一类。
             - 函数式语言（Functional programming language）：函数式编程语言，它将计算视为数学上的函数，将函数作为第一类对象，函数可以接收输入并返回输出，函数之间通过参数传递数据。像Lisp、Haskell、ML等函数式编程语言都属于这一类。
           3. “C++”的创造：在“C语言”的基础上，1983年，比尔·盖茨和路易斯·爱泼斯坦合作，在贝尔实验室继续开发“C++”语言。“C++”与“C”类似，都是由低级控制机制和高级抽象机制构成，但是“C++”引入了面向对象编程的特性。1983年10月，“C++”被国际标准化组织ANSI正式采用。“C++”增加的面向对象编程特性，使得程序员更容易编写健壮、可扩展的代码。“C++”的开发经历，标志着一个重要的里程碑。
         # 第二章 运行机制（Execution model）
         1. 程序执行流程：计算机程序从磁盘加载到内存运行的流程如下：
           1. 编译阶段：C/C++编译器把源代码编译成目标代码，其中包含了机器代码和汇编代码。
           2. 链接阶段：链接器把多个目标代码合并成一个可执行文件。
           3. 执行阶段：加载到内存中并执行的程序称为虚拟机（Virtual Machine）。虚拟机对代码进行解释和执行。
           4. 栈空间：在程序运行过程中，会在内存中开辟一个区域用来存放函数调用栈（call stack），用于存储函数的参数和局部变量等。栈空间由编译器自动分配和释放。
           5. 数据空间：程序运行时，会在内存中开辟一个区域用来存放全局变量、静态变量、堆栈变量等。数据空间由编译器自动分配和释放。
           通过以上分析，我们知道，程序执行过程中需要经历编译、链接、执行三个阶段，然后再在内存中开辟相应的空间供程序运行使用。
           - 主函数main()：
              在执行程序时，首先是调用main()函数，它是整个程序的入口点。只有main()函数才是真正的程序的入口，其他函数只能通过调用来间接进入程序，并最终返回至main()函数。
              main()函数是程序的第一段代码，通常包含一些初始化工作、命令行参数解析、创建窗口或控件、调用其他函数等。
              如果希望一个可执行文件既可以独立运行，也可以被其他程序调用，则必须在main()函数之前添加一些预处理指令，让编译器忽略掉main()函数的内容，防止其被编译到可执行文件中去。
         # 第三章 数据类型（Data types）
         1. 基本数据类型：C++语言有八种基本数据类型：整数型int、浮点型float、双精度型double、字符型char、逻辑型bool、指针型pointer、数组型array、枚举型enum。其中，整数型int和浮点型float的大小根据不同平台而定。
           1. 整数型int：int类型是最常用的整数类型，其长度一般为32位或64位。int类型可以存储整数、无符号整数、带符号整数。int类型可以表示的范围比short类型、long类型大得多。
           2. 浮点型float：float类型是单精度浮点型，它的大小和float相同。
           3. 双精度型double：double类型是双精度浮点型，它的大小是单精度浮点型的两倍。
           4. 字符型char：char类型代表一个ASCII码字符，占1个字节。
           5. 逻辑型bool：bool类型只有两种取值：true或者false。
           6. 指针型pointer：指针类型指向另一片存储单元的内存地址，它的值是一个地址值，可以用来存放地址。
           7. 数组型array：数组类型是一个固定数量的元素组成的序列，每个元素都有一个唯一的索引，可以通过下标的方式访问。
           8. 枚举型enum：枚举类型是自定义类型，它允许用户定义一个集合。枚举类型的值只能是集合内定义的特定值。
           - 类型转换：类型转换是指将一种数据类型的值转换成另一种数据类型的值。在C++语言中，类型转换可以通过static_cast<>、dynamic_cast<>、const_cast<>和reinterpret_cast<>()四种方式实现。其中，static_cast<>是最常用的类型转换方法。
         2. typedef关键字：typedef是C++提供的一个新的关键字，它可以给已存在的数据类型取一个新名称。
           使用typedef关键字定义一个数据类型别名，可以简化代码，增强代码的可读性和可维护性。如下示例代码：
           ```c++
           // before using typedef
           int x = 10;
           double y = static_cast<double>(x);

           // after using typedef
           typedef int INT;
           INT x = 10;
           double y = static_cast<double>(x);
           ```
         # 第四章 语句控制（Statements and flow control）
         1. if-else语句：if-else语句是条件语句，它可以基于布尔表达式的值，决定执行哪个分支的语句。
           1. if语句：if语句是最简单的条件语句，它只会在布尔表达式的值为true时执行指定的语句。
           2. else语句：else语句是在if语句之后，如果布尔表达式的值为false，则执行该语句。
           3. else if语句：else if语句是可选的，如果有多个分支条件，可以使用else if语句。
           4. switch语句：switch语句可以实现多分支条件选择。
           5. constexpr语句：constexpr语句是在C++11引入的，它可以声明一个常量表达式，它的值在编译期间就能确定，而不是在运行期间确定。
           - 执行顺序：C++语言中的语句通常按顺序执行，除非遇到跳转语句或终止语句，否则从上到下执行。
         2. while语句：while语句是循环语句，它会重复执行语句块，直到指定的条件为false。
           - do-while语句：do-while语句也是循环语句，它会先执行一次语句块，然后再判断条件是否为true，如果为true，则继续执行语句块，否则跳出循环。
           1. for语句：for语句是一种特殊形式的循环语句，它有三个表达式，初始化表达式、循环条件表达式、更新表达式，它们分别在每次循环开始之前、每次循环结束时以及每次循环开始时执行。
           - break语句：break语句可以立即退出当前循环，继续执行循环后的语句。
           - continue语句：continue语句可以立即结束本次循环，开始下一次循环。
           - goto语句：goto语句可以在代码中设置一个标签，然后转到指定位置执行，goto语句非常危险，应谨慎使用。
         # 第五章 表达式求值（Expression evaluation）
         1. 算术运算符：C++语言支持的所有算术运算符包括+、-、*、/、%、+=、-=、*=、/=、%=、++、--。
           1. 加法运算符+：+用于两个数相加。
           2. 减法运算符-：-用于两个数相减。
           3. 乘法运算符*：*用于两个数相乘。
           4. 除法运算符/：/用于两个数相除。
           5. 模ulo运算符%：%用于两个数相除的余数。
           6. 复合赋值运算符：+=、-=、*=、/=、%=用于累加、累减、累乘、累除、累加的赋值。
           7. 前置/后置运算符：++、--可以作为前缀或后缀运算符，用于对变量进行递增、递减操作。
           - 结合律：在C++语言中，所有运算符的结合律都遵循左结合原则，也就是说，如果有括号包围的表达式，则计算括号中的表达式，然后再计算整个表达式。
         2. 比较运算符：C++语言支持的所有比较运算符包括==、!=、>、>=、<、<=。
           1. 等于运算符==：==用于判断两个值是否相等。
           2. 不等于运算符!=：!=用于判断两个值是否不相等。
           3. 大于运算符>：>用于判断第一个值是否大于第二个值。
           4. 大于等于运算符>=：>=用于判断第一个值是否大于等于第二个值。
           5. 小于运算符<：<用于判断第一个值是否小于第二个值。
           6. 小于等于运算符<=：<=用于判断第一个值是否小于等于第二个值。
           - 返回值：所有比较运算符均返回值为bool型。
         3. 逻辑运算符：C++语言支持的所有逻辑运算符包括&&、||、!。
           1. 短路逻辑运算符：短路逻辑运算符如&&和||在计算过程中，如果前面的表达式已经能够确定结果，则不会继续执行后面的表达式。
           2. 逻辑非运算符！：!用于反转表达式的值，如果表达式的值为true，则变为false；如果表达式的值为false，则变为true。
           - 执行优先级：与运算符 && 和 || 具有相同的优先级，即它们从左往右计算，但是! 的优先级比 &&、|| 高，所以如果! 操作符前面出现 && 或 || ，则需要加括号。
         4. 赋值运算符：C++语言支持的所有赋值运算符包括=、*=、/=、%=、+=、-=、<<=、>>=、&=、^=、|=。
           - 链式赋值：C++还支持链式赋值，可以将多个赋值语句连在一起执行。例如：a = b = c = 10;
           - 自增/自减运算符：++i 表示 i = i + 1，--i 表示 i = i - 1。它们可以放在变量、数组元素、指针偏移量的前面或后面，分别表示自增或自减变量、数组元素、指针偏移量的值。
         5. 函数调用：C++支持通过函数名来调用函数。
           - 参数传递：函数调用时，可以传入任意类型的参数，包括整型、浮点型、字符型、指针型、数组型等。
         6. 类型转换：C++语言支持通过类型转换来改变变量的数据类型，包括强制类型转换static_cast<>、const_cast<>、reinterpret_cast<>和dynamic_cast<>()。
           - 显式类型转换：将一种类型的数据转换为另外一种类型的数据，需要使用static_cast<>()进行显式类型转换。
           - const_cast<>()：const_cast<>()用来移除const修饰符，使变量的常量性变成非常量，这样可以修改其值。
           - reinterpret_cast<>()：reinterpret_cast<>()用来重新解释变量的存储格式，这个操作非常危险，需要格外小心。
           - dynamic_cast<>()：dynamic_cast<>()用来执行运行时类型检查，转换子类指针或基类的引用为派生类的指针或引用。
         7. 条件成员访问运算符：条件成员访问运算符?. 可以在运行时根据表达式的值来选择对象的方法或属性。
         # 第六章 函数（Functions）
         1. 函数声明：函数声明是函数定义的前半部分，声明了函数的名称、返回类型、参数列表、函数属性等。
           - extern "C"：extern "C"是C++中一个重要的扩展，用来声明C语言兼容的函数，可以隐藏函数的名称修饰符。
         2. 默认参数值：C++支持函数的默认参数值，在声明函数时可以为参数指定默认值，这样在调用函数的时候就可以省略参数值。
           - 可变参数列表：C++支持可变参数列表，可以让函数接受任意数量的参数。
           - inline函数：inline函数是另一个重要的优化技术，它可以减少函数调用的开销，提高性能。
         3. 函数重载：函数重载(overload)是指在同一个作用域内，函数的名字相同但参数个数或参数类型不同。函数重载可以提高程序的灵活性和效率，降低代码出错的可能性。
           - 重载解析：编译器根据参数类型及个数选择相应的函数进行调用。
         4. 递归函数：递归函数是指一个函数直接或者间接调用自己的函数。
           - 尾递归：尾递归是指函数最后调用自己，没有做其他操作，这种情况编译器会优化成普通的循环。
         # 第七章 数组和指针（Arrays and pointers）
         1. 一维数组：C++中，数组是拥有相同类型的元素的集合。数组可以保存若干个相同类型的值，数组的每个元素可以通过下标访问。
           - 初始化数组：数组可以用花括号{}的方式初始化，每个元素的初始值可以省略。
           - 多维数组：C++支持多维数组，它可以有多个维度，每一维的长度可以不同。
           - 数组元素的指针：数组变量名本身就是一个指针，可以用&运算符获取数组首元素的地址，并用*运算符访问数组元素。
         2. 二维数组：二维数组就是一个数组的数组，它的每个元素都是一个一维数组。
         3. 指针：指针变量保存的是内存地址，可以通过*运算符访问存储在指针变量中的值。
           - 指针数组：可以用指针数组来保存多个指针变量，每个指针指向不同的内存位置。
         4. 引用：引用变量类似于指针，区别在于它不能被赋值，只能用来访问值。
           - 指针和引用的区别：指针可以修改它指向的内存中的值，而引用无法修改，只能访问值。
         5. new/delete运算符：new/delete运算符用来动态地申请和释放内存，它们类似于malloc()/free()，不过它们不是C语言的标准函数。
           - sizeof操作符：sizeof操作符可以获得变量、数组或类的大小，单位为字节。
           - auto关键字：auto关键字用来声明变量的类型，它的类型由初始化表达式来推断。
         # 第八章 类和对象（Classes and objects）
         1. class关键字：class关键字用来定义一个新的类，可以继承现有的类或者实现一个接口。
           - 构造函数：构造函数是类的入口点，当创建一个类的对象时，就会调用构造函数来初始化对象。
           - 析构函数：析构函数是类的退出点，当对象销毁时，就会调用析构函数清理对象。
           - 友元函数：友元函数可以访问类的私有成员，不需要借助类的实例。
           - 保护成员：保护成员只能被同一类的成员函数和友元函数访问，在类的内部和外部都可以访问。
           - 普通成员：普通成员可以被类的所有成员函数访问。
           - 静态成员：静态成员属于整个类而非某个实例，不依赖于任何对象，可以被类的所有成员函数访问。
         2. 对象：对象是类的实例，每一个对象都包含自己的状态（数据成员）、行为（成员函数）和标识（this指针）。
           - 拷贝构造函数：拷贝构造函数是类的一个特殊成员函数，当用=赋值操作符复制对象时，就会调用拷贝构造函数。
           - this指针：this指针指向当前对象的地址。
         3. 抽象类：抽象类是指类中至少有一个纯虚函数的类，抽象类不能实例化，只能用来继承。
           - pure virtual function：纯虚函数是指没有实现的方法，它的定义放在类的声明和定义中，需要被类的所有派生类实现。
           - abstract base class：抽象基类是指不能创建对象的基类。
         4. 继承：继承是面向对象编程的重要特征之一，它允许创建新的类，通过重用现有类的代码来节省时间和 effort。
           - 多重继承：C++支持多重继承，可以从多个父类中派生子类。
         5. 封装：封装是面向对象编程的一项重要特点，它要求把数据和操作数据的方法绑定到一起。
           - public、private、protected：public成员可以被类外部访问，private成员只能被类的成员函数和友元函数访问，protected成员可以被类的成员函数、友元函数和派生类访问。
         # 第九章 异常处理（Exception handling）
         1. try-catch语句：try-catch语句用来处理异常，当程序执行抛出异常时，就会执行对应的catch块。
           - throw语句：throw语句用来抛出一个异常，它接受一个参数，表示要抛出的异常。
           - noexcept：noexcept用来指定函数不抛出异常。
           - 抛出自定义异常：可以派生自std::exception类，并重写what()函数来自定义异常的提示信息。
         2. 异常安全：异常安全是指函数在遇到错误时仍然保持正确性和完整性。
           - 以前的错误处理方式：当遇到错误时，应用程序可能会崩溃或导致数据的丢失。
           - 异常处理方式：使用异常处理，可以让程序在发生错误时恢复正常。
         3. 函数签名：函数签名是一个函数的名称、返回类型、参数类型和参数顺序的总结。
         # 第十章 文件I/O（File input/output）
         1. 头文件：头文件是指用来描述C/C++语言的各种实体的预编译文件。
           - include指令：include指令用来导入头文件，其作用是让源文件包含指定头文件中的定义。
         2. 文件处理函数：FILE *fopen(const char *filename, const char *mode)，打开一个文件，成功返回文件的指针，失败返回NULL。
           - fclose(FILE *fp)，关闭一个打开的文件。
           - fread(void *ptr, size_t size, size_t nmemb, FILE *stream)，从一个已打开的文件中读取指定的数据。
           - fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)，向一个已打开的文件写入指定的数据。
           - feof(FILE *stream)，检测文件是否到达了EOF。
           - ferror(FILE *stream)，检测是否发生错误。
         3. 文本文件：文本文件是一种以ASCII或UNICODE编码存储的普通文件，里面保存着文本数据。
           - fprintf(FILE *stream, const char *format,...),printf()函数的打印版本，可以向文件输出数据。
           - fscanf(FILE *stream, const char *format,...),scanf()函数的扫描版本，可以从文件输入数据。
         4. 二进制文件：二进制文件保存的数据是以二进制形式保存的，可以包含任何数据类型。
           - fputc(int c, FILE *stream)，向一个已打开的文件中输出一个字符。
           - fgetc(FILE *stream)，从一个已打开的文件中读取一个字符。
         # 第十一章 字符串和字符串处理（Strings and string processing）
         1. 字符串：字符串是指由零个或多个字符组成的有限序列。
           - 字符数组：字符数组是由字符组成的固定长度数组。
           - 字符串字面值：字符串字面值是使用""或''括起来的任意文本序列。
         2. 字符串长度：C++提供了strlen()函数来计算字符串长度。
           - strcpy(char *dest, const char *src)，strcpy()函数用来复制字符串。
           - strncpy(char *dest, const char *src, size_t n)，strncpy()函数用来复制字符串，但是仅复制n个字符。
           - strcmp(const char *s1, const char *s2)，strcmp()函数用来比较两个字符串是否相等。
           -strncmp(const char *s1, const char *s2, size_t n)，strncmp()函数用来比较两个字符串的前n个字符是否相等。
         3. 字符串操作：C++提供的字符串操作函数包括 strtok(), strcat(), strdup(), strerror(), strlen().
           - strtok(): strtok()函数用来对字符串进行分割，通过分隔符来将字符串切割成多个字符串。
           - strcat(): strcat()函数用来连接两个字符串。
           - strdup(): strdup()函数用来复制字符串到新的空间。
           - strerror(): strerror()函数用来把errno变量的值转换成一个错误消息字符串。
           - strlen(): strlen()函数用来计算字符串的长度。
         # 第十二章 动态内存分配（Dynamic memory allocation）
         1. malloc()函数：malloc()函数用来动态地分配内存，malloc()的返回值是指向新分配的内存块的指针，失败时返回空指针。
           - calloc()函数：calloc()函数用来动态地分配内存，并初始化为0。
           - realloc()函数：realloc()函数用来调整分配的内存块的大小，如果新的大小比原来大，则进行扩充，如果新的大小比原来小，则进行收缩。
         2. free()函数：free()函数用来释放内存，释放一个空指针将导致不可预知的行为。
           - delete[]操作符：delete[]操作符用来删除一个数组。
         # 第十三章 模板（Templates）
         1. 模板是C++的一项重要特性，它允许用户定义一个通用的数据类型，在这个类型上定义操作，从而实现更灵活、更强大的功能。
           - 基本语法：模板的基本语法如下：template <typename T> ……
           - 模板参数：模板参数是模板定义的一部分，它用来声明函数或者类的类型。
           - 特化：模板可以定义特化版本，特化版本是一个模板的特定实例化，它定义了一个模板的具体实现。
           - 函数模板：函数模板定义了一个操作，这个操作可以接收任意类型的参数。
           - 类模板：类模板定义了一组相关的类，这些类共享相同的行为和状态，但是它们可以有不同的类型。
         2. STL：STL是C++的一组标准模板库，包括容器、算法、迭代器和函数对象等。
         # 第十四章 联合体（Unions）
         1. 联合体是一种特殊的数据类型，它可以用来保存不同数据类型的数据。
           - 基本语法：union 标识符{类型说明符 变量名[size];};
           - 例子：union Data {int a; float b; }; Data u; u.a = 10; /* assign integer to union */
         # 第十五章 位域（Bit fields）
         1. 位域是一种特殊的数据类型，它用来表示一个或几个二进制位。
           - 基本语法：位域声明语法如下：struct 结构体名 {位域说明符 位域名 : 宽度;};
           - 例子：struct Employee{unsigned short empno:11; char name[20]:5; unsigned age:3;};/* Employee data structure*/
         # 第十六章 递归（Recursion）
         1. 递归函数：递归函数是一种函数调用自身的函数。
           - 尾递归：尾递归是指函数的最后一步调用自身。尾递归函数能优化成循环，这样可以避免栈空间的消耗，提高运行效率。
           - 例子：阶乘函数：long factorial(int n){if (n == 0) return 1;return n * factorial(n-1);}
         # 第十七章 迭代器（Iterators）
         1. 迭代器是一种用于访问容器中的元素的对象。
           - 描述性质：迭代器必须具有三个性质：dereferenceable、incrementable、decrementable。dereferenceable表示可以解引用指针；incrementable表示可以移动到下一个元素；decrementable表示可以移动到上一个元素。
           - 例子：vector<int>::iterator iter = v.begin(); (*iter)++;
         # 第十八章 类型转换（Type conversions）
         1. 类型转换是一种操作，它将一种数据类型的值转换成另一种数据类型的值。
           - static_cast<>()：static_cast<>用于执行各种显式的数据类型转换，包括转换整数值、浮点值、指针、引用、布尔值等。
           - const_cast<>()：const_cast<>用来移除常量属性，其目的是将常量的性质移除，以便修改其值。
           - reinterpret_cast<>()：reinterpret_cast<>用来重新解释变量的存储格式，这个操作非常危险，需要格外小心。
           - dynamic_cast<>()：dynamic_cast<>用来执行运行时类型检查，转换子类指针或基类的引用为派生类的指针或引用。
         # 附录A 参考文献
         [1]C++ Primer Plus, 第五版, 中国铁道出版社, 陈昊鹏, 郭凌飞, 等译, 清华大学出版社.
         [2][CppCon 2014]C++ Conference 2014 Proceedings, Santa Fe, USA, May 23–27, 2014, ISBN 978-1-4822-7531-2.