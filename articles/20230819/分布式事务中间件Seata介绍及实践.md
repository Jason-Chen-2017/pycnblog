
作者：禅与计算机程序设计艺术                    

# 1.简介
  

## 1.1 分布式事务简介
分布式事务（Distributed Transaction）是指事务的参与者、支持事务的服务器、资源服务器之间互相协作完成事务提交或回滚功能的一种处理方式。常见的分布式事务协议包括2PC、3PC、TCC、消息事务、本地消息表等。
## 1.2 Seata简介
Seata 是阿里巴巴开源的一个高可用分布式事务解决方案，致力于提供 AT、TCC、Saga 和 XA 事务型。其主要特点是 一站式解决方案，提供支持多种 RPC 框架，与 Spring Cloud、Dubbo、gRPC 等微服务框架无缝集成；采用纯 Java 开发，性能高，适合互联网公司内部系统、小项目的部署；二级索引、异步 commit、存储过程支持等更加灵活的特性。
## 1.3 为什么要使用Seata？
随着互联网业务的发展，单体应用逐渐演变为微服务架构，用户对于运维的要求也越来越高，包括系统可用性、数据一致性、容量规划、故障恢复、监控报警、慢查询分析等，这些都需要通过分布式事务进行管理。但是，分布式事务的实现和维护难度较高，往往会导致系统耦合性增强，增加运维复杂度和风险。因此，在大量采用微服务架构之后，如何实现微服务架构下的分布式事务就成为一个迫切的问题。
Seata 的出现就是为了解决这一难题。它提供一站式解决方案，能够帮助企业轻松实现微服务架构下分布式事务，并且对业务零侵入，只需简单配置即可，有效降低了开发成本。另外，其二级索引、异步 commit、存储过程等更加灵活的特性也会大幅提升分布式事务的效率和可用性。
# 2.Seata基本概念术语说明
## 2.1 全局事务 GTX （Global Transaction）
全局事务是指一个满足 ACID 的分布式事务，由一组分支事务组成。GTX 在整个生命周期内保持统一的状态。当所有分支事务都成功执行结束后，GTX 的状态被标记为 COMMITTED，反之如果任何一个分支事务失败，则状态被标记为 ROLLEDBACK。GTX 中的任意一个分支事务失败或者超时，都会导致 GTX 的状态被标记为Rollbacked。GTX 可以是跨越多个数据源的数据操作，也可以是一个数据库操作。GTX 的范围可以很大，可以跨越多个业务模块。
## 2.2 事务分支 Branch Transaction （AT模式）
分支事务是 GTX 中不同时间点上的一个动作，每个分支事务代表某一个具体的业务操作。例如，一次购买交易可能包含创建订单、支付、库存锁定等多个分支事务。GTX 会根据分支事务的执行情况来决定是否提交或者回滚。
## 2.3 服务化单元 Service Unit
服务化单元是一个可执行事务的最小单元，可以是一个服务的调用，也可以是一个消息的发布或订阅。每一个服务化单元对应一个本地事务。
## 2.4 资源长短期限 Resource Sharing Mode & Lifetime
资源共享模式（Resource Sharing Mode）和生存期限（Lifetime）表示不同时段的资源拥有者。
资源共享模式：Exclusive（独占）、Shareable（共享）、Volatile（易失）。
资源生存期限：Long（长期）、Short（短期）、Permanent（永久）。
## 2.5 柔性事务模式
柔性事务模式是指当一个分布式事务中某个分支事务因为某些原因失败，不影响其他分支事务正常提交的机制。常用的有三种模式：
- 补偿型 TCC (Try-Confirm-Cancel) 模式：用于实现 2PC 的最终一致性。Xid 事务记录在每个分支事务中，分别记录事务是否已经完成、已经提交还是取消。当某个分支事务失败时，它的任务是通过对已完成事务的预估或重试的方式来进行回滚。
- 自动生成 Undo Log 或 Redo Log 并重试型 Saga 模式：该模式下，当某个分支事务失败时，会生成一个 Undo Log ，用来反向执行已成功的事物。而其它分支事务再次尝试执行，如果仍然失败，则继续生成 Undo Log，直到所有分支事务均提交成功或者达到最大重试次数。这种模式比 TCC 模式实现更加彻底的最终一致性。
- 最大努力通知型 Message Acknowledgement 模式：该模式下，当某个分支事务失败时，只需要通知其它分支事务，自己可以安全的重试。由于不需要额外的日志机制来保证事务的可靠性，因此延时短，吞吐量高。
## 2.6 并行事务 Parallel Transaction Coordinator Coordinator
并行事务协调器，也就是 TM，是一个独立的组件，负责管理全局事务的提交或回滚。TM 根据全局事务的配置，协调多个分支事务的提交和回滚，确保全局事务的完整性。TM 使用类似 Paxos 的原子广播协议进行集群间的同步。TM 有主备两个角色，提供服务时通过主节点处理请求，备份节点做冗余。TM 还会定期的发送 Heartbeat 来检测各个分支事务的运行状态。
## 2.7 协调器 Coordinator
协调器（Coordinator）是 TM 和 RM 的组合，负责维护全局事务的提交/回滚、协调分支事务的提交/回滚、参与者的注册、配置等事务管理相关的操作。协调器只需要完成少量事务管理操作，对于业务数据的处理完全依赖 RM 。
## 2.8 分支查询 Branch Query
分支查询是指在一个事务中，为了查询某个变量的值而暂停当前正在执行的事务的一类操作。当分支事务的执行完成后，被暂停的事务可以通过数据库的快照读取到之前的值。分支查询是一种特殊的本地事务。
## 2.9 回滚策略 Rollback Strategy
回滚策略，又称重试策略，是在异常情况下，决定当某个分支事务失败时，如何进行回滚。可以是最新的一次提交前的提交版本，也可以是选择一个备份的时间点的旧值。不同的回滚策略可以获得不同的最终一致性级别。
## 2.10 本地事务 Local Transaction
本地事务（Local Transaction），又称局部事务，是一个在一个数据库引擎中的事务。事务并非是跨越多个数据库或多个应用程序，而只是在一个单机数据库引擎上执行的一组 SQL 操作。目前绝大部分的关系型数据库都提供了基于 ACID 规范的本地事务，如 MySQL InnoDB 和 Oracle，但也存在一些嵌套事务或不遵循 ACID 规范的本地事务实现。
## 2.11 两阶段提交 Two-Phase Commit (2PC)
2PC 是指在一个事务中包含两个阶段：第一阶段准备提交（Prepare Phase），第二阶段提交（Commit Phase）。其中，第一阶段是协调者对所有参与者发送提交指令，参与者执行事务提交前的准备工作。若所有的参与者都成功执行了提交前的准备工作，那么协调者将向所有参与者发出提交指令。第二阶段是参与者正式提交事务，如果发生错误，那么参与者将被降级。此时，协调者将撤销所有参与者的提交指令，回滚事务。2PC 可保证数据正确性，适用于数据库事务繁忙的场景，且性能较差。
## 2.12 三阶段提交 Three-Phase Commit (3PC)
3PC 是基于 2PC 的改进方案，在 2PC 的准备提交阶段前，引入了一个准备阶段，主要目的是让各个参与者知晓即将执行的事务提交计划，避免因网络或其他原因造成的冲突。若所有参与者准备均成功，协调者将给予 +1 的确认响应，表示事务可以提交；否则，协调者将给予 -1 的拒绝响应，表示事务无法提交。此时，参与者将终止事务的执行。3PC 可以保证严格的最终一致性，通常比 2PC 更好地利用了集群资源，但在性能上略逊色于 2PC。
## 2.13 基于Saga模型的事务处理 Transaction processing based on Saga pattern
Saga 模式是一种长事务的解决方案，采用两阶段提交来实现长事务的原子提交。Saga 模式中，参与者完成本地事务的前提下，向长事务协调器发送请求或命令，使得协调器决定事务是否要继续执行。协调器向其他参与者发送指令，协助参与者完成长事务的提交。如果参与者因网络问题或其他原因无法响应，则可以向后端系统重新发送指令，实现重试机制。Saga 模式可以保证数据最终一致性，但是也需要维护每个参与方的业务逻辑，并处理各种异常情况。
## 2.14 TCC事务模型 Transaction processing based on TCC pattern
TCC 模式是一种柔性事务模型，在 2PC 的基础上，将事务分成三个阶段，包括 Try、Confirm 和 Cancel 三个操作，其中 Try 表示预留资源阶段，Confirm 表示更新资源阶段，Cancel 表示释放资源阶段。TCC 模式适用于对异常情况敏感的业务，但会产生额外的异常日志，降低系统的性能。
## 2.15 基于MQ的事务处理 Transaction processing based on MQ messaging
基于 MQ 的事务处理是一种基于消息队列的长事务处理模型，使用分布式消息事务来保证事务的最终一致性。事务消息在消费失败时，可以进入定时重试，直到一定次数后，系统才会判断为死亡消息，并进行重试。消息消费失败时，系统会自动触发回滚操作，确保数据的一致性。基于 MQ 的事务处理模型实现简单，性能优良，适用于与业务无关的后台任务处理。
## 2.16 分布式事务 Seata 架构
Seata 的架构主要分为三层：TC（Transaction Coordinator）、RM（Resource Manager）和 TM（Transaction Manager）。其中 TC 是一个独立的服务，用来接受客户端的 TM 请求，管理全局事务的提交或回滚，并且管理 RM 上的资源分配和回收；RM 是一个独立的服务，用来管理分支事务的状态，包括提交、回滚和超时的事务，并向 TC 返回事务结果；TM 是客户端连接 TC，发起全局事务的编程接口。Seata 的架构如下图所示：

## 2.17 全局锁 Global Locks
全局锁是数据库隔离级别中最高的一种，对整个数据库加锁，阻塞其他的所有并发事务。为了防止死锁，需要设定超时时间。当一个事务持有全局锁的时候，其他事务只能排队等待，直到该事务释放全局锁。在 MySQL 中，全局锁一般用以下语句获取：
```mysql
GET GLOBAL LOCK
SELECT... FOR UPDATE
```
## 2.18 分支锁 Branch Locks
分支锁是对一组记录加锁，保证在并发环境下数据的正确性，在 MySQL 中，分支锁一般用以下语句获取：
```mysql
BEGIN;
SELECT... FOR UPDATE
COMMIT;
```
## 2.19 行级锁 Row Level Locks
行级锁是 MySQL 数据库中提供的一种对数据库中行数据进行锁定的机制，它允许在行级进行数据的读写控制，通过索引列的范围来确定需要锁定的行。在执行 SELECT 查询或者 UPDATE 更新语句时，数据库默认会按照索引顺序从上到下依次加锁，对于加锁的范围，叫做偏向锁（Next-Key Locking）。
## 2.20 RC隔离级别 Read Committed Isolation level
RC隔离级别(Read committed isolation level)是MySQL中默认的隔离级别，其定义了：一个事务开始后的查找操作，只能看见已提交事务所做的改变，不能看到未提交事务的任何变化。换句话说，一个事务要查看的数据，一个接一个地展示，不能看到其他事务还没有提交的中间结果。此外，如果一个事务已经开始了一个修改，另一个事务也试图写入同一条记录，那么只有先提交后一个事务的修改，才算是真正意义上的提交。这也是为了防止脏读，不可重复读和幻影读。

## 2.21 SI隔离级别 Snapshot Isolation level
SI隔离级别(Snapshot isolation level)是InnoDB支持的隔离级别。其定义了：一个事务开始时，会在所有涉及到的行上加行锁，其他事务无法对这些行加任何锁。而在事务提交或回滚后，才释放行锁。Snapshot Isolation 不会出现幻象读和不可重复读，但是可能会出现读脏数据。通过对数据行上一份快照来实现，因此不能完全解决写Skew的问题。

## 2.22 REPEATABLE READ隔离级别 Repeatable read isolation level
REPEATABLE READ隔离级别(Repeatable read)是MySQL的默认隔离级别。它保证同一事务的多个实例在并发读取数据时，会看到同样的数据行。InnoDB在MVCC下，通过多版本并发控制(Multi-Version Concurrency Control)，保证读取的一致性。InnoDB只在需要获取行级共享锁的情况下，才会使用行锁；其他情况下，Innodb使用的是表锁。所以对于同一张表，REPEATABLE READ隔离级别效率与SERIALIZABLE并无差别。