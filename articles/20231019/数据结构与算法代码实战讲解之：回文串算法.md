
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


回文串(palindrome)是一个具有双向性质的字符串，即从前往后阅读与从后往前阅读都是一样的字符序列。例如："racecar"就是一个典型的回文串。在本节中，我们将介绍如何判断一个给定的字符串是否是回文串，以及如何找出最长的回文子串。
## 概念定义与联系
首先我们要明确两个重要的概念：“回文中心”与“回文半径”。对于一个长度为n的字符串，它的回文中心是一个位于第n/2个位置的字符。假设回文串为s，那么它对应的回文半径rad(s)=floor((n-1)/2)。也就是说，它可以由两侧对称的相同字符组成。比如：
```
abcde     a    b   c   d   e
          / \ / \ / \ / 
         9  7  5  3  1   
 ``` 
图中的数字代表字符的ASCII码，蓝色的竖线表示中心，红色的虚线表示半径。

根据上面的图，如果一个字符串不是回文串，那么它就一定有两个相邻的字符不一样（即没有回文中心），或者有一个字符出现了奇数次，即回文半径只有奇数个。比如"abccba"这个字符串的回文半径有三个而不是偶数个。此外，还有一个更严格的定义是，只要字符串s存在一个回文半径，那么s必定是回文串。但是一般情况下，我们希望找到长度最大的回文子串，并不需要把所有的回文子串都列举出来。因此，以下讨论中，我们只考虑等长的回文串，即回文半径是偶数的情况。

## 确定性算法与非确定性算法
### 确定性算法
这是一种基于中心扩展法(Center Expansion Method)，首先构造一个中间区域，使得左右两侧的回文串间隔至少为回文半径。然后再检查两端是否满足回文串条件，若满足则说明整个串是回文串；否则继续检查中间区域是否也是回文串。直到所有可能的回文串均检查完毕。这种算法的时间复杂度为O(n^2)。
### 非确定性算法
这是一种动态规划(Dynamic Programming)方法，基于“自下而上”(bottom-up)的思想，先找到每个位置的最大回文半径，再根据最大回文半径构建回文串。这种算法的时间复杂度为O(n^2)。
## 实现代码
下面我们将展示两种算法的具体实现，并且比较它们的时间性能和空间消耗。同时，我们也会提出一些代码优化建议。
### 确定性算法的代码
确定性算法的代码非常简单，按照算法流程一步步执行即可。这里的实现只是为了演示算法原理，并不是一个优化或高效的实现。
#### Python代码实现
Python代码如下：

```python
def is_palindrome(s):
    n = len(s)
    for i in range(n // 2):
        if s[i]!= s[n - 1 - i]:
            return False
    return True


def longest_palindrome(s):
    n = len(s)
    maxlen = 1
    start = 0

    # odd length palindromes
    for i in range(n // 2):
        l, r = i, i

        while l >= 0 and r < n and s[l] == s[r]:
            l -= 1
            r += 1

        if r - l - 1 > maxlen:
            maxlen = r - l - 1
            start = l + 1

    # even length palindromes
    for i in range(n // 2):
        l, r = i, i+1

        while l >= 0 and r < n and s[l] == s[r]:
            l -= 1
            r += 1

        if r - l - 1 > maxlen:
            maxlen = r - l - 1
            start = l + 1

    return s[start:start+maxlen]
```
#### Java代码实现
Java代码如下：

```java
public class Palindrome {
    
    public static boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left)!= s.charAt(right))
                return false;
            
            left++;
            right--;
        }
        
        return true;
    }
    
    public static String longestPalindrome(String s) {
        int maxLength = 1;
        int start = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i+1);
            int len = Math.max(len1, len2);
            
            if (len > maxLength) {
                maxLength = len;
                start = i - ((maxLength - 1) >> 1);
            }
        }
        
        return s.substring(start, start + maxLength);
    }
    
    private static int expandAroundCenter(String s, int left, int right) {
        int L = left;
        int R = right;
        while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
            L--;
            R++;
        }
        return R - L - 1;
    }
    
}
```
### 非确定性算法的代码
#### Python代码实现
Python代码如下：

```python
def manacher(s):
    t = '#' + '#'.join(list(s)) + '#'
    p = [0] * len(t)
    c = r = 0
    m = None

    for j in range(1, len(t)):
        mirror = 2*c - j
        if r > j or mirror < p[j-1]:
            center = j
            k = j

            while k <= r and t[k] == t[center + k - j]:
                k += 1

            p[j] = k - j
            c = center + k - j
        else:
            p[j] = p[mirror]
            c = mirror + p[mirror]

        if p[j] > m:
            m = p[j]
            pos = c

    return t[pos - m//2 : pos + m//2].replace('#', '')
```
#### Java代码实现
Java代码如下：

```java
public class Manacher {
    
    public static String longestPalindrome(String s) {
        char[] chars = addBoundaries(s).toCharArray();
        int[][] dp = new int[chars.length][chars.length];
        int mid = getMid(dp, chars);
        
        return getMaxSubstring(s, dp, mid);
    }
    
    private static StringBuilder addBoundaries(String s) {
        StringBuilder sb = new StringBuilder("#");
        for (char c : s.toCharArray()) {
            sb.append(c).append('#');
        }
        sb.append("$");
        return sb;
    }
    
    private static int getMid(int[][] dp, char[] chars) {
        int n = chars.length;
        int maxLen = 1;
        int begin = 0;
        
        for (int i = 1; i < n-1; i++) {
            int curMaxLen = 1;
            int pre = Integer.MIN_VALUE / 2;
            int next = Integer.MAX_VALUE / 2;
            for (int j = i; j >= 0; j--) {
                if (chars[j] == chars[i]) {
                    if (pre < dp[j+1][i-1])
                        dp[j][i] = pre + 1;
                    
                    curMaxLen = Math.max(curMaxLen, dp[j][i]);
                    pre = dp[j][i];
                }
            }
            
            for (int j = i+2; j < n; j++) {
                if (chars[j] == chars[i]) {
                    if (next < dp[i+1][j-1])
                        dp[i][j] = next + 1;
                        
                    curMaxLen = Math.max(curMaxLen, dp[i][j]);
                    next = dp[i][j];
                }
            }
            
            dp[i][i] = curMaxLen;
            if (curMaxLen > maxLen) {
                maxLen = curMaxLen;
                begin = i - (maxLen - 1) / 2;
            }
        }
        
        return begin;
    }
    
    private static String getMaxSubstring(String s, int[][] dp, int mid) {
        int end = mid + dp[mid][mid] / 2;
        int start = mid - dp[mid][mid] / 2;
        int i = start;
        while (i >= 0 && end - i > dp[end][end]/2) {
            i--;
        }
        
        int j = end;
        while (j < s.length()-1 && j - start > dp[start][end]/2) {
            j++;
        }
        
        return s.substring(i+1, j);
    }
    
}
```