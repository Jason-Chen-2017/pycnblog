
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


模式匹配（pattern matching）是一种用来控制执行路径的语言机制，它在很多编程语言中都有实现。Rust语言独特的特性之一就是其强大的模式匹配能力，可以让我们写出更加简洁、可读性高的代码。本教程将会带领读者理解Rust中的模式匹配机制，并通过实际例子学习如何运用它。

# 2.核心概念与联系
## 模式
模式是一个声明语句，它描述了一个值的结构、形式或样式。在Rust中，模式由三种基本类型组成：标量、元组和分支。它们分别对应着不同的值类型——整数、浮点数、布尔值、字符、字符串等，也包括复合类型——数组、元组、结构体、枚举等。模式的语法和表达方式与其他语言的类似。例如，在Python中，可以使用“if”和“elif”语句来对不同类型的变量进行条件判断，这些条件被称为模式；而在JavaScript中，可以使用“switch”语句来实现相同的目的。

## 模式语法
在Rust中，模式有两种主要语法。第一种是绑定模式（binding pattern），用于将一个值与一个变量绑定。第二种是解构模式（destructuring pattern），用于从一个值的各个部分提取数据。接下来我们将详细介绍这两种模式。

### 绑定模式
绑定模式最简单的形式如下：`<variable> = <value>`，其中`<variable>`是新创建的变量名，`<value>`是要绑定的表达式。例如：`let x = 42;`就是绑定模式的一个例子，这里我们用`x`这个名字来表示绑定的值`42`。当模式出现在赋值号的左侧时，就隐含着创建一个新的局部变量。

绑定模式还有一种扩展形式，即允许在赋值号右边的表达式进行解构。这种扩展形式的语法为：`<variable> @= <value>`。它的作用相当于先对`<value>`的值进行解构，再对结果进行绑定。例如：`let (a, b) @= Some(42);`首先对`Some(42)`的值进行解构，得到`a`的值为`42`，`b`的值为`()`（因为元组中没有第二个元素）。然后绑定到新的局部变量`a`。

### 解构模式
解构模式使用了运算符 `@` 来分隔两个模式：`<pattern> @ <expression>`。它的作用是将一个表达式的值解构成一个或多个值，然后应用给定模式进行匹配。表达式的值可能是一个元组、结构体或者枚举。解构模式的形式支持多种不同的语法，下面我们将详细介绍。

#### 元组解构
元组解构指的是，将元组中每一个位置上的元素按照给定的模式进行匹配。比如说，假设有一个元组`(a, b, c)`，我们希望把它拆开并分别赋给三个变量。那么该怎么做呢？下面展示了两种解构模式语法：
```rust
// 使用逗号分隔模式
let (x, y, z) = t; // 对t进行解构，分别赋值给变量x、y、z

// 使用括号分隔模式
let (x, (_, y), z) = t; // 对t进行解构，将第一个元素赋值给变量x，其余元素依次赋值给变量y、z
```
第一个模式使用逗号 `,` 分隔了三个模式，因此需要解构的元组只能有三个元素。第二个模式使用括号 `(` 和 `)` 分隔了三个模式，因此元组可以有三个或更多元素。

如果解构的元组元素少于模式要求的数量，则不会产生编译错误。然而，如果解构的元�元素多余模式要求的数量，则只有模式中的元素会被匹配成功，其余的元素将被忽略。

#### 结构体解构
结构体解构与元组解构类似，只是使用的模式语法不同。结构体解构语法为：
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point{ x: 1, y: 2 };

    match p {
        Point { x,.. } => println!("({}, _)", x), // 只匹配结构体的x成员，忽略y成员
    }
    
    fn add_one((x, y): (i32, i32)) -> (i32, i32) {
        (x + 1, y + 1)
    }
    
    let q = add_one(p); // 对Point类型的值进行解构并调用函数
    
    match q {
        (new_x, new_y) if new_x == 2 && new_y == 3 => (), // 检查函数返回值是否符合预期
        _ => panic!("unexpected value"),
    }
}
```

结构体解构语法有一些限制。比如，它只能匹配命名字段，不能匹配位置字段。如果需要匹配位置字段，则只能采用元组解构语法。另外，结构体解构不能跳过任意字段。如果需要跳过某个字段，可以使用 `_` 占位符。

结构体解构还支持带表达式的模式。这种模式可以使用表达式计算所需的数据。上面的例子里，我们调用了 `add_one` 函数，它的参数是一个元组 `(p.x, p.y)`，我们将这个元组解构并传入 `add_one` 函数。然后用函数返回的新元组 `(new_x, new_y)` 与模式 `(2, 3)` 进行匹配。注意，我们还可以通过关键字 `if` 添加额外的检查。