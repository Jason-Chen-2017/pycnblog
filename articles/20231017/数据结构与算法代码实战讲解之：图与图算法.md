
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


## 一、什么是图？
在图论中，图是由节点（node）和边（edge）组成的集合，通常表示为G(V,E)。其中，V是顶点的集合，E是顶点间的连接关系的集合；一个无向图G=(V,E)是一个二元组(V,{0,1},E)，而一个有向图G=(V,A)则是一个三元组(V,{0,1},A)。
## 二、图的分类
- 简单图——由边或弧连接的两个结点称为顶点的简单图。如：完全图、不完全图、权重图等；
- 多重图——一个结点可以具有多个邻居，这种图称为多重图；
- 带权图——每个边有一个权值或费用，这种图称为带权图。一般情况下，带权图都可转换为无权图，即去掉所有边的权值，使得每个边仅有一个。
- 稀疏图——当图中的边很多时，图中某些边并不存在，这种图称为稀疏图。相反，当图中的边很少时，图也称为密集图。
## 三、图的表示方法
- 邻接矩阵法——图的邻接矩阵是指用邻接矩阵表示图。矩阵的行数等于图的顶点数，列数等于图的顶点数，对于无向图，如果两点之间存在一条边，则邻接矩阵相应位置上的值为1；对于有向图，则判断两个顶点之间的方向性，再确定相应位置上的元素值。例如：
```python
# 无向图
graph = [[0,1,1],[1,0,1],[1,1,0]]
# 有向图
digraph = [[0,1,0],[0,0,1],[1,0,0]]
```
- 邻接表法——图的邻接表是指用邻接表表示图。邻接表中存储了图中每一个顶点的邻接点的信息。在邻接表中，每个顶点对应一个链表，该链表中存储了它所连接的各个顶点及其对应的权值或费用。例如：
```python
# 无向图
graph = {
    'A': [('B', 1), ('C', 2)], 
    'B': [('D', 1)], 
    'C': [('D', 1)]
}
# 有向图
digraph = {
    'A': [('B', 1)], 
    'B': [('C', 1)], 
    'C': []
}
```
# 2.核心概念与联系
## 一、图的遍历
图的遍历就是从图中的某个顶点出发，按照图的定义，访问该顶点的所有邻接顶点，然后转到下一个没有被访问过的顶点继续访问，直至所有的顶点均被访问完毕。以下是图的遍历算法：
### 1. 深度优先搜索(DFS)：将图的邻接矩阵看作是以当前顶点为中心，四周存在或不存在的探测线段；首先选定起始顶点，标记已访问；随后沿探测线进行探查，首先往右侧探测，如果发现没有访问过的顶点则递归地对该顶点进行深度优先搜索，并将该顶点标记为已访问；若该顶点的邻居（包括自己）都被探查过，则回溯到上一级顶点，然后向左侧探测。重复以上过程，直至所有顶点均被探查完毕。
```python
def dfs_matrix(graph):
    n = len(graph)
    visited = [False]*n # 初始化访问数组
    
    def dfs(u):
        nonlocal graph, visited
        if not visited[u]:
            visited[u] = True
            for v in range(n):
                if graph[u][v]==1 and not visited[v]:
                    dfs(v)
            
    for i in range(n):
        if not visited[i]:
            dfs(i)
            
dfs_matrix(graph)    # 深度优先搜索遍历图
```
### 2. 广度优先搜索(BFS)：将图的邻接表看作是以当前顶点为中心，横向延伸出的探测线段。首先选定起始顶点，标记已访问；随后逐层进行探查，从当前层的每个顶点开始探查，对第一个发现的没有访问过的顶点进行深度优先搜索，并将该顶点标记为已访问；重复以上过程，直至所有顶点均被探查完毕。
```python
from queue import Queue 

def bfs(graph):
    n = len(graph)
    visited = [False]*n # 初始化访问数组
    q = Queue()
    q.put((0, None))   # 将起始顶点入队
        
    while not q.empty():
        u, parent = q.get()
        if not visited[u]:
            visited[u] = True
            print("Vertex", u+1, ":", end=' ')
            for v, weight in graph[u]:
                if not visited[v]:
                    q.put((v, u))
                    print("Edge", (parent+1, u+1, v+1, weight), end=' ')
                    
bfs(graph)           # 广度优先搜索遍历图
```