                 

# 1.背景介绍


在计算机科学中，图（Graph）是一种抽象数据类型，由一些顶点（vertex）组成，用边（edge）连接这些顶点。通过图可以表示复杂系统中的各种实体之间的关系、人与人的关系、物品间的物流网络等等，应用非常广泛。图的重要性不亚于数据结构的重要性。对于图的处理有很多种算法，如搜索、连通性、最大生成子图、最小支配子集等等。对于图算法的研究及其实现一直是计算机科学领域的一个热门话题，并且也吸引着各个领域的专家开发人员共同探讨。

本文将以图论的经典问题——最短路径算法——作为切入点，进行全面的图算法讲解。文章内容以通俗易懂的语言向读者展示如何利用图论解决实际问题。通过阅读本文，读者能够了解图论的基本知识，掌握基于图论的算法原理和操作方法，并能轻松地在实际场景下运用这些算法。
# 2.核心概念与联系

## 图(Graph)

1. 定义：无向图G=(V,E),其中 V 是非空集合，称为图的顶点集，E 是满足 (u,v)∈ E <=> u,v ∈ V且 u ≠ v 的二元组的集合，称为图的边集。
2. 举例：
   * G=(V={a,b,c},E={(a,b),(b,c),(c,a)}) 表示一个无向简单图，其中顶点集 V = {a, b, c}，边集 E = {(a,b),(b,c),(c,a)}；
   * G=(V={A,B,C,D},E={(A,B),(B,C),(A,D),(D,C)}) 表示一个无向四分图，其中顶点集 V = {A, B, C, D}，边集 E = {(A,B),(B,C),(A,D),(D,C)}。

## 有向图(Directed Graph)

1. 定义：若图G=(V,E)，则称G为有向图。
2. 举例：
   * G=(V={1,2,3,4},E={(1,2),(1,3),(2,4),(3,4)}) 表示一个有向简单图，其中顶点集 V = {1, 2, 3, 4}，边集 E = {(1,2),(1,3),(2,4),(3,4)}；
   * G=(V={A,B,C,D},E={(A,B),(A,C),(B,D),(C,D)}) 表示一个有向四分图，其中顶点集 V = {A, B, C, D}，边集 E = {(A,B),(A,C),(B,D),(C,D)}。

## 带权图(Weighted Graph)

1. 定义：若图G=(V,E)，设 e =(u,v) ∈ E ，其中u,v∈V，则称e的权重为 w(e)。记作 w(u,v)=w(e) 。
2. 举例：
   * G=(V={1,2,3,4},E={(1,2,7),(1,3,9),(2,4,5),(3,4,15)}) 表示一个带权简单图，其中顶点集 V = {1, 2, 3, 4}，边集 E = {(1,2,7),(1,3,9),(2,4,5),(3,4,15)}，权重 w(e) 可以是距离、时间或其他真值函数；
   * G=(V={A,B,C,D},E={(A,B,4),(A,C,1),(B,D,2),(C,D,3)}) 表示一个带权四分图，其中顶点集 V = {A, B, C, D}，边集 E = {(A,B,4),(A,C,1),(B,D,2),(C,D,3)}。

## 邻接矩阵(Adjacency Matrix)

1. 定义：对于无向图G=(V,E)，用一个 n × n 矩阵 A ，其中n=|V|,i=1,...,n ，j=1,...,n 来表示。如果存在边 e=(u,v)∈ E ，那么A[i][j]置为 1 ，否则 A[i][j]置为 0 。
2. 举例：
   * A=[[0,1,1],[1,0,1],[1,1,0]] 表示无向简单图，其中顶点集 V = {1, 2, 3}，边集 E = {(1,2),(1,3),(2,3)}。

## 邻接表(Adjacency List)

1. 定义：对于无向图G=(V,E)，用一个数组Adj[v]=[vj], 1≤j≤|E|(vi∈Vj), 表示所有与 vi 相邻的顶点。
2. 举例：
   * Adj=[[], [2, 3], [1, 3], [1, 2]] 表示无向简单图，其中顶点集 V = {1, 2, 3}，边集 E = {(1,2),(1,3),(2,3)}。

## 图的表示方式

根据图的不同属性和特点，图可以被不同的形式表示。如无向图可以使用邻接矩阵和邻接表两种表示法；有向图可以使用邻接矩阵和邻接表两种表示法；带权图可以使用邻接矩阵和邻接表两种表示法。下面是各种图的表示方式：

1. 无向简单图：


```python
# 邻接矩阵
adjacency_matrix = [[0,1,1],[1,0,1],[1,1,0]] 

# 邻接表
adjacency_list = [[2,3], [1,3], [1,2]] 
```

2. 无向加权图：


```python
# 邻接矩阵
weighted_adjancecy_matrix = [
    [0, 1, 4, INF], 
    [INF, 0, 2, 5], 
    [INF, INF, 0, 3], 
    [INF, INF, INF, 0]
]  

# 邻接表
weighted_adjacency_list = [
    [(2, 1)], # node 1 connected to node 2 with weight of 1
    [(3, 2), (4, 5)], # node 2 connected to nodes 3 and 4 with weights of 2 and 5 respectively
    [(4, 3)], # node 3 connected to node 4 with weight of 3
    [] # no connections for node 4 in this case
]  
```

3. 有向简单图：


```python
# 邻接矩阵
directed_adjacecny_matrix = [
    [0, 1, 1, 0], 
    [0, 0, 1, 1], 
    [0, 0, 0, 1], 
    [0, 0, 0, 0]
]

# 邻接表
directed_adjacency_list = [
    [], # node 1 has no edges in this case
    [(2,), (3,)], # node 2 is directed to both node 2 and 3
    [(4,)] # node 3 is directed to node 4 only
]  
```

4. 有向加权图：


```python
# 邻接矩阵
directional_weighted_adjacecny_matrix = [
    [0, 1, INF, INF], 
    [INF, 0, 2, 5], 
    [INF, INF, 0, 3], 
    [INF, INF, INF, 0]
]  
  
# 邻接表
directional_weighted_adjacency_list = [
    [], # node 1 has no edges in this case
    [(2, 1)], # node 2 is directed to node 2 with weight of 1
    [(4, 3)] # node 3 is directed to node 4 with weight of 3
]  
```