                 

# 1.背景介绍


## 1.1 什么是身份认证与授权？
身份认证（Authentication）和授权（Authorization）是最基本也是最重要的两个概念。身份认证（Authentication）是确认一个实体（如人、设备或软件程序等）是真实有效的过程；而授权（Authorization）则是在身份验证之后进行的一项决定，它决定了一个已知身份的主体对一个特定的信息或资源是否具有访问权限。

很多情况下，身份认证与授权是密不可分的。比如在线银行交易，需要用户通过身份认证，然后才能进行交易。当你输入用户名密码后，银行可以确定你是一个合法的客户。授权允许你访问你有权查看的账户资产，阻止你的敌人篡改你的数据等。

## 1.2 为什么要做身份认证与授权？
随着互联网的发展，越来越多的应用被迫面向社会公众。这种需求给用户数据带来的隐私和安全问题越来越多。为了保障用户数据安全，企业必须充分考虑其用户身份认证与授权机制，防止恶意攻击、泄露个人信息等安全风险。

对于身份认证，主要是为了确保你是一个合法的用户，你是你说的是你。而授权则是为了限制不合法用户对特定信息和资源的访问权限，保护个人隐私和数据安全。

## 1.3 那什么是开放平台呢？
开放平台（Open Platform），简单来说就是一种服务提供商模式。它将所有服务端的功能模块都打包成接口，让第三方开发者基于这些接口自行开发出各种类型的应用程序。

在开放平台中，所有的用户都必须通过身份认证与授权过程才能使用该平台上的服务。也就是说，只有经过身份认证和授权才可以调用平台提供的服务接口。

## 1.4 那么身份认证与授权又有什么不同之处？
身份认证与授权之间的不同点一般包括以下几种：
1. 身份认证类型不同：通常，身份认证是通过用户名、密码或者其他形式的凭据来判断用户的合法性。有的平台还提供了单点登录（Single Sign-On, SSO）功能，简化了用户认证流程，使得用户只需登录一次就可以访问多个平台或服务。

2. 授权方式不同：有的平台要求用户必须指定某些角色或权限才能访问某个功能或资源，有时还会提供基于角色的访问控制（Role-based Access Control, RBAC）策略。

3. 用户标识不同：有的平台使用不同的用户标识，如IP地址、姓名、邮箱等。此外，有的平台允许用户同时使用多个账号登录，即多重身份认证（Multi-factor Authentication, MFA）。

4. 错误处理机制不同：有的平台会提供相应的错误提示信息，指导用户进行正确的操作，有的平台则会采用严厉的方式直接拒绝掉非法请求。

5. 服务级别不同：有的平台的服务级别比较高，需要满足高级认证标准，有时还有欺诈检测功能。

综上所述，对于实现安全的身份认证与授权，我们需要综合考虑其各个方面差异性，构建符合需求的系统架构和流程，并采用合适的技术方案。本文将详细讨论这一话题。

# 2.核心概念与联系
## 2.1 OAuth
OAuth 是 OpenID Connect 的简称，它是一种授权框架，它允许第三方应用访问受保护资源，而无需获取用户的用户名及密码。OAuth 的授权流程由四个阶段组成：授权确认、令牌获取、资源访问、令牌释放。

- 授权确认: 授权确认阶段，客户端先向服务器索要授权，然后根据服务器返回的信息进行自身的授权确认。
- 令牌获取：令牌获取阶段，客户端利用上一步获得的授权信息，向服务器申请令牌，请求的过程中需要携带相关信息，如授权类型、有效期、回调地址等。
- 资源访问：资源访问阶段，客户端使用令牌向服务器请求访问自己的资源，资源访问完成后，客户端主动向服务器注销令牌。
- 令牌释放：令牌释放阶段，如果客户端不需要继续访问资源，也可以选择主动向服务器释放令牌，释放之后再次访问资源都会重新进行授权确认。

## 2.2 JWT（Json Web Tokens）
JSON Web Token（JWT）是一个紧凑且自包含的、可移植的、URL 安全的表现层状态规范。JWT 可以用来传递加密信息。作为一个开放标准（RFC 7519），JWT 已经成为行业标准。JWT 以 JSON 对象形式存储载荷（payload），提供了一种用于交换声明的简便方法。JWT 可以使用 HMAC 或者 RSA 来签名，还可以使用 AES 对称加密，以防数据被篡改。

## 2.3 OIDC
OIDC （OpenID Connect）是 OAuth2.0 的扩展协议，它继承了 OAuth2.0 的优点，同时加入了更多的特性。OIDC 在 OAuth2.0 之上添加了用户识别和属性共享的功能。

- 用户识别：相比于传统的用户名/密码登录，用户可以在 OpenID Connect 中直接用 OpenID 登录。OpenID 可以表示网站、App 或用户的唯一标识符。
- 属性共享：OIDC 提供了统一的用户属性共享协议，让用户可以分享自己在各个网站上的个人信息。例如，用户的名字、头像、邮箱、所在地区等。

# 3.核心算法原理和具体操作步骤以及数学模型公式详细讲解
## 3.1 数字签名算法：RSA、ECDSA
### 3.1.1 RSA算法概述
RSA (Rivest–Shamir–Adleman) 算法是目前最流行的公钥加密算法，由 Rivest 、 Shamir 和 Adleman 三人在 1978 年合作提出的。

RSA 分为公钥加密算法和私钥加密算法。公钥加密算法的关键是找到两个不同的大的素数 p 和 q ，它们的积 n=(p−1)(q−1)，两个质数乘积是一个非常大的质数，这两个数就成了公钥。另一个是求出 e 满足 1<e<n-1并且 gcd(e,n)=1 ，公钥就是 (n,e)。私钥就是 (n,d) 满足 d*e=1 mod n 。

私钥用于加密，公钥用于解密。公钥加密的内容只能通过私钥解密。私钥加密的内容只能通过公钥解密。

公钥加密速度快，私钥加密速度慢。

### 3.1.2 ECDSA算法概述
ECDSA 是 Elliptic Curve Digital Signature Algorithm 的缩写。它是一种基于椭圆曲线的数字签名算法。

椭圆曲线由两条相互垂直的直线段构成，一条为轴，另外一条为焦点。椭圆曲线的定义为：y^2 = x^3 + ax + b （其中 a,b 不为零，a≠0 时域曲线，b≠0 坐标曲线）。

### 3.1.3 RSA与ECDSA的比较
- RSA：
  - 优点：
    - 公钥算法速度快，加密效率高。
    - 避免低耗时的离散对数运算，加解密速度快。
    - 大量使用，公钥长度小。
  - 缺点：
    - 模数长，密钥生成复杂。
    - 容易遭受“重放攻击”等攻击。
- ECDSA：
  - 优点：
    - 计算量小，加密速度快。
    - 支持两种曲线，能抵抗短指数攻击。
  - 缺点：
    - 需要确定曲线参数，曲线选取困难。
    - 使用椭圆曲线签名，发送者和接收者需要共同信任，通信安全性较弱。

## 3.2 用户注册与登录流程
### 3.2.1 用户注册
#### 3.2.1.1 用户注册前期准备工作
1. 生成 RSA 公私钥对，公钥用于登录和校验，私钥用于数据加密。公钥和私钥长度至少 2048 bit。
2. 获取验证码（用于校验注册用户的合法身份）。
3. 配置安全策略，设置密码最小长度、最大登录失败次数、登录间隔时间等。
4. 设置账户锁定阈值，超过该阈值账户自动解锁。
5. 配置 SMTP 服务器，发送验证码到注册邮箱。
6. 配置 LDAP/AD 服务器，集中管理账户信息。

#### 3.2.1.2 用户注册流程
1. 用户填写注册表单提交信息，手机号码、邮箱、用户名、密码等信息必填。
2. 检查手机号码是否已注册。
3. 检查邮箱是否已注册。
4. 校验验证码是否正确。
5. 将注册信息保存到 LDAP/AD 服务器。
6. 使用私钥对用户密码加密。
7. 如果配置 SMTP 服务器，将注册验证码发送到用户注册邮箱。
8. 返回成功注册页面。

### 3.2.2 用户登录
#### 3.2.2.1 用户登录前期准备工作
1. 根据业务场景，配置不同登录方式，如用户名密码登录、手机验证码登录、扫码登录等。
2. 根据业务场景，配置不同登录方式的账号冻结策略，如登录失败次数达到阈值，账号自动解锁等。
3. 配置滑动验证码，减少登录失败风险。
4. 配置 CAPTCHA 验证码，增加登录方式的复杂度。
5. 配置安全日志记录，记录登录尝试信息。
6. 配置登录失败通知，管理员账号收到登录失败通知，可以通过管理界面查看登录失败详情。

#### 3.2.2.2 用户登录流程
1. 用户输入用户名或邮箱或手机号码和密码进行登录。
2. 使用私钥解密用户密码，校验登录密码是否正确。
3. 根据登录方式，校验登录信息。
4. 如果配置滑动验证码，校验滑动验证码是否正确。
5. 如果配置 CAPTCHA 验证码，校验 CAPTCHA 是否正确。
6. 如果登录成功，生成 JWT 令牌，发给用户。
7. 如果登录失败，记录登录失败信息。
8. 返回登录成功或失败结果。

## 3.3 基于角色的访问控制RBAC
基于角色的访问控制（Role-based Access Control, RBAC）是一种非常常用的访问控制策略。它通过将用户划分到不同的角色组，并制定不同角色组内拥有不同权限的规则，实现细粒度的访问控制。

RBAC 有助于降低权限分配与管理的复杂度，而且适用于分布式环境下。

RBAC 常见的角色有：管理员、普通用户、超级用户、审计员、运维人员、访客等。管理员拥有所有权限，普通用户仅拥有部分权限，超级用户拥有一切权限。审计员可以查看所有数据的变化历史，运维人员可以查看服务器运行状态和配置信息，访客只能浏览网站内容。

RBAC 的工作流程如下：
1. 创建角色与权限。
2. 分配角色与用户。
3. 配置角色权限。
4. 审核权限分配。
5. 浏览网站，享受权限带来的访问权限。

RBAC 管理系统可以提供权限控制的命令行工具、图形界面或 API。

## 3.4 JWT（Json Web Tokens）生成与解析
JWT 是一个紧凑且自包含的、可移植的、URL 安全的表现层状态规范。JWT 可以用来传递加密信息。作为一个开放标准（RFC 7519），JWT 已经成为行业标准。

JWT 以 JSON 对象形式存储载荷（payload），提供了一种用于交换声明的简便方法。JWT 可以使用 HMAC 或者 RSA 来签名，还可以使用 AES 对称加密，以防数据被篡改。

JWT 生成方式：
1. 服务端生成JWT。
2. 服务端返回JWT给客户端。
3. 客户端储存JWT。
4. 客户端每次向服务端请求资源的时候，都应该带上JWT。
5. 服务端验证JWT，如果验证成功，则继续处理请求。

JWT 解析方式：
1. 客户端从本地缓存或Cookie中获取JWT。
2. 从HTTP请求的Header中获取JWT。
3. 从URL中获取JWT。
4. 如果JWT有效，则返回给客户端。
5. 如果JWT失效或伪造，则返回401 Unauthorized。

## 3.5 JWT实现身份认证与授权
JWT 的主要作用是身份认证与授权。它的优点是：
1. 只需要发送一次 token，简化认证流程，减少网络延迟，提升响应速度。
2. 支持多种语言，可以与前端技术栈完美整合。
3. 支持移动 APP 平台，方便用户登录。
4. 支持同源跨站请求（Cross-Origin Resource Sharing，CORS）。
5. 支持刷新机制，可将过期时间续租。

# 4.具体代码实例和详细解释说明
## 4.1 用户注册与登录示例代码
```php
// 用户注册
public function register() {
    // 获取注册信息
    $email    = $_POST['email'];
    $username = $_POST['username'];
    $password = $_POST['password'];
    
    // 校验参数
    if(!preg_match('/^[A-Za-z0-9]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/', $email)) {
        throw new Exception('邮箱格式不正确');
    }

    if (!preg_match('/^[a-zA-Z]\w{3,19}$/', $username)) {
        throw new Exception('用户名格式不正确');
    }

    if(strlen($password)<6 || strlen($password)>16) {
        throw new Exception('密码长度应在6~16字符之间');
    }

    // 判断手机号码是否已注册
    $ldap = ldap_connect("ldap://localhost");
    $res = @ldap_bind($ldap);

    if(!$res){
        throw new Exception('LDAP连接失败');
    }

    $filter="(cn=$username)";
    $result = ldap_search($ldap,"ou=Users,$baseDn",$filter);
    $entries = ldap_get_entries($ldap, $result);
    if ($entries["count"] > 0) {
        throw new Exception('手机号码已注册');
    }

    // 使用私钥对密码加密
    openssl_private_encrypt($password, $encryptedPassword, $privateKey);

    // 插入到数据库
    try {
        $pdo = new PDO("mysql:host=localhost;dbname=test", "root", "123456");
        $stmt = $pdo->prepare("INSERT INTO user (email, username, password) VALUES (:email, :username, :password)");
        $stmt->execute(['email' => $email, 'username' => $username, 'password' => base64_encode($encryptedPassword)]);
        return true;
    } catch (\PDOException $exception) {
        echo "Error:". $exception->getMessage();
        return false;
    } finally {
        unset($pdo);
    }
}

// 用户登录
public function login() {
    // 获取登录信息
    $account  = isset($_POST['account'])? $_POST['account'] : '';
    $password = isset($_POST['password'])? $_POST['password'] : '';
    $captcha  = isset($_POST['captcha'])? $_POST['captcha'] : '';
    
    // 参数校验
    if (!$account &&!$captcha) {
        throw new Exception('请输入手机号码或邮箱或用户名或验证码');
    } elseif (!$password) {
        throw new Exception('请输入密码');
    } elseif ($captcha!= $_SESSION['code']) {
        throw new Exception('验证码错误');
    }

    // 使用私钥解密密码
    openssl_private_decrypt($password, $decryptedPassword, $privateKey);

    // 从数据库读取用户信息
    try {
        $pdo = new PDO("mysql:host=localhost;dbname=test", "root", "123456");
        $stmt = $pdo->prepare("SELECT * FROM user WHERE email=:email OR mobile=:mobile OR username=:username");
        $stmt->execute([
            ':email'   => $account,
            ':mobile'  => $account,
            ':username'=> $account
        ]);
        $user = $stmt->fetch(\PDO::FETCH_ASSOC);

        // 判断密码是否正确
        if ($user && $decryptedPassword == base64_decode($user['password'])) {
            // 生成token并缓存
            $jwt = $this->generateToken($user['id']);

            // 设置cookie
            setcookie('token', $jwt, time()+60*60*24*7);
            
            // 跳转到首页
            header('Location:/index.html');
        } else {
            throw new Exception('帐号或密码错误');
        }
    } catch (\PDOException $exception) {
        echo "Error:". $exception->getMessage();
        return false;
    } finally {
        unset($pdo);
    }
}
```

## 4.2 基于角色的访问控制RBAC示例代码
```php
// 用户身份认证与授权
class UserAuth {

    public static function authenticate($identity) {
        // 通过 identity 查询用户信息
        //...
        
        // 查找用户的角色与权限
        //...
        
        // 生成 JWT token
        $token = self::generateToken($userId, ['role' => $roles]);
        
        return $token;
    }

    private static function generateToken($userId, array $payload) {
        $key = config('app.key');
        
        $header = [
            'typ' => 'JWT',
            'alg' => 'HS256'
        ];
        
        $data = [
            'iss' => config('app.name'),
            'iat' => time(),
            'nbf' => time(),
            'exp' => time() + 60*60*24*7,
           'sub' => $userId,
            'data' => $payload
        ];
        
        $headerStr = json_encode($header);
        $dataStr = json_encode($data);
        
        $signature = hash_hmac('sha256', "$headerStr.$dataStr", $key, true);
        
        $token = implode('.', [
            str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($headerStr)),
            str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($dataStr)),
            str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($signature))
        ]);
        
        return $token;
    }
    
}


// 视图控制器
class HomeController extends Controller {
    
    protected $middleware = [
        Middleware\AuthenticateMiddleware::class,
    ];
    
    public function index(){
        $userData = session('auth')['user'];
        
        $data = [];
        
        switch ($userData['role']) {
            case Roles::ADMIN:
                // 显示管理员页面
                break;
            case Roles::NORMAL_USER:
                // 显示普通用户页面
                break;
            default:
                throw new ForbiddenException('没有访问权限');
        }
        
        // 渲染视图
        return view('home/index', compact('data'));
        
    }
    
    
}
```

## 4.3 JWT实现身份认证与授权示例代码
```php
// 控制器
class AuthController extends Controller {
    
    public function login() {
        $params = request()->all();
        
        $rules = [
            'account|帐号'        =>'required',
            'password|密码'       =>'required',
            'captcha|验证码'      =>'required'
        ];
        
        validate($params, $rules)->validateOrException();
        
        $account = input('account');
        $password = input('password');
        $captcha = input('captcha');
        
        // 验证码验证
        if (session('code')!== md5($captcha)) {
            exception('验证码错误');
        }
        
        // 用户身份认证与授权
        $token = UserAuth::authenticate($account, $password);
        
        // 设置 cookie
        response()->withCookie(config('app.token_cookie_name'), $token, time() + 60*60*24*7);
        
        success('登录成功', [], '/');
    }
    
    
}

// 权限中间件
class AuthenticateMiddleware implements MiddlewareInterface {

    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface {
        // 从请求中获取 token
        $token = request()->cookie(config('app.token_cookie_name'));
        
        // 验证 token
        if (!$token ||!self::verifyToken($token)) {
            redirect("/login?redirect=".urlencode(request()->path()));
            exit;
        }
        
        $tokenData = get_array_value((new Parser())->parse((string)$token), 'data', []);
        
        // 设置 session
        session(['auth' => [
            'user' => $tokenData
        ]]);
        
        return $handler->handle($request);
    }
    
    private static function verifyToken($token) {
        $secretKey = config('app.key');
        
        list($header, $payload, $sign) = explode('.', $token);
        
        $header = json_decode(base64_decode(str_replace('_', '/', str_replace('-', '+', $header))), true);
        
        if ('JWT'!== $header['typ']) {
            return false;
        }
        
        $data = json_decode(base64_decode(str_replace('_', '/', str_replace('-', '+', $payload))), true);
        
        $currentTimeStamp = time();
        
        if ($currentTimeStamp > $data['exp']) {
            return false;
        }
        
        $expectedSign = hash_hmac('sha256', "$header.$payload", $secretKey, true);
        
        if ($expectedSign!== base64_decode($sign)) {
            return false;
        }
        
        return true;
    }
    
}

// jwt 生成与解析器
class JwtParser {
    
    private static $instance;
    
    /**
     * 获取JwtParser对象
     */
    public static function getInstance(): JwtParser
    {
        if (!self::$instance instanceof JwtParser) {
            self::$instance = new JwtParser();
        }
        
        return self::$instance;
    }
    
    /**
     * 生成JWT
     * @param integer $userId 用户ID
     * @param array $payload 载荷数据
     */
    public function encode(int $userId, array $payload = []): string
    {
        $key = config('app.key');
        
        $header = [
            'typ' => 'JWT',
            'alg' => 'HS256'
        ];
        
        $data = [
            'iss' => config('app.name'),
            'iat' => time(),
            'nbf' => time(),
            'exp' => time() + 60*60*24*7,
           'sub' => $userId,
            'data' => $payload
        ];
        
        $headerStr = json_encode($header);
        $dataStr = json_encode($data);
        
        $signature = hash_hmac('sha256', "$headerStr.$dataStr", $key, true);
        
        $token = implode('.', [
            str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($headerStr)),
            str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($dataStr)),
            str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($signature))
        ]);
        
        return $token;
    }
    
    /**
     * 解析JWT
     * @param string $token JWT字符串
     */
    public function decode(string $token): array
    {
        $secretKey = config('app.key');
        
        list($header, $payload, $sign) = explode('.', $token);
        
        $header = json_decode(base64_decode(str_replace('_', '/', str_replace('-', '+', $header))), true);
        
        if ('JWT'!== $header['typ']) {
            throw new \Exception('类型错误');
        }
        
        $data = json_decode(base64_decode(str_replace('_', '/', str_replace('-', '+', $payload))), true);
        
        $currentTimeStamp = time();
        
        if ($currentTimeStamp > $data['exp']) {
            throw new \Exception('超时');
        }
        
        $expectedSign = hash_hmac('sha256', "$header.$payload", $secretKey, true);
        
        if ($expectedSign!== base64_decode($sign)) {
            throw new \Exception('签名错误');
        }
        
        return $data;
    }
    
}

function parseJwt($token): array
{
    return JwtParser::getInstance()->decode($token);
}

function createJwt($userId, array $payload = []): string
{
    return JwtParser::getInstance()->encode($userId, $payload);
}
```

# 5.未来发展趋势与挑战
安全的身份认证与授权是一个长期的话题，在不断的演进中会遇到新的技术挑战。以下是一些我认为可能会影响当前身份认证与授权领域发展方向的技术趋势与机遇。

## 5.1 生物特征认证（Biometrics）
生物特征识别技术正在逐步取代密码技术成为身份认证的主要手段。生物特征识别技术有助于提高系统的安全性和用户的认证体验。

典型的生物特征识别技术包括指纹识别、虹膜识别、面部识别、声纹识别、IR（激光反射）摄像头等。指纹识别依赖于用户在每天生活中习惯使用的不同指纹扫描装置，而虹膜识别依赖于用户在入门时刻固定在指尖上的红色指甲。

由于生物特征识别技术相比密码更具侵入性、技术门槛低、设备成本高、重复性强，因此它们在日益流行的情况下可能成为身份认证的新标准。

## 5.2 边缘计算（Edge Computing）
云计算已经成为IT基础设施发展的一个重要趋势。边缘计算就是利用云计算资源实现的分布式计算，它可以减轻中心化计算的压力，实现云端计算的能力增强。

边缘计算的目标是把计算任务从中心位置转移到距离数据源最近的地方，这样可以降低中心位置的处理负担，提升性能，提高响应速度。通过部署在边缘位置的云计算资源，边缘计算能够对上千台设备的数据进行快速、实时的分析，从而有效地节省资源和成本。

随着边缘计算的发展，公司内部部署的基础设施会越来越多，而在边缘位置的计算资源就会越来越多。边缘计算的特性也会带来一些新的挑战，例如计算任务的传输和存储成本，以及对用户的隐私保护需求。

## 5.3 扩展性
随着身份认证与授权技术的广泛应用，企业的身份保障体系也会成为一个复杂的问题。由于人数、部门、业务等多样性，身份认证与授权的机制、流程、监控与管理等都会面临巨大的挑战。

解决这个问题的方法之一是建立可扩展的架构，使身份认证与授权组件具有弹性、灵活性，可快速响应快速变化的业务需求。

扩展性的架构还可以通过微服务架构来实现，通过将身份认证与授权功能部署到不同的微服务中，可以更好地实现业务的解耦，提升系统的灵活性和扩展性。

## 5.4 可用性与弹性
我们常说的可用性就是指某个系统或服务的正常运行时间，弹性则是指当某些外部因素导致系统或服务变得不可用时，仍然能够保持稳定的运行能力。

可用性与弹性直接影响到身份认证与授权的可靠性和安全性，因此，必须通过针对性的部署和运营策略，来保证身份认证与授权系统的高可用性与弹性。

高可用性的架构可以提升系统的容错能力，降低单点故障的影响。弹性的架构可以应对突发状况，通过设计自动化手段及时调整系统的处理策略。

# 6.附录常见问题与解答
## 6.1 JWT安全吗？
JWT 本身不是加密算法，只是一种编码规范。加密算法有 AES、DES、RSA 等等，可以用来对 JWT 进行加密，不过我们不能完全依赖加密算法，因为它们都无法完全保证信息的机密性和完整性。

JWT 本身很安全，因为它不会加密敏感数据，也不会使用像 SSL 一样的公钥/私钥机制。我们可以用 JWT 来传输非敏感信息，但不要用来存储敏感数据。

## 6.2 为什么不建议用 JWT 来存储敏感数据？
如果用 JWT 来存储敏感数据，其实就是用了一种没加密的、无限制的、不安全的存储方式。

首先，JWT 本身并没有加密算法，所以不管你加密还是不加密，都是无效的。实际上，如果你用任何加密算法对 JWT 进行加密，也没用。

其次，JWT 默认的加密算法 HS256 没有提供完整性保证。也就是说，你用相同的密钥加密一个 JWT，得到的结果是不同的。除非你对两个结果同时暴力破解，否则无法知道原始数据。

第三，JWT 的编码规范并不推荐使用明文存储敏感信息。虽然它不加密，但它使用 URL safe 编码，这意味着它并不安全。

最后，JWT 并不是专为单点登录（SSO）设计的，所以并不适合用来存储敏感数据。

## 6.3 如何防止 CSRF 攻击？
CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种攻击方法，攻击者盗用他人的身份信息，以自己的名义发送恶意请求。

CSRF 攻击可以发生在 HTTP 请求中，而 JWT 并不存在此漏洞。

解决 CSRF 攻击的方法有以下两种：
1. 验证 Referer 字段。浏览器每次发送 HTTP 请求时，都会自动带上当前页面的地址作为 Referer 字段的值，服务器可以通过此字段验证请求来源。

可以通过检查 Referer 字段中的域名是否一致，来阻止 CSRF 攻击。

2. 在请求中添加验证码。服务器生成随机验证码，每个验证码只能使用一次，然后将验证码和请求绑定一起。

前端提交请求之前，先向服务器发送验证码，服务器验证验证码的正确性，然后再处理请求。

## 6.4 Cookie 劫持如何防御？
Cookie 是用户和服务器之间交换数据的一种方式。它是一个小文本文件，包含少量数据，例如用户名、密码、购物车信息等。Cookie 可以隐藏在用户的浏览器里，不受到外界影响，因此安全性比较高。

Cookie 劫持（又称 Session 劫持）是攻击者盗用用户的 Cookie，通过修改或伪造 Cookie 值来假扮用户身份，获取访问用户的权限，获取用户个人信息。

常见的 Cookie 劫持方式有：
1. 会话固定攻击（Session Fixation Attack）

攻击者盗用用户的访问权限，在用户不知情的情况下，冒充用户身份访问受害网站，获取用户个人信息。

解决办法：
除了增加验证码外，还可以设置过期时间短的 cookie 或者设置 httpOnly 为 true。

2. 会话损坏攻击（Session Hijacking Attack）

攻击者盗用用户的会话，获取用户个人信息。

解决办法：
除了提高安全措施外，还可以绑定 IP 地址、登录信息等，检测异常访问。

3. Cookie 欺骗攻击（Cookie Tampering Attack）

攻击者在用户不知情的情况下，篡改用户的 Cookie，获取访问用户的权限，获取用户个人信息。

解决办法：
对 Cookie 进行签名或加密，增加安全性。