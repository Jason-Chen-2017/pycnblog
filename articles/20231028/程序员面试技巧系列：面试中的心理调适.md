
作者：禅与计算机程序设计艺术                    

# 1.背景介绍


“面试不仅仅是筛选简历，也是一种情绪上的交流，技术面试只是其中的一个环节。”——雷军
技术面试作为求职的一条重要途径，也是最为耗时的阶段。然而，相比于其他岗位而言，技术面试对应届生来说并不容易通过。
为此，很多应届生都选择跳槽、转行或者放弃了技术面试。当面试官的回答在意料之中时，更多人认为“好厉害！”；当面试官的答案陌生到令人费解时，更多人则更加沮丧，甚至放弃。
因此，如何在面试中克服自身弱点，调动自己的思维和情绪，提升自信和能力，是技术面试的一项重要技能。
为了帮助应届生们克服心理障碍，本文将从“心理建设”、“算法”、“编程”三个方面介绍一些面试中常用的心理技巧。文章的目录如下:

Ⅰ 心理建设
  - 避免被面试官“左手伸得太长”，“右手伸得太长”
  - 没有准备充分，不要急于上岗
  - 好好说话，用词要清晰，用语要表达自己的想法
  - 提前询问面试时间，防止因错过而耽误时间
 
Ⅱ 算法
  - 判断两个字符串是否相同的两种方法
  - 从排序数组中查找数字的两种方法
  - 如何判断链表是否成环
  - 二叉树遍历方法
  
Ⅲ 编程 
  - C/C++的内存分配方式
  - MySQL索引优化的方法
  - Python实现栈的两种方法
  - Redis集群搭建方法
  
在正文开始之前，先简单介绍一下作者：
我是李玉刚，目前就职于微软亚洲研究院微软研究院院长助理，曾担任深圳市潮汕信息科技有限公司负责人，是一名产品经理和技术专家。我的工作包括产品策略、商业模式设计、管理决策、规划、培训和研发等。

接下来，让我们开始吧！:)

# Ⅰ 心理建设
## 1. “左手伸得太长”，“右手伸得太长”
这个问题很难回答，因为它存在多种不同的原因。但一般来说，可能有以下几种情况导致：

1. 对方比较紧张或无话可说，并且双手都拄着拐杖，所以要求说话。（不过，其实这种情况多半是对方不擅长自我介绍和引导）
2. 对方太忙，看起来没有时间反馈。
3. 对方特别耿直，脾气火爆，经常把自己一说话就插嘴。
4. 面试官先让你去领英、LinkedIn、Github等社交平台找工作，然后才到场进行技术面试。如果面试官先安排的交流项目（如做PPT）并不是你擅长的，或者是在后期才突然出现，这样可能会让你迟钝或者失去兴趣。
5. 在学习某些知识过程中，需要反复验证自己的理解是否正确，就会出现“左手伸得太长”或者“右手伸得太长”的问题。遇到这种问题，可以试着缩短时间，或者减少反复验证的次数，或者在一些关键节点的时候跳过一些知识点。

## 2. 没有准备充分，不要急于上岗
作为应届生，充满了各种各样的不确定性，并非所有岗位都需要工作两年、三年甚至五年的经验。所以，即使能够在面试中获胜，也不能盲目乐观。一定要认真准备，并且做好充足的准备。

另外，初入职场的应届生往往比较缺乏经验，没有经验的情况下，有的只会凭直觉，有的则可能跟随较为高端的人才走捷径。这种现象尤其严重于技术类岗位，因为很多岗位的要求都是比较高的。因此，初期应该坚持理性的思维，主动积极的探索新的东西。

## 3. 好好说话，用词要清晰，用语要表达自己的想法
总结来讲，就是说话要有韵律，语言要流畅准确，表情要清晰，不要含糊其辞，表达自己的意图。而且，更重要的是要从自我出发，有意识地听取对方的建议，去发现解决问题的方法。只有准确的描述自己的需求，才能准确获得需要的资源。

## 4. 提前询问面试时间，防止因错过而耽误时间
很多应届生因为技术水平有限，没有充分准备，很多时候只能匆忙投递简历。所以，在投递简历之前，一定要准时提交，并且提前一天预约面试时间。面试时，尽量能够在规定时间内完成，否则就会产生误会，甚至直接退出。另外，一些电话面试可能会延迟一个小时，建议提前半个小时准时接受。

## 5. 再来聊聊个人情况
这个问题不是必需的，但是了解自我、了解对方的工作经历、项目经历、兴趣爱好，都会为面试提供很大的帮助。尤其是可以让你知道对方是一个很好的合作伙伴，而不是独来独往。

# Ⅱ 算法
## 1. 判断两个字符串是否相同的两种方法
### 方法1-暴力破解法：
```python
def is_anagram(s):
    """
    Returns True if s is an anagram of another string, False otherwise.
    """
    return sorted(s) == sorted("".join(set(list(s))))
```
该方法的时间复杂度为O(nlogn)，其中n是字符串的长度。

### 方法2-排序算法
首先，将两个字符串转换为字符列表，然后对列表进行排序。最后，比较排序后的列表是否相等。
```python
def is_anagram(s):
    """
    Returns True if s is an anagram of another string, False otherwise.
    """
    return sorted(list(s)) == sorted(list(s)[::-1])
```
该方法的时间复杂度为O(nlogn)。

## 2. 从排序数组中查找数字的两种方法
### 方法1-线性搜索法
```python
def find_target(nums, target):
    """
    Finds the first index of a target in nums. If not found, returns -1.
    """
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1
```
该方法的时间复杂度为O(n)。

### 方法2-折半查找法
```python
def find_target(nums, target):
    """
    Finds the first index of a target in nums. If not found, returns -1.
    """
    left = 0
    right = len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mid - 1
        else:
            # Found it!
            return mid
        
    return -1
```
该方法的时间复杂度为O(logn)。

## 3. 如何判断链表是否成环
```python
def hasCycle(head):
    """
    Determines whether a linked list has a cycle or not.
    """
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            return True
            
    return False
```
该方法采用快慢指针的方法。初始化两个指针slow和fast，它们都指向头结点head。然后，slow指针每次移动一步，fast指针每移动两步。如果链表有环，那么一定会在某一点相遇。

## 4. 二叉树遍历方法
### 方法1-先序遍历：
```python
def preorderTraversal(root):
    """
    Traverse a binary tree in preorder order.
    """
    if root:
        print(root.val)
        preorderTraversal(root.left)
        preorderTraversal(root.right)
```
该方法先打印根节点的值，然后依次递归左子树和右子树。

### 方法2-中序遍历：
```python
def inorderTraversal(root):
    """
    Traverse a binary tree in inorder order.
    """
    if root:
        inorderTraversal(root.left)
        print(root.val)
        inorderTraversal(root.right)
```
该方法先递归左子树，然后打印根节点的值，最后递归右子树。

### 方法3-后序遍历：
```python
def postorderTraversal(root):
    """
    Traverse a binary tree in postorder order.
    """
    if root:
        postorderTraversal(root.left)
        postorderTraversal(root.right)
        print(root.val)
```
该方法先递归左子树和右子树，然后打印根节点的值。

### 方法4-层次遍历：
```python
from collections import deque

def levelOrder(root):
    """
    Traverse a binary tree in breadth-first order.
    """
    queue = deque([root])
    
    while queue:
        node = queue.popleft()
        print(node.val)
        
        if node.left:
            queue.append(node.left)
            
        if node.right:
            queue.append(node.right)
```
该方法使用队列queue保存当前层的所有节点。首先，将根节点加入队列。然后，从队列中取出一个节点，打印它的值，并将它的所有孩子节点加入队列。如此循环，直到队列为空。