# 基于单片机抢答器的设计与实现

作者：禅与计算机程序设计艺术

## 1. 背景介绍

### 1.1 抢答器的应用场景

抢答器是一种常见的电子设备,广泛应用于各类竞赛、游戏、教学等场合。它可以准确、公平、高效地判断出第一个按下按钮的参赛者,方便主持人或裁判进行后续流程控制。

### 1.2 抢答器的基本原理

抢答器的核心是单片机控制电路。参赛者按下按钮后,按钮开关接通,产生一个低电平信号。单片机通过外部中断或IO口电平变化,可以捕捉到这个信号,并迅速做出响应,点亮对应的指示灯,发出声音,同时锁定其他按钮。这样就可以明确第一个按键的参赛者。

### 1.3 设计一个抢答器的意义

自行设计一个抢答器,可以根据实际需求,定制按键数量、外观造型、附加功能等,更加灵活方便。同时还可以锻炼动手能力,加深对单片机原理的理解,提升嵌入式系统开发技能。是一个综合性很强的实践项目。

## 2. 核心概念与联系

### 2.1 单片机

单片机是一种集成度高、功能强大的微型计算机。通过对内部寄存器、IO口、定时器等模块编程,可实现数字信号采集、处理、控制等功能。是嵌入式系统的核心部件。

### 2.2 中断系统

中断是单片机响应外部事件的重要机制。通过中断,可使CPU暂停当前任务,转而执行中断服务程序,处理紧急事件。抢答器一般使用外部中断,监测按键动作。

### 2.3 GPIO

GPIO(General Purpose Input Output)是单片机用于控制IO口电平或读取电平状态的端口。每个IO口可配置为输入或输出,输出时可控制高低电平,输入时可读取外部信号。

### 2.4 按键电路

按键电路是抢答器的信号输入部分。一般采用瞬时开关+上拉电阻的形式,按键按下时产生低电平信号,松开时恢复高电平,便于单片机识别按键事件。

## 3. 核心算法原理与具体操作步骤

### 3.1 按键扫描算法

为了准确检测到按键动作,需要对按键状态进行连续扫描。每隔一定时间(如20ms)读取一次按键IO口电平,连续读取两次,如果两次都是有效电平(一般为低电平),则认为按键真正按下。这样可以消除按键抖动影响。

```c
uint8_t key_scan(void)
{
    static uint8_t key_state = 0;
    
    if(KEY_PORT == 0)
    {
        delay_ms(20);
        if(KEY_PORT == 0)
        {
            key_state = 1;
        }
    }
    else
    {
        if(key_state == 1)
        {
            key_state = 0;
            return 1;
        }
    }
    
    return 0;
}
```

### 3.2 中断处理流程

当检测到按键按下后,触发外部中断,MCU转入中断处理函数。在中断处理函数中,判断是哪个按键触发,给相应的IO口输出高电平点亮指示灯,同时禁止其他按键中断,并设置标志位。

```c
void EXTI_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET) 
    {
        if(key_scan())
        {
            LED0_ON;
            NVIC_DisableIRQ(EXTI1_IRQn);
            NVIC_DisableIRQ(EXTI2_IRQn);
            flag = 1;
        }
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
    
    if(EXTI_GetITStatus(EXTI_Line1) != RESET)
    {
        //...
    }
}
```

### 3.3 主循环逻辑

在主循环中,首先初始化各模块,如GPIO、中断、定时器、蜂鸣器等。然后进入while(1)循环,不断检测标志位。如果标志位置1,表示有按键按下,蜂鸣器响一段时间,并设置一个较长的延时,防止连续触发。延时结束后,关闭蜂鸣器,清除标志位,重新使能其他按键中断,等待下一轮抢答。

```c
int main(void)
{
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    delay_init();
    LED_Init();
    KEY_Init();
    BEEP_Init();
    
    while(1)
    {
        if(flag == 1)
        {
            BEEP_ON;
            delay_ms(1000);
            BEEP_OFF;
            flag = 0;
            LED0_OFF;
            NVIC_EnableIRQ(EXTI1_IRQn);
            NVIC_EnableIRQ(EXTI2_IRQn);
        }
    }
}
```

## 4. 数学模型和公式详细讲解举例说明

抢答器的核心算法比较简单,主要是逻辑控制,涉及的数学模型和公式较少。下面举例说明一下按键消抖的原理。

### 4.1 按键消抖原理

机械按键在按下和松开过程中,由于机械结构的特性,会产生一些尖峰脉冲,称为抖动。如果不加处理,MCU可能会误判为多次按键事件。常见的消抖方法有软件延时和硬件RC滤波电路。

软件消抖的数学模型可以表示为:

$$ T_d = \max(T_1, T_2, ..., T_n) $$

其中,$T_d$为消抖延时时间,$T_1, T_2, ..., T_n$为每次抖动的持续时间。只要延时时间大于抖动持续的最长时间,就可以可靠地消除抖动影响。一般取10~20ms。

硬件RC滤波的数学模型为:

$$ V_o = V_i \cdot (1 - e^{-\frac{t}{RC}}) $$

其中,$V_o$为滤波后的输出电压,$V_i$为输入电压,$t$为时间,$RC$为时间常数。通过选择合适的R和C值,可以对高频抖动进行滤除,输出平滑的信号。

## 5. 项目实践：代码实例和详细解释说明

下面以STM32F103单片机为例,给出抢答器的代码实现。

### 5.1 硬件连接

- 三个按键分别接PA0、PA1、PA2,上拉10K电阻
- 三个指示灯分别接PB0、PB1、PB2
- 蜂鸣器接PA3

### 5.2 头文件和宏定义

```c
#include "stm32f10x.h"
#include "delay.h"

#define KEY0_PORT   GPIOA
#define KEY0_PIN    GPIO_Pin_0
#define KEY1_PORT   GPIOA  
#define KEY1_PIN    GPIO_Pin_1
#define KEY2_PORT   GPIOA
#define KEY2_PIN    GPIO_Pin_2

#define LED0_PORT   GPIOB
#define LED0_PIN    GPIO_Pin_0
#define LED1_PORT   GPIOB
#define LED1_PIN    GPIO_Pin_1  
#define LED2_PORT   GPIOB
#define LED2_PIN    GPIO_Pin_2

#define BEEP_PORT   GPIOA
#define BEEP_PIN    GPIO_Pin_3

#define LED0_ON     GPIO_SetBits(LED0_PORT,LED0_PIN)
#define LED0_OFF    GPIO_ResetBits(LED0_PORT,LED0_PIN)
#define LED1_ON     GPIO_SetBits(LED1_PORT,LED1_PIN)
#define LED1_OFF    GPIO_ResetBits(LED1_PORT,LED1_PIN)
#define LED2_ON     GPIO_SetBits(LED2_PORT,LED2_PIN)
#define LED2_OFF    GPIO_ResetBits(LED2_PORT,LED2_PIN)

#define BEEP_ON     GPIO_SetBits(BEEP_PORT,BEEP_PIN)
#define BEEP_OFF    GPIO_ResetBits(BEEP_PORT,BEEP_PIN)
```

### 5.3 按键初始化函数

```c
void KEY_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    EXTI_InitTypeDef EXTI_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);
    
    GPIO_InitStructure.GPIO_Pin = KEY0_PIN | KEY1_PIN | KEY2_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    GPIO_Init(KEY0_PORT, &GPIO_InitStructure);
    
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0);
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource1);
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource2);
    
    EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1 | EXTI_Line2;
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
    
    NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    
    NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;
    NVIC_Init(&NVIC_InitStructure);
    
    NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn; 
    NVIC_Init(&NVIC_InitStructure);
}
```

### 5.4 LED初始化函数

```c
void LED_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    
    GPIO_InitStructure.GPIO_Pin = LED0_PIN | LED1_PIN | LED2_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(LED0_PORT, &GPIO_InitStructure);
    
    LED0_OFF;
    LED1_OFF;
    LED2_OFF;
}
```

### 5.5 蜂鸣器初始化函数

```c
void BEEP_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
    GPIO_InitStructure.GPIO_Pin = BEEP_PIN;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(BEEP_PORT, &GPIO_InitStructure);
    
    BEEP_OFF;
}
```

### 5.6 外部中断服务函数

```c
uint8_t flag = 0;

void EXTI0_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line0) != RESET)
    {
        if(key_scan())  
        {
            LED0_ON;
            NVIC_DisableIRQ(EXTI1_IRQn);
            NVIC_DisableIRQ(EXTI2_IRQn);
            flag = 1;
        }
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
}

void EXTI1_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line1) != RESET)
    {
        if(key_scan())
        {
            LED1_ON;
            NVIC_DisableIRQ(EXTI0_IRQn);
            NVIC_DisableIRQ(EXTI2_IRQn);
            flag = 2;
        }
        EXTI_ClearITPendingBit(EXTI_Line1);
    }
}

void EXTI2_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line2) != RESET)
    {
        if(key_scan())
        {
            LED2_ON;
            NVIC_DisableIRQ(EXTI0_IRQn);
            NVIC_DisableIRQ(EXTI1_IRQn);
            flag = 3;
        }
        EXTI_ClearITPendingBit(EXTI_Line2);
    }
}
```

### 5.7 主函数

```c
int main(void)
{
    NVIC_PriorityGroupConfig(NVIC_