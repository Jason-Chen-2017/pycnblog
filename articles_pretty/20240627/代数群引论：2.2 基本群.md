# 代数群引论：2.2 基本群

关键词：群、阿贝尔群、循环群、对称群、置换群、Cayley定理、Lagrange定理、正规子群

## 1. 背景介绍
### 1.1 问题的由来
群论作为现代数学的重要分支,在数学、物理、化学、计算机科学等领域有着广泛的应用。它研究对象的对称性和不变性,是一个高度抽象但又极其有用的理论。群论的发展源于对多项式方程求解的探索,19世纪初期由法国数学家Galois创立。

### 1.2 研究现状
目前群论已经发展成为一个庞大而完善的理论体系。从有限群到无限群,从离散群到连续群,各种类型的群都有深入系统的研究。一些重要的群如对称群、置换群、矩阵群等在理论和应用中都有着举足轻重的地位。现代的群论研究领域十分广泛,涉及表示论、同调论、算术群论、几何群论等众多分支。

### 1.3 研究意义 
群是数学中最基本的代数结构之一。深入理解群的性质和结构,对于学习现代代数、几何拓扑、数论、编码理论等数学分支都是必不可少的。此外,群论思想在物理学(如量子力学、粒子物理)、化学(如分子对称性)、计算机科学(如编码、密码学)等学科中也有重要应用。因此系统学习群论十分必要。

### 1.4 本文结构
本文将重点介绍几类最基本的群,包括阿贝尔群、循环群、对称群、置换群等。通过学习这些具体的群,加深对群的抽象概念、性质、运算的理解。同时,本文还会介绍群论的一些重要定理如Cayley定理、Lagrange定理等。通过理论联系实际,学以致用,提升群论的学习兴趣。

## 2. 核心概念与联系
群是一种代数结构,它由一个非空集合G和一个二元运算 · 组成,满足以下性质:
1) 封闭性:对任意a,b∈G,都有a·b∈G
2) 结合律:(a·b)·c=a·(b·c) 
3) 单位元:存在e∈G,对任意a∈G,都有e·a=a·e=a
4) 逆元:对任意a∈G,存在b∈G使得a·b=b·a=e

如果群G还满足交换律,即对任意a,b∈G都有a·b=b·a,则称G为阿贝尔群(或交换群)。

群中的一些重要概念:
- 子群:群G的非空子集H,在G的运算下它自身构成一个群,则称H是G的一个子群
- 陪集:对于子群H,a∈G,称aH={ah:h∈H}为a关于H的左陪集,Ha={ha:h∈H}为右陪集
- 正规子群:如果H是G的子群,且对任意g∈G有gH=Hg,则称H是G的正规子群
- 商群:设H是G的正规子群,G/H={aH:a∈G}在运算(aH)(bH)=abH下构成一个群,称为商群
- 同态:设(G,·),(G',*)是两个群,如果存在映射f:G→G',对任意a,b∈G,有f(a·b)=f(a)*f(b),则称f是G到G'的同态
- 同构:如果f是双射,则称f是G到G'的同构,记为G≌G'

## 3. 核心原理与算法
### 3.1 Cayley定理
Cayley定理说明了任意一个群都同构于某个置换群。

**定理**:每个群G都同构于G上的置换群Sym(G)的一个子群。

证明思路是定义左正则表示 L:G→Sym(G),对任意g∈G,a∈G,令L(g)(a)=ga。可以验证L是单射群同态,从而L(G)≌G。

这一结果揭示了群与置换之间的内在联系,为研究抽象群提供了具体模型。

### 3.2 Lagrange定理
Lagrange定理刻画了一个群的子群的阶与整个群的阶之间的关系。

**定理**:有限群G的子群H的阶必定整除G的阶,即|G|=|H|[G:H],其中[G:H]=|G|/|H|称为H在G中的指数。

证明用到了陪集分解的方法,任取x1,..,xn∈G 使得G=x1H∪..∪xnH,可证明[G:H]=n。

推论:群G的任意元素a的阶都整除G的阶。因为<a>是G的子群,由Lagrange定理即得。

Lagrange定理在有限群的研究中有重要作用,它给出了群的阶与子群阶的整除关系。

### 3.3 基本群分类
接下来介绍几类最基本的群。

**定义**:
1) 阿贝尔群:满足交换律的群。如整数集Z在加法下构成阿贝尔群。 
2) 循环群:由一个元素生成的群。无限循环群同构于(Z,+),有限循环群同构于Zn。
3) 对称群:n个元素构成的集合Ω上的全体置换在复合运算下构成的群,记为Sn,其阶为n!。
4) 置换群:Ω上置换的任一子集在复合运算下构成的群。Sn的子群都是置换群。
5) 二面体群Dn:由n阶循环群Cn和满足s^2=1,sas=a^-1的对称s生成的群,其阶为2n。

这些基本群体现了群的多样性,也是构造更复杂群的基础。

### 3.4 判定方法与举例
判断一个集合G在给定运算 · 下是否构成群,只需验证群的四条性质是否成立。对于有限群,可以列出运算表进行验证。

**例1**:集合G={1,-1,i,-i}在复数乘法下构成群,它同构于循环群C4。验证:
1) 封闭性:显然G对复数乘法封闭
2) 结合律:复数乘法满足结合律
3) 单位元:1是复数乘法的单位元
4) 逆元:1的逆元是1,-1的逆元是-1,i的逆元是-i,-i的逆元是i

**例2**:集合G={1,0}在异或运算⊕下构成群,它同构于循环群C2。验证:
异或运算表:
| ⊕ | 0 | 1 |
|---|---|---|
| 0 | 0 | 1 |
| 1 | 1 | 0 |

1) 封闭性:由运算表知异或运算在G上封闭 
2) 结合律:异或运算满足结合律
3) 单位元:0是异或运算单位元
4) 逆元:0和1互为逆元

## 4. 数学模型与公式
### 4.1 群的抽象定义
群可以用抽象语言定义如下:

**定义**: 二元代数系统$(G,\cdot)$称为一个群,如果它满足:
1) 封闭性:$\forall a,b \in G, a \cdot b \in G$
2) 结合律:$\forall a,b,c \in G,(a \cdot b) \cdot c=a \cdot (b \cdot c)$
3) 单位元:$\exists e \in G, \forall a \in G, e \cdot a=a \cdot e=a$
4) 逆元:$\forall a \in G,\exists b \in G, a \cdot b=b \cdot a=e$

如果$\forall a,b \in G,a \cdot b=b \cdot a$,则称G为阿贝尔群。

### 4.2 子群判定公式
设$(G,\cdot),(H,\cdot)$都是群,$H \subseteq G$,则以下三条等价:
1) $(H,\cdot)$是$(G,\cdot)$的子群
2) $H \neq \emptyset$,且$\forall a,b \in H,ab^{-1} \in H$
3) $H \neq \emptyset$,且$\forall a,b \in H,ab \in H,a^{-1} \in H$

### 4.3 Lagrange定理公式
设$(G,\cdot)$是有限群,H是G的子群,则
$$|G|=|H|[G:H]$$
其中$[G:H]$是H在G中的指数。

推论:群G的任意元素a的阶都整除G的阶。

### 4.4 二面体群的表示
二面体群$D_n$可以表示为:
$$D_n=<a,b|a^n=b^2=1,bab=a^{-1}>$$

其中a为旋转,b为对称,它们满足以下关系:
1) $a^n=1$ (旋转n次为恒等置换)
2) $b^2=1$ (对称两次为恒等置换)
3) $bab=a^{-1}$ (对称与旋转的关系)

## 5. 代码实例
下面用Python实现几个基本群,并验证它们的性质。

### 5.1 循环群Zn
```python
class CyclicGroup:
    def __init__(self, n):
        self.n = n
        self.elements = list(range(n))
    
    def operation(self, a, b):
        return (a + b) % self.n
    
    def inverse(self, a):
        return (self.n - a) % self.n
        
    def is_closed(self):
        for a in self.elements:
            for b in self.elements:
                if self.operation(a, b) not in self.elements:
                    return False
        return True
    
    def is_associative(self):
        for a in self.elements:
            for b in self.elements:
                for c in self.elements:
                    if self.operation(self.operation(a, b), c) != \
                       self.operation(a, self.operation(b, c)):
                        return False
        return True
    
    def has_identity(self):
        for e in self.elements:
            is_identity = True
            for a in self.elements:
                if self.operation(a, e) != a or self.operation(e, a) != a:
                    is_identity = False
                    break
            if is_identity:
                return True
        return False
    
    def has_inverses(self):
        for a in self.elements:
            has_inverse = False
            for b in self.elements:
                if self.operation(a, b) == 0 and self.operation(b, a) == 0:
                    has_inverse = True
                    break
            if not has_inverse:
                return False
        return True
    
    def is_group(self):
        return self.is_closed() and self.is_associative() and \
               self.has_identity() and self.has_inverses()

# 测试
Z3 = CyclicGroup(3)
print(Z3.elements)  # [0, 1, 2]
print(Z3.operation(1, 2))  # 0
print(Z3.inverse(1))  # 2
print(Z3.is_group())  # True
```

### 5.2 对称群Sn
```python
import itertools

class SymmetricGroup:
    def __init__(self, n):
        self.n = n
        self.elements = list(itertools.permutations(range(1, n+1)))
    
    def operation(self, p, q):
        return tuple(p[i-1] for i in q)
    
    def inverse(self, p):
        q = [0] * self.n
        for i in range(self.n):
            q[p[i]-1] = i+1
        return tuple(q)
        
    def is_closed(self):
        for p in self.elements:
            for q in self.elements:
                if self.operation(p, q) not in self.elements:
                    return False
        return True
    
    def is_associative(self):
        for p in self.elements:
            for q in self.elements:
                for r in self.elements:
                    if self.operation(self.operation(p, q), r) != \
                       self.operation(p, self.operation(q, r)):
                        return False
        return True
    
    def has_identity(self):
        identity = tuple(range(1, self.n+1))
        return identity in self.elements
    
    def has_inverses(self):
        for p in self.elements:
            has_inverse = False
            for q in self.elements:
                if self.operation(p, q) == (1,2,3) and self.operation(q, p) == (1,2,3):
                    has_inverse = True
                    break
            if not has_inverse:
                return False
        return True
    
    def is_group(self):
        return self.is_closed() and self.is_associative() and \
               self.has_identity() and self.has_inverses()

# 测试               
S3 = SymmetricGroup(3)
print(S3.elements) 
# [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
print(S3.operation((1,2,3), (1,3,2))) # (1, 3, 2)
print(S3.inverse((2,3,1))) # (