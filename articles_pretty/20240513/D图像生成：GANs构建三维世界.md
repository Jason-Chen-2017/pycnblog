# 3Då›¾åƒç”Ÿæˆï¼šGANsæ„å»ºä¸‰ç»´ä¸–ç•Œ

ä½œè€…ï¼šç¦…ä¸è®¡ç®—æœºç¨‹åºè®¾è®¡è‰ºæœ¯

## 1.èƒŒæ™¯ä»‹ç»

### 1.1 ä¸‰ç»´å›¾åƒç”Ÿæˆçš„é‡è¦æ€§
åœ¨è®¡ç®—æœºè§†è§‰ã€è™šæ‹Ÿç°å®ã€æ¸¸æˆè®¾è®¡ç­‰é¢†åŸŸ,ä¸‰ç»´å›¾åƒç”Ÿæˆæ‰®æ¼”ç€è‡³å…³é‡è¦çš„è§’è‰²ã€‚é«˜è´¨é‡ã€é€¼çœŸçš„3Då›¾åƒèƒ½å¤Ÿæä¾›èº«ä¸´å…¶å¢ƒçš„è§†è§‰ä½“éªŒ,å¤§å¤§æå‡ç”¨æˆ·çš„æ²‰æµ¸æ„Ÿã€‚ç„¶è€Œ,ä¼ ç»Ÿçš„3Då»ºæ¨¡æ–¹æ³•å¾€å¾€éœ€è¦å¤§é‡çš„äººå·¥å’Œæ—¶é—´æˆæœ¬ã€‚è¿‘å¹´æ¥,ä»¥ç”Ÿæˆå¯¹æŠ—ç½‘ç»œ(GANs)ä¸ºä»£è¡¨çš„æ·±åº¦å­¦ä¹ æ–¹æ³•ä¸º3Då›¾åƒç”Ÿæˆå¸¦æ¥äº†é©å‘½æ€§çš„çªç ´ã€‚

### 1.2 ç”Ÿæˆå¯¹æŠ—ç½‘ç»œ(GANs)ç®€ä»‹  
ç”Ÿæˆå¯¹æŠ—ç½‘ç»œ(Generative Adversarial Networks, GANs)æ˜¯ä¸€ç§æ— ç›‘ç£å­¦ä¹ çš„ç¥ç»ç½‘ç»œæ¶æ„,ç”±Goodfellowç­‰äººäº2014å¹´æå‡ºã€‚GANsç”±ä¸¤ä¸ªå­ç½‘ç»œç»„æˆ:ç”Ÿæˆå™¨(Generator)å’Œåˆ¤åˆ«å™¨(Discriminator),ä¸¤è€…ç›¸äº’åšå¼ˆ,ä¸æ–­æå‡å½¼æ­¤çš„èƒ½åŠ›ã€‚ç”Ÿæˆå™¨è‡´åŠ›äºç”Ÿæˆé€¼çœŸçš„æ ·æœ¬å»æ¬ºéª—åˆ¤åˆ«å™¨,è€Œåˆ¤åˆ«å™¨åˆ™ä¸æ–­æå‡è‡ªå·±åŒºåˆ†çœŸå‡æ ·æœ¬çš„èƒ½åŠ›ã€‚ç»è¿‡å¤šè½®å¯¹æŠ—è®­ç»ƒ,æœ€ç»ˆç”Ÿæˆå™¨å¯ä»¥ç”Ÿæˆéå¸¸é€¼çœŸçš„æ ·æœ¬ã€‚

### 1.3 GANsåœ¨3Då›¾åƒç”Ÿæˆä¸­çš„åº”ç”¨ç°çŠ¶
GANså¼ºå¤§çš„ç”Ÿæˆèƒ½åŠ›å¾ˆå¿«è¢«åº”ç”¨åˆ°3Då›¾åƒç”Ÿæˆé¢†åŸŸã€‚2016å¹´,Wuç­‰äººæå‡ºäº†3D-GAN,é¦–æ¬¡å°†GANsæ‹“å±•åˆ°äº†3Dç©ºé—´ã€‚æ­¤å,GANsåœ¨3Däººè„¸ã€3Dç‰©ä½“ã€3Dåœºæ™¯ç”Ÿæˆç­‰æ–¹é¢å–å¾—äº†é•¿è¶³è¿›å±•ã€‚åŸºäºä½“ç´ (Voxel)ã€ç‚¹äº‘(Point Cloud)ã€ç½‘æ ¼(Mesh)ç­‰ä¸åŒ3Dæ•°æ®è¡¨ç¤º,æ¶Œç°å‡ºäº†ä¸€ç³»åˆ—GANså˜ä½“,å¦‚3D-VAE-GANã€PC-GANã€AtlasNetç­‰ã€‚GANsæ­£é€æ­¥æˆä¸º3Då›¾åƒç”Ÿæˆçš„ä¸»æµèŒƒå¼ã€‚

## 2. æ ¸å¿ƒæ¦‚å¿µä¸è”ç³»

### 2.1 ç”Ÿæˆå™¨(Generator)
- ä½œç”¨:ç”Ÿæˆå‡æ ·æœ¬å»æ¬ºéª—åˆ¤åˆ«å™¨ 
- ç»“æ„:é€šå¸¸é‡‡ç”¨è§£å·ç§¯(Deconvolution)ç½‘ç»œ
- è¾“å…¥:éšæœºå™ªå£°å‘é‡z
- è¾“å‡º:ç”Ÿæˆçš„å‡æ ·æœ¬G(z)

### 2.2 åˆ¤åˆ«å™¨(Discriminator) 
- ä½œç”¨:åŒºåˆ†çœŸå®æ ·æœ¬å’Œç”Ÿæˆçš„å‡æ ·æœ¬
- ç»“æ„:é€šå¸¸é‡‡ç”¨å·ç§¯(Convolution)ç½‘ç»œ  
- è¾“å…¥:çœŸå®æ ·æœ¬xæˆ–ç”Ÿæˆçš„å‡æ ·æœ¬G(z)
- è¾“å‡º:è¾“å…¥æ ·æœ¬ä¸ºçœŸçš„æ¦‚ç‡D(Â·)

### 2.3 å¯¹æŠ—æŸå¤±(Adversarial Loss)
- ç”Ÿæˆå™¨å’Œåˆ¤åˆ«å™¨åšå¼ˆçš„ç›®æ ‡å‡½æ•°
- ç”Ÿæˆå™¨Loss:$min_G V(D,G)=ğ”¼_{z~p_z(z)}[log(1-D(G(z)))]$
- åˆ¤åˆ«å™¨Loss:$max_D V(D,G)=ğ”¼_{x~p_{data}(x)}[logD(x)]+ğ”¼_{z~p_z(z)}[log(1-D(G(z)))]$

### 2.4 3Dæ•°æ®è¡¨ç¤º
- ä½“ç´ (Voxel):ä¸‰ç»´ç©ºé—´çš„åƒç´ ,è§„åˆ™ç½‘æ ¼
- ç‚¹äº‘(Point Cloud):ç©ºé—´ä¸­çš„ç‚¹é›†åˆ 
- ç½‘æ ¼(Mesh):ç”±é¡¶ç‚¹ã€è¾¹ã€é¢æ„æˆçš„ä¸è§„åˆ™ç½‘æ ¼
- éšå¼æ›²é¢(Implicit Surface):ç©ºé—´ä¸­æ»¡è¶³æŸä¸ªæ¡ä»¶çš„ç‚¹çš„é›†åˆ

### 2.5 3Då·ç§¯(3D Convolution)
- å®šä¹‰åœ¨3Dç©ºé—´çš„å·ç§¯æ“ä½œ
- èƒ½æå–ç©ºé—´ç‰¹å¾,ä¿ç•™3Då½¢çŠ¶ä¿¡æ¯
- 3Då·ç§¯æ ¸åœ¨ä¸‰ä¸ªç»´åº¦ä¸Šæ»‘åŠ¨åšä¹˜ç§¯æ±‚å’Œ

## 3. æ ¸å¿ƒç®—æ³•åŸç†ä¸å…·ä½“æ­¥éª¤

### 3.1 vanilla GAN
#### 3.1.1 ç”Ÿæˆå™¨

1. è¾“å…¥:éšæœºå™ªå£°å‘é‡z
2. ç»è¿‡å¤šå±‚è½¬ç½®å·ç§¯(Transpose Convolution),å°†zæ˜ å°„åˆ°æ•°æ®ç©ºé—´
3. è¾“å‡º:ç”Ÿæˆçš„å‡æ ·æœ¬G(z)
4. è½¬ç½®å·ç§¯:ä¸Šé‡‡æ ·+å·ç§¯,å°†ç‰¹å¾å›¾åˆ†è¾¨ç‡æ”¾å¤§

#### 3.1.2 åˆ¤åˆ«å™¨ 

1. è¾“å…¥:çœŸå®æ ·æœ¬xæˆ–ç”Ÿæˆæ ·æœ¬G(z) 
2. ç»è¿‡å¤šå±‚å·ç§¯å±‚æå–ç‰¹å¾
3. è¾“å‡º:è¾“å…¥ä¸ºçœŸå®æ ·æœ¬çš„æ¦‚ç‡D(x)âˆˆ[0,1]  
4. å·ç§¯:æå–ç©ºé—´ç‰¹å¾,ä¿ç•™å½¢çŠ¶ä¿¡æ¯

#### 3.1.3 å¯¹æŠ—è®­ç»ƒ

1. å›ºå®šG,ä¼˜åŒ–Dä½¿Lossæœ€å¤§åŒ–:$max_D V(D,G) $
2. å›ºå®šD,ä¼˜åŒ–Gä½¿Lossæœ€å°åŒ–:$min_G V(D,G)$
3. äº¤æ›¿è®­ç»ƒDå’ŒG,ç›´åˆ°Nashå‡è¡¡

### 3.2 3D-GAN
#### 3.2.1 Volumetric Convolutional Networks

1. ä¸‰ç»´å·ç§¯:åœ¨ä¸‰ç»´ç©ºé—´æ»‘åŠ¨å·ç§¯æ ¸
2. ä¸‰ç»´è½¬ç½®å·ç§¯:ä¸‰ç»´ä¸Šé‡‡æ ·

#### 3.2.2 Volumetric GANs

1. ä½¿ç”¨3Då·ç§¯ & 3Dè½¬ç½®å·ç§¯,ç›´æ¥åœ¨ä½“ç´ ç½‘æ ¼ä¸Šæ“ä½œ
2. ç”Ÿæˆå™¨G:å™ªå£°zâ†’3Dä½“ç´ å¯¹è±¡
3. åˆ¤åˆ«å™¨D:3Dä½“ç´ å¯¹è±¡â†’çœŸ/å‡

#### 3.2.3 è®­ç»ƒè¿‡ç¨‹

1. é€šè¿‡3Då·ç§¯æå–3Då½¢çŠ¶ç‰¹å¾ 
2. å¯¹æŠ—è®­ç»ƒ,ä¼˜åŒ–Gå’ŒD  

### 3.3 AtlasNet
#### 3.3.1 å‚æ•°åŒ–æ›²é¢

1. æ›²é¢$S=\{xâˆˆR^3:x=Ï•(u,v),(u,v)âˆˆ[0,1]^2\}$
2. Ï•å°†2Då‚æ•°ç©ºé—´æ˜ å°„åˆ°3D
3. $Ï•(u,v)=\{(cosucosv, sinucosv, sinv):u,vâˆˆ[0,1]\}$

#### 3.3.2 AtlasNet Generators

1. å¤šä¸ªç‹¬ç«‹çš„MLPç½‘ç»œ,æ¯ä¸ªç½‘ç»œç”Ÿæˆä¸€ä¸ªæ›²é¢å—
2. æ›´çµæ´»åœ°æ‹Ÿåˆå¤æ‚3Då½¢çŠ¶
3. MLPæ˜ å°„:(u,v,z)â†’3Dç‚¹

#### 3.3.3 è®­ç»ƒæ–¹å¼

1. çœŸå®ç‚¹äº‘ä¸ç”Ÿæˆç‚¹äº‘ä¹‹é—´çš„Chamferè·ç¦»ä½œä¸ºé‡å»ºæŸå¤±  
2. è®­ç»ƒGæœ€å°åŒ–é‡å»ºæŸå¤±
3. å¯¹æŠ—è®­ç»ƒGå’ŒD

## 4. æ•°å­¦æ¨¡å‹ä¸å…¬å¼è¯¦è§£  

### 4.1 å¯¹æŠ—æŸå¤±
- ç”Ÿæˆå™¨Gè¯•å›¾æœ€å°åŒ–ç›®æ ‡å‡½æ•°:

$$min_G V(D,G)=ğ”¼_{z~p_z(z)}[log(1-D(G(z)))]$$

- åˆ¤åˆ«å™¨Dè¯•å›¾æœ€å¤§åŒ–ç›®æ ‡å‡½æ•°:

$$max_D V(D,G)=ğ”¼_{x~p_data(x)}[logD(x)]+ğ”¼_{z~p_z(z)}[log(1-D(G(z)))]$$

- æ•´ä¸ªå¯¹æŠ—ç½‘ç»œçš„ç›®æ ‡å‡½æ•°:

$$min_G max_D V(D,G)=ğ”¼_{x~p_data(x)}[logD(x)]+ğ”¼_{z~p_z(z)}[log(1-D(G(z)))]$$

### 4.2 Chamferè·ç¦»
- ç‚¹é›†Xå’ŒYçš„Chamferè·ç¦»:

$$d_{CD}(X,Y)=\frac{1}{|X|}\sum_{xâˆˆX} \min_{yâˆˆY}||x-y||_2^2+\frac{1}{|Y|}\sum_{yâˆˆY} \min_{xâˆˆX}||y-x||_2^2$$

- ç”¨äºè¡¡é‡ä¸¤ç»„ç‚¹äº‘çš„ç›¸ä¼¼ç¨‹åº¦,æ˜¯AtlasNetç­‰æ¨¡å‹å¸¸ç”¨çš„é‡å»ºæŸå¤±  
- è®¡ç®—æ•ˆç‡é«˜,é²æ£’æ€§å¥½

### 4.3 earth mover's distance (EMD)
- ä¹Ÿå« Wasserstein distance
- ä¸¤ä¸ªåˆ†å¸ƒÎ¼å’ŒÎ½ä¹‹é—´çš„EMD: 

$$W(\mu,\nu)=\inf_{Î³âˆˆÎ (\mu,\Î½)} E_{(x,y)~Î³}[||x-y||]$$

- å…¶ä¸­Î (Î¼,Î½)æ˜¯Î¼å’ŒÎ½çš„æ‰€æœ‰è”åˆåˆ†å¸ƒçš„é›†åˆ
- ç›´è§‚ç†è§£:å°†Î¼å˜æˆÎ½æ‰€éœ€çš„æœ€å°ä»£ä»·
- ç”Ÿæˆåˆ†å¸ƒä¸çœŸå®åˆ†å¸ƒçš„EMDè¶Šå°,ç”Ÿæˆè´¨é‡è¶Šå¥½

## 5. é¡¹ç›®å®è·µ:ä»£ç å®ä¾‹ä¸è¯¦è§£

### 5.1 ä½“ç´ åŒ–(Voxelization)

```python
import numpy as np

def voxelize(mesh, voxel_size):
    # ç½‘æ ¼é¡¶ç‚¹åæ ‡
    vertices = mesh.vertices
    # è®¡ç®—åŒ…å›´ç›’
    bbox_min = np.min(vertices, axis=0) 
    bbox_max = np.max(vertices, axis=0)
    # è®¡ç®—ä½“ç´ åˆ†è¾¨ç‡
    dim = np.ceil((bbox_max - bbox_min) / voxel_size)
    # è®¡ç®—æ¯ä¸ªé¡¶ç‚¹çš„ä½“ç´ ç´¢å¼•
    indices = np.floor((vertices - bbox_min) / voxel_size)
    # å°†é¡¶ç‚¹ä½“ç´ åŒ–
    voxels = np.zeros(dim, dtype=bool)
    voxels[indices[:, 0], indices[:, 1], indices[:, 2]] = True
    
    return voxels
```

- å°†ä¸‰è§’ç½‘æ ¼è½¬æ¢ä¸ºä½“ç´ ç½‘æ ¼
- `mesh`:è¾“å…¥çš„ä¸‰è§’ç½‘æ ¼  
- `voxel_size`:ä½“ç´ çš„è¾¹é•¿
- å…ˆè®¡ç®—ç½‘æ ¼çš„åŒ…å›´ç›’,å†æ ¹æ®åŒ…å›´ç›’å’Œåˆ†è¾¨ç‡å¾—åˆ°ä½“ç´ ç½‘æ ¼çš„å½¢çŠ¶
- éå†æ¯ä¸ªé¡¶ç‚¹,å°†å…¶å½’å…¥å¯¹åº”çš„ä½“ç´ å¹¶æ ‡è®°ä¸ºå æ®

### 5.2 3D-GANç”Ÿæˆå™¨

```python
class Generator(nn.Module):
    def __init__(self, z_dim, voxel_size, voxel_res):
        super(Generator, self).__init__()
        self.z_dim = z_dim
        self.voxel_size = voxel_size
        self.voxel_res = voxel_res
        
        self.fc = nn.Linear(z_dim, 512 * 2 * 2 * 2)
        
        self.deconv1 = nn.ConvTranspose3d(512, 256, 4, 2, 1)
        self.deconv2 = nn.ConvTranspose3d(256, 128, 4, 2, 1) 
        self.deconv3 = nn.ConvTranspose3d(128, 64, 4, 2, 1)
        self.deconv4 = nn.ConvTranspose3d(64, 1, 4, 2, 1)
        
        self.bn1 = nn.BatchNorm3d(256)
        self.bn2 = nn.BatchNorm3d(128)
        self.bn3 = nn.BatchNorm3d(64)
        
        self.relu = nn.ReLU()
        self.sigmoid = nn.Sigmoid()
        
    def forward(self, z):
        x = self.fc(z)
        x = x.view(-1, 512, 2, 2, 2)
        
        x = self.relu(self.bn1(self.deconv1(x)))
        x = self.relu(self.bn2(self.deconv2(x))) 
        x = self.relu(self.bn3(self.deconv3(x)))
        x = self.sigmoid(self.deconv4(x))
        
        return x
```
- è¾“å…¥:éšæœºå™ªå£°å‘é‡z
- è¾“å‡º:ç”Ÿæˆçš„ä½“ç´ ç½‘æ ¼
- å…¨è¿æ¥å±‚å°†zæ˜ å°„åˆ°512x2x2x2çš„feature map
- 4ä¸ªè½¬ç½®å·ç§¯å±‚,å°†feature mapæ”¾å¤§åˆ°64x64x64
- æ‰¹å½’ä¸€åŒ–å’ŒReLUæ¿€æ´»æé«˜è®­ç»ƒç¨³å®šæ€§
- Sigmoidè¾“å‡ºæ¯ä¸ªä½“ç´ è¢«å æ®çš„æ¦‚ç‡

### 5.3 AtlasNetç”Ÿæˆå™¨  

```python
class AtlasGenerator(nn.Module):
    def __init__(self, z_dim, num_points, num_patches):
        super(AtlasGenerator, self).__init__()
        self.z_dim = z_dim
        self.num_points = num_points
        self.num_patches = num_patches
        
        self.patch_size = num_points // num_patches
        
        self.mlp1 = nn.Sequential(
            nn.Linear(z_dim + 2, 128), 
            nn.ReLU(),
            nn.Linear(128, 128),
            nn.ReLU(),  
        )
        self.mlp2 = nn.Sequential(  
            nn.Linear(128, 256),
            nn.ReLU(),
            nn.Linear(256, 512),
            nn.ReLU(),
        )
        self.mlp3 = nn.Linear(512, 3)
    
    def forward(self, z):
        
        points_list = []
        for i in range(self.num_patches):
            u = torch.rand(z.size(0), 1) 
            v = torch.rand(z.size(0), 1)
            
            latent = torch.cat([u, v, z], dim=1)
            
            patch = self.mlp1(latent)
            patch = self.mlp2(patch)
            patch = self.mlp3(patch)
            
            points_list.append(patch)
        
        points = torch.stack(points_list, dim=1)
        points = points.view(z.size(0), self.num_points, 3)
        
        return points        
```
- è¾“å…¥:éšæœºå™ªå£°å‘é‡z
- è¾“å‡º:ç”Ÿæˆçš„ç‚¹äº‘
- å¤šä¸ªç‹¬ç«‹çš„MLPç½‘ç»œ,æ¯ä¸ªç½‘ç»œç”Ÿæˆä¸€ä¸ªå±€éƒ¨ç‚¹äº‘
- å°†(u,v,z)è¾“å…¥MLP,è¾“å‡ºå¯¹åº”çš„3Dç‚¹åæ ‡
- é‡‡æ ·u,vâˆˆ[0,1],å°†å…¶ä¸zæ‹¼æ¥ä½œä¸ºMLPçš„è¾“å…¥  
- å°†å„ä¸ªå±€éƒ¨ç‚¹äº‘æ‹¼æ¥ä¸ºå®Œæ•´çš„ç‚¹äº‘è¾“å‡º

## 6. å®é™…åº”ç”¨åœºæ™¯

### 6.1 è™šæ‹Ÿç°å®(VR)
- 3Dç‰©ä½“å’Œåœºæ™¯çš„è‡ªåŠ¨ç”Ÿæˆ
- ç¨‹åºåŒ–å†…å®¹åˆ›ä½œ,é™ä½äººå·¥æˆæœ¬
- æå‡VRåœºæ™¯çš„ä¸°å¯Œåº¦å’ŒçœŸå®æ„Ÿ